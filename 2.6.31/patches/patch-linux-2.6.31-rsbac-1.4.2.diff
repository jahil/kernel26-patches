diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/alpha/include/asm/unistd.h linux-2.6.31-rsbac-1.4.2/arch/alpha/include/asm/unistd.h
--- trunk/arch/alpha/include/asm/unistd.h	2009-09-10 18:15:41.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/alpha/include/asm/unistd.h	2009-09-10 18:18:19.000000000 +0200
@@ -331,7 +331,11 @@
 #define __NR_getdents64			377
 #define __NR_gettid			378
 #define __NR_readahead			379
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac                      380
+#else
 /* 380 is unused */
+#endif
 #define __NR_tkill			381
 #define __NR_setxattr			382
 #define __NR_lsetxattr			383
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/alpha/kernel/asm-offsets.c linux-2.6.31-rsbac-1.4.2/arch/alpha/kernel/asm-offsets.c
--- trunk/arch/alpha/kernel/asm-offsets.c	2009-09-10 18:15:41.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/alpha/kernel/asm-offsets.c	2009-09-10 18:18:18.000000000 +0200
@@ -35,6 +35,9 @@ void foo(void)
 	DEFINE(PT_PTRACED, PT_PTRACED);
 	DEFINE(CLONE_VM, CLONE_VM);
 	DEFINE(CLONE_UNTRACED, CLONE_UNTRACED);
+#ifdef CONFIG_RSBAC
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
+#endif
 	DEFINE(SIGCHLD, SIGCHLD);
 	BLANK();
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/alpha/kernel/entry.S linux-2.6.31-rsbac-1.4.2/arch/alpha/kernel/entry.S
--- trunk/arch/alpha/kernel/entry.S	2009-09-10 18:15:41.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/alpha/kernel/entry.S	2009-09-10 18:18:19.000000000 +0200
@@ -643,7 +643,11 @@ kernel_thread:
 	stq	$2, 152($sp)		/* HAE */
 
 	/* Shuffle FLAGS to the front; add CLONE_VM.  */
+#ifdef CONFIG_RSBAC
+	ldi$1, CLONE_VM|CLONE_UNTRACED | CLONE_KTHREAD;
+#else
 	ldi	$1, CLONE_VM|CLONE_UNTRACED
+#endif
 	or	$18, $1, $16
 	bsr	$26, sys_clone
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/alpha/kernel/ptrace.c linux-2.6.31-rsbac-1.4.2/arch/alpha/kernel/ptrace.c
--- trunk/arch/alpha/kernel/ptrace.c	2009-09-10 18:15:41.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/alpha/kernel/ptrace.c	2009-09-10 18:18:19.000000000 +0200
@@ -22,6 +22,8 @@
 
 #include "proto.h"
 
+#include <rsbac/hooks.h>
+
 #define DEBUG	DBG_MEM
 #undef DEBUG
 
@@ -264,6 +266,26 @@ long arch_ptrace(struct task_struct *chi
 	unsigned long tmp;
 	size_t copied;
 	long ret;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(child);
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
 
 	switch (request) {
 	/* When I and D space are separate, these will need to be fixed.  */
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/arm/include/asm/unistd.h linux-2.6.31-rsbac-1.4.2/arch/arm/include/asm/unistd.h
--- trunk/arch/arm/include/asm/unistd.h	2009-09-10 18:15:22.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/arm/include/asm/unistd.h	2009-09-10 18:18:06.000000000 +0200
@@ -248,7 +248,12 @@
 #define __NR_madvise			(__NR_SYSCALL_BASE+220)
 #define __NR_fcntl64			(__NR_SYSCALL_BASE+221)
 					/* 222 for tux */
-					/* 223 is unused */
+/* RSBAC - we use 223, the old sys_security */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac                      (__NR_SYSCALL_BASE+223)
+#else
+                                        /* 223 is unused */
+#endif
 #define __NR_gettid			(__NR_SYSCALL_BASE+224)
 #define __NR_readahead			(__NR_SYSCALL_BASE+225)
 #define __NR_setxattr			(__NR_SYSCALL_BASE+226)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/arm/kernel/calls.S linux-2.6.31-rsbac-1.4.2/arch/arm/kernel/calls.S
--- trunk/arch/arm/kernel/calls.S	2009-09-10 18:15:24.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/arm/kernel/calls.S	2009-09-10 18:18:08.000000000 +0200
@@ -232,7 +232,11 @@
 /* 220 */	CALL(sys_madvise)
 		CALL(ABI(sys_fcntl64, sys_oabi_fcntl64))
 		CALL(sys_ni_syscall) /* TUX */
+#ifdef CONFIG_RSBAC
+		CALL(sys_rsbac)
+#else
 		CALL(sys_ni_syscall)
+#endif
 		CALL(sys_gettid)
 /* 225 */	CALL(ABI(sys_readahead, sys_oabi_readahead))
 		CALL(sys_setxattr)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/arm/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/arm/kernel/process.c
--- trunk/arch/arm/kernel/process.c	2009-09-10 18:15:24.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/arm/kernel/process.c	2009-09-10 18:18:08.000000000 +0200
@@ -37,6 +37,10 @@
 #include <asm/stacktrace.h>
 #include <asm/mach/time.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 static const char *processor_modes[] = {
   "USER_26", "FIQ_26" , "IRQ_26" , "SVC_26" , "UK4_26" , "UK5_26" , "UK6_26" , "UK7_26" ,
   "UK8_26" , "UK9_26" , "UK10_26", "UK11_26", "UK12_26", "UK13_26", "UK14_26", "UK15_26",
@@ -382,6 +386,10 @@ pid_t kernel_thread(int (*fn)(void *), v
 {
 	struct pt_regs regs;
 
+#ifdef CONFIG_RSBAC
+	int rsbac_retval;
+#endif
+
 	memset(&regs, 0, sizeof(regs));
 
 	regs.ARM_r1 = (unsigned long)arg;
@@ -390,7 +398,14 @@ pid_t kernel_thread(int (*fn)(void *), v
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
 	regs.ARM_cpsr = SVC_MODE | PSR_ENDSTATE;
 
+#ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if (rsbac_retval > 0)
+		rsbac_kthread_notify(find_pid_ns(rsbac_retval, &init_pid_ns));
+	return rsbac_retval;
+#else
 	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/avr32/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/avr32/kernel/process.c
--- trunk/arch/avr32/kernel/process.c	2009-09-10 18:15:44.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/avr32/kernel/process.c	2009-09-10 18:18:21.000000000 +0200
@@ -22,6 +22,10 @@
 
 #include <mach/pm.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
@@ -100,8 +104,13 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.pc = (unsigned long)kernel_thread_helper;
 	regs.sr = MODE_SUPERVISOR;
 
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED,
+#ifdef CONFIG_RSBAC
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
 		       0, &regs, 0, NULL, NULL);
+#else
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED,
+                       0, &regs, 0, NULL, NULL);
+#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/blackfin/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/blackfin/kernel/process.c
--- trunk/arch/blackfin/kernel/process.c	2009-09-10 18:15:58.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/blackfin/kernel/process.c	2009-09-10 18:18:40.000000000 +0200
@@ -41,6 +41,10 @@
 #include <asm/fixed_code.h>
 #include <asm/mem_map.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 asmlinkage void ret_from_fork(void);
 
 /* Points to the SDRAM backup memory for the stack that is currently in
@@ -155,8 +159,13 @@ pid_t kernel_thread(int (*fn) (void *), 
 	   mode.  */
 	regs.ipend = 0x8002;
 	__asm__ __volatile__("%0 = syscfg;":"=da"(regs.syscfg):);
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL,
+#ifdef CONFIG_RSBAC
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL,
 		       NULL);
+#else
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL,
+                       NULL);
+#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/cris/arch-v10/kernel/entry.S linux-2.6.31-rsbac-1.4.2/arch/cris/arch-v10/kernel/entry.S
--- trunk/arch/cris/arch-v10/kernel/entry.S	2009-09-10 18:15:46.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/cris/arch-v10/kernel/entry.S	2009-09-10 18:18:25.000000000 +0200
@@ -825,7 +825,11 @@ sys_call_table:	
 	.long sys_getdents64	/* 220 */
 	.long sys_fcntl64
 	.long sys_ni_syscall	/* reserved for TUX */
-	.long sys_ni_syscall
+#ifdef CONFIG_RSBAC
+	.long sys_rsbac 	/*	reserved for sys_security */
+#else
+ 	.long sys_ni_syscall 	/*	reserved for sys_security */
+#endif
 	.long sys_gettid
 	.long sys_readahead	/* 225 */
 	.long sys_setxattr
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/cris/arch-v10/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/cris/arch-v10/kernel/process.c
--- trunk/arch/cris/arch-v10/kernel/process.c	2009-09-10 18:15:46.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/cris/arch-v10/kernel/process.c	2009-09-10 18:18:25.000000000 +0200
@@ -17,6 +17,10 @@
 #include <arch/svinto.h>
 #include <linux/init.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #ifdef CONFIG_ETRAX_GPIO
 void etrax_gpio_wake_up_check(void); /* drivers/gpio.c */
 #endif
@@ -93,6 +97,10 @@ int kernel_thread(int (*fn)(void *), voi
 {
 	struct pt_regs regs;
 
+#ifdef CONFIG_RSBAC
+	int rsbac_retval;
+#endif
+
 	memset(&regs, 0, sizeof(regs));
 
         /* Don't use r10 since that is set to 0 in copy_thread */
@@ -102,7 +110,14 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.dccr = 1 << I_DCCR_BITNR;
 
 	/* Ok, create the new process.. */
-        return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if (rsbac_retval > 0)
+		rsbac_kthread_notify(find_pid_ns(rsbac_retval, &init_pid_ns));
+	return rsbac_retval;
+#else
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#endif
 }
 
 /* setup the child's kernel stack with a pt_regs and switch_stack on it.
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/cris/arch-v32/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/cris/arch-v32/kernel/process.c
--- trunk/arch/cris/arch-v32/kernel/process.c	2009-09-10 18:15:47.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/cris/arch-v32/kernel/process.c	2009-09-10 18:18:26.000000000 +0200
@@ -116,7 +116,11 @@ kernel_thread(int (*fn)(void *), void * 
 	regs.ccs = 1 << (I_CCS_BITNR + CCS_SHIFT);
 
 	/* Create the new process. */
-        return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#ifdef CONFIG_RSBAC
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+#else
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#endif
 }
 
 /*
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/frv/kernel/kernel_thread.S linux-2.6.31-rsbac-1.4.2/arch/frv/kernel/kernel_thread.S
--- trunk/arch/frv/kernel/kernel_thread.S	2009-09-10 18:15:44.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/frv/kernel/kernel_thread.S	2009-09-10 18:18:22.000000000 +0200
@@ -13,6 +13,10 @@
 #include <asm/unistd.h>
 
 #define CLONE_VM	0x00000100	/* set if VM shared between processes */
+#ifdef CONFIG_RSBAC
+#define CLONE_KTHREAD   0x100000000      /* kernel thread */
+#define CLONE_KT        (CLONE_VM | CLONE_KTHREAD) /* kernel thread flags */
+#endif
 #define	KERN_ERR	"<3>"
 
 	.section .rodata
@@ -37,7 +41,11 @@ kernel_thread:
 
 	# start by forking the current process, but with shared VM
 	setlos.p	#__NR_clone,gr7		; syscall number
+#ifdef CONFIG_RSBAC
+	ori 		gr10,#CLONE_KT,gr8 	; first syscall arg	[clone_flags]
+#else
 	ori		gr10,#CLONE_VM,gr8	; first syscall arg	[clone_flags]
+#endif
 	sethi.p		#0xe4e4,gr9		; second syscall arg	[newsp]
 	setlo		#0xe4e4,gr9
 	setlos.p	#0,gr10			; third syscall arg	[parent_tidptr]
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/h8300/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/h8300/kernel/process.c
--- trunk/arch/h8300/kernel/process.c	2009-09-10 18:15:48.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/h8300/kernel/process.c	2009-09-10 18:18:26.000000000 +0200
@@ -44,6 +44,10 @@
 #include <asm/setup.h>
 #include <asm/pgtable.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 void (*pm_power_off)(void) = NULL;
 EXPORT_SYMBOL(pm_power_off);
 
@@ -134,7 +138,11 @@ int kernel_thread(int (*fn)(void *), voi
 
 	fs = get_fs();
 	set_fs (KERNEL_DS);
+#ifdef CONFIG_RSBAC
+	clone_arg = flags | CLONE_VM | CLONE_KTHREAD;
+#else
 	clone_arg = flags | CLONE_VM;
+#endif
 	__asm__("mov.l sp,er3\n\t"
 		"sub.l er2,er2\n\t"
 		"mov.l %2,er1\n\t"
@@ -153,6 +161,12 @@ int kernel_thread(int (*fn)(void *), voi
 		:"i"(__NR_clone),"g"(clone_arg),"g"(fn),"g"(arg),"i"(__NR_exit)
 		:"er0","er1","er2","er3");
 	set_fs (fs);
+
+#ifdef CONFIG_RSBAC
+	if (retval > 0)
+		rsbac_kthread_notify(find_pid_ns(retval, &init_pid_ns));
+#endif
+
 	return retval;
 }
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/ia64/include/asm/unistd.h linux-2.6.31-rsbac-1.4.2/arch/ia64/include/asm/unistd.h
--- trunk/arch/ia64/include/asm/unistd.h	2009-09-10 18:15:50.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/ia64/include/asm/unistd.h	2009-09-10 18:18:30.000000000 +0200
@@ -312,10 +312,18 @@
 #define __NR_pwritev			1320
 #define __NR_rt_tgsigqueueinfo		1321
 
-#ifdef __KERNEL__
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac                      1319
+#endif
 
 
+#ifdef __KERNEL__
+
+#ifdef CONFIG_RSBAC
+#define NR_syscalls			296
+#else
 #define NR_syscalls			298 /* length of syscall table */
+#endif
 
 /*
  * The following defines stop scripts/checksyscalls.sh from complaining about
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/ia64/kernel/asm-offsets.c linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/asm-offsets.c
--- trunk/arch/ia64/kernel/asm-offsets.c	2009-09-10 18:15:50.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/asm-offsets.c	2009-09-10 18:18:29.000000000 +0200
@@ -205,6 +205,9 @@ void foo(void)
     /* for assembly files which can't include sched.h: */
 	DEFINE(IA64_CLONE_VFORK, CLONE_VFORK);
 	DEFINE(IA64_CLONE_VM, CLONE_VM);
+#ifdef CONFIG_RSBAC
+	DEFINE(IA64_CLONE_KTHREAD, CLONE_KTHREAD);
+#endif
 
 	BLANK();
 	DEFINE(IA64_CPUINFO_NSEC_PER_CYC_OFFSET,
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/ia64/kernel/entry.S linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/entry.S
--- trunk/arch/ia64/kernel/entry.S	2009-09-10 18:15:50.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/entry.S	2009-09-10 18:18:30.000000000 +0200
@@ -1797,6 +1797,9 @@ sys_call_table:
 	data8 sys_timerfd_create		// 1310
 	data8 sys_timerfd_settime
 	data8 sys_timerfd_gettime
+#ifdef CONFIG_RSBAC
+	data8 sys_rsbac
+#endif
 	data8 sys_signalfd4
 	data8 sys_eventfd2
 	data8 sys_epoll_create1			// 1315
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/ia64/kernel/perfmon.c linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/perfmon.c
--- trunk/arch/ia64/kernel/perfmon.c	2009-09-10 18:15:50.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/perfmon.c	2009-09-10 18:18:29.000000000 +0200
@@ -52,6 +52,10 @@
 #include <asm/uaccess.h>
 #include <asm/delay.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #ifdef CONFIG_PERFMON
 /*
  * perfmon context state
@@ -1559,8 +1563,12 @@ init_pfm_fs(void)
 		err = PTR_ERR(pfmfs_mnt);
 		if (IS_ERR(pfmfs_mnt))
 			unregister_filesystem(&pfm_fs_type);
-		else
+		else {
 			err = 0;
+#ifdef CONFIG_RSBAC
+			rsbac_mount(pfmfs_mnt);
+#endif
+		}
 	}
 	return err;
 }
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/ia64/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/process.c
--- trunk/arch/ia64/kernel/process.c	2009-09-10 18:15:50.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/process.c	2009-09-10 18:18:29.000000000 +0200
@@ -50,6 +50,10 @@
 # include <asm/perfmon.h>
 #endif
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #include "sigframe.h"
 
 void (*ia64_mark_idle)(int);
@@ -676,6 +680,10 @@ kernel_thread (int (*fn)(void *), void *
 		struct pt_regs pt;
 	} regs;
 
+#ifdef CONFIG_RSBAC
+	int rsbac_retval;
+#endif
+
 	memset(&regs, 0, sizeof(regs));
 	regs.pt.cr_iip = helper_fptr[0];	/* set entry point (IP) */
 	regs.pt.r1 = helper_fptr[1];		/* set GP */
@@ -687,7 +695,14 @@ kernel_thread (int (*fn)(void *), void *
 	regs.sw.ar_fpsr = regs.pt.ar_fpsr = ia64_getreg(_IA64_REG_AR_FPSR);
 	regs.sw.ar_bspstore = (unsigned long) current + IA64_RBS_OFFSET;
 	regs.sw.pr = (1 << PRED_KERNEL_STACK);
+#ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs.pt, 0, NULL, NULL);
+	if (rsbac_retval > 0)
+		rsbac_kthread_notify(find_pid_ns(rsbac_retval, &init_pid_ns));
+	return rsbac_retval;
+#else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
+#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/ia64/kernel/ptrace.c linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/ptrace.c
--- trunk/arch/ia64/kernel/ptrace.c	2009-09-10 18:15:50.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/ia64/kernel/ptrace.c	2009-09-10 18:18:30.000000000 +0200
@@ -36,6 +36,8 @@
 
 #include "entry.h"
 
+#include <rsbac/hooks.h>
+
 /*
  * Bits in the PSR that we allow ptrace() to change:
  *	be, up, ac, mfl, mfh (the user mask; five bits total)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/m32r/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/m32r/kernel/process.c
--- trunk/arch/m32r/kernel/process.c	2009-09-10 18:15:33.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/m32r/kernel/process.c	2009-09-10 18:18:14.000000000 +0200
@@ -194,7 +194,11 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.psw = M32R_PSW_BIE;
 
 	/* Ok, create the new process. */
+#ifdef CONFIG_RSBAC
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL,
+#else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL,
+#endif
 		NULL);
 }
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/m32r/kernel/ptrace.c linux-2.6.31-rsbac-1.4.2/arch/m32r/kernel/ptrace.c
--- trunk/arch/m32r/kernel/ptrace.c	2009-09-10 18:15:33.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/m32r/kernel/ptrace.c	2009-09-10 18:18:14.000000000 +0200
@@ -33,6 +33,8 @@
 #include <asm/processor.h>
 #include <asm/mmu_context.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * This routine will get a word off of the process kernel stack.
  */
@@ -596,6 +598,23 @@ long
 arch_ptrace(struct task_struct *child, long request, long addr, long data)
 {
 	int ret;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(child);
+		rsbac_attribute_value.trace_request = request;
+		if (!rsbac_adf_request(R_TRACE,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_trace_request,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+#endif
 
 	switch (request) {
 	/*
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/m68k/include/asm/unistd.h linux-2.6.31-rsbac-1.4.2/arch/m68k/include/asm/unistd.h
--- trunk/arch/m68k/include/asm/unistd.h	2009-09-10 18:15:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/m68k/include/asm/unistd.h	2009-09-10 18:18:20.000000000 +0200
@@ -336,10 +336,17 @@
 #define __NR_pwritev		330
 #define __NR_rt_tgsigqueueinfo	331
 #define __NR_perf_counter_open	332
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac              333
+#endif
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_RSBAC
+#define NR_syscalls		334
+#else
 #define NR_syscalls		333
+#endif
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/m68k/kernel/entry.S linux-2.6.31-rsbac-1.4.2/arch/m68k/kernel/entry.S
--- trunk/arch/m68k/kernel/entry.S	2009-09-10 18:15:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/m68k/kernel/entry.S	2009-09-10 18:18:19.000000000 +0200
@@ -758,3 +758,10 @@ sys_call_table:
 	.long sys_rt_tgsigqueueinfo
 	.long sys_perf_counter_open
 
+#ifdef CONFIG_RSBAC
+	/* we use 300, until sys_security gets defined here */
+	.rept 299-281
+		.long sys_ni_syscall
+	.endr
+	.long sys_rsbac
+#endif
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/m68k/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/m68k/kernel/process.c
--- trunk/arch/m68k/kernel/process.c	2009-09-10 18:15:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/m68k/kernel/process.c	2009-09-10 18:18:19.000000000 +0200
@@ -34,6 +34,10 @@
 #include <asm/setup.h>
 #include <asm/pgtable.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * Initial task/thread structure. Make this a per-architecture thing,
  * because different architectures tend to have different
@@ -153,7 +157,11 @@ int kernel_thread(int (*fn)(void *), voi
 
 	{
 	register long retval __asm__ ("d0");
+#ifdef CONFIG_RSBAC
+	register long clone_arg __asm__ ("d1") = flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD;
+#else
 	register long clone_arg __asm__ ("d1") = flags | CLONE_VM | CLONE_UNTRACED;
+#endif
 
 	retval = __NR_clone;
 	__asm__ __volatile__
@@ -179,6 +187,12 @@ int kernel_thread(int (*fn)(void *), voi
 	}
 
 	set_fs (fs);
+
+#ifdef CONFIG_RSBAC
+	if (pid > 0)
+		rsbac_kthread_notify(find_pid_ns(pid, &init_pid_ns));
+#endif
+
 	return pid;
 }
 EXPORT_SYMBOL(kernel_thread);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/m68knommu/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/m68knommu/kernel/process.c
--- trunk/arch/m68knommu/kernel/process.c	2009-09-10 18:15:48.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/m68knommu/kernel/process.c	2009-09-10 18:18:26.000000000 +0200
@@ -36,6 +36,10 @@
 #include <asm/setup.h>
 #include <asm/pgtable.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 asmlinkage void ret_from_fork(void);
 
 /*
@@ -122,7 +126,11 @@ void show_regs(struct pt_regs * regs)
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
 	int retval;
+#ifdef CONFIG_RSBAC
+	long clone_arg = flags | CLONE_VM | CLONE_KTHREAD;
+#else
 	long clone_arg = flags | CLONE_VM;
+#endif
 	mm_segment_t fs;
 
 	fs = get_fs();
@@ -150,6 +158,12 @@ int kernel_thread(int (*fn)(void *), voi
 		: "cc", "%d0", "%d1", "%d2");
 
 	set_fs(fs);
+
+#ifdef CONFIG_RSBAC
+	if (retval > 0)
+		rsbac_kthread_notify(find_pid_ns(retval, &init_pid_ns));
+#endif
+
 	return retval;
 }
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/mips/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/mips/kernel/process.c
--- trunk/arch/mips/kernel/process.c	2009-09-10 18:15:51.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/mips/kernel/process.c	2009-09-10 18:18:31.000000000 +0200
@@ -43,6 +43,10 @@
 #include <asm/inst.h>
 #include <asm/stacktrace.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * The idle thread. There's no useful work to be done, so just try to conserve
  * power and have a low exit latency (ie sit in a loop waiting for somebody to
@@ -231,6 +235,7 @@ static void __noreturn kernel_thread_hel
 long kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
 	struct pt_regs regs;
+	int retval;
 
 	memset(&regs, 0, sizeof(regs));
 
@@ -246,7 +251,14 @@ long kernel_thread(int (*fn)(void *), vo
 #endif
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#ifdef CONFIG_RSBAC
+	retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if (retval > 0)
+		rsbac_kthread_notify(find_pid_ns(retval, &init_pid_ns));
+#else
+	retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#endif
+        return retval;
 }
 
 /*
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/mips/kernel/scall32-o32.S linux-2.6.31-rsbac-1.4.2/arch/mips/kernel/scall32-o32.S
--- trunk/arch/mips/kernel/scall32-o32.S	2009-09-10 18:15:52.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/mips/kernel/scall32-o32.S	2009-09-10 18:18:31.000000000 +0200
@@ -530,7 +530,11 @@ einval:	li	v0, -ENOSYS
 	sys	sys_madvise		3
 	sys	sys_getdents64		3
 	sys	sys_fcntl64		3	/* 4220 */
+#ifdef CONFIG_RSBAC
+	sys	sys_rsbac		2	/* Security */
+#else
 	sys	sys_ni_syscall		0
+#endif
 	sys	sys_gettid		0
 	sys	sys_readahead		5
 	sys	sys_setxattr		5
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/mips/kernel/scall64-64.S linux-2.6.31-rsbac-1.4.2/arch/mips/kernel/scall64-64.S
--- trunk/arch/mips/kernel/scall64-64.S	2009-09-10 18:15:51.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/mips/kernel/scall64-64.S	2009-09-10 18:18:31.000000000 +0200
@@ -375,7 +375,11 @@ sys_call_table:
 	PTR	sys_ni_syscall			/* res. for getpmsg */
 	PTR	sys_ni_syscall			/* 5175  for putpmsg */
 	PTR	sys_ni_syscall			/* res. for afs_syscall */
+#ifdef CONFIG_RSBAC
+	PTR	sys_rsbac			/* Security */
+#else
 	PTR	sys_ni_syscall			/* res. for security */
+#endif
 	PTR	sys_gettid
 	PTR	sys_readahead
 	PTR	sys_setxattr			/* 5180 */
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/mips/kernel/scall64-o32.S linux-2.6.31-rsbac-1.4.2/arch/mips/kernel/scall64-o32.S
--- trunk/arch/mips/kernel/scall64-o32.S	2009-09-10 18:15:51.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/mips/kernel/scall64-o32.S	2009-09-10 18:18:31.000000000 +0200
@@ -424,7 +424,11 @@ sys_call_table:
 	PTR	sys_madvise
 	PTR	sys_getdents64
 	PTR	compat_sys_fcntl64		/* 4220 */
+#ifdef CONFIG_RSBAC
+	PTR	sys_rsbac			/* Security */
+#else
 	PTR	sys_ni_syscall
+#endif
 	PTR	sys_gettid
 	PTR	sys32_readahead
 	PTR	sys_setxattr
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/mn10300/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/mn10300/kernel/process.c
--- trunk/arch/mn10300/kernel/process.c	2009-09-10 18:15:46.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/mn10300/kernel/process.c	2009-09-10 18:18:24.000000000 +0200
@@ -37,6 +37,10 @@
 #include <asm/gdb-stub.h>
 #include "internal.h"
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * power management idle function, if any..
  */
@@ -150,8 +154,13 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.epsw |= EPSW_IE | EPSW_IM_7;
 
 	/* Ok, create the new process.. */
+#ifdef CONFIG_RSBAC
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0,
+                       NULL, NULL);
+#else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0,
 		       NULL, NULL);
+#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/parisc/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/parisc/kernel/process.c
--- trunk/arch/parisc/kernel/process.c	2009-09-10 18:15:32.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/parisc/kernel/process.c	2009-09-10 18:18:13.000000000 +0200
@@ -56,6 +56,10 @@
 #include <asm/unwind.h>
 #include <asm/sections.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * The idle thread. There's no useful work to be
  * done, so just try to conserve power and have a
@@ -169,13 +173,24 @@ EXPORT_SYMBOL(pm_power_off);
 extern pid_t __kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
 pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
+#ifdef CONFIG_RSBAC
+	pid_t rsbac_retval;
+#endif
 
 	/*
 	 * FIXME: Once we are sure we don't need any debug here,
 	 *	  kernel_thread can become a #define.
 	 */
 
+	/* Ok, create the new process.. */
+#ifdef CONFIG_RSBAC
+	rsbac_retval = __kernel_thread(fn, arg, flags | CLONE_KTHREAD);
+	if (rsbac_retval > 0)
+		rsbac_kthread_notify(find_pid_ns(rsbac_retval, &init_pid_ns));
+	return rsbac_retval;
+#else
 	return __kernel_thread(fn, arg, flags);
+#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/parisc/kernel/syscall_table.S linux-2.6.31-rsbac-1.4.2/arch/parisc/kernel/syscall_table.S
--- trunk/arch/parisc/kernel/syscall_table.S	2009-09-10 18:15:32.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/parisc/kernel/syscall_table.S	2009-09-10 18:18:13.000000000 +0200
@@ -407,6 +407,9 @@
 	ENTRY_SAME(timerfd_create)
 	ENTRY_COMP(timerfd_settime)
 	ENTRY_COMP(timerfd_gettime)
+#ifdef CONFIG_RSBAC
+	ENTRY_SAME(rsbac)
+#endif
 	ENTRY_COMP(signalfd4)
 	ENTRY_SAME(eventfd2)		/* 310 */
 	ENTRY_SAME(epoll_create1)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/powerpc/include/asm/systbl.h linux-2.6.31-rsbac-1.4.2/arch/powerpc/include/asm/systbl.h
--- trunk/arch/powerpc/include/asm/systbl.h	2009-09-10 18:15:17.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/powerpc/include/asm/systbl.h	2009-09-10 18:18:00.000000000 +0200
@@ -227,7 +227,11 @@ SYSCALL_SPU(fremovexattr)
 COMPAT_SYS_SPU(futex)
 COMPAT_SYS_SPU(sched_setaffinity)
 COMPAT_SYS_SPU(sched_getaffinity)
+#ifdef CONFIG_RSBAC
+SYSCALL(rsbac)
+#else
 SYSCALL(ni_syscall)
+#endif
 SYSCALL(ni_syscall)
 SYS32ONLY(sendfile64)
 COMPAT_SYS_SPU(io_setup)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/powerpc/include/asm/unistd.h linux-2.6.31-rsbac-1.4.2/arch/powerpc/include/asm/unistd.h
--- trunk/arch/powerpc/include/asm/unistd.h	2009-09-10 18:15:17.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/powerpc/include/asm/unistd.h	2009-09-10 18:17:59.000000000 +0200
@@ -238,6 +238,10 @@
 #define __NR_futex		221
 #define __NR_sched_setaffinity	222
 #define __NR_sched_getaffinity	223
+/* RSBAC - we use 224, the old sys_security */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac              224
+#endif
 /* 224 currently unused */
 #define __NR_tuxcall		225
 #ifndef __powerpc64__
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/powerpc/kernel/asm-offsets.c linux-2.6.31-rsbac-1.4.2/arch/powerpc/kernel/asm-offsets.c
--- trunk/arch/powerpc/kernel/asm-offsets.c	2009-09-10 18:15:15.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/powerpc/kernel/asm-offsets.c	2009-09-10 18:17:54.000000000 +0200
@@ -281,6 +281,9 @@ int main(void)
 
 	DEFINE(CLONE_VM, CLONE_VM);
 	DEFINE(CLONE_UNTRACED, CLONE_UNTRACED);
+#ifdef CONFIG_RSBAC
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
+#endif
 
 #ifndef CONFIG_PPC64
 	DEFINE(MM_PGD, offsetof(struct mm_struct, pgd));
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/powerpc/kernel/misc_32.S linux-2.6.31-rsbac-1.4.2/arch/powerpc/kernel/misc_32.S
--- trunk/arch/powerpc/kernel/misc_32.S	2009-09-10 18:15:15.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/powerpc/kernel/misc_32.S	2009-09-10 18:17:54.000000000 +0200
@@ -31,6 +31,9 @@
 #include <asm/kexec.h>
 #include <asm/bug.h>
 
+#ifdef CONFIG_RSBAC
+#define CLONE_KTHREAD           0x20000000      /* clone a kernel thread */
+#endif
 	.text
 
 #ifdef CONFIG_IRQSTACKS
@@ -679,7 +682,11 @@ _GLOBAL(kernel_thread)
 	mr	r30,r3		/* function */
 	mr	r31,r4		/* argument */
 	ori	r3,r5,CLONE_VM	/* flags */
+#ifdef CONFIG_RSBAC
+	oris	r3,r3,(CLONE_UNTRACED|CLONE_KTHREAD)>>16
+#else
 	oris	r3,r3,CLONE_UNTRACED>>16
+#endif
 	li	r4,0		/* new sp (unused) */
 	li	r0,__NR_clone
 	sc
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/powerpc/kernel/misc_64.S linux-2.6.31-rsbac-1.4.2/arch/powerpc/kernel/misc_64.S
--- trunk/arch/powerpc/kernel/misc_64.S	2009-09-10 18:15:15.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/powerpc/kernel/misc_64.S	2009-09-10 18:17:54.000000000 +0200
@@ -25,6 +25,10 @@
 #include <asm/cputable.h>
 #include <asm/thread_info.h>
 
+#ifdef CONFIG_RSBAC
+#define CLONE_KTHREAD           0x20000000      /* clone a kernel thread */
+#endif
+
 	.text
 
 #ifdef CONFIG_IRQSTACKS
@@ -422,7 +426,11 @@ _GLOBAL(kernel_thread)
 	mr	r29,r3
 	mr	r30,r4
 	ori	r3,r5,CLONE_VM	/* flags */
+#ifdef CONFIG_RSBAC
+	oris    r3,r3,(CLONE_UNTRACED|CLONE_KTHREAD)>>16
+#else
 	oris	r3,r3,(CLONE_UNTRACED>>16)
+#endif
 	li	r4,0		/* new sp (unused) */
 	li	r0,__NR_clone
 	sc
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/powerpc/kernel/sys_ppc32.c linux-2.6.31-rsbac-1.4.2/arch/powerpc/kernel/sys_ppc32.c
--- trunk/arch/powerpc/kernel/sys_ppc32.c	2009-09-10 18:15:15.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/powerpc/kernel/sys_ppc32.c	2009-09-10 18:17:54.000000000 +0200
@@ -52,7 +52,6 @@
 #include <asm/ppc-pci.h>
 #include <asm/syscalls.h>
 
-
 asmlinkage long ppc32_select(u32 n, compat_ulong_t __user *inp,
 		compat_ulong_t __user *outp, compat_ulong_t __user *exp,
 		compat_uptr_t tvp_x)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/s390/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/s390/kernel/process.c
--- trunk/arch/s390/kernel/process.c	2009-09-10 18:15:45.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/s390/kernel/process.c	2009-09-10 18:18:23.000000000 +0200
@@ -43,6 +43,10 @@
 #include <asm/nmi.h>
 #include "entry.h"
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 asmlinkage void ret_from_fork(void) asm ("ret_from_fork");
 
 /*
@@ -130,6 +134,10 @@ int kernel_thread(int (*fn)(void *), voi
 {
 	struct pt_regs regs;
 
+#ifdef CONFIG_RSBAC
+	int rsbac_retval;
+#endif
+
 	memset(&regs, 0, sizeof(regs));
 	regs.psw.mask = psw_kernel_bits | PSW_MASK_IO | PSW_MASK_EXT;
 	regs.psw.addr = (unsigned long) kernel_thread_starter | PSW_ADDR_AMODE;
@@ -139,8 +147,15 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.orig_gpr2 = -1;
 
 	/* Ok, create the new process.. */
+#ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if (rsbac_retval > 0)
+		rsbac_kthread_notify(find_pid_ns(rsbac_retval, &init_pid_ns));
+	return rsbac_retval;
+#else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED,
-		       0, &regs, 0, NULL, NULL);
+			0, &regs, 0, NULL, NULL);
+#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/s390/kernel/ptrace.c linux-2.6.31-rsbac-1.4.2/arch/s390/kernel/ptrace.c
--- trunk/arch/s390/kernel/ptrace.c	2009-09-10 18:15:45.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/s390/kernel/ptrace.c	2009-09-10 18:18:23.000000000 +0200
@@ -51,6 +51,8 @@
 #include "compat_ptrace.h"
 #endif
 
+#include <rsbac/hooks.h>
+
 enum s390_regset {
 	REGSET_GENERAL,
 	REGSET_FP,
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sh/include/asm/unistd_32.h linux-2.6.31-rsbac-1.4.2/arch/sh/include/asm/unistd_32.h
--- trunk/arch/sh/include/asm/unistd_32.h	2009-09-10 18:16:00.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sh/include/asm/unistd_32.h	2009-09-10 18:18:43.000000000 +0200
@@ -231,7 +231,11 @@
 #define __NR_madvise		219
 #define __NR_getdents64		220
 #define __NR_fcntl64		221
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac              223
+#else
 /* 223 is unused */
+#endif
 #define __NR_gettid		224
 #define __NR_readahead		225
 #define __NR_setxattr		226
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sh/include/asm/unistd_64.h linux-2.6.31-rsbac-1.4.2/arch/sh/include/asm/unistd_64.h
--- trunk/arch/sh/include/asm/unistd_64.h	2009-09-10 18:16:00.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sh/include/asm/unistd_64.h	2009-09-10 18:18:42.000000000 +0200
@@ -271,7 +271,11 @@
 
 #define __NR_getdents64		248
 #define __NR_fcntl64		249
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac              223
+#else
 /* 223 is unused */
+#endif
 #define __NR_gettid		252
 #define __NR_readahead		253
 #define __NR_setxattr		254
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sh/kernel/process_32.c linux-2.6.31-rsbac-1.4.2/arch/sh/kernel/process_32.c
--- trunk/arch/sh/kernel/process_32.c	2009-09-10 18:16:00.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sh/kernel/process_32.c	2009-09-10 18:18:42.000000000 +0200
@@ -32,6 +32,10 @@
 #include <asm/fpu.h>
 #include <asm/syscalls.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 int ubc_usercnt = 0;
 
 void machine_restart(char * __unused)
@@ -116,10 +120,18 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.sr = (1 << 30);
 
 	/* Ok, create the new process.. */
+#ifdef CONFIG_RSBAC
+	pid = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+			0, &regs, 0, NULL, NULL);
+	if (pid > 0)
+		rsbac_kthread_notify(find_pid_ns(pid, &init_pid_ns));
+#else
 	pid = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0,
 		      &regs, 0, NULL, NULL);
+#endif
 
 	return pid;
+#endif
 }
 
 /*
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sh/kernel/process_64.c linux-2.6.31-rsbac-1.4.2/arch/sh/kernel/process_64.c
--- trunk/arch/sh/kernel/process_64.c	2009-09-10 18:16:00.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sh/kernel/process_64.c	2009-09-10 18:18:42.000000000 +0200
@@ -30,6 +30,8 @@
 #include <asm/mmu_context.h>
 #include <asm/fpu.h>
 
+
+
 struct task_struct *last_task_used_math = NULL;
 
 void machine_restart(char * __unused)
@@ -332,8 +334,12 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.sr = (1 << 30);
 
 	/* Ok, create the new process.. */
+#ifdef CONFIG_RSBAC
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | KERNEL_THREAD, 0,
+#else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0,
 		      &regs, 0, NULL, NULL);
+#endif
 }
 
 /*
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sh/kernel/syscalls_32.S linux-2.6.31-rsbac-1.4.2/arch/sh/kernel/syscalls_32.S
--- trunk/arch/sh/kernel/syscalls_32.S	2009-09-10 18:16:00.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sh/kernel/syscalls_32.S	2009-09-10 18:18:42.000000000 +0200
@@ -239,7 +239,11 @@ ENTRY(sys_call_table)
 	.long sys_getdents64	/* 220 */
 	.long sys_fcntl64
 	.long sys_ni_syscall	/* reserved for TUX */
+#ifdef CONFIG_RSBAC
+        .long sys_rsbac
+#else
 	.long sys_ni_syscall	/* Reserved for Security */
+#endif
 	.long sys_gettid
 	.long sys_readahead	/* 225 */
 	.long sys_setxattr
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sh/kernel/syscalls_64.S linux-2.6.31-rsbac-1.4.2/arch/sh/kernel/syscalls_64.S
--- trunk/arch/sh/kernel/syscalls_64.S	2009-09-10 18:16:00.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sh/kernel/syscalls_64.S	2009-09-10 18:18:42.000000000 +0200
@@ -276,7 +276,11 @@ sys_call_table:
 	.long sys_getdents64
 	.long sys_fcntl64
 	.long sys_ni_syscall		/* 250 reserved for TUX */
+#ifdef CONFIG_RSBAC
+        .long sys_rsbac
+#else
 	.long sys_ni_syscall		/* Reserved for Security */
+#endif
 	.long sys_gettid
 	.long sys_readahead
 	.long sys_setxattr
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sparc/include/asm/unistd.h linux-2.6.31-rsbac-1.4.2/arch/sparc/include/asm/unistd.h
--- trunk/arch/sparc/include/asm/unistd.h	2009-09-10 18:15:57.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sparc/include/asm/unistd.h	2009-09-10 18:18:39.000000000 +0200
@@ -396,7 +396,12 @@
 #define __NR_pwritev		325
 #define __NR_rt_tgsigqueueinfo	326
 
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac              327
+#define NR_SYSCALLS		328
+#else
 #define NR_SYSCALLS		327
+#endif
 
 #ifdef __32bit_syscall_numbers__
 /* Sparc 32-bit only has the "setresuid32", "getresuid32" variants,
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sparc/kernel/process_32.c linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/process_32.c
--- trunk/arch/sparc/kernel/process_32.c	2009-09-10 18:15:56.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/process_32.c	2009-09-10 18:18:38.000000000 +0200
@@ -39,6 +39,11 @@
 #include <asm/prom.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#include <linux/pid.h>
+#endif
+
 /* 
  * Power management idle function 
  * Set in pm platform drivers (apc.c and pmc.c)
@@ -669,9 +674,19 @@ pid_t kernel_thread(int (*fn)(void *), v
 			     /* Notreached by child. */
 			     "1: mov %%o0, %0\n\t" :
 			     "=r" (retval) :
+#ifdef CONFIG_RSBAC
+			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED | CLOE_KTHREAD),
+#else
 			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED),
+#endif
 			     "i" (__NR_exit),  "r" (fn), "r" (arg) :
 			     "g1", "g2", "g3", "o0", "o1", "memory", "cc");
+
+#ifdef CONFIG_RSBAC
+	if (retval > 0)
+		rsbac_kthread_notify(find_pid_ns(retval, &init_pid_ns));
+#endif
+
 	return retval;
 }
 EXPORT_SYMBOL(kernel_thread);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sparc/kernel/process_64.c linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/process_64.c
--- trunk/arch/sparc/kernel/process_64.c	2009-09-10 18:15:56.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/process_64.c	2009-09-10 18:18:39.000000000 +0200
@@ -49,6 +49,11 @@
 #include <asm/irq_regs.h>
 #include <asm/smp.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#include <linux/pid.h>
+#endif
+
 #include "kstack.h"
 
 static void sparc64_yield(int cpu)
@@ -676,9 +681,19 @@ pid_t kernel_thread(int (*fn)(void *), v
 			     /* Notreached by child. */
 			     "1:" :
 			     "=r" (retval) :
+#ifdef CONFIG_RSBAC
+			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD),
+#else
 			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED),
+#endif
 			     "i" (__NR_exit),  "r" (fn), "r" (arg) :
 			     "g1", "g2", "g3", "o0", "o1", "memory", "cc");
+
+#ifdef CONFIG_RSBAC
+	if (retval > 0)
+		rsbac_kthread_notify(find_pid_ns(retval, &init_pid_ns));
+#endif
+
 	return retval;
 }
 EXPORT_SYMBOL(kernel_thread);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sparc/kernel/ptrace_32.c linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/ptrace_32.c
--- trunk/arch/sparc/kernel/ptrace_32.c	2009-09-10 18:15:56.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/ptrace_32.c	2009-09-10 18:18:38.000000000 +0200
@@ -26,6 +26,8 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 /* #define ALLOW_INIT_TRACING */
 
 /*
@@ -209,6 +211,28 @@ static int fpregs32_get(struct task_stru
 	const unsigned long *fpregs = target->thread.float_regs;
 	int ret = 0;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+ 
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = find_pid_ns(pid, &init_pid_ns);
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
+
 #if 0
 	if (target == current)
 		save_and_clear_fpu();
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sparc/kernel/ptrace_64.c linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/ptrace_64.c
--- trunk/arch/sparc/kernel/ptrace_64.c	2009-09-10 18:15:56.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/ptrace_64.c	2009-09-10 18:18:38.000000000 +0200
@@ -37,6 +37,8 @@
 #include <asm/cpudata.h>
 #include <asm/cacheflush.h>
 
+#include <rsbac/hooks.h>
+
 #include "entry.h"
 
 /* #define ALLOW_INIT_TRACING */
@@ -862,9 +864,32 @@ long compat_arch_ptrace(struct task_stru
 	unsigned long data = cdata;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	pregs = (struct pt_regs32 __user *) addr;
 	fps = (struct compat_fps __user *) addr;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(child);
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	switch (request) {
 	case PTRACE_PEEKUSR:
 		ret = (addr != 0) ? -EIO : 0;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sparc/kernel/systbls_32.S linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/systbls_32.S
--- trunk/arch/sparc/kernel/systbls_32.S	2009-09-10 18:15:56.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/systbls_32.S	2009-09-10 18:18:38.000000000 +0200
@@ -48,7 +48,11 @@ sys_call_table:
 /*145*/	.long sys_setrlimit, sys_pivot_root, sys_prctl, sys_pciconfig_read, sys_pciconfig_write
 /*150*/	.long sys_nis_syscall, sys_inotify_init, sys_inotify_add_watch, sys_poll, sys_getdents64
 /*155*/	.long sys_fcntl64, sys_inotify_rm_watch, sys_statfs, sys_fstatfs, sys_oldumount
+#ifdef CONFIG_RSBAC /* we use 164, which seems to be unused */
+/*160*/	.long sys_sched_setaffinity, sys_sched_getaffinity, sys_getdomainname, sys_setdomainname, sys_rsbac
+#else
 /*160*/	.long sys_sched_setaffinity, sys_sched_getaffinity, sys_getdomainname, sys_setdomainname, sys_nis_syscall
+#endif
 /*165*/	.long sys_quotactl, sys_set_tid_address, sys_mount, sys_ustat, sys_setxattr
 /*170*/	.long sys_lsetxattr, sys_fsetxattr, sys_getxattr, sys_lgetxattr, sys_getdents
 /*175*/	.long sys_setsid, sys_fchdir, sys_fgetxattr, sys_listxattr, sys_llistxattr
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/sparc/kernel/systbls_64.S linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/systbls_64.S
--- trunk/arch/sparc/kernel/systbls_64.S	2009-09-10 18:15:56.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/sparc/kernel/systbls_64.S	2009-09-10 18:18:38.000000000 +0200
@@ -50,7 +50,11 @@ sys_call_table32:
 	.word compat_sys_setrlimit, sys_pivot_root, sys32_prctl, sys_pciconfig_read, sys_pciconfig_write
 /*150*/	.word sys_nis_syscall, sys_inotify_init, sys_inotify_add_watch, sys_poll, sys_getdents64
 	.word compat_sys_fcntl64, sys_inotify_rm_watch, compat_sys_statfs, compat_sys_fstatfs, sys_oldumount
-/*160*/	.word compat_sys_sched_setaffinity, compat_sys_sched_getaffinity, sys32_getdomainname, sys32_setdomainname, sys_nis_syscall
+#ifdef CONFIG_RSBAC /* we use 164, which seems to be unused */
+/*160*/	.long sys_sched_setaffinity, sys_sched_getaffinity, sys_getdomainname, sys_setdomainname, sys_rsbac
+#else
+/*160*/	.long sys_sched_setaffinity, sys_sched_getaffinity, sys_getdomainname, sys_setdomainname, sys_nis_syscall
+#endif
 	.word sys_quotactl, sys_set_tid_address, compat_sys_mount, compat_sys_ustat, sys32_setxattr
 /*170*/	.word sys32_lsetxattr, sys32_fsetxattr, sys_getxattr, sys_lgetxattr, compat_sys_getdents
 	.word sys_setsid, sys_fchdir, sys32_fgetxattr, sys_listxattr, sys_llistxattr
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/um/kernel/process.c linux-2.6.31-rsbac-1.4.2/arch/um/kernel/process.c
--- trunk/arch/um/kernel/process.c	2009-09-10 18:15:29.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/um/kernel/process.c	2009-09-10 18:18:12.000000000 +0200
@@ -72,7 +72,11 @@ int kernel_thread(int (*fn)(void *), voi
 
 	current->thread.request.u.thread.proc = fn;
 	current->thread.request.u.thread.arg = arg;
+#ifdef CONFIG_RSBAC
+	pid = do_fork(CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD | flags, 0,
+#else
 	pid = do_fork(CLONE_VM | CLONE_UNTRACED | flags, 0,
+#endif
 		      &current->thread.regs, 0, NULL, NULL);
 	return pid;
 }
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/x86/ia32/ia32entry.S linux-2.6.31-rsbac-1.4.2/arch/x86/ia32/ia32entry.S
--- trunk/arch/x86/ia32/ia32entry.S	2009-09-10 18:15:40.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/x86/ia32/ia32entry.S	2009-09-10 18:18:17.000000000 +0200
@@ -718,7 +718,11 @@ ia32_sys_call_table:
 	.quad compat_sys_getdents64	/* 220 getdents64 */
 	.quad compat_sys_fcntl64	
 	.quad quiet_ni_syscall		/* tux */
-	.quad quiet_ni_syscall    	/* security */
+#ifdef CONFIG_RSBAC
+	.quad sys_rsbac         /* security */
+#else
+	.quad quiet_ni_syscall          /* security */
+#endif
 	.quad sys_gettid	
 	.quad sys32_readahead	/* 225 */
 	.quad sys_setxattr
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/x86/include/asm/processor.h linux-2.6.31-rsbac-1.4.2/arch/x86/include/asm/processor.h
--- trunk/arch/x86/include/asm/processor.h	2009-09-10 18:15:39.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/x86/include/asm/processor.h	2009-09-10 18:18:17.000000000 +0200
@@ -619,7 +619,11 @@ typedef struct {
 /*
  * create a kernel thread without removing it from tasklists
  */
+#ifdef CONFIG_RSBAC
+extern int kernel_thread(int (*fn)(void *), void *arg, unsigned long long flags);
+#else
 extern int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
+#endif
 
 /* Free all resources held by a thread. */
 extern void release_thread(struct task_struct *);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/x86/include/asm/unistd_32.h linux-2.6.31-rsbac-1.4.2/arch/x86/include/asm/unistd_32.h
--- trunk/arch/x86/include/asm/unistd_32.h	2009-09-10 18:15:40.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/x86/include/asm/unistd_32.h	2009-09-10 18:18:17.000000000 +0200
@@ -228,7 +228,7 @@
 #define __NR_madvise1		219	/* delete when C lib stub is removed */
 #define __NR_getdents64		220
 #define __NR_fcntl64		221
-/* 223 is unused */
+#define __NR_rsbac		223	/* was security */
 #define __NR_gettid		224
 #define __NR_readahead		225
 #define __NR_setxattr		226
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/x86/include/asm/unistd_64.h linux-2.6.31-rsbac-1.4.2/arch/x86/include/asm/unistd_64.h
--- trunk/arch/x86/include/asm/unistd_64.h	2009-09-10 18:15:39.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/x86/include/asm/unistd_64.h	2009-09-10 18:18:17.000000000 +0200
@@ -431,7 +431,14 @@ __SYSCALL(__NR_afs_syscall, sys_ni_sysca
 __SYSCALL(__NR_tuxcall, sys_ni_syscall)
 
 #define __NR_security				185
+#ifdef CONFIG_RSBAC
+#ifndef __NR_rsbac
+#define __NR_rsbac __NR_security
+#endif
+__SYSCALL(__NR_rsbac, sys_rsbac)
+#else
 __SYSCALL(__NR_security, sys_ni_syscall)
+#endif
 
 #define __NR_gettid				186
 __SYSCALL(__NR_gettid, sys_gettid)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/x86/kernel/ioport.c linux-2.6.31-rsbac-1.4.2/arch/x86/kernel/ioport.c
--- trunk/arch/x86/kernel/ioport.c	2009-09-10 18:15:37.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/x86/kernel/ioport.c	2009-09-10 18:18:16.000000000 +0200
@@ -16,6 +16,8 @@
 #include <linux/syscalls.h>
 #include <asm/syscalls.h>
 
+#include <rsbac/hooks.h>
+
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base,
 		       unsigned int extent, int new_value)
@@ -39,11 +41,31 @@ asmlinkage long sys_ioperm(unsigned long
 	struct tss_struct *tss;
 	unsigned int i, max_long, bytes, bytes_updated;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_ioports;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -107,6 +129,11 @@ static int do_iopl(unsigned int level, s
 {
 	unsigned int old = (regs->flags >> 12) & 3;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (level > 3)
 		return -EINVAL;
 	/* Trying to gain more privileges? */
@@ -114,6 +141,22 @@ static int do_iopl(unsigned int level, s
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
 	}
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_ioports;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	regs->flags = (regs->flags & ~X86_EFLAGS_IOPL) | (level << 12);
 
 	return 0;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/x86/kernel/process_32.c linux-2.6.31-rsbac-1.4.2/arch/x86/kernel/process_32.c
--- trunk/arch/x86/kernel/process_32.c	2009-09-10 18:15:36.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/x86/kernel/process_32.c	2009-09-10 18:18:15.000000000 +0200
@@ -59,6 +59,10 @@
 #include <asm/syscalls.h>
 #include <asm/ds.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
 DEFINE_PER_CPU(struct task_struct *, current_task) = &init_task;
@@ -204,10 +208,18 @@ extern void kernel_thread_helper(void);
 /*
  * Create a kernel thread
  */
+#ifdef CONFIG_RSBAC
+int kernel_thread(int (*fn)(void *), void *arg, unsigned long long flags)
+#else
 int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
+#endif
 {
 	struct pt_regs regs;
 
+#ifdef CONFIG_RSBAC
+	long rsbac_retval;
+#endif
+
 	memset(&regs, 0, sizeof(regs));
 
 	regs.bx = (unsigned long) fn;
@@ -223,7 +235,14 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.flags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2;
 
 	/* Ok, create the new process.. */
+#ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if (rsbac_retval > 0)
+		rsbac_kthread_notify(find_pid_ns(rsbac_retval, &init_pid_ns));
+	return rsbac_retval;
+#else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/x86/kernel/process_64.c linux-2.6.31-rsbac-1.4.2/arch/x86/kernel/process_64.c
--- trunk/arch/x86/kernel/process_64.c	2009-09-10 18:15:38.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/x86/kernel/process_64.c	2009-09-10 18:18:16.000000000 +0200
@@ -61,7 +61,11 @@ EXPORT_PER_CPU_SYMBOL(current_task);
 DEFINE_PER_CPU(unsigned long, old_rsp);
 static DEFINE_PER_CPU(unsigned char, is_idle);
 
+#ifdef CONFIG_RSBAC
+unsigned long kernel_thread_flags = CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD;
+#else
 unsigned long kernel_thread_flags = CLONE_VM | CLONE_UNTRACED;
+#endif
 
 static ATOMIC_NOTIFIER_HEAD(idle_notifier);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/x86/kernel/syscall_table_32.S linux-2.6.31-rsbac-1.4.2/arch/x86/kernel/syscall_table_32.S
--- trunk/arch/x86/kernel/syscall_table_32.S	2009-09-10 18:15:35.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/x86/kernel/syscall_table_32.S	2009-09-10 18:18:15.000000000 +0200
@@ -222,7 +222,11 @@ ENTRY(sys_call_table)
 	.long sys_getdents64	/* 220 */
 	.long sys_fcntl64
 	.long sys_ni_syscall	/* reserved for TUX */
-	.long sys_ni_syscall
+#ifdef CONFIG_RSBAC
+        .long sys_rsbac
+#else
+        .long sys_ni_syscall
+#endif
 	.long sys_gettid
 	.long sys_readahead	/* 225 */
 	.long sys_setxattr
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/arch/xtensa/kernel/entry.S linux-2.6.31-rsbac-1.4.2/arch/xtensa/kernel/entry.S
--- trunk/arch/xtensa/kernel/entry.S	2009-09-10 18:15:49.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/arch/xtensa/kernel/entry.S	2009-09-10 18:18:28.000000000 +0200
@@ -1844,7 +1844,11 @@ ENTRY(kernel_thread)
 	mov	a5, a2			# preserve fn over syscall
 	mov	a7, a3			# preserve args over syscall
 
+#ifdef CONFIG_RSBAC
+	movi	a3, _CLONE_VM | _CLONE_UNTRACED | _CLONE_KTHREAD)
+#else
 	movi	a3, _CLONE_VM | _CLONE_UNTRACED
+#endif
 	movi	a2, __NR_clone
 	or	a6, a4, a3		# arg0: flags
 	mov	a3, a1			# arg1: sp
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/block/ioctl.c linux-2.6.31-rsbac-1.4.2/block/ioctl.c
--- trunk/block/ioctl.c	2009-09-10 18:14:50.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/block/ioctl.c	2009-09-10 18:17:35.000000000 +0200
@@ -8,6 +8,12 @@
 #include <linux/blktrace_api.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#include <linux/hdreg.h>
+#endif
+
+
 static int blkpg_ioctl(struct block_device *bdev, struct blkpg_ioctl_arg __user *arg)
 {
 	struct block_device *bdevp;
@@ -235,6 +241,64 @@ int blkdev_ioctl(struct block_device *bd
 	loff_t size;
 	int ret, n;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t rsbac_request;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "blkdev_ioctl(): calling ADF\n");
+#endif
+
+	/* values taken from include/linux/fs.h and hdreg.h */
+	switch (cmd) {
+		case BLKGETSIZE:   /* Return device size */
+		case BLKGETSIZE64:
+		case BLKROGET:
+		case BLKRAGET:
+		case BLKFRAGET:
+		case BLKSECTGET:
+		case BLKSSZGET:
+		case BLKBSZGET:
+		case HDIO_GETGEO:
+		case HDIO_OBSOLETE_IDENTITY:
+		case HDIO_GET_UNMASKINTR:
+		case HDIO_GET_IDENTITY:
+		case HDIO_GET_NICE:
+		case HDIO_GET_BUSSTATE:
+		case HDIO_GET_QDMA:
+		case HDIO_GET_MULTCOUNT:
+		case HDIO_GET_KEEPSETTINGS:
+		case HDIO_GET_32BIT:
+		case HDIO_GET_NOWERR:
+		case HDIO_GET_DMA:
+		case HDIO_GET_WCACHE:
+		case HDIO_GET_ACOUSTIC:
+		case HDIO_GET_ADDRESS:
+			rsbac_request = R_GET_STATUS_DATA;
+			break;
+
+		default:
+			rsbac_request = R_MODIFY_SYSTEM_DATA;
+	}
+
+	rsbac_target_id.dev.type = D_block;
+	rsbac_target_id.dev.major = RSBAC_MAJOR(bdev->bd_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(bdev->bd_dev);
+
+	rsbac_attribute_value.ioctl_cmd = cmd;
+	if (!rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_ioctl_cmd,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	switch(cmd) {
 	case BLKFLSBUF:
 		if (!capable(CAP_SYS_ADMIN))
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/block/loop.c linux-2.6.31-rsbac-1.4.2/drivers/block/loop.c
--- trunk/drivers/block/loop.c	2009-09-10 18:16:25.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/block/loop.c	2009-09-10 18:19:02.000000000 +0200
@@ -77,6 +77,8 @@
 
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 static LIST_HEAD(loop_devices);
 static DEFINE_MUTEX(loop_devices_mutex);
 
@@ -746,6 +748,12 @@ static int loop_set_fd(struct loop_devic
 	int		error;
 	loff_t		size;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/* This is safe, since we have a reference from open(). */
 	__module_get(THIS_MODULE);
 
@@ -807,6 +815,46 @@ static int loop_set_fd(struct loop_devic
 	if (!(mode & FMODE_WRITE))
 		lo_flags |= LO_FLAGS_READ_ONLY;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[lo_ioctl()]: calling ADF for FILE/DEV\n");
+	if (S_ISREG(inode->i_mode)) {
+		rsbac_target = T_FILE;
+		rsbac_target_id.dir.device = file->f_dentry->d_sb->s_dev;
+		rsbac_target_id.dir.inode  = inode->i_ino;
+		rsbac_target_id.dir.dentry_p = file->f_dentry;
+	}
+	else { /* must be block */
+		rsbac_target = T_DEV;
+		rsbac_target_id.dev.type = D_block;
+		rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+	}
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		error = -EPERM;
+		goto out_putf;
+	}
+	rsbac_pr_debug(aef, "[lo_ioctl()]: calling ADF for DEV\n");
+	rsbac_target_id.dev.type = D_block;
+	rsbac_target_id.dev.major = RSBAC_MAJOR(bdev->bd_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(bdev->bd_dev);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		error = -EPERM;
+		goto out_putf;
+	}
+#endif
+
 	set_device_ro(bdev, (lo_flags & LO_FLAGS_READ_ONLY) != 0);
 
 	lo->lo_blocksize = lo_blocksize;
@@ -909,6 +957,12 @@ static int loop_clr_fd(struct loop_devic
 	struct file *filp = lo->lo_backing_file;
 	gfp_t gfp = lo->old_gfp_mask;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (lo->lo_state != Lo_bound)
 		return -ENXIO;
 
@@ -918,6 +972,44 @@ static int loop_clr_fd(struct loop_devic
 	if (filp == NULL)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[lo_ioctl()]: calling ADF for FILE/DEV\n");
+	if (S_ISREG(filp->f_dentry->d_inode->i_mode)) {
+		rsbac_target = T_FILE;
+		rsbac_target_id.dir.device = filp->f_dentry->d_sb->s_dev;
+		rsbac_target_id.dir.inode  = filp->f_dentry->d_inode->i_ino;
+		rsbac_target_id.dir.dentry_p = filp->f_dentry;
+	}
+	else { /* must be block dev */
+		rsbac_target = T_DEV;
+		rsbac_target_id.dev.type = D_block;
+		rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+	}
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_UMOUNT,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[lo_ioctl()]: calling ADF for DEV\n");
+	rsbac_target_id.dev.type = D_block;
+	rsbac_target_id.dev.major = LOOP_MAJOR;
+	rsbac_target_id.dev.minor = lo->lo_number;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_UMOUNT,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		return -EPERM;
+	}
+#endif
+
 	spin_lock_irq(&lo->lo_lock);
 	lo->lo_state = Lo_rundown;
 	spin_unlock_irq(&lo->lo_lock);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/char/mem.c linux-2.6.31-rsbac-1.4.2/drivers/char/mem.c
--- trunk/drivers/char/mem.c	2009-09-10 18:16:38.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/char/mem.c	2009-09-10 18:19:17.000000000 +0200
@@ -35,6 +35,8 @@
 # include <linux/efi.h>
 #endif
 
+#include <rsbac/hooks.h>
+
 /*
  * Architectures vary in how they handle caching for addresses
  * outside of main memory.
@@ -121,6 +123,11 @@ static ssize_t read_mem(struct file * fi
 	ssize_t read, sz;
 	char *ptr;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 	read = 0;
@@ -155,6 +162,25 @@ static ssize_t read_mem(struct file * fi
 		if (!range_is_allowed(p >> PAGE_SHIFT, count))
 			return -EPERM;
 
+#ifdef CONFIG_RSBAC
+		rsbac_attribute_value.pagenr = p >> PAGE_SHIFT;
+		if (rsbac_is_videomem(rsbac_attribute_value.pagenr, count))
+			rsbac_target_id.scd = ST_videomem;
+		else
+			rsbac_target_id.scd = ST_kmem;
+		rsbac_pr_debug(aef, "calling ADF\n");
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_pagenr,
+					rsbac_attribute_value)) {
+			rsbac_printk(KERN_INFO "read_mem(): RSBAC denied read access to kernel mem page %u, size %u\n",
+					rsbac_attribute_value.pagenr, count);
+			return -EPERM;
+		}
+#endif
+
 		/*
 		 * On ia64 if a page has been mapped somewhere as
 		 * uncached, then it must also be accessed uncached
@@ -189,6 +215,11 @@ static ssize_t write_mem(struct file * f
 	unsigned long copied;
 	void *ptr;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 
@@ -222,6 +253,25 @@ static ssize_t write_mem(struct file * f
 		if (!range_is_allowed(p >> PAGE_SHIFT, sz))
 			return -EPERM;
 
+#ifdef CONFIG_RSBAC
+		rsbac_attribute_value.pagenr = p >> PAGE_SHIFT;
+		if (rsbac_is_videomem(rsbac_attribute_value.pagenr, sz))
+			rsbac_target_id.scd = ST_videomem;
+		else
+			rsbac_target_id.scd = ST_kmem;
+		rsbac_pr_debug(aef, "calling ADF\n");
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_pagenr,
+					rsbac_attribute_value)) {
+			rsbac_printk(KERN_INFO "write_mem(): RSBAC denied write access to kernel mem page %u, size %u\n",
+					rsbac_attribute_value.pagenr, sz);
+			return -EPERM;
+		}
+#endif
+
 		/*
 		 * On ia64 if a page has been mapped somewhere as
 		 * uncached, then it must also be accessed uncached
@@ -311,6 +361,11 @@ static int mmap_mem(struct file * file, 
 {
 	size_t size = vma->vm_end - vma->vm_start;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!valid_mmap_phys_addr_range(vma->vm_pgoff, size))
 		return -EINVAL;
 
@@ -324,6 +379,25 @@ static int mmap_mem(struct file * file, 
 						&vma->vm_page_prot))
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	rsbac_attribute_value.pagenr = vma->vm_pgoff;
+	if (rsbac_is_videomem(rsbac_attribute_value.pagenr, size))
+		rsbac_target_id.scd = ST_videomem;
+	else
+		rsbac_target_id.scd = ST_kmem;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_pagenr,
+				rsbac_attribute_value)) {
+		rsbac_printk(KERN_INFO "mmap_mem(): RSBAC denied mmap access to kernel mem page %u, size %u\n",
+				rsbac_attribute_value.pagenr, size);
+		return -EPERM;
+	}
+#endif
+
 	vma->vm_page_prot = phys_mem_access_prot(file, vma->vm_pgoff,
 						 size,
 						 vma->vm_page_prot);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/char/sysrq.c linux-2.6.31-rsbac-1.4.2/drivers/char/sysrq.c
--- trunk/drivers/char/sysrq.c	2009-09-10 18:16:40.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/char/sysrq.c	2009-09-10 18:19:19.000000000 +0200
@@ -41,6 +41,11 @@
 #include <asm/ptrace.h>
 #include <asm/irq_regs.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/types.h>
+#include <rsbac/debug.h>
+#endif
+
 /* Whether we react on sysrq keys or just ignore them */
 int __read_mostly __sysrq_enabled = 1;
 
@@ -181,6 +186,25 @@ static struct sysrq_key_op sysrq_mountro
 	.enable_mask	= SYSRQ_ENABLE_REMOUNT,
 };
 
+#ifdef CONFIG_RSBAC_SOFTMODE_SYSRQ
+static void sysrq_handle_rsbac_softmode(int key,
+		                        struct tty_struct *tty) {
+	if (rsbac_softmode) {
+		rsbac_printk(KERN_WARNING "Soft mode disabled via SysRq!\n");
+		rsbac_softmode = 0;
+	}
+	else {
+		rsbac_printk(KERN_WARNING "Soft mode enabled via SysRq!\n");
+		rsbac_softmode = 1;
+	}
+}
+static struct sysrq_key_op sysrq_rsbac_softmode_op = {
+	handler:	sysrq_handle_rsbac_softmode,
+	help_msg:	"rsbac_toggle_softmode_X",
+	action_msg:	"RSBAC toggle softmode\n",
+};
+#endif
+
 #ifdef CONFIG_LOCKDEP
 static void sysrq_handle_showlocks(int key, struct tty_struct *tty)
 {
@@ -436,7 +460,11 @@ static struct sysrq_key_op *sysrq_key_ta
 	NULL,				/* v */
 	&sysrq_showstate_blocked_op,	/* w */
 	/* x: May be registered on ppc/powerpc for xmon */
+#ifdef CONFIG_RSBAC_SOFTMODE_SYSRQ
+	&sysrq_rsbac_softmode_op,	/* x */
+#else
 	NULL,				/* x */
+#endif
 	/* y: May be registered on sparc64 for global register dump */
 	NULL,				/* y */
 	&sysrq_ftrace_dump_op,		/* z */
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/char/tty_io.c linux-2.6.31-rsbac-1.4.2/drivers/char/tty_io.c
--- trunk/drivers/char/tty_io.c	2009-09-10 18:16:39.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/char/tty_io.c	2009-09-10 18:19:18.000000000 +0200
@@ -102,11 +102,14 @@
 
 #include <linux/kbd_kern.h>
 #include <linux/vt_kern.h>
+#include <linux/security.h>
 #include <linux/selection.h>
 
 #include <linux/kmod.h>
 #include <linux/nsproxy.h>
 
+#include <rsbac/hooks.h>
+
 #undef TTY_DEBUG_HANGUP
 
 #define TTY_PARANOIA_CHECK 1
@@ -1947,10 +1950,33 @@ static int tiocsti(struct tty_struct *tt
 	char ch, mbz = 0;
 	struct tty_ldisc *ld;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+ 
 	if ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (get_user(ch, p))
 		return -EFAULT;
+ 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.dev.type = D_char;
+	rsbac_target_id.dev.major = tty->driver->major;
+	rsbac_target_id.dev.minor = tty->driver->minor_start + tty->index;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEND,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+ 
 	tty_audit_tiocsti(tty, ch);
 	ld = tty_ldisc_ref_wait(tty);
 	ld->ops->receive_buf(tty, &ch, &mbz, 1);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/char/tty_ioctl.c linux-2.6.31-rsbac-1.4.2/drivers/char/tty_ioctl.c
--- trunk/drivers/char/tty_ioctl.c	2009-09-10 18:16:40.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/char/tty_ioctl.c	2009-09-10 18:19:18.000000000 +0200
@@ -26,6 +26,8 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#include <rsbac/hooks.h>
+
 #undef TTY_DEBUG_WAIT_UNTIL_SENT
 
 #undef	DEBUG
@@ -947,12 +949,56 @@ int tty_mode_ioctl(struct tty_struct *tt
 	int ret = 0;
 	struct ktermios kterm;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t rsbac_request;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (tty->driver->type == TTY_DRIVER_TYPE_PTY &&
 	    tty->driver->subtype == PTY_TYPE_MASTER)
 		real_tty = tty->link;
 	else
 		real_tty = tty;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	switch (cmd) {
+#ifdef TIOCGETP
+		case TIOCGETP:
+#endif
+#ifdef TIOCGETC
+		case TIOCGETC:
+#endif
+#ifdef TIOCGLTC
+		case TIOCGLTC:
+#endif
+		case TCGETS:
+		case TCGETA:
+		case TIOCOUTQ:
+		case TIOCINQ:
+		case TIOCGLCKTRMIOS:
+		case TIOCGSOFTCAR:
+			rsbac_request = R_GET_PERMISSIONS_DATA;
+			break;
+		default:
+			rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+	}
+	rsbac_target_id.dev.type = D_char;
+	rsbac_target_id.dev.major = tty->driver->major;
+	rsbac_target_id.dev.minor = tty->driver->minor_start + tty->index;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	switch (cmd) {
 #ifdef TIOCGETP
 	case TIOCGETP:
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/ide/ide.c linux-2.6.31-rsbac-1.4.2/drivers/ide/ide.c
--- trunk/drivers/ide/ide.c	2009-09-10 18:16:59.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/ide/ide.c	2009-09-10 18:19:35.000000000 +0200
@@ -59,6 +59,7 @@
 #include <linux/hdreg.h>
 #include <linux/completion.h>
 #include <linux/device.h>
+#include <linux/security.h>
 
 struct class *ide_port_class;
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/ide/ide-ioctls.c linux-2.6.31-rsbac-1.4.2/drivers/ide/ide-ioctls.c
--- trunk/drivers/ide/ide-ioctls.c	2009-09-10 18:16:59.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/ide/ide-ioctls.c	2009-09-10 18:19:35.000000000 +0200
@@ -4,6 +4,7 @@
 
 #include <linux/hdreg.h>
 #include <linux/ide.h>
+#include <rsbac/hooks.h>
 
 static const struct ide_ioctl_devset ide_ioctl_settings[] = {
 { HDIO_GET_32BIT,	 HDIO_SET_32BIT,	&ide_devset_io_32bit  },
@@ -238,6 +239,58 @@ int generic_ide_ioctl(ide_drive_t *drive
 {
 	int err;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t rsbac_request;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	/* values taken from include/linux/fs.h and hdreg.h */
+	switch (cmd) {
+		case BLKGETSIZE:   /* Return device size */
+		case BLKGETSIZE64:
+		case BLKROGET:
+		case BLKRAGET:
+		case BLKFRAGET:
+		case BLKSECTGET:
+		case BLKSSZGET:
+		case BLKBSZGET:
+		case HDIO_GETGEO:
+		case HDIO_OBSOLETE_IDENTITY:
+		case HDIO_GET_UNMASKINTR:
+		case HDIO_GET_IDENTITY:
+		case HDIO_GET_NICE:
+		case HDIO_GET_BUSSTATE:
+		case HDIO_GET_QDMA:
+		case HDIO_GET_MULTCOUNT:
+		case HDIO_GET_KEEPSETTINGS:
+		case HDIO_GET_32BIT:
+		case HDIO_GET_NOWERR:
+		case HDIO_GET_DMA:
+		case HDIO_GET_WCACHE:
+		case HDIO_GET_ACOUSTIC:
+		case HDIO_GET_ADDRESS:
+			rsbac_request = R_GET_STATUS_DATA;
+			break;
+
+		default:
+			rsbac_request = R_MODIFY_SYSTEM_DATA;
+	}
+	rsbac_target_id.dev.type = D_block;
+	rsbac_target_id.dev.major = RSBAC_MAJOR(bdev->bd_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(bdev->bd_dev);
+	rsbac_attribute_value.ioctl_cmd = cmd;
+	if (!rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_ioctl_cmd,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	err = ide_setting_ioctl(drive, bdev, cmd, arg, ide_ioctl_settings);
 	if (err != -EOPNOTSUPP)
 		return err;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/infiniband/core/uverbs_main.c linux-2.6.31-rsbac-1.4.2/drivers/infiniband/core/uverbs_main.c
--- trunk/drivers/infiniband/core/uverbs_main.c	2009-09-10 18:16:26.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/infiniband/core/uverbs_main.c	2009-09-10 18:19:03.000000000 +0200
@@ -46,6 +46,10 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #include "uverbs.h"
 
 MODULE_AUTHOR("Roland Dreier");
@@ -871,6 +875,9 @@ static int __init ib_uverbs_init(void)
 		goto out_fs;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_mount(uverbs_event_mnt);
+#endif
 	ret = ib_register_client(&uverbs_client);
 	if (ret) {
 		printk(KERN_ERR "user_verbs: couldn't register client\n");
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/isdn/capi/capifs.c linux-2.6.31-rsbac-1.4.2/drivers/isdn/capi/capifs.c
--- trunk/drivers/isdn/capi/capifs.c	2009-09-10 18:16:36.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/isdn/capi/capifs.c	2009-09-10 18:19:15.000000000 +0200
@@ -17,6 +17,10 @@
 #include <linux/ctype.h>
 #include <linux/sched.h>	/* current */
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #include "capifs.h"
 
 MODULE_DESCRIPTION("CAPI4Linux: /dev/capi/ filesystem");
@@ -207,6 +211,10 @@ static int __init capifs_init(void)
 			err = PTR_ERR(capifs_mnt);
 			unregister_filesystem(&capifs_fs_type);
 		}
+#ifdef CONFIG_RSBAC
+		else
+			rsbac_mount(capifs_mnt);
+#endif
 	}
 	if (!err)
 		printk(KERN_NOTICE "capifs: Rev %s\n", rev);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/drivers/usb/core/usb.c linux-2.6.31-rsbac-1.4.2/drivers/usb/core/usb.c
--- trunk/drivers/usb/core/usb.c	2009-09-10 18:16:56.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/drivers/usb/core/usb.c	2009-09-10 18:19:33.000000000 +0200
@@ -648,6 +648,10 @@ exit:
 	return dev;
 }
 
+#ifdef CONFIG_RSBAC_REG
+EXPORT_SYMBOL_GPL(usb_find_device);
+#endif
+
 /**
  * usb_get_current_frame_number - return current bus frame number
  * @dev: the device whose bus is being queried
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/afs/mntpt.c linux-2.6.31-rsbac-1.4.2/fs/afs/mntpt.c
--- trunk/fs/afs/mntpt.c	2009-09-10 18:14:54.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/afs/mntpt.c	2009-09-10 18:17:38.000000000 +0200
@@ -17,6 +17,7 @@
 #include <linux/pagemap.h>
 #include <linux/mount.h>
 #include <linux/namei.h>
+#include <rsbac/aci.h>
 #include "internal.h"
 
 
@@ -190,6 +191,11 @@ static struct vfsmount *afs_mntpt_do_aut
 	mnt = vfs_kern_mount(&afs_fs_type, 0, devname, options);
 	_debug("--- mount result %p ---", mnt);
 
+#ifdef CONFIG_RSBAC
+	if (!IS_ERR(mnt))
+		rsbac_mount(mnt);
+#endif
+
 	free_page((unsigned long) devname);
 	free_page((unsigned long) options);
 	_leave(" = %p", mnt);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/anon_inodes.c linux-2.6.31-rsbac-1.4.2/fs/anon_inodes.c
--- trunk/fs/anon_inodes.c	2009-09-10 18:14:57.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/anon_inodes.c	2009-09-10 18:17:40.000000000 +0200
@@ -21,6 +21,10 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 static struct vfsmount *anon_inode_mnt __read_mostly;
 static struct inode *anon_inode_inode;
 static const struct file_operations anon_inode_fops;
@@ -192,6 +196,9 @@ static int __init anon_inode_init(void)
 		error = PTR_ERR(anon_inode_mnt);
 		goto err_unregister_filesystem;
 	}
+#ifdef CONFIG_RSBAC
+	rsbac_mount(anon_inode_mnt);
+#endif
 	anon_inode_inode = anon_inode_mkinode();
 	if (IS_ERR(anon_inode_inode)) {
 		error = PTR_ERR(anon_inode_inode);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/block_dev.c linux-2.6.31-rsbac-1.4.2/fs/block_dev.c
--- trunk/fs/block_dev.c	2009-09-10 18:14:59.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/block_dev.c	2009-09-10 18:17:41.000000000 +0200
@@ -29,6 +29,10 @@
 #include <asm/uaccess.h>
 #include "internal.h"
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 struct bdev_inode {
 	struct block_device bdev;
 	struct inode vfs_inode;
@@ -498,6 +502,10 @@ void __init bdev_cache_init(void)
 	bd_mnt = kern_mount(&bd_type);
 	if (IS_ERR(bd_mnt))
 		panic("Cannot create bdev pseudo-fs");
+#ifdef CONFIG_RSBAC
+	else
+		rsbac_mount(bd_mnt);
+#endif
 	/*
 	 * This vfsmount structure is only used to obtain the
 	 * blockdev_superblock, so tell kmemleak not to report it.
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/devpts/inode.c linux-2.6.31-rsbac-1.4.2/fs/devpts/inode.c
--- trunk/fs/devpts/inode.c	2009-09-10 18:14:55.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/devpts/inode.c	2009-09-10 18:17:39.000000000 +0200
@@ -24,6 +24,10 @@
 #include <linux/fsnotify.h>
 #include <linux/seq_file.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #define DEVPTS_SUPER_MAGIC 0x1cd1
 
 #define DEVPTS_DEFAULT_MODE 0600
@@ -560,6 +564,10 @@ static int __init init_devpts_fs(void)
 			err = PTR_ERR(devpts_mnt);
 			unregister_filesystem(&devpts_fs_type);
 		}
+#ifdef CONFIG_RSBAC
+		else
+			rsbac_mount(devpts_mnt);
+#endif
 	}
 	return err;
 }
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/exec.c linux-2.6.31-rsbac-1.4.2/fs/exec.c
--- trunk/fs/exec.c	2009-09-10 18:14:59.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/exec.c	2009-09-10 18:17:41.000000000 +0200
@@ -61,6 +61,8 @@
 #include <asm/tlb.h>
 #include "internal.h"
 
+#include <rsbac/hooks.h>
+
 int core_uses_pid;
 char core_pattern[CORENAME_MAX_SIZE] = "core";
 int suid_dumpable = 0;
@@ -109,6 +111,11 @@ SYSCALL_DEFINE1(uselib, const char __use
 	char *tmp = getname(library);
 	int error = PTR_ERR(tmp);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (IS_ERR(tmp))
 		goto out;
 
@@ -124,10 +131,36 @@ SYSCALL_DEFINE1(uselib, const char __use
 	if (!S_ISREG(file->f_path.dentry->d_inode->i_mode))
 		goto exit;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if (rsbac_dac_part_disabled(file->f_path.dentry))
+		error = 0;
+	else
+#endif
 	error = -EACCES;
 	if (file->f_path.mnt->mnt_flags & MNT_NOEXEC)
 		goto exit;
 
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.file.device = file->f_path.dentry->d_inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = file->f_path.dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = file->f_path.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MAP_EXEC,
+				task_pid(current),
+				T_FILE,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_pr_debug(aef, "request not granted, my PID: %i\n",
+			       task_pid(current));
+		error = -EPERM;
+		goto exit;
+	}
+#endif
+
 	fsnotify_open(file->f_path.dentry);
 
 	error = -ENOEXEC;
@@ -151,6 +184,29 @@ SYSCALL_DEFINE1(uselib, const char __use
 	}
 exit:
 	fput(file);
+
+	/* RSBAC: notify ADF of mapped segment */
+#ifdef CONFIG_RSBAC
+	if (!error) {
+		union rsbac_target_id_t rsbac_new_target_id;
+
+		rsbac_pr_debug(aef, "calling ADF_set_attr\n");
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_MAP_EXEC,
+					task_pid(current),
+					T_FILE,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_uselib(): rsbac_adf_set_attr() returned error\n");
+		}
+	}
+#endif
+
 out:
   	return error;
 }
@@ -665,6 +721,13 @@ struct file *open_exec(const char *name)
 
 	fsnotify_open(file->f_path.dentry);
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if (rsbac_dac_part_disabled(file->f_path.dentry))
+		err = 0;
+	else
+#endif
+
+
 	err = deny_write_access(file);
 	if (err)
 		goto exit;
@@ -1290,6 +1353,12 @@ int do_execve(char * filename,
 	bool clear_in_exec;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	retval = unshare_files(&displaced);
 	if (retval)
 		goto out_ret;
@@ -1332,6 +1401,26 @@ int do_execve(char * filename,
 	if ((retval = bprm->envc) < 0)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_execve()]: calling ADF\n");
+	rsbac_target_id.file.device = file->f_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = file->f_dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_EXECUTE,
+				task_pid(current),
+				T_FILE,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_pr_debug(aef, "[sys_execve()]: request not granted, my PID: %i\n",
+				task_pid(current));
+		retval = -EPERM;
+		goto out;
+	}
+#endif
+
 	retval = prepare_binprm(bprm);
 	if (retval < 0)
 		goto out;
@@ -1349,6 +1438,12 @@ int do_execve(char * filename,
 	if (retval < 0)
 		goto out;
 
+/*#ifdef CONFIG_RSBAC_CAP
+	retval = rsbac_cap_check_envp(bprm);
+	if (retval < 0)
+		goto out;
+#endif*/
+
 	current->flags &= ~PF_KTHREAD;
 	retval = search_binary_handler(bprm,regs);
 	if (retval < 0)
@@ -1358,6 +1453,25 @@ int do_execve(char * filename,
 	current->fs->in_exec = 0;
 	current->in_execve = 0;
 	acct_update_integrals(current);
+/* RSBAC: notify ADF of changed program in this process
+ * Most structures are already filled
+ */
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_execve()]: calling ADF_set_attr\n");
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_EXECUTE,
+					task_pid(current),
+					T_FILE,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"do_execve() [sys_execve]: rsbac_adf_set_attr() returned error\n");
+		}
+#endif
 	free_bprm(bprm);
 	if (displaced)
 		put_files_struct(displaced);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/ext2/ioctl.c linux-2.6.31-rsbac-1.4.2/fs/ext2/ioctl.c
--- trunk/fs/ext2/ioctl.c	2009-09-10 18:15:04.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/ext2/ioctl.c	2009-09-10 18:17:43.000000000 +0200
@@ -10,12 +10,17 @@
 #include "ext2.h"
 #include <linux/capability.h>
 #include <linux/time.h>
+#include <linux/security.h>
 #include <linux/sched.h>
 #include <linux/compat.h>
 #include <linux/mount.h>
 #include <asm/current.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
 
 long ext2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
@@ -25,6 +30,73 @@ long ext2_ioctl(struct file *filp, unsig
 	unsigned short rsv_window_size;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t rsbac_request;
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	switch (cmd) {
+		case EXT2_IOC_GETFLAGS:
+		case EXT2_IOC_GETVERSION:
+			rsbac_request = R_GET_PERMISSIONS_DATA;
+			break;
+		case EXT2_IOC_SETFLAGS:
+		case EXT2_IOC_SETVERSION:
+			rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+			break;
+		default:
+			rsbac_request = R_NONE;
+	}
+	if(S_ISSOCK(inode->i_mode)) {
+		if(SOCKET_I(inode)->ops
+				&& (SOCKET_I(inode)->ops->family == AF_UNIX)) {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p
+				= SOCKET_I(inode);
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+	}
+	else {
+		if (S_ISDIR(inode->i_mode))
+			rsbac_target = T_DIR;
+		else if (S_ISFIFO(inode->i_mode))
+			rsbac_target = T_FIFO;
+		else if (S_ISLNK(inode->i_mode))
+			rsbac_target = T_SYMLINK;
+		else
+			rsbac_target = T_FILE;
+		rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+		rsbac_target_id.file.inode  = inode->i_ino;
+		rsbac_target_id.file.dentry_p = filp->f_dentry;
+	}
+	rsbac_attribute_value.ioctl_cmd = cmd;
+	if(   (rsbac_request != R_NONE)
+			&& !rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_ioctl_cmd,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	ext2_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/ext2/namei.c linux-2.6.31-rsbac-1.4.2/fs/ext2/namei.c
--- trunk/fs/ext2/namei.c	2009-09-10 18:15:04.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/ext2/namei.c	2009-09-10 18:17:43.000000000 +0200
@@ -31,11 +31,14 @@
  */
 
 #include <linux/pagemap.h>
+#include <linux/security.h>
 #include "ext2.h"
 #include "xattr.h"
 #include "acl.h"
 #include "xip.h"
 
+#include <rsbac/hooks.h>
+
 static inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)
 {
 	int err = ext2_add_link(dentry, inode);
@@ -270,6 +273,11 @@ static int ext2_unlink(struct inode * di
 	if (err)
 		goto out;
 
+#ifdef CONFIG_RSBAC_SECDEL
+	if (inode->i_nlink == 1)
+		rsbac_sec_del(dentry, TRUE);
+#endif
+
 	inode->i_ctime = dir->i_ctime;
 	inode_dec_link_count(inode);
 	err = 0;
@@ -327,6 +335,12 @@ static int ext2_rename (struct inode * o
 		new_de = ext2_find_entry (new_dir, &new_dentry->d_name, &new_page);
 		if (!new_de)
 			goto out_dir;
+                
+#ifdef CONFIG_RSBAC_SECDEL
+		if (new_inode->i_nlink == 1)
+			rsbac_sec_del(new_dentry, TRUE);
+#endif
+
 		inode_inc_link_count(old_inode);
 		ext2_set_link(new_dir, new_de, new_page, old_inode, 1);
 		new_inode->i_ctime = CURRENT_TIME_SEC;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/ext3/ioctl.c linux-2.6.31-rsbac-1.4.2/fs/ext3/ioctl.c
--- trunk/fs/ext3/ioctl.c	2009-09-10 18:15:04.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/ext3/ioctl.c	2009-09-10 18:17:43.000000000 +0200
@@ -12,11 +12,17 @@
 #include <linux/capability.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/security.h>
 #include <linux/mount.h>
 #include <linux/time.h>
 #include <linux/compat.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
+
 long ext3_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	struct inode *inode = filp->f_dentry->d_inode;
@@ -24,6 +30,83 @@ long ext3_ioctl(struct file *filp, unsig
 	unsigned int flags;
 	unsigned short rsv_window_size;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t rsbac_request;
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	switch (cmd) {
+#ifdef CONFIG_JBD_DEBUG
+		case EXT3_IOC_WAIT_FOR_READONLY:
+#endif
+		case EXT3_IOC_GETFLAGS:
+		case EXT3_IOC_GETVERSION:
+		case EXT3_IOC_GETVERSION_OLD:
+		case EXT3_IOC_GETRSVSZ:
+			rsbac_request = R_GET_PERMISSIONS_DATA;
+			break;
+		case EXT3_IOC_SETFLAGS:
+		case EXT3_IOC_SETVERSION:
+		case EXT3_IOC_SETVERSION_OLD:
+		case EXT3_IOC_SETRSVSZ:
+		case EXT3_IOC_GROUP_EXTEND:
+		case EXT3_IOC_GROUP_ADD:
+			rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+			break;
+		default:
+			rsbac_request = R_NONE;
+	}
+	if(S_ISSOCK(inode->i_mode)) {
+		if(SOCKET_I(inode)->ops
+				&& (SOCKET_I(inode)->ops->family == AF_UNIX)) {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p
+				= SOCKET_I(inode);
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+	}
+	else {
+		if (S_ISDIR(inode->i_mode))
+			rsbac_target = T_DIR;
+		else if (S_ISFIFO(inode->i_mode))
+			rsbac_target = T_FIFO;
+		else if (S_ISLNK(inode->i_mode))
+			rsbac_target = T_SYMLINK;
+		else
+			rsbac_target = T_FILE;
+		rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+		rsbac_target_id.file.inode  = inode->i_ino;
+		rsbac_target_id.file.dentry_p = filp->f_dentry;
+	}
+	rsbac_attribute_value.ioctl_cmd = cmd;
+	if(   (rsbac_request != R_NONE)
+			&& !rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_ioctl_cmd,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	ext3_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/ext3/namei.c linux-2.6.31-rsbac-1.4.2/fs/ext3/namei.c
--- trunk/fs/ext3/namei.c	2009-09-10 18:15:04.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/ext3/namei.c	2009-09-10 18:17:43.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
 #include <linux/fcntl.h>
+#include <linux/security.h>
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/quotaops.h>
@@ -41,6 +42,8 @@
 #include "xattr.h"
 #include "acl.h"
 
+#include <rsbac/hooks.h>
+
 /*
  * define how far ahead to read directories while searching them.
  */
@@ -2132,6 +2135,20 @@ static int ext3_unlink(struct inode * di
 
 	inode = dentry->d_inode;
 
+#ifdef CONFIG_RSBAC_SECDEL
+	/* Clear content and sync */
+	if(inode->i_nlink == 1) {
+		ext3_journal_stop(handle);
+		rsbac_sec_del(dentry, TRUE);
+		handle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));
+		if (IS_ERR(handle))
+			return PTR_ERR(handle);
+
+		if (IS_DIRSYNC(dir))
+			handle->h_sync = 1;
+	}
+#endif
+
 	retval = -EIO;
 	if (le32_to_cpu(de->inode) != inode->i_ino)
 		goto end_unlink;
@@ -2145,6 +2162,7 @@ static int ext3_unlink(struct inode * di
 	retval = ext3_delete_entry(handle, dir, de, bh);
 	if (retval)
 		goto end_unlink;
+
 	dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;
 	ext3_update_dx_flag(dir);
 	ext3_mark_inode_dirty(handle, dir);
@@ -2310,6 +2328,24 @@ static int ext3_rename (struct inode * o
 			brelse (new_bh);
 			new_bh = NULL;
 		}
+
+#ifdef CONFIG_RSBAC_SECDEL
+		/* Clear content, but do not sync */
+		else
+			if(new_inode->i_nlink == 1) {
+				ext3_journal_stop(handle);
+				rsbac_sec_del(new_dentry, FALSE);
+				handle = ext3_journal_start(old_dir, 2 *
+						EXT3_DATA_TRANS_BLOCKS(old_dir->i_sb) +
+						EXT3_INDEX_EXTRA_TRANS_BLOCKS + 2);
+				if (IS_ERR(handle))
+					return PTR_ERR(handle);
+
+				if (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))
+					handle->h_sync = 1;
+			}
+#endif
+
 	}
 	if (S_ISDIR(old_inode->i_mode)) {
 		if (new_inode) {
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/ext4/ioctl.c linux-2.6.31-rsbac-1.4.2/fs/ext4/ioctl.c
--- trunk/fs/ext4/ioctl.c	2009-09-10 18:15:04.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/ext4/ioctl.c	2009-09-10 18:17:43.000000000 +0200
@@ -18,12 +18,93 @@
 #include "ext4_jbd2.h"
 #include "ext4.h"
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
+
 long ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	struct inode *inode = filp->f_dentry->d_inode;
 	struct ext4_inode_info *ei = EXT4_I(inode);
 	unsigned int flags;
 
+#ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t rsbac_request;
+        enum  rsbac_target_t rsbac_target = T_NONE;
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+
+        rsbac_pr_debug(aef, "calling ADF\n");
+        switch (cmd) {
+#ifdef CONFIG_JBD2_DEBUG
+                case EXT4_IOC_WAIT_FOR_READONLY:
+#endif
+                case EXT4_IOC_GETFLAGS:
+                case EXT4_IOC_GETVERSION:
+                case EXT4_IOC_GETVERSION_OLD:
+                case EXT4_IOC_GETRSVSZ:
+                        rsbac_request = R_GET_PERMISSIONS_DATA;
+                        break;
+                case EXT4_IOC_SETFLAGS:
+                case EXT4_IOC_SETVERSION:
+                case EXT4_IOC_SETVERSION_OLD:
+                case EXT4_IOC_SETRSVSZ:
+                case EXT4_IOC_GROUP_EXTEND:
+                case EXT4_IOC_GROUP_ADD:
+		case EXT4_IOC_MIGRATE:
+                        rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+                        break;
+                default:
+                        rsbac_request = R_NONE;
+        }
+        if(S_ISSOCK(inode->i_mode)) {
+                if(SOCKET_I(inode)->ops
+                                && (SOCKET_I(inode)->ops->family == AF_UNIX)) {
+                        rsbac_target = T_UNIXSOCK;
+                        rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+                        rsbac_target_id.unixsock.inode  = inode->i_ino;
+                        rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+
+                }
+#ifdef CONFIG_RSBAC_NET_OBJ
+                else {
+                        rsbac_target = T_NETOBJ;
+                        rsbac_target_id.netobj.sock_p
+                                = SOCKET_I(inode);
+                        rsbac_target_id.netobj.local_addr = NULL;
+                        rsbac_target_id.netobj.local_len = 0;
+                        rsbac_target_id.netobj.remote_addr = NULL;
+                        rsbac_target_id.netobj.remote_len = 0;
+                }
+#endif
+	        }
+        else {
+                if (S_ISDIR(inode->i_mode))
+                        rsbac_target = T_DIR;
+                else if (S_ISFIFO(inode->i_mode))
+                        rsbac_target = T_FIFO;
+                else if (S_ISLNK(inode->i_mode))
+                        rsbac_target = T_SYMLINK;
+                else
+                        rsbac_target = T_FILE;
+                rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+                rsbac_target_id.file.inode  = inode->i_ino;
+                rsbac_target_id.file.dentry_p = filp->f_dentry;
+        }
+        rsbac_attribute_value.ioctl_cmd = cmd;
+        if(   (rsbac_request != R_NONE)
+                        && !rsbac_adf_request(rsbac_request,
+                                task_pid(current),
+                                rsbac_target,
+                                rsbac_target_id,
+                                A_ioctl_cmd,
+                                rsbac_attribute_value))
+        {
+                return -EPERM;
+        }
+#endif
+
 	ext4_debug("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/ext4/namei.c linux-2.6.31-rsbac-1.4.2/fs/ext4/namei.c
--- trunk/fs/ext4/namei.c	2009-09-10 18:15:04.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/ext4/namei.c	2009-09-10 18:17:43.000000000 +0200
@@ -40,6 +40,8 @@
 #include "xattr.h"
 #include "acl.h"
 
+#include <rsbac/hooks.h>
+
 /*
  * define how far ahead to read directories while searching them.
  */
@@ -2215,6 +2217,20 @@ static int ext4_unlink(struct inode *dir
 
 	inode = dentry->d_inode;
 
+#ifdef CONFIG_RSBAC_SECDEL
+        /* Clear content and sync */
+        if(inode->i_nlink == 1) {
+                ext4_journal_stop(handle);
+                rsbac_sec_del(dentry, TRUE);
+                handle = ext4_journal_start(dir, EXT4_DELETE_TRANS_BLOCKS(dir->i_sb));
+                if (IS_ERR(handle))
+                        return PTR_ERR(handle);
+
+                if (IS_DIRSYNC(dir))
+                        handle->h_sync = 1;
+        }
+#endif
+
 	retval = -EIO;
 	if (le32_to_cpu(de->inode) != inode->i_ino)
 		goto end_unlink;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/fat/namei_msdos.c linux-2.6.31-rsbac-1.4.2/fs/fat/namei_msdos.c
--- trunk/fs/fat/namei_msdos.c	2009-09-10 18:15:03.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/fat/namei_msdos.c	2009-09-10 18:17:43.000000000 +0200
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/time.h>
 #include <linux/buffer_head.h>
+#include <rsbac/hooks.h>
 #include "fat.h"
 
 /* Characters that are undesirable in an MS-DOS file name */
@@ -433,6 +434,9 @@ static int msdos_unlink(struct inode *di
 	clear_nlink(inode);
 	inode->i_ctime = CURRENT_TIME_SEC;
 	fat_detach(inode);
+#ifdef CONFIG_RSBAC_SECDEL
+        rsbac_sec_del(dentry, TRUE);
+#endif
 out:
 	unlock_super(sb);
 	if (!err)
@@ -526,6 +530,11 @@ static int do_msdos_rename(struct inode 
 	}
 	new_dir->i_version++;
 
+#ifdef CONFIG_RSBAC_SECDEL
+        if (new_inode && (new_inode->i_nlink == 1))
+		rsbac_sec_del(new_dentry, TRUE);
+#endif
+
 	fat_detach(old_inode);
 	fat_attach(old_inode, new_i_pos);
 	if (is_hid)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/fat/namei_vfat.c linux-2.6.31-rsbac-1.4.2/fs/fat/namei_vfat.c
--- trunk/fs/fat/namei_vfat.c	2009-09-10 18:15:03.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/fat/namei_vfat.c	2009-09-10 18:17:43.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/slab.h>
 #include <linux/buffer_head.h>
 #include <linux/namei.h>
+#include <rsbac/hooks.h>
 #include "fat.h"
 
 /*
@@ -844,6 +845,10 @@ static int vfat_unlink(struct inode *dir
 	if (err)
 		goto out;
 
+#ifdef CONFIG_RSBAC_SECDEL
+        rsbac_sec_del(dentry, TRUE);
+#endif
+
 	err = fat_remove_entries(dir, &sinfo);	/* and releases bh */
 	if (err)
 		goto out;
@@ -940,6 +945,11 @@ static int vfat_rename(struct inode *old
 			if (err)
 				goto out;
 		}
+#ifdef CONFIG_RSBAC_SECDEL
+		else
+			if(new_inode->i_nlink == 1)
+				rsbac_sec_del(new_dentry, TRUE);
+#endif
 		new_i_pos = MSDOS_I(new_inode)->i_pos;
 		fat_detach(new_inode);
 	} else {
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/fcntl.c linux-2.6.31-rsbac-1.4.2/fs/fcntl.c
--- trunk/fs/fcntl.c	2009-09-10 18:14:54.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/fcntl.c	2009-09-10 18:17:38.000000000 +0200
@@ -23,6 +23,7 @@
 #include <asm/poll.h>
 #include <asm/siginfo.h>
 #include <asm/uaccess.h>
+#include <rsbac/hooks.h>
 
 void set_close_on_exec(unsigned int fd, int flag)
 {
@@ -268,6 +269,11 @@ static long do_fcntl(int fd, unsigned in
 {
 	long err = -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	switch (cmd) {
 	case F_DUPFD:
 	case F_DUPFD_CLOEXEC:
@@ -311,6 +317,24 @@ static long do_fcntl(int fd, unsigned in
 		force_successful_syscall_return();
 		break;
 	case F_SETOWN:
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rcu_read_lock();
+		rsbac_target_id.process = find_vpid(arg);
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_SEND_SIGNAL,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rcu_read_unlock();
+			err = -EPERM;
+			break;
+		}
+		rcu_read_unlock();
+#endif
 		err = f_setown(filp, arg, 1);
 		break;
 	case F_GETSIG:
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/hugetlbfs/inode.c linux-2.6.31-rsbac-1.4.2/fs/hugetlbfs/inode.c
--- trunk/fs/hugetlbfs/inode.c	2009-09-10 18:14:54.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/hugetlbfs/inode.c	2009-09-10 18:17:38.000000000 +0200
@@ -34,6 +34,10 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /* some random number */
 #define HUGETLBFS_MAGIC	0x958458f6
 
@@ -1028,6 +1032,9 @@ static int __init init_hugetlbfs_fs(void
 
 	if (!IS_ERR(vfsmount)) {
 		hugetlbfs_vfsmount = vfsmount;
+#ifdef CONFIG_RSBAC
+		rsbac_mount(hugetlbfs_vfsmount);
+#endif
 		return 0;
 	}
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/ioctl.c linux-2.6.31-rsbac-1.4.2/fs/ioctl.c
--- trunk/fs/ioctl.c	2009-09-10 18:14:58.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/ioctl.c	2009-09-10 18:17:40.000000000 +0200
@@ -19,6 +19,11 @@
 
 #include <asm/ioctls.h>
 
+#ifdef CONFIG_RSBAC_IOCTL
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
+
 /* So that the fiemap access checks can't overflow on 32 bit machines. */
 #define FIEMAP_MAX_EXTENTS	(UINT_MAX / sizeof(struct fiemap_extent))
 
@@ -39,9 +44,78 @@ static long vfs_ioctl(struct file *filp,
 {
 	int error = -ENOTTY;
 
+#ifdef CONFIG_RSBAC_IOCTL
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!filp->f_op)
 		goto out;
 
+#ifdef CONFIG_RSBAC_IOCTL
+	if (S_ISBLK(filp->f_dentry->d_inode->i_mode)) {
+		rsbac_target = T_DEV;
+		rsbac_target_id.dev.type = D_block;
+		rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+	}
+	else
+		if (S_ISCHR(filp->f_dentry->d_inode->i_mode)) {
+			rsbac_target = T_DEV;
+			rsbac_target_id.dev.type = D_char;
+			rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+			rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+		}
+		else
+			if (S_ISSOCK(filp->f_dentry->d_inode->i_mode)) {
+				if (   SOCKET_I(filp->f_dentry->d_inode)->ops
+						&& (SOCKET_I(filp->f_dentry->d_inode)->ops->family == AF_UNIX)
+				  ) {
+					if (filp->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+						rsbac_target = T_IPC;
+						rsbac_target_id.ipc.type = I_anonunix;
+						rsbac_target_id.ipc.id.id_nr = filp->f_dentry->d_inode->i_ino;
+					}
+					else {
+						rsbac_target = T_UNIXSOCK;
+						rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+						rsbac_target_id.unixsock.inode  = filp->f_dentry->d_inode->i_ino;
+						rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+					}
+				}
+				else {
+#ifdef CONFIG_RSBAC_NET_OBJ
+					rsbac_target = T_NETOBJ;
+					rsbac_target_id.netobj.sock_p
+						= SOCKET_I(filp->f_dentry->d_inode);
+					rsbac_target_id.netobj.local_addr = NULL;
+					rsbac_target_id.netobj.local_len = 0;
+					rsbac_target_id.netobj.remote_addr = NULL;
+					rsbac_target_id.netobj.remote_len = 0;
+#else
+					rsbac_target = T_NONE;
+#endif
+				}
+			}
+			else
+				rsbac_target = T_NONE;
+	if (rsbac_target != T_NONE) {
+		rsbac_pr_debug(aef, "[sys_ioctl()]: calling ADF\n");
+		rsbac_attribute_value.ioctl_cmd = cmd;
+		if (!rsbac_adf_request(R_IOCTL,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_ioctl_cmd,
+					rsbac_attribute_value))
+		{
+			error = -EPERM;
+			goto out;
+		}
+	}
+#endif
+
 	if (filp->f_op->unlocked_ioctl) {
 		error = filp->f_op->unlocked_ioctl(filp, cmd, arg);
 		if (error == -ENOIOCTLCMD)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/ioprio.c linux-2.6.31-rsbac-1.4.2/fs/ioprio.c
--- trunk/fs/ioprio.c	2009-09-10 18:14:54.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/ioprio.c	2009-09-10 18:17:37.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/capability.h>
 #include <linux/syscalls.h>
 #include <linux/security.h>
+#include <rsbac/hooks.h>
 #include <linux/pid_namespace.h>
 
 int set_task_ioprio(struct task_struct *task, int ioprio)
@@ -81,6 +82,25 @@ SYSCALL_DEFINE3(ioprio_set, int, which, 
 	struct pid *pgrp;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_priority;
+	rsbac_attribute_value.priority = ioprio;
+
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_priority,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	switch (class) {
 		case IOPRIO_CLASS_RT:
 			if (!capable(CAP_SYS_ADMIN))
@@ -160,6 +180,25 @@ static int get_task_ioprio(struct task_s
 {
 	int ret;
 
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_priority;
+        rsbac_attribute_value.dummy = 0;
+
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                task_pid(current),
+                                T_SCD,
+                                rsbac_target_id,
+                                A_none,
+                                rsbac_attribute_value))
+        {
+                return -EPERM;
+        }
+#endif
+
 	ret = security_task_getioprio(p);
 	if (ret)
 		goto out;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/jfs/namei.c linux-2.6.31-rsbac-1.4.2/fs/jfs/namei.c
--- trunk/fs/jfs/namei.c	2009-09-10 18:14:57.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/jfs/namei.c	2009-09-10 18:17:40.000000000 +0200
@@ -32,6 +32,8 @@
 #include "jfs_acl.h"
 #include "jfs_debug.h"
 
+#include <rsbac/hooks.h>
+
 /*
  * forward references
  */
@@ -488,6 +490,12 @@ static int jfs_unlink(struct inode *dip,
 	if ((rc = get_UCSname(&dname, dentry)))
 		goto out;
 
+	/* RSBAC jfs_unlink */
+#ifdef CONFIG_RSBAC_SECDEL
+	if(dentry->d_inode->i_nlink == 1)
+		rsbac_sec_del(dentry, TRUE);
+#endif
+	
 	IWRITE_LOCK(ip, RDWRLOCK_NORMAL);
 
 	tid = txBegin(dip->i_sb, 0);
@@ -1134,6 +1142,10 @@ static int jfs_rename(struct inode *old_
 			goto out3;
 		}
 	} else if (new_ip) {
+#ifdef CONFIG_RSBAC_SECDEL
+		if (new_ip->i_nlink == 1)
+			rsbac_sec_del(new_dentry, TRUE);
+#endif
 		IWRITE_LOCK(new_ip, RDWRLOCK_NORMAL);
 		/* Init inode for quota operations. */
 		vfs_dq_init(new_ip);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/libfs.c linux-2.6.31-rsbac-1.4.2/fs/libfs.c
--- trunk/fs/libfs.c	2009-09-10 18:14:52.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/libfs.c	2009-09-10 18:17:36.000000000 +0200
@@ -14,6 +14,10 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 int simple_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		   struct kstat *stat)
 {
@@ -487,6 +491,10 @@ int simple_pin_fs(struct file_system_typ
 		mnt = vfs_kern_mount(type, 0, type->name, NULL);
 		if (IS_ERR(mnt))
 			return PTR_ERR(mnt);
+#ifdef CONFIG_RSBAC
+		else
+			rsbac_mount(mnt);
+#endif
 		spin_lock(&pin_fs_lock);
 		if (!*mount)
 			*mount = mnt;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/locks.c linux-2.6.31-rsbac-1.4.2/fs/locks.c
--- trunk/fs/locks.c	2009-09-10 18:14:54.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/locks.c	2009-09-10 18:17:38.000000000 +0200
@@ -130,6 +130,8 @@
 
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 #define IS_POSIX(fl)	(fl->fl_flags & FL_POSIX)
 #define IS_FLOCK(fl)	(fl->fl_flags & FL_FLOCK)
 #define IS_LEASE(fl)	(fl->fl_flags & FL_LEASE)
@@ -1572,6 +1574,12 @@ SYSCALL_DEFINE2(flock, unsigned int, fd,
 	int can_sleep, unlock;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = -EBADF;
 	filp = fget(fd);
 	if (!filp)
@@ -1585,6 +1593,39 @@ SYSCALL_DEFINE2(flock, unsigned int, fd,
 	    !(filp->f_mode & (FMODE_READ|FMODE_WRITE)))
 		goto out_putf;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+        rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+        rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+	if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+        else if (S_ISSOCK(filp->f_dentry->d_inode->i_mode)) {
+          if(filp->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+            rsbac_target = T_IPC;
+            rsbac_target_id.ipc.type = I_anonunix;
+            rsbac_target_id.ipc.id.id_nr = filp->f_dentry->d_inode->i_ino;
+          } else
+            rsbac_target = T_UNIXSOCK;
+        }
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_LOCK,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto out_putf;
+	}
+#endif
+
 	error = flock_make_lock(filp, &lock, cmd);
 	if (error)
 		goto out_putf;
@@ -1670,6 +1711,12 @@ int fcntl_getlk(struct file *filp, struc
 	struct flock flock;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = -EFAULT;
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
@@ -1681,6 +1728,33 @@ int fcntl_getlk(struct file *filp, struc
 	if (error)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_fcntl()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = filp->f_dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto out;
+	}
+#endif
+
 	error = vfs_test_lock(filp, &file_lock);
 	if (error)
 		goto out;
@@ -1776,6 +1850,12 @@ int fcntl_setlk(unsigned int fd, struct 
 	struct file *f;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (file_lock == NULL)
 		return -ENOLCK;
 
@@ -1804,6 +1884,39 @@ again:
 		file_lock->fl_flags |= FL_SLEEP;
 	}
 	
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_fcntl()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = filp->f_dentry;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(filp->f_dentry->d_inode->i_mode)) {
+		if(filp->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = filp->f_dentry->d_inode->i_ino;
+		} else
+			rsbac_target = T_UNIXSOCK;
+	}
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_LOCK,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto out;
+	}
+#endif
+
 	error = -EBADF;
 	switch (flock.l_type) {
 	case F_RDLCK:
@@ -1855,6 +1968,12 @@ int fcntl_getlk64(struct file *filp, str
 	struct flock64 flock;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = -EFAULT;
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
@@ -1866,6 +1985,33 @@ int fcntl_getlk64(struct file *filp, str
 	if (error)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_fcntl()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = filp->f_dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto out;
+	}
+#endif
+
 	error = vfs_test_lock(filp, &file_lock);
 	if (error)
 		goto out;
@@ -1894,6 +2040,12 @@ int fcntl_setlk64(unsigned int fd, struc
 	struct file *f;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (file_lock == NULL)
 		return -ENOLCK;
 
@@ -1939,6 +2091,39 @@ again:
 		goto out;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_fcntl()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = filp->f_dentry;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(filp->f_dentry->d_inode->i_mode)) {
+		if(filp->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = filp->f_dentry->d_inode->i_ino;
+		} else
+			rsbac_target = T_UNIXSOCK;
+	}
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_LOCK,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto out;
+	}
+#endif
+
 	error = do_lock_file_wait(filp, cmd, file_lock);
 
 	/*
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/minix/namei.c linux-2.6.31-rsbac-1.4.2/fs/minix/namei.c
--- trunk/fs/minix/namei.c	2009-09-10 18:14:59.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/minix/namei.c	2009-09-10 18:17:41.000000000 +0200
@@ -6,6 +6,8 @@
 
 #include "minix.h"
 
+#include <rsbac/hooks.h>
+
 static int add_nondir(struct dentry *dentry, struct inode *inode)
 {
 	int err = minix_add_link(dentry, inode);
@@ -164,6 +166,11 @@ static int minix_unlink(struct inode * d
 	if (err)
 		goto end_unlink;
 
+#ifdef CONFIG_RSBAC_SECDEL
+	if (inode->i_nlink == 1)
+		rsbac_sec_del(dentry, TRUE);
+#endif
+
 	inode->i_ctime = dir->i_ctime;
 	inode_dec_link_count(inode);
 end_unlink:
@@ -220,6 +227,12 @@ static int minix_rename(struct inode * o
 		new_de = minix_find_entry(new_dentry, &new_page);
 		if (!new_de)
 			goto out_dir;
+                
+#ifdef CONFIG_RSBAC_SECDEL
+		if (new_inode->i_nlink == 1)
+			rsbac_sec_del(new_dentry, TRUE);
+#endif
+
 		inode_inc_link_count(old_inode);
 		minix_set_link(new_de, new_page, old_inode);
 		new_inode->i_ctime = CURRENT_TIME_SEC;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/namei.c linux-2.6.31-rsbac-1.4.2/fs/namei.c
--- trunk/fs/namei.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/namei.c	2009-09-10 18:17:37.000000000 +0200
@@ -34,6 +34,7 @@
 #include <linux/device_cgroup.h>
 #include <linux/fs_struct.h>
 #include <asm/uaccess.h>
+#include <rsbac/hooks.h>
 
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 
@@ -242,6 +243,12 @@ int inode_permission(struct inode *inode
 {
 	int retval;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_FULL
+	if (rsbac_dac_disable)
+	  return 0;
+#endif
+
+
 	if (mask & MAY_WRITE) {
 		umode_t mode = inode->i_mode;
 
@@ -633,8 +640,19 @@ static __always_inline int __do_follow_l
 	if (!IS_ERR(cookie)) {
 		char *s = nd_get_link(nd);
 		error = 0;
-		if (s)
+		if (s) {
+#ifdef CONFIG_RSBAC_SYM_REDIR
+			char * rsbac_name;
+
+			rsbac_name = rsbac_symlink_redirect(dentry, s, PAGE_SIZE);
+			if (rsbac_name) {
+				error = __vfs_follow_link(nd, rsbac_name);
+				kfree(rsbac_name);
+			}
+			else
+#endif
 			error = __vfs_follow_link(nd, s);
+                }
 		if (dentry->d_inode->i_op->put_link)
 			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
 	}
@@ -653,6 +671,12 @@ static __always_inline int __do_follow_l
 static inline int do_follow_link(struct path *path, struct nameidata *nd)
 {
 	int err = -ELOOP;
+
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (current->link_count >= MAX_NESTED_LINKS)
 		goto loop;
 	if (current->total_link_count >= 40)
@@ -662,6 +686,28 @@ static inline int do_follow_link(struct 
 	err = security_inode_follow_link(path->dentry, nd);
 	if (err)
 		goto loop;
+
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.dir.device = path->dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = path->dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path->dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEARCH,
+				task_pid(current),
+				T_SYMLINK,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+		err = -ENOENT;
+#else
+		err = -EPERM;
+#endif
+		goto loop;
+	}
+#endif
+
 	current->link_count++;
 	current->total_link_count++;
 	nd->depth++;
@@ -836,6 +882,11 @@ static int __link_path_walk(const char *
 	int err;
 	unsigned int lookup_flags = nd->flags;
 	
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	while (*name=='/')
 		name++;
 	if (!*name)
@@ -852,6 +903,11 @@ static int __link_path_walk(const char *
 		unsigned int c;
 
 		nd->flags |= LOOKUP_CONTINUE;
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+		if (rsbac_dac_part_disabled(nd->path.dentry))
+			err = 0;
+		else
+#endif
 		err = exec_permission_lite(inode);
 		if (err == -EAGAIN)
 			err = inode_permission(nd->path.dentry->d_inode,
@@ -862,6 +918,27 @@ static int __link_path_walk(const char *
  		if (err)
 			break;
 
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.dir.device = inode->i_sb->s_dev;
+		rsbac_target_id.dir.inode  = inode->i_ino;
+		rsbac_target_id.dir.dentry_p = nd->path.dentry;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_SEARCH,
+					task_pid(current),
+					T_DIR,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+			err = -ENOENT;
+#else
+			err = -EPERM;
+#endif
+			break;
+		}
+#endif
+
 		this.name = name;
 		c = *(const unsigned char *)name;
 
@@ -1005,6 +1082,23 @@ return_reval:
 				break;
 		}
 return_base:
+
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+		rsbac_target_id.dir.device = nd->path.dentry->d_inode->i_sb->s_dev;
+		rsbac_target_id.dir.inode  = nd->path.dentry->d_inode->i_ino;
+		rsbac_target_id.dir.dentry_p = nd->path.dentry;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_SEARCH,
+					task_pid(current),
+					T_DIR,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			path_put(&nd->path);
+			return -ENOENT;
+		}
+#endif
 		return 0;
 out_dput:
 		path_put_conditional(&next, nd);
@@ -1178,8 +1272,31 @@ static struct dentry *__lookup_hash(stru
 	struct inode *inode;
 	int err;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	inode = base->d_inode;
 
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.dir.device = inode->i_sb->s_dev;
+	rsbac_target_id.dir.inode  = inode->i_ino;
+	rsbac_target_id.dir.dentry_p = base;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEARCH,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		dentry = ERR_PTR(err);
+		goto out;
+	}
+#endif
+
 	/*
 	 * See if the low-level filesystem might want
 	 * to use its own hash..
@@ -1223,6 +1340,11 @@ static struct dentry *lookup_hash(struct
 {
 	int err;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if (rsbac_dac_part_disabled(nd->path.dentry))
+		err = 0;
+	else
+#endif
 	err = inode_permission(nd->path.dentry->d_inode, MAY_EXEC);
 	if (err)
 		return ERR_PTR(err);
@@ -1279,6 +1401,82 @@ struct dentry *lookup_one_len(const char
 	return __lookup_hash(&this, base, NULL);
 }
 
+/* RSBAC
+ * I hate to put new functions into this file, but even more I hate removing
+ * all statics from all the lookup helpers in here...
+ * Still, I need some form of RSBAC bypass for internal file access.
+ * Amon Ott <ao@rsbac.org>
+ */
+#ifdef CONFIG_RSBAC
+static struct dentry * __rsbac_lookup_hash(struct qstr *name, struct dentry * base, struct nameidata *nd)
+{
+	struct dentry * dentry;
+	struct inode *inode;
+	int err;
+
+	inode = base->d_inode;
+
+	/*
+	 * See if the low-level filesystem might want
+	 * to use its own hash..
+	 */
+	if (base->d_op && base->d_op->d_hash) {
+		err = base->d_op->d_hash(base, name);
+		dentry = ERR_PTR(err);
+		if (err < 0)
+			goto out;
+	}
+
+	dentry = cached_lookup(base, name, nd);
+	if (!dentry) {
+		struct dentry *new = d_alloc(base, name);
+		dentry = ERR_PTR(-ENOMEM);
+		if (!new)
+			goto out;
+		dentry = inode->i_op->lookup(inode, new, nd);
+		if (!dentry)
+			dentry = new;
+		else
+			dput(new);
+	}
+out:
+	return dentry;
+}
+
+struct dentry * rsbac_lookup_hash(struct qstr *name, struct dentry * base)
+{
+	return __rsbac_lookup_hash(name, base, NULL);
+}
+
+/* SMP-safe */
+struct dentry * rsbac_lookup_one_len(const char * name, struct dentry * base, int len)
+{
+	unsigned long hash;
+	struct qstr this;
+	unsigned int c;
+
+	this.name = name;
+	this.len = len;
+	if (!len)
+		goto access;
+
+	hash = init_name_hash();
+	while (len--) {
+		c = *(const unsigned char *)name++;
+		if (c == '/' || c == '\0')
+			goto access;
+		hash = partial_name_hash(c, hash);
+	}
+	this.hash = end_name_hash(hash);
+
+	return rsbac_lookup_hash(&this, base);
+access:
+	return ERR_PTR(-EACCES);
+}
+
+EXPORT_SYMBOL(rsbac_lookup_one_len);
+#endif
+
 /**
  * lookup_one_noperm - bad hack for sysfs
  * @name:	pathname component to lookup
@@ -1383,6 +1581,11 @@ static int may_delete(struct inode *dir,
 	BUG_ON(victim->d_parent->d_inode != dir);
 	audit_inode_child(victim->d_name.name, victim, dir);
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if (rsbac_dac_part_disabled(victim))
+		error = 0;
+	else
+#endif
 	error = inode_permission(dir, MAY_WRITE | MAY_EXEC);
 	if (error)
 		return error;
@@ -1419,6 +1622,12 @@ static inline int may_create(struct inod
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
+
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if (rsbac_dac_part_disabled(child->d_parent))
+		return 0;
+	else
+#endif
 	return inode_permission(dir, MAY_WRITE | MAY_EXEC);
 }
 
@@ -1485,6 +1694,14 @@ int vfs_create(struct inode *dir, struct
 {
 	int error = may_create(dir, dentry);
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	enum  rsbac_target_t rsbac_new_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -1495,10 +1712,53 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[open_namei() [filp_open() [do_open() [sys_open()]]]]: calling ADF\n");
+	rsbac_target = T_DIR;
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dir->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry->d_parent;
+	rsbac_attribute_value.create_data.target = T_FILE;
+	rsbac_attribute_value.create_data.dentry_p = dentry;
+	rsbac_attribute_value.create_data.mode = mode;
+	rsbac_attribute_value.create_data.device = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_create_data,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	vfs_dq_init(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
-	if (!error)
+	if (!error) {
 		fsnotify_create(dir, dentry);
+
+		/* RSBAC: notify ADF of new file */
+#ifdef CONFIG_RSBAC
+		{
+			rsbac_new_target = T_FILE;
+			rsbac_new_target_id.file.device = dentry->d_sb->s_dev;
+			rsbac_new_target_id.file.inode  = dentry->d_inode->i_ino;
+			rsbac_new_target_id.file.dentry_p = dentry;
+			if (rsbac_adf_set_attr(R_CREATE,
+						task_pid(current),
+						rsbac_target,
+						rsbac_target_id,
+						rsbac_new_target,
+						rsbac_new_target_id,
+						A_create_data,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"vfs_create() [open_namei() [filp_open() [do_open() [sys_open()]]]]: rsbac_adf_set_attr() returned error");
+			}
+		}
+#endif
+	}
 	return error;
 }
 
@@ -1508,6 +1768,14 @@ int may_open(struct path *path, int acc_
 	struct inode *inode = dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t rsbac_adf_req;
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!inode)
 		return -ENOENT;
 
@@ -1529,6 +1797,12 @@ int may_open(struct path *path, int acc_
 		break;
 	}
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if (rsbac_dac_part_disabled(dentry))
+		error = 0;
+	else
+#endif
+
 	error = inode_permission(inode, acc_mode);
 	if (error)
 		return error;
@@ -1556,6 +1830,69 @@ int may_open(struct path *path, int acc_
 			goto err_out;
 		}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[open_namei() [filp_open() [do_open() [sys_open()]]]]: calling ADF\n");
+	/* get target type and id clear */
+	if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)){
+		rsbac_target = T_DEV;
+		if (S_ISBLK(inode->i_mode)) {
+			rsbac_target_id.dev.type = D_block;
+		}
+		else {
+			rsbac_target_id.dev.type = D_char;
+		}
+		rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+	}
+	else { /* must be file, dir or fifo */
+		if (S_ISDIR(inode->i_mode))
+			rsbac_target = T_DIR;
+		else if (S_ISSOCK(inode->i_mode))
+			rsbac_target = T_UNIXSOCK;
+		else if (S_ISFIFO(inode->i_mode)) {
+			if (inode->i_sb->s_magic != PIPEFS_MAGIC)
+				rsbac_target = T_FIFO;
+			else
+				rsbac_target = T_NONE;
+		}
+		else
+			rsbac_target = T_FILE;
+
+		rsbac_target_id.file.device = inode->i_sb->s_dev;
+		rsbac_target_id.file.inode  = inode->i_ino;
+		rsbac_target_id.file.dentry_p = dentry;
+	}
+	/* determine request type */
+	rsbac_adf_req = R_NONE;
+	if (flag & O_APPEND)
+		rsbac_adf_req = R_APPEND_OPEN;
+	else
+		if ((flag & FMODE_WRITE) && (flag & FMODE_READ))
+			rsbac_adf_req = R_READ_WRITE_OPEN;
+		else
+			if (flag & FMODE_WRITE)
+				rsbac_adf_req = R_WRITE_OPEN;
+			else
+				if (flag & FMODE_READ) {
+					if (rsbac_target == T_DIR)
+						rsbac_adf_req = R_READ;
+					else
+						rsbac_adf_req = R_READ_OPEN;
+				}
+	if ((rsbac_adf_req != R_NONE) && (rsbac_target != T_NONE)) {
+		rsbac_attribute_value.open_flag = flag;
+		if (!rsbac_adf_request(rsbac_adf_req,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_open_flag,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+	}
+#endif
+
 	/*
 	 * Ensure there are no outstanding leases on the file.
 	 */
@@ -1589,6 +1926,24 @@ int may_open(struct path *path, int acc_
 		if (flag & FMODE_WRITE)
 			vfs_dq_init(inode);
 
+#ifdef CONFIG_RSBAC
+	if ((rsbac_adf_req != R_NONE) && (rsbac_target != T_NONE)) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(rsbac_adf_req,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_open_flag,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"open_namei() [filp_open() [do_open() [sys_open()]]]: rsbac_adf_set_attr() returned error\n");
+		}
+	}
+#endif
+
 	return 0;
 err_out:
 	ima_counts_put(path, acc_mode ?
@@ -1676,6 +2031,11 @@ struct file *do_filp_open(int dfd, const
 	int will_write;
 	int flag = open_to_namei_flags(open_flag);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!acc_mode)
 		acc_mode = MAY_OPEN | ACC_MODE(flag);
 
@@ -1874,6 +2234,24 @@ do_link:
 	error = security_inode_follow_link(path.dentry, &nd);
 	if (error)
 		goto exit_dput;
+
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.dir.device = path.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEARCH,
+				task_pid(current),
+				T_SYMLINK,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto exit_dput;
+	}
+#endif
+
 	error = __do_follow_link(&path, &nd);
 	if (error) {
 		/* Does someone understand code flow here? Or it is only
@@ -1982,6 +2360,13 @@ int vfs_mknod(struct inode *dir, struct 
 {
 	int error = may_create(dir, dentry);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	enum  rsbac_target_t rsbac_new_target;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -1999,10 +2384,58 @@ int vfs_mknod(struct inode *dir, struct 
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_mknod()]: calling ADF\n");
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dir->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry->d_parent;
+	rsbac_attribute_value.create_data.target = T_FILE;
+	rsbac_attribute_value.create_data.dentry_p = dentry;
+	rsbac_attribute_value.create_data.mode = mode;
+	rsbac_attribute_value.create_data.device = dev;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_create_data,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	vfs_dq_init(dir);
 	error = dir->i_op->mknod(dir, dentry, mode, dev);
-	if (!error)
+	if (!error) {
 		fsnotify_create(dir, dentry);
+
+#ifdef CONFIG_RSBAC
+		if (S_ISFIFO(dentry->d_inode->i_mode))
+			rsbac_new_target = T_FIFO;
+		else
+			if (S_ISLNK(dentry->d_inode->i_mode))
+				rsbac_new_target = T_SYMLINK;
+			else
+				if (S_ISSOCK(dentry->d_inode->i_mode))
+					rsbac_new_target = T_UNIXSOCK;
+				else
+					rsbac_new_target = T_FILE;
+		rsbac_new_target_id.dir.device = dentry->d_sb->s_dev;
+		rsbac_new_target_id.dir.inode  = dentry->d_inode->i_ino;
+		rsbac_new_target_id.dir.dentry_p = dentry;
+		if (rsbac_adf_set_attr(R_CREATE,
+					task_pid(current),
+					T_DIR,
+					rsbac_target_id,
+					rsbac_new_target,
+					rsbac_new_target_id,
+					A_create_data,
+					rsbac_attribute_value))
+		{
+			rsbac_pr_debug(aef, "[do_mknod(), sys_mknod()]: rsbac_adf_set_attr() returned error");
+		}
+#endif
+	}
 	return error;
 }
 
@@ -2087,6 +2520,12 @@ int vfs_mkdir(struct inode *dir, struct 
 {
 	int error = may_create(dir, dentry);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -2098,10 +2537,49 @@ int vfs_mkdir(struct inode *dir, struct 
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_mkdir()]: calling ADF\n");
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dir->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry->d_parent;
+	rsbac_attribute_value.create_data.target = T_DIR;
+	rsbac_attribute_value.create_data.dentry_p = dentry;
+	rsbac_attribute_value.create_data.mode = mode;
+	rsbac_attribute_value.create_data.device = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_create_data,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	vfs_dq_init(dir);
 	error = dir->i_op->mkdir(dir, dentry, mode);
-	if (!error)
+	if (!error) {
 		fsnotify_mkdir(dir, dentry);
+
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.dir.device = dentry->d_sb->s_dev;
+		rsbac_new_target_id.dir.inode  = dentry->d_inode->i_ino;
+		rsbac_new_target_id.dir.dentry_p = dentry;
+		if (rsbac_adf_set_attr(R_CREATE,
+					task_pid(current),
+					T_DIR,
+					rsbac_target_id,
+					T_DIR,
+					rsbac_new_target_id,
+					A_create_data,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"vfs_mkdir() [sys_mkdir()]: rsbac_adf_set_attr() returned error");
+		}
+#endif
+	}
 	return error;
 }
 
@@ -2178,12 +2656,35 @@ int vfs_rmdir(struct inode *dir, struct 
 {
 	int error = may_delete(dir, dentry, 1);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
 	if (!dir->i_op->rmdir)
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_rmdir() [sys_rmdir()]]: calling ADF\n");
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_DELETE,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	vfs_dq_init(dir);
 
 	mutex_lock(&dentry->d_inode->i_mutex);
@@ -2201,6 +2702,24 @@ int vfs_rmdir(struct inode *dir, struct 
 	mutex_unlock(&dentry->d_inode->i_mutex);
 	if (!error) {
 		d_delete(dentry);
+
+#ifdef CONFIG_RSBAC
+		{
+			rsbac_new_target_id.dummy = 0;
+			if (rsbac_adf_set_attr(R_DELETE,
+						task_pid(current),
+						T_DIR,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"vfs_rmdir() [do_rmdir() [sys_rmdir()]]: rsbac_adf_set_attr() returned error");
+			}
+		}
+#endif
 	}
 	dput(dentry);
 
@@ -2265,6 +2784,13 @@ int vfs_unlink(struct inode *dir, struct
 {
 	int error = may_delete(dir, dentry, 0);
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -2278,8 +2804,58 @@ int vfs_unlink(struct inode *dir, struct
 		error = -EBUSY;
 	else {
 		error = security_inode_unlink(dir, dentry);
-		if (!error)
+		if (!error) {
+#ifdef CONFIG_RSBAC
+			rsbac_pr_debug(aef, "[do_unlink() [sys_unlink()]]: calling ADF\n");
+			if (S_ISDIR(dentry->d_inode->i_mode))
+				rsbac_target = T_DIR;
+			else
+				if (S_ISFIFO(dentry->d_inode->i_mode))
+					rsbac_target = T_FIFO;
+				else
+					if (S_ISLNK(dentry->d_inode->i_mode))
+						rsbac_target = T_SYMLINK;
+					else
+						if (S_ISSOCK(dentry->d_inode->i_mode))
+							rsbac_target = T_UNIXSOCK;
+					else
+						rsbac_target = T_FILE;
+			rsbac_target_id.file.device = dentry->d_sb->s_dev;
+			rsbac_target_id.file.inode  = dentry->d_inode->i_ino;
+			rsbac_target_id.file.dentry_p = dentry;
+			rsbac_attribute_value.nlink = dentry->d_inode->i_nlink;
+			if (!rsbac_adf_request(R_DELETE,
+						task_pid(current),
+						rsbac_target,
+						rsbac_target_id,
+						A_nlink,
+						rsbac_attribute_value))
+			{
+				mutex_unlock(&dentry->d_inode->i_mutex);
+				return -EPERM;
+			}
+#endif
+
 			error = dir->i_op->unlink(dir, dentry);
+
+#ifdef CONFIG_RSBAC
+			if (!error) {
+				rsbac_new_target_id.dummy = 0;
+				if (rsbac_adf_set_attr(R_DELETE,
+							task_pid(current),
+							rsbac_target,
+							rsbac_target_id,
+							T_NONE,
+							rsbac_new_target_id,
+							A_nlink,
+							rsbac_attribute_value))
+				{
+					rsbac_printk(KERN_WARNING
+							"vfs_unlink() [do_unlink() [sys_unlink()]]: rsbac_adf_set_attr() returned error\n");
+				}
+			}
+#endif
+		}
 	}
 	mutex_unlock(&dentry->d_inode->i_mutex);
 
@@ -2372,6 +2948,12 @@ int vfs_symlink(struct inode *dir, struc
 {
 	int error = may_create(dir, dentry);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -2382,10 +2964,49 @@ int vfs_symlink(struct inode *dir, struc
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_symlink(), sys_symlink()]: calling ADF\n");
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dir->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry->d_parent;
+	rsbac_attribute_value.create_data.target = T_SYMLINK;
+	rsbac_attribute_value.create_data.dentry_p = dentry;
+	rsbac_attribute_value.create_data.mode = 0;
+	rsbac_attribute_value.create_data.device = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_create_data,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	vfs_dq_init(dir);
 	error = dir->i_op->symlink(dir, dentry, oldname);
-	if (!error)
+	if (!error) {
 		fsnotify_create(dir, dentry);
+
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.file.device = dentry->d_sb->s_dev;
+		rsbac_new_target_id.file.inode  = dentry->d_inode->i_ino;
+		rsbac_new_target_id.file.dentry_p = dentry;
+		if (rsbac_adf_set_attr(R_CREATE,
+					task_pid(current),
+					T_DIR,
+					rsbac_target_id,
+					T_SYMLINK,
+					rsbac_new_target_id,
+					A_create_data,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"vfs_symlink() [do_symlink(), sys_symlink()]: rsbac_adf_set_attr() returned error");
+		}
+#endif
+	}
 	return error;
 }
 
@@ -2441,6 +3062,12 @@ int vfs_link(struct dentry *old_dentry, 
 	struct inode *inode = old_dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!inode)
 		return -ENOENT;
 
@@ -2465,6 +3092,32 @@ int vfs_link(struct dentry *old_dentry, 
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_link() [sys_link()]]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR (old_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO (old_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.dir.device = old_dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = old_dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = old_dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_LINK_HARD,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	vfs_dq_init(dir);
 	error = dir->i_op->link(old_dentry, dir, new_dentry);
@@ -2576,11 +3229,27 @@ static int vfs_rename_dir(struct inode *
 	int error = 0;
 	struct inode *target;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	enum  rsbac_target_t rsbac_target2 = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_target_id2;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	union rsbac_attribute_value_t rsbac_attribute_value2;
+	rsbac_boolean_t target_exists = FALSE;
+#endif
+
 	/*
 	 * If we are going to change the parent - check write permissions,
 	 * we'll need to flip '..'.
 	 */
 	if (new_dir != old_dir) {
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+		if (rsbac_dac_part_disabled(old_dentry))
+			error = 0;
+		else
+#endif
 		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
 		if (error)
 			return error;
@@ -2590,6 +3259,73 @@ static int vfs_rename_dir(struct inode *
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[vfs_rename_dir()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO (old_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = old_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = old_dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = old_dentry;
+	rsbac_attribute_value.new_dir_dentry_p = new_dentry->d_parent;
+	if (!rsbac_adf_request(R_RENAME,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_new_dir_dentry_p,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[vfs_rename_dir()]: calling ADF for WRITE on new_dir\n");
+	rsbac_target_id2.dir.device = new_dentry->d_sb->s_dev;
+	rsbac_target_id2.dir.inode  = new_dir->i_ino;
+	rsbac_target_id2.dir.dentry_p = new_dentry->d_parent;
+	rsbac_attribute_value2.dummy = 0;
+	if (!rsbac_adf_request(R_WRITE,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id2,
+				A_none,
+				rsbac_attribute_value2))
+	{
+		return -EPERM;
+	}
+	if(new_dentry->d_inode)
+	{
+		target_exists = TRUE;
+		rsbac_pr_debug(aef, "[vfs_rename_dir()]: calling ADF for DELETE on existing target\n");
+		rsbac_target2 = T_FILE;
+		if (S_ISDIR(new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_DIR;
+		else if (S_ISFIFO (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_FIFO;
+		else if (S_ISLNK (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_SYMLINK;
+		else if (S_ISSOCK (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_UNIXSOCK;
+		rsbac_target_id2.file.device = new_dentry->d_sb->s_dev;
+		rsbac_target_id2.file.inode  = new_dentry->d_inode->i_ino;
+		rsbac_target_id2.file.dentry_p = new_dentry;
+		rsbac_attribute_value2.nlink = new_dentry->d_inode->i_nlink;
+		if (!rsbac_adf_request(R_DELETE,
+					task_pid(current),
+					rsbac_target2,
+					rsbac_target_id2,
+					A_nlink,
+					rsbac_attribute_value2))
+		{
+			return -EPERM;
+		}
+	}
+#endif
+
 	target = new_dentry->d_inode;
 	if (target) {
 		mutex_lock(&target->i_mutex);
@@ -2607,9 +3343,40 @@ static int vfs_rename_dir(struct inode *
 			d_rehash(new_dentry);
 		dput(new_dentry);
 	}
-	if (!error)
+	if (!error) {
 		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
 			d_move(old_dentry,new_dentry);
+
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_RENAME,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_new_dir_dentry_p,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+				"do_rename() [sys_rename()]: rsbac_adf_set_attr() for RENAME returned error\n");
+		}
+		if (target_exists) {
+			if (rsbac_adf_set_attr(R_DELETE,
+						task_pid(current),
+						rsbac_target2,
+						rsbac_target_id2,
+						T_NONE,
+						rsbac_new_target_id,
+						A_nlink,
+						rsbac_attribute_value2))
+			{
+				rsbac_printk(KERN_WARNING
+						"do_rename() [sys_rename()]: rsbac_adf_set_attr() for DELETE returned error\n");
+			}
+		}
+#endif
+	}
 	return error;
 }
 
@@ -2619,10 +3386,87 @@ static int vfs_rename_other(struct inode
 	struct inode *target;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	enum  rsbac_target_t rsbac_target2 = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_target_id2;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	union rsbac_attribute_value_t rsbac_attribute_value2;
+	rsbac_boolean_t target_exists = FALSE;
+#endif
+
 	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_rename()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO (old_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = old_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = old_dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = old_dentry;
+	rsbac_attribute_value.new_dir_dentry_p = new_dentry->d_parent;
+	if (!rsbac_adf_request(R_RENAME,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_new_dir_dentry_p,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[sys_rename()]: calling ADF for WRITE on new_dir\n");
+	rsbac_target_id2.dir.device = new_dentry->d_sb->s_dev;
+	rsbac_target_id2.dir.inode  = new_dir->i_ino;
+	rsbac_target_id2.dir.dentry_p = new_dentry->d_parent;
+	rsbac_attribute_value2.dummy = 0;
+	if (!rsbac_adf_request(R_WRITE,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id2,
+				A_none,
+				rsbac_attribute_value2))
+	{
+		return -EPERM;
+	}
+	if(new_dentry->d_inode) {
+		target_exists = TRUE;
+		rsbac_pr_debug(aef, "[sys_rename()]: calling ADF for DELETE on existing target\n");
+		rsbac_target2 = T_FILE;
+		if (S_ISDIR(new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_DIR;
+		else if (S_ISFIFO (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_FIFO;
+		else if (S_ISLNK (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_SYMLINK;
+		else if (S_ISSOCK (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_UNIXSOCK;
+		rsbac_target_id2.file.device = new_dentry->d_sb->s_dev;
+		rsbac_target_id2.file.inode  = new_dentry->d_inode->i_ino;
+		rsbac_target_id2.file.dentry_p = new_dentry;
+		rsbac_attribute_value2.nlink = new_dentry->d_inode->i_nlink;
+		if (!rsbac_adf_request(R_DELETE,
+					task_pid(current),
+					rsbac_target2,
+					rsbac_target_id2,
+					A_nlink,
+					rsbac_attribute_value2))
+		{
+			return -EPERM;
+		}
+	}
+#endif
+
 	dget(new_dentry);
 	target = new_dentry->d_inode;
 	if (target)
@@ -2634,6 +3478,37 @@ static int vfs_rename_other(struct inode
 	if (!error) {
 		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
 			d_move(old_dentry, new_dentry);
+
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_RENAME,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_new_dir_dentry_p,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"do_rename() [sys_rename()]: rsbac_adf_set_attr() returned error");
+		}
+		if (target_exists)
+		{
+			if (rsbac_adf_set_attr(R_DELETE,
+						task_pid(current),
+						rsbac_target2,
+						rsbac_target_id2,
+						T_NONE,
+						rsbac_new_target_id,
+						A_nlink,
+						rsbac_attribute_value2))
+			{
+				rsbac_printk(KERN_WARNING
+						"do_rename() [sys_rename()]: rsbac_adf_set_attr() returned error");
+			}
+		}
+#endif
 	}
 	if (target)
 		mutex_unlock(&target->i_mutex);
@@ -2786,6 +3661,9 @@ SYSCALL_DEFINE2(rename, const char __use
 int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
 {
 	int len;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+	char * rsbac_name;
+#endif
 
 	len = PTR_ERR(link);
 	if (IS_ERR(link))
@@ -2794,8 +3672,20 @@ int vfs_readlink(struct dentry *dentry, 
 	len = strlen(link);
 	if (len > (unsigned) buflen)
 		len = buflen;
+
+#ifdef CONFIG_RSBAC_SYM_REDIR
+	rsbac_name = rsbac_symlink_redirect(dentry, link, buflen);
+	if (rsbac_name) {
+		len = strlen(rsbac_name);
+		if (copy_to_user(buffer, rsbac_name, len))
+			len = -EFAULT;
+		kfree(rsbac_name);
+	}
+	else
+#endif
 	if (copy_to_user(buffer, link, len))
 		len = -EFAULT;
+
 out:
 	return len;
 }
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/namespace.c linux-2.6.31-rsbac-1.4.2/fs/namespace.c
--- trunk/fs/namespace.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/namespace.c	2009-09-10 18:17:37.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/fs_struct.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
+#include <rsbac/hooks.h>
 #include "pnode.h"
 #include "internal.h"
 
@@ -192,6 +193,13 @@ out_free_cache:
  */
 int __mnt_is_readonly(struct vfsmount *mnt)
 {
+#ifdef CONFIG_RSBAC
+	/* HACK - Remove me when switching to full 2.6, pass over the vfsmount
+	 * in init_private_file() instead
+	 */
+	if(!mnt)
+		return 0;
+#endif
 	if (mnt->mnt_flags & MNT_READONLY)
 		return 1;
 	if (mnt->mnt_sb->s_flags & MS_RDONLY)
@@ -1029,6 +1037,11 @@ static int do_umount(struct vfsmount *mn
 	int retval;
 	LIST_HEAD(umount_list);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	retval = security_sb_umount(mnt, flags);
 	if (retval)
 		return retval;
@@ -1051,6 +1064,46 @@ static int do_umount(struct vfsmount *mn
 			return -EAGAIN;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF for DIR\n");
+	rsbac_target_id.dir.device = sb->s_root->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = sb->s_root->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = sb->s_root;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_UMOUNT,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "calling ADF for dev\n");
+	rsbac_target_id.dev.type = D_block;
+	rsbac_target_id.dev.major = RSBAC_MAJOR(sb->s_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(sb->s_dev);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_UMOUNT,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
+        /* RSBAC: removing data structures for this fs from memory (not /) */
+#ifdef CONFIG_RSBAC
+	if ((mnt != current->fs->root.mnt) || (flags & MNT_DETACH)) {
+		rsbac_pr_debug(ds, "[sys_umount()]: calling rsbac_umount for Device %02u:%02u\n",
+				MAJOR(sb->s_dev), MINOR(sb->s_dev));
+		rsbac_umount(mnt);
+	}
+#endif
+
 	/*
 	 * If we may have to abort operations to get out of this
 	 * mount, and they will themselves hold resources we must
@@ -1079,6 +1132,7 @@ static int do_umount(struct vfsmount *mn
 		 * Special case for "unmounting" root ...
 		 * we just try to remount it readonly.
 		 */
+
 		down_write(&sb->s_umount);
 		if (!(sb->s_flags & MS_RDONLY))
 			retval = do_remount_sb(sb, MS_RDONLY, NULL, 0);
@@ -1087,6 +1141,7 @@ static int do_umount(struct vfsmount *mn
 	}
 
 	down_write(&namespace_sem);
+
 	spin_lock(&vfsmount_lock);
 	event++;
 
@@ -1102,6 +1157,17 @@ static int do_umount(struct vfsmount *mn
 	spin_unlock(&vfsmount_lock);
 	if (retval)
 		security_sb_umount_busy(mnt);
+
+#ifdef CONFIG_RSBAC
+	/* RSBAC: umount failed, so reread data structures for this fs from disk */
+	if(retval) {
+		rsbac_printk(KERN_WARNING
+				"do_umount() [sys_umount()]: umount failed -> calling rsbac_mount for Device %02u:%02u\n",
+				MAJOR(mnt->mnt_sb->s_dev),MINOR(mnt->mnt_sb->s_dev));
+		rsbac_mount(mnt);
+	}
+#endif
+
 	up_write(&namespace_sem);
 	release_mounts(&umount_list);
 	return retval;
@@ -1407,6 +1473,17 @@ out_unlock:
 	mutex_unlock(&path->dentry->d_inode->i_mutex);
 	if (!err)
 		security_sb_post_addmount(mnt, path);
+
+        /* RSBAC: initialising data structures for this fs (not root fs) */
+#ifdef CONFIG_RSBAC
+        if (!err) {
+		rsbac_pr_debug(ds, "[do_loopback(), do_add_mount() [sys_mount()]]: calling rsbac_mount for Device %02u:%02u\n",
+			       MAJOR(mnt->mnt_sb->s_dev),
+			       MINOR(mnt->mnt_sb->s_dev));
+		rsbac_mount(mnt);
+	}
+#endif
+
 	return err;
 }
 
@@ -1452,6 +1529,13 @@ static int do_loopback(struct path *path
 	struct path old_path;
 	struct vfsmount *mnt = NULL;
 	int err = mount_is_safe(path);
+
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (err)
 		return err;
 	if (!old_name || !*old_name)
@@ -1460,6 +1544,96 @@ static int do_loopback(struct path *path
 	if (err)
 		return err;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DIR\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+	rsbac_target_id.dir.device = old_path.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = old_path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = old_path.dentry;
+#else
+	rsbac_target_id.dir.device = nd->path.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = nd->path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = nd->path.dentry;
+#endif
+	rsbac_attribute_value.mode = recurse;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		path_put(&old_path);
+#else
+		path_put(&old_nd.path);
+#endif
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DEV\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+	if(S_ISBLK(old_path.dentry->d_inode->i_mode))
+#else
+	if(S_ISBLK(old_nd.path.dentry->d_inode->i_mode))
+#endif
+	{
+		rsbac_target = T_DEV;
+		rsbac_target_id.dev.type = D_block;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		rsbac_target_id.dev.major = RSBAC_MAJOR(old_path.dentry->d_sb->s_dev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(old_path.dentry->d_sb->s_dev);
+#else
+		rsbac_target_id.dev.major = RSBAC_MAJOR(old_nd.path.dentry->d_sb->s_dev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(old_nd.path.dentry->d_sb->s_dev);
+#endif
+	}
+	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		if(S_ISDIR(old_path.dentry->d_inode->i_mode))
+#else
+		if(S_ISDIR(old_nd.path.dentry->d_inode->i_mode))
+#endif
+		{
+			rsbac_target = T_DIR;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+			rsbac_target_id.dir.device = old_path.dentry->d_sb->s_dev;
+			rsbac_target_id.dir.inode  = old_path.dentry->d_inode->i_ino;
+			rsbac_target_id.dir.dentry_p = old_path.dentry;
+#else
+			rsbac_target_id.dir.device = old_nd.path.dentry->d_sb->s_dev;
+			rsbac_target_id.dir.inode  = old_nd.path.dentry->d_inode->i_ino;
+			rsbac_target_id.dir.dentry_p = old_nd.path.dentry;
+#endif
+		}
+		else
+		{
+			rsbac_target = T_FILE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+			rsbac_target_id.file.device = old_path.dentry->d_sb->s_dev;
+			rsbac_target_id.file.inode  = old_path.dentry->d_inode->i_ino;
+			rsbac_target_id.file.dentry_p = old_path.dentry;
+#else
+			rsbac_target_id.file.device = old_nd.path.dentry->d_sb->s_dev;
+			rsbac_target_id.file.inode  = old_nd.path.dentry->d_inode->i_ino;
+			rsbac_target_id.file.dentry_p = old_nd.path.dentry;
+#endif
+		}
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		path_put(&old_path);
+#else
+		path_put(&old_nd.path);
+#endif
+		return -EPERM;
+	}
+#endif
+
 	down_write(&namespace_sem);
 	err = -EINVAL;
 	if (IS_MNT_UNBINDABLE(old_path.mnt))
@@ -1520,6 +1694,11 @@ static int do_remount(struct path *path,
 	int err;
 	struct super_block *sb = path->mnt->mnt_sb;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -1529,6 +1708,42 @@ static int do_remount(struct path *path,
 	if (path->dentry != path->mnt->mnt_root)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DIR\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+	rsbac_target_id.dir.device = path->dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = path->dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path->dentry;
+#else
+	rsbac_target_id.dir.device = nd->path.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = nd->path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = nd->path.dentry;
+#endif
+	rsbac_attribute_value.mode = flags;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DEV\n");
+	rsbac_target_id.dev.type = D_block;
+	rsbac_target_id.dev.major = RSBAC_MAJOR(sb->s_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(sb->s_dev);
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	down_write(&sb->s_umount);
 	if (flags & MS_BIND)
 		err = change_mount_flags(path->mnt, flags);
@@ -1562,6 +1777,12 @@ static int do_move_mount(struct path *pa
 	struct path old_path, parent_path;
 	struct vfsmount *p;
 	int err = 0;
+
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (!old_name || !*old_name)
@@ -1570,6 +1791,97 @@ static int do_move_mount(struct path *pa
 	if (err)
 		return err;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for UMOUNT on old DIR\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+	rsbac_target_id.dir.device = old_path.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = old_path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = old_path.dentry;
+#else
+	rsbac_target_id.dir.device = old_nd.path.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = old_nd.path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = old_nd.path.dentry;
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_UMOUNT,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		path_put(&old_path);
+#else
+		path_put(&old_nd.path);
+#endif
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for MOUNT on new DIR\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+	rsbac_target_id.dir.device = path->dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = path->dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path->dentry;
+#else
+	rsbac_target_id.dir.device = nd->path.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = nd->path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = nd->path.dentry;
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		path_put(&old_path);
+#else
+		path_put(&old_nd.path);
+#endif
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for UMOUNT on DEV\n");
+	rsbac_target_id.dev.type = D_block;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+	rsbac_target_id.dev.major = RSBAC_MAJOR(old_path.dentry->d_sb->s_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(old_path.dentry->d_sb->s_dev);
+#else
+	rsbac_target_id.dev.major = RSBAC_MAJOR(old_nd.path.dentry->d_sb->s_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(old_nd.path.dentry->d_sb->s_dev);
+#endif
+	if (!rsbac_adf_request(R_UMOUNT,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		path_put(&old_path);
+#else
+		path_put(&old_nd.path);
+#endif
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for MOUNT on DEV\n");
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		path_put(&old_path);
+#else
+		path_put(&old_nd.path);
+#endif
+		return -EPERM;
+	}
+#endif
+
 	down_write(&namespace_sem);
 	while (d_mountpoint(path->dentry) &&
 	       follow_down(path))
@@ -1665,6 +1977,11 @@ int do_add_mount(struct vfsmount *newmnt
 {
 	int err;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	down_write(&namespace_sem);
 	/* Something was mounted here while we slept */
 	while (d_mountpoint(path->dentry) &&
@@ -1684,6 +2001,39 @@ int do_add_mount(struct vfsmount *newmnt
 	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
 		goto unlock;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DIR\n");
+	rsbac_target_id.dir.device = path->dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = path->dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path->dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto unlock;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DEV\n");
+	rsbac_target_id.dev.type = D_block;
+	rsbac_target_id.dev.major = RSBAC_MAJOR(newmnt->mnt_sb->s_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(newmnt->mnt_sb->s_dev);
+	rsbac_attribute_value.mode = mnt_flags;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DEV,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto unlock;
+	}
+#endif
+
 	newmnt->mnt_flags = mnt_flags;
 	if ((err = graft_tree(newmnt, path)))
 		goto unlock;
@@ -2138,6 +2488,11 @@ SYSCALL_DEFINE2(pivot_root, const char _
 	struct path new, old, parent_path, root_parent, root;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -2158,6 +2513,44 @@ SYSCALL_DEFINE2(pivot_root, const char _
 		goto out1;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF for MOUNT on put_old\n");
+	rsbac_target_id.dir.device = old.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = old.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = old.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		path_put(&old);
+		error = -EPERM;
+		goto out1;
+	}
+	rsbac_pr_debug(aef, "calling ADF for MOUNT on root DIR\n");
+	rsbac_target_id.dir.device = current->fs->root.mnt->mnt_sb->s_dev;
+	rsbac_target_id.dir.inode  = current->fs->root.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = current->fs->root.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MOUNT,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		path_put(&old);
+		error = -EPERM;
+		goto out1;
+	}
+
+	/* Make the new root's cached rsbac.dat dentry be put to free the old root's dcache */
+	rsbac_free_dat_dentries();
+#endif
+
 	read_lock(&current->fs->lock);
 	root = current->fs->root;
 	path_get(&current->fs->root);
@@ -2242,6 +2635,9 @@ static void __init init_mount_tree(void)
 	mnt = do_kern_mount("rootfs", 0, "rootfs", NULL);
 	if (IS_ERR(mnt))
 		panic("Can't create rootfs");
+#ifdef CONFIG_RSBAC
+	rsbac_mount(mnt);
+#endif
 	ns = create_mnt_ns(mnt);
 	if (IS_ERR(ns))
 		panic("Can't allocate initial namespace");
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/notify/inotify/inotify_user.c linux-2.6.31-rsbac-1.4.2/fs/notify/inotify/inotify_user.c
--- trunk/fs/notify/inotify/inotify_user.c	2009-09-10 18:14:56.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/notify/inotify/inotify_user.c	2009-09-10 18:17:39.000000000 +0200
@@ -45,6 +45,10 @@
 
 #include <asm/ioctls.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+ 
 static struct vfsmount *inotify_mnt __read_mostly;
 
 /* these are configurable via /proc/sys/fs/inotify/ */
@@ -825,6 +829,10 @@ static int __init inotify_user_setup(voi
 	if (IS_ERR(inotify_mnt))
 		panic("inotify: kern_mount ret %ld!\n", PTR_ERR(inotify_mnt));
 
+#ifdef CONFIG_RSBAC
+	rsbac_mount(inotify_mnt);
+#endif
+
 	inotify_inode_mark_cachep = KMEM_CACHE(inotify_inode_mark_entry, SLAB_PANIC);
 	event_priv_cachep = KMEM_CACHE(inotify_event_private_data, SLAB_PANIC);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/open.c linux-2.6.31-rsbac-1.4.2/fs/open.c
--- trunk/fs/open.c	2009-09-10 18:15:00.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/open.c	2009-09-10 18:17:42.000000000 +0200
@@ -31,11 +31,38 @@
 #include <linux/falloc.h>
 #include <linux/fs_struct.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
+
 int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	int retval = -ENODEV;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (dentry) {
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.dev.type = D_block;
+		rsbac_target_id.dev.major = RSBAC_MAJOR(dentry->d_sb->s_dev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(dentry->d_sb->s_dev);
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_DEV,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+#endif
+
 		retval = -ENOSYS;
 		if (dentry->d_sb->s_op->statfs) {
 			memset(buf, 0, sizeof(*buf));
@@ -202,10 +229,41 @@ int do_truncate(struct dentry *dentry, l
 	int err;
 	struct iattr newattrs;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#ifdef CONFIG_RSBAC_SECDEL
+	loff_t old_len = dentry->d_inode->i_size;
+#endif
+#endif
+
 	/* Not pretty: "inode->i_size" shouldn't really be signed. But it is. */
 	if (length < 0)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[open_namei(), do_sys_truncate() [sys_truncate()]]: calling ADF\n");
+	rsbac_target_id.file.device = dentry->d_inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_TRUNCATE,
+				task_pid(current),
+				T_FILE,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
+	/* RSBAC: Overwrite truncated part, if asked by flag */
+#ifdef CONFIG_RSBAC_SECDEL
+	rsbac_sec_trunc(dentry, length, old_len);
+#endif
+
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | time_attrs;
 	if (filp) {
@@ -219,6 +277,26 @@ int do_truncate(struct dentry *dentry, l
 	mutex_lock(&dentry->d_inode->i_mutex);
 	err = notify_change(dentry, &newattrs);
 	mutex_unlock(&dentry->d_inode->i_mutex);
+
+#ifdef CONFIG_RSBAC
+	if (!err) {
+		rsbac_pr_debug(aef, "[open_namei(), do_sys_truncate() [sys_truncate()]]: notifying ADF\n");
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_TRUNCATE,
+					task_pid(current),
+					T_FILE,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"do_truncate() [open_namei(), do_sys_truncate() [sys_truncate()]]: rsbac_adf_set_attr() returned error\n");
+		}
+	}
+#endif
+
 	return err;
 }
 
@@ -246,6 +324,15 @@ static long do_sys_truncate(const char _
 	if (!S_ISREG(inode->i_mode))
 		goto dput_and_out;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+        if (rsbac_dac_part_disabled(path.dentry))
+#else
+        if (rsbac_dac_part_disabled(nd.path.dentry))
+#endif
+		error = 0;
+	else
+#endif
 	error = mnt_want_write(path.mnt);
 	if (error)
 		goto dput_and_out;
@@ -383,6 +470,10 @@ int do_fallocate(struct file *file, int 
 {
 	struct inode *inode = file->f_path.dentry->d_inode;
 	long ret;
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (offset < 0 || len <= 0)
 		return -EINVAL;
@@ -401,6 +492,21 @@ int do_fallocate(struct file *file, int 
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "sys_fallocate(): calling ADF\n");
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode = inode->i_ino;
+	rsbac_target_id.file.dentry_p = file->f_path.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_WRITE,
+			task_pid(current),
+			T_FILE,
+			rsbac_target_id,
+			A_none,
+			rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	if (S_ISFIFO(inode->i_mode))
 		return -ESPIPE;
 
@@ -456,6 +562,12 @@ SYSCALL_DEFINE3(faccessat, int, dfd, con
 	struct inode *inode;
 	int res;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
 
@@ -468,7 +580,11 @@ SYSCALL_DEFINE3(faccessat, int, dfd, con
 
 	if (!issecure(SECURE_NO_SETUID_FIXUP)) {
 		/* Clear the capabilities if we switch to a non-root user */
-		if (override_cred->uid)
+		if (override_cred->uid
+#ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+			&& !rsbac_uid_faked()
+#endif
+		)
 			cap_clear(override_cred->cap_effective);
 		else
 			override_cred->cap_effective =
@@ -478,9 +594,36 @@ SYSCALL_DEFINE3(faccessat, int, dfd, con
 	old_cred = override_creds(override_cred);
 
 	res = user_path_at(dfd, filename, LOOKUP_FOLLOW, &path);
+
 	if (res)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(path.dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(path.dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(path.dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(path.dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = path.dentry->d_inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = path.dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = path.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		res = -EPERM;
+		goto out_path_release;
+	}
+#endif
+
 	inode = path.dentry->d_inode;
 
 	if ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {
@@ -528,14 +671,46 @@ SYSCALL_DEFINE1(chdir, const char __user
 	struct path path;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = user_path_dir(filename, &path);
 	if (error)
 		goto out;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+	if (rsbac_dac_part_disabled(path.dentry))
+#else
+	if (rsbac_dac_part_disabled(nd.path.dentry))
+#endif
+		error = 0;
+	else
+#endif
 	error = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_ACCESS);
 	if (error)
 		goto dput_and_out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.dir.device = path.dentry->d_inode->i_sb->s_dev;
+	rsbac_target_id.dir.inode  = path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CHDIR,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto dput_and_out;
+	}
+#endif
+
 	set_fs_pwd(current->fs, &path);
 
 dput_and_out:
@@ -550,6 +725,11 @@ SYSCALL_DEFINE1(fchdir, unsigned int, fd
 	struct inode *inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -561,7 +741,32 @@ SYSCALL_DEFINE1(fchdir, unsigned int, fd
 	if (!S_ISDIR(inode->i_mode))
 		goto out_putf;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if (rsbac_dac_part_disabled(file->f_path.dentry))
+		error = 0;
+	else
+#endif
 	error = inode_permission(inode, MAY_EXEC | MAY_ACCESS);
+
+#ifdef CONFIG_RSBAC
+	if(!error) {
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.dir.device = inode->i_sb->s_dev;
+		rsbac_target_id.dir.inode  = inode->i_ino;
+		rsbac_target_id.dir.dentry_p = file->f_path.dentry;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_CHDIR,
+					task_pid(current),
+					T_DIR,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			error = -EPERM;
+		}
+	}
+#endif
+
 	if (!error)
 		set_fs_pwd(current->fs, &file->f_path);
 out_putf:
@@ -575,10 +780,24 @@ SYSCALL_DEFINE1(chroot, const char __use
 	struct path path;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = user_path_dir(filename, &path);
 	if (error)
 		goto out;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+	if (rsbac_dac_part_disabled(path.dentry))
+#else
+	if (rsbac_dac_part_disabled(nd.path.dentry))
+#endif
+		error = 0;
+	else
+#endif
 	error = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_ACCESS);
 	if (error)
 		goto dput_and_out;
@@ -587,6 +806,24 @@ SYSCALL_DEFINE1(chroot, const char __use
 	if (!capable(CAP_SYS_CHROOT))
 		goto dput_and_out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.dir.device = path.dentry->d_inode->i_sb->s_dev;
+	rsbac_target_id.dir.inode  = path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CHDIR,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto dput_and_out;
+	}
+#endif
+
 	set_fs_root(current->fs, &path);
 	error = 0;
 dput_and_out:
@@ -603,6 +840,12 @@ SYSCALL_DEFINE2(fchmod, unsigned int, fd
 	int err = -EBADF;
 	struct iattr newattrs;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	file = fget(fd);
 	if (!file)
 		goto out;
@@ -615,6 +858,42 @@ SYSCALL_DEFINE2(fchmod, unsigned int, fd
 	err = mnt_want_write_file(file);
 	if (err)
 		goto out_putf;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode)) {
+		if(inode->i_sb->s_magic == SOCKFS_MAGIC) {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+		} else {
+			rsbac_target = T_UNIXSOCK;
+		}
+	}
+	rsbac_attribute_value.mode = mode;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		mnt_drop_write(file->f_path.mnt);
+		goto out_putf;
+	}
+#endif
+        
 	mutex_lock(&inode->i_mutex);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
@@ -636,6 +915,12 @@ SYSCALL_DEFINE3(fchmodat, int, dfd, cons
 	int error;
 	struct iattr newattrs;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = user_path_at(dfd, filename, LOOKUP_FOLLOW, &path);
 	if (error)
 		goto out;
@@ -644,6 +929,41 @@ SYSCALL_DEFINE3(fchmodat, int, dfd, cons
 	error = mnt_want_write(path.mnt);
 	if (error)
 		goto dput_and_out;
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = path.dentry;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode)) {
+		if(inode->i_sb->s_magic == SOCKFS_MAGIC) {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+		} else {
+			rsbac_target = T_UNIXSOCK;
+		}
+	}
+	rsbac_attribute_value.mode = mode;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		mnt_drop_write(path.mnt);
+		goto dput_and_out;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
@@ -669,6 +989,36 @@ static int chown_common(struct dentry * 
 	int error;
 	struct iattr newattrs;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "[sys_*chown]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CHANGE_OWNER,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	newattrs.ia_valid =  ATTR_CTIME;
 	if (user != (uid_t) -1) {
 		newattrs.ia_valid |= ATTR_UID;
@@ -681,6 +1031,7 @@ static int chown_common(struct dentry * 
 	if (!S_ISDIR(inode->i_mode))
 		newattrs.ia_valid |=
 			ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
+
 	mutex_lock(&inode->i_mutex);
 	error = notify_change(dentry, &newattrs);
 	mutex_unlock(&inode->i_mutex);
@@ -1095,16 +1446,122 @@ int filp_close(struct file *filp, fl_own
 {
 	int retval = 0;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	enum  rsbac_attribute_t       rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!file_count(filp)) {
 		printk(KERN_ERR "VFS: Close: file count is 0\n");
 		return 0;
 	}
 
+#ifdef CONFIG_RSBAC
+	if (filp && filp->f_dentry && filp->f_dentry->d_inode) {
+		rsbac_pr_debug(aef, "[sys_close]: calling ADF\n");
+		rsbac_target = T_NONE;
+		if (S_ISBLK(filp->f_dentry->d_inode->i_mode)
+			|| S_ISCHR(filp->f_dentry->d_inode->i_mode)) {
+			rsbac_target = T_DEV;
+			if (S_ISBLK(filp->f_dentry->d_inode->i_mode)) {
+				rsbac_target_id.dev.type = D_block;
+			}
+			else {
+				rsbac_target_id.dev.type = D_char;
+			}
+			rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_sb->s_dev);
+			rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_sb->s_dev);
+			rsbac_attribute = A_f_mode;
+			rsbac_attribute_value.f_mode = filp->f_mode;
+		}
+		else
+			if (S_ISSOCK(filp->f_dentry->d_inode->i_mode)) {
+				if (SOCKET_I(filp->f_dentry->d_inode)->ops
+					&& (SOCKET_I(filp->f_dentry->d_inode)->ops->family == AF_UNIX)) {
+					if (filp->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+						rsbac_target = T_IPC;
+						rsbac_target_id.ipc.type = I_anonunix;
+						rsbac_target_id.ipc.id.id_nr = filp->f_dentry->d_inode->i_ino;
+						rsbac_attribute = A_nlink;
+						rsbac_attribute_value.nlink = filp->f_dentry->d_inode->i_nlink;
+					}
+					else {
+						rsbac_target = T_UNIXSOCK;
+						rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+						rsbac_target_id.unixsock.inode  = filp->f_dentry->d_inode->i_ino;
+						rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+						rsbac_attribute = A_f_mode;
+						rsbac_attribute_value.f_mode = filp->f_mode;
+					}
+				}
+				else {
+					rsbac_target = T_NETOBJ;
+					rsbac_target_id.netobj.sock_p
+						= SOCKET_I(filp->f_dentry->d_inode);
+					rsbac_target_id.netobj.local_addr = NULL;
+					rsbac_target_id.netobj.local_len = 0;
+					rsbac_target_id.netobj.remote_addr = NULL;
+					rsbac_target_id.netobj.remote_len = 0;
+					rsbac_attribute = A_f_mode;
+					rsbac_attribute_value.f_mode = filp->f_mode;
+				}
+			}
+			else { /* must be file, fifo or dir */
+				if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+					rsbac_target = T_DIR;
+				else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+					rsbac_target = T_FIFO;
+				else
+					rsbac_target = T_FILE;
+				rsbac_target_id.file.device = filp->f_dentry->d_inode->i_sb->s_dev;
+				rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+				rsbac_target_id.file.dentry_p = filp->f_dentry;
+				rsbac_attribute = A_f_mode;
+				rsbac_attribute_value.f_mode = filp->f_mode;
+			}
+		if ((rsbac_target != T_NONE) && !rsbac_adf_request(R_CLOSE,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+		{
+#ifdef CONFIG_RSBAC_ENFORCE_CLOSE
+			return -EPERM;
+#endif
+		}
+	}
+#endif
+
 	if (filp->f_op && filp->f_op->flush)
 		retval = filp->f_op->flush(filp, id);
 
 	dnotify_flush(filp, id);
 	locks_remove_posix(filp, id);
+
+#ifdef CONFIG_RSBAC
+	if (rsbac_target != T_NONE) {
+		rsbac_pr_debug(aef, "[sys_close]: notifying ADF\n");
+		rsbac_new_target_id.dummy = 0;
+		rsbac_attribute_value.f_mode = filp->f_mode;
+		if (rsbac_adf_set_attr(R_CLOSE,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"filp_close() [sys_close]: rsbac_adf_set_attr() returned error\n");
+		}
+	}
+#endif
+
 	fput(filp);
 	return retval;
 }
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/pipe.c linux-2.6.31-rsbac-1.4.2/fs/pipe.c
--- trunk/fs/pipe.c	2009-09-10 18:15:00.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/pipe.c	2009-09-10 18:17:42.000000000 +0200
@@ -22,6 +22,8 @@
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * We use a start+len construction, which provides full use of the 
  * allocated memory.
@@ -338,11 +340,34 @@ pipe_read(struct kiocb *iocb, const stru
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
 
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	do_wakeup = 0;
 	ret = 0;
 	mutex_lock(&inode->i_mutex);
@@ -434,8 +459,27 @@ redo:
 		wake_up_interruptible_sync(&pipe->wait);
 		kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
 	}
-	if (ret > 0)
+	if (ret > 0) {
 		file_accessed(filp);
+		
+#ifdef CONFIG_RSBAC_RW
+		rsbac_new_target_id.dummy = 0;
+
+		if (rsbac_adf_set_attr(R_READ,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"pipe_readv(): rsbac_adf_set_attr() returned error\n");
+		}
+#endif
+
+	}
 	return ret;
 }
 
@@ -452,11 +496,34 @@ pipe_write(struct kiocb *iocb, const str
 	size_t total_len;
 	ssize_t chars;
 
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	total_len = iov_length(iov, nr_segs);
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	do_wakeup = 0;
 	ret = 0;
 	mutex_lock(&inode->i_mutex);
@@ -607,8 +674,27 @@ out:
 		wake_up_interruptible_sync(&pipe->wait);
 		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
 	}
-	if (ret > 0)
+	if (ret > 0) {
 		file_update_time(filp);
+		
+#ifdef CONFIG_RSBAC_RW
+		rsbac_new_target_id.dummy = 0;
+
+		if (rsbac_adf_set_attr(R_WRITE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"pipe_writev(): rsbac_adf_set_attr() returned error\n");
+		}
+#endif
+	}
+
 	return ret;
 }
 
@@ -694,7 +780,20 @@ pipe_release(struct inode *inode, int de
 	pipe->writers -= decw;
 
 	if (!pipe->readers && !pipe->writers) {
+
+#ifdef CONFIG_RSBAC
+		union rsbac_target_id_t rsbac_target_id;
+#endif
+
 		free_pipe_info(inode);
+
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ACI remove_target()\n");
+		rsbac_target_id.ipc.type   = I_anonpipe;
+		rsbac_target_id.ipc.id.id_nr  = inode->i_ino;
+		rsbac_remove_target(T_IPC, rsbac_target_id);
+#endif
+
 	} else {
 		wake_up_interruptible_sync(&pipe->wait);
 		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
@@ -711,10 +810,49 @@ pipe_read_fasync(int fd, struct file *fi
 	struct inode *inode = filp->f_path.dentry->d_inode;
 	int retval;
 
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	retval = fasync_helper(fd, filp, on, &inode->i_pipe->fasync_readers);
 	mutex_unlock(&inode->i_mutex);
 
+#ifdef CONFIG_RSBAC_RW
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_READ,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING "pipe_read_fasync(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return retval;
 }
 
@@ -725,10 +863,49 @@ pipe_write_fasync(int fd, struct file *f
 	struct inode *inode = filp->f_path.dentry->d_inode;
 	int retval;
 
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	retval = fasync_helper(fd, filp, on, &inode->i_pipe->fasync_writers);
 	mutex_unlock(&inode->i_mutex);
 
+#ifdef CONFIG_RSBAC_RW
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_WRITE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING "pipe_write_fasync(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return retval;
 }
 
@@ -740,6 +917,45 @@ pipe_rdwr_fasync(int fd, struct file *fi
 	struct pipe_inode_info *pipe = inode->i_pipe;
 	int retval;
 
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF for READ\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+
+	rsbac_pr_debug(aef, "calling ADF for WRITE\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
+
 	mutex_lock(&inode->i_mutex);
 	retval = fasync_helper(fd, filp, on, &pipe->fasync_readers);
 	if (retval >= 0) {
@@ -748,6 +964,39 @@ pipe_rdwr_fasync(int fd, struct file *fi
 			fasync_helper(-1, filp, 0, &pipe->fasync_readers);
 	}
 	mutex_unlock(&inode->i_mutex);
+#ifdef CONFIG_RSBAC_RW
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_READ,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"pipe_rwdr_fasync(): rsbac_adf_set_attr() returned error\n");
+	}
+
+	/* RSBAC: notify adf of write to pipe */
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_WRITE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"pipe_rwdr_fasync(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return retval;
 }
 
@@ -777,28 +1026,127 @@ pipe_rdwr_release(struct inode *inode, s
 static int
 pipe_read_open(struct inode *inode, struct file *filp)
 {
+	
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ_OPEN,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	/* We could have perhaps used atomic_t, but this and friends
 	   below are the only places.  So it doesn't seem worthwhile.  */
 	mutex_lock(&inode->i_mutex);
 	inode->i_pipe->readers++;
 	mutex_unlock(&inode->i_mutex);
 
+#ifdef CONFIG_RSBAC
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_READ_OPEN,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING "pipe_read_open(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return 0;
 }
 
 static int
 pipe_write_open(struct inode *inode, struct file *filp)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE_OPEN,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	inode->i_pipe->writers++;
 	mutex_unlock(&inode->i_mutex);
 
+#ifdef CONFIG_RSBAC
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_WRITE_OPEN,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING "pipe_write_open(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return 0;
 }
 
 static int
 pipe_rdwr_open(struct inode *inode, struct file *filp)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ_WRITE_OPEN,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	if (filp->f_mode & FMODE_READ)
 		inode->i_pipe->readers++;
@@ -806,6 +1154,23 @@ pipe_rdwr_open(struct inode *inode, stru
 		inode->i_pipe->writers++;
 	mutex_unlock(&inode->i_mutex);
 
+#ifdef CONFIG_RSBAC
+	/* RSBAC: notify adf of read_write_open on pipe */
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_READ_WRITE_OPEN,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING "pipe_rdwr_open(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return 0;
 }
 
@@ -958,6 +1323,12 @@ struct file *create_write_pipe(int flags
 	struct dentry *dentry;
 	struct qstr name = { .name = "" };
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	err = -ENFILE;
 	inode = get_pipe_inode();
 	if (!inode)
@@ -986,6 +1357,24 @@ struct file *create_write_pipe(int flags
 	f->f_flags = O_WRONLY | (flags & O_NONBLOCK);
 	f->f_version = 0;
 
+#ifdef CONFIG_RSBAC
+        rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_new_target_id.dummy = 0;
+	rsbac_attribute_value.dummy = 0;
+	if (rsbac_adf_set_attr(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"do_pipe() [sys_pipe()]: rsbac_adf_set_attr() returned error");
+	}
+#endif
 	return f;
 
  err_dentry:
@@ -1033,6 +1422,27 @@ int do_pipe_flags(int *fd, int flags)
 	int error;
 	int fdw, fdr;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_pipe()]: calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = 0;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (flags & ~(O_CLOEXEC | O_NONBLOCK))
 		return -EINVAL;
 
@@ -1126,12 +1536,28 @@ static int __init init_pipe_fs(void)
 			err = PTR_ERR(pipe_mnt);
 			unregister_filesystem(&pipe_fs_type);
 		}
+#ifdef CONFIG_RSBAC
+		else {
+			/* RSBAC: initialising data structures for this fs (not root fs) */
+			rsbac_pr_debug(ds, "calling rsbac_mount for Device %02u:%02u\n",
+					MAJOR(pipe_mnt->mnt_sb->s_dev), MINOR(pipe_mnt->mnt_sb->s_dev));
+			rsbac_mount(pipe_mnt);
+		}
+#endif
 	}
 	return err;
 }
 
 static void __exit exit_pipe_fs(void)
 {
+	/* RSBAC: removing data structures for this fs from memory */
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(ds, "calling rsbac_umount for "
+			"Device %02u:%02u\n", MAJOR(pipe_mnt->mnt_sb->s_dev),
+			MINOR(pipe_mnt->mnt_sb->s_dev));
+	rsbac_umount(pipe_mnt);
+#endif
+
 	unregister_filesystem(&pipe_fs_type);
 	mntput(pipe_mnt);
 }
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/proc/array.c linux-2.6.31-rsbac-1.4.2/fs/proc/array.c
--- trunk/fs/proc/array.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/proc/array.c	2009-09-10 18:17:37.000000000 +0200
@@ -86,6 +86,7 @@
 #include <asm/pgtable.h>
 #include <asm/processor.h>
 #include "internal.h"
+#include <rsbac/hooks.h>
 
 static inline void task_name(struct seq_file *m, struct task_struct *p)
 {
@@ -326,6 +327,28 @@ int proc_pid_status(struct seq_file *m, 
 {
 	struct mm_struct *mm = get_task_mm(task);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		if (mm)
+			mmput(mm);
+		return -EPERM;
+	}
+#endif
+
 	task_name(m, task);
 	task_state(m, ns, pid, task);
 
@@ -354,7 +377,7 @@ static int do_task_stat(struct seq_file 
 	pid_t ppid = 0, pgid = -1, sid = -1;
 	int num_threads = 0;
 	int permitted;
-	struct mm_struct *mm;
+	struct mm_struct *mm = get_task_mm(task);
 	unsigned long long start_time;
 	unsigned long cmin_flt = 0, cmaj_flt = 0;
 	unsigned long  min_flt = 0,  maj_flt = 0;
@@ -364,10 +387,30 @@ static int do_task_stat(struct seq_file 
 	char tcomm[sizeof(task->comm)];
 	unsigned long flags;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))	{
+		if (mm)
+			mmput(mm);
+		return -EPERM;
+	}
+#endif
+
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
 	permitted = ptrace_may_access(task, PTRACE_MODE_READ);
-	mm = get_task_mm(task);
 	if (mm) {
 		vsize = task_vsize(mm);
 		if (permitted) {
@@ -523,8 +566,29 @@ int proc_pid_statm(struct seq_file *m, s
 			struct pid *pid, struct task_struct *task)
 {
 	int size = 0, resident = 0, shared = 0, text = 0, lib = 0, data = 0;
-	struct mm_struct *mm = get_task_mm(task);
+	struct mm_struct *mm;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+	
+	mm = get_task_mm(task);
 	if (mm) {
 		size = task_statm(mm, &shared, &text, &data, &resident);
 		mmput(mm);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/proc/base.c linux-2.6.31-rsbac-1.4.2/fs/proc/base.c
--- trunk/fs/proc/base.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/proc/base.c	2009-09-10 18:17:37.000000000 +0200
@@ -82,6 +82,7 @@
 #include <linux/pid_namespace.h>
 #include <linux/fs_struct.h>
 #include "internal.h"
+#include <rsbac/hooks.h>
 
 /* NOTE:
  *	Implementing inode permission operations in /proc is almost
@@ -182,6 +183,30 @@ static int proc_cwd_link(struct inode *i
 	struct task_struct *task = get_proc_task(inode);
 	int result = -ENOENT;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	
+	if(!task)
+		return result;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = proc_pid(inode);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		put_task_struct(task);
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
+
 	if (task) {
 		result = get_fs_path(task, path, 0);
 		put_task_struct(task);
@@ -193,6 +218,30 @@ static int proc_root_link(struct inode *
 {
 	struct task_struct *task = get_proc_task(inode);
 	int result = -ENOENT;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	if(!task)
+		return result;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		put_task_struct(task);
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
 
 	if (task) {
 		result = get_fs_path(task, path, 1);
@@ -234,12 +283,36 @@ static int check_mem_permission(struct t
 
 struct mm_struct *mm_for_maps(struct task_struct *task)
 {
-	struct mm_struct *mm;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (mutex_lock_killable(&task->cred_guard_mutex))
 		return NULL;
 
-	mm = get_task_mm(task);
+	struct mm_struct *mm = get_task_mm(task);
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		if (mm)
+			mmput(mm);
+		rcu_read_unlock();
+		mutex_unlock(&task->cred_guard_mutex);
+		return NULL;
+	}
+	rcu_read_unlock();
+#endif
+
 	if (mm && mm != current->mm &&
 			!ptrace_may_access(task, PTRACE_MODE_READ)) {
 		mmput(mm);
@@ -255,11 +328,35 @@ static int proc_pid_cmdline(struct task_
 	int res = 0;
 	unsigned int len;
 	struct mm_struct *mm = get_task_mm(task);
+
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!mm)
 		goto out;
 	if (!mm->arg_end)
 		goto out_mm;	/* Shh! No looking before we're done */
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		res = -EPERM;
+		rcu_read_unlock();
+		goto out_mm;
+	}
+	rcu_read_unlock();
+#endif
+
  	len = mm->arg_end - mm->arg_start;
  
 	if (len > PAGE_SIZE)
@@ -291,6 +388,31 @@ static int proc_pid_auxv(struct task_str
 {
 	int res = 0;
 	struct mm_struct *mm = get_task_mm(task);
+
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		if (mm)
+			mmput(mm);
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	if (mm) {
 		unsigned int nwords = 0;
 		do {
@@ -316,6 +438,28 @@ static int proc_pid_wchan(struct task_st
 	unsigned long wchan;
 	char symname[KSYM_NAME_LEN];
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	wchan = get_wchan(task);
 
 	if (lookup_symbol_name(wchan, symname) < 0)
@@ -365,6 +509,29 @@ static int proc_pid_stack(struct seq_fil
  */
 static int proc_pid_schedstat(struct task_struct *task, char *buffer)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	return sprintf(buffer, "%llu %llu %lu\n",
 			(unsigned long long)task->se.sum_exec_runtime,
 			(unsigned long long)task->sched_info.run_delay,
@@ -445,6 +612,29 @@ static int proc_oom_score(struct task_st
 	unsigned long points;
 	struct timespec uptime;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	do_posix_clock_monotonic_gettime(&uptime);
 	read_lock(&tasklist_lock);
 	points = badness(task, uptime.tv_sec);
@@ -590,6 +780,32 @@ static int mounts_open_common(struct ino
 	struct proc_mounts *p;
 	int ret = -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	if(!task)
+		return -EINVAL;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		put_task_struct(task);
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	if (task) {
 		rcu_read_lock();
 		nsp = task_nsproxy(task);
@@ -790,12 +1006,33 @@ static ssize_t mem_read(struct file * fi
 	int ret = -ESRCH;
 	struct mm_struct *mm;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!task)
 		goto out_no_task;
 
 	if (check_mem_permission(task))
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		goto out;
+	}
+#endif
+
 	ret = -ENOMEM;
 	page = (char *)__get_free_page(GFP_TEMPORARY);
 	if (!page)
@@ -859,6 +1096,11 @@ static ssize_t mem_write(struct file * f
 	struct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);
 	unsigned long dst = *ppos;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	copied = -ESRCH;
 	if (!task)
 		goto out_no_task;
@@ -866,6 +1108,22 @@ static ssize_t mem_write(struct file * f
 	if (check_mem_permission(task))
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		copied = -EPERM;
+		goto out;
+	}
+#endif
+
 	copied = -ENOMEM;
 	page = (char *)__get_free_page(GFP_TEMPORARY);
 	if (!page)
@@ -1001,8 +1259,30 @@ static ssize_t oom_adjust_read(struct fi
 	size_t len;
 	int oom_adjust;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!task)
 		return -ESRCH;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		put_task_struct(task);
+		return -EPERM;
+	}
+#endif
+
 	oom_adjust = task->oomkilladj;
 	put_task_struct(task);
 
@@ -1018,6 +1298,12 @@ static ssize_t oom_adjust_write(struct f
 	char buffer[PROC_NUMBUF], *end;
 	int oom_adjust;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+
 	memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
@@ -1032,6 +1318,23 @@ static ssize_t oom_adjust_write(struct f
 	task = get_proc_task(file->f_path.dentry->d_inode);
 	if (!task)
 		return -ESRCH;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		put_task_struct(task);
+		return -EPERM;
+	}
+#endif
+
 	if (oom_adjust < task->oomkilladj && !capable(CAP_SYS_RESOURCE)) {
 		put_task_struct(task);
 		return -EACCES;
@@ -1058,8 +1361,30 @@ static ssize_t proc_loginuid_read(struct
 	ssize_t length;
 	char tmpbuf[TMPBUFLEN];
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!task)
 		return -ESRCH;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		put_task_struct(task);
+		return -EPERM;
+	}
+#endif
+
 	length = scnprintf(tmpbuf, TMPBUFLEN, "%u",
 				audit_get_loginuid(task));
 	put_task_struct(task);
@@ -1074,6 +1399,11 @@ static ssize_t proc_loginuid_write(struc
 	ssize_t length;
 	uid_t loginuid;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_AUDIT_CONTROL))
 		return -EPERM;
 
@@ -1087,6 +1417,25 @@ static ssize_t proc_loginuid_write(struc
 		/* No partial writes. */
 		return -EINVAL;
 	}
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process =  pid_task(proc_pid(inode), PIDTYPE_PID)->pid;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	page = (char*)__get_free_page(GFP_TEMPORARY);
 	if (!page)
 		return -ENOMEM;
@@ -1304,11 +1653,32 @@ static int proc_exe_link(struct inode *i
 	struct task_struct *task;
 	struct mm_struct *mm;
 	struct file *exe_file;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	task = get_proc_task(inode);
 	if (!task)
 		return -ENOENT;
+
+#ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = task_pid(task);
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                task_pid(current),
+                                T_PROCESS,
+                                rsbac_target_id,
+                                A_none,
+                                rsbac_attribute_value))
+        {
+		put_task_struct(task);
+                return -EPERM;
+        }
+#endif
 	mm = get_task_mm(task);
+
 	put_task_struct(task);
 	if (!mm)
 		return -ENOENT;
@@ -1624,6 +1994,30 @@ static int proc_fd_info(struct inode *in
 	struct file *file;
 	int fd = proc_fd(inode);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = proc_pid(inode);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		if (task)
+			put_task_struct(task);
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	if (task) {
 		files = get_files_struct(task);
 		put_task_struct(task);
@@ -2699,6 +3093,11 @@ struct dentry *proc_pid_lookup(struct in
 	unsigned tgid;
 	struct pid_namespace *ns;
 
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif			
+
 	result = proc_base_lookup(dir, dentry);
 	if (!IS_ERR(result) || PTR_ERR(result) != -ENOENT)
 		goto out;
@@ -2716,6 +3115,22 @@ struct dentry *proc_pid_lookup(struct in
 	if (!task)
 		goto out;
 
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		result = ERR_PTR(-ENOENT);
+		put_task_struct(task);
+		goto out;
+	}
+#endif						
+
 	result = proc_pid_instantiate(dir, dentry, task, NULL);
 	put_task_struct(task);
 out:
@@ -2783,6 +3198,10 @@ int proc_pid_readdir(struct file * filp,
 	struct task_struct *reaper = get_proc_task(filp->f_path.dentry->d_inode);
 	struct tgid_iter iter;
 	struct pid_namespace *ns;
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (!reaper)
 		goto out_no_task;
@@ -2793,12 +3212,30 @@ int proc_pid_readdir(struct file * filp,
 			goto out;
 	}
 
+
 	ns = filp->f_dentry->d_sb->s_fs_info;
 	iter.task = NULL;
 	iter.tgid = filp->f_pos - TGID_OFFSET;
 	for (iter = next_tgid(ns, iter);
 	     iter.task;
 	     iter.tgid += 1, iter = next_tgid(ns, iter)) {
+#ifdef CONFIG_RSBAC_PROC_HIDE
+		rcu_read_lock();
+		rsbac_target_id.process = task_pid(iter.task);
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rcu_read_unlock();
+			continue;
+		}
+		rcu_read_unlock();
+#endif
+
 		filp->f_pos = iter.tgid + TGID_OFFSET;
 		if (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {
 			put_task_struct(iter.task);
@@ -2939,6 +3376,10 @@ static struct dentry *proc_task_lookup(s
 	struct task_struct *leader = get_proc_task(dir);
 	unsigned tid;
 	struct pid_namespace *ns;
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif			
 
 	if (!leader)
 		goto out_no_task;
@@ -2958,6 +3399,21 @@ static struct dentry *proc_task_lookup(s
 	if (!same_thread_group(leader, task))
 		goto out_drop_task;
 
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	rsbac_target_id.process = task_pid(task);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		goto out_drop_task;
+	}
+#endif						
+
+
 	result = proc_task_instantiate(dir, dentry, task, NULL);
 out_drop_task:
 	put_task_struct(task);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/proc/kcore.c linux-2.6.31-rsbac-1.4.2/fs/proc/kcore.c
--- trunk/fs/proc/kcore.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/proc/kcore.c	2009-09-10 18:17:37.000000000 +0200
@@ -18,8 +18,11 @@
 #include <linux/vmalloc.h>
 #include <linux/highmem.h>
 #include <linux/init.h>
+#include <linux/security.h>
+
 #include <asm/uaccess.h>
 #include <asm/io.h>
+#include <rsbac/hooks.h>
 
 #define CORE_STR "CORE"
 
@@ -31,7 +34,28 @@ static struct proc_dir_entry *proc_root_
 
 static int open_kcore(struct inode * inode, struct file * filp)
 {
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+
+	if(!capable(CAP_SYS_RAWIO))
+	  return -EPERM;
+
+        rsbac_target_id.scd = ST_kmem;
+        rsbac_attribute_value.dummy = 0;
+        rsbac_pr_debug(aef, "calling ADF\n");
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                              task_pid(current),
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          return -EPERM;
+        else
+          return 0;
+#else
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+#endif
 }
 
 static ssize_t read_kcore(struct file *, char __user *, size_t, loff_t *);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/proc/root.c linux-2.6.31-rsbac-1.4.2/fs/proc/root.c
--- trunk/fs/proc/root.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/proc/root.c	2009-09-10 18:17:37.000000000 +0200
@@ -19,6 +19,10 @@
 #include <linux/mount.h>
 #include <linux/pid_namespace.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #include "internal.h"
 
 static int proc_test_super(struct super_block *sb, void *data)
@@ -115,6 +119,10 @@ void __init proc_root_init(void)
 		unregister_filesystem(&proc_fs_type);
 		return;
 	}
+#ifdef CONFIG_RSBAC
+	else
+		rsbac_mount(proc_mnt);
+#endif
 
 	proc_symlink("mounts", NULL, "self/mounts");
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/proc/task_mmu.c linux-2.6.31-rsbac-1.4.2/fs/proc/task_mmu.c
--- trunk/fs/proc/task_mmu.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/proc/task_mmu.c	2009-09-10 18:17:37.000000000 +0200
@@ -6,13 +6,14 @@
 #include <linux/ptrace.h>
 #include <linux/pagemap.h>
 #include <linux/mempolicy.h>
+#include <linux/security.h>
 #include <linux/swap.h>
 #include <linux/swapops.h>
-
 #include <asm/elf.h>
 #include <asm/uaccess.h>
 #include <asm/tlbflush.h>
 #include "internal.h"
+#include <rsbac/hooks.h>
 
 void task_mem(struct seq_file *m, struct mm_struct *mm)
 {
@@ -185,9 +186,28 @@ static int do_maps_open(struct inode *in
 {
 	struct proc_maps_private *priv;
 	int ret = -ENOMEM;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (priv) {
 		priv->pid = proc_pid(inode);
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = priv->pid;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			kfree(priv);
+			return -EPERM;
+		}
+#endif
 		ret = seq_open(file, ops);
 		if (!ret) {
 			struct seq_file *m = file->private_data;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/proc/task_nommu.c linux-2.6.31-rsbac-1.4.2/fs/proc/task_nommu.c
--- trunk/fs/proc/task_nommu.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/proc/task_nommu.c	2009-09-10 18:17:37.000000000 +0200
@@ -7,6 +7,7 @@
 #include <linux/ptrace.h>
 #include <linux/seq_file.h>
 #include "internal.h"
+#include <rsbac/hooks.h>
 
 /*
  * Logic: we've got two memory sums for each process, "shared", and
@@ -226,10 +227,32 @@ static const struct seq_operations proc_
 };
 
 static int maps_open(struct inode *inode, struct file *file)
-{
+{	
 	struct proc_maps_private *priv;
 	int ret = -ENOMEM;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	struct task_struct *task = get_proc_task(inode);
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = pid_task(proc_pid(inode), PIDTYPE_PID)->pid;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
+
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (priv) {
 		priv->pid = proc_pid(inode);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/quota/quota.c linux-2.6.31-rsbac-1.4.2/fs/quota/quota.c
--- trunk/fs/quota/quota.c	2009-09-10 18:15:02.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/quota/quota.c	2009-09-10 18:17:42.000000000 +0200
@@ -17,6 +17,7 @@
 #include <linux/buffer_head.h>
 #include <linux/capability.h>
 #include <linux/quotaops.h>
+#include <rsbac/hooks.h>
 #include <linux/types.h>
 
 /* Check validity of generic quotactl commands */
@@ -86,10 +87,30 @@ static int generic_quotactl_valid(struct
 		    !capable(CAP_SYS_ADMIN))
 			return -EPERM;
 	}
-	else if (cmd != Q_GETFMT && cmd != Q_SYNC && cmd != Q_GETINFO)
+	else if (cmd != Q_GETFMT && cmd != Q_SYNC && cmd != Q_GETINFO) {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+#endif
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
+#ifdef CONFIG_RSBAC
 
+		rsbac_target_id.scd = ST_quota;
+		rsbac_attribute_value.dummy = 0;
+		rsbac_pr_debug(aef, "[sys_quotactl()]: calling ADF\n");
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+#endif
+	}
 	return 0;
 }
 
@@ -138,8 +159,28 @@ static int xqm_quotactl_valid(struct sup
 		     !capable(CAP_SYS_ADMIN))
 			return -EPERM;
 	} else if (cmd != Q_XGETQSTAT && cmd != Q_XQUOTASYNC) {
+#ifdef CONFIG_RSBAC
+		union rsbac_target_id_t rsbac_target_id;
+		union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
+
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.scd = ST_quota;
+		rsbac_attribute_value.dummy = 0;
+		rsbac_pr_debug(aef, "[sys_quotactl()]: calling ADF\n");
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+#endif
 	}
 
 	return 0;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/readdir.c linux-2.6.31-rsbac-1.4.2/fs/readdir.c
--- trunk/fs/readdir.c	2009-09-10 18:14:59.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/readdir.c	2009-09-10 18:17:41.000000000 +0200
@@ -19,10 +19,27 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+#include "hfsplus/hfsplus_fs.h"
+#include "hfsplus/hfsplus_raw.h"
+#endif
+#endif
+
+#include <rsbac/hooks.h>
+#include <linux/namei.h>
+
 int vfs_readdir(struct file *file, filldir_t filler, void *buf)
 {
 	struct inode *inode = file->f_path.dentry->d_inode;
 	int res = -ENOTDIR;
+
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
 
@@ -30,6 +47,23 @@ int vfs_readdir(struct file *file, filld
 	if (res)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[old_readdir(), sys_getdents()]: calling ADF\n");
+	rsbac_target_id.dir.device = inode->i_sb->s_dev;
+	rsbac_target_id.dir.inode = inode->i_ino;
+	rsbac_target_id.dir.dentry_p = file->f_dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_READ,
+				task_pid(current),
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))	{
+		res = -EPERM;
+		goto out;
+	}
+#endif
+
 	res = mutex_lock_killable(&inode->i_mutex);
 	if (res)
 		goto out;
@@ -67,6 +101,9 @@ struct old_linux_dirent {
 
 struct readdir_callback {
 	struct old_linux_dirent __user * dirent;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	struct file * file;
+#endif
 	int result;
 };
 
@@ -79,6 +116,11 @@ static int fillonedir(void * __buf, cons
 
 	if (buf->result)
 		return -EINVAL;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	if (!rsbac_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+#endif
+
 	d_ino = ino;
 	if (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {
 		buf->result = -EOVERFLOW;
@@ -97,6 +139,7 @@ static int fillonedir(void * __buf, cons
 		__put_user(0, dirent->d_name + namlen))
 		goto efault;
 	return 0;
+
 efault:
 	buf->result = -EFAULT;
 	return -EFAULT;
@@ -116,6 +159,9 @@ SYSCALL_DEFINE3(old_readdir, unsigned in
 
 	buf.result = 0;
 	buf.dirent = dirent;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	buf.file = file;
+#endif
 
 	error = vfs_readdir(file, fillonedir, &buf);
 	if (buf.result)
@@ -142,6 +188,9 @@ struct linux_dirent {
 struct getdents_callback {
 	struct linux_dirent __user * current_dir;
 	struct linux_dirent __user * previous;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	struct file * file;
+#endif
 	int count;
 	int error;
 };
@@ -157,6 +206,10 @@ static int filldir(void * __buf, const c
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	if (!rsbac_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+#endif
 	d_ino = ino;
 	if (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {
 		buf->error = -EOVERFLOW;
@@ -183,6 +236,7 @@ static int filldir(void * __buf, const c
 	buf->current_dir = dirent;
 	buf->count -= reclen;
 	return 0;
+
 efault:
 	buf->error = -EFAULT;
 	return -EFAULT;
@@ -207,6 +261,9 @@ SYSCALL_DEFINE3(getdents, unsigned int, 
 
 	buf.current_dir = dirent;
 	buf.previous = NULL;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	buf.file = file;
+#endif
 	buf.count = count;
 	buf.error = 0;
 
@@ -230,6 +287,9 @@ struct getdents_callback64 {
 	struct linux_dirent64 __user * previous;
 	int count;
 	int error;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	struct file * file;
+#endif
 };
 
 static int filldir64(void * __buf, const char * name, int namlen, loff_t offset,
@@ -242,6 +302,12 @@ static int filldir64(void * __buf, const
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	if (!rsbac_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+#endif
+
 	dirent = buf->previous;
 	if (dirent) {
 		if (__put_user(offset, &dirent->d_off))
@@ -265,6 +331,7 @@ static int filldir64(void * __buf, const
 	buf->current_dir = dirent;
 	buf->count -= reclen;
 	return 0;
+
 efault:
 	buf->error = -EFAULT;
 	return -EFAULT;
@@ -289,6 +356,9 @@ SYSCALL_DEFINE3(getdents64, unsigned int
 
 	buf.current_dir = dirent;
 	buf.previous = NULL;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	buf.file = file;
+#endif
 	buf.count = count;
 	buf.error = 0;
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/read_write.c linux-2.6.31-rsbac-1.4.2/fs/read_write.c
--- trunk/fs/read_write.c	2009-09-10 18:14:57.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/read_write.c	2009-09-10 18:17:40.000000000 +0200
@@ -18,6 +18,12 @@
 #include <linux/splice.h>
 #include "read_write.h"
 
+#ifdef CONFIG_RSBAC_RW
+#include <net/sock.h>
+#include <net/af_unix.h>
+#endif
+#include <rsbac/hooks.h>
+
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
@@ -239,7 +245,7 @@ int rw_verify_area(int read_write, struc
 	return count > MAX_RW_COUNT ? MAX_RW_COUNT : count;
 }
 
-static void wait_on_retry_sync_kiocb(struct kiocb *iocb)
+void wait_on_retry_sync_kiocb(struct kiocb *iocb)
 {
 	set_current_state(TASK_UNINTERRUPTIBLE);
 	if (!kiocbIsKicked(iocb))
@@ -278,6 +284,10 @@ ssize_t vfs_read(struct file *file, char
 {
 	ssize_t ret;
 
+#ifdef CONFIG_RSBAC_RW
+	struct rsbac_rw_req rsbac_rw_req_obj;
+#endif
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!file->f_op || (!file->f_op->read && !file->f_op->aio_read))
@@ -288,6 +298,12 @@ ssize_t vfs_read(struct file *file, char
 	ret = rw_verify_area(READ, file, pos, count);
 	if (ret >= 0) {
 		count = ret;
+#ifdef CONFIG_RSBAC_RW
+		rsbac_rw_req_obj.rsbac_target = T_NONE;
+		rsbac_rw_req_obj.rsbac_request = R_READ;
+		if (!rsbac_handle_rw_req(file, &rsbac_rw_req_obj))
+			return -EPERM;
+#endif
 		if (file->f_op->read)
 			ret = file->f_op->read(file, buf, count, pos);
 		else
@@ -295,6 +311,9 @@ ssize_t vfs_read(struct file *file, char
 		if (ret > 0) {
 			fsnotify_access(file->f_path.dentry);
 			add_rchar(current, ret);
+#ifdef CONFIG_RSBAC_RW
+		rsbac_handle_rw_up(&rsbac_rw_req_obj);
+#endif
 		}
 		inc_syscr(current);
 	}
@@ -333,6 +352,10 @@ ssize_t vfs_write(struct file *file, con
 {
 	ssize_t ret;
 
+#ifdef CONFIG_RSBAC_RW
+	struct rsbac_rw_req rsbac_rw_req_obj;
+#endif
+
 	if (!(file->f_mode & FMODE_WRITE))
 		return -EBADF;
 	if (!file->f_op || (!file->f_op->write && !file->f_op->aio_write))
@@ -343,6 +366,12 @@ ssize_t vfs_write(struct file *file, con
 	ret = rw_verify_area(WRITE, file, pos, count);
 	if (ret >= 0) {
 		count = ret;
+#ifdef CONFIG_RSBAC_RW
+		rsbac_rw_req_obj.rsbac_target = T_NONE;
+		rsbac_rw_req_obj.rsbac_request = R_WRITE;
+		if (!rsbac_handle_rw_req(file, &rsbac_rw_req_obj))
+			return -EPERM;
+#endif
 		if (file->f_op->write)
 			ret = file->f_op->write(file, buf, count, pos);
 		else
@@ -350,6 +379,10 @@ ssize_t vfs_write(struct file *file, con
 		if (ret > 0) {
 			fsnotify_modify(file->f_path.dentry);
 			add_wchar(current, ret);
+
+#ifdef CONFIG_RSBAC_RW
+		rsbac_handle_rw_up(&rsbac_rw_req_obj);
+#endif
 		}
 		inc_syscw(current);
 	}
@@ -621,6 +654,11 @@ static ssize_t do_readv_writev(int type,
 	io_fn_t fn;
 	iov_fn_t fnv;
 
+#ifdef CONFIG_RSBAC_RW
+	struct rsbac_rw_req rsbac_rw_req_obj;
+	rsbac_rw_req_obj.rsbac_target = T_NONE;
+#endif
+
 	if (!file->f_op) {
 		ret = -EINVAL;
 		goto out;
@@ -636,6 +674,19 @@ static ssize_t do_readv_writev(int type,
 	if (ret < 0)
 		goto out;
 
+#ifdef CONFIG_RSBAC_RW
+	if (type == READ)
+		rsbac_rw_req_obj.rsbac_request = R_READ;
+	else
+/* if type wouldn't be WRITE here it's going to be funny ;)
+   kernel itself does NOT check on it. */
+		rsbac_rw_req_obj.rsbac_request = R_WRITE;
+        if(!rsbac_handle_rw_req(file, &rsbac_rw_req_obj)) {
+		ret = -EPERM;
+		goto out;
+	}
+#endif
+
 	fnv = NULL;
 	if (type == READ) {
 		fn = file->f_op->read;
@@ -660,6 +711,12 @@ out:
 		else
 			fsnotify_modify(file->f_path.dentry);
 	}
+
+#ifdef CONFIG_RSBAC_RW
+	if (ret > 0)
+		rsbac_handle_rw_up(&rsbac_rw_req_obj);
+#endif
+
 	return ret;
 }
 
@@ -796,6 +853,15 @@ static ssize_t do_sendfile(int out_fd, i
 	ssize_t retval;
 	int fput_needed_in, fput_needed_out, fl;
 
+#ifdef CONFIG_RSBAC_RW
+	struct rsbac_rw_req rsbac_rw_req_obj1;
+	struct rsbac_rw_req rsbac_rw_req_obj2;
+	struct socket * sock1;
+	struct socket * sock2;
+	rsbac_rw_req_obj1.rsbac_target = T_NONE;
+	rsbac_rw_req_obj2.rsbac_target = T_NONE;
+#endif
+
 	/*
 	 * Get input file, and verify that it is ok..
 	 */
@@ -816,6 +882,29 @@ static ssize_t do_sendfile(int out_fd, i
 		goto fput_in;
 	count = retval;
 
+#ifdef CONFIG_RSBAC_RW
+/* i could have done it in few lines of code, but that's way it is MUCH faster and sendfile is mostly beeing used with network sockets */
+	if (S_ISSOCK(in_file->f_dentry->d_inode->i_mode)) {
+		sock1 = SOCKET_I(in_file->f_dentry->d_inode);
+		if ((sock1->ops) && (sock1->ops->family != AF_UNIX)) {
+			rsbac_rw_req_obj1.rsbac_target = T_NETOBJ;
+                        rsbac_rw_req_obj1.rsbac_target_id.netobj.sock_p = sock1;
+                        rsbac_rw_req_obj1.rsbac_target_id.netobj.local_addr = NULL;
+                        rsbac_rw_req_obj1.rsbac_target_id.netobj.local_len = 0;
+                        rsbac_rw_req_obj1.rsbac_target_id.netobj.remote_addr = NULL;
+                        rsbac_rw_req_obj1.rsbac_target_id.netobj.remote_len = 0;
+                        rsbac_rw_req_obj1.rsbac_attribute = A_sock_type;
+                        rsbac_rw_req_obj1.rsbac_attribute_value.sock_type = sock1->type;
+                }
+	}	
+	rsbac_rw_req_obj1.rsbac_request = R_READ;
+	if(!rsbac_handle_rw_req(in_file, &rsbac_rw_req_obj1))
+	{
+		retval = -EPERM;
+		goto fput_in;
+	}
+#endif
+
 	/*
 	 * Get output file, and verify that it is ok..
 	 */
@@ -835,6 +924,28 @@ static ssize_t do_sendfile(int out_fd, i
 		goto fput_out;
 	count = retval;
 
+#ifdef CONFIG_RSBAC_RW
+	if (S_ISSOCK(out_file->f_dentry->d_inode->i_mode)) {
+		sock2 = SOCKET_I(out_file->f_dentry->d_inode);
+		if ((sock2->ops) && (sock2->ops->family != AF_UNIX)) {
+                        rsbac_rw_req_obj2.rsbac_target = T_NETOBJ;
+                        rsbac_rw_req_obj2.rsbac_target_id.netobj.sock_p = sock2;
+                        rsbac_rw_req_obj2.rsbac_target_id.netobj.local_addr = NULL;
+                        rsbac_rw_req_obj2.rsbac_target_id.netobj.local_len = 0;
+                        rsbac_rw_req_obj2.rsbac_target_id.netobj.remote_addr = NULL;
+                        rsbac_rw_req_obj2.rsbac_target_id.netobj.remote_len = 0;
+                        rsbac_rw_req_obj2.rsbac_attribute = A_sock_type;
+                        rsbac_rw_req_obj2.rsbac_attribute_value.sock_type = sock2->type;
+                }
+	}
+	rsbac_rw_req_obj2.rsbac_request = R_WRITE;
+	if(!rsbac_handle_rw_req(out_file, &rsbac_rw_req_obj2))
+	{
+		retval = -EPERM;
+		goto fput_out;
+	}
+#endif
+
 	if (!max)
 		max = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);
 
@@ -872,6 +983,11 @@ static ssize_t do_sendfile(int out_fd, i
 	if (*ppos > max)
 		retval = -EOVERFLOW;
 
+#ifdef CONFIG_RSBAC_RW
+	rsbac_handle_rw_up(&rsbac_rw_req_obj1);
+	rsbac_handle_rw_up(&rsbac_rw_req_obj2);
+#endif
+
 fput_out:
 	fput_light(out_file, fput_needed_out);
 fput_in:
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/reiserfs/namei.c linux-2.6.31-rsbac-1.4.2/fs/reiserfs/namei.c
--- trunk/fs/reiserfs/namei.c	2009-09-10 18:14:54.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/reiserfs/namei.c	2009-09-10 18:17:37.000000000 +0200
@@ -17,6 +17,7 @@
 #include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
 #include <linux/quotaops.h>
+#include <rsbac/hooks.h>
 
 #define INC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) { inc_nlink(i); if (i->i_nlink >= REISERFS_LINK_MAX) i->i_nlink=1; }
 #define DEC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) drop_nlink(i);
@@ -964,6 +965,11 @@ static int reiserfs_unlink(struct inode 
 	 * count so we don't race
 	 */
 	savelink = inode->i_nlink;
+	
+#ifdef CONFIG_RSBAC_SECDEL
+	if (inode->i_nlink == 1)
+		rsbac_sec_del(dentry, TRUE);
+#endif
 
 	retval =
 	    reiserfs_cut_from_item(&th, &path, &(de.de_entry_key), dir, NULL,
@@ -1343,6 +1349,11 @@ static int reiserfs_rename(struct inode 
 			journal_end(&th, old_dir->i_sb, jbegin_count);
 			reiserfs_write_unlock(old_dir->i_sb);
 			return -EIO;
+#ifdef CONFIG_RSBAC_SECDEL
+		} else {
+			if (new_dentry_inode && (new_dentry_inode->i_nlink == 1))
+				rsbac_sec_del(new_dentry, TRUE);
+#endif
 		}
 
 		copy_item_head(&new_entry_ih, get_ih(&new_entry_path));
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/reiserfs/xattr.c linux-2.6.31-rsbac-1.4.2/fs/reiserfs/xattr.c
--- trunk/fs/reiserfs/xattr.c	2009-09-10 18:14:53.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/reiserfs/xattr.c	2009-09-10 18:17:37.000000000 +0200
@@ -969,6 +969,10 @@ static const struct dentry_operations xa
 	.d_compare = xattr_lookup_poison,
 };
 
+#ifdef CONFIG_RSBAC
+struct dentry * rsbac_lookup_one_len(const char * name, struct dentry * base, int len);
+#endif
+
 int reiserfs_lookup_privroot(struct super_block *s)
 {
 	struct dentry *dentry;
@@ -1014,8 +1018,13 @@ int reiserfs_xattr_init(struct super_blo
 		mutex_lock(&privroot->d_inode->i_mutex);
 		if (!REISERFS_SB(s)->xattr_root) {
 			struct dentry *dentry;
+#ifdef CONFIG_RSBAC
+			dentry = rsbac_lookup_one_len(XAROOT_NAME, s->s_root,
+						strlen(XAROOT_NAME));
+#else
 			dentry = lookup_one_len(XAROOT_NAME, privroot,
 						strlen(XAROOT_NAME));
+#endif
 			if (!IS_ERR(dentry))
 				REISERFS_SB(s)->xattr_root = dentry;
 			else
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/stat.c linux-2.6.31-rsbac-1.4.2/fs/stat.c
--- trunk/fs/stat.c	2009-09-10 18:14:55.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/stat.c	2009-09-10 18:17:38.000000000 +0200
@@ -18,6 +18,11 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#include <rsbac/hooks.h>
+#endif
+
 void generic_fillattr(struct inode *inode, struct kstat *stat)
 {
 	stat->dev = inode->i_sb->s_dev;
@@ -30,6 +35,16 @@ void generic_fillattr(struct inode *inod
 	stat->atime = inode->i_atime;
 	stat->mtime = inode->i_mtime;
 	stat->ctime = inode->i_ctime;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+#ifdef CONFIG_RSBAC_SYM_REDIR_MAC_CAT
+	if (S_ISLNK(inode->i_mode))
+		stat->size = i_size_read(inode) + 85;
+#else
+	if (S_ISLNK(inode->i_mode))
+		stat->size = i_size_read(inode) + 20;
+#endif
+	else
+#endif
 	stat->size = i_size_read(inode);
 	stat->blocks = inode->i_blocks;
 	stat->blksize = (1 << inode->i_blkbits);
@@ -42,10 +57,51 @@ int vfs_getattr(struct vfsmount *mnt, st
 	struct inode *inode = dentry->d_inode;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	retval = security_inode_getattr(mnt, dentry);
 	if (retval)
 		return retval;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_stat() etc.]: calling ADF\n");
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode)) {
+		if (inode->i_sb->s_magic == SOCKFS_MAGIC) {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+		} else {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = inode->i_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = dentry;
+		}
+	} else
+		rsbac_target = T_FILE;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		return -EPERM;
+	}
+#endif
+
 	if (inode->i_op->getattr)
 		return inode->i_op->getattr(mnt, dentry, stat);
 
@@ -287,6 +343,11 @@ SYSCALL_DEFINE4(readlinkat, int, dfd, co
 	struct path path;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (bufsiz <= 0)
 		return -EINVAL;
 
@@ -298,6 +359,24 @@ SYSCALL_DEFINE4(readlinkat, int, dfd, co
 		if (inode->i_op->readlink) {
 			error = security_inode_readlink(path.dentry);
 			if (!error) {
+#ifdef CONFIG_RSBAC
+				rsbac_pr_debug(aef, "calling ADF\n");
+				rsbac_target_id.file.device = path.dentry->d_sb->s_dev;
+				rsbac_target_id.file.inode  = inode->i_ino;
+				rsbac_target_id.file.dentry_p = path.dentry;
+				rsbac_attribute_value.dummy = 0;
+				if (!rsbac_adf_request(R_GET_STATUS_DATA,
+							task_pid(current),
+							T_SYMLINK,
+							rsbac_target_id,
+							A_none,
+							rsbac_attribute_value))
+				{
+					path_put(&path);
+					return -EPERM;
+				}
+#endif
+
 				touch_atime(path.mnt, path.dentry);
 				error = inode->i_op->readlink(path.dentry,
 							      buf, bufsiz);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/sysfs/file.c linux-2.6.31-rsbac-1.4.2/fs/sysfs/file.c
--- trunk/fs/sysfs/file.c	2009-09-10 18:14:59.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/sysfs/file.c	2009-09-10 18:17:41.000000000 +0200
@@ -24,6 +24,8 @@
 
 #include "sysfs.h"
 
+#include <rsbac/hooks.h>
+
 /* used in crash dumps to help with debugging */
 static char last_sysfs_file[PATH_MAX];
 void sysfs_printk_last_file(void)
@@ -338,6 +340,11 @@ static int sysfs_open_file(struct inode 
 	int error = -EACCES;
 	char *p;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	p = d_path(&file->f_path, last_sysfs_file, sizeof(last_sysfs_file));
 	if (p)
 		memmove(last_sysfs_file, p, strlen(p) + 1);
@@ -362,6 +369,21 @@ static int sysfs_open_file(struct inode 
 	if (file->f_mode & FMODE_WRITE) {
 		if (!(inode->i_mode & S_IWUGO) || !ops->store)
 			goto err_out;
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sysfs_open_file()]: calling ADF\n");
+		rsbac_target_id.scd = ST_sysfs;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_owner,
+					rsbac_attribute_value))
+		{
+			error = -EPERM;
+			goto err_out;
+		}
+#endif
 	}
 
 	/* File needs read support.
@@ -371,6 +393,22 @@ static int sysfs_open_file(struct inode 
 	if (file->f_mode & FMODE_READ) {
 		if (!(inode->i_mode & S_IRUGO) || !ops->show)
 			goto err_out;
+
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sysfs_open_file()]: calling ADF\n");
+		rsbac_target_id.scd = ST_sysfs;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_owner,
+					rsbac_attribute_value))
+		{
+			error = -EPERM;
+			goto err_out;
+		}
+#endif
 	}
 
 	/* No error? Great, allocate a buffer for the file, and store it
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/sysfs/mount.c linux-2.6.31-rsbac-1.4.2/fs/sysfs/mount.c
--- trunk/fs/sysfs/mount.c	2009-09-10 18:14:59.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/sysfs/mount.c	2009-09-10 18:17:41.000000000 +0200
@@ -19,6 +19,10 @@
 #include <linux/module.h>
 #include <linux/magic.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #include "sysfs.h"
 
 
@@ -109,6 +113,9 @@ int __init sysfs_init(void)
 			unregister_filesystem(&sysfs_fs_type);
 			goto out_err;
 		}
+#ifdef CONFIG_RSBAC
+		rsbac_mount(sysfs_mount);
+#endif
 	} else
 		goto out_err;
 out:
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/utimes.c linux-2.6.31-rsbac-1.4.2/fs/utimes.c
--- trunk/fs/utimes.c	2009-09-10 18:14:52.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/utimes.c	2009-09-10 18:17:36.000000000 +0200
@@ -10,6 +10,7 @@
 #include <linux/syscalls.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
+#include <rsbac/hooks.h>
 
 #ifdef __ARCH_WANT_SYS_UTIME
 
@@ -54,6 +55,12 @@ static int utimes_common(struct path *pa
 	struct iattr newattrs;
 	struct inode *inode = path->dentry->d_inode;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = mnt_want_write(path->mnt);
 	if (error)
 		goto out;
@@ -94,13 +101,43 @@ static int utimes_common(struct path *pa
 		error = -EACCES;
                 if (IS_IMMUTABLE(inode))
 			goto mnt_drop_write_and_out;
-
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+		if (!rsbac_dac_part_disabled(path->dentry))
+#endif
 		if (!is_owner_or_cap(inode)) {
 			error = inode_permission(inode, MAY_WRITE);
 			if (error)
 				goto mnt_drop_write_and_out;
 		}
 	}
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = path->dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_ACCESS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto mnt_drop_write_and_out;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	error = notify_change(path->dentry, &newattrs);
 	mutex_unlock(&inode->i_mutex);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/xattr.c linux-2.6.31-rsbac-1.4.2/fs/xattr.c
--- trunk/fs/xattr.c	2009-09-10 18:14:54.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/xattr.c	2009-09-10 18:17:37.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/audit.h>
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
 
 /*
  * Check permissions for extended attribute access.  This is a bit complicated
@@ -73,6 +74,13 @@ vfs_setxattr(struct dentry *dentry, cons
 	struct inode *inode = dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+
 	error = xattr_permission(inode, name, MAY_WRITE);
 	if (error)
 		return error;
@@ -81,6 +89,31 @@ vfs_setxattr(struct dentry *dentry, cons
 	error = security_inode_setxattr(dentry, name, value, size, flags);
 	if (error)
 		goto out;
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_*setxattr()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		error = -EPERM;
+		goto out;
+	}
+#endif
 	error = -EOPNOTSUPP;
 	if (inode->i_op->setxattr) {
 		error = inode->i_op->setxattr(dentry, name, value, size, flags);
@@ -136,6 +169,12 @@ vfs_getxattr(struct dentry *dentry, cons
 	struct inode *inode = dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = xattr_permission(inode, name, MAY_READ);
 	if (error)
 		return error;
@@ -144,6 +183,33 @@ vfs_getxattr(struct dentry *dentry, cons
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_*getxattr()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		return error;
+	}
+#endif
+
 	if (!strncmp(name, XATTR_SECURITY_PREFIX,
 				XATTR_SECURITY_PREFIX_LEN)) {
 		const char *suffix = name + XATTR_SECURITY_PREFIX_LEN;
@@ -170,7 +236,36 @@ ssize_t
 vfs_listxattr(struct dentry *d, char *list, size_t size)
 {
 	ssize_t error;
-
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_*listxattr()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(d->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(d->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(d->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(d->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = d->d_sb->s_dev;
+	rsbac_target_id.file.inode  = d->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = d;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))	{
+		return -EPERM;
+	}
+#endif
 	error = security_inode_listxattr(d);
 	if (error)
 		return error;
@@ -192,6 +287,12 @@ vfs_removexattr(struct dentry *dentry, c
 	struct inode *inode = dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!inode->i_op->removexattr)
 		return -EOPNOTSUPP;
 
@@ -203,6 +304,33 @@ vfs_removexattr(struct dentry *dentry, c
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_*removexattr()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		return error;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	error = inode->i_op->removexattr(dentry, name);
 	mutex_unlock(&inode->i_mutex);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/fs/xfs/linux-2.6/xfs_iops.c linux-2.6.31-rsbac-1.4.2/fs/xfs/linux-2.6/xfs_iops.c
--- trunk/fs/xfs/linux-2.6/xfs_iops.c	2009-09-10 18:14:52.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/fs/xfs/linux-2.6/xfs_iops.c	2009-09-10 18:17:37.000000000 +0200
@@ -57,6 +57,8 @@
 #include <linux/falloc.h>
 #include <linux/fiemap.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * Bring the atime in the XFS inode uptodate.
  * Used before logging the inode to disk or when the Linux inode goes away.
@@ -371,6 +373,10 @@ xfs_vn_unlink(
 	struct xfs_name	name;
 	int		error;
 
+#ifdef CONFIG_RSBAC_SECDEL
+	if (dentry->d_inode->i_nlink == 1)
+		rsbac_sec_del(dentry, FALSE);
+#endif
 	xfs_dentry_to_name(&name, dentry);
 
 	error = -xfs_remove(XFS_I(dir), &name, XFS_I(dentry->d_inode));
@@ -432,10 +438,34 @@ xfs_vn_rename(
 	struct inode	*new_inode = ndentry->d_inode;
 	struct xfs_name	oname;
 	struct xfs_name	nname;
-
+#ifdef CONFIG_RSBAC_SECDEL
+	struct xfs_inode *cip;
+#endif
+        
 	xfs_dentry_to_name(&oname, odentry);
 	xfs_dentry_to_name(&nname, ndentry);
 
+#ifdef CONFIG_RSBAC_SECDEL
+	/* RSBAC secure delete code. in the event of overwritting existing
+	 * file with sec_del flag set, its blocks will be deallocated so we
+	 * have to overwrite their content. since XFS does all the necessary
+	 * checks on the layer below linux VFS, operating on vnodes
+	 * i decided to implement my own set of checks here, so we can see
+	 * if the existing file is being overwritten.
+	 * inspired by ext2/3/4 and jfs code. michal@rsbac.org 
+	 */
+
+	if (new_inode) {
+		if (new_inode->i_nlink == 1) {
+			if (!xfs_lookup(XFS_I(ndir), &nname, &cip, NULL)) {
+				IRELE(cip);
+				if(!S_ISDIR(new_inode->i_mode))
+					rsbac_sec_del(ndentry, TRUE);
+			}
+		}
+	}
+#endif
+	
 	return -xfs_rename(XFS_I(odir), &oname, XFS_I(odentry->d_inode),
 			   XFS_I(ndir), &nname, new_inode ?
 			   			XFS_I(new_inode) : NULL);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/include/linux/sched.h linux-2.6.31-rsbac-1.4.2/include/linux/sched.h
--- trunk/include/linux/sched.h	2009-09-10 18:14:36.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/include/linux/sched.h	2009-09-10 18:17:18.000000000 +0200
@@ -28,6 +28,9 @@
 #define CLONE_NEWPID		0x20000000	/* New pid namespace */
 #define CLONE_NEWNET		0x40000000	/* New network namespace */
 #define CLONE_IO		0x80000000	/* Clone io context */
+#ifdef CONFIG_RSBAC
+#define CLONE_KTHREAD           0x100000000      /* clone a kernel thread */
+#endif
 
 /*
  * Scheduling policies
@@ -92,6 +95,10 @@ struct sched_param {
 
 #include <asm/processor.h>
 
+#if defined(CONFIG_RSBAC_CAP_LOG_MISSING) || defined(CONFIG_RSBAC_JAIL_LOG_MISSING)
+#include <rsbac/log_cap.h>
+#endif
+
 struct exec_domain;
 struct futex_pi_state;
 struct robust_list_head;
@@ -104,7 +111,11 @@ struct perf_counter_context;
  * List of flags we want to share for kernel threads,
  * if only because they are not used by them anyway.
  */
+#ifdef CONFIG_RSBAC
+#define CLONE_KERNEL	(CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_KTHREAD)
+#else
 #define CLONE_KERNEL	(CLONE_FS | CLONE_FILES | CLONE_SIGHAND)
+#endif
 
 /*
  * These are the constant used to fake the fixed-point load-average
@@ -2027,6 +2038,13 @@ static inline void mmdrop(struct mm_stru
 
 /* mmput gets rid of the mappings and all user-space */
 extern void mmput(struct mm_struct *);
+#ifdef CONFIG_RSBAC
+/* mmput gets rid of the mappings and all user-space 
+ * not sleeping version. feeling like we have something in common ;)
+ * michal.
+ * */
+extern void mmput_nosleep(struct mm_struct *);
+#endif
 /* Grab a reference to a task's mm, if it is not already going away */
 extern struct mm_struct *get_task_mm(struct task_struct *task);
 /* Remove the current tasks stale references to the old mm_struct */
@@ -2053,7 +2071,11 @@ extern int allow_signal(int);
 extern int disallow_signal(int);
 
 extern int do_execve(char *, char __user * __user *, char __user * __user *, struct pt_regs *);
+#ifdef CONFIG_RSBAC
+extern long do_fork(unsigned long long, unsigned long, struct pt_regs *, unsigned long, int __user *, int __user *);
+#else
 extern long do_fork(unsigned long, unsigned long, struct pt_regs *, unsigned long, int __user *, int __user *);
+#endif
 struct task_struct *fork_idle(int);
 
 extern void set_task_comm(struct task_struct *tsk, char *from);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/init/do_mounts.c linux-2.6.31-rsbac-1.4.2/init/do_mounts.c
--- trunk/init/do_mounts.c	2009-09-10 18:14:51.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/init/do_mounts.c	2009-09-10 18:17:35.000000000 +0200
@@ -22,6 +22,14 @@
 
 #include "do_mounts.h"
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#include <rsbac/debug.h>
+#ifdef CONFIG_BLK_DEV_INITRD
+#include <linux/initrd.h>
+#endif
+#endif
+
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
 
 int root_mountflags = MS_RDONLY | MS_SILENT;
@@ -417,5 +425,13 @@ void __init prepare_namespace(void)
 out:
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
+
+        /* RSBAC: OK, most stuff initialized and root mounted: Init RSBAC. */
+#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_INIT_DELAY
+        if(rsbac_no_delay_init)
+#endif
+        rsbac_init(ROOT_DEV);
+#endif
 }
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/init/main.c linux-2.6.31-rsbac-1.4.2/init/main.c
--- trunk/init/main.c	2009-09-10 18:14:51.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/init/main.c	2009-09-10 18:17:35.000000000 +0200
@@ -76,6 +76,10 @@
 #include <asm/sections.h>
 #include <asm/cacheflush.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #ifdef CONFIG_X86_LOCAL_APIC
 #include <asm/smp.h>
 #endif
@@ -696,6 +700,9 @@ asmlinkage void __init start_kernel(void
 	buffer_init();
 	key_init();
 	security_init();
+#ifdef CONFIG_RSBAC
+	rsbac_kthreads_init();
+#endif
 	vfs_caches_init(num_physpages);
 	radix_tree_init();
 	signals_init();
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/ipc/mqueue.c linux-2.6.31-rsbac-1.4.2/ipc/mqueue.c
--- trunk/ipc/mqueue.c	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/ipc/mqueue.c	2009-09-10 18:17:52.000000000 +0200
@@ -34,6 +34,10 @@
 #include <linux/ipc_namespace.h>
 #include <linux/ima.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #include <net/sock.h>
 #include "util.h"
 
@@ -1289,6 +1293,9 @@ static int __init init_mqueue_fs(void)
 		goto out_filesystem;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_mount(init_ipc_ns.mq_mnt);
+#endif
 	return 0;
 
 out_filesystem:
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/ipc/msg.c linux-2.6.31-rsbac-1.4.2/ipc/msg.c
--- trunk/ipc/msg.c	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/ipc/msg.c	2009-09-10 18:17:52.000000000 +0200
@@ -42,6 +42,7 @@
 #include <asm/current.h>
 #include <asm/uaccess.h>
 #include "util.h"
+#include <rsbac/hooks.h>
 
 /*
  * one msg_receiver structure for each sleeping receiver:
@@ -184,6 +185,12 @@ static int newque(struct ipc_namespace *
 	key_t key = params->key;
 	int msgflg = params->flg;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	msq = ipc_rcu_alloc(sizeof(*msq));
 	if (!msq)
 		return -ENOMEM;
@@ -191,6 +198,23 @@ static int newque(struct ipc_namespace *
 	msq->q_perm.mode = msgflg & S_IRWXUGO;
 	msq->q_perm.key = key;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_msgget()]: calling ADF\n");
+	rsbac_target_id.ipc.type = I_msg;
+	rsbac_target_id.ipc.id.id_nr = 0;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ipc_rcu_putref(msq);
+		return -EPERM;
+	}
+#endif
+
 	msq->q_perm.security = NULL;
 	retval = security_msg_queue_alloc(msq);
 	if (retval) {
@@ -217,6 +241,25 @@ static int newque(struct ipc_namespace *
 	INIT_LIST_HEAD(&msq->q_receivers);
 	INIT_LIST_HEAD(&msq->q_senders);
 
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.ipc.type = I_msg;
+	rsbac_target_id.ipc.id.id_nr = msq->q_perm.id;
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"newque() [sys_msgget()]: rsbac_adf_set_attr() returned error");
+	}
+#endif
+
+
 	msg_unlock(msq);
 
 	return msq->q_perm.id;
@@ -415,6 +458,11 @@ static int msgctl_down(struct ipc_namesp
 	struct msqid64_ds msqid64;
 	struct msg_queue *msq;
 	int err;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (cmd == IPC_SET) {
 		if (copy_msqid_from_user(&msqid64, buf, version))
@@ -434,7 +482,38 @@ static int msgctl_down(struct ipc_namesp
 
 	switch (cmd) {
 	case IPC_RMID:
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.ipc.type = I_msg;
+		rsbac_target_id.ipc.id.id_nr = msqid;
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_DELETE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out_unlock;
+		}
+#endif
 		freeque(ns, ipcp);
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_DELETE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_msgctl(): rsbac_adf_set_attr() returned error");
+		}
+#endif
 		goto out_up;
 	case IPC_SET:
 		if (msqid64.msg_qbytes > ns->msg_ctlmnb &&
@@ -442,7 +521,52 @@ static int msgctl_down(struct ipc_namesp
 			err = -EPERM;
 			goto out_unlock;
 		}
-
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.ipc.type = I_msg;
+		rsbac_target_id.ipc.id.id_nr = msqid;
+		if (ipcp->uid != msqid64.msg_perm.uid) {
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.owner = msqid64.msg_perm.uid;
+			if (!rsbac_adf_request(R_CHANGE_OWNER,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						A_owner,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+		if (ipcp->gid != msqid64.msg_perm.gid) {
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.group = msqid64.msg_perm.gid;
+			if (!rsbac_adf_request(R_CHANGE_GROUP,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						A_group,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+		if (ipcp->mode != ((ipcp->mode & ~S_IRWXUGO) | (S_IRWXUGO & msqid64.msg_perm.mode))) {
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.mode = (S_IRWXUGO & msqid64.msg_perm.mode);
+			if (!rsbac_adf_request(R_ALTER,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						A_mode,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+#endif
 		msq->q_qbytes = msqid64.msg_qbytes;
 
 		ipc_update_perm(&msqid64.msg_perm, ipcp);
@@ -640,6 +764,12 @@ long do_msgsnd(int msqid, long mtype, vo
 	int err;
 	struct ipc_namespace *ns;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	ns = current->nsproxy->ipc_ns;
 
 	if (msgsz > ns->msg_ctlmax || (long) msgsz < 0 || msqid < 0)
@@ -647,6 +777,22 @@ long do_msgsnd(int msqid, long mtype, vo
 	if (mtype < 1)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type   = I_msg;
+	rsbac_target_id.ipc.id.id_nr  = msqid;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEND,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	msg = load_msg(mtext, msgsz);
 	if (IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -712,6 +858,22 @@ long do_msgsnd(int msqid, long mtype, vo
 		atomic_inc(&ns->msg_hdrs);
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_SEND,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"sys_msgsnd(): rsbac_adf_set_attr() returned error");
+	}
+#endif
+
 	err = 0;
 	msg = NULL;
 
@@ -760,11 +922,33 @@ long do_msgrcv(int msqid, long *pmtype, 
 	int mode;
 	struct ipc_namespace *ns;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (msqid < 0 || (long) msgsz < 0)
 		return -EINVAL;
 	mode = convert_mode(&msgtyp, msgflg);
 	ns = current->nsproxy->ipc_ns;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type   = I_msg;
+	rsbac_target_id.ipc.id.id_nr  = msqid;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_RECEIVE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	msq = msg_lock_check(ns, msqid);
 	if (IS_ERR(msq))
 		return PTR_ERR(msq);
@@ -808,6 +992,23 @@ long do_msgrcv(int msqid, long *pmtype, 
 				msg = ERR_PTR(-E2BIG);
 				goto out_unlock;
 			}
+	                /* RSBAC: notify ADF of opened ipc */
+#ifdef CONFIG_RSBAC
+			rsbac_new_target_id.dummy = 0;
+			if (rsbac_adf_set_attr(R_RECEIVE,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"sys_msgrcv(): rsbac_adf_set_attr() returned error");
+			}
+#endif
+
 			list_del(&msg->m_list);
 			msq->q_qnum--;
 			msq->q_rtime = get_seconds();
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/ipc/sem.c linux-2.6.31-rsbac-1.4.2/ipc/sem.c
--- trunk/ipc/sem.c	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/ipc/sem.c	2009-09-10 18:17:52.000000000 +0200
@@ -86,6 +86,7 @@
 
 #include <asm/uaccess.h>
 #include "util.h"
+#include <rsbac/hooks.h>
 
 #define sem_ids(ns)	((ns)->ids[IPC_SEM_IDS])
 
@@ -241,6 +242,12 @@ static int newary(struct ipc_namespace *
 	int nsems = params->u.nsems;
 	int semflg = params->flg;
 
+#ifdef CONFIG_RSBAC_IPC_SEM
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!nsems)
 		return -EINVAL;
 	if (ns->used_sems + nsems > ns->sc_semmns)
@@ -256,6 +263,23 @@ static int newary(struct ipc_namespace *
 	sma->sem_perm.mode = (semflg & S_IRWXUGO);
 	sma->sem_perm.key = key;
 
+#ifdef CONFIG_RSBAC_IPC_SEM
+	rsbac_pr_debug(aef, "[sys_semget()]: calling ADF\n");
+	rsbac_target_id.ipc.type = I_sem;
+	rsbac_target_id.ipc.id.id_nr = 0;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ipc_rcu_putref(sma);
+		return -EPERM;
+	}
+#endif
+
 	sma->sem_perm.security = NULL;
 	retval = security_sem_alloc(sma);
 	if (retval) {
@@ -278,6 +302,21 @@ static int newary(struct ipc_namespace *
 	sma->sem_ctime = get_seconds();
 	sem_unlock(sma);
 
+/* RSBAC: notify ADF of new shm */
+#ifdef CONFIG_RSBAC_IPC_SEM
+	rsbac_target_id.ipc.id.id_nr = sma->sem_perm.id;
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+		rsbac_printk(KERN_WARNING
+		"newary() [sys_semget()]: rsbac_adf_set_attr() returned error\n");
+#endif
 	return sma->sem_perm.id;
 }
 
@@ -668,6 +707,12 @@ static int semctl_main(struct ipc_namesp
 	ushort* sem_io = fast_sem_io;
 	int nsems;
 
+#ifdef CONFIG_RSBAC_IPC_SEM
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sma = sem_lock_check(ns, semid);
 	if (IS_ERR(sma))
 		return PTR_ERR(sma);
@@ -706,12 +751,49 @@ static int semctl_main(struct ipc_namesp
 			}
 		}
 
+#ifdef CONFIG_RSBAC_IPC_SEM
+		rsbac_target_id.ipc.type = I_sem;
+		rsbac_target_id.ipc.id.id_nr = semid;
+		rsbac_pr_debug(aef, "[sys_semctl()]: calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_READ,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out_unlock;
+		}
+#endif
+
 		for (i = 0; i < sma->sem_nsems; i++)
 			sem_io[i] = sma->sem_base[i].semval;
 		sem_unlock(sma);
 		err = 0;
 		if(copy_to_user(array, sem_io, nsems*sizeof(ushort)))
 			err = -EFAULT;
+
+		/* RSBAC: notify ADF of read sem */
+#ifdef CONFIG_RSBAC_IPC_SEM
+		if(!err) {
+			rsbac_new_target_id.dummy = 0;
+			if (rsbac_adf_set_attr(R_READ,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"semctl_main() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+			}
+		}
+#endif
+
 		goto out_free;
 	}
 	case SETALL:
@@ -735,6 +817,23 @@ static int semctl_main(struct ipc_namesp
 			goto out_free;
 		}
 
+#ifdef CONFIG_RSBAC_IPC_SEM
+		rsbac_target_id.ipc.type = I_sem;
+		rsbac_target_id.ipc.id.id_nr = semid;
+		rsbac_pr_debug(aef, "[sys_semctl()]: calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_WRITE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value)) {
+			err = -EPERM;
+			sem_putref(sma);
+			goto out_free;
+		}
+#endif
+
 		for (i = 0; i < nsems; i++) {
 			if (sem_io[i] > SEMVMX) {
 				sem_putref(sma);
@@ -758,6 +857,24 @@ static int semctl_main(struct ipc_namesp
 				un->semadj[i] = 0;
 		}
 		sma->sem_ctime = get_seconds();
+
+                /* RSBAC: notify ADF of written sem */
+#ifdef CONFIG_RSBAC_IPC_SEM
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_WRITE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"semctl_main() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+		}
+#endif
+
 		/* maybe some queued-up processes were waiting for this */
 		update_queue(sma);
 		err = 0;
@@ -793,6 +910,23 @@ static int semctl_main(struct ipc_namesp
 		if (val > SEMVMX || val < 0)
 			goto out_unlock;
 
+#ifdef CONFIG_RSBAC_IPC_SEM
+		rsbac_target_id.ipc.type = I_sem;
+		rsbac_target_id.ipc.id.id_nr = semid;
+		rsbac_pr_debug(aef, "[sys_semctl()]: calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_WRITE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out_unlock;
+		}
+#endif
+
 		assert_spin_locked(&sma->sem_perm.lock);
 		list_for_each_entry(un, &sma->list_id, list_id)
 			un->semadj[semnum] = 0;
@@ -853,6 +987,12 @@ static int semctl_down(struct ipc_namesp
 	struct semid64_ds semid64;
 	struct kern_ipc_perm *ipcp;
 
+#ifdef CONFIG_RSBAC_IPC_SEM
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if(cmd == IPC_SET) {
 		if (copy_semid_from_user(&semid64, arg.buf, version))
 			return -EFAULT;
@@ -870,9 +1010,90 @@ static int semctl_down(struct ipc_namesp
 
 	switch(cmd){
 	case IPC_RMID:
+#ifdef CONFIG_RSBAC_IPC_SEM
+		rsbac_target_id.ipc.type = I_sem;
+		rsbac_target_id.ipc.id.id_nr = semid;
+		rsbac_pr_debug(aef, "[sys_semctl()]: calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_DELETE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out_unlock;
+		}
+#endif
+
 		freeary(ns, ipcp);
+
+                /* RSBAC: notify ADF of deleted sem */
+#ifdef CONFIG_RSBAC_IPC_SEM
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_DELETE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"semctl_down() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+		}
+#endif
+
 		goto out_up;
 	case IPC_SET:
+#ifdef CONFIG_RSBAC_IPC_SEM
+		rsbac_target_id.ipc.type = I_sem;
+		rsbac_target_id.ipc.id.id_nr = semid;
+		if (ipcp->uid != semid64.sem_perm.uid) {
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.owner = semid64.sem_perm.uid;
+			if (!rsbac_adf_request(R_CHANGE_OWNER,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						A_owner,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+		if (ipcp->gid != semid64.sem_perm.gid) {
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.group = semid64.sem_perm.gid;
+			if (!rsbac_adf_request(R_CHANGE_GROUP,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						A_group,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+		if (ipcp->mode != ((ipcp->mode & ~S_IRWXUGO) | (S_IRWXUGO & semid64.sem_perm.mode))) {
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.mode = (S_IRWXUGO & semid64.sem_perm.mode);
+			if (!rsbac_adf_request(R_ALTER,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						A_mode,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+#endif
 		ipc_update_perm(&semid64.sem_perm, ipcp);
 		sma->sem_ctime = get_seconds();
 		break;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/ipc/shm.c linux-2.6.31-rsbac-1.4.2/ipc/shm.c
--- trunk/ipc/shm.c	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/ipc/shm.c	2009-09-10 18:17:52.000000000 +0200
@@ -45,6 +45,8 @@
 
 #include "util.h"
 
+#include <rsbac/hooks.h>
+
 struct shm_file_data {
 	int id;
 	struct ipc_namespace *ns;
@@ -85,6 +87,11 @@ void shm_init_ns(struct ipc_namespace *n
  */
 static void do_shm_rmid(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 	struct shmid_kernel *shp;
 	shp = container_of(ipcp, struct shmid_kernel, shm_perm);
 
@@ -93,8 +100,25 @@ static void do_shm_rmid(struct ipc_names
 		/* Do not find it any more */
 		shp->shm_perm.key = IPC_PRIVATE;
 		shm_unlock(shp);
-	} else
+	} else {
 		shm_destroy(ns, shp);
+			/* RSBAC: notify ADF of deleted shm */
+#ifdef CONFIG_RSBAC
+			rsbac_new_target_id.dummy = 0;
+			if (rsbac_adf_set_attr(R_DELETE,
+						task_pid(current),
+						T_IPC,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"sys_shmctl(): rsbac_adf_set_attr() returned error");
+			}
+#endif
+	}
 }
 
 #ifdef CONFIG_IPC_NS
@@ -169,6 +193,10 @@ static void shm_open(struct vm_area_stru
  */
 static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+#endif
+
 	ns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid(ns, shp);
 	shm_unlock(shp);
@@ -179,6 +207,14 @@ static void shm_destroy(struct ipc_names
 						shp->mlock_user);
 	fput (shp->shm_file);
 	security_shm_free(shp);
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ACI remove_target()\n");
+	rsbac_target_id.ipc.type   = I_shm;
+	rsbac_target_id.ipc.id.id_nr  = shp->shm_perm.id;
+	rsbac_remove_target(T_IPC, rsbac_target_id);
+#endif
+
 	ipc_rcu_putref(shp);
 }
 
@@ -195,6 +231,28 @@ static void shm_close(struct vm_area_str
 	struct shmid_kernel *shp;
 	struct ipc_namespace *ns = sfd->ns;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_shmdt() et al.]: calling ADF\n");
+	rsbac_target_id.ipc.type   = I_shm;
+	rsbac_target_id.ipc.id.id_nr  = sfd->id;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CLOSE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"shm_close() [sys_shmdt() et al.]: rsbac_adf_request() for CLOSE returned NOT_GRANTED\n");
+	}
+#endif
+
 	down_write(&shm_ids(ns).rw_mutex);
 	/* remove from the list of attaches of the shm segment */
 	shp = shm_lock(ns, sfd->id);
@@ -343,6 +401,12 @@ static int newseg(struct ipc_namespace *
 	int id;
 	int acctflag = 0;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (size < SHMMIN || size > ns->shm_ctlmax)
 		return -EINVAL;
 
@@ -353,6 +417,23 @@ static int newseg(struct ipc_namespace *
 	if (!shp)
 		return -ENOMEM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_shmget()]: calling ADF\n");
+	rsbac_target_id.ipc.type = I_shm;
+	rsbac_target_id.ipc.id.id_nr = 0;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ipc_rcu_putref(shp);
+		return -EPERM;
+	}
+#endif
+
 	shp->shm_perm.key = key;
 	shp->shm_perm.mode = (shmflg & S_IRWXUGO);
 	shp->mlock_user = NULL;
@@ -407,6 +488,23 @@ static int newseg(struct ipc_namespace *
 	ns->shm_tot += numpages;
 	error = shp->shm_perm.id;
 	shm_unlock(shp);
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+	rsbac_new_target_id.ipc.type = I_shm;
+	rsbac_new_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+	if (rsbac_adf_set_attr(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				T_IPC,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"newseg() [sys_shmget()]: rsbac_adf_set_attr() returned error");
+	}
+#endif
 	return error;
 
 no_id:
@@ -637,6 +735,11 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int,
 	struct shmid_kernel *shp;
 	int err, version;
 	struct ipc_namespace *ns;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 
 	if (cmd < 0 || shmid < 0) {
 		err = -EINVAL;
@@ -769,7 +872,7 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int,
 		err = security_shm_shmctl(shp, cmd);
 		if (err)
 			goto out_unlock;
-		
+	
 		if(cmd==SHM_LOCK) {
 			struct user_struct *user = current_user();
 			if (!is_file_hugepages(shp->shm_file)) {
@@ -788,7 +891,39 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int,
 		goto out;
 	}
 	case IPC_RMID:
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.ipc.type = I_shm;
+		rsbac_target_id.ipc.id.id_nr = shmid;
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_DELETE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out_unlock;
+		}
+#endif
 	case IPC_SET:
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.ipc.type = I_shm;
+		rsbac_target_id.ipc.id.id_nr = shmid;
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_DELETE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out_unlock;
+		}
+#endif
 		err = shmctl_down(ns, shmid, cmd, buf, version);
 		return err;
 	default:
@@ -824,6 +959,13 @@ long do_shmat(int shmid, char __user *sh
 	struct path path;
 	fmode_t f_mode;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t rsbac_request = R_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	err = -EINVAL;
 	if (shmid < 0)
 		goto out;
@@ -878,6 +1020,27 @@ long do_shmat(int shmid, char __user *sh
 	if (err)
 		goto out_unlock;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef,  "calling ADF\n");
+	if ((shmflg & SHM_RDONLY))
+		rsbac_request = R_READ_OPEN;
+	else
+		rsbac_request = R_READ_WRITE_OPEN;
+	rsbac_target_id.ipc.type   = I_shm;
+	rsbac_target_id.ipc.id.id_nr  = shp->shm_perm.id;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto out_unlock;
+	}
+#endif
+
 	path.dentry = dget(shp->shm_file->f_path.dentry);
 	path.mnt    = shp->shm_file->f_path.mnt;
 	shp->shm_nattch++;
@@ -938,6 +1101,25 @@ out_nattch:
 	up_write(&shm_ids(ns).rw_mutex);
 
 out:
+/* RSBAC: notify ADF of attached shm */
+#ifdef CONFIG_RSBAC
+	if(!err) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(rsbac_request,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_shmat(): rsbac_adf_set_attr() returned error");
+		}
+	}
+#endif
+
 	return err;
 
 out_unlock:
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/capability.c linux-2.6.31-rsbac-1.4.2/kernel/capability.c
--- trunk/kernel/capability.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/capability.c	2009-09-10 18:17:08.000000000 +0200
@@ -17,6 +17,15 @@
 #include <asm/uaccess.h>
 #include "cred-internals.h"
 
+#include <rsbac/hooks.h>
+
+/* RSBAC: Setting caps from outside, need the lock */
+#if defined(CONFIG_RSBAC_CAP) || defined(CONFIG_RSBAC_JAIL)
+DEFINE_SPINLOCK(task_capability_lock);
+#else
+static DEFINE_SPINLOCK(task_capability_lock);
+#endif
+
 /*
  * Leveraged for setting/resetting capabilities
  */
@@ -133,6 +142,10 @@ static inline int cap_get_target_pid(pid
 				     kernel_cap_t *pIp, kernel_cap_t *pPp)
 {
 	int ret;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (pid && (pid != task_pid_vnr(current))) {
 		struct task_struct *target;
@@ -142,12 +155,34 @@ static inline int cap_get_target_pid(pid
 		target = find_task_by_vpid(pid);
 		if (!target)
 			ret = -ESRCH;
-		else
+		else {
 			ret = security_capget(target, pEp, pIp, pPp);
+#ifdef CONFIG_RSBAC
+			rsbac_target_id.process = task_pid(target);
+#endif
+		}
 
 		read_unlock(&tasklist_lock);
-	} else
+	} else {
 		ret = security_capget(current, pEp, pIp, pPp);
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.process = task_pid(current);
+#endif
+	}
+#ifdef CONFIG_RSBAC
+	if(!ret) {
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if(!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value)) {
+			ret = -EPERM;
+		}
+	}
+#endif
 
 	return ret;
 }
@@ -244,6 +279,12 @@ SYSCALL_DEFINE2(capset, cap_user_header_
 	int ret;
 	pid_t pid;
 
+#ifdef CONFIG_RSBAC
+     union rsbac_target_id_t rsbac_target_id;
+     union rsbac_target_id_t rsbac_new_target_id;
+     union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	ret = cap_validate_magic(header, &tocopy);
 	if (ret != 0)
 		return ret;
@@ -275,6 +316,25 @@ SYSCALL_DEFINE2(capset, cap_user_header_
 	if (!new)
 		return -ENOMEM;
 
+#ifdef CONFIG_RSBAC
+	if (!cap_issubset(effective, new->cap_effective) 
+		     || !cap_issubset(permitted, new->cap_permitted) 
+		     || !cap_issubset(inheritable, new->cap_inheritable)) {
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.scd = ST_capability;
+		rsbac_attribute_value.dummy = 0;
+		if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value)) {
+		     ret = -EPERM;
+		     goto error;
+		}
+	}
+#endif
+
 	ret = security_capset(new, current_cred(),
 			      &effective, &inheritable, &permitted);
 	if (ret < 0)
@@ -282,7 +342,26 @@ SYSCALL_DEFINE2(capset, cap_user_header_
 
 	audit_log_capset(pid, new, current_cred());
 
-	return commit_creds(new);
+	ret = commit_creds(new);
+
+#ifdef CONFIG_RSBAC
+	if (!ret) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value)) {
+			rsbac_printk(KERN_WARNING
+					"sys_setcap(): rsbac_adf_set_attr() returned error");
+		}
+	}
+#endif
+
+	return ret;
 
 error:
 	abort_creds(new);
@@ -310,6 +389,10 @@ int capable(int cap)
 		current->flags |= PF_SUPERPRIV;
 		return 1;
 	}
+#if defined(CONFIG_RSBAC_CAP_LOG_MISSING) || defined(CONFIG_RSBAC_JAIL_LOG_MISSING)
+	else
+		rsbac_log_missing_cap(cap);
+#endif
 	return 0;
 }
 EXPORT_SYMBOL(capable);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/exit.c linux-2.6.31-rsbac-1.4.2/kernel/exit.c
--- trunk/kernel/exit.c	2009-09-10 18:14:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/exit.c	2009-09-10 18:17:09.000000000 +0200
@@ -56,6 +56,8 @@
 #include <asm/mmu_context.h>
 #include "cred-internals.h"
 
+#include <rsbac/hooks.h>
+
 static void exit_mm(struct task_struct * tsk);
 
 static void __unhash_process(struct task_struct *p)
@@ -890,6 +892,11 @@ NORET_TYPE void do_exit(long code)
 	struct task_struct *tsk = current;
 	int group_dead;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	profile_task_exit(tsk);
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
@@ -962,6 +969,23 @@ NORET_TYPE void do_exit(long code)
 	exit_sem(tsk);
 	exit_files(tsk);
 	exit_fs(tsk);
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_exit()]: calling ADF\n");
+	rsbac_target_id.process = task_pid(tsk);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_TERMINATE,
+				rsbac_target_id.process,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"do_exit() [sys_exit()]: ADF request for TERMINATE returned NOT_GRANTED!\n");
+	}
+#endif
+
 	check_stack_usage();
 	exit_thread();
 	cgroup_exit(tsk, 1);
@@ -982,6 +1006,7 @@ NORET_TYPE void do_exit(long code)
 	perf_counter_exit_task(tsk);
 
 	exit_notify(tsk, group_dead);
+
 #ifdef CONFIG_NUMA
 	mpol_put(tsk->mempolicy);
 	tsk->mempolicy = NULL;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/fork.c linux-2.6.31-rsbac-1.4.2/kernel/fork.c
--- trunk/kernel/fork.c	2009-09-10 18:14:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/fork.c	2009-09-10 18:17:09.000000000 +0200
@@ -70,6 +70,8 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
+#include <rsbac/hooks.h>
+
 #include <trace/events/sched.h>
 
 /*
@@ -498,6 +500,26 @@ void mmput(struct mm_struct *mm)
 	}
 }
 EXPORT_SYMBOL_GPL(mmput);
+#ifdef CONFIG_RSBAC
+/* yes, i hate putting new functions here as much as ao does. seems like we
+ * have no choice because mmput() is beeing used from rsbac_adf_request_int()
+ * which in turn cannot be sleeping when called from do_exit(). michal. */
+void mmput_nosleep(struct mm_struct *mm)
+{
+	if (atomic_dec_and_test(&mm->mm_users)) {
+		exit_aio(mm);
+		exit_mmap(mm);
+		if (!list_empty(&mm->mmlist)) {
+			spin_lock(&mmlist_lock);
+			list_del(&mm->mmlist);
+			spin_unlock(&mmlist_lock);
+		}
+		put_swap_token(mm);
+		mmdrop(mm);
+	}
+}
+EXPORT_SYMBOL_GPL(mmput_nosleep);
+#endif
 
 /**
  * get_task_mm - acquire a reference to the task's mm
@@ -1330,7 +1352,11 @@ struct task_struct * __cpuinit fork_idle
  * It copies the process, and if successful kick-starts
  * it and waits for it to finish using the VM if required.
  */
+#ifdef CONFIG_RSBAC
+long do_fork(unsigned long long clone_flags,
+#else
 long do_fork(unsigned long clone_flags,
+#endif
 	      unsigned long stack_start,
 	      struct pt_regs *regs,
 	      unsigned long stack_size,
@@ -1341,6 +1367,32 @@ long do_fork(unsigned long clone_flags,
 	int trace = 0;
 	long nr;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	enum  rsbac_attribute_t rsbac_attribute;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+	
+#ifdef CONFIG_RSBAC
+	rsbac_attribute = A_none;
+	rsbac_attribute_value.dummy = 0;
+	if(current->pid) {
+		rsbac_pr_debug(aef, "[sys_fork(),sys_clone(),sys_vfork]: calling ADF\n");
+		rsbac_target_id.process = task_pid(current);
+		if (!rsbac_adf_request(R_CLONE,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+	}
+#endif
+
 	/*
 	 * Do some preliminary argument and permissions checking before we
 	 * actually start allocating stuff
@@ -1367,7 +1419,11 @@ long do_fork(unsigned long clone_flags,
 
 			count--;
 			printk(KERN_INFO "fork(): process `%s' used deprecated "
+#ifdef CONFIG_RSBAC
+					"clone flags 0x%llx\n",
+#else
 					"clone flags 0x%lx\n",
+#endif
 				get_task_comm(comm, current),
 				clone_flags & CLONE_STOPPED);
 		}
@@ -1411,6 +1467,33 @@ long do_fork(unsigned long clone_flags,
 		 */
 		p->flags &= ~PF_STARTING;
 
+#ifdef CONFIG_RSBAC
+		if (clone_flags & CLONE_KTHREAD) {
+			rsbac_attribute = A_kernel_thread;
+			rsbac_attribute_value.kernel_thread = 1;
+			rsbac_mark_kthread(task_pid(p));
+			rsbac_kthread_notify(task_pid(p));
+		}
+
+		if (current->pid)
+		{
+			rsbac_pr_debug(aef, "[sys_fork(),sys_clone(),sys_vfork()]: calling ADF_set_attr\n");
+			rsbac_new_target_id.process = task_pid(p);
+			if (rsbac_adf_set_attr(R_CLONE,
+						task_pid(current),
+						T_PROCESS,
+						rsbac_target_id,
+						T_PROCESS,
+						rsbac_new_target_id,
+						rsbac_attribute,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"do_fork() [sys_fork(), sys_clone()]: rsbac_adf_set_attr() returned error!\n");
+			}
+		}
+#endif
+
 		if (unlikely(clone_flags & CLONE_STOPPED)) {
 			/*
 			 * We'll start up with an immediate SIGSTOP.
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/groups.c linux-2.6.31-rsbac-1.4.2/kernel/groups.c
--- trunk/kernel/groups.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/groups.c	2009-09-10 18:17:08.000000000 +0200
@@ -8,6 +8,8 @@
 #include <linux/syscalls.h>
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 /* init to 2 - one for init_task, one to ensure it is never freed */
 struct group_info init_groups = { .usage = ATOMIC_INIT(2) };
 
@@ -240,6 +242,12 @@ SYSCALL_DEFINE2(setgroups, int, gidsetsi
 	struct group_info *group_info;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	int i;
+#endif
+
 	if (!capable(CAP_SETGID))
 		return -EPERM;
 	if ((unsigned)gidsetsize > NGROUPS_MAX)
@@ -254,6 +262,26 @@ SYSCALL_DEFINE2(setgroups, int, gidsetsi
 		return retval;
 	}
 
+#ifdef CONFIG_RSBAC
+	if (gidsetsize > 0) {
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(current);
+		for (i=0; i < gidsetsize; i++) {
+			rsbac_attribute_value.group = RSBAC_GEN_GID(RSBAC_UM_VIRTUAL_KEEP, group_info->blocks[i / NGROUPS_PER_BLOCK][i]);
+			if(!rsbac_adf_request(R_CHANGE_GROUP,
+						task_pid(current),
+						T_PROCESS,
+						rsbac_target_id,
+						A_group,
+						rsbac_attribute_value))
+			{
+				put_group_info(group_info);
+				return -EPERM;
+			}
+		}
+	}
+#endif
+
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/kallsyms.c linux-2.6.31-rsbac-1.4.2/kernel/kallsyms.c
--- trunk/kernel/kallsyms.c	2009-09-10 18:14:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/kallsyms.c	2009-09-10 18:17:09.000000000 +0200
@@ -24,6 +24,8 @@
 
 #include <asm/sections.h>
 
+#include <rsbac/hooks.h>
+
 #ifdef CONFIG_KALLSYMS_ALL
 #define all_var 1
 #else
@@ -500,6 +502,26 @@ static int kallsyms_open(struct inode *i
 	struct kallsym_iter *iter;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.scd = ST_ksyms;
+	rsbac_attribute_value.dummy = 0;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	iter = kmalloc(sizeof(*iter), GFP_KERNEL);
 	if (!iter)
 		return -ENOMEM;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/kexec.c linux-2.6.31-rsbac-1.4.2/kernel/kexec.c
--- trunk/kernel/kexec.c	2009-09-10 18:14:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/kexec.c	2009-09-10 18:17:09.000000000 +0200
@@ -38,6 +38,8 @@
 #include <asm/system.h>
 #include <asm/sections.h>
 
+#include <rsbac/hooks.h>
+
 /* Per cpu memory for storing cpu states in case of system crash. */
 note_buf_t* crash_notes;
 
@@ -940,10 +942,30 @@ SYSCALL_DEFINE4(kexec_load, unsigned lon
 	struct kimage **dest_image, *image;
 	int result;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t	rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!capable(CAP_SYS_BOOT))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.scd = ST_kexec;
+	rsbac_attribute_value.dummy = 0;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+	
 	/*
 	 * Verify we have a legal set of flags
 	 * This leaves us room for future extensions.
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/kmod.c linux-2.6.31-rsbac-1.4.2/kernel/kmod.c
--- trunk/kernel/kmod.c	2009-09-10 18:14:14.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/kmod.c	2009-09-10 18:17:09.000000000 +0200
@@ -37,6 +37,10 @@
 #include <linux/suspend.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 extern int max_threads;
 
 static struct workqueue_struct *khelper_wq;
@@ -204,6 +208,11 @@ static int wait_for_helper(void *data)
 	allow_signal(SIGCHLD);
 
 	pid = kernel_thread(____call_usermodehelper, sub_info, SIGCHLD);
+	
+#ifdef CONFIG_RSBAC
+	rsbac_kthread_notify(find_pid_ns(pid, &init_pid_ns));
+#endif
+
 	if (pid < 0) {
 		sub_info->retval = pid;
 	} else {
@@ -251,10 +260,19 @@ static void __call_usermodehelper(struct
 	 * until that is done.  */
 	if (wait == UMH_WAIT_PROC || wait == UMH_NO_WAIT)
 		pid = kernel_thread(wait_for_helper, sub_info,
+#ifdef CONFIG_RSBAC
+				    CLONE_FS | CLONE_FILES | CLONE_KTHREAD | SIGCHLD);
+#else
 				    CLONE_FS | CLONE_FILES | SIGCHLD);
+#endif
 	else
 		pid = kernel_thread(____call_usermodehelper, sub_info,
+#ifdef CONFIG_RSBAC
+				    CLONE_VFORK | CLONE_KTHREAD | SIGCHLD);
+	rsbac_kthread_notify(find_pid_ns(pid, &init_pid_ns));
+#else
 				    CLONE_VFORK | SIGCHLD);
+#endif
 
 	switch (wait) {
 	case UMH_NO_WAIT:
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/kthread.c linux-2.6.31-rsbac-1.4.2/kernel/kthread.c
--- trunk/kernel/kthread.c	2009-09-10 18:14:14.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/kthread.c	2009-09-10 18:17:09.000000000 +0200
@@ -16,6 +16,10 @@
 #include <linux/mutex.h>
 #include <trace/events/sched.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #define KTHREAD_NICE_LEVEL (-5)
 
 static DEFINE_SPINLOCK(kthread_create_lock);
@@ -93,6 +97,10 @@ static void create_kthread(struct kthrea
 		create->result = ERR_PTR(pid);
 		complete(&create->done);
 	}
+#ifdef CONFIG_RSBAC
+	else
+		rsbac_kthread_notify(find_pid_ns(pid, &init_pid_ns));
+#endif
 }
 
 /**
@@ -148,6 +156,10 @@ struct task_struct *kthread_create(int (
 		set_user_nice(create.result, KTHREAD_NICE_LEVEL);
 		set_cpus_allowed_ptr(create.result, cpu_all_mask);
 	}
+#ifdef CONFIG_RSBAC
+	rsbac_kthread_notify(task_pid(create.result));
+#endif
+
 	return create.result;
 }
 EXPORT_SYMBOL(kthread_create);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/module.c linux-2.6.31-rsbac-1.4.2/kernel/module.c
--- trunk/kernel/module.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/module.c	2009-09-10 18:17:08.000000000 +0200
@@ -55,6 +55,8 @@
 #include <linux/percpu.h>
 #include <linux/kmemleak.h>
 
+#include <rsbac/hooks.h>
+
 #if 0
 #define DEBUGP printk
 #else
@@ -793,6 +795,11 @@ SYSCALL_DEFINE2(delete_module, const cha
 	char name[MODULE_NAME_LEN];
 	int ret, forced = 0;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_SYS_MODULE) || modules_disabled)
 		return -EPERM;
 
@@ -800,6 +807,21 @@ SYSCALL_DEFINE2(delete_module, const cha
 		return -EFAULT;
 	name[MODULE_NAME_LEN-1] = '\0';
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.dummy = 0;
+	rsbac_attribute_value.mod_name = name;
+	if (!rsbac_adf_request(R_REMOVE_FROM_KERNEL,
+				task_pid(current),
+				T_NONE,
+				rsbac_target_id,
+				A_mod_name,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	/* Create stop_machine threads since free_module relies on
 	 * a non-failing stop_machine call. */
 	ret = stop_machine_create();
@@ -2418,10 +2440,30 @@ SYSCALL_DEFINE3(init_module, void __user
 	struct module *mod;
 	int ret = 0;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/* Must have permission */
 	if (!capable(CAP_SYS_MODULE) || modules_disabled)
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.dummy = 0;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_ADD_TO_KERNEL,
+				task_pid(current),
+				T_NONE,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	/* Only one module load at a time, please */
 	if (mutex_lock_interruptible(&module_mutex) != 0)
 		return -EINTR;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/printk.c linux-2.6.31-rsbac-1.4.2/kernel/printk.c
--- trunk/kernel/printk.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/printk.c	2009-09-10 18:17:08.000000000 +0200
@@ -36,6 +36,8 @@
 
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * Architectures can override it:
  */
@@ -272,10 +274,55 @@ int do_syslog(int type, char __user *buf
 	char c;
 	int error = 0;
 
+#ifdef CONFIG_RSBAC_SYSLOG
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = security_syslog(type);
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC_SYSLOG
+	rsbac_pr_debug(aef, "[sys_syslog()]: calling ADF\n");
+	rsbac_target_id.scd = ST_syslog;
+	rsbac_attribute_value.dummy = 0;
+	switch(type) {
+		case 2:
+		case 3:
+			if (!rsbac_adf_request(R_GET_STATUS_DATA,
+						task_pid(current),
+						T_SCD,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				error = -EPERM;
+				goto out;
+			}
+			break;
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+		case 8:
+			if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+						task_pid(current),
+						T_SCD,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				error = -EPERM;
+				goto out;
+			}
+			break;
+
+		default:
+			break;
+	}
+#endif
+
 	switch (type) {
 	case 0:		/* Close log */
 		break;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/ptrace.c linux-2.6.31-rsbac-1.4.2/kernel/ptrace.c
--- trunk/kernel/ptrace.c	2009-09-10 18:14:14.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/ptrace.c	2009-09-10 18:17:09.000000000 +0200
@@ -24,6 +24,8 @@
 #include <linux/uaccess.h>
 
 
+#include <rsbac/hooks.h>
+
 /*
  * ptrace a task: make the debugger its new parent and
  * move it to the ptrace list.
@@ -224,10 +226,31 @@ int ptrace_traceme(void)
 {
 	int ret = -EPERM;
 
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	write_lock_irq(&tasklist_lock);
 	/* Are we already being traced? */
 	if (!current->ptrace) {
 		ret = security_ptrace_traceme(current->parent);
+
+#ifdef CONFIG_RSBAC
+                rsbac_pr_debug(aef, "[sys_ptrace] calling ADF\n");
+                rsbac_target_id.process = task_pid(current);
+                rsbac_attribute_value.trace_request = PTRACE_TRACEME;
+                if (!rsbac_adf_request(R_TRACE,
+                                        task_pid(current),
+                                        T_PROCESS,
+                                        rsbac_target_id,
+                                        A_trace_request,
+                                        rsbac_attribute_value))
+                {
+                        ret = -EPERM;
+                }
+#endif
+
 		/*
 		 * Check PF_EXITING to ensure ->real_parent has not passed
 		 * exit_ptrace(). Otherwise we don't report the error but
@@ -601,6 +624,11 @@ SYSCALL_DEFINE4(ptrace, long, request, l
 	struct task_struct *child;
 	long ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/*
 	 * This lock_kernel fixes a subtle race with suid exec
 	 */
@@ -612,6 +640,27 @@ SYSCALL_DEFINE4(ptrace, long, request, l
 		goto out;
 	}
 
+#ifdef CONFIG_RSBAC
+	if (request != PTRACE_DETACH) {
+		rsbac_pr_debug(aef, "[sys_ptrace] calling ADF\n");
+		rcu_read_lock();
+		rsbac_target_id.process = find_pid_ns(pid, &init_pid_ns);
+		rsbac_attribute_value.trace_request = request;
+		if (!rsbac_adf_request(R_TRACE,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_trace_request,
+					rsbac_attribute_value))
+		{
+			ret = -EPERM;
+			rcu_read_unlock();
+			goto out;
+		}
+		rcu_read_unlock();
+	}
+#endif
+
 	child = ptrace_get_task_struct(pid);
 	if (IS_ERR(child)) {
 		ret = PTR_ERR(child);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/sched.c linux-2.6.31-rsbac-1.4.2/kernel/sched.c
--- trunk/kernel/sched.c	2009-09-10 18:14:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/sched.c	2009-09-10 18:17:09.000000000 +0200
@@ -76,6 +76,8 @@
 #include <asm/tlb.h>
 #include <asm/irq_regs.h>
 
+#include <rsbac/hooks.h>
+
 #include "sched_cpupri.h"
 
 #define CREATE_TRACE_POINTS
@@ -2455,7 +2457,6 @@ static int try_to_wake_up(struct task_st
 #ifdef CONFIG_SMP
 	if (unlikely(task_running(rq, p)))
 		goto out_activate;
-
 	cpu = p->sched_class->select_task_rq(p, sync);
 	if (cpu != orig_cpu) {
 		set_task_cpu(p, cpu);
@@ -5994,6 +5995,10 @@ int can_nice(const struct task_struct *p
 SYSCALL_DEFINE1(nice, int, increment)
 {
 	long nice, retval;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	/*
 	 * Setpriority might change our priority at the same moment.
@@ -6014,6 +6019,23 @@ SYSCALL_DEFINE1(nice, int, increment)
 	if (increment < 0 && !can_nice(current, nice))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	if (increment < 0) {
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.scd = ST_priority;
+		rsbac_attribute_value.priority = nice;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+	}
+#endif
+
 	retval = security_task_setnice(current, nice);
 	if (retval)
 		return retval;
@@ -6195,6 +6217,7 @@ recheck:
 			return retval;
 	}
 
+
 	/*
 	 * make sure no PI-waiters arrive (or leave) while we are
 	 * changing the priority of the task:
@@ -6277,6 +6300,12 @@ do_sched_setscheduler(pid_t pid, int pol
 	struct task_struct *p;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!param || pid < 0)
 		return -EINVAL;
 	if (copy_from_user(&lparam, param, sizeof(struct sched_param)))
@@ -6285,8 +6314,31 @@ do_sched_setscheduler(pid_t pid, int pol
 	rcu_read_lock();
 	retval = -ESRCH;
 	p = find_process_by_pid(pid);
-	if (p != NULL)
+	if (p != NULL) {
+	#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_sched_setscheduler, sys_sched_setparam]: calling ADF\n");
+		if (!pid || (pid == current->pid)) {
+			rsbac_target = T_SCD;
+			rsbac_target_id.scd = ST_priority;
+		} else {
+			rsbac_target = T_PROCESS;
+			rsbac_target_id.process = task_pid(p);
+		}
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rcu_read_unlock();
+			return -EPERM;
+		}
+#endif
+
 		retval = sched_setscheduler(p, policy, &lparam);
+	}
 	rcu_read_unlock();
 
 	return retval;
@@ -6327,9 +6379,36 @@ SYSCALL_DEFINE1(sched_getscheduler, pid_
 	struct task_struct *p;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+        enum  rsbac_target_t rsbac_target;
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (pid < 0)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_sched_getscheduler]: calling ADF\n");
+        if (!pid || (pid == current->pid)) {
+                rsbac_target = T_SCD;
+                rsbac_target_id.scd = ST_priority;
+        } else {
+                rsbac_target = T_PROCESS;
+                rsbac_target_id.process = find_pid_ns(pid, &init_pid_ns);
+        }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                task_pid(current),
+                                rsbac_target,
+                                rsbac_target_id,
+                                A_none,
+                                rsbac_attribute_value))
+        {
+                return -EPERM;
+        }
+#endif
+
 	retval = -ESRCH;
 	read_lock(&tasklist_lock);
 	p = find_process_by_pid(pid);
@@ -6353,9 +6432,36 @@ SYSCALL_DEFINE2(sched_getparam, pid_t, p
 	struct task_struct *p;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+        enum  rsbac_target_t rsbac_target;
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!param || pid < 0)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_sched_getparam]: calling ADF\n");
+        if (!pid || (pid == current->pid)) {
+                rsbac_target = T_SCD;
+                rsbac_target_id.scd = ST_priority;
+        } else {
+                rsbac_target = T_PROCESS;
+                rsbac_target_id.process = find_pid_ns(pid, &init_pid_ns);
+        }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                task_pid(current),
+                                rsbac_target,
+                                rsbac_target_id,
+                                A_none,
+                                rsbac_attribute_value))
+        {
+                return -EPERM;
+        }
+#endif
+
 	read_lock(&tasklist_lock);
 	p = find_process_by_pid(pid);
 	retval = -ESRCH;
@@ -6383,6 +6489,12 @@ out_unlock:
 
 long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
 {
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	cpumask_var_t cpus_allowed, new_mask;
 	struct task_struct *p;
 	int retval;
@@ -6421,6 +6533,28 @@ long sched_setaffinity(pid_t pid, const 
 	if (retval)
 		goto out_unlock;
 
+#ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_sched_setaffinity]: calling ADF\n");
+        if (p == current) {
+                rsbac_target = T_SCD;
+                rsbac_target_id.scd = ST_priority;
+        } else {
+                rsbac_target = T_PROCESS;
+                rsbac_target_id.process = task_pid(p);
+        }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                task_pid(current),
+                                rsbac_target,
+                                rsbac_target_id,
+                                A_none,
+                                rsbac_attribute_value))
+        {
+                retval = -EPERM;
+                goto out_unlock;
+	}
+#endif
+
 	cpuset_cpus_allowed(p, cpus_allowed);
 	cpumask_and(new_mask, in_mask, cpus_allowed);
  again:
@@ -6485,6 +6619,32 @@ long sched_getaffinity(pid_t pid, struct
 {
 	struct task_struct *p;
 	int retval;
+#ifdef CONFIG_RSBAC
+	enum rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sched_getaffinity]: calling ADF\n");
+        if (!pid || (pid == current->pid)) {
+                rsbac_target = T_SCD;
+                rsbac_target_id.scd = ST_priority;
+        } else {
+                rsbac_target = T_PROCESS;
+                rsbac_target_id.process = find_pid_ns(pid, &init_pid_ns);
+        }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                task_pid(current),
+                                rsbac_target,
+                                rsbac_target_id,
+                                A_none,
+                                rsbac_attribute_value))
+        {
+                return -EPERM;
+        }
+#endif
 
 	get_online_cpus();
 	read_lock(&tasklist_lock);
@@ -6746,9 +6906,36 @@ SYSCALL_DEFINE2(sched_rr_get_interval, p
 	int retval;
 	struct timespec t;
 
+#ifdef CONFIG_RSBAC
+	enum rsbac_target_t rsbac_target;
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (pid < 0)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_sched_rr_get_interval]: calling ADF\n");
+        if (!pid || (pid == current->pid)) {
+                rsbac_target = T_SCD;
+                rsbac_target_id.scd = ST_priority;
+        } else {
+                rsbac_target = T_PROCESS;
+                rsbac_target_id.process = find_pid_ns(pid, &init_pid_ns);
+        }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                task_pid(current),
+                                rsbac_target,
+                                rsbac_target_id,
+                                A_none,
+                                rsbac_attribute_value))
+        {
+                return -EPERM;
+        }
+#endif
+
 	retval = -ESRCH;
 	read_lock(&tasklist_lock);
 	p = find_process_by_pid(pid);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/signal.c linux-2.6.31-rsbac-1.4.2/kernel/signal.c
--- trunk/kernel/signal.c	2009-09-10 18:14:14.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/signal.c	2009-09-10 18:17:09.000000000 +0200
@@ -35,6 +35,8 @@
 #include <asm/siginfo.h>
 #include "audit.h"	/* audit_signal_info() */
 
+#include <rsbac/hooks.h>
+
 /*
  * SLAB caches for signal bits.
  */
@@ -595,6 +597,11 @@ static int check_kill_permission(int sig
 	struct pid *sid;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!valid_signal(sig))
 		return -EINVAL;
 
@@ -625,6 +632,23 @@ static int check_kill_permission(int sig
 		}
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[group_send_sig_info(), sys_tgkill(),sys_tkill()]: calling ADF\n");
+	rsbac_target_id.process = task_pid(t);
+	rsbac_attribute_value.dummy = 0;
+	if ((!info || ((unsigned long)info != 1
+			&& (unsigned long)info != 2 && SI_FROMUSER(info)))
+			&& ((sig != SIGCONT) || (task_session(current) != task_session(t)))
+				&& !rsbac_adf_request(R_SEND_SIGNAL,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)
+	  )
+		return -EPERM;
+#endif
+
 	return security_task_kill(t, info, sig, 0);
 }
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/sys.c linux-2.6.31-rsbac-1.4.2/kernel/sys.c
--- trunk/kernel/sys.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/sys.c	2009-09-10 18:17:09.000000000 +0200
@@ -46,6 +46,8 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#include <rsbac/hooks.h>
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
 #endif
@@ -138,6 +140,7 @@ static int set_one_prio(struct task_stru
 		error = no_nice;
 		goto out;
 	}
+
 	if (error == -ESRCH)
 		error = 0;
 	set_user_nice(p, niceval);
@@ -153,6 +156,12 @@ SYSCALL_DEFINE3(setpriority, int, which,
 	int error = -EINVAL;
 	struct pid *pgrp;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (which > PRIO_USER || which < PRIO_PROCESS)
 		goto out;
 
@@ -163,6 +172,38 @@ SYSCALL_DEFINE3(setpriority, int, which,
 	if (niceval > 19)
 		niceval = 19;
 
+#ifdef CONFIG_RSBAC
+	if ((niceval < (current->static_prio - MAX_RT_PRIO - 20)) || ((which == PRIO_PROCESS) 
+				&& (who != 0)
+				&& (who != current->pid))
+					|| ((which == PRIO_PGRP)
+					&& (who != 0)
+					&& (who != current->pid)))
+	{
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rcu_read_lock();
+		if (niceval < (current->static_prio - MAX_RT_PRIO - 20)) {
+			rsbac_target = T_SCD;
+			rsbac_target_id.scd = ST_priority;
+		} else {
+			rsbac_target = T_PROCESS;
+			rsbac_target_id.process = find_pid_ns(who, &init_pid_ns);
+		}
+		rsbac_attribute_value.priority = niceval;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_priority,
+					rsbac_attribute_value))
+		{
+			rcu_read_unlock();
+			return -EPERM;
+		}
+		rcu_read_unlock();
+	}
+#endif
+
 	read_lock(&tasklist_lock);
 	switch (which) {
 		case PRIO_PROCESS:
@@ -363,6 +404,11 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
 	char buffer[256];
 	int ret = 0;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!capable(CAP_SYS_BOOT))
 		return -EPERM;
@@ -381,6 +427,21 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
 	if ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !pm_power_off)
 		cmd = LINUX_REBOOT_CMD_HALT;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.dummy = 0;
+	rsbac_attribute_value.reboot_cmd = cmd;
+	if (!rsbac_adf_request(R_SHUTDOWN,
+				task_pid(current),
+				T_NONE,
+				rsbac_target_id,
+				A_reboot_cmd,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	lock_kernel();
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
@@ -492,18 +553,62 @@ SYSCALL_DEFINE2(setregid, gid_t, rgid, g
 
 	retval = -EPERM;
 	if (rgid != (gid_t) -1) {
-		if (old->gid == rgid ||
+#ifdef CONFIG_RSBAC
+		union rsbac_target_id_t rsbac_target_id;
+		union rsbac_attribute_value_t rsbac_attribute_value;
+
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(current);
+		rsbac_attribute_value.long_dummy = 0;
+		rsbac_attribute_value.group = RSBAC_GEN_GID(RSBAC_UM_VIRTUAL_KEEP, rgid);
+#endif
+
+		if ((old->gid == rgid ||
 		    old->egid == rgid ||
 		    capable(CAP_SETGID))
+#ifdef CONFIG_RSBAC
+				&& rsbac_adf_request(R_CHANGE_GROUP,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_group,
+					rsbac_attribute_value)
+#endif
+                   )
 			new->gid = rgid;
 		else
 			goto error;
 	}
 	if (egid != (gid_t) -1) {
-		if (old->gid == egid ||
+#ifdef CONFIG_RSBAC_DAC_GROUP
+		union rsbac_target_id_t rsbac_target_id;
+		union rsbac_attribute_value_t rsbac_attribute_value;
+
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(current);
+		rsbac_attribute_value.long_dummy = 0;
+		rsbac_attribute_value.group = RSBAC_GEN_GID(RSBAC_UM_VIRTUAL_KEEP, egid);
+#endif
+
+		if ((old->gid == egid ||
 		    old->egid == egid ||
 		    old->sgid == egid ||
 		    capable(CAP_SETGID))
+#ifdef CONFIG_RSBAC_DAC_GROUP
+				&& rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_group,
+					rsbac_attribute_value)
+				&& rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_group,
+					rsbac_attribute_value)
+#endif
+                   )
 			new->egid = egid;
 		else
 			goto error;
@@ -532,6 +637,11 @@ SYSCALL_DEFINE1(setgid, gid_t, gid)
 	struct cred *new;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -541,11 +651,58 @@ SYSCALL_DEFINE1(setgid, gid_t, gid)
 	if (retval)
 		goto error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(current);
+	rsbac_attribute_value.group = RSBAC_GEN_GID(RSBAC_UM_VIRTUAL_KEEP, gid);
+#endif
+
 	retval = -EPERM;
-	if (capable(CAP_SETGID))
+	if ((capable(CAP_SETGID))
+#ifdef CONFIG_RSBAC
+			&& rsbac_adf_request(R_CHANGE_GROUP,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_group,
+				rsbac_attribute_value)
+#ifdef CONFIG_RSBAC_DAC_GROUP
+			&& rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_group,
+				rsbac_attribute_value)
+			&& rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_group,
+				rsbac_attribute_value)
+#endif
+#endif
+           )
+	{
 		new->gid = new->egid = new->sgid = new->fsgid = gid;
-	else if (gid == old->gid || gid == old->sgid)
+	} else if ((gid == old->gid || gid == old->sgid)
+#ifdef CONFIG_RSBAC_DAC_GROUP
+			&& rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_group,
+				rsbac_attribute_value)
+			&& rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_group,
+				rsbac_attribute_value)
+#endif
+                )
+	{
 		new->egid = new->fsgid = gid;
+	}
 	else
 		goto error;
 
@@ -605,6 +762,12 @@ SYSCALL_DEFINE2(setreuid, uid_t, ruid, u
 	struct cred *new;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -614,6 +777,44 @@ SYSCALL_DEFINE2(setreuid, uid_t, ruid, u
 	if (retval)
 		goto error;
 
+#ifdef CONFIG_RSBAC
+	if (ruid != (uid_t) -1) {
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(current);
+		rsbac_attribute_value.long_dummy = 0;
+		rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, ruid);
+		if (!rsbac_adf_request(R_CHANGE_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_owner,
+					rsbac_attribute_value))
+			return -EPERM;
+	}
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	if (euid != (uid_t) -1) {
+		rsbac_pr_debug(aef, "calling ADF for euid\n");
+		rsbac_target_id.process = task_pid(current);
+		rsbac_attribute_value.long_dummy = 0;
+		rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, euid);
+		if (!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_owner,
+					rsbac_attribute_value))
+			return -EPERM;
+		if (!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_owner,
+					rsbac_attribute_value))
+			return -EPERM;
+	}
+#endif
+#endif
+
 	retval = -EPERM;
 	if (ruid != (uid_t) -1) {
 		new->uid = ruid;
@@ -646,6 +847,56 @@ SYSCALL_DEFINE2(setreuid, uid_t, ruid, u
 	if (retval < 0)
 		goto error;
 
+#ifdef CONFIG_RSBAC
+	if(ruid != (uid_t) -1) {
+		rsbac_set_audit_uid(old->uid);
+		rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, current_uid());
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_owner,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_setreuid(): rsbac_adf_set_attr() returned error");
+		}
+	}
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	if(euid != (uid_t) -1) {
+		rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, current_euid());
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_owner,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_setreuid(): rsbac_adf_set_attr() for euid returned error");
+		}
+		if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_owner,
+					rsbac_attribute_value))
+		{
+			printk(KERN_WARNING
+					"sys_setreuid(): rsbac_adf_set_attr() for fsuid returned error");
+		}
+	}
+#endif
+#endif
+
 	return commit_creds(new);
 
 error:
@@ -670,6 +921,17 @@ SYSCALL_DEFINE1(setuid, uid_t, uid)
 	struct cred *new;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+	if(!uid && rsbac_uid_faked())
+		return 0;
+#endif
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -679,6 +941,40 @@ SYSCALL_DEFINE1(setuid, uid_t, uid)
 	if (retval)
 		goto error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(current);
+	rsbac_attribute_value.long_dummy = 0;
+	rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, uid);
+	if(!rsbac_adf_request(R_CHANGE_OWNER,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_owner,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	rsbac_pr_debug(aef, "calling ADF for euid\n");
+	if (!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_owner,
+				rsbac_attribute_value))
+		return -EPERM;
+	rsbac_pr_debug(aef, "calling ADF for fsuid\n");
+	if (!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_owner,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+#endif
+
 	retval = -EPERM;
 	if (capable(CAP_SETUID)) {
 		new->suid = new->uid = uid;
@@ -694,6 +990,52 @@ SYSCALL_DEFINE1(setuid, uid_t, uid)
 	new->fsuid = new->euid = uid;
 
 	retval = security_task_fix_setuid(new, old, LSM_SETID_ID);
+
+#ifdef CONFIG_RSBAC
+	rsbac_set_audit_uid(old->uid);
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_owner,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"sys_setuid(): rsbac_adf_set_attr() returned error");
+	}
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_owner,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"sys_setuid(): rsbac_adf_set_attr() for euid returned error");
+	}
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_owner,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"sys_setuid(): rsbac_adf_set_attr() for fsuid returned error");
+	}
+#endif
+#endif
+
 	if (retval < 0)
 		goto error;
 
@@ -715,6 +1057,12 @@ SYSCALL_DEFINE3(setresuid, uid_t, ruid, 
 	struct cred *new;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -737,6 +1085,46 @@ SYSCALL_DEFINE3(setresuid, uid_t, ruid, 
 			goto error;
 	}
 
+#ifdef CONFIG_RSBAC
+	if(ruid != (uid_t) -1) {
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(current);
+		rsbac_attribute_value.long_dummy = 0;
+		rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, ruid);
+		if(!rsbac_adf_request(R_CHANGE_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_owner,
+					rsbac_attribute_value))
+			return -EPERM;
+	}
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	if(euid != (uid_t) -1) {
+		rsbac_pr_debug(aef, "calling ADF for euid\n");
+		rsbac_target_id.process = task_pid(current);
+		rsbac_attribute_value.long_dummy = 0;
+		rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, euid);
+		if(!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_owner,
+					rsbac_attribute_value))
+			return -EPERM;
+		rsbac_pr_debug(aef, "calling ADF for fsuid\n");
+		if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_owner,
+					rsbac_attribute_value))
+			return -EPERM;
+	}
+#endif
+#endif
+
+
 	if (ruid != (uid_t) -1) {
 		new->uid = ruid;
 		if (ruid != old->uid) {
@@ -755,6 +1143,57 @@ SYSCALL_DEFINE3(setresuid, uid_t, ruid, 
 	if (retval < 0)
 		goto error;
 
+
+#ifdef CONFIG_RSBAC
+	if(ruid != (uid_t) -1) {
+		rsbac_set_audit_uid(old->uid);
+		rsbac_new_target_id.dummy = 0;
+		rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, current_uid());
+		if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_owner,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_setresuid(): rsbac_adf_set_attr() returned error");
+		}
+	}
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	if(euid != (uid_t) -1) {
+		rsbac_new_target_id.dummy = 0;
+		rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, current_euid());
+		if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_owner,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_setreuid(): rsbac_adf_set_attr() for euid returned error\n");
+		}
+		if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_owner,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_setreuid(): rsbac_adf_set_attr() for fsuid returned error\n");
+		}
+	}
+#endif
+#endif
+
 	return commit_creds(new);
 
 error:
@@ -783,6 +1222,11 @@ SYSCALL_DEFINE3(setresgid, gid_t, rgid, 
 	struct cred *new;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
@@ -805,10 +1249,44 @@ SYSCALL_DEFINE3(setresgid, gid_t, rgid, 
 			goto error;
 	}
 
-	if (rgid != (gid_t) -1)
+	if (rgid != (gid_t) -1) {
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(current);
+		rsbac_attribute_value.group = RSBAC_GEN_GID(RSBAC_UM_VIRTUAL_KEEP, rgid);
+		if(!rsbac_adf_request(R_CHANGE_GROUP,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_group,
+					rsbac_attribute_value))
+			return -EPERM;
+#endif
 		new->gid = rgid;
-	if (egid != (gid_t) -1)
+	}
+
+	if (egid != (gid_t) -1) {
+#ifdef CONFIG_RSBAC_DAC_GROUP
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(current);
+		rsbac_attribute_value.group = RSBAC_GEN_GID(RSBAC_UM_VIRTUAL_KEEP, egid);
+		if (!rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_group,
+					rsbac_attribute_value))
+			return -EPERM;
+		if (!rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_group,
+					rsbac_attribute_value))
+			return -EPERM;
+#endif
 		new->egid = egid;
+	}
 	if (sgid != (gid_t) -1)
 		new->sgid = sgid;
 	new->fsgid = new->egid;
@@ -845,12 +1323,31 @@ SYSCALL_DEFINE1(setfsuid, uid_t, uid)
 	struct cred *new;
 	uid_t old_fsuid;
 
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	new = prepare_creds();
 	if (!new)
 		return current_fsuid();
 	old = current_cred();
 	old_fsuid = old->fsuid;
 
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(current);
+	rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, uid);
+	if (!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_owner,
+				rsbac_attribute_value))
+		return old_fsuid;
+#endif
+
 	if (security_task_setuid(uid, (uid_t)-1, (uid_t)-1, LSM_SETID_FS) < 0)
 		goto error;
 
@@ -870,6 +1367,24 @@ error:
 
 change_okay:
 	commit_creds(new);
+#ifdef CONFIG_RSBAC_DAC_OWNER
+	rsbac_target_id.process = task_pid(current);
+	rsbac_new_target_id.dummy = 0;
+	rsbac_attribute_value.owner = RSBAC_GEN_UID(RSBAC_UM_VIRTUAL_KEEP, uid);
+	if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_owner,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"sys_setfsuid(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return old_fsuid;
 }
 
@@ -882,6 +1397,11 @@ SYSCALL_DEFINE1(setfsgid, gid_t, gid)
 	struct cred *new;
 	gid_t old_fsgid;
 
+#ifdef CONFIG_RSBAC_DAC_GROUP
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	new = prepare_creds();
 	if (!new)
 		return current_fsgid();
@@ -891,6 +1411,19 @@ SYSCALL_DEFINE1(setfsgid, gid_t, gid)
 	if (security_task_setgid(gid, (gid_t)-1, (gid_t)-1, LSM_SETID_FS))
 		goto error;
 
+#ifdef CONFIG_RSBAC_DAC_GROUP
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task_pid(current);
+	rsbac_attribute_value.group = RSBAC_GEN_GID(RSBAC_UM_VIRTUAL_KEEP, gid);
+	if (!rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_group,
+				rsbac_attribute_value))
+		return old_fsgid;
+#endif
+
 	if (gid == old->gid  || gid == old->egid  ||
 	    gid == old->sgid || gid == old->fsgid ||
 	    capable(CAP_SETGID)) {
@@ -957,6 +1490,11 @@ SYSCALL_DEFINE2(setpgid, pid_t, pid, pid
 	struct pid *pgrp;
 	int err;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!pid)
 		pid = task_pid_vnr(group_leader);
 	if (!pgid)
@@ -964,6 +1502,24 @@ SYSCALL_DEFINE2(setpgid, pid_t, pid, pid
 	if (pgid < 0)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rcu_read_lock();
+	rsbac_target_id.process = find_pid_ns(pid, &init_pid_ns);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+#endif
+
 	/* From this point forward we keep holding onto the tasklist lock
 	 * so that our parent does not change from under us. -DaveM
 	 */
@@ -1029,6 +1585,11 @@ SYSCALL_DEFINE1(getpgid, pid_t, pid)
 	if (!pid)
 		grp = task_pgrp(current);
 	else {
+#ifdef CONFIG_RSBAC
+		union rsbac_target_id_t rsbac_target_id;
+		union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 		retval = -ESRCH;
 		p = find_task_by_vpid(pid);
 		if (!p)
@@ -1037,6 +1598,22 @@ SYSCALL_DEFINE1(getpgid, pid_t, pid)
 		if (!grp)
 			goto out;
 
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(p);
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			retval = -EPERM;
+			goto out;
+		}
+#endif
+
 		retval = security_task_getpgid(p);
 		if (retval)
 			goto out;
@@ -1066,6 +1643,11 @@ SYSCALL_DEFINE1(getsid, pid_t, pid)
 	if (!pid)
 		sid = task_session(current);
 	else {
+#ifdef CONFIG_RSBAC
+		union rsbac_target_id_t rsbac_target_id;
+		union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 		retval = -ESRCH;
 		p = find_task_by_vpid(pid);
 		if (!p)
@@ -1074,6 +1656,22 @@ SYSCALL_DEFINE1(getsid, pid_t, pid)
 		if (!sid)
 			goto out;
 
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = task_pid(p);
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_PROCESS,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			retval = -EPERM;
+			goto out;
+		}
+#endif
+
 		retval = security_task_getsid(p);
 		if (retval)
 			goto out;
@@ -1131,10 +1729,31 @@ SYSCALL_DEFINE2(sethostname, char __user
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+	
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_host_id;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	down_write(&uts_sem);
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
@@ -1180,11 +1799,31 @@ SYSCALL_DEFINE2(setdomainname, char __us
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+	
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_net_id;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	down_write(&uts_sem);
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
@@ -1241,6 +1880,12 @@ SYSCALL_DEFINE2(setrlimit, unsigned int,
 	struct rlimit new_rlim, *old_rlim;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
 	if (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
@@ -1258,6 +1903,22 @@ SYSCALL_DEFINE2(setrlimit, unsigned int,
 	if (retval)
 		return retval;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_rlimit;
+	rsbac_attribute_value.rlimit.resource = resource;
+	rsbac_attribute_value.rlimit.limit = new_rlim;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_rlimit,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (resource == RLIMIT_CPU && new_rlim.rlim_cur == 0) {
 		/*
 		 * The caller is asking for an immediate RLIMIT_CPU
@@ -1272,6 +1933,22 @@ SYSCALL_DEFINE2(setrlimit, unsigned int,
 	*old_rlim = new_rlim;
 	task_unlock(current->group_leader);
 
+#ifdef CONFIG_RSBAC
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_rlimit,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"sys_setrlimit(): rsbac_adf_set_attr() returned error");
+	}
+#endif
+
 	if (resource != RLIMIT_CPU)
 		goto out;
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/sysctl.c linux-2.6.31-rsbac-1.4.2/kernel/sysctl.c
--- trunk/kernel/sysctl.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/sysctl.c	2009-09-10 18:17:08.000000000 +0200
@@ -56,6 +56,8 @@
 #include <asm/uaccess.h>
 #include <asm/processor.h>
 
+#include <rsbac/hooks.h>
+
 #ifdef CONFIG_X86
 #include <asm/nmi.h>
 #include <asm/stacktrace.h>
@@ -1837,6 +1839,12 @@ int sysctl_perm(struct ctl_table_root *r
 	int error;
 	int mode;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+
 	error = security_sysctl(table, op & (MAY_READ | MAY_WRITE | MAY_EXEC));
 	if (error)
 		return error;
@@ -1846,6 +1854,32 @@ int sysctl_perm(struct ctl_table_root *r
 	else
 		mode = table->mode;
 
+#ifdef CONFIG_RSBAC
+	if (op & 002) { /* write access */
+		switch (table->ctl_name) {
+			case KERN_NODENAME:
+				rsbac_target_id.scd = ST_host_id;
+				break;
+			case KERN_DOMAINNAME:
+				rsbac_target_id.scd = ST_net_id;
+				break;
+			default:
+				rsbac_target_id.scd = ST_sysctl;
+		}
+		rsbac_attribute_value.mode = mode;
+		rsbac_pr_debug(aef, "[sysctl() etc.]: calling ADF\n");
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_mode,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+	}
+#endif
+
 	return test_perm(mode, op);
 }
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/time/ntp.c linux-2.6.31-rsbac-1.4.2/kernel/time/ntp.c
--- trunk/kernel/time/ntp.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/time/ntp.c	2009-09-10 18:17:08.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/timex.h>
 #include <linux/time.h>
 #include <linux/mm.h>
+#include <rsbac/hooks.h>
 
 /*
  * NTP timekeeping variables:
@@ -451,6 +452,11 @@ int do_adjtimex(struct timex *txc)
 	struct timespec ts;
 	int result;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/* Validate the data before disabling interrupts */
 	if (txc->modes & ADJ_ADJTIME) {
 		/* singleshot must not be used with any other mode bits */
@@ -464,6 +470,19 @@ int do_adjtimex(struct timex *txc)
 		 if (txc->modes && !capable(CAP_SYS_TIME))
 			return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_time_strucs;
+	rsbac_attribute_value.dummy = 0;
+	if (txc->modes && !rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 		/*
 		 * if the quartz is off by more than 10% then
 		 * something is VERY wrong!
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/time.c linux-2.6.31-rsbac-1.4.2/kernel/time.c
--- trunk/kernel/time.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/time.c	2009-09-10 18:17:08.000000000 +0200
@@ -42,6 +42,8 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#include <rsbac/hooks.h>
+
 #include "timeconst.h"
 
 /*
@@ -84,9 +86,29 @@ SYSCALL_DEFINE1(stime, time_t __user *, 
 	struct timespec tv;
 	int err;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (get_user(tv.tv_sec, tptr))
 		return -EFAULT;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_clock;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	tv.tv_nsec = 0;
 
 	err = security_settime(&tv, NULL);
@@ -157,6 +179,11 @@ int do_sys_settimeofday(struct timespec 
 	static int firsttime = 1;
 	int error = 0;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (tv && !timespec_valid(tv))
 		return -EINVAL;
 
@@ -164,6 +191,21 @@ int do_sys_settimeofday(struct timespec 
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_settimeofday()]: calling ADF\n");
+	rsbac_target_id.scd = ST_clock;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (tz) {
 		/* SMP safe, global irq locking makes it work. */
 		sys_tz = *tz;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/timer.c linux-2.6.31-rsbac-1.4.2/kernel/timer.c
--- trunk/kernel/timer.c	2009-09-10 18:14:14.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/timer.c	2009-09-10 18:17:09.000000000 +0200
@@ -46,6 +46,8 @@
 #include <asm/timex.h>
 #include <asm/io.h>
 
+#include <rsbac/hooks.h>
+
 u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;
 
 EXPORT_SYMBOL(jiffies_64);
@@ -1254,14 +1256,22 @@ SYSCALL_DEFINE0(getppid)
 
 SYSCALL_DEFINE0(getuid)
 {
+#ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+	return rsbac_fake_uid();
+#else
 	/* Only we change this so SMP safe */
 	return current_uid();
+#endif
 }
 
 SYSCALL_DEFINE0(geteuid)
 {
+#ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+	return rsbac_fake_euid();
+#else
 	/* Only we change this so SMP safe */
 	return current_euid();
+#endif
 }
 
 SYSCALL_DEFINE0(getgid)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/kernel/uid16.c linux-2.6.31-rsbac-1.4.2/kernel/uid16.c
--- trunk/kernel/uid16.c	2009-09-10 18:14:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/kernel/uid16.c	2009-09-10 18:17:08.000000000 +0200
@@ -17,6 +17,8 @@
 
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 SYSCALL_DEFINE3(chown16, const char __user *, filename, old_uid_t, user, old_gid_t, group)
 {
 	long ret = sys_chown(filename, low2highuid(user), low2highgid(group));
@@ -190,6 +192,12 @@ SYSCALL_DEFINE2(setgroups16, int, gidset
 	struct group_info *group_info;
 	int retval;
 
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        int i;
+#endif
+
 	if (!capable(CAP_SETGID))
 		return -EPERM;
 	if ((unsigned)gidsetsize > NGROUPS_MAX)
@@ -204,6 +212,26 @@ SYSCALL_DEFINE2(setgroups16, int, gidset
 		return retval;
 	}
 
+#ifdef CONFIG_RSBAC
+        if (gidsetsize > 0) {
+                rsbac_pr_debug(aef, "calling ADF\n");
+                rsbac_target_id.process = task_pid(current);
+                for (i=0; i < gidsetsize; i++) {
+                        rsbac_attribute_value.group = RSBAC_GEN_GID(RSBAC_UM_VIRTUAL_KEEP, group_info->blocks[i / NGROUPS_PER_BLOCK][i]);
+                        if(!rsbac_adf_request(R_CHANGE_GROUP,
+                                                task_pid(current),
+                                                T_PROCESS,
+                                                rsbac_target_id,
+                                                A_group,
+                                                rsbac_attribute_value))
+                        {
+                                put_group_info(group_info);
+                                return -EPERM;
+                        }
+		}
+	}
+#endif
+
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
@@ -212,12 +240,20 @@ SYSCALL_DEFINE2(setgroups16, int, gidset
 
 SYSCALL_DEFINE0(getuid16)
 {
+#ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+	return high2lowuid(rsbac_fake_uid());
+#else
 	return high2lowuid(current_uid());
+#endif
 }
 
 SYSCALL_DEFINE0(geteuid16)
 {
+#ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+	return high2lowuid(rsbac_fake_euid());
+#else
 	return high2lowuid(current_euid());
+#endif
 }
 
 SYSCALL_DEFINE0(getgid16)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/MAINTAINERS linux-2.6.31-rsbac-1.4.2/MAINTAINERS
--- trunk/MAINTAINERS	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/MAINTAINERS	2009-09-10 18:17:51.000000000 +0200
@@ -4293,6 +4293,13 @@ F:	include/linux/rose.h
 F:	include/net/rose.h
 F:	net/rose/
 
+RSBAC
+P:	Amon Ott
+M:	ao@rsbac.org
+L:	rsbac@rsbac.org
+W:	http://www.rsbac.org
+S:	Maintained
+
 RTL8180 WIRELESS DRIVER
 M:	"John W. Linville" <linville@tuxdriver.com>
 L:	linux-wireless@vger.kernel.org
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/Makefile linux-2.6.31-rsbac-1.4.2/Makefile
--- trunk/Makefile	2009-09-10 18:16:02.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/Makefile	2009-09-10 18:18:44.000000000 +0200
@@ -612,6 +612,13 @@ export KBUILD_IMAGE ?= vmlinux
 export	INSTALL_PATH ?= /boot
 
 #
+
+# Add RSBAC version
+ifeq ($(CONFIG_RSBAC),y)
+EXTRAVERSION:=$(EXTRAVERSION)-rsbac
+core-y		+= rsbac/
+endif
+
 # INSTALL_MOD_PATH specifies a prefix to MODLIB for module directory
 # relocations required by build roots.  This is not defined in the
 # makefile but the argument can be passed to make if needed.
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/mm/mlock.c linux-2.6.31-rsbac-1.4.2/mm/mlock.c
--- trunk/mm/mlock.c	2009-09-10 18:15:12.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/mm/mlock.c	2009-09-10 18:17:51.000000000 +0200
@@ -12,7 +12,9 @@
 #include <linux/swapops.h>
 #include <linux/pagemap.h>
 #include <linux/mempolicy.h>
+#include <linux/security.h>
 #include <linux/syscalls.h>
+#include <rsbac/hooks.h>
 #include <linux/sched.h>
 #include <linux/module.h>
 #include <linux/rmap.h>
@@ -474,9 +476,29 @@ SYSCALL_DEFINE2(mlock, unsigned long, st
 	unsigned long lock_limit;
 	int error = -ENOMEM;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!can_do_mlock())
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.scd = ST_mlock;
+	rsbac_attribute_value.dummy = 0;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	lru_add_drain_all();	/* flush pagevec */
 
 	down_write(&current->mm->mmap_sem);
@@ -538,13 +560,34 @@ SYSCALL_DEFINE1(mlockall, int, flags)
 	unsigned long lock_limit;
 	int ret = -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!flags || (flags & ~(MCL_CURRENT | MCL_FUTURE)))
-		goto out;
+	goto out;
 
 	ret = -EPERM;
 	if (!can_do_mlock())
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.scd = ST_mlock;
+	rsbac_attribute_value.dummy = 0;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		goto out;
+	}
+#endif
+
 	lru_add_drain_all();	/* flush pagevec */
 
 	down_write(&current->mm->mmap_sem);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/mm/mmap.c linux-2.6.31-rsbac-1.4.2/mm/mmap.c
--- trunk/mm/mmap.c	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/mm/mmap.c	2009-09-10 18:17:51.000000000 +0200
@@ -33,6 +33,7 @@
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
 #include <asm/tlb.h>
+#include <rsbac/hooks.h>
 #include <asm/mmu_context.h>
 
 #include "internal.h"
@@ -918,6 +919,12 @@ unsigned long do_mmap_pgoff(struct file 
 	int error;
 	unsigned long reqprot = prot;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/*
 	 * Does the application expect PROT_READ to imply PROT_EXEC?
 	 *
@@ -1051,6 +1058,33 @@ unsigned long do_mmap_pgoff(struct file 
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	if (prot & PROT_EXEC) {
+		rsbac_pr_debug(aef, "[do_mmap() [sys_mmap()]]: calling ADF\n");
+		if (file) {
+			rsbac_target = T_FILE;
+			rsbac_target_id.file.device = file->f_dentry->d_inode->i_sb->s_dev;
+			rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+			rsbac_target_id.file.dentry_p = file->f_dentry;
+		} else {
+			rsbac_target = T_NONE;
+			rsbac_target_id.dummy = 0;
+		}
+		rsbac_attribute_value.prot_bits = prot;
+		if (!rsbac_adf_request(R_MAP_EXEC,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_prot_bits,
+					rsbac_attribute_value))
+		{
+			rsbac_pr_debug(aef, "[do_mmap() [sys_mmap()]]: request not granted, my PID: %i\n",
+					current->pid);
+			return -EPERM;
+		}
+	}
+#endif
+
 	return mmap_region(file, addr, len, flags, vm_flags, pgoff);
 }
 EXPORT_SYMBOL(do_mmap_pgoff);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/mm/mprotect.c linux-2.6.31-rsbac-1.4.2/mm/mprotect.c
--- trunk/mm/mprotect.c	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/mm/mprotect.c	2009-09-10 18:17:51.000000000 +0200
@@ -28,6 +28,7 @@
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
+#include <rsbac/hooks.h>
 
 #ifndef pgprot_modify
 static inline pgprot_t pgprot_modify(pgprot_t oldprot, pgprot_t newprot)
@@ -226,6 +227,14 @@ SYSCALL_DEFINE3(mprotect, unsigned long,
 	struct vm_area_struct *vma, *prev;
 	int error = -EINVAL;
 	const int grows = prot & (PROT_GROWSDOWN|PROT_GROWSUP);
+
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	int need_notify = FALSE;
+#endif
+
 	prot &= ~(PROT_GROWSDOWN|PROT_GROWSUP);
 	if (grows == (PROT_GROWSDOWN|PROT_GROWSUP)) /* can't be both */
 		return -EINVAL;
@@ -294,6 +303,34 @@ SYSCALL_DEFINE3(mprotect, unsigned long,
 		if (error)
 			goto out;
 
+#ifdef CONFIG_RSBAC
+		if ((prot & PROT_EXEC) && !(vma->vm_flags & PROT_EXEC)) {
+			rsbac_pr_debug(aef, "calling ADF\n");
+			if (vma->vm_file) {
+		                rsbac_target = T_FILE;
+				rsbac_target_id.file.device = vma->vm_file->f_dentry->d_inode->i_sb->s_dev;
+				rsbac_target_id.file.inode = vma->vm_file->f_dentry->d_inode->i_ino;
+				rsbac_target_id.file.dentry_p = vma->vm_file->f_dentry;
+			} else {
+				rsbac_target = T_NONE;
+				rsbac_target_id.dummy = 0;
+			}
+			rsbac_attribute_value.prot_bits = prot;
+			if (!rsbac_adf_request(R_MAP_EXEC,
+						  task_pid(current),
+						  rsbac_target,
+						  rsbac_target_id,
+						  A_prot_bits,
+						  rsbac_attribute_value)) 
+			{
+				rsbac_pr_debug(aef, "request NOT_GRANTED\n");
+				error = -EPERM;
+				goto out;
+			} else
+			  need_notify = TRUE;
+		}
+#endif
+
 		tmp = vma->vm_end;
 		if (tmp > end)
 			tmp = end;
@@ -316,5 +353,28 @@ SYSCALL_DEFINE3(mprotect, unsigned long,
 	}
 out:
 	up_write(&current->mm->mmap_sem);
+
+        /* RSBAC: notify ADF of mapped segment */
+#ifdef CONFIG_RSBAC
+	if (need_notify && !error) {
+		union rsbac_target_id_t rsbac_new_target_id;
+
+		rsbac_pr_debug(aef, "calling ADF_set_attr\n");
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_MAP_EXEC,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_mprotect: rsbac_adf_set_attr() returned error\n");
+		}
+	}
+#endif
+
 	return error;
 }
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/mm/shmem.c linux-2.6.31-rsbac-1.4.2/mm/shmem.c
--- trunk/mm/shmem.c	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/mm/shmem.c	2009-09-10 18:17:51.000000000 +0200
@@ -65,6 +65,10 @@ static struct vfsmount *shm_mnt;
 #include <asm/div64.h>
 #include <asm/pgtable.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * The maximum size of a shmem/tmpfs file is limited by the maximum size of
  * its triple-indirect swap vector - see illustration at shmem_swp_entry().
@@ -2544,6 +2548,9 @@ static int __init init_tmpfs(void)
 		printk(KERN_ERR "Could not kern_mount tmpfs\n");
 		goto out1;
 	}
+#ifdef CONFIG_RSBAC
+	rsbac_mount(shm_mnt);
+#endif
 	return 0;
 
 out1:
@@ -2583,6 +2590,10 @@ static int __init init_tmpfs(void)
 	shm_mnt = kern_mount(&tmpfs_fs_type);
 	BUG_ON(IS_ERR(shm_mnt));
 
+#ifdef CONFIG_RSBAC
+	rsbac_mount(selinuxfs_mount);
+#endif
+
 	return 0;
 }
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/mm/swapfile.c linux-2.6.31-rsbac-1.4.2/mm/swapfile.c
--- trunk/mm/swapfile.c	2009-09-10 18:15:13.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/mm/swapfile.c	2009-09-10 18:17:51.000000000 +0200
@@ -33,6 +33,7 @@
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 #include <linux/swapops.h>
+#include <rsbac/hooks.h>
 #include <linux/page_cgroup.h>
 
 static DEFINE_SPINLOCK(swap_lock);
@@ -1517,9 +1518,30 @@ SYSCALL_DEFINE1(swapoff, const char __us
 	int i, type, prev;
 	int err;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_swap;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	pathname = getname(specialfile);
 	err = PTR_ERR(pathname);
 	if (IS_ERR(pathname))
@@ -1531,6 +1553,36 @@ SYSCALL_DEFINE1(swapoff, const char __us
 	if (IS_ERR(victim))
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF for DEV / FILE\n");
+	if (S_ISBLK(victim->f_dentry->d_inode->i_mode)) {
+		rsbac_target = T_DEV;
+		rsbac_target_id.dev.type = D_block;
+		rsbac_target_id.dev.major = RSBAC_MAJOR(victim->f_dentry->d_inode->i_rdev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(victim->f_dentry->d_inode->i_rdev);
+	} else
+		if (S_ISREG(victim->f_dentry->d_inode->i_mode)) {
+			rsbac_target = T_FILE;
+			rsbac_target_id.file.device = victim->f_dentry->d_sb->s_dev;
+			rsbac_target_id.file.inode  = victim->f_dentry->d_inode->i_ino;
+			rsbac_target_id.file.dentry_p = victim->f_dentry;
+		} else {
+			rsbac_target = T_NONE;
+			rsbac_target_id.dummy = 0;
+		}
+	rsbac_attribute_value.dummy = 0;
+	if ((rsbac_target != T_NONE) && !rsbac_adf_request(R_REMOVE_FROM_KERNEL,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto out_dput;
+	}
+#endif
+
 	mapping = victim->f_mapping;
 	prev = -1;
 	spin_lock(&swap_lock);
@@ -1783,8 +1835,28 @@ SYSCALL_DEFINE2(swapon, const char __use
 	struct inode *inode = NULL;
 	int did_down = 0;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_swap;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	spin_lock(&swap_lock);
 	p = swap_info;
 	for (type = 0 ; type < nr_swapfiles ; type++,p++)
@@ -1829,6 +1901,44 @@ SYSCALL_DEFINE2(swapon, const char __use
 			goto bad_swap;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF for DEV / FILE\n");
+        if(S_ISBLK(inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+          }
+        else
+        if(S_ISREG(inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.file.device = swap_file->f_dentry->d_sb->s_dev;
+            rsbac_target_id.file.inode  = inode->i_ino;
+            rsbac_target_id.file.dentry_p = swap_file->f_dentry;
+          }
+        else
+          {
+            rsbac_target = T_NONE;
+            rsbac_target_id.dummy = 0;
+          }
+        rsbac_attribute_value.dummy = 0;
+        if(   (rsbac_target != T_NONE)
+           && !rsbac_adf_request(R_ADD_TO_KERNEL,
+                                 task_pid(current),
+                                 rsbac_target,
+                                 rsbac_target_id,
+                                 A_none,
+                                 rsbac_attribute_value)
+	  )
+          {
+            error = -EPERM;
+            goto bad_swap;
+          }
+        #endif
+
 	error = -EINVAL;
 	if (S_ISBLK(inode->i_mode)) {
 		bdev = I_BDEV(inode);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/bridge/br_if.c linux-2.6.31-rsbac-1.4.2/net/bridge/br_if.c
--- trunk/net/bridge/br_if.c	2009-09-10 18:14:43.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/bridge/br_if.c	2009-09-10 18:17:26.000000000 +0200
@@ -21,6 +21,10 @@
 #include <linux/if_ether.h>
 #include <net/sock.h>
 
+#include <linux/security.h>
+
+#include <rsbac/hooks.h>
+
 #include "br_private.h"
 
 /*
@@ -370,6 +374,11 @@ int br_add_if(struct net_bridge *br, str
 	struct net_bridge_port *p;
 	int err = 0;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (dev->flags & IFF_LOOPBACK || dev->type != ARPHRD_ETHER)
 		return -EINVAL;
 
@@ -379,6 +388,34 @@ int br_add_if(struct net_bridge *br, str
 	if (dev->br_port != NULL)
 		return -EBUSY;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+		char * p = rsbac_target_id.netdev;
+		while (*p) {
+			if (*p == ':') {
+				*p=' ';
+				break;
+			}
+			p++;
+		}
+	}
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+			task_pid(current),
+			T_NETDEV,
+			rsbac_target_id,
+			A_none,
+			rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	p = new_nbp(br, dev);
 	if (IS_ERR(p))
 		return PTR_ERR(p);
@@ -437,10 +474,45 @@ put_back:
 int br_del_if(struct net_bridge *br, struct net_device *dev)
 {
 	struct net_bridge_port *p = dev->br_port;
+	
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (!p || p->br != br)
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+		char * p = rsbac_target_id.netdev;
+		while (*p)
+		{
+			if (*p == ':')
+			{
+				*p=' ';
+				break;
+			}
+			p++;
+		}
+	}
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	del_nbp(p);
 
 	spin_lock_bh(&br->lock);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/core/dev.c linux-2.6.31-rsbac-1.4.2/net/core/dev.c
--- trunk/net/core/dev.c	2009-09-10 18:14:40.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/core/dev.c	2009-09-10 18:17:23.000000000 +0200
@@ -128,6 +128,8 @@
 #include <linux/random.h>
 #include <trace/events/napi.h>
 
+#include <rsbac/hooks.h>
+
 #include "net-sysfs.h"
 
 /* Instead of increasing this, you should create a hash table. */
@@ -4395,6 +4397,11 @@ int dev_ioctl(struct net *net, unsigned 
 	int ret;
 	char *colon;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/* One special case: SIOCGIFCONF takes ifconf argument
 	   and requires shared lock, because it sleeps writing
 	   to user space.
@@ -4414,10 +4421,20 @@ int dev_ioctl(struct net *net, unsigned 
 
 	ifr.ifr_name[IFNAMSIZ-1] = 0;
 
+#ifdef CONFIG_RSBAC_NET_DEV_VIRT
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#endif
+
 	colon = strchr(ifr.ifr_name, ':');
 	if (colon)
 		*colon = 0;
 
+#if defined(CONFIG_RSBAC_NET_DEV) && !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#endif
+
 	/*
 	 *	See which interface the caller is talking about.
 	 */
@@ -4437,6 +4454,20 @@ int dev_ioctl(struct net *net, unsigned 
 		case SIOCGIFMAP:
 		case SIOCGIFINDEX:
 		case SIOCGIFTXQLEN:
+#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_GET_STATUS_DATA,
+						task_pid(current),
+						T_NETDEV,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				return -EPERM;
+			}
+#endif
+
 			dev_load(net, ifr.ifr_name);
 			read_lock(&dev_base_lock);
 			ret = dev_ifsioc_locked(net, &ifr, cmd);
@@ -4475,6 +4506,21 @@ int dev_ioctl(struct net *net, unsigned 
 		case SIOCSIFNAME:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+
+#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+						task_pid(current),
+						T_NETDEV,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				return -EPERM;
+			}
+#endif
+
 			dev_load(net, ifr.ifr_name);
 			rtnl_lock();
 			ret = dev_ifsioc(net, &ifr, cmd);
@@ -4514,6 +4560,20 @@ int dev_ioctl(struct net *net, unsigned 
 		case SIOCSHWTSTAMP:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+
+#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+			{
+				return -EPERM;
+			}
+#endif
 			/* fall through */
 		case SIOCBONDSLAVEINFOQUERY:
 		case SIOCBONDINFOQUERY:
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/core/fib_rules.c linux-2.6.31-rsbac-1.4.2/net/core/fib_rules.c
--- trunk/net/core/fib_rules.c	2009-09-10 18:14:39.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/core/fib_rules.c	2009-09-10 18:17:23.000000000 +0200
@@ -14,6 +14,7 @@
 #include <net/net_namespace.h>
 #include <net/sock.h>
 #include <net/fib_rules.h>
+#include <rsbac/hooks.h>
 
 int fib_default_rule_add(struct fib_rules_ops *ops,
 			 u32 pref, u32 table, u32 flags)
@@ -220,6 +221,10 @@ static int fib_nl_newrule(struct sk_buff
 	struct fib_rule *rule, *r, *last = NULL;
 	struct nlattr *tb[FRA_MAX+1];
 	int err = -EINVAL, unresolved = 0;
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh)))
 		goto errout;
@@ -238,6 +243,25 @@ static int fib_nl_newrule(struct sk_buff
 	if (err < 0)
 		goto errout;
 
+#ifdef CONFIG_RSBAC_NET
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "fib_nl_newrule(): calling ADF\n");
+#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto errout;
+	}
+#endif
+
 	rule = kzalloc(ops->rule_size, GFP_KERNEL);
 	if (rule == NULL) {
 		err = -ENOMEM;
@@ -359,6 +383,10 @@ static int fib_nl_delrule(struct sk_buff
 	struct fib_rule *rule, *tmp;
 	struct nlattr *tb[FRA_MAX+1];
 	int err = -EINVAL;
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh)))
 		goto errout;
@@ -377,6 +405,25 @@ static int fib_nl_delrule(struct sk_buff
 	if (err < 0)
 		goto errout;
 
+#ifdef CONFIG_RSBAC_NET
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "fib_nl_delrule(): calling ADF\n");
+#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto errout;
+	}
+#endif
+
 	list_for_each_entry(rule, &ops->rules_list, list) {
 		if (frh->action && (frh->action != rule->action))
 			continue;
@@ -465,6 +512,28 @@ static int fib_nl_fill_rule(struct sk_bu
 {
 	struct nlmsghdr *nlh;
 	struct fib_rule_hdr *frh;
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_NET
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "fib_nl_fill_rule(): calling ADF\n");
+#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	#endif
 
 	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*frh), flags);
 	if (nlh == NULL)
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/ipv4/arp.c linux-2.6.31-rsbac-1.4.2/net/ipv4/arp.c
--- trunk/net/ipv4/arp.c	2009-09-10 18:14:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/ipv4/arp.c	2009-09-10 18:17:25.000000000 +0200
@@ -97,6 +97,7 @@
 #include <linux/net.h>
 #include <linux/rcupdate.h>
 #include <linux/jhash.h>
+#include <linux/security.h>
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
@@ -121,6 +122,8 @@ struct neigh_table *clip_tbl_hook;
 
 #include <linux/netfilter_arp.h>
 
+#include <rsbac/hooks.h>
+
 /*
  *	Interface to generic neighbour cache.
  */
@@ -1133,15 +1136,28 @@ int arp_ioctl(struct net *net, unsigned 
 	struct arpreq r;
 	struct net_device *dev = NULL;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	enum  rsbac_adf_request_t rsbac_request = R_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	switch (cmd) {
 		case SIOCDARP:
 		case SIOCSARP:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_request = R_MODIFY_SYSTEM_DATA;
+#endif
 		case SIOCGARP:
 			err = copy_from_user(&r, arg, sizeof(struct arpreq));
 			if (err)
 				return -EFAULT;
+#ifdef CONFIG_RSBAC_NET_DEV
+			if (rsbac_request == R_NONE)
+				rsbac_request = R_GET_STATUS_DATA;
+#endif
 			break;
 		default:
 			return -EINVAL;
@@ -1168,6 +1184,23 @@ int arp_ioctl(struct net *net, unsigned 
 		err = -EINVAL;
 		if ((r.arp_flags & ATF_COM) && r.arp_ha.sa_family != dev->type)
 			goto out;
+
+#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_pr_debug(aef, "calling ADF\n");
+		strncpy(rsbac_target_id.netdev, r.arp_dev, RSBAC_IFNAMSIZ);
+		rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(rsbac_request,
+					task_pid(current),
+					T_NETDEV,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out;
+		}
+#endif
 	} else if (cmd == SIOCGARP) {
 		err = -ENODEV;
 		goto out;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/ipv4/devinet.c linux-2.6.31-rsbac-1.4.2/net/ipv4/devinet.c
--- trunk/net/ipv4/devinet.c	2009-09-10 18:14:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/ipv4/devinet.c	2009-09-10 18:17:25.000000000 +0200
@@ -50,6 +50,7 @@
 #include <linux/notifier.h>
 #include <linux/inetdevice.h>
 #include <linux/igmp.h>
+#include <linux/security.h>
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
@@ -62,6 +63,8 @@
 #include <net/rtnetlink.h>
 #include <net/net_namespace.h>
 
+#include <rsbac/hooks.h>
+
 static struct ipv4_devconf ipv4_devconf = {
 	.data = {
 		[NET_IPV4_CONF_ACCEPT_REDIRECTS - 1] = 1,
@@ -436,6 +439,11 @@ static int inet_rtm_deladdr(struct sk_bu
 	struct in_ifaddr *ifa, **ifap;
 	int err = -EINVAL;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	ASSERT_RTNL();
 
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);
@@ -449,6 +457,39 @@ static int inet_rtm_deladdr(struct sk_bu
 		goto errout;
 	}
 
+
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, in_dev->dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+		char * p = rsbac_target_id.netdev;
+
+		while (*p)
+		{
+			if (*p == ':')
+			{
+				*p=' ';
+				break;
+			}
+			p++;
+		}
+	}
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_BIND,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		__in_dev_put(in_dev);
+		err = -EPERM;
+		goto errout;
+	}
+#endif
+
 	__in_dev_put(in_dev);
 
 	for (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;
@@ -483,6 +524,11 @@ static struct in_ifaddr *rtm_to_ifaddr(s
 	struct in_device *in_dev;
 	int err;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);
 	if (err < 0)
 		goto errout;
@@ -502,6 +548,37 @@ static struct in_ifaddr *rtm_to_ifaddr(s
 	if (in_dev == NULL)
 		goto errout;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, in_dev->dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+		char * p = rsbac_target_id.netdev;
+		while (*p)
+		{
+			if (*p == ':')
+			{
+				*p=' ';
+				break;
+			}
+			p++;
+		}
+	}
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_BIND,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto errout;
+	}
+#endif
+
 	ifa = inet_alloc_ifa();
 	if (ifa == NULL)
 		/*
@@ -591,6 +668,12 @@ int devinet_ioctl(struct net *net, unsig
 	int ret = -EFAULT;
 	int tryaddrmatch = 0;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	enum  rsbac_adf_request_t rsbac_request = R_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/*
 	 *	Fetch the caller's info block into kernel space
 	 */
@@ -599,6 +682,11 @@ int devinet_ioctl(struct net *net, unsig
 		goto out;
 	ifr.ifr_name[IFNAMSIZ - 1] = 0;
 
+#ifdef CONFIG_RSBAC_NET_DEV_VIRT
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#endif
+
 	/* save original address for comparison */
 	memcpy(&sin_orig, sin, sizeof(*sin));
 
@@ -606,6 +694,11 @@ int devinet_ioctl(struct net *net, unsig
 	if (colon)
 		*colon = 0;
 
+#if defined(CONFIG_RSBAC_NET_DEV) && !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#endif
+
 	dev_load(net, ifr.ifr_name);
 
 	switch (cmd) {
@@ -620,12 +713,19 @@ int devinet_ioctl(struct net *net, unsig
 		tryaddrmatch = (sin_orig.sin_family == AF_INET);
 		memset(sin, 0, sizeof(*sin));
 		sin->sin_family = AF_INET;
+
+#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_GET_STATUS_DATA;
+#endif
 		break;
 
 	case SIOCSIFFLAGS:
 		ret = -EACCES;
 		if (!capable(CAP_NET_ADMIN))
 			goto out;
+#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_MODIFY_SYSTEM_DATA;
+#endif
 		break;
 	case SIOCSIFADDR:	/* Set interface address (and family) */
 	case SIOCSIFBRDADDR:	/* Set the broadcast address */
@@ -637,6 +737,9 @@ int devinet_ioctl(struct net *net, unsig
 		ret = -EINVAL;
 		if (sin->sin_family != AF_INET)
 			goto out;
+#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_BIND;
+#endif
 		break;
 	default:
 		ret = -EINVAL;
@@ -649,6 +752,21 @@ int devinet_ioctl(struct net *net, unsig
 	if ((dev = __dev_get_by_name(net, ifr.ifr_name)) == NULL)
 		goto done;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		goto done;
+	}
+#endif
+
 	if (colon)
 		*colon = ':';
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/ipv4/fib_frontend.c linux-2.6.31-rsbac-1.4.2/net/ipv4/fib_frontend.c
--- trunk/net/ipv4/fib_frontend.c	2009-09-10 18:14:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/ipv4/fib_frontend.c	2009-09-10 18:17:25.000000000 +0200
@@ -44,6 +44,8 @@
 #include <net/ip_fib.h>
 #include <net/rtnetlink.h>
 
+#include <rsbac/hooks.h>
+
 #ifndef CONFIG_IP_MULTIPLE_TABLES
 
 static int __net_init fib4_rules_init(struct net *net)
@@ -456,6 +458,11 @@ int ip_rt_ioctl(struct net *net, unsigne
 	struct rtentry rt;
 	int err;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	switch (cmd) {
 	case SIOCADDRT:		/* Add a route */
 	case SIOCDELRT:		/* Delete a route */
@@ -465,6 +472,21 @@ int ip_rt_ioctl(struct net *net, unsigne
 		if (copy_from_user(&rt, arg, sizeof(rt)))
 			return -EFAULT;
 
+#ifdef CONFIG_RSBAC_NET
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.scd = ST_network;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+#endif
+
 		rtnl_lock();
 		err = rtentry_to_fib_config(net, cmd, &rt, &cfg);
 		if (err == 0) {
@@ -584,10 +606,30 @@ static int inet_rtm_delroute(struct sk_b
 	struct fib_table *tb;
 	int err;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	err = rtm_to_fib_config(net, skb, nlh, &cfg);
 	if (err < 0)
 		goto errout;
 
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	tb = fib_get_table(net, cfg.fc_table);
 	if (tb == NULL) {
 		err = -ESRCH;
@@ -606,10 +648,30 @@ static int inet_rtm_newroute(struct sk_b
 	struct fib_table *tb;
 	int err;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	err = rtm_to_fib_config(net, skb, nlh, &cfg);
 	if (err < 0)
 		goto errout;
 
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	tb = fib_new_table(net, cfg.fc_table);
 	if (tb == NULL) {
 		err = -ENOBUFS;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/ipv4/inet_diag.c linux-2.6.31-rsbac-1.4.2/net/ipv4/inet_diag.c
--- trunk/net/ipv4/inet_diag.c	2009-09-10 18:14:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/ipv4/inet_diag.c	2009-09-10 18:17:25.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/random.h>
 #include <linux/cache.h>
 #include <linux/init.h>
+#include <linux/security.h>
 #include <linux/time.h>
 
 #include <net/icmp.h>
@@ -33,6 +34,8 @@
 
 #include <linux/inet_diag.h>
 
+#include <rsbac/hooks.h>
+
 static const struct inet_diag_handler **inet_diag_table;
 
 struct inet_diag_entry {
@@ -846,6 +849,11 @@ unlock:
 
 static int inet_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	int hdrlen = sizeof(struct inet_diag_req);
 
 	if (nlh->nlmsg_type >= INET_DIAG_GETSOCK_MAX ||
@@ -856,6 +864,19 @@ static int inet_diag_rcv_msg(struct sk_b
 		if (nlmsg_attrlen(nlh, hdrlen)) {
 			struct nlattr *attr;
 
+#ifdef CONFIG_RSBAC_NET
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_target_id.scd = ST_network;
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+				return -EPERM;
+#endif
+
 			attr = nlmsg_find_attr(nlh, hdrlen,
 					       INET_DIAG_REQ_BYTECODE);
 			if (attr == NULL ||
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/ipv4/ipmr.c linux-2.6.31-rsbac-1.4.2/net/ipv4/ipmr.c
--- trunk/net/ipv4/ipmr.c	2009-09-10 18:14:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/ipv4/ipmr.c	2009-09-10 18:17:25.000000000 +0200
@@ -46,6 +46,7 @@
 #include <linux/seq_file.h>
 #include <linux/mroute.h>
 #include <linux/init.h>
+#include <linux/security.h>
 #include <linux/if_ether.h>
 #include <net/net_namespace.h>
 #include <net/ip.h>
@@ -63,6 +64,8 @@
 #include <net/checksum.h>
 #include <net/netlink.h>
 
+#include <rsbac/hooks.h>
+
 #if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
 #define CONFIG_IP_PIMSM	1
 #endif
@@ -943,8 +946,27 @@ int ip_mroute_setsockopt(struct sock *sk
 	struct net *net = sock_net(sk);
 
 	if (optname != MRT_INIT) {
+#ifdef CONFIG_RSBAC_NET_DEV
+		union rsbac_target_id_t rsbac_target_id;
+		union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 		if (sk != net->ipv4.mroute_sk && !capable(CAP_NET_ADMIN))
 			return -EACCES;
+
+#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.scd = ST_network;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+#endif
 	}
 
 	switch (optname) {
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/ipv4/netfilter/ip_tables.c linux-2.6.31-rsbac-1.4.2/net/ipv4/netfilter/ip_tables.c
--- trunk/net/ipv4/netfilter/ip_tables.c	2009-09-10 18:14:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/ipv4/netfilter/ip_tables.c	2009-09-10 18:17:25.000000000 +0200
@@ -23,11 +23,14 @@
 #include <linux/proc_fs.h>
 #include <linux/err.h>
 #include <linux/cpumask.h>
+#include <linux/security.h>
 
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <net/netfilter/nf_log.h>
 
+#include <rsbac/hooks.h>
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("IPv4 packet filter");
@@ -1159,6 +1162,24 @@ get_entries(struct net *net, struct ipt_
 	struct ipt_get_entries get;
 	struct xt_table *t;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (*len < sizeof(get)) {
 		duprintf("get_entries: %u < %zu\n", *len, sizeof(get));
 		return -EINVAL;
@@ -1847,9 +1868,29 @@ compat_do_ipt_set_ctl(struct sock *sk,	i
 {
 	int ret;
 
+#ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+#endif
+
 	switch (cmd) {
 	case IPT_SO_SET_REPLACE:
 		ret = compat_do_replace(sock_net(sk), user, len);
@@ -1912,6 +1953,26 @@ compat_get_entries(struct net *net, stru
 	struct compat_ipt_get_entries get;
 	struct xt_table *t;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (*len < sizeof(get)) {
 		duprintf("compat_get_entries: %u < %zu\n", *len, sizeof(get));
 		return -EINVAL;
@@ -1980,9 +2041,29 @@ do_ipt_set_ctl(struct sock *sk, int cmd,
 {
 	int ret;
 
+#ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+#endif
+
 	switch (cmd) {
 	case IPT_SO_SET_REPLACE:
 		ret = do_replace(sock_net(sk), user, len);
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/ipv4/route.c linux-2.6.31-rsbac-1.4.2/net/ipv4/route.c
--- trunk/net/ipv4/route.c	2009-09-10 18:14:42.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/ipv4/route.c	2009-09-10 18:17:25.000000000 +0200
@@ -90,6 +90,7 @@
 #include <linux/jhash.h>
 #include <linux/rcupdate.h>
 #include <linux/times.h>
+#include <linux/security.h>
 #include <net/dst.h>
 #include <net/net_namespace.h>
 #include <net/protocol.h>
@@ -108,6 +109,8 @@
 #include <linux/sysctl.h>
 #endif
 
+#include <rsbac/hooks.h>
+
 #define RT_FL_TOS(oldflp) \
     ((u32)(oldflp->fl4_tos & (IPTOS_RT_MASK | RTO_ONLINK)))
 
@@ -2906,6 +2909,27 @@ static int inet_rtm_getroute(struct sk_b
 	int err;
 	struct sk_buff *skb;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto errout;
+	}
+#endif
+
 	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy);
 	if (err < 0)
 		goto errout;
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/sched/cls_api.c linux-2.6.31-rsbac-1.4.2/net/sched/cls_api.c
--- trunk/net/sched/cls_api.c	2009-09-10 18:14:39.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/sched/cls_api.c	2009-09-10 18:17:22.000000000 +0200
@@ -30,6 +30,8 @@
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
 
+#include <rsbac/hooks.h>
+
 /* The list of all installed classifier types */
 
 static struct tcf_proto_ops *tcf_proto_base __read_mostly;
@@ -137,6 +139,29 @@ static int tc_ctl_tfilter(struct sk_buff
 	int err;
 	int tp_created = 0;
 
+#ifdef CONFIG_RSBAC_NET
+	enum  rsbac_adf_request_t rsbac_request;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if (n->nlmsg_type == RTM_GETTFILTER)
+		rsbac_request = R_GET_STATUS_DATA;
+	else
+		rsbac_request = R_MODIFY_SYSTEM_DATA;
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (net != &init_net)
 		return -EINVAL;
 
@@ -416,6 +441,26 @@ static int tc_dump_tfilter(struct sk_buf
 	const struct Qdisc_class_ops *cops;
 	struct tcf_dump_args arg;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (net != &init_net)
 		return 0;
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/sched/sch_api.c linux-2.6.31-rsbac-1.4.2/net/sched/sch_api.c
--- trunk/net/sched/sch_api.c	2009-09-10 18:14:39.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/sched/sch_api.c	2009-09-10 18:17:22.000000000 +0200
@@ -34,6 +34,8 @@
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
 
+#include <rsbac/hooks.h>
+
 static int qdisc_notify(struct sk_buff *oskb, struct nlmsghdr *n, u32 clid,
 			struct Qdisc *old, struct Qdisc *new);
 static int tclass_notify(struct sk_buff *oskb, struct nlmsghdr *n,
@@ -954,12 +956,46 @@ static int tc_get_qdisc(struct sk_buff *
 	struct Qdisc *p = NULL;
 	int err;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	enum  rsbac_adf_request_t rsbac_request;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+#endif
+#endif
+
 	if (net != &init_net)
 		return -EINVAL;
 
 	if ((dev = __dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if (n->nlmsg_type == RTM_DELQDISC)
+		rsbac_request = R_MODIFY_SYSTEM_DATA;
+	else
+		rsbac_request = R_GET_STATUS_DATA;
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if (rsbac_colon)
+		*rsbac_colon = 0;
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);
 	if (err < 0)
 		return err;
@@ -1018,6 +1054,14 @@ static int tc_modify_qdisc(struct sk_buf
 	struct Qdisc *q, *p;
 	int err;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+#endif
+#endif
+
 	if (net != &init_net)
 		return -EINVAL;
 
@@ -1030,6 +1074,27 @@ replay:
 	if ((dev = __dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "tc_modify_qdisc(): calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if (rsbac_colon)
+		*rsbac_colon = 0;
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);
 	if (err < 0)
 		return err;
@@ -1275,6 +1340,14 @@ static int tc_dump_qdisc(struct sk_buff 
 	int s_idx, s_q_idx;
 	struct net_device *dev;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+#endif
+#endif
+
 	if (net != &init_net)
 		return 0;
 
@@ -1289,6 +1362,28 @@ static int tc_dump_qdisc(struct sk_buff 
 			goto cont;
 		if (idx > s_idx)
 			s_q_idx = 0;
+
+#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_pr_debug(aef, "tc_dump_qdisc(): calling ADF\n");
+		strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+		rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+		rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+		if(rsbac_colon)
+			*rsbac_colon = 0;
+#endif
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					T_NETDEV,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			continue;
+		}
+#endif
+
 		q_idx = 0;
 
 		dev_queue = netdev_get_tx_queue(dev, 0);
@@ -1336,12 +1431,41 @@ static int tc_ctl_tclass(struct sk_buff 
 	u32 qid = TC_H_MAJ(clid);
 	int err;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+#endif
+#endif
+
 	if (net != &init_net)
 		return -EINVAL;
 
 	if ((dev = __dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "tc_ctl_tclass(): calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if (rsbac_colon)
+		*rsbac_colon = 0;
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);
 	if (err < 0)
 		return err;
@@ -1575,6 +1699,14 @@ static int tc_dump_tclass(struct sk_buff
 	struct net_device *dev;
 	int t, s_t;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+#endif
+#endif
+
 	if (net != &init_net)
 		return 0;
 
@@ -1583,6 +1715,27 @@ static int tc_dump_tclass(struct sk_buff
 	if ((dev = dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return 0;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if (rsbac_colon)
+		*rsbac_colon = 0;
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		dev_put(dev);
+		return -EPERM;
+	}
+#endif
+
 	s_t = cb->args[0];
 	t = 0;
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/socket.c linux-2.6.31-rsbac-1.4.2/net/socket.c
--- trunk/net/socket.c	2009-09-10 18:14:44.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/socket.c	2009-09-10 18:17:26.000000000 +0200
@@ -87,6 +87,12 @@
 #include <linux/wireless.h>
 #include <linux/nsproxy.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/af_unix.h>
+#include <net/scm.h>
+#include <rsbac/hooks.h>
+#endif
+
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
@@ -561,6 +567,118 @@ static inline int __sock_sendmsg(struct 
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
 	int err;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	enum  rsbac_attribute_t rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#if defined(CONFIG_RSBAC)
+	rsbac_pr_debug(aef, "[sys_send(), sys_sendto(), sys_sendmsg()]: calling ADF\n");
+	if (sock->ops->family == AF_UNIX) {
+		if (sock->sk) {
+			if (unix_sk(unix_sk(sock->sk)->peer)) {
+				if (   unix_sk(unix_sk(sock->sk)->peer)->dentry
+				    && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+				   ) {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = unix_sk(unix_sk(sock->sk)->peer)->dentry;
+				} else {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					if (   unix_sk(sock->sk)->peer->sk_socket
+					    && unix_sk(sock->sk)->peer->sk_socket->file
+					    && unix_sk(sock->sk)->peer->sk_socket->file->f_dentry
+					    && unix_sk(sock->sk)->peer->sk_socket->file->f_dentry->d_inode
+					   )
+						rsbac_target_id.ipc.id.id_nr = unix_sk(sock->sk)->peer->sk_socket->file->f_dentry->d_inode->i_ino;
+					else
+						if (   sock->file
+						    && sock->file->f_dentry
+						    && sock->file->f_dentry->d_inode
+						   )
+							rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+						else
+							rsbac_target_id.ipc.id.id_nr = 0;
+				}
+			} else {
+				if (   unix_sk(sock->sk)->dentry
+				    && unix_sk(sock->sk)->dentry->d_inode
+				   ) {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = unix_sk(sock->sk)->dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = unix_sk(sock->sk)->dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = unix_sk(sock->sk)->dentry;
+				} else {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					if (   sock->file
+					    && sock->file->f_dentry
+					    && sock->file->f_dentry->d_inode
+					   )
+						rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+					else
+						rsbac_target_id.ipc.id.id_nr = 0;
+				}
+			}
+			if (   sock->sk->sk_peercred.pid
+			    && (rsbac_attribute_value.process = find_pid_ns(sock->sk->sk_peercred.pid, &init_pid_ns))
+			    && (pid_nr(rsbac_attribute_value.process) > 0)
+			   ) {
+				rsbac_attribute = A_process;
+			} else
+				if (   unix_sk(sock->sk)->peer
+				    && unix_sk(sock->sk)->peer->sk_peercred.pid
+				    && (rsbac_attribute_value.process = find_pid_ns(unix_sk(sock->sk)->peer->sk_peercred.pid, &init_pid_ns))
+				    && (pid_nr(rsbac_attribute_value.process) > 0)
+				   ) {
+					rsbac_attribute = A_process;
+				} else {
+					rsbac_attribute = A_sock_type;
+					rsbac_attribute_value.sock_type = sock->type;
+				}
+		}
+	}
+#if defined(CONFIG_RSBAC_NET_OBJ)
+	else {
+#if !defined(CONFIG_RSBAC_NET_OBJ_RW)
+		if(sock->type != SOCK_STREAM)
+#endif
+		{
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = msg->msg_name;
+			rsbac_target_id.netobj.remote_len = msg->msg_namelen;
+			if (   sock->sk->sk_peercred.pid
+			    && (rsbac_attribute_value.process = find_pid_ns(sock->sk->sk_peercred.pid, &init_pid_ns))
+			    && (pid_nr(rsbac_attribute_value.process) > 0)
+			   ) {
+				rsbac_attribute = A_process;
+			} else {
+                        	rsbac_attribute = A_sock_type;
+				rsbac_attribute_value.sock_type = sock->type;
+			}
+		}
+	}
+#endif
+	if ((rsbac_target != T_NONE)
+			&& !rsbac_adf_request(R_SEND,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				rsbac_attribute,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	si->sock = sock;
 	si->scm = NULL;
 	si->msg = msg;
@@ -570,7 +688,27 @@ static inline int __sock_sendmsg(struct 
 	if (err)
 		return err;
 
-	return sock->ops->sendmsg(iocb, sock, msg, size);
+	err = sock->ops->sendmsg(iocb, sock, msg, size);
+
+#ifdef CONFIG_RSBAC
+	if (!err && (rsbac_target != T_NONE)) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_SEND,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sock_sendmsg() [sys_send(), sys_sendto(), sys_sendmsg()]: rsbac_adf_set_attr() returned error\n");
+		}
+	}
+#endif
+
+	return err;
 }
 
 int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
@@ -674,6 +812,14 @@ static inline int __sock_recvmsg(struct 
 	int err;
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	enum  rsbac_attribute_t rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	si->sock = sock;
 	si->scm = NULL;
 	si->msg = msg;
@@ -684,7 +830,135 @@ static inline int __sock_recvmsg(struct 
 	if (err)
 		return err;
 
-	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	err = sock->ops->recvmsg(iocb, sock, msg, size, flags);
+
+#ifdef CONFIG_RSBAC
+	if (err > 0) {
+		rsbac_pr_debug(aef, "[sys_recv(), sys_recvfrom(), sys_recvmsg()]: calling ADF\n");
+		if (sock->ops->family == AF_UNIX) {
+			if(sock->sk) {
+				if(unix_sk(unix_sk(sock->sk)->peer)) {
+					if(   unix_sk(unix_sk(sock->sk)->peer)->dentry
+					   && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+					  ) {
+						rsbac_target = T_UNIXSOCK;
+						rsbac_target_id.unixsock.device = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_sb->s_dev;
+						rsbac_target_id.unixsock.inode  = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+						rsbac_target_id.unixsock.dentry_p = unix_sk(unix_sk(sock->sk)->peer)->dentry;
+					} else {
+						rsbac_target = T_IPC;
+						rsbac_target_id.ipc.type = I_anonunix;
+						if(   unix_sk(sock->sk)->peer->sk_socket
+						   && unix_sk(sock->sk)->peer->sk_socket->file
+						   && unix_sk(sock->sk)->peer->sk_socket->file->f_dentry
+						   && unix_sk(sock->sk)->peer->sk_socket->file->f_dentry->d_inode
+						  )
+							rsbac_target_id.ipc.id.id_nr = unix_sk(sock->sk)->peer->sk_socket->file->f_dentry->d_inode->i_ino;
+						else
+							if(   sock->file
+							   && sock->file->f_dentry
+							   && sock->file->f_dentry->d_inode
+							  )
+								rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+							else
+								rsbac_target_id.ipc.id.id_nr = 0;
+					}
+				} else {
+					if(   unix_sk(sock->sk)->dentry
+					   && unix_sk(sock->sk)->dentry->d_inode
+					  ) {
+						rsbac_target = T_UNIXSOCK;
+						rsbac_target_id.unixsock.device = unix_sk(sock->sk)->dentry->d_sb->s_dev;
+						rsbac_target_id.unixsock.inode  = unix_sk(sock->sk)->dentry->d_inode->i_ino;
+						rsbac_target_id.unixsock.dentry_p = unix_sk(sock->sk)->dentry;
+					} else {
+						rsbac_target = T_IPC;
+						rsbac_target_id.ipc.type = I_anonunix;
+						if(   sock->file
+						   && sock->file->f_dentry
+						   && sock->file->f_dentry->d_inode
+						  )
+							rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+						else
+							rsbac_target_id.ipc.id.id_nr = 0;
+					}
+				}
+				if (   sock->sk->sk_peercred.pid
+				    && (rsbac_attribute_value.process = find_pid_ns(sock->sk->sk_peercred.pid, &init_pid_ns))
+				    && (pid_nr(rsbac_attribute_value.process) > 0)
+				   ) {
+					rsbac_attribute = A_process;
+				} else
+					if (   unix_sk(sock->sk)->peer
+					    && unix_sk(sock->sk)->peer->sk_peercred.pid
+					    && (rsbac_attribute_value.process = find_pid_ns(unix_sk(sock->sk)->peer->sk_peercred.pid, &init_pid_ns))
+					    && (pid_nr(rsbac_attribute_value.process) > 0)
+					   ) {
+						rsbac_attribute = A_process;
+					} else {
+						rsbac_attribute = A_sock_type;
+						rsbac_attribute_value.sock_type = sock->type;
+					}
+			}
+		}
+#if defined(CONFIG_RSBAC_NET_OBJ)
+		else {
+#if !defined(CONFIG_RSBAC_NET_OBJ_RW)
+			if (sock->type != SOCK_STREAM)
+#endif
+			{
+				rsbac_target = T_NETOBJ;
+				rsbac_target_id.netobj.sock_p = sock;
+				rsbac_target_id.netobj.local_addr = NULL;
+				rsbac_target_id.netobj.local_len = 0;
+				rsbac_target_id.netobj.remote_addr = msg->msg_name;
+				rsbac_target_id.netobj.remote_len = msg->msg_namelen;
+				if (   sock->sk->sk_peercred.pid
+				    && (rsbac_attribute_value.process = find_pid_ns(sock->sk->sk_peercred.pid, &init_pid_ns))
+				    && (pid_nr(rsbac_attribute_value.process) > 0)
+				   ) {
+					rsbac_attribute = A_process;
+				} else {
+	                        	rsbac_attribute = A_sock_type;
+					rsbac_attribute_value.sock_type = sock->type;
+				}
+			}
+		}
+#endif
+		if ((rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_RECEIVE,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+		{
+			/* clear buffer */
+			memset(msg->msg_iov->iov_base - err, 0, err);
+			return -EPERM;
+		}
+	}
+#endif
+
+#ifdef CONFIG_RSBAC
+	if ((err > 0) && (rsbac_target != T_NONE)) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_RECEIVE,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sock_recvmsg() [sys_recv(), sys_recvfrom(), sys_recvmsg()]: rsbac_adf_set_attr() for RECEIVE returned error\n");
+		}
+	}
+#endif
+
+	return err;
 }
 
 int sock_recvmsg(struct socket *sock, struct msghdr *msg,
@@ -1269,6 +1543,13 @@ SYSCALL_DEFINE3(socket, int, family, int
 	struct socket *sock;
 	int flags;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union  rsbac_target_id_t rsbac_target_id;
+	union  rsbac_target_id_t rsbac_new_target_id;
+	union  rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/* Check the SOCK_* constants for consistency.  */
 	BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);
 	BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);
@@ -1287,10 +1568,60 @@ SYSCALL_DEFINE3(socket, int, family, int
 	if (retval < 0)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	if (family == AF_UNIX) {
+		rsbac_target = T_IPC;
+		rsbac_target_id.ipc.type = I_anonunix;
+		rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock)->i_ino;
+	}
+#ifdef CONFIG_RSBAC_NET_OBJ
+	else {
+		rsbac_pr_debug(aef, "[sys_socket()]: calling ADF\n");
+		rsbac_target = T_NETOBJ;
+		rsbac_target_id.netobj.sock_p = sock;
+		rsbac_target_id.netobj.local_addr = NULL;
+		rsbac_target_id.netobj.local_len = 0;
+		rsbac_target_id.netobj.remote_addr = NULL;
+		rsbac_target_id.netobj.remote_len = 0;
+	}
+#endif
+	rsbac_attribute_value.sock_type = type;
+	if ((rsbac_target != T_NONE)
+			&& !rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_sock_type,
+				rsbac_attribute_value))
+	{
+		rsbac_pr_debug(aef, "[sys_socket()]: ADF returned NOT_GRANTED\n");
+		retval = -EPERM;
+		goto out_release;
+	}
+#endif
+
 	retval = sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));
 	if (retval < 0)
 		goto out_release;
 
+#ifdef CONFIG_RSBAC
+	if(rsbac_target != T_NONE) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CREATE,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_sock_type,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_socket(): rsbac_adf_set_attr() returned error\n");
+		}
+	}
+#endif
+
 out:
 	/* It may be already another descriptor 8) Not kernel problem. */
 	return retval;
@@ -1312,6 +1643,12 @@ SYSCALL_DEFINE4(socketpair, int, family,
 	struct file *newfile1, *newfile2;
 	int flags;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	flags = type & ~SOCK_TYPE_MASK;
 	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
 		return -EINVAL;
@@ -1329,10 +1666,45 @@ SYSCALL_DEFINE4(socketpair, int, family,
 	if (err < 0)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonunix;
+	rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock1)->i_ino;
+	rsbac_attribute_value.sock_type = type;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_sock_type,
+				rsbac_attribute_value))
+	{
+		rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+		err = -EPERM;
+		goto out_release_1;
+	}
+#endif
+
 	err = sock_create(family, type, protocol, &sock2);
 	if (err < 0)
 		goto out_release_1;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonunix;
+	rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock2)->i_ino;
+	if (!rsbac_adf_request(R_CREATE,
+				task_pid(current),
+				T_IPC,
+				rsbac_target_id,
+				A_sock_type,
+				rsbac_attribute_value))
+	{
+		rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+		err = -EPERM;
+		goto out_release_both;
+	}
+#endif
+
 	err = sock1->ops->socketpair(sock1, sock2);
 	if (err < 0)
 		goto out_release_both;
@@ -1372,8 +1744,41 @@ SYSCALL_DEFINE4(socketpair, int, family,
 	err = put_user(fd1, &usockvec[0]);
 	if (!err)
 		err = put_user(fd2, &usockvec[1]);
-	if (!err)
+
+	if (!err) {
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock1)->i_ino;
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CREATE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_sock_type,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_socketpair() [sys_socketcall()]: rsbac_adf_set_attr() for sock1 returned error\n");
+		}
+		rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock2)->i_ino;
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CREATE,
+					task_pid(current),
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_sock_type,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_socketpair() [sys_socketcall()]: rsbac_adf_set_attr() for sock2 returned error\n");
+		}
+#endif
+
 		return 0;
+        }
 
 	sys_close(fd2);
 	sys_close(fd1);
@@ -1411,10 +1816,38 @@ SYSCALL_DEFINE3(bind, int, fd, struct so
 	struct sockaddr_storage address;
 	int err, fput_needed;
 
+#ifdef CONFIG_RSBAC_NET_OBJ
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t	rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock) {
 		err = move_addr_to_kernel(umyaddr, addrlen, (struct sockaddr *)&address);
-		if (err >= 0) {
+		if(err >= 0) {
+#ifdef CONFIG_RSBAC_NET_OBJ
+			if (sock->ops->family != AF_UNIX) {
+				rsbac_target_id.netobj.sock_p = sock;
+				rsbac_target_id.netobj.local_addr = (struct sockaddr *)&address;
+				rsbac_target_id.netobj.local_len = addrlen;
+				rsbac_target_id.netobj.remote_addr = NULL;
+				rsbac_target_id.netobj.remote_len = 0;
+				rsbac_attribute_value.sock_type = sock->type;
+				rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF");
+				if(!rsbac_adf_request(R_BIND,
+							task_pid(current),
+							T_NETOBJ,
+							rsbac_target_id,
+							A_sock_type,
+							rsbac_attribute_value)) {
+					rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+					fput_light(sock->file, fput_needed);
+					return -EPERM;
+				}
+			}
+#endif
+
 			err = security_socket_bind(sock,
 						   (struct sockaddr *)&address,
 						   addrlen);
@@ -1422,6 +1855,24 @@ SYSCALL_DEFINE3(bind, int, fd, struct so
 				err = sock->ops->bind(sock,
 						      (struct sockaddr *)
 						      &address, addrlen);
+
+#ifdef CONFIG_RSBAC_NET_OBJ
+			if (!err && sock->ops && (sock->ops->family != AF_UNIX)) {
+				rsbac_new_target_id.dummy = 0;
+				if (rsbac_adf_set_attr(R_BIND,
+							task_pid(current),
+							T_NETOBJ,
+							rsbac_target_id,
+							T_NONE,
+							rsbac_new_target_id,
+							A_sock_type,
+							rsbac_attribute_value))
+				{
+					rsbac_printk(KERN_WARNING
+							"sys_bind() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+				}
+			}
+#endif
 		}
 		fput_light(sock->file, fput_needed);
 	}
@@ -1438,10 +1889,60 @@ SYSCALL_DEFINE2(listen, int, fd, int, ba
 {
 	struct socket *sock;
 	int err, fput_needed;
+	
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+	
 	int somaxconn;
 
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock) {
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+		if (sock->ops->family == AF_UNIX) {
+			if (sock->file
+			&& sock->file->f_dentry
+			&& sock->file->f_dentry->d_inode) {
+				if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+				} else {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+				}
+			}
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+		rsbac_attribute_value.sock_type = sock->type;
+		if ((rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_LISTEN,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value)) {
+			rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+			fput_light(sock->file, fput_needed);
+			return -EPERM;
+		}
+#endif
+
 		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
 		if ((unsigned)backlog > somaxconn)
 			backlog = somaxconn;
@@ -1450,6 +1951,23 @@ SYSCALL_DEFINE2(listen, int, fd, int, ba
 		if (!err)
 			err = sock->ops->listen(sock, backlog);
 
+
+#ifdef CONFIG_RSBAC
+		if (!err && (rsbac_target != T_NONE)) {
+			rsbac_new_target_id.dummy = 0;
+			if (rsbac_adf_set_attr(R_LISTEN,
+						task_pid(current),
+						rsbac_target,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_sock_type,
+						rsbac_attribute_value))
+				rsbac_printk(KERN_WARNING
+						"sys_listen() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+		}
+#endif
+
 		fput_light(sock->file, fput_needed);
 	}
 	return err;
@@ -1475,6 +1993,14 @@ SYSCALL_DEFINE4(accept4, int, fd, struct
 	int err, len, newfd, fput_needed;
 	struct sockaddr_storage address;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	enum  rsbac_attribute_t rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
 		return -EINVAL;
 
@@ -1517,6 +2043,100 @@ SYSCALL_DEFINE4(accept4, int, fd, struct
 	if (err < 0)
 		goto out_fd;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+	if (sock->ops->family == AF_UNIX) {
+		if (sock->sk) {
+			if (unix_sk(unix_sk(sock->sk)->peer)) {
+				if (unix_sk(unix_sk(sock->sk)->peer)->dentry
+						&& unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode) {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = unix_sk(unix_sk(sock->sk)->peer)->dentry;
+				} else {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					if (unix_sk(unix_sk(sock->sk)->peer)->dentry
+							&& unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+							&& SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file
+							&& SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry
+							&& SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry->d_inode)
+						rsbac_target_id.ipc.id.id_nr = SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry->d_inode->i_ino;
+					else
+						if (sock->file
+								&& sock->file->f_dentry
+								&& sock->file->f_dentry->d_inode)
+							rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+						else
+							rsbac_target_id.ipc.id.id_nr = 0;
+				}
+			} else {
+				if(   unix_sk(sock->sk)->dentry
+						&& unix_sk(sock->sk)->dentry->d_inode) {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = unix_sk(sock->sk)->dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = unix_sk(sock->sk)->dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = unix_sk(sock->sk)->dentry;
+				} else {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					if (sock->file
+							&& sock->file->f_dentry
+							&& sock->file->f_dentry->d_inode)
+						rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+					else
+						rsbac_target_id.ipc.id.id_nr = 0;
+				}
+			}
+		}
+		if (   sock->sk
+		    && sock->sk->sk_peercred.pid
+		    && (rsbac_attribute_value.process = find_pid_ns(sock->sk->sk_peercred.pid, &init_pid_ns))
+		    && (pid_nr(rsbac_attribute_value.process) > 0)
+		   ) {
+			rsbac_attribute = A_process;
+		} else {
+                       	rsbac_attribute = A_sock_type;
+			rsbac_attribute_value.sock_type = sock->type;
+		}
+	}
+#ifdef CONFIG_RSBAC_NET_OBJ
+	else {
+		rsbac_target = T_NETOBJ;
+		rsbac_target_id.netobj.sock_p = newsock;
+		rsbac_target_id.netobj.local_addr = NULL;
+		rsbac_target_id.netobj.local_len = 0;
+		if(newsock->ops->getname(newsock, (struct sockaddr *)&address, &len, 2) <0) {
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		} else {
+			rsbac_target_id.netobj.remote_addr = (struct sockaddr *)&address;
+			rsbac_target_id.netobj.remote_len = len;
+		}
+		if (sock->sk
+			&& sock->sk->sk_peercred.pid) {
+			rsbac_attribute = A_process;
+			rsbac_attribute_value.process = find_pid_ns(sock->sk->sk_peercred.pid, &init_pid_ns);
+		} else {
+			rsbac_attribute = A_sock_type;
+			rsbac_attribute_value.sock_type = sock->type;
+		}
+	}
+#endif
+	if ((rsbac_target != T_NONE)
+		&& !rsbac_adf_request(R_ACCEPT,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				rsbac_attribute,
+				rsbac_attribute_value)) {
+		rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+		err = -EPERM;
+		goto out_fd;
+	}
+#endif
+
 	if (upeer_sockaddr) {
 		if (newsock->ops->getname(newsock, (struct sockaddr *)&address,
 					  &len, 2) < 0) {
@@ -1534,6 +2154,22 @@ SYSCALL_DEFINE4(accept4, int, fd, struct
 	fd_install(newfd, newfile);
 	err = newfd;
 
+#ifdef CONFIG_RSBAC
+	if (rsbac_target != T_NONE) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_ACCEPT,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+			rsbac_printk(KERN_WARNING
+					"sys_accept() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
@@ -1574,6 +2210,12 @@ SYSCALL_DEFINE3(connect, int, fd, struct
 	struct sockaddr_storage address;
 	int err, fput_needed;
 
+#ifdef CONFIG_RSBAC_NET_OBJ
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
@@ -1586,8 +2228,51 @@ SYSCALL_DEFINE3(connect, int, fd, struct
 	if (err)
 		goto out_put;
 
+        /* RSBAC UNIX socket connects get intercepted in unix/af_unix.c */
+#ifdef CONFIG_RSBAC_NET_OBJ
+	if (sock->ops->family != AF_UNIX) {
+		rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+		rsbac_target_id.netobj.sock_p = sock;
+		rsbac_target_id.netobj.local_addr = NULL;
+		rsbac_target_id.netobj.local_len = 0;
+		rsbac_target_id.netobj.remote_addr = (struct sockaddr *)&address;
+		rsbac_target_id.netobj.remote_len = addrlen;
+		rsbac_attribute_value.sock_type = sock->type;
+		if (!rsbac_adf_request(R_CONNECT,
+					task_pid(current),
+					T_NETOBJ,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value))
+		{
+			rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+			err = -EPERM;
+			goto out_put;
+		}
+	}
+#endif
+
 	err = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,
 				 sock->file->f_flags);
+
+        /* RSBAC: notify ADF of opened socket connection */
+#ifdef CONFIG_RSBAC_NET_OBJ
+	if (!err
+		&& (sock->ops->family != AF_UNIX)) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CONNECT,
+					task_pid(current),
+					T_NETOBJ,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_sock_type,
+					rsbac_attribute_value))
+			rsbac_printk(KERN_WARNING
+					"sys_connect() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
@@ -1606,6 +2291,12 @@ SYSCALL_DEFINE3(getsockname, int, fd, st
 	struct sockaddr_storage address;
 	int len, err, fput_needed;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
@@ -1614,6 +2305,47 @@ SYSCALL_DEFINE3(getsockname, int, fd, st
 	if (err)
 		goto out_put;
 
+#if defined(CONFIG_RSBAC)
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if (sock->ops->family == AF_UNIX) {
+		if (sock->file
+                && sock->file->f_dentry
+		&& sock->file->f_dentry->d_inode) {
+			if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+				rsbac_target = T_IPC;
+				rsbac_target_id.ipc.type = I_anonunix;
+				rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+			} else {
+				rsbac_target = T_UNIXSOCK;
+				rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+				rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+				rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+			}
+		}
+	}
+#ifdef CONFIG_RSBAC_NET_OBJ
+	else {
+		rsbac_target = T_NETOBJ;
+		rsbac_target_id.netobj.sock_p = sock;
+		rsbac_target_id.netobj.local_addr = NULL;
+		rsbac_target_id.netobj.local_len = 0;
+		rsbac_target_id.netobj.remote_addr = NULL;
+		rsbac_target_id.netobj.remote_len = 0;
+	}
+#endif
+	rsbac_attribute_value.sock_type = sock->type;
+	if ((rsbac_target != T_NONE)
+		&& !rsbac_adf_request(R_GET_STATUS_DATA,
+				task_pid(current),
+				rsbac_target,
+				rsbac_target_id,
+				A_sock_type,
+				rsbac_attribute_value)) {
+		err = -EPERM;
+		goto out_put;
+	}
+#endif
+
 	err = sock->ops->getname(sock, (struct sockaddr *)&address, &len, 0);
 	if (err)
 		goto out_put;
@@ -1637,6 +2369,12 @@ SYSCALL_DEFINE3(getpeername, int, fd, st
 	struct sockaddr_storage address;
 	int len, err, fput_needed;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock != NULL) {
 		err = security_socket_getpeername(sock);
@@ -1645,6 +2383,47 @@ SYSCALL_DEFINE3(getpeername, int, fd, st
 			return err;
 		}
 
+#if defined(CONFIG_RSBAC)
+		rsbac_pr_debug(aef, "calling ADF\n");
+		if (sock->ops->family == AF_UNIX) {
+			if (sock->file
+			&& sock->file->f_dentry
+			&& sock->file->f_dentry->d_inode) {
+				if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+				} else {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+				}
+			}
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+		rsbac_attribute_value.sock_type = sock->type;
+		if ((rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value)) {
+			fput_light(sock->file, fput_needed);
+			return -EPERM;
+		}
+#endif
+
 		err =
 		    sock->ops->getname(sock, (struct sockaddr *)&address, &len,
 				       1);
@@ -1779,6 +2558,12 @@ SYSCALL_DEFINE5(setsockopt, int, fd, int
 	int err, fput_needed;
 	struct socket *sock;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (optlen < 0)
 		return -EINVAL;
 
@@ -1788,6 +2573,47 @@ SYSCALL_DEFINE5(setsockopt, int, fd, int
 		if (err)
 			goto out_put;
 
+#if defined(CONFIG_RSBAC)
+		rsbac_pr_debug(aef, "calling ADF\n");
+		if (sock->ops->family == AF_UNIX) {
+			if (sock->file
+			&& sock->file->f_dentry
+			&& sock->file->f_dentry->d_inode) {
+				if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+				} else {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+				}
+			}
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+		rsbac_attribute_value.setsockopt_level = level;
+		if ((rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_setsockopt_level,
+					rsbac_attribute_value)) {
+			err = -EPERM;
+			goto out_put;
+		}
+#endif
+
 		if (level == SOL_SOCKET)
 			err =
 			    sock_setsockopt(sock, level, optname, optval,
@@ -1813,12 +2639,62 @@ SYSCALL_DEFINE5(getsockopt, int, fd, int
 	int err, fput_needed;
 	struct socket *sock;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock != NULL) {
 		err = security_socket_getsockopt(sock, level, optname);
 		if (err)
 			goto out_put;
 
+#if defined(CONFIG_RSBAC)
+		rsbac_pr_debug(aef, "calling ADF\n");
+		if (sock->ops->family == AF_UNIX) {
+			if (sock->file
+			&& sock->file->f_dentry
+			&& sock->file->f_dentry->d_inode
+			&& sock->file->f_dentry->d_inode->i_ino
+			&& sock->file->f_dentry->d_sb
+			&& sock->file->f_dentry->d_sb->s_dev) {
+				if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+				} else {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+				}
+			}
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+		rsbac_attribute_value.sock_type = sock->type;
+		if ((rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_GET_STATUS_DATA,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value)) {
+			err = -EPERM;
+			goto out_put;
+		}
+#endif
+
 		if (level == SOL_SOCKET)
 			err =
 			    sock_getsockopt(sock, level, optname, optval,
@@ -1842,11 +2718,82 @@ SYSCALL_DEFINE2(shutdown, int, fd, int, 
 	int err, fput_needed;
 	struct socket *sock;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+#ifdef CONFIG_RSBAC_NET_OBJ
+	union rsbac_target_id_t rsbac_new_target_id;
+#endif
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock != NULL) {
 		err = security_socket_shutdown(sock, how);
+
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+		if (sock->ops->family == AF_UNIX) {
+			if (sock->file
+			&& sock->file->f_dentry
+			&& sock->file->f_dentry->d_inode) {
+				if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+					rsbac_target = T_IPC;
+					rsbac_target_id.ipc.type = I_anonunix;
+					rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+				} else {
+					rsbac_target = T_UNIXSOCK;
+					rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+					rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+					rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+				}
+			}
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+		rsbac_attribute_value.sock_type = sock->type;
+		if ((rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_NET_SHUTDOWN,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value)) {
+			err = -EPERM;
+		}
+#endif
+
 		if (!err)
 			err = sock->ops->shutdown(sock, how);
+
+#ifdef CONFIG_RSBAC_NET_OBJ
+		if (!err && (rsbac_target != T_NONE)) {
+			rsbac_pr_debug(aef, "calling rsbac_adf_set_attr() for NET_SHUTDOWN on netobj\n");
+			rsbac_new_target_id.dummy = 0;
+			rsbac_attribute_value.dummy = 0;
+			if (rsbac_adf_set_attr(R_NET_SHUTDOWN,
+						task_pid(current),
+						rsbac_target,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_sock_type,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING 
+						"sys_shutdown(): rsbac_adf_set_attr() for NET_SHUTDOWN on socket returned error\n");
+			}
+		}
+#endif
+
 		fput_light(sock->file, fput_needed);
 	}
 	return err;
@@ -2264,6 +3211,10 @@ static int __init sock_init(void)
 	init_inodecache();
 	register_filesystem(&sock_fs_type);
 	sock_mnt = kern_mount(&sock_fs_type);
+#ifdef CONFIG_RSBAC
+	if (!IS_ERR(sock_mnt))
+		rsbac_mount(sock_mnt);
+#endif
 
 	/* The real protocol initialization is performed in later initcalls.
 	 */
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/unix/af_unix.c linux-2.6.31-rsbac-1.4.2/net/unix/af_unix.c
--- trunk/net/unix/af_unix.c	2009-09-10 18:14:39.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/unix/af_unix.c	2009-09-10 18:17:22.000000000 +0200
@@ -115,6 +115,8 @@
 #include <net/checksum.h>
 #include <linux/security.h>
 
+#include <rsbac/hooks.h>
+
 static struct hlist_head unix_socket_table[UNIX_HASH_SIZE + 1];
 static DEFINE_SPINLOCK(unix_table_lock);
 static atomic_t unix_nr_socks = ATOMIC_INIT(0);
@@ -655,11 +657,26 @@ static int unix_release(struct socket *s
 {
 	struct sock *sk = sock->sk;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+#endif
+
 	if (!sk)
 		return 0;
 
 	sock->sk = NULL;
 
+#ifdef CONFIG_RSBAC
+	if (   sock->file
+			&& sock->file->f_dentry
+			&& sock->file->f_dentry->d_inode
+	   ) {
+		rsbac_target_id.ipc.type = I_anonunix;
+		rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+		rsbac_remove_target(T_IPC, rsbac_target_id);
+	}
+#endif
+
 	return unix_release_sock(sk, 0);
 }
 
@@ -828,6 +845,19 @@ static int unix_bind(struct socket *sock
 		if (IS_ERR(dentry))
 			goto out_mknod_unlock;
 
+#ifdef CONFIG_RSBAC
+		/* RSBAC add: set credentials so connect and send can copy them */
+		{
+			const struct cred *tcred;
+			rcu_read_lock();
+			tcred = __task_cred(current);
+			sk->sk_peercred.pid	= tcred->sgid;
+			sk->sk_peercred.uid	= tcred->euid;
+			sk->sk_peercred.gid	= tcred->egid;
+			rcu_read_unlock();
+		}
+#endif
+
 		/*
 		 * All right, let's create it.
 		 */
@@ -927,6 +957,14 @@ static int unix_dgram_connect(struct soc
 	unsigned hash;
 	int err;
 
+#ifdef CONFIG_RSBAC
+	enum rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	enum  rsbac_attribute_t rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (addr->sa_family != AF_UNSPEC) {
 		err = unix_mkname(sunaddr, alen, &hash);
 		if (err < 0)
@@ -942,6 +980,46 @@ restart:
 		if (!other)
 			goto out;
 
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_connect() [sys_socketcall()]]: calling ADF\n");
+		/* Named socket? */
+		if(sunaddr->sun_path[0]) {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = unix_sk(other)->dentry->d_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = unix_sk(other)->dentry->d_inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = unix_sk(other)->dentry;
+		} else {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = unix_sk(other)->dentry->d_inode->i_ino;
+		}
+		if (   other->sk_peercred.pid
+		    && (rsbac_attribute_value.process = find_pid_ns(other->sk_peercred.pid, &init_pid_ns))
+		    && (pid_nr(rsbac_attribute_value.process) > 0)
+		   ) {
+			rsbac_attribute = A_process;
+		} else if (   sk->sk_peercred.pid
+			   && (rsbac_attribute_value.process = find_pid_ns(sk->sk_peercred.pid, &init_pid_ns))
+			   && (pid_nr(rsbac_attribute_value.process) > 0)
+		          ) {
+			rsbac_attribute = A_process;
+		} else {
+			rsbac_attribute = A_sock_type;
+			rsbac_attribute_value.sock_type = sock->type;
+		}
+		if (!rsbac_adf_request(R_CONNECT,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value)) {
+			rsbac_pr_debug(aef, "[sys_connect() [sys_socketcall()]]: ADF returned NOT_GRANTED\n");
+			err = -EPERM;
+			sock_put(other);
+			goto out;
+		}
+#endif
+
 		unix_state_double_lock(sk, other);
 
 		/* Apparently VFS overslept socket death. Retry. */
@@ -982,6 +1060,23 @@ restart:
 		unix_peer(sk) = other;
 		unix_state_double_unlock(sk, other);
 	}
+
+#ifdef CONFIG_RSBAC
+	if (rsbac_target != T_NONE) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CONNECT,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+			rsbac_printk(KERN_WARNING
+					"unix_dgram_connect() [sys_connect() [sys_socketcall()]]: rsbac_adf_set_attr() returned error\n");
+	}
+        #endif
+
 	return 0;
 
 out_unlock:
@@ -1027,6 +1122,14 @@ static int unix_stream_connect(struct so
 	int err;
 	long timeo;
 
+#ifdef CONFIG_RSBAC
+	enum rsbac_target_t rsbac_target = T_NONE;
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t rsbac_new_target_id;
+	enum  rsbac_attribute_t rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
 		goto out;
@@ -1061,6 +1164,48 @@ restart:
 	if (!other)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	if (unix_sk(other)->dentry && unix_sk(other)->dentry->d_inode) {
+		rsbac_pr_debug(aef, "[sys_connect() [sys_socketcall()]]: calling ADF\n");
+		/* Named socket? */
+		if (sunaddr->sun_path[0]) {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = unix_sk(other)->dentry->d_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = unix_sk(other)->dentry->d_inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = unix_sk(other)->dentry;
+		} else {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = unix_sk(other)->dentry->d_inode->i_ino;
+		}
+		if (   other->sk_peercred.pid
+		    && (rsbac_attribute_value.process = find_pid_ns(other->sk_peercred.pid, &init_pid_ns))
+		    && (pid_nr(rsbac_attribute_value.process) > 0)
+		   ) {
+			rsbac_attribute = A_process;
+		} else if (   sk->sk_peercred.pid
+			   && (rsbac_attribute_value.process = find_pid_ns(sk->sk_peercred.pid, &init_pid_ns))
+			   && (pid_nr(rsbac_attribute_value.process) > 0)
+		          ) {
+			rsbac_attribute = A_process;
+		} else {
+			rsbac_attribute = A_sock_type;
+			rsbac_attribute_value.sock_type = sock->type;
+		}
+		if (!rsbac_adf_request(R_CONNECT,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value)) {
+			rsbac_pr_debug(aef, "[sys_connect() [sys_socketcall()]]:"
+					" ADF returned NOT_GRANTED\n");
+			err = -EPERM;
+			goto out;
+		}
+	}
+#endif
+
 	/* Latch state of peer */
 	unix_state_lock(other);
 
@@ -1170,6 +1315,23 @@ restart:
 	spin_unlock(&other->sk_receive_queue.lock);
 	unix_state_unlock(other);
 	other->sk_data_ready(other, 0);
+
+#ifdef CONFIG_RSBAC
+	if (rsbac_target != T_NONE) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CONNECT,
+					task_pid(current),
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+			rsbac_printk(KERN_WARNING
+					"unix_stream_connect() [sys_connect() [sys_socketcall()]]: rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	sock_put(other);
 	return 0;
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/net/wireless/wext.c linux-2.6.31-rsbac-1.4.2/net/wireless/wext.c
--- trunk/net/wireless/wext.c	2009-09-10 18:14:43.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/net/wireless/wext.c	2009-09-10 18:17:26.000000000 +0200
@@ -102,6 +102,8 @@
 
 #include <asm/uaccess.h>		/* copy_to_user() */
 
+#include <rsbac/hooks.h>
+
 /************************* GLOBAL VARIABLES *************************/
 /*
  * You should not use global variables, because of re-entrancy.
@@ -1106,10 +1108,28 @@ static int wireless_process_ioctl(struct
  */
 static int wext_permission_check(unsigned int cmd)
 {
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if ((IW_IS_SET(cmd) || cmd == SIOCGIWENCODE || cmd == SIOCGIWENCODEEXT)
 	    && !capable(CAP_NET_ADMIN))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, " calling ADF\n");
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				task_pid(current),
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	return 0;
 }
 
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/security/Kconfig linux-2.6.31-rsbac-1.4.2/security/Kconfig
--- trunk/security/Kconfig	2009-09-10 18:14:51.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/security/Kconfig	2009-09-10 18:17:36.000000000 +0200
@@ -4,6 +4,8 @@
 
 menu "Security options"
 
+source "rsbac/Kconfig"
+
 config KEYS
 	bool "Enable access key retention support"
 	help
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/security/selinux/selinuxfs.c linux-2.6.31-rsbac-1.4.2/security/selinux/selinuxfs.c
--- trunk/security/selinux/selinuxfs.c	2009-09-10 18:14:51.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/security/selinux/selinuxfs.c	2009-09-10 18:17:36.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/percpu.h>
 #include <linux/audit.h>
 #include <linux/uaccess.h>
+#include <rsbac/aci.h>
 
 /* selinuxfs pseudo filesystem for exporting the security policy API.
    Based on the proc code and the fs/nfsd/nfsctl.c code. */
@@ -1726,6 +1727,10 @@ static int __init init_sel_fs(void)
 			err = PTR_ERR(selinuxfs_mount);
 			selinuxfs_mount = NULL;
 		}
+#ifdef CONFIG_RSBAC
+		else
+			rsbac_mount(selinuxfs_mount);
+#endif
 	}
 	return err;
 }
diff -urpN -x rsbac -x autoconf.h -x .config -x .gitignore trunk/security/smack/smackfs.c linux-2.6.31-rsbac-1.4.2/security/smack/smackfs.c
--- trunk/security/smack/smackfs.c	2009-09-10 18:14:52.000000000 +0200
+++ linux-2.6.31-rsbac-1.4.2/security/smack/smackfs.c	2009-09-10 18:17:36.000000000 +0200
@@ -1358,6 +1358,10 @@ static int __init init_smk_fs(void)
 			err = PTR_ERR(smackfs_mount);
 			smackfs_mount = NULL;
 		}
+#ifdef CONFIG_RSBAC
+		else
+			rsbac_mount(smackfs_mount);
+#endif
 	}
 
 	smk_cipso_doi();
