diff -ruN linux-2.6.21/drivers/media/video/Kconfig linux-2.6.21-gspca/drivers/media/video/Kconfig
--- linux-2.6.21/drivers/media/video/Kconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-gspca/drivers/media/video/Kconfig	2007-05-13 00:27:26.000000000 +0200
@@ -703,6 +703,8 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ovcamchip.
 
+source "drivers/media/video/gspca/Kconfig"
+
 config USB_W9968CF
 	tristate "USB W996[87]CF JPEG Dual Mode Camera support"
 	depends on USB && VIDEO_V4L1 && I2C
diff -ruN linux-2.6.21/drivers/media/video/Makefile linux-2.6.21-gspca/drivers/media/video/Makefile
--- linux-2.6.21/drivers/media/video/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21-gspca/drivers/media/video/Makefile	2007-05-13 00:27:29.000000000 +0200
@@ -112,4 +112,6 @@
 
 obj-$(CONFIG_VIDEO_VIVI) += vivi.o
 
+obj-$(CONFIG_VIDEO_GSPCA) += gspca/
+
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
diff -ruN linux-2.6.21/drivers/media/video/gspca/Conexant/cx11646.h linux-2.6.21-gspca/drivers/media/video/gspca/Conexant/cx11646.h
--- linux-2.6.21/drivers/media/video/gspca/Conexant/cx11646.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Conexant/cx11646.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,167 @@
+#ifndef CX11646USB_H
+#define CX11646USB_H
+/****************************************************************************
+#	 	Connexant Cx11646    library                                #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+#include "cxlib.h"
+/**************************************************************************/
+static int cx11646_init(struct usb_spca50x *spca50x);
+static void cx11646_start(struct usb_spca50x *spca50x);
+static void cx11646_stop0(struct usb_spca50x *spca50x);
+static void cx11646_stopN(struct usb_spca50x *spca50x);
+static int cx11646_config(struct usb_spca50x *spca50x);
+static void cx11646_shutdown(struct usb_spca50x *spca50x);
+static void cx11646_setAutobright(struct usb_spca50x *spca50x);
+static void cx11646_setquality(struct usb_spca50x *spca50x);
+static int cx11646_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char* cdata,int *iPix, int seqnum, int *datalength);
+/**************************************************************************/
+static void cx11646_stopN(struct usb_spca50x *spca50x){}
+static void cx11646_shutdown(struct usb_spca50x *spca50x){}
+static void cx11646_setAutobright(struct usb_spca50x *spca50x){}
+static void cx11646_setquality(struct usb_spca50x *spca50x){}
+/**************************************************************************/
+static struct cam_operation fcx11646 = {
+ 	.initialize = cx11646_init,
+	.configure = cx11646_config,
+	.start = cx11646_start,
+	.stopN = cx11646_stopN,
+	.stop0 = cx11646_stop0,
+	.get_bright = cx_getbrightness,
+	.set_bright = cx_setbrightness,
+	.get_contrast = cx_getcontrast,
+	.set_contrast = cx_setcontrast,
+	.get_colors = cx_getcolors,
+	.set_colors = cx_setcolors,
+	.set_autobright = cx11646_setAutobright,
+	.set_quality = cx11646_setquality,
+	.cam_shutdown = cx11646_shutdown,
+	.sof_detect = cx11646_sofdetect,
+ };
+static int cx11646_init(struct usb_spca50x *spca50x)
+{
+    int err;
+    cx11646_init1(spca50x);
+    err = cx11646_initsize(spca50x);
+    cx11646_fw(spca50x);
+    cx_sensor(spca50x);
+    cx11646_jpegInit(spca50x);
+    return 0;
+}
+static void cx11646_start(struct usb_spca50x *spca50x)
+{
+    int err;
+    err = cx11646_initsize(spca50x);
+    cx11646_fw(spca50x);
+    cx_sensor(spca50x);
+    cx11646_jpeg(spca50x);
+}
+static void cx11646_stop0(struct usb_spca50x *spca50x)
+{
+
+    int retry = 50;
+    __u8 val = 0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0000, &val, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0002, &val, 1);
+    val = 0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0053, &val, 1);
+
+    while (retry--) {
+	//spca5xxRegRead (spca50x->dev,0x00,0x00,0x0002,&val,1);
+	spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0053, &val, 1);
+	if (val == 0)
+	    break;
+    }
+    val = 0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0000, &val, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0002, &val, 1);
+
+    val = 0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, &val, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0033, &val, 1);
+    val = 0xE0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00fc, &val, 1);
+
+}
+static int cx11646_config(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1023;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 0;
+    
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1023;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 0;
+    
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 1;
+    
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 2;
+    
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 2;
+    
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_JPEG | P_RAW |P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 640;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 3;
+    
+return 0;
+}
+static int cx11646_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+   *iPix = 0;
+		if (cdata[0] == 0xFF && cdata[1] == 0xD8) {
+		    *iPix = 2;
+		    *datalength -= *iPix;
+		    PDEBUG(5,
+			   "Cx11646 header packet found datalength %d !!",
+			   *datalength);
+		   return 0;
+		} else 
+		   return (seqnum+1);
+}
+#endif				//CX11646USB_H
diff -ruN linux-2.6.21/drivers/media/video/gspca/Conexant/cxlib.h linux-2.6.21-gspca/drivers/media/video/gspca/Conexant/cxlib.h
--- linux-2.6.21/drivers/media/video/gspca/Conexant/cxlib.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Conexant/cxlib.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,839 @@
+
+/****************************************************************************
+#	 	Connexant Cx11646    library                                #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+static __u8 cx_sensor_init[][4] = {
+    {0x88, 0x11, 0x01, 0x01},
+    {0x88, 0x12, 0x70, 0x01},
+    {0x88, 0x0f, 0x00, 0x01},
+    {0x88, 0x05, 0x01, 0x01},
+    {0, 0, 0, 0}
+};
+static void cx11646_init1(struct usb_spca50x *spca50x)
+{
+    __u8 val = 0;
+    int i = 0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, &val, 1);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0053, &val, 1);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0052, &val, 1);
+    val = 0x2f;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x009b, &val, 1);
+    val = 0x10;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x009c, &val, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0098, &val, 1);
+    val = 0x40;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0098, &val, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0099, &val, 1);
+    val = 0x07;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0099, &val, 1);
+    val = 0x40;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0039, &val, 1);
+    val = 0xff;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x003c, &val, 1);
+    val = 0x1f;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x003f, &val, 1);
+    val = 0x40;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x003d, &val, 1);
+//val= 0x60;
+//spca5xxRegWrite(spca50x->dev,0x00,0x00,0x003d,&val,1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0099, &val, 1);	//->0x07
+
+    while (cx_sensor_init[i][0]) {
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5,
+			cx_sensor_init[i], 1);
+	spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, &val, 1);	// -> 0x00
+	if (i == 1) {
+	    val = 1;
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00ed, &val, 1);
+	    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00ed, &val, 1);	//-> 0x01
+	}
+	i++;
+    }
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c3, &val, 1);
+}
+static __u8 cx11646_fw1[][3] = {
+    {0x00, 0x02, 0x00},
+    {0x01, 0x43, 0x00},
+    {0x02, 0xA7, 0x00},
+    {0x03, 0x8B, 0x01},
+    {0x04, 0xE9, 0x02},
+    {0x05, 0x08, 0x04},
+    {0x06, 0x08, 0x05},
+    {0x07, 0x07, 0x06},
+    {0x08, 0xE7, 0x06},
+    {0x09, 0xC6, 0x07},
+    {0x0A, 0x86, 0x08},
+    {0x0B, 0x46, 0x09},
+    {0x0C, 0x05, 0x0A},
+    {0x0D, 0xA5, 0x0A},
+    {0x0E, 0x45, 0x0B},
+    {0x0F, 0xE5, 0x0B},
+    {0x10, 0x85, 0x0C},
+    {0x11, 0x25, 0x0D},
+    {0x12, 0xC4, 0x0D},
+    {0x13, 0x45, 0x0E},
+    {0x14, 0xE4, 0x0E},
+    {0x15, 0x64, 0x0F},
+    {0x16, 0xE4, 0x0F},
+    {0x17, 0x64, 0x10},
+    {0x18, 0xE4, 0x10},
+    {0x19, 0x64, 0x11},
+    {0x1A, 0xE4, 0x11},
+    {0x1B, 0x64, 0x12},
+    {0x1C, 0xE3, 0x12},
+    {0x1D, 0x44, 0x13},
+    {0x1E, 0xC3, 0x13},
+    {0x1F, 0x24, 0x14},
+    {0x20, 0xA3, 0x14},
+    {0x21, 0x04, 0x15},
+    {0x22, 0x83, 0x15},
+    {0x23, 0xE3, 0x15},
+    {0x24, 0x43, 0x16},
+    {0x25, 0xA4, 0x16},
+    {0x26, 0x23, 0x17},
+    {0x27, 0x83, 0x17},
+    {0x28, 0xE3, 0x17},
+    {0x29, 0x43, 0x18},
+    {0x2A, 0xA3, 0x18},
+    {0x2B, 0x03, 0x19},
+    {0x2C, 0x63, 0x19},
+    {0x2D, 0xC3, 0x19},
+    {0x2E, 0x22, 0x1A},
+    {0x2F, 0x63, 0x1A},
+    {0x30, 0xC3, 0x1A},
+    {0x31, 0x23, 0x1B},
+    {0x32, 0x83, 0x1B},
+    {0x33, 0xE2, 0x1B},
+    {0x34, 0x23, 0x1C},
+    {0x35, 0x83, 0x1C},
+    {0x36, 0xE2, 0x1C},
+    {0x37, 0x23, 0x1D},
+    {0x38, 0x83, 0x1D},
+    {0x39, 0xE2, 0x1D},
+    {0x3A, 0x23, 0x1E},
+    {0x3B, 0x82, 0x1E},
+    {0x3C, 0xC3, 0x1E},
+    {0x3D, 0x22, 0x1F},
+    {0x3E, 0x63, 0x1F},
+    {0x3F, 0xC1, 0x1F},
+    {0, 0, 0}
+};
+static void cx11646_fw(struct usb_spca50x *spca50x)
+{
+    __u8 val = 0;
+    int i = 0;
+    val = 0x02;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x006a, &val, 1);
+    while (cx11646_fw1[i][1]) {
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x006b, cx11646_fw1[i],
+			3);
+	i++;
+    }
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x006a, &val, 1);
+}
+static __u8 cxsensor[] = {
+    0x88, 0x12, 0x70, 0x01,
+    0x88, 0x0d, 0x02, 0x01,
+    0x88, 0x0f, 0x00, 0x01,
+    0x88, 0x03, 0x71, 0x01, 0x88, 0x04, 0x00, 0x01,	//3
+    0x88, 0x02, 0x10, 0x01,
+    0x88, 0x00, 0xD4, 0x01, 0x88, 0x01, 0x01, 0x01,	//5
+    0x88, 0x0B, 0x00, 0x01,
+    0x88, 0x0A, 0x0A, 0x01,
+    0x88, 0x00, 0x08, 0x01, 0x88, 0x01, 0x00, 0x01,	//8
+    0x88, 0x05, 0x01, 0x01,
+    0xA1, 0x18, 0x00, 0x01,
+    0x00
+};
+static __u8 reg20[] = { 0x10, 0x42, 0x81, 0x19, 0xd3, 0xff, 0xa7, 0xff };
+static __u8 reg28[] = { 0x87, 0x00, 0x87, 0x00, 0x8f, 0xff, 0xea, 0xff };
+static __u8 reg10[] = { 0xb1, 0xb1 };
+static __u8 reg71a[] = { 0x08, 0x18, 0x0a, 0x1e };	// 640
+static __u8 reg71b[] = { 0x04, 0x0c, 0x05, 0x0f };	// 352{0x04,0x0a,0x06,0x12}; //352{0x05,0x0e,0x06,0x11}; //352
+static __u8 reg71c[] = { 0x02, 0x07, 0x03, 0x09 };	// 320{0x04,0x0c,0x05,0x0f}; //320
+static __u8 reg71d[] = { 0x02, 0x07, 0x03, 0x09 };	// 176
+static __u8 reg71e[] = { 0x02, 0x07, 0x03, 0x09 };	// 160
+static __u8 reg7b[] = { 0x00, 0xff, 0x00, 0xff, 0x00, 0xff };
+
+static void cx_sensor(struct usb_spca50x *spca50x)
+{
+    __u8 val = 0;
+    int i = 0;
+    __u8 bufread[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+    int length = 0;
+    __u8 *ptsensor = cxsensor;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0020, reg20, 8);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0028, reg28, 8);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, reg10, 8);
+    val = 0x03;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0092, &val, 1);
+    PDEBUG(3, "spca50x->mode cx11646 %d", spca50x->mode);
+    switch (spca50x->mode) {
+    case 0:
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0071, reg71a, 4);
+	break;
+    case 1:
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0071, reg71b, 4);
+	break;
+    case 2:
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0071, reg71c, 4);
+	break;
+    case 3:
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0071, reg71d, 4);
+	break;
+    case 4:
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0071, reg71e, 4);
+	break;
+    default:
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0071, reg71c, 4);
+	break;
+    }
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x007b, reg7b, 6);
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00f8, &val, 1);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, reg10, 8);
+    val = 0x41;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0098, &val, 1);
+    for (i = 0; i < 11; i++) {
+	if ((i == 3) || (i == 5) || (i == 8)) {
+	    length = 8;
+	} else {
+	    length = 4;
+	}
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5, ptsensor,
+			length);
+	if (length == 4) {
+	    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, &val, 1);
+	} else {
+	    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, bufread,
+			   length);
+	}
+	ptsensor += length;
+    }
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e7, bufread, 8);
+}
+static __u8 cx_inits_160[] = {
+    0x81, 0x81, 0xa0, 0x00, 0x78, 0x00, 0x04, 0x01,
+    0x00, 0x01, 0x01, 0x01, 0x10, 0x00, 0x04, 0x01,
+    0x65, 0x45, 0x13, 0x1a, 0x2c, 0xdf, 0xb9, 0x81,
+    0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+    0xe2, 0xff, 0xf1, 0xff, 0xc2, 0xff, 0xbc, 0xff,
+    0xf5, 0xff, 0x6b, 0xff, 0xf2, 0x01, 0x43, 0x02,
+    0xe4, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static __u8 cx_inits_176[] = {
+    0x33, 0x81, 0xB0, 0x00, 0x90, 0x00, 0x0A, 0x03,	//176x144
+    0x00, 0x03, 0x03, 0x03, 0x1B, 0x05, 0x30, 0x03,
+    0x65, 0x15, 0x18, 0x25, 0x03, 0x25, 0x08, 0x30,
+    0x3B, 0x25, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00,
+    0xDC, 0xFF, 0xEE, 0xFF, 0xC5, 0xFF, 0xBF, 0xFF,
+    0xF7, 0xFF, 0x88, 0xFF, 0x66, 0x02, 0x28, 0x02,
+    0x1E, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static __u8 cx_inits_320[] = {
+    0x7f, 0x7f, 0x40, 0x01, 0xf0, 0x00, 0x02, 0x01,
+    0x00, 0x01, 0x01, 0x01, 0x10, 0x00, 0x02, 0x01,
+    0x65, 0x45, 0xfa, 0x4c, 0x2c, 0xdf, 0xb9, 0x81,
+    0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+    0xe2, 0xff, 0xf1, 0xff, 0xc2, 0xff, 0xbc, 0xff,
+    0xf5, 0xff, 0x6d, 0xff, 0xf6, 0x01, 0x43, 0x02,
+    0xd3, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static __u8 cx_inits_352[] = {
+    0x2e, 0x7c, 0x60, 0x01, 0x20, 0x01, 0x05, 0x03,
+    0x00, 0x06, 0x03, 0x06, 0x1b, 0x10, 0x05, 0x3b,
+    0x30, 0x25, 0x18, 0x25, 0x08, 0x30, 0x03, 0x25,
+    0x3b, 0x30, 0x25, 0x1b, 0x10, 0x05, 0x00, 0x00,
+    0xe3, 0xff, 0xf1, 0xff, 0xc2, 0xff, 0xbc, 0xff,
+    0xf5, 0xff, 0x6b, 0xff, 0xee, 0x01, 0x43, 0x02,
+    0xe4, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static __u8 cx_inits_640[] = {
+    0x7e, 0x7e, 0x80, 0x02, 0xe0, 0x01, 0x01, 0x01,
+    0x00, 0x02, 0x01, 0x02, 0x10, 0x30, 0x01, 0x01,
+    0x65, 0x45, 0xf7, 0x52, 0x2c, 0xdf, 0xb9, 0x81,
+    0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+    0xe2, 0xff, 0xf1, 0xff, 0xc2, 0xff, 0xbc, 0xff,
+    0xf6, 0xff, 0x7b, 0xff, 0x01, 0x02, 0x43, 0x02,
+    0x77, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static int cx11646_initsize(struct usb_spca50x *spca50x)
+{
+    int i;
+    __u8 reg12[] = { 0x08, 0x05, 0x07, 0x04, 0x24 };
+    __u8 reg17[] = { 0x0a, 0x00, 0xf2, 0x01, 0x0f, 0x00, 0x97, 0x02 };
+    __u8 *cxinit;
+    __u8 val = 0;
+    switch (spca50x->mode) {
+    case 0:
+	cxinit = cx_inits_640;
+	break;
+    case 1:
+	cxinit = cx_inits_352;
+	break;
+    case 2:
+	cxinit = cx_inits_320;
+	break;
+    case 3:
+	cxinit = cx_inits_176;
+	break;
+    case 4:
+	cxinit = cx_inits_160;
+	break;
+    default:
+	cxinit = cx_inits_320;
+	break;
+    }
+    val = 0x01;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x009a, &val, 1);
+    val = 0x10;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, &val, 1);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0012, reg12, 5);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0017, reg17, 8);
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c0, &val, 1);
+    val = 0x04;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c1, &val, 1);
+    val = 0x04;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c2, &val, 1);
+    for (i = 0; i < 7; i++) {
+	switch (i) {
+	case 0:
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0061, cxinit, 8);
+	    break;
+	case 1:
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00ca, cxinit, 8);
+	    break;
+	case 2:
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00d2, cxinit, 8);
+	    break;
+	case 3:
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00da, cxinit, 6);
+	    break;
+	case 4:
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0041, cxinit, 8);
+	    break;
+	case 5:
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0049, cxinit, 8);
+	    break;
+	case 6:
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0051, cxinit, 2);
+	    break;
+	}
+	if (i < 6)
+	    cxinit += 8;	//surf trought the table
+    }
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0010, &val, 1);
+    return (int) val;
+}
+
+static __u8 cx_jpeg_init[][8] = {
+    {0xFF, 0xD8, 0xFF, 0xDB, 0x00, 0x84, 0x00, 0x15},	// 1
+    {0x0F, 0x10, 0x12, 0x10, 0x0D, 0x15, 0x12, 0x11},
+    {0x12, 0x18, 0x16, 0x15, 0x19, 0x20, 0x35, 0x22},
+    {0x20, 0x1D, 0x1D, 0x20, 0x41, 0x2E, 0x31, 0x26},
+    {0x35, 0x4D, 0x43, 0x51, 0x4F, 0x4B, 0x43, 0x4A},
+    {0x49, 0x55, 0x5F, 0x79, 0x67, 0x55, 0x5A, 0x73},
+    {0x5B, 0x49, 0x4A, 0x6A, 0x90, 0x6B, 0x73, 0x7D},
+    {0x81, 0x88, 0x89, 0x88, 0x52, 0x66, 0x95, 0xA0},
+    {0x94, 0x84, 0x9E, 0x79, 0x85, 0x88, 0x83, 0x01},
+    {0x15, 0x0F, 0x10, 0x12, 0x10, 0x0D, 0x15, 0x12},
+    {0x11, 0x12, 0x18, 0x16, 0x15, 0x19, 0x20, 0x35},
+    {0x22, 0x20, 0x1D, 0x1D, 0x20, 0x41, 0x2E, 0x31},
+    {0x26, 0x35, 0x4D, 0x43, 0x51, 0x4F, 0x4B, 0x43},
+    {0x4A, 0x49, 0x55, 0x5F, 0x79, 0x67, 0x55, 0x5A},
+    {0x73, 0x5B, 0x49, 0x4A, 0x6A, 0x90, 0x6B, 0x73},
+    {0x7D, 0x81, 0x88, 0x89, 0x88, 0x52, 0x66, 0x95},
+    {0xA0, 0x94, 0x84, 0x9E, 0x79, 0x85, 0x88, 0x83},
+    {0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05},
+    {0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02},
+    {0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A},
+    {0x0B, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01},
+    {0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05},
+    {0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00},
+    {0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05},
+    {0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01},
+    {0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21},
+    {0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22},
+    {0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08, 0x23},
+    {0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24},
+    {0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17},
+    {0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29},
+    {0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A},
+    {0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A},
+    {0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A},
+    {0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A},
+    {0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A},
+    {0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A},
+    {0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99},
+    {0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8},
+    {0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7},
+    {0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6},
+    {0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5},
+    {0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3},
+    {0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1},
+    {0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9},
+    {0xFA, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04},
+    {0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01},
+    {0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04},
+    {0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07},
+    {0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14},
+    {0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33},
+    {0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16},
+    {0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19},
+    {0x1A, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x35, 0x36},
+    {0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46},
+    {0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56},
+    {0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66},
+    {0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76},
+    {0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85},
+    {0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94},
+    {0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3},
+    {0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2},
+    {0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA},
+    {0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9},
+    {0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8},
+    {0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7},
+    {0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6},
+    {0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0x20, 0x00, 0x1F},
+    {0x02, 0x0C, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00},
+    {0x00, 0x00, 0x11, 0x00, 0x11, 0x22, 0x00, 0x22},
+    {0x22, 0x11, 0x22, 0x22, 0x11, 0x33, 0x33, 0x11},
+    {0x44, 0x66, 0x22, 0x55, 0x66, 0xFF, 0xDD, 0x00},
+    {0x04, 0x00, 0x14, 0xFF, 0xC0, 0x00, 0x11, 0x08},
+    {0x00, 0xF0, 0x01, 0x40, 0x03, 0x00, 0x21, 0x00},
+    {0x01, 0x11, 0x01, 0x02, 0x11, 0x01, 0xFF, 0xDA},
+    {0x00, 0x0C, 0x03, 0x00, 0x00, 0x01, 0x11, 0x02},
+    {0x11, 0x00, 0x3F, 0x00, 0xFF, 0xD9, 0x00, 0x00}	//79
+};
+
+
+static __u8 cxjpeg_640[][8] = {
+    {0xFF, 0xD8, 0xFF, 0xDB, 0x00, 0x84, 0x00, 0x10},	//1
+    {0x0B, 0x0C, 0x0E, 0x0C, 0x0A, 0x10, 0x0E, 0x0D},
+    {0x0E, 0x12, 0x11, 0x10, 0x13, 0x18, 0x28, 0x1A},
+    {0x18, 0x16, 0x16, 0x18, 0x31, 0x23, 0x25, 0x1D},
+    {0x28, 0x3A, 0x33, 0x3D, 0x3C, 0x39, 0x33, 0x38},
+    {0x37, 0x40, 0x48, 0x5C, 0x4E, 0x40, 0x44, 0x57},
+    {0x45, 0x37, 0x38, 0x50, 0x6D, 0x51, 0x57, 0x5F},
+    {0x62, 0x67, 0x68, 0x67, 0x3E, 0x4D, 0x71, 0x79},
+    {0x70, 0x64, 0x78, 0x5C, 0x65, 0x67, 0x63, 0x01},
+    {0x10, 0x0B, 0x0C, 0x0E, 0x0C, 0x0A, 0x10, 0x0E},
+    {0x0D, 0x0E, 0x12, 0x11, 0x10, 0x13, 0x18, 0x28},
+    {0x1A, 0x18, 0x16, 0x16, 0x18, 0x31, 0x23, 0x25},
+    {0x1D, 0x28, 0x3A, 0x33, 0x3D, 0x3C, 0x39, 0x33},
+    {0x38, 0x37, 0x40, 0x48, 0x5C, 0x4E, 0x40, 0x44},
+    {0x57, 0x45, 0x37, 0x38, 0x50, 0x6D, 0x51, 0x57},
+    {0x5F, 0x62, 0x67, 0x68, 0x67, 0x3E, 0x4D, 0x71},
+    {0x79, 0x70, 0x64, 0x78, 0x5C, 0x65, 0x67, 0x63},
+    {0xFF, 0x20, 0x00, 0x1F, 0x00, 0x83, 0x00, 0x00},
+    {0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00},
+    {0x11, 0x22, 0x00, 0x22, 0x22, 0x11, 0x22, 0x22},
+    {0x11, 0x33, 0x33, 0x11, 0x44, 0x66, 0x22, 0x55},
+    {0x66, 0xFF, 0xDD, 0x00, 0x04, 0x00, 0x28, 0xFF},
+    {0xC0, 0x00, 0x11, 0x08, 0x01, 0xE0, 0x02, 0x80},
+    {0x03, 0x00, 0x21, 0x00, 0x01, 0x11, 0x01, 0x02},
+    {0x11, 0x01, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x00},
+    {0x00, 0x01, 0x11, 0x02, 0x11, 0x00, 0x3F, 0x00},
+    {0xFF, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}	//27
+};
+static __u8 cxjpeg_352[][8] = {
+    {0xFF, 0xD8, 0xFF, 0xDB, 0x00, 0x84, 0x00, 0x0D},
+    {0x09, 0x09, 0x0B, 0x09, 0x08, 0x0D, 0x0B, 0x0A},
+    {0x0B, 0x0E, 0x0D, 0x0D, 0x0F, 0x13, 0x1F, 0x14},
+    {0x13, 0x11, 0x11, 0x13, 0x26, 0x1B, 0x1D, 0x17},
+    {0x1F, 0x2D, 0x28, 0x30, 0x2F, 0x2D, 0x28, 0x2C},
+    {0x2B, 0x32, 0x38, 0x48, 0x3D, 0x32, 0x35, 0x44},
+    {0x36, 0x2B, 0x2C, 0x3F, 0x55, 0x3F, 0x44, 0x4A},
+    {0x4D, 0x50, 0x51, 0x50, 0x30, 0x3C, 0x58, 0x5F},
+    {0x58, 0x4E, 0x5E, 0x48, 0x4F, 0x50, 0x4D, 0x01},
+    {0x0D, 0x09, 0x09, 0x0B, 0x09, 0x08, 0x0D, 0x0B},
+    {0x0A, 0x0B, 0x0E, 0x0D, 0x0D, 0x0F, 0x13, 0x1F},
+    {0x14, 0x13, 0x11, 0x11, 0x13, 0x26, 0x1B, 0x1D},
+    {0x17, 0x1F, 0x2D, 0x28, 0x30, 0x2F, 0x2D, 0x28},
+    {0x2C, 0x2B, 0x32, 0x38, 0x48, 0x3D, 0x32, 0x35},
+    {0x44, 0x36, 0x2B, 0x2C, 0x3F, 0x55, 0x3F, 0x44},
+    {0x4A, 0x4D, 0x50, 0x51, 0x50, 0x30, 0x3C, 0x58},
+    {0x5F, 0x58, 0x4E, 0x5E, 0x48, 0x4F, 0x50, 0x4D},
+    {0xFF, 0x20, 0x00, 0x1F, 0x01, 0x83, 0x00, 0x00},
+    {0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00},
+    {0x11, 0x22, 0x00, 0x22, 0x22, 0x11, 0x22, 0x22},
+    {0x11, 0x33, 0x33, 0x11, 0x44, 0x66, 0x22, 0x55},
+    {0x66, 0xFF, 0xDD, 0x00, 0x04, 0x00, 0x16, 0xFF},
+    {0xC0, 0x00, 0x11, 0x08, 0x01, 0x20, 0x01, 0x60},
+    {0x03, 0x00, 0x21, 0x00, 0x01, 0x11, 0x01, 0x02},
+    {0x11, 0x01, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x00},
+    {0x00, 0x01, 0x11, 0x02, 0x11, 0x00, 0x3F, 0x00},
+    {0xFF, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+};
+static __u8 cxjpeg_320[][8] = {
+    {0xFF, 0xD8, 0xFF, 0xDB, 0x00, 0x84, 0x00, 0x05},
+    {0x03, 0x04, 0x04, 0x04, 0x03, 0x05, 0x04, 0x04},
+    {0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0C, 0x08},
+    {0x07, 0x07, 0x07, 0x07, 0x0F, 0x0B, 0x0B, 0x09},
+    {0x0C, 0x11, 0x0F, 0x12, 0x12, 0x11, 0x0F, 0x11},
+    {0x11, 0x13, 0x16, 0x1C, 0x17, 0x13, 0x14, 0x1A},
+    {0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1A, 0x1D},
+    {0x1D, 0x1F, 0x1F, 0x1F, 0x13, 0x17, 0x22, 0x24},
+    {0x22, 0x1E, 0x24, 0x1C, 0x1E, 0x1F, 0x1E, 0x01},
+    {0x05, 0x03, 0x04, 0x04, 0x04, 0x03, 0x05, 0x04},
+    {0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0C},
+    {0x08, 0x07, 0x07, 0x07, 0x07, 0x0F, 0x0B, 0x0B},
+    {0x09, 0x0C, 0x11, 0x0F, 0x12, 0x12, 0x11, 0x0F},
+    {0x11, 0x11, 0x13, 0x16, 0x1C, 0x17, 0x13, 0x14},
+    {0x1A, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1A},
+    {0x1D, 0x1D, 0x1F, 0x1F, 0x1F, 0x13, 0x17, 0x22},
+    {0x24, 0x22, 0x1E, 0x24, 0x1C, 0x1E, 0x1F, 0x1E},
+    {0xFF, 0x20, 0x00, 0x1F, 0x02, 0x0C, 0x00, 0x00},
+    {0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00},
+    {0x11, 0x22, 0x00, 0x22, 0x22, 0x11, 0x22, 0x22},
+    {0x11, 0x33, 0x33, 0x11, 0x44, 0x66, 0x22, 0x55},
+    {0x66, 0xFF, 0xDD, 0x00, 0x04, 0x00, 0x14, 0xFF},
+    {0xC0, 0x00, 0x11, 0x08, 0x00, 0xF0, 0x01, 0x40},
+    {0x03, 0x00, 0x21, 0x00, 0x01, 0x11, 0x01, 0x02},
+    {0x11, 0x01, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x00},
+    {0x00, 0x01, 0x11, 0x02, 0x11, 0x00, 0x3F, 0x00},
+    {0xFF, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}	//27
+};
+static __u8 cxjpeg_176[][8] = {
+    {0xFF, 0xD8, 0xFF, 0xDB, 0x00, 0x84, 0x00, 0x0D},
+    {0x09, 0x09, 0x0B, 0x09, 0x08, 0x0D, 0x0B, 0x0A},
+    {0x0B, 0x0E, 0x0D, 0x0D, 0x0F, 0x13, 0x1F, 0x14},
+    {0x13, 0x11, 0x11, 0x13, 0x26, 0x1B, 0x1D, 0x17},
+    {0x1F, 0x2D, 0x28, 0x30, 0x2F, 0x2D, 0x28, 0x2C},
+    {0x2B, 0x32, 0x38, 0x48, 0x3D, 0x32, 0x35, 0x44},
+    {0x36, 0x2B, 0x2C, 0x3F, 0x55, 0x3F, 0x44, 0x4A},
+    {0x4D, 0x50, 0x51, 0x50, 0x30, 0x3C, 0x58, 0x5F},
+    {0x58, 0x4E, 0x5E, 0x48, 0x4F, 0x50, 0x4D, 0x01},
+    {0x0D, 0x09, 0x09, 0x0B, 0x09, 0x08, 0x0D, 0x0B},
+    {0x0A, 0x0B, 0x0E, 0x0D, 0x0D, 0x0F, 0x13, 0x1F},
+    {0x14, 0x13, 0x11, 0x11, 0x13, 0x26, 0x1B, 0x1D},
+    {0x17, 0x1F, 0x2D, 0x28, 0x30, 0x2F, 0x2D, 0x28},
+    {0x2C, 0x2B, 0x32, 0x38, 0x48, 0x3D, 0x32, 0x35},
+    {0x44, 0x36, 0x2B, 0x2C, 0x3F, 0x55, 0x3F, 0x44},
+    {0x4A, 0x4D, 0x50, 0x51, 0x50, 0x30, 0x3C, 0x58},
+    {0x5F, 0x58, 0x4E, 0x5E, 0x48, 0x4F, 0x50, 0x4D},
+    {0xFF, 0x20, 0x00, 0x1F, 0x03, 0xA1, 0x00, 0x00},
+    {0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00},
+    {0x11, 0x22, 0x00, 0x22, 0x22, 0x11, 0x22, 0x22},
+    {0x11, 0x33, 0x33, 0x11, 0x44, 0x66, 0x22, 0x55},
+    {0x66, 0xFF, 0xDD, 0x00, 0x04, 0x00, 0x0B, 0xFF},
+    {0xC0, 0x00, 0x11, 0x08, 0x00, 0x90, 0x00, 0xB0},
+    {0x03, 0x00, 0x21, 0x00, 0x01, 0x11, 0x01, 0x02},
+    {0x11, 0x01, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x00},
+    {0x00, 0x01, 0x11, 0x02, 0x11, 0x00, 0x3F, 0x00},
+    {0xFF, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+};
+static __u8 cxjpeg_160[][8] = {
+    {0xFF, 0xD8, 0xFF, 0xDB, 0x00, 0x84, 0x00, 0x0D},	//1
+    {0x09, 0x09, 0x0B, 0x09, 0x08, 0x0D, 0x0B, 0x0A},
+    {0x0B, 0x0E, 0x0D, 0x0D, 0x0F, 0x13, 0x1F, 0x14},
+    {0x13, 0x11, 0x11, 0x13, 0x26, 0x1B, 0x1D, 0x17},
+    {0x1F, 0x2D, 0x28, 0x30, 0x2F, 0x2D, 0x28, 0x2C},
+    {0x2B, 0x32, 0x38, 0x48, 0x3D, 0x32, 0x35, 0x44},
+    {0x36, 0x2B, 0x2C, 0x3F, 0x55, 0x3F, 0x44, 0x4A},
+    {0x4D, 0x50, 0x51, 0x50, 0x30, 0x3C, 0x58, 0x5F},
+    {0x58, 0x4E, 0x5E, 0x48, 0x4F, 0x50, 0x4D, 0x01},
+    {0x0D, 0x09, 0x09, 0x0B, 0x09, 0x08, 0x0D, 0x0B},
+    {0x0A, 0x0B, 0x0E, 0x0D, 0x0D, 0x0F, 0x13, 0x1F},
+    {0x14, 0x13, 0x11, 0x11, 0x13, 0x26, 0x1B, 0x1D},
+    {0x17, 0x1F, 0x2D, 0x28, 0x30, 0x2F, 0x2D, 0x28},
+    {0x2C, 0x2B, 0x32, 0x38, 0x48, 0x3D, 0x32, 0x35},
+    {0x44, 0x36, 0x2B, 0x2C, 0x3F, 0x55, 0x3F, 0x44},
+    {0x4A, 0x4D, 0x50, 0x51, 0x50, 0x30, 0x3C, 0x58},
+    {0x5F, 0x58, 0x4E, 0x5E, 0x48, 0x4F, 0x50, 0x4D},
+    {0xFF, 0x20, 0x00, 0x1F, 0x03, 0xB1, 0x00, 0x00},
+    {0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00},
+    {0x11, 0x22, 0x00, 0x22, 0x22, 0x11, 0x22, 0x22},
+    {0x11, 0x33, 0x33, 0x11, 0x44, 0x66, 0x22, 0x55},
+    {0x66, 0xFF, 0xDD, 0x00, 0x04, 0x00, 0x0A, 0xFF},
+    {0xC0, 0x00, 0x11, 0x08, 0x00, 0x78, 0x00, 0xA0},
+    {0x03, 0x00, 0x21, 0x00, 0x01, 0x11, 0x01, 0x02},
+    {0x11, 0x01, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x00},
+    {0x00, 0x01, 0x11, 0x02, 0x11, 0x00, 0x3F, 0x00},
+    {0xFF, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}	//27
+};
+
+static __u8 cxjpeg_qtable[][8] = {	// 640 take with the zcx30x part
+    {0xff, 0xd8, 0xff, 0xdb, 0x00, 0x84, 0x00, 0x08},
+    {0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07},
+    {0x07, 0x09, 0x09, 0x08, 0x0a, 0x0c, 0x14, 0x0a},
+    {0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12, 0x13, 0x0f},
+    {0x14, 0x1d, 0x1a, 0x1f, 0x1e, 0x1d, 0x1a, 0x1c},
+    {0x1c, 0x20, 0x24, 0x2e, 0x27, 0x20, 0x22, 0x2c},
+    {0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29, 0x2c, 0x30},
+    {0x31, 0x34, 0x34, 0x34, 0x1f, 0x27, 0x39, 0x3d},
+    {0x38, 0x32, 0x3c, 0x2e, 0x33, 0x34, 0x32, 0x01},
+    {0x09, 0x09, 0x09, 0x0c, 0x0b, 0x0c, 0x18, 0x0a},
+    {0x0a, 0x18, 0x32, 0x21, 0x1c, 0x21, 0x32, 0x32},
+    {0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32},
+    {0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32},
+    {0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32},
+    {0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32},
+    {0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32},
+    {0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32},
+    {0xFF, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}	//18
+};
+
+
+static void cx11646_jpegInit(struct usb_spca50x *spca50x)
+{
+    __u8 val = 0;
+    int i = 0;
+    int length = 8;
+    val = 0x01;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c0, &val, 1);
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c3, &val, 1);
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c0, &val, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0001, &val, 1);
+    for (i = 0; i < 79; i++) {
+	if (i == 78)
+	    length = 6;
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0008, cx_jpeg_init[i],
+			length);
+    }
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0002, &val, 1);
+    val = 0x14;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0055, &val, 1);
+}
+
+static __u8 reg12[] = { 0x0a, 0x05, 0x07, 0x04, 0x19 };
+static __u8 regE5_8[] = { 0x88, 0x00, 0xd4, 0x01, 0x88, 0x01, 0x01, 0x01 };
+static __u8 regE5a[] = { 0x88, 0x0a, 0x0c, 0x01 };
+static __u8 regE5b[] = { 0x88, 0x0b, 0x12, 0x01 };
+static __u8 regE5c[] = { 0x88, 0x05, 0x01, 0x01 };
+static __u8 reg51[] = { 0x77, 0x03 };
+static __u8 reg70 = 0x03;
+
+static void cx11646_jpeg(struct usb_spca50x *spca50x)
+{
+    __u8 val = 0;
+    int i = 0;
+    int length = 8;
+    __u8 Reg55 = 0x14;
+    __u8 bufread[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+    int retry = 50;
+
+    val = 0x01;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c0, &val, 1);
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c3, &val, 1);
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00c0, &val, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0001, &val, 1);
+    switch (spca50x->mode) {
+    case 0:
+	for (i = 0; i < 27; i++) {
+	    if (i == 26)
+		length = 2;
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0008,
+			    cxjpeg_640[i], length);
+	}
+	Reg55 = 0x28;
+	break;
+    case 1:
+	for (i = 0; i < 27; i++) {
+	    if (i == 26)
+		length = 2;
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0008,
+			    cxjpeg_352[i], length);
+	}
+	Reg55 = 0x16;
+	break;
+    case 2:
+	for (i = 0; i < 27; i++) {
+	    if (i == 26)
+		length = 2;
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0008,
+			    cxjpeg_320[i], length);
+	}
+	Reg55 = 0x14;
+	break;
+    case 3:
+	for (i = 0; i < 27; i++) {
+	    if (i == 26)
+		length = 2;
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0008,
+			    cxjpeg_176[i], length);
+	}
+	Reg55 = 0x0B;
+	break;
+    case 4:
+	for (i = 0; i < 27; i++) {
+	    if (i == 26)
+		length = 2;
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0008,
+			    cxjpeg_160[i], length);
+	}
+	Reg55 = 0x0A;
+	break;
+    default:
+	for (i = 0; i < 27; i++) {
+	    if (i == 26)
+		length = 2;
+	    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0008,
+			    cxjpeg_320[i], length);
+	}
+	Reg55 = 0x14;
+	break;
+    }
+
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0002, &val, 1);
+    val = Reg55;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0055, &val, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0002, &val, 1);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, reg10, 2);
+    val = 0x02;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0054, &val, 1);
+    val = 0x01;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0054, &val, 1);
+    val = 0x94;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0000, &val, 1);
+    val = 0xc0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0053, &val, 1);
+    val = 0xe1;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00fc, &val, 1);
+    val = 0x00;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0000, &val, 1);
+    // wait for completion 
+    while (retry--) {
+	spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0002, &val, 1);	// 0x07 until 0x00
+	if (val == 0x00)
+	    break;
+	val = 0x00;
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0053, &val, 1);
+    }
+    if (retry == 0)
+	PDEBUG(0, "Damned Errors sending jpeg Table");
+    // send the qtable now
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0001, &val, 1);	// -> 0x18
+    length = 8;
+    for (i = 0; i < 18; i++) {
+	if (i == 17)
+	    length = 2;
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0008, cxjpeg_qtable[i],
+			length);
+
+    }
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0002, &val, 1);	// 0x00
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0053, &val, 1);	// 0x00
+    val = 0x02;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0054, &val, 1);
+    val = 0x01;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0054, &val, 1);
+    val = 0x94;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0000, &val, 1);
+    val = 0xc0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0053, &val, 1);
+
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0038, &val, 1);	// 0x40
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x0038, &val, 1);	// 0x40
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x001f, &val, 1);	// 0x38
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0012, reg12, 5);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5, regE5_8, 8);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, bufread, 8);	// 
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5, regE5a, 4);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, &val, 1);	// 0x00
+    val = 0x01;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x009a, &val, 1);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5, regE5b, 4);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, &val, 1);	// 0x00
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5, regE5c, 4);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, &val, 1);	// 0x00
+
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0051, reg51, 2);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, reg10, 2);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0070, &reg70, 1);
+}
+
+static void cx_setcolors(struct usb_spca50x *spca50x)
+{
+// Nothing
+}
+static __u16 cx_getcontrast(struct usb_spca50x *spca50x)
+{
+   spca50x->contrast = 0x0c << 11;	// 0..0x1f
+return spca50x->contrast;
+}
+static __u16 cx_getcolors(struct usb_spca50x *spca50x)
+{
+   spca50x->colour = 0x03 << 13;	// 0..7
+return spca50x->colour;
+}
+static __u16 cx_getbrightness(struct usb_spca50x *spca50x)
+{
+/*FIXME hardcoded as we need to read register of the sensor */
+    spca50x->brightness = 0xD4 << 8;	// 0..256
+    spca50x->contrast = 0x0c << 11;	// 0..0x1f
+    spca50x->colour = 0x03 << 13;	// 0..7
+    return (0xD4 << 8);
+}
+static void cx_setbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 regE5cbx[] = { 0x88, 0x00, 0xd4, 0x01, 0x88, 0x01, 0x01, 0x01 };
+    __u8 reg51c[] = { 0x77, 0x03 };
+    __u8 bright = 0;
+    __u8 colors = 0;
+    __u8 val = 0;
+    __u8 bufread[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+    bright = (spca50x->brightness >> 8) & 0xff;
+    colors = (spca50x->colour >> 13) & 0x07;
+    regE5cbx[2] = bright;
+    reg51c[1] = colors;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5, regE5cbx, 8);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, bufread, 8);	//
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5, regE5c, 4);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, &val, 1);	// 0x00
+
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0051, reg51c, 2);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, reg10, 2);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0070, &reg70, 1);
+
+
+}
+static void cx_setcontrast(struct usb_spca50x *spca50x)
+{
+
+    __u8 regE5acx[] = { 0x88, 0x0a, 0x0c, 0x01 };	//seem MSB
+    //__u8 regE5bcx[]={0x88,0x0b,0x12,0x01}; // LSB
+    __u8 reg51c[] = { 0x77, 0x03 };
+    __u8 contrast = 0;
+    __u8 val = 0;
+    __u8 colors = 0;
+    colors = (spca50x->colour >> 13) & 0x07;
+    reg51c[1] = colors;
+    contrast = (spca50x->contrast >> 11) & 0x1f;
+    if (contrast < 10)
+	contrast = 10;
+    regE5acx[2] = contrast;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x00e5, regE5acx, 4);
+    spca5xxRegRead(spca50x->dev, 0x00, 0x00, 0x00e8, &val, 1);	// 0x00
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0051, reg51c, 2);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0010, reg10, 2);
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x00, 0x0070, &reg70, 1);
+
+}
+
diff -ruN linux-2.6.21/drivers/media/video/gspca/Etoms/et61xx51.h linux-2.6.21-gspca/drivers/media/video/gspca/Etoms/et61xx51.h
--- linux-2.6.21/drivers/media/video/gspca/Etoms/et61xx51.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Etoms/et61xx51.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,892 @@
+ /*************************************************************************** 
+# Etoms Et61x151 GPL Linux driver by Michel Xhaard (09/09/2004)
+# This driver is design for embedded Linux hardware but should work happy
+# on Linux host computer
+# Etoms compagnies did not provided any help and support
+# The Linux driver is made by reverse engeneering the usb protocol. 
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+#ifndef ET61XX51_H
+#define ET61XX51_H
+
+#define ETOMS_ALT_SIZE_1000   12
+
+#define ET_GPIO_DIR_CTRL 0x04	//Control IO bit[0..5] (0 in  1 out)
+#define ET_GPIO_OUT 0x05	// Only IO data
+#define ET_GPIO_IN 0x06		//Read Only IO data
+#define ET_RESET_ALL 0x03
+#define ET_ClCK 0x01
+#define ET_CTRL 0x02		//enable i2c OutClck Powerdown mode
+
+#define ET_COMP 0x12		//Compression register
+#define ET_MAXQt 0x13
+#define ET_MINQt 0x14
+#define ET_COMP_VAL0 0x02
+#define ET_COMP_VAL1 0x03
+
+#define ET_REG1d 0x1d
+#define ET_REG1e 0x1e
+#define ET_REG1f 0x1f
+#define ET_REG20 0x20
+#define ET_REG21 0x21
+#define ET_REG22 0x22
+#define ET_REG23 0x23
+#define ET_REG24 0x24
+#define ET_REG25 0x25
+// base registers for luma calculation
+#define ET_LUMA_CENTER 0x39
+
+#define ET_G_RED 0x4d
+#define ET_G_GREEN1 0x4e
+#define ET_G_BLUE 0x4f
+#define ET_G_GREEN2 0x50
+#define ET_G_GR_H 0x51
+#define ET_G_GB_H 0x52
+
+#define ET_O_RED 0x34
+#define ET_O_GREEN1 0x35
+#define ET_O_BLUE 0x36
+#define ET_O_GREEN2 0x37
+
+#define ET_SYNCHRO 0x68
+#define ET_STARTX 0x69
+#define ET_STARTY 0x6a
+#define ET_WIDTH_LOW 0x6b
+#define ET_HEIGTH_LOW 0x6c
+#define ET_W_H_HEIGTH 0x6d
+
+#define ET_REG6e 0x6e		//OBW
+#define ET_REG6f 0x6f		//OBW
+#define ET_REG70 0x70		//OBW_AWB
+#define ET_REG71 0x71		//OBW_AWB
+#define ET_REG72 0x72		//OBW_AWB
+#define ET_REG73 0x73		//Clkdelay ns
+#define ET_REG74 0x74		// test pattern
+#define ET_REG75 0x75		// test pattern
+
+#define ET_I2C_CLK 0x8c
+#define ET_PXL_CLK 0x60
+
+#define ET_I2C_BASE 0x89
+#define ET_I2C_COUNT 0x8a
+#define ET_I2C_PREFETCH 0x8b
+#define ET_I2C_REG 0x88
+#define ET_I2C_DATA7 0x87
+#define ET_I2C_DATA6 0x86
+#define ET_I2C_DATA5 0x85
+#define ET_I2C_DATA4 0x84
+#define ET_I2C_DATA3 0x83
+#define ET_I2C_DATA2 0x82
+#define ET_I2C_DATA1 0x81
+#define ET_I2C_DATA0 0x80
+
+
+#define PAS106_REG2 0x02	//pxlClk = systemClk/(reg2)
+#define PAS106_REG3 0x03	//line/frame H [11..4]
+#define PAS106_REG4 0x04	//line/frame L [3..0]
+#define PAS106_REG5 0x05	//exposure time line offset(default 5)
+#define PAS106_REG6 0x06	//exposure time pixel offset(default 6)
+#define PAS106_REG7 0x07	//signbit Dac (default 0)
+#define PAS106_REG9 0x09
+#define PAS106_REG0e 0x0e	//global gain [4..0](default 0x0e)
+#define PAS106_REG13 0x13	//end i2c write
+
+
+
+static __u8 GainRGBG[] = { 0x80, 0x80, 0x80, 0x80, 0x00, 0x00 };
+
+static __u8 I2c2[] = { 0x08, 0x08, 0x08, 0x08, 0x0d };
+
+static __u8 I2c3[] = { 0x12, 0x05 };
+
+static __u8 I2c4[] = { 0x41, 0x08 };
+
+/***************************************************************************/
+/*******************     Camera Interface       ***********************/
+static int Et_init(struct usb_spca50x *etx);
+static void Et_startCamera(struct usb_spca50x *etx);
+static void Et_stopCameraN(struct usb_spca50x *etx);
+static void Et_stopCamera0(struct usb_spca50x *etx);
+static void Et_setbrightness(struct usb_spca50x *etx);
+static __u16 Et_getbrightness(struct usb_spca50x *etx);
+static void Et_setcontrast(struct usb_spca50x *etx);
+static __u16 Et_getcontrast(struct usb_spca50x *etx);
+static void Et_setcolors(struct usb_spca50x *etx);
+static __u16 Et_getcolors(struct usb_spca50x *etx);
+static void Et_setAutobright(struct usb_spca50x *etx);
+static int Et_config(struct usb_spca50x *spca50x);
+static void Et_shutdown(struct usb_spca50x *spca50x);
+static void Et_setquality(struct usb_spca50x *spca50x);
+static int Et_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/*******************     Camera private  ******************************/
+static void Et_stopCamera0(struct usb_spca50x *etx){}
+static void Et_shutdown(struct usb_spca50x *spca50x){}
+static void Et_setquality(struct usb_spca50x *spca50x){}
+static __u8 Et_getgainG(struct usb_spca50x *etx);
+static void Et_setgainG(struct usb_spca50x *etx, __u8 gain);
+static int Et_i2cwrite(struct usb_device *dev, __u8 reg, __u8 * buffer,
+		       __u16 length, __u8 mode);
+static int Et_i2cread(struct usb_device *dev, __u8 reg, __u8 * buffer,
+		      __u16 length, __u8 mode);
+static int Et_WaitStatus(struct usb_device *dev);
+static int Et_videoOff(struct usb_device *dev);
+static int Et_videoOn(struct usb_device *dev);
+static void Et_init1(struct usb_spca50x *etx);
+/***************************************************************************/
+static struct cam_operation fet61x = {
+ 	.initialize = Et_init,
+	.configure = Et_config,
+	.start = Et_startCamera,
+	.stopN = Et_stopCameraN,
+	.stop0 = Et_stopCamera0,
+	.get_bright = Et_getbrightness,
+	.set_bright = Et_setbrightness,
+	.get_contrast = Et_getcontrast,
+	.set_contrast = Et_setcontrast,
+	.get_colors = Et_getcolors,
+	.set_colors = Et_setcolors,
+	.set_autobright = Et_setAutobright,
+	.set_quality = Et_setquality,
+	.cam_shutdown = Et_shutdown,
+	.sof_detect = Et_sofdetect,
+ };
+static int Et_i2cwrite(struct usb_device *dev, __u8 reg, __u8 * buffer,
+		       __u16 length, __u8 mode)
+{
+/* buffer should be [D0..D7] */
+    int i, j;
+    __u8 base = 0x40;		// sensor base for the pas106
+    __u8 ptchcount = 0;
+    ptchcount = (((length & 0x07) << 4) | (mode & 0x03));
+/* set the base address */
+    Et_RegWrite(dev, 0x0, 0x0, ET_I2C_BASE, &base, 1);
+/* set count and prefetch */
+    Et_RegWrite(dev, 0x0, 0x0, ET_I2C_COUNT, &ptchcount, 1);
+/* set the register base */
+    Et_RegWrite(dev, 0x0, 0x0, ET_I2C_REG, &reg, 1);
+    j = length - 1;
+    for (i = 0; i < length; i++) {
+	Et_RegWrite(dev, 0x0, 0x0, (ET_I2C_DATA0 + j), &buffer[j], 1);
+	j--;
+    }
+    return 0;
+}
+static int Et_i2cread(struct usb_device *dev, __u8 reg, __u8 * buffer,
+		      __u16 length, __u8 mode)
+{
+/* buffer should be [D0..D7] */
+    int i, j;
+    __u8 base = 0x40;		// sensor base for the pas106
+    __u8 ptchcount = 0;
+    __u8 prefetch = 0x02;
+    ptchcount = (((length & 0x07) << 4) | (mode & 0x03));
+/* set the base address */
+    Et_RegWrite(dev, 0x0, 0x0, ET_I2C_BASE, &base, 1);
+/* set count and prefetch */
+    Et_RegWrite(dev, 0x0, 0x0, ET_I2C_COUNT, &ptchcount, 1);
+/* set the register base */
+    Et_RegWrite(dev, 0x0, 0x0, ET_I2C_REG, &reg, 1);
+    Et_RegWrite(dev, 0x0, 0x0, ET_I2C_PREFETCH, &prefetch, 1);
+    prefetch = 0x00;
+    Et_RegWrite(dev, 0x0, 0x0, ET_I2C_PREFETCH, &prefetch, 1);
+    j = length - 1;
+    for (i = 0; i < length; i++) {
+	Et_RegRead(dev, 0x0, 0x0, (ET_I2C_DATA0 + j), &buffer[j], 1);
+	j--;
+    }
+    return 0;
+}
+static int Et_WaitStatus(struct usb_device *dev)
+{
+    __u8 bytereceived = 0;
+    int retry = 10;
+    while (retry--) {
+	Et_RegRead(dev, 0x0, 0x0, ET_ClCK, &bytereceived, 1);
+	if (bytereceived != 0)
+	    return 1;
+    }
+    return 0;
+}
+
+static int Et_videoOff(struct usb_device *dev)
+{
+    int err = -1;
+    __u8 stopvideo = 0;
+    Et_RegWrite(dev, 0x0, 0x0, ET_GPIO_OUT, &stopvideo, 1);
+    err = Et_WaitStatus(dev);
+    if (!err)
+	PDEBUG(5, "timeout Et_waitStatus VideoON");
+    return err;
+}
+
+static int Et_videoOn(struct usb_device *dev)
+{
+    int err = -1;
+    __u8 startvideo = 0x10;	//set Bit5
+    Et_RegWrite(dev, 0x0, 0x0, ET_GPIO_OUT, &startvideo, 1);
+    err = Et_WaitStatus(dev);
+    if (!err)
+	PDEBUG(5, "timeout Et_waitStatus VideoOFF");
+    return err;
+}
+static void Et_init2(struct usb_spca50x *etx)
+{
+    __u8 value = 0x00;
+    __u8 received = 0x00;
+    __u8 FormLine[] = { 0x84, 0x03, 0x14, 0xf4, 0x01, 0x05 };
+
+    PDEBUG(5, "Open Init2 ET");
+    value = 0x2f;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_GPIO_DIR_CTRL, &value, 1);
+    value = 0x10;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_GPIO_OUT, &value, 1);
+    Et_RegRead(etx->dev, 0x0, 0x0, ET_GPIO_IN, &received, 1);
+    value = 0x14;		//0x14 // 0x16 enabled pattern
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_ClCK, &value, 1);
+    value = 0x1b;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_CTRL, &value, 1);
+
+    /*   compression et subsampling */
+    if (etx->mode) {
+	value = ET_COMP_VAL1;	// 320
+
+    } else {
+	value = ET_COMP_VAL0;	// 640
+
+    }
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_COMP, &value, 1);
+    value = 0x1f;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_MAXQt, &value, 1);
+    value = 0x04;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_MINQt, &value, 1);
+    /* undocumented registers */
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG1d, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG1e, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG1f, &value, 1);
+    value = 0x35;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG20, &value, 1);
+    value = 0x01;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG21, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG22, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG23, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG24, &value, 1);
+    value = 0x0f;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG25, &value, 1);
+    /* colors setting */
+    value = 0x11;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x30, &value, 1);	//0x30
+    value = 0x40;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x31, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x32, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_O_RED, &value, 1);	//0x34
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_O_GREEN1, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_O_BLUE, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_O_GREEN2, &value, 1);
+	/*************/
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_RED, &value, 1);	//0x4d
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_GREEN1, &value, 1);
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_BLUE, &value, 1);
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_GREEN2, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_GR_H, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_GB_H, &value, 1);	//0x52
+    /* Window control registers */
+
+
+    value = 0x80;		/* use cmc_out */
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x61, &value, 1);
+
+
+    value = 0x02;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x62, &value, 1);
+    value = 0x03;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x63, &value, 1);
+    value = 0x14;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x64, &value, 1);
+    value = 0x0e;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x65, &value, 1);
+    value = 0x02;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x66, &value, 1);
+    value = 0x02;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x67, &value, 1);
+
+
+	/**************************************/
+    value = 0x8f;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_SYNCHRO, &value, 1);	//0x68
+    value = 0x69;		//0x6a //0x69
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_STARTX, &value, 1);
+    value = 0x0d;		//0x0d //0x0c
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_STARTY, &value, 1);
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_WIDTH_LOW, &value, 1);
+    value = 0xe0;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_HEIGTH_LOW, &value, 1);
+    value = 0x60;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_W_H_HEIGTH, &value, 1);	//6d
+    value = 0x86;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG6e, &value, 1);
+    value = 0x01;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG6f, &value, 1);
+    value = 0x26;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG70, &value, 1);
+    value = 0x7a;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG71, &value, 1);
+    value = 0x01;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG72, &value, 1);
+    /* Clock Pattern registers ***************** */
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG73, &value, 1);
+    value = 0x18;		//0x28
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG74, &value, 1);
+    value = 0x0f;		// 0x01
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG75, &value, 1);
+	/**********************************************/
+    value = 0x20;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x8a, &value, 1);
+    value = 0x0f;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x8d, &value, 1);
+    value = 0x08;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x8e, &value, 1);
+	/**************************************/
+    value = 0x08;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x03, &value, 1);
+    value = 0x03;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_PXL_CLK, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x81, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x80, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x81, &value, 1);
+    value = 0x20;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x80, &value, 1);
+    value = 0x01;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x03, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x03, &value, 1);
+    value = 0x08;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x03, &value, 1);
+	/********************************************/
+
+    // Et_RegRead(etx->dev,0x0,0x0,ET_I2C_BASE,&received,1); always 0x40 as the pas106 ???
+    /* set the sensor */
+    if (etx->mode) {		/* 320 */
+	value = 0x04;
+	Et_RegWrite(etx->dev, 0x0, 0x0, ET_PXL_CLK, &value, 1);
+	/* now set by fifo the FormatLine setting */
+	Et_RegWrite(etx->dev, 0x0, 0x0, 0x62, FormLine, 6);
+
+    } else {			/* 640 */
+	/* setting PixelClock 
+	   0x03 mean 24/(3+1) = 6 Mhz
+	   0x05 -> 24/(5+1) = 4 Mhz
+	   0x0b -> 24/(11+1) = 2 Mhz
+	   0x17 -> 24/(23+1) = 1 Mhz
+	 */
+	value = 0x1e;		//0x17
+	Et_RegWrite(etx->dev, 0x0, 0x0, ET_PXL_CLK, &value, 1);
+	/* now set by fifo the FormatLine setting */
+	Et_RegWrite(etx->dev, 0x0, 0x0, 0x62, FormLine, 6);
+
+    }
+
+    value = 0x47;		// 0x47;  
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x81, &value, 1);	// set exposure times [ 0..0x78] 0->longvalue 0x78->shortvalue
+    value = 0x40;		//  0x40;  
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x80, &value, 1);
+    /* Pedro change */
+    // Brightness change Brith+ decrease value 
+    // Brigth- increase value 
+    // original value = 0x70;
+    value = 0x30;		// 0x20; 
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x81, &value, 1);	// set brightness
+    value = 0x20;		// 0x20;
+    Et_RegWrite(etx->dev, 0x0, 0x0, 0x80, &value, 1);
+}
+
+
+static void Et_init1(struct usb_spca50x *etx)
+{
+    __u8 value = 0x00;
+    __u8 received = 0x00;
+    //__u8 I2c0 [] ={0x0a,0x12,0x05,0x22,0xac,0x00,0x01,0x00};
+    __u8 I2c0[] = { 0x0a, 0x12, 0x05, 0x6d, 0xcd, 0x00, 0x01, 0x00 };	// try 1/120 0x6d 0xcd 0x40
+    //__u8 I2c0 [] ={0x0a,0x12,0x05,0xfe,0xfe,0xc0,0x01,0x00}; // 1/60000 hmm ??
+    PDEBUG(5, "Open Init1 ET");
+
+    value = 7;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_GPIO_DIR_CTRL, &value, 1);
+    Et_RegRead(etx->dev, 0x0, 0x0, ET_GPIO_IN, &received, 1);
+    value = 1;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_RESET_ALL, &value, 1);
+    value = 0;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_RESET_ALL, &value, 1);
+    value = 0x10;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_ClCK, &value, 1);
+    value = 0x19;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_CTRL, &value, 1);
+    /*   compression et subsampling */
+    if (etx->mode) {
+	value = ET_COMP_VAL1;
+
+    } else {
+	value = ET_COMP_VAL0;
+    }
+    PDEBUG(0, "Open mode %d Compression %d", etx->mode, value);
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_COMP, &value, 1);
+    value = 0x1d;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_MAXQt, &value, 1);
+    value = 0x02;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_MINQt, &value, 1);
+    /* undocumented registers */
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG1d, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG1e, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG1f, &value, 1);
+    value = 0x35;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG20, &value, 1);
+    value = 0x01;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG21, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG22, &value, 1);
+    value = 0xf7;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG23, &value, 1);
+    value = 0xff;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG24, &value, 1);
+    value = 0x07;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG25, &value, 1);
+    /* colors setting */
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_RED, &value, 1);
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_GREEN1, &value, 1);
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_BLUE, &value, 1);
+    value = 0x80;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_GREEN2, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_GR_H, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_GB_H, &value, 1);
+    /* Window control registers */
+    value = 0xf0;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_SYNCHRO, &value, 1);
+    value = 0x56;		//0x56
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_STARTX, &value, 1);
+    value = 0x05;		//0x04
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_STARTY, &value, 1);
+    value = 0x60;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_WIDTH_LOW, &value, 1);
+    value = 0x20;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_HEIGTH_LOW, &value, 1);
+    value = 0x50;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_W_H_HEIGTH, &value, 1);
+    value = 0x86;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG6e, &value, 1);
+    value = 0x01;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG6f, &value, 1);
+    value = 0x86;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG70, &value, 1);
+    value = 0x14;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG71, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG72, &value, 1);
+    /* Clock Pattern registers */
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG73, &value, 1);
+    value = 0x00;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG74, &value, 1);
+    value = 0x0a;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_REG75, &value, 1);
+    value = 0x04;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_I2C_CLK, &value, 1);
+    value = 0x01;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_PXL_CLK, &value, 1);
+    /* set the sensor */
+    if (etx->mode) {
+	I2c0[0] = 0x06;
+	Et_i2cwrite(etx->dev, PAS106_REG2, I2c0, sizeof(I2c0), 1);
+	Et_i2cwrite(etx->dev, PAS106_REG9, I2c2, sizeof(I2c2), 1);
+	value = 0x06;
+	Et_i2cwrite(etx->dev, PAS106_REG2, &value, 1, 1);
+	Et_i2cwrite(etx->dev, PAS106_REG3, I2c3, sizeof(I2c3), 1);
+	//value = 0x1f;
+	value = 0x04;
+	Et_i2cwrite(etx->dev, PAS106_REG0e, &value, 1, 1);
+    } else {
+	I2c0[0] = 0x0a;
+
+	Et_i2cwrite(etx->dev, PAS106_REG2, I2c0, sizeof(I2c0), 1);
+	Et_i2cwrite(etx->dev, PAS106_REG9, I2c2, sizeof(I2c2), 1);
+	value = 0x0a;
+
+	Et_i2cwrite(etx->dev, PAS106_REG2, &value, 1, 1);
+	Et_i2cwrite(etx->dev, PAS106_REG3, I2c3, sizeof(I2c3), 1);
+	value = 0x04;
+	//value = 0x10;
+	Et_i2cwrite(etx->dev, PAS106_REG0e, &value, 1, 1);
+	/* bit 2 enable bit 1:2 select 0 1 2 3 
+	   value = 0x07;// curve 0
+	   Et_i2cwrite(etx->dev,PAS106_REG0f,&value,1,1);
+	 */
+    }
+
+    //value = 0x01;
+    //value = 0x22;
+    //Et_i2cwrite(etx->dev,PAS106_REG5,&value,1,1);
+    /* magnetude and sign bit for DAC */
+    Et_i2cwrite(etx->dev, PAS106_REG7, I2c4, sizeof(I2c4), 1);
+    /* now set by fifo the whole colors setting */
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_RED, GainRGBG, 6);
+    etx->colour = Et_getcolors(etx);
+    Et_setcolors(etx);
+}
+
+static int Et_init(struct usb_spca50x *etx)
+{
+    int err = -1;
+    __u8 value = 0x00;
+
+    PDEBUG(5, "Initialize ET1");
+    if (etx->desc == Etoms61x151) {
+	Et_init1(etx);
+    } else {
+	Et_init2(etx);
+    }
+    value = 0x08;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_RESET_ALL, &value, 1);
+    err = Et_videoOff(etx->dev);
+    PDEBUG(5, "Et_Init_VideoOff %d", err);
+    return 0;
+}
+
+static void Et_startCamera(struct usb_spca50x *etx)
+{
+    int err = -1;
+    __u8 value = 0x00;
+
+    if (etx->desc == Etoms61x151) {
+	Et_init1(etx);
+    } else {
+	Et_init2(etx);
+    }
+
+    value = 0x08;
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_RESET_ALL, &value, 1);
+    err = Et_videoOn(etx->dev);
+    PDEBUG(5, "Et_VideoOn %d", err);
+}
+
+static void Et_stopCameraN(struct usb_spca50x *etx)
+{
+    int err = -1;
+    err = Et_videoOff(etx->dev);
+    PDEBUG(5, "Et_VideoOff %d", err);
+
+}
+
+static void Et_setbrightness(struct usb_spca50x *etx)
+{
+    int i;
+    __u8 brightness = etx->brightness >> 9;
+    for (i = 0; i < 4; i++) {
+	Et_RegWrite(etx->dev, 0x0, 0x0, (ET_O_RED + i), &brightness, 1);
+    }
+}
+
+static __u16 Et_getbrightness(struct usb_spca50x *etx)
+{
+    int i;
+    int brightness = 0;
+    __u8 value = 0;
+    for (i = 0; i < 4; i++) {
+	Et_RegRead(etx->dev, 0x0, 0x0, (ET_O_RED + i), &value, 1);
+	brightness += value;
+    }
+    etx->brightness = (brightness << 6);
+    return etx->brightness;
+}
+
+static void Et_setcontrast(struct usb_spca50x *etx)
+{
+    __u8 RGBG[] = { 0x80, 0x80, 0x80, 0x80, 0x00, 0x00 };
+    __u8 contrast = etx->contrast >> 8;
+    memset(RGBG, contrast, sizeof(RGBG) - 2);
+    Et_RegWrite(etx->dev, 0x0, 0x0, ET_G_RED, RGBG, 6);
+}
+
+static __u16 Et_getcontrast(struct usb_spca50x *etx)
+{
+    int i;
+    int contrast = 0;
+    __u8 value = 0;
+    for (i = 0; i < 4; i++) {
+	Et_RegRead(etx->dev, 0x0, 0x0, (ET_G_RED + i), &value, 1);
+	contrast += value;
+    }
+    etx->contrast = (contrast << 6);
+    return etx->contrast;
+}
+
+static __u8 Et_getgainG(struct usb_spca50x *etx)
+{
+
+    __u8 value = 0;
+    if (etx->sensor == SENSOR_PAS106) {
+	Et_i2cread(etx->dev, PAS106_REG0e, &value, 1, 1);
+	PDEBUG(5, "Etoms gain G %d", value);
+	return value;
+    } else {
+	return 0x1f;
+    }
+}
+
+static void Et_setgainG(struct usb_spca50x *etx, __u8 gain)
+{
+
+    __u8 i2cflags = 0x01;
+    if (etx->sensor == SENSOR_PAS106) {
+	Et_i2cwrite(etx->dev, PAS106_REG13, &i2cflags, 1, 3);
+	Et_i2cwrite(etx->dev, PAS106_REG0e, &gain, 1, 1);
+#if 0
+	Et_i2cwrite(etx->dev, 0x09, &gain, 1, 1);
+	Et_i2cwrite(etx->dev, 0x0a, &gain, 1, 1);
+	Et_i2cwrite(etx->dev, 0x0b, &gain, 1, 1);
+	Et_i2cwrite(etx->dev, 0x0c, &gain, 1, 1);
+#endif
+    }
+
+}
+
+#define BLIMIT(bright) (__u8)((bright>0x1F)?0x1f:((bright<4)?3:bright))
+#define LIMIT(color) (unsigned char)((color>0xFF)?0xff:((color<0)?0:color))
+
+static void Et_setAutobright(struct usb_spca50x *etx)
+{
+    __u8 GRBG[] = { 0, 0, 0, 0 };
+    __u8 luma = 0;
+    __u8 luma_mean = 128;
+    __u8 luma_delta = 20;
+    __u8 spring = 4;
+    int Gbright = 0;
+    __u8 r, g, b;
+    Gbright = Et_getgainG(etx);
+    Et_RegRead(etx->dev, 0x0, 0x0, ET_LUMA_CENTER, GRBG, 4);
+    g = (GRBG[0] + GRBG[3]) >> 1;
+    r = GRBG[1];
+    b = GRBG[2];
+    r = ((r << 8) - (r << 4) - (r << 3)) >> 10;
+    b = ((b << 7) >> 10);
+    g = ((g << 9) + (g << 7) + (g << 5)) >> 10;
+    luma = LIMIT(r + g + b);
+    PDEBUG(5, "Etoms luma G %d", luma);
+    if ((luma < (luma_mean - luma_delta)) ||
+	(luma > (luma_mean + luma_delta))) {
+	Gbright += ((luma_mean - luma) >> spring);
+	Gbright = BLIMIT(Gbright);
+	PDEBUG(5, "Etoms Gbright %d", Gbright);
+	Et_setgainG(etx, (__u8) Gbright);
+    }
+}
+#undef BLIMIT
+#undef LIMIT
+
+static void Et_setcolors(struct usb_spca50x *etx)
+{
+
+    static __u8 I2cc[] = { 0x05, 0x02, 0x02, 0x05, 0x0d };
+    __u8 i2cflags = 0x01;
+    //__u8 green = 0;
+    __u8 colors = (etx->colour >> 12) & 0x0f;
+
+    I2cc[3] = colors;		//red
+    I2cc[0] = 15 - colors;	//blue     
+    // green = 15 - ((((7*I2cc[0]) >> 2 ) + I2cc[3]) >> 1);
+    // I2cc[1] = I2cc[2] = green;
+    if (etx->sensor == SENSOR_PAS106) {
+	Et_i2cwrite(etx->dev, PAS106_REG13, &i2cflags, 1, 3);
+	Et_i2cwrite(etx->dev, PAS106_REG9, I2cc, sizeof(I2cc), 1);
+    }
+    //PDEBUG(5 , "Etoms red %d blue %d green %d",I2cc[3],I2cc[0],green);
+}
+static __u16 Et_getcolors(struct usb_spca50x *etx)
+{
+
+    //__u8 valblue = 0;
+    __u8 valred = 0;
+    etx->colour = 0;
+    if (etx->sensor == SENSOR_PAS106) {
+	//Et_i2cread(etx->dev,PAS106_REG9,&valblue,1,1);
+	Et_i2cread(etx->dev, PAS106_REG9 + 3, &valred, 1, 1);
+	etx->colour = (((valred) & 0x0f) << 12);
+    }
+    return etx->colour;
+}
+static void set_EtxxVGA(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+#if 0
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1000;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 0;
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1000;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 0;
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1000;
+    spca50x->mode_cam[SIF].method = 1;
+    spca50x->mode_cam[SIF].mode = 0;
+#endif
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1000;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 1;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1000;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 1;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1000;
+    spca50x->mode_cam[QSIF].method = 1;
+    spca50x->mode_cam[QSIF].mode = 1;
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 1000;
+    spca50x->mode_cam[QCIF].method = 1;
+    spca50x->mode_cam[QCIF].mode = 1;
+}
+static void set_EtxxSIF(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1000;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 0;
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1000;
+    spca50x->mode_cam[CIF].method = 1;
+    spca50x->mode_cam[CIF].mode = 0;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1000;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 0;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1000;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 1;
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 1000;
+    spca50x->mode_cam[QCIF].method = 1;
+    spca50x->mode_cam[QCIF].mode = 1;
+}
+static int Et_config(struct usb_spca50x *spca50x)
+{
+    switch (spca50x->sensor) {
+    case SENSOR_TAS5130CXX:
+	set_EtxxVGA(spca50x);
+	break;
+    case SENSOR_PAS106:
+	set_EtxxSIF(spca50x);
+	break;
+    default:
+	return -EINVAL;
+	break;
+    }
+    return 0;
+}
+static int Et_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+int seqframe;
+		seqframe = cdata[0] & 0x3f;
+		*datalength = (int) (((cdata[0] & 0xc0) << 2) | cdata[1]);
+		if (seqframe == 0x3f) {
+		    PDEBUG(5,
+			   "Etoms header packet found datalength %d !!",
+			   *datalength);
+		    PDEBUG(5, "Etoms G %d R %d G %d B %d", cdata[2],
+			   cdata[3], cdata[4], cdata[5]);
+		    
+		    *iPix = 30;
+		    /* don't change datalength as the chips provided it */
+		    return 0;
+		} else {
+		    if (*datalength) {
+		    *iPix = 8;
+			return (seqnum+1);
+		    } else {
+			/* Drop Packet */
+			return -1;
+		    }
+		}
+}
+#endif				/* ET61XX51_H */
diff -ruN linux-2.6.21/drivers/media/video/gspca/Kconfig linux-2.6.21-gspca/drivers/media/video/gspca/Kconfig
--- linux-2.6.21/drivers/media/video/gspca/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Kconfig	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,25 @@
+config VIDEO_GSPCA
+	tristate "Gspca WebCams Driver"
+	depends on I2C && VIDEO_V4L2 && USB
+	---help---
+	  Say Y or M if you have a USB webcam with one this chips:
+  	   * Sunplus
+	   * Z-star/Vimicro
+	   * Sonix
+	   * Etoms
+	   * Conexant
+	   * Zoran
+	   * IcMedia/TransVision
+	   * Pixart
+
+	  To know if your webcam is compatible with this driver, check
+	  out this list: http://mxhaard.free.fr/spca5xx.html
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gspca.
+
+config VIDEO_GSPCA_DEBUG
+	bool "Enable debug mode"
+	depends on VIDEO_GSPCA
+	---help---
+	  This option enables debug mode for Gspca driver.
diff -ruN linux-2.6.21/drivers/media/video/gspca/Makefile linux-2.6.21-gspca/drivers/media/video/gspca/Makefile
--- linux-2.6.21/drivers/media/video/gspca/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Makefile	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,10 @@
+VERSION = 01.00.18
+
+gspca-objs := gspca_core.o decoder/gspcadecoder.o
+
+obj-$(CONFIG_VIDEO_GSPCA) += gspca.o
+
+EXTRA_CFLAGS += -DGSPCA_ENABLE_COMPRESSION
+EXTRA_CFLAGS += -DVID_HARDWARE_GSPCA=0xFF
+EXTRA_CFLAGS += -DGSPCA_VERSION=\"$(VERSION)\"
+
diff -ruN linux-2.6.21/drivers/media/video/gspca/Mars-Semi/mr97311.h linux-2.6.21-gspca/drivers/media/video/gspca/Mars-Semi/mr97311.h
--- linux-2.6.21/drivers/media/video/gspca/Mars-Semi/mr97311.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Mars-Semi/mr97311.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,540 @@
+/****************************************************************************
+#	 	Mars-Semi MR97311A library                                  #
+# 		Copyright (C) 2005 <bradlch@hotmail.com>                    #
+# Part of spca5xx project                                                   #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+static int mr97311_init(struct usb_spca50x *pcam);
+static void mr97311_start(struct usb_spca50x *pcam);
+static void mr97311_stopN(struct usb_spca50x *pcam);
+static void mr97311_stop0(struct usb_spca50x *pcam);
+static int mr97311_config(struct usb_spca50x *pcam);
+static __u16 mr97311_getbrightness(struct usb_spca50x *spca50x);
+static __u16 mr97311_getcontrast(struct usb_spca50x *spca50x);
+static __u16 mr97311_getcolors(struct usb_spca50x *spca50x);
+static void mr97311_setbrightness(struct usb_spca50x *spca50x);
+static void mr97311_setcontrast(struct usb_spca50x *spca50x);
+static void mr97311_setcolors(struct usb_spca50x *spca50x);
+static void mr97311_shutdown(struct usb_spca50x *spca50x);
+static void mr97311_setAutobright(struct usb_spca50x *spca50x);
+static void mr97311_setquality(struct usb_spca50x *spca50x);
+static int mr97311_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/*****************************************************************/
+static int mr97311_init(struct usb_spca50x *pcam){return 0;}
+static __u16 mr97311_getbrightness(struct usb_spca50x *spca50x){return 0;}
+static __u16 mr97311_getcontrast(struct usb_spca50x *spca50x){return 0;}
+static __u16 mr97311_getcolors(struct usb_spca50x *spca50x){return 0;}
+static void mr97311_setbrightness(struct usb_spca50x *spca50x){}
+static void mr97311_setcontrast(struct usb_spca50x *spca50x){}
+static void mr97311_setcolors(struct usb_spca50x *spca50x){}
+
+static void mr97311_shutdown(struct usb_spca50x *spca50x){}
+static void mr97311_setAutobright(struct usb_spca50x *spca50x){}
+static void mr97311_setquality(struct usb_spca50x *spca50x){}
+static void mr97311_stop0(struct usb_spca50x *pcam){}
+/****************************************************************/
+static struct cam_operation fmr97311 = {
+ 	.initialize = mr97311_init,
+	.configure = mr97311_config,
+	.start = mr97311_start,
+	.stopN = mr97311_stopN,
+	.stop0 = mr97311_stop0,
+	.get_bright = mr97311_getbrightness,
+	.set_bright = mr97311_setbrightness,
+	.get_contrast = mr97311_getcontrast,
+	.set_contrast = mr97311_setcontrast,
+	.get_colors = mr97311_getcolors,
+	.set_colors = mr97311_setcolors,
+	.set_autobright = mr97311_setAutobright,
+	.set_quality = mr97311_setquality,
+	.cam_shutdown = mr97311_shutdown,
+	.sof_detect = mr97311_sofdetect,
+ };
+static int pcam_reg_write(struct usb_device *dev,
+			  __u16 index, unsigned char *value, int length);
+
+static void MISensor_BulkWrite(struct usb_device *dev, unsigned short *pch,
+			       char Address, int length, char controlbyte);
+
+//MI Register table //elvis
+enum {
+    REG_HW_MI_0,
+    REG_HW_MI_1,
+    REG_HW_MI_2,
+    REG_HW_MI_3,
+    REG_HW_MI_4,
+    REG_HW_MI_5,
+    REG_HW_MI_6,
+    REG_HW_MI_7,
+    REG_HW_MI_9 = 0x09,
+    REG_HW_MI_B = 0x0B,
+    REG_HW_MI_C,
+    REG_HW_MI_D,
+    REG_HW_MI_1E = 0x1E,
+    REG_HW_MI_20 = 0x20,
+    REG_HW_MI_2B = 0x2B,
+    REG_HW_MI_2C,
+    REG_HW_MI_2D,
+    REG_HW_MI_2E,
+    REG_HW_MI_35 = 0x35,
+    REG_HW_MI_5F = 0x5F,
+    REG_HW_MI_60,
+    REG_HW_MI_61,
+    REG_HW_MI_62,
+    REG_HW_MI_63,
+    REG_HW_MI_64,
+    REG_HW_MI_F1 = 0xF1,
+    ATTR_TOTAL_MI_REG = 242
+};
+static void mr97311_stopN(struct usb_spca50x *pcam)
+{
+    int result;
+    char data[2];
+    memset(data, 0, 2);
+    data[0] = 1;
+    data[1] = 0;
+    result = pcam_reg_write(pcam->dev, data[0], data, 2);
+    if (result < 0)
+	printk("Camera Stop failed \n");
+
+}
+static int pcam_reg_write(struct usb_device *dev,
+			  __u16 index, unsigned char *value, int length)
+{
+    unsigned char buf[12];
+    int rc;
+    int i;
+    unsigned char index_value = 0;
+
+    memset(buf, 0, sizeof(buf));
+
+    for (i = 0; i < length; i++)
+	buf[i] = value[i];
+
+    rc = usb_control_msg(dev,
+			 usb_sndbulkpipe(dev, 4),
+			 0x12,
+			 0xc8, index_value, index, value, length, 5 * HZ);
+
+    PDEBUG(1, "reg write: 0x%02X , result = 0x%x \n", index, rc);
+
+    if (rc < 0) {
+	PDEBUG(1, "reg write: error %d \n", rc);
+    }
+    return rc;
+}
+
+static void mr97311_start(struct usb_spca50x *pcam)
+{
+    int err_code;
+    unsigned char data[242];
+    unsigned short MI_buf[242];
+    int h_size, v_size;
+    int intpipe;
+    //struct usb_device *dev = pcam->dev;
+    memset(data, 0, 242);
+    memset(MI_buf, 0, 242);
+
+    PDEBUG(1,
+	   "usb_set_interface in pcamCameraStart , interface %d , alt 8 \n",
+	   pcam->iface);
+    if (usb_set_interface(pcam->dev, pcam->iface, 8) < 0) {
+	err("Set packet size: set interface error");
+	return ;
+    }
+
+    data[0] = 0x01;		//address
+    data[1] = 0x01;
+
+    err_code = pcam_reg_write(pcam->dev, data[0], data, 0x02);
+    if (err_code < 0) {
+	printk("Register write failed \n");
+	return ;
+    }
+
+
+    /*
+       Initialize the MR97113 chip register
+     */
+
+    data[0] = 0x00;		//address
+    data[1] = 0x0c | 0x01;	//reg 0
+    data[2] = 0x01;		//reg 1
+
+    switch (pcam->width) {
+    case 1280:
+	h_size = 1280;
+	v_size = 1024;
+	break;
+    case 640:
+	h_size = 640;
+	v_size = 480;
+	break;
+    case 384:
+	h_size = 384;
+	v_size = 288;
+	break;
+    case 352:
+	h_size = 352;
+	v_size = 288;
+	break;
+    case 320:
+	h_size = 320;
+	v_size = 240;
+	break;
+    default:
+	h_size = 352;
+	v_size = 288;
+	break;
+    }
+    data[3] = h_size / 8;	//h_size , reg 2
+    data[4] = v_size / 8;	//v_size , reg 3
+    data[5] = 0x30;		// reg 4, MI, PAS5101 : 0x30 for 24mhz , 0x28 for 12mhz
+    data[6] = 4;		// reg 5, H start
+    data[7] = 0xc0;		// reg 6, gamma 1.5
+    data[8] = 3;		// reg 7, V start
+    //if(pcam->width == 320 )
+    //data[9]= 0x56;        // reg 8, 24MHz, 2:1 scale down
+    //else
+    data[9] = 0x52;		// reg 8, 24MHz, no scale down
+    data[10] = 0x5d;		// reg 9, I2C device address [for PAS5101 (0x40)] [for MI (0x5d)]
+
+    err_code = pcam_reg_write(pcam->dev, data[0], data, 0x0b);
+    if (err_code < 0) {
+	PDEBUG(1, "Register write failed \n");
+	return ;
+    }
+
+
+    data[0] = 0x23;		//address
+    data[1] = 0x09;		// reg 35, append frame header
+
+    err_code = pcam_reg_write(pcam->dev, data[0], data, 0x02);
+    if (err_code < 0) {
+	PDEBUG(1, "Register write failed \n");
+	return ;
+    }
+
+
+
+    data[0] = 0x3C;		//address
+    if (pcam->width == 1280)
+	data[1] = 200;		// reg 60, pc-cam frame size (unit: 4KB) 800KB
+    else
+	data[1] = 50;		// 50 reg 60, pc-cam frame size (unit: 4KB) 200KB
+    err_code = pcam_reg_write(pcam->dev, data[0], data, 0x02);
+    if (err_code < 0) {
+	PDEBUG(1, "Register write failed \n");
+	return ;
+    }
+
+
+    if (0) {			// fixed dark-gain
+	data[1] = 0;		// reg 94, Y Gain (1.75)
+	data[2] = 0;		// reg 95, UV Gain (1.75)
+	data[3] = 0x3f;		// reg 96, Y Gain/UV Gain/disable auto dark-gain
+	data[4] = 0;		// reg 97, set fixed dark level
+	data[5] = 0;		// reg 98, don't care
+    } else {			// auto dark-gain
+	data[1] = 0;		// reg 94, Y Gain (auto)
+	data[2] = 0;		// reg 95, UV Gain (1.75)
+	data[3] = 0x78;		// reg 96, Y Gain/UV Gain/disable auto dark-gain
+	switch (pcam->width) {
+	case 1280:
+	    data[4] = 154;	// reg 97, %3 shadow point (unit: 256 pixel)
+	    data[5] = 51;	// reg 98, %1 highlight point (uint: 256 pixel)
+	    break;
+	case 640:
+	    data[4] = 36;	// reg 97, %3 shadow point (unit: 256 pixel)
+	    data[5] = 12;	// reg 98, %1 highlight point (uint: 256 pixel)
+	    break;
+	case 320:
+	    data[4] = 9;	// reg 97, %3 shadow point (unit: 256 pixel)
+	    data[5] = 3;	// reg 98, %1 highlight point (uint: 256 pixel)
+	    break;
+	}
+    }
+    // auto dark-gain
+    data[0] = 0x5E;		// address
+
+    err_code = pcam_reg_write(pcam->dev, data[0], data, 0x06);
+    if (err_code < 0) {
+	PDEBUG(1, "Register write failed \n");
+	return ;
+    }
+
+
+
+    data[0] = 0x67;
+    data[1] = 0x13;		// reg 103, first pixel B, disable sharpness
+    err_code = pcam_reg_write(pcam->dev, data[0], data, 0x02);
+    if (err_code < 0) {
+	PDEBUG(1, "Register write failed \n");
+	return ;
+    }
+
+
+    /*
+       initialize the value of MI sensor...
+     */
+
+    MI_buf[REG_HW_MI_1] = 0x000a;
+    MI_buf[REG_HW_MI_2] = 0x000c;
+    MI_buf[REG_HW_MI_3] = 0x0405;
+    MI_buf[REG_HW_MI_4] = 0x0507;
+    //mi_Attr_Reg_[REG_HW_MI_5]     = 0x01ff;//13
+    MI_buf[REG_HW_MI_5] = 0x0013;	//13
+    MI_buf[REG_HW_MI_6] = 0x001f;	// vertical blanking
+    //mi_Attr_Reg_[REG_HW_MI_6]     = 0x0400;  // vertical blanking
+    MI_buf[REG_HW_MI_7] = 0x0002;
+    //mi_Attr_Reg_[REG_HW_MI_9]     = 0x015f;
+    //mi_Attr_Reg_[REG_HW_MI_9]     = 0x030f;
+    MI_buf[REG_HW_MI_9] = 0x0374;
+    MI_buf[REG_HW_MI_B] = 0x0000;
+    MI_buf[REG_HW_MI_C] = 0x0000;
+    MI_buf[REG_HW_MI_D] = 0x0000;
+    MI_buf[REG_HW_MI_1E] = 0x8000;
+//      mi_Attr_Reg_[REG_HW_MI_20]      = 0x1104;
+    MI_buf[REG_HW_MI_20] = 0x1104;	//0x111c;
+    MI_buf[REG_HW_MI_2B] = 0x0008;
+//      mi_Attr_Reg_[REG_HW_MI_2C]      = 0x000f;
+    MI_buf[REG_HW_MI_2C] = 0x001f;	//lita suggest
+    MI_buf[REG_HW_MI_2D] = 0x0008;
+    MI_buf[REG_HW_MI_2E] = 0x0008;
+    MI_buf[REG_HW_MI_35] = 0x0051;
+    MI_buf[REG_HW_MI_5F] = 0x0904;	//fail to write
+    MI_buf[REG_HW_MI_60] = 0x0000;
+    MI_buf[REG_HW_MI_61] = 0x0000;
+    MI_buf[REG_HW_MI_62] = 0x0498;
+    MI_buf[REG_HW_MI_63] = 0x0000;
+    MI_buf[REG_HW_MI_64] = 0x0000;
+    MI_buf[REG_HW_MI_F1] = 0x0001;
+    //changing while setting up the different value of dx/dy
+
+    if (pcam->width != 1280) {
+	MI_buf[0x01] = 0x010a;
+	MI_buf[0x02] = 0x014c;
+	MI_buf[0x03] = 0x01e5;
+	MI_buf[0x04] = 0x0287;
+    }
+    MI_buf[0x20] = 0x1104;
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 1, 1, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 2, 2, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 3, 3, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 4, 4, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 5, 5, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 6, 6, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 7, 7, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 9, 9, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x0B, 0x0B, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x0C, 0x0C, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x0D, 0x0D, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x1E, 0x1E, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x20, 0x20, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x2B, 0x2B, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x2C, 0x2C, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x2D, 0x2D, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x2E, 0x2E, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x35, 0x35, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x5F, 0x5F, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x60, 0x60, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x61, 0x61, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x62, 0x62, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x63, 0x63, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0x64, 0x64, 1, 0);
+
+
+    MISensor_BulkWrite(pcam->dev, MI_buf + 0xF1, 0xF1, 1, 0);
+
+
+
+    intpipe = usb_sndintpipe(pcam->dev, 0);
+    err_code = usb_clear_halt(pcam->dev, intpipe);
+
+    data[0] = 0x00;
+    data[1] = 0x4D;		// ISOC transfering enable...
+    err_code = pcam_reg_write(pcam->dev, data[0], data, 0x02);
+    if (err_code < 0) {
+	PDEBUG(1, "Register write failed \n");
+	return ;
+    }
+
+
+    return ;
+}
+static void MISensor_BulkWrite(struct usb_device *dev, unsigned short *pch,
+			       char Address, int length, char controlbyte)
+{
+    int dest, src, result;
+    unsigned char data[6];
+
+    memset(data, 0, 6);
+
+    for (dest = 3, src = 0; src < length; src++) {
+	data[0] = 0x1f;
+	data[1] = controlbyte;
+	data[2] = Address + src;
+	data[dest] = pch[src] >> 8;	//high byte;
+	data[dest + 1] = pch[src];	//low byte;
+	data[dest + 2] = 0;
+
+	result = usb_control_msg(dev,
+				 usb_sndbulkpipe(dev, 4),
+				 0x12, 0xc8, 0, Address, data, 5, 5 * HZ);
+
+	PDEBUG(1, "reg write: 0x%02X , result = 0x%x \n", Address, result);
+
+	if (result < 0) {
+	    printk("reg write: error %d \n", result);
+	}
+
+    }
+
+}
+static int mr97311_config(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1023;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 1;
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1023;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 1;
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 1;
+    spca50x->mode_cam[SIF].mode = 1;
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 896;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 2;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 896;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 2;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 896;
+    spca50x->mode_cam[QSIF].method = 1;
+    spca50x->mode_cam[QSIF].mode = 2;
+    spca50x->qindex = 1;	// set quantization table
+    return 0;
+}
+static int mr97311_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+	int sof = 0;
+	int p;
+		
+		if (*datalength < 6)
+		    return -1;
+		else {
+		    for (p = 0; p < *datalength - 6; p++) {
+			if ((cdata[0 + p] == 0xFF)
+			    && (cdata[1 + p] == 0xFF)
+			    && (cdata[2 + p] == 0x00)
+			    && (cdata[3 + p] == 0xFF)
+			    && (cdata[4 + p] == 0x96)
+			    ) {
+			    if ((cdata[5 + p] == 0x64)
+				|| (cdata[5 + p] == 0x65)
+				|| (cdata[5 + p] == 0x66)
+				|| (cdata[5 + p] == 0x67)) {
+				sof = 1;
+				break;
+			    }
+			}
+		    }
+
+		    if (sof) {
+			*iPix = p + 16;
+			*datalength -= *iPix;
+			PDEBUG(5,
+			       "Pcam header packet found, %d datalength %d !",
+			       p, *datalength );
+			       return 0;
+		    } else {
+			*iPix = 0;
+			return (seqnum+1);
+		    }
+
+		}
+}
diff -ruN linux-2.6.21/drivers/media/video/gspca/Pixart/pac207.h linux-2.6.21-gspca/drivers/media/video/gspca/Pixart/pac207.h
--- linux-2.6.21/drivers/media/video/gspca/Pixart/pac207.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Pixart/pac207.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,375 @@
+
+#ifndef PAC207USB_H
+#define PAC207USB_H
+/****************************************************************************
+#	 	Pixart PAC207BCA library                                    #
+# 		Copyright (C) 2005 Thomas Kaiser thomas@kaiser-linux.li     #
+#               Copyleft (C) 2005 Michel Xhaard mxhaard@magic.fr            #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+
+static __u8 pac207_sensor_init[][8] = {
+    {0x10, 0x12, 0x0d, 0x12, 0x0c, 0x01, 0x29, 0xf0},	//2 
+  //{0x10, 0x24, 0x06, 0x12, 0x0c, 0x01, 0x29, 0xf0},	//2 increase the times exposure decrease frame rate
+    {0x00, 0x64, 0x64, 0x64, 0x04, 0x10, 0xF0, 0x30},	//a reg_10 digital gain Red Green Blue Ggain
+    {0x00, 0x00, 0x00, 0x70, 0xA0, 0xF8, 0x00, 0x00},	//12
+    {0x00, 0x00, 0x32, 0x00, 0x96, 0x00, 0xA2, 0x02},	//40
+    {0x32, 0x00, 0x96, 0x00, 0xA2, 0x02, 0xAF, 0x00},	//42 reg_66 rate control
+};
+
+static __u8 PacReg72[] = { 0x00, 0x00, 0x36, 0x00 };	//48 reg_72 Rate Control end BalSize_4a =0x36
+
+/*******************     Camera Interface   ***********************/
+static __u16 pac207_getbrightness(struct usb_spca50x *spca50x);
+static __u16 pac207_getcontrast(struct usb_spca50x *spca50x);
+static __u16 pac207_getcolors(struct usb_spca50x *spca50x);
+static void pac207_setbrightness(struct usb_spca50x *spca50x);
+static void pac207_setcontrast(struct usb_spca50x *spca50x);
+static void pac207_setcolors(struct usb_spca50x *spca50x);
+static int pac207_init(struct usb_spca50x *spca50x);
+static void pac207_start(struct usb_spca50x *spca50x);
+static void pac207_stopN(struct usb_spca50x *spca50x);
+static void pac207_stop0(struct usb_spca50x *spca50x);
+static int pac207_config(struct usb_spca50x *spca50x);
+static void pac207_shutdown(struct usb_spca50x *spca50x);
+static void pac207_setAutobright(struct usb_spca50x *spca50x);
+static void pac207_setquality(struct usb_spca50x *spca50x);
+static int pac207_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/*******************************************************************/
+static __u16 pac207_getcolors(struct usb_spca50x *spca50x){return 0 ;}
+static void pac207_setcolors(struct usb_spca50x *spca50x){ spca50x->colour = 0;}
+static void pac207_stop0(struct usb_spca50x *spca50x){}
+static void pac207_setquality(struct usb_spca50x *spca50x){}
+/*******************     Camera Private     ***********************/
+static void pac207_reg_write(struct usb_device *dev, __u16 index,
+			     __u16 value);
+static void pac207_reg_read(struct usb_device *dev, __u16 index,
+			    __u8 * buffer);
+
+/***************************** Implementation ****************************/
+static struct cam_operation fpac207 = {
+ 	.initialize = pac207_init,
+	.configure = pac207_config,
+	.start = pac207_start,
+	.stopN = pac207_stopN,
+	.stop0 = pac207_stop0,
+	.get_bright = pac207_getbrightness,
+	.set_bright = pac207_setbrightness,
+	.get_contrast = pac207_getcontrast,
+	.set_contrast = pac207_setcontrast,
+	.get_colors = pac207_getcolors,
+	.set_colors = pac207_setcolors,
+	.set_autobright = pac207_setAutobright,
+	.set_quality = pac207_setquality,
+	.cam_shutdown = pac207_shutdown,
+	.sof_detect = pac207_sofdetect,
+ };
+static void pac207_reg_read(struct usb_device *dev, __u16 index,
+			    __u8 * buffer)
+{
+    pac207RegRead(dev, 0x00, 0x00, index, buffer, 1);
+    return;
+}
+
+static void pac207_reg_write(struct usb_device *dev, __u16 index,
+			     __u16 value)
+{
+    pac207RegWrite(dev, 0x00, value, index, NULL, 0);
+    return;
+}
+
+
+static __u16 pac207_getbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 brightness = 0;
+    pac207_reg_read(spca50x->dev, 0x0008, &brightness);
+    spca50x->brightness = brightness << 8;
+    return spca50x->brightness;
+}
+static __u16 pac207_getcontrast(struct usb_spca50x *spca50x)
+{
+    __u8 contrast = 0;
+    pac207_reg_read(spca50x->dev, 0x000e, &contrast);
+    spca50x->contrast = contrast << 11;
+    return spca50x->contrast;
+}
+static void pac207_setcontrast(struct usb_spca50x *spca50x)
+{
+    __u8 contrast = spca50x->contrast >> 11;
+    pac207_reg_write(spca50x->dev, 0x000e, contrast);
+    pac207_reg_write(spca50x->dev, 0x13, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    pac207_reg_write(spca50x->dev, 0x1c, 0x01);	//not documented
+}
+static void pac207_setbrightness(struct usb_spca50x *spca50x)
+{
+
+    __u8 brightness = spca50x->brightness >> 8;
+    pac207_reg_write(spca50x->dev, 0x0008, brightness);
+    pac207_reg_write(spca50x->dev, 0x13, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    pac207_reg_write(spca50x->dev, 0x1c, 0x01);	//not documented
+}
+
+static int pac207_init(struct usb_spca50x *spca50x)
+{
+    __u8 id[] = { 0, 0 };
+    pac207_reg_write(spca50x->dev, 0x41, 0x00);	//Turn of LED
+    pac207_reg_read(spca50x->dev, 0x0000, &id[0]);
+    pac207_reg_read(spca50x->dev, 0x0001, &id[1]);
+    id[0] = ((id[0] & 0x0F) << 4) | ((id[1] & 0xf0) >> 4);
+    id[1] = id[1] & 0x0f;
+    PDEBUG(2, " Pixart Sensor ID 0x%02X Chips ID 0x%02X !!\n", id[0],
+	   id[1]);
+    if (id[0] != 0x27 || id[1] != 0x00)
+	return -ENODEV;
+
+    return 0;
+}
+
+static void set_pac207SIF(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 0;
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 1;
+    spca50x->mode_cam[CIF].mode = 0;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 1;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 1;
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 1023;
+    spca50x->mode_cam[QCIF].method = 1;
+    spca50x->mode_cam[QCIF].mode = 1;
+    return;
+}
+
+static int pac207_config(struct usb_spca50x *spca50x)
+{
+
+    PDEBUG(2, "Find Sensor PAC207");
+    spca50x->sensor = SENSOR_PAC207;
+    set_pac207SIF(spca50x);
+    pac207_reg_write(spca50x->dev, 0x41, 0x00);	//00 Bit_0=Image Format, Bit_1=LED, Bit_2=Compression test mode enable
+    pac207_reg_write(spca50x->dev, 0x0f, 0x00);	//Power Control
+    pac207_reg_write(spca50x->dev, 0x11, 0x30);	//Analog Bias
+
+    return 0;
+}
+
+static void pac207_start(struct usb_spca50x *spca50x)
+{
+
+    __u8 buffer;
+    __u8 mode;
+
+    pac207_reg_write(spca50x->dev, 0x0f, 0x10);	//Power control (Bit 6-0)
+    pac207RegWrite(spca50x->dev, 0x01, 0, 0x0002, pac207_sensor_init[0],
+		   8);
+    pac207RegWrite(spca50x->dev, 0x01, 0, 0x000a, pac207_sensor_init[1],
+		   8);
+    pac207RegWrite(spca50x->dev, 0x01, 0, 0x0012, pac207_sensor_init[2],
+		   8);
+    pac207RegWrite(spca50x->dev, 0x01, 0, 0x0040, pac207_sensor_init[3],
+		   8);
+    pac207RegWrite(spca50x->dev, 0x01, 0, 0x0042, pac207_sensor_init[4],
+		   8);
+    pac207RegWrite(spca50x->dev, 0x01, 0, 0x0048, PacReg72, 4);
+    if (spca50x->compress) {
+	pac207_reg_write(spca50x->dev, 0x4a, 0x88);	//Compression Balance size 0x88
+    } else {
+	pac207_reg_write(spca50x->dev, 0x4a, 0xff);	//Compression Balance size
+    }
+    pac207_reg_write(spca50x->dev, 0x4b, 0x00);	//Sram test value
+    pac207_reg_write(spca50x->dev, 0x13, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    pac207_reg_write(spca50x->dev, 0x1c, 0x01);	//not documented
+    pac207_reg_write(spca50x->dev, 0x41, 0x02);	//Image Format (Bit 0), LED (Bit 1), Compression test mode enable (Bit 2)
+
+    if (spca50x->mode) {
+	/* 176x144 */
+	pac207_reg_read(spca50x->dev, 0x41, &buffer);
+	mode = buffer | 0x01;
+	//mode = buffer | 0x00;
+	pac207_reg_write(spca50x->dev, 0x41, mode);	//Set mode
+	pac207_reg_write(spca50x->dev, 0x02, 0x04);	//PXCK = 12MHz /n
+	pac207_reg_write(spca50x->dev, 0x0e, 0x0f);	//PGA global gain (Bit 4-0)
+	pac207_reg_write(spca50x->dev, 0x13, 0x01);	//load registers to sensor (Bit 0, auto clear)
+	pac207_reg_write(spca50x->dev, 0x1c, 0x01);	//not documented
+	PDEBUG(1, "pac207_start mode 176x144, mode = %x", mode);
+    } else {
+	/* 352x288 */
+	pac207_reg_read(spca50x->dev, 0x41, &buffer);
+	mode = buffer & 0xfe;
+	pac207_reg_write(spca50x->dev, 0x41, mode);	//Set mode
+	if (spca50x->compress) {
+	    pac207_reg_write(spca50x->dev, 0x02, 0x04);	//PXCK = 12MHz / n 04
+	} else {
+	    pac207_reg_write(spca50x->dev, 0x02, 0x0a);	//PXCK = 12MHz / n
+	}
+	pac207_reg_write(spca50x->dev, 0x0e, 0x04);	//PGA global gain (Bit 4-0)
+	pac207_reg_write(spca50x->dev, 0x13, 0x01);	//load registers to sensor (Bit 0, auto clear)
+	pac207_reg_write(spca50x->dev, 0x1c, 0x01);	//not documented
+	PDEBUG(1, "pac207_start mode 352x288, mode = %x", mode);
+    }
+    udelay(1000);
+    pac207_reg_write(spca50x->dev, 0x40, 0x01);	//Start ISO pipe
+
+//      pac207_setbrightness(spca50x);
+    return;
+}
+
+static void pac207_stopN(struct usb_spca50x *spca50x)
+{
+    pac207_reg_write(spca50x->dev, 0x40, 0x00);	//Stop ISO pipe
+    pac207_reg_write(spca50x->dev, 0x41, 0x00);	//Turn of LED
+    pac207_reg_write(spca50x->dev, 0x0f, 0x00);	//Power Control
+    return;
+}
+
+static void pac207_shutdown(struct usb_spca50x *spca50x)
+{
+    pac207_reg_write(spca50x->dev, 0x41, 0x00);	//Turn of LED
+    pac207_reg_write(spca50x->dev, 0x0f, 0x00);	//Power Control
+    return;
+}
+
+#ifdef GSPCA_ENABLE_REGISTERPLAY
+static void pac207_RegRead(struct usb_spca50x *spca50x)
+{
+    __u8 buffer;
+    RegAddress = RegAddress & 0xff;
+    pac207_reg_read(spca50x->dev, RegAddress, &buffer);
+    RegValue = buffer;
+    PDEBUG(0, "pac207_ReadReg, Reg 0x%02X value = %x", RegAddress,
+	   RegValue);
+    return;
+}
+
+static void pac207_RegWrite(struct usb_spca50x *spca50x)
+{
+    __u8 buffer;
+
+    RegAddress = RegAddress & 0xff;
+    buffer = RegValue & 0xff;
+    pac207_reg_write(spca50x->dev, RegAddress, buffer);
+    pac207_reg_write(spca50x->dev, 0x13, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    pac207_reg_write(spca50x->dev, 0x1c, 0x01);	//not documented
+    PDEBUG(0, "pac207_WriteReg,Reg 0x%02X value = %x", RegAddress, buffer);
+    return;
+}
+#endif
+	
+#define BLIMIT(bright) (__u8)((bright>0x1a)?0x1a:((bright < 4)? 4:bright))
+
+static void pac207_setAutobright(struct usb_spca50x *spca50x)
+{
+    unsigned long flags;
+    __u8 luma = 0;
+    __u8 luma_mean = 128;
+    __u8 luma_delta = 20;
+    __u8 spring = 5;
+    __u8 Pxclk;
+    int Gbright = 0;
+    
+    
+    pac207_reg_read(spca50x->dev, 0x02, &Pxclk);
+    Gbright = Pxclk;
+    spin_lock_irqsave(&spca50x->v4l_lock, flags);
+    luma = spca50x->avg_lum;
+    spin_unlock_irqrestore(&spca50x->v4l_lock, flags);
+    
+    PDEBUG(2, "Pac207 lumamean %d", luma);
+    if ((luma < (luma_mean - luma_delta)) ||
+	(luma > (luma_mean + luma_delta))) {
+	Gbright += ((luma_mean - luma) >> spring);
+	Gbright = BLIMIT(Gbright);
+	PDEBUG(2, "Pac207 Gbright %d", Gbright);
+	pac207_reg_write(spca50x->dev, 0x02,(__u8) Gbright);
+	pac207_reg_write(spca50x->dev, 0x13, 0x01);	//load registers to sensor (Bit 0, auto clear)
+	pac207_reg_write(spca50x->dev, 0x1c, 0x01);	//not documented
+    }
+}
+#undef BLIMIT
+static int pac207_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+		
+		int sof = 0;
+		int p = 0;
+		if (*datalength < 6)
+		    return -1;
+		else {
+		    for (p = 0; p < *datalength - 6; p++) {
+			if ((cdata[0 + p] == 0xFF)
+			    && (cdata[1 + p] == 0xFF)
+			    && (cdata[2 + p] == 0x00)
+			    && (cdata[3 + p] == 0xFF)
+			    && (cdata[4 + p] == 0x96)
+			    ) {
+			    sof = 1;
+			    break;
+			}
+		    }
+
+		    if (sof) {
+#if 1
+		spin_lock(&spca50x->v4l_lock);
+		spca50x->avg_lum = cdata[p+9] ;
+		spin_unlock(&spca50x->v4l_lock);
+		PDEBUG(5, "mean luma %d", spca50x->avg_lum);
+#endif
+			// copy the end of data to the current frame
+			memcpy(frame->highwater, cdata, p);
+			frame->highwater += p;
+			//totlen += p;
+			*iPix = p;	//copy to the nextframe start at p
+			*datalength -= *iPix;
+			PDEBUG(5,
+			       "Pixartcam header packet found, %d datalength %d !!",
+			       p, *datalength );
+			return 0;
+		    } else {
+		    *iPix = 0;
+			return (seqnum+1);
+		    }
+
+		}
+}
+			/* GSPCA_ENABLE_REGISTERPLAY */
+#endif				// PAC207USB_H
diff -ruN linux-2.6.21/drivers/media/video/gspca/Pixart/pac7311.h linux-2.6.21-gspca/drivers/media/video/gspca/Pixart/pac7311.h
--- linux-2.6.21/drivers/media/video/gspca/Pixart/pac7311.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Pixart/pac7311.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,508 @@
+#ifndef PAC7311USB_H
+#define PAC7311USB_H
+/****************************************************************************
+#	 	Pixart PAC7311 library                                              #
+# 		Copyright (C) 2005 Thomas Kaiser thomas@kaiser-linux.li             #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+/*******************     Camera Interface   ***********************/
+static __u16 pac7311_getbrightness(struct usb_spca50x *spca50x);
+static __u16 pac7311_getcontrast(struct usb_spca50x *spca50x);
+static __u16 pac7311_getcolors(struct usb_spca50x *spca50x);
+static void pac7311_setbrightness(struct usb_spca50x *spca50x);
+static void pac7311_setcontrast(struct usb_spca50x *spca50x);
+static void pac7311_setcolors(struct usb_spca50x *spca50x);
+static int pac7311_init(struct usb_spca50x *spca50x);
+static void pac7311_start(struct usb_spca50x *spca50x);
+static void pac7311_stopN(struct usb_spca50x *spca50x);
+static void pac7311_stop0(struct usb_spca50x *spca50x);
+static int pac7311_config(struct usb_spca50x *spca50x);
+static void pac7311_shutdown(struct usb_spca50x *spca50x);
+static void pac7311_setAutobright(struct usb_spca50x *spca50x);
+static void pac7311_setquality(struct usb_spca50x *spca50x);
+static int pac7311_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/*******************************************************************/
+static __u16 pac7311_getcolors(struct usb_spca50x *spca50x){return 0 ;}
+static void pac7311_stop0(struct usb_spca50x *spca50x){}
+static void pac7311_setquality(struct usb_spca50x *spca50x){}
+/*******************     Camera Private     ***********************/
+static void pac7311_reg_write(struct usb_device *dev, __u16 index,
+			     __u16 value);
+static void pac7311_reg_read(struct usb_device *dev, __u16 index,
+			    __u8 * buffer);
+
+/***************************** Implementation ****************************/
+static struct cam_operation fpac7311 = {
+ 	.initialize = pac7311_init,
+	.configure = pac7311_config,
+	.start = pac7311_start,
+	.stopN = pac7311_stopN,
+	.stop0 = pac7311_stop0,
+	.get_bright = pac7311_getbrightness,
+	.set_bright = pac7311_setbrightness,
+	.get_contrast = pac7311_getcontrast,
+	.set_contrast = pac7311_setcontrast,
+	.get_colors = pac7311_getcolors,
+	.set_colors = pac7311_setcolors,
+	.set_autobright = pac7311_setAutobright,
+	.set_quality = pac7311_setquality,
+	.cam_shutdown = pac7311_shutdown,
+	.sof_detect = pac7311_sofdetect,
+ };
+static void pac7311_reg_read(struct usb_device *dev, __u16 index,
+			    __u8 * buffer)
+{
+    pac7311RegRead(dev, 0x00, 0x00, index, buffer, 1);
+    return;
+}
+
+static void pac7311_reg_write(struct usb_device *dev, __u16 index,
+			     __u16 value)
+{
+    char pvalue;
+    pvalue = value;
+    pac7311RegWrite(dev, 0x00, value, index, &pvalue, 1);
+    return;
+}
+
+static __u16 pac7311_getbrightness(struct usb_spca50x *spca50x)
+{
+    /*
+    __u8 brightness = 0;
+    pac7311_reg_read(spca50x->dev, 0x0008, &brightness);
+    spca50x->brightness = brightness << 8;
+    return spca50x->brightness;
+    */
+    //PDEBUG(0, "Called pac7311_getbrightness: Not implemented yet");
+    return spca50x->avg_lum;
+}
+
+static __u16 pac7311_getcontrast(struct usb_spca50x *spca50x)
+{
+    /*
+    __u8 contrast = 0;
+    pac7311_reg_read(spca50x->dev, 0x000e, &contrast);
+    spca50x->contrast = contrast << 11;
+    return spca50x->contrast;
+    */
+    PDEBUG(0, "Called pac7311_getcontrast: Not implemented yet");
+    return 0;
+}
+
+static void pac7311_setcontrast(struct usb_spca50x *spca50x)
+{
+    __u8 contrast = spca50x->contrast >> 8;
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x80, contrast);
+    pac7311_reg_write(spca50x->dev, 0x11, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    PDEBUG(0, "contrast = %i", contrast);
+}
+
+static void pac7311_setbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 brightness = (spca50x->brightness >> 8) * -1;
+    pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+    //pac7311_reg_write(spca50x->dev, 0x0e, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x0f, brightness);
+    pac7311_reg_write(spca50x->dev, 0x11, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    PDEBUG(0, "brightness = %i", brightness);
+}
+
+static void pac7311_setcolors(struct usb_spca50x *spca50x)
+{
+    __u8 colour = spca50x->colour >> 8;
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x10, colour);
+    pac7311_reg_write(spca50x->dev, 0x11, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    PDEBUG(0, "color = %i", colour);
+}
+
+static int pac7311_init(struct usb_spca50x *spca50x)
+{
+    //__u8 id[] = { 0, 0 };
+    pac7311_reg_write(spca50x->dev, 0x78, 0x00);	//Turn on LED
+
+    return 0;
+}
+
+static void set_pac7311SIF(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof (struct mwebcam));
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1023;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = VGA;
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette = P_JPEG | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1023;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = PAL;
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 1;
+    spca50x->mode_cam[SIF].mode = SIF;
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = CIF;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = CIF;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette = P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 1;
+    spca50x->mode_cam[QSIF].mode = QSIF;
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette = P_JPEG | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 1023;
+    spca50x->mode_cam[QCIF].method = 0;
+    spca50x->mode_cam[QCIF].mode = QCIF;
+    return;
+}
+
+static int pac7311_config(struct usb_spca50x *spca50x)
+{
+    PDEBUG(2, "Find Sensor PAC7311");
+    spca50x->sensor = SENSOR_PAC7311;
+    set_pac7311SIF(spca50x);
+    pac7311_reg_write(spca50x->dev, 0x78, 0x40);	//Bit_0=start stream, Bit_7=LED
+    pac7311_reg_write(spca50x->dev, 0x78, 0x40);	//Bit_0=start stream, Bit_7=LED
+    pac7311_reg_write(spca50x->dev, 0x78, 0x44);	//Bit_0=start stream, Bit_7=LED
+    pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+    pac7311_reg_write(spca50x->dev, 0x27, 0x80);
+    pac7311_reg_write(spca50x->dev, 0x28, 0xca);
+    pac7311_reg_write(spca50x->dev, 0x29, 0x53);
+    pac7311_reg_write(spca50x->dev, 0x2a, 0x0e);
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x3e, 0x20);
+
+    return 0;
+}
+
+static void pac7311_start(struct usb_spca50x *spca50x)
+{
+    //__u8 buffer;
+    __u8 mode;
+
+    mode = spca50x->mode;
+
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0002, "\x48\x0a\x40\x08\x00\x00\x08\x00", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x000a, "\x06\xff\x11\xff\x5a\x30\x90\x4c", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0012, "\x00\x07\x00\x0a\x10\x00\xa0\x10", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x001a, "\x02\x00\x00\x00\x00\x0b\x01\x00", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0022, "\x00\x00\x00\x00\x00\x00\x00\x00", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x002a, "\x00\x00\x00", 3);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x003e, "\x00\x00\x78\x52\x4a\x52\x78\x6e", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0046, "\x48\x46\x48\x6e\x5f\x49\x42\x49", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x004e, "\x5f\x5f\x49\x42\x49\x5f\x6e\x48", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0056, "\x46\x48\x6e\x78\x52\x4a\x52\x78", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x005e, "\x00\x00\x09\x1b\x34\x49\x5c\x9b", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0066, "\xd0\xff", 2);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0078, "\x44\x00\xf2\x01\x01\x80", 6);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x007f, "\x2a\x1c\x00\xc8\x02\x58\x03\x84", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0087, "\x12\x00\x1a\x04\x08\x0c\x10\x14", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x008f, "\x18\x20", 2);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x0096, "\x01\x08\x04", 3);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x00a0, "\x44\x44\x44\x04", 4);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x00f0, "\x01\x00\x00\x00\x22\x00\x20\x00", 8);
+    pac7311RegWrite(spca50x->dev, 0x01, 0, 0x00f8, "\x3f\x00\x0a\x01\x00", 5);
+
+    pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+    pac7311_reg_write(spca50x->dev, 0x02, 0x04);
+    pac7311_reg_write(spca50x->dev, 0x03, 0x54);
+    pac7311_reg_write(spca50x->dev, 0x04, 0x07);
+    pac7311_reg_write(spca50x->dev, 0x05, 0x2b);
+    pac7311_reg_write(spca50x->dev, 0x06, 0x09);
+    pac7311_reg_write(spca50x->dev, 0x07, 0x0f);
+    pac7311_reg_write(spca50x->dev, 0x08, 0x09);
+    pac7311_reg_write(spca50x->dev, 0x09, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x0c, 0x07);
+    pac7311_reg_write(spca50x->dev, 0x0d, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x0e, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x0f, 0x62);
+    pac7311_reg_write(spca50x->dev, 0x10, 0x08);
+    pac7311_reg_write(spca50x->dev, 0x12, 0x07);
+    pac7311_reg_write(spca50x->dev, 0x13, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x14, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x15, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x16, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x17, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x18, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x19, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x1a, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x1b, 0x03);
+    pac7311_reg_write(spca50x->dev, 0x1c, 0xa0);
+    pac7311_reg_write(spca50x->dev, 0x1d, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x1e, 0xf4);
+    pac7311_reg_write(spca50x->dev, 0x21, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x22, 0x08);
+    pac7311_reg_write(spca50x->dev, 0x24, 0x03);
+    pac7311_reg_write(spca50x->dev, 0x26, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x27, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x28, 0xca);
+    pac7311_reg_write(spca50x->dev, 0x29, 0x10);
+    pac7311_reg_write(spca50x->dev, 0x2a, 0x06);
+    pac7311_reg_write(spca50x->dev, 0x2b, 0x78);
+    pac7311_reg_write(spca50x->dev, 0x2c, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x2d, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x2e, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x2f, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x30, 0x23);
+    pac7311_reg_write(spca50x->dev, 0x31, 0x28);
+    pac7311_reg_write(spca50x->dev, 0x32, 0x04);
+    pac7311_reg_write(spca50x->dev, 0x33, 0x11);
+    pac7311_reg_write(spca50x->dev, 0x34, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x35, 0x00);
+    pac7311_reg_write(spca50x->dev, 0x11, 0x01);
+
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x80, 0x10);
+    pac7311_reg_write(spca50x->dev, 0x11, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+    pac7311_reg_write(spca50x->dev, 0x0f, 0x10);
+    pac7311_reg_write(spca50x->dev, 0x11, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x10, 0x10);
+    pac7311_reg_write(spca50x->dev, 0x11, 0x01);	//load registers to sensor (Bit 0, auto clear)
+
+    //set correct resolution
+    switch (mode) {
+        case QCIF:
+            pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+            pac7311_reg_write(spca50x->dev, 0x02, 0x03);
+            pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+            pac7311_reg_write(spca50x->dev, 0x08, 0x09);
+            pac7311_reg_write(spca50x->dev, 0x17, 0x20);
+            pac7311_reg_write(spca50x->dev, 0x1b, 0x00);
+            //pac7311_reg_write(spca50x->dev, 0x80, 0x69);
+            pac7311_reg_write(spca50x->dev, 0x87, 0x10);
+        break;
+        case QSIF:
+            pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+            pac7311_reg_write(spca50x->dev, 0x02, 0x03);
+            pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+            pac7311_reg_write(spca50x->dev, 0x08, 0x09);
+            pac7311_reg_write(spca50x->dev, 0x17, 0x30);
+            //pac7311_reg_write(spca50x->dev, 0x80, 0x69);
+            pac7311_reg_write(spca50x->dev, 0x87, 0x10);
+        break;
+        case QPAL:
+            pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+            pac7311_reg_write(spca50x->dev, 0x02, 0x03);
+            pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+            pac7311_reg_write(spca50x->dev, 0x08, 0x09);
+            pac7311_reg_write(spca50x->dev, 0x17, 0x30);
+            //pac7311_reg_write(spca50x->dev, 0x80, 0x69);
+            pac7311_reg_write(spca50x->dev, 0x87, 0x10);
+        break;
+        case CIF:
+            pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+            pac7311_reg_write(spca50x->dev, 0x02, 0x03);
+            pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+            pac7311_reg_write(spca50x->dev, 0x08, 0x09);
+            pac7311_reg_write(spca50x->dev, 0x17, 0x30);
+            //pac7311_reg_write(spca50x->dev, 0x80, 0x3f);
+            pac7311_reg_write(spca50x->dev, 0x87, 0x11);
+        break;
+        case SIF:
+            pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+            pac7311_reg_write(spca50x->dev, 0x02, 0x03);
+            pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+            pac7311_reg_write(spca50x->dev, 0x08, 0x08);
+            pac7311_reg_write(spca50x->dev, 0x17, 0x00);
+            //pac7311_reg_write(spca50x->dev, 0x80, 0x3f);
+            pac7311_reg_write(spca50x->dev, 0x87, 0x11);
+        break;
+        case PAL:
+            pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+            pac7311_reg_write(spca50x->dev, 0x02, 0x03);
+            pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+            pac7311_reg_write(spca50x->dev, 0x08, 0x08);
+            pac7311_reg_write(spca50x->dev, 0x17, 0x00);
+            //pac7311_reg_write(spca50x->dev, 0x80, 0x3f);
+            pac7311_reg_write(spca50x->dev, 0x87, 0x11);
+        break;
+        case VGA:
+            pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+            pac7311_reg_write(spca50x->dev, 0x02, 0x03);
+            pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+            pac7311_reg_write(spca50x->dev, 0x08, 0x08);
+            pac7311_reg_write(spca50x->dev, 0x17, 0x00);
+            //pac7311_reg_write(spca50x->dev, 0x80, 0x1c);
+            pac7311_reg_write(spca50x->dev, 0x87, 0x12);
+        break;
+    }
+
+    //start stream
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x78, 0x04);
+    pac7311_reg_write(spca50x->dev, 0x78, 0x05);
+
+    return;
+}
+
+static void pac7311_stopN(struct usb_spca50x *spca50x)
+{
+    pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+    pac7311_reg_write(spca50x->dev, 0x27, 0x80);
+    pac7311_reg_write(spca50x->dev, 0x28, 0xca);
+    pac7311_reg_write(spca50x->dev, 0x29, 0x53);
+    pac7311_reg_write(spca50x->dev, 0x2a, 0x0e);
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x3e, 0x20);
+    pac7311_reg_write(spca50x->dev, 0x78, 0x04);	//Bit_0=start stream, Bit_7=LED
+    pac7311_reg_write(spca50x->dev, 0x78, 0x44);	//Bit_0=start stream, Bit_7=LED
+    pac7311_reg_write(spca50x->dev, 0x78, 0x44);	//Bit_0=start stream, Bit_7=LED
+    return;
+}
+
+static void pac7311_shutdown(struct usb_spca50x *spca50x)
+{
+    pac7311_reg_write(spca50x->dev, 0xff, 0x04);
+    pac7311_reg_write(spca50x->dev, 0x27, 0x80);
+    pac7311_reg_write(spca50x->dev, 0x28, 0xca);
+    pac7311_reg_write(spca50x->dev, 0x29, 0x53);
+    pac7311_reg_write(spca50x->dev, 0x2a, 0x0e);
+    pac7311_reg_write(spca50x->dev, 0xff, 0x01);
+    pac7311_reg_write(spca50x->dev, 0x3e, 0x20);
+    pac7311_reg_write(spca50x->dev, 0x78, 0x04);	//Bit_0=start stream, Bit_7=LED
+    pac7311_reg_write(spca50x->dev, 0x78, 0x44);	//Bit_0=start stream, Bit_7=LED
+    pac7311_reg_write(spca50x->dev, 0x78, 0x44);	//Bit_0=start stream, Bit_7=LED
+    return;
+}
+
+#ifdef GSPCA_ENABLE_REGISTERPLAY
+static void pac7311_RegRead(struct usb_spca50x *spca50x)
+{
+    __u8 buffer;
+    RegAddress = RegAddress & 0xff;
+    pac7311_reg_read(spca50x->dev, RegAddress, &buffer);
+    RegValue = buffer;
+    PDEBUG(0, "pac7311_ReadReg, Reg 0x%02X value = %x", RegAddress, RegValue);
+    return;
+}
+
+static void pac7311_RegWrite(struct usb_spca50x *spca50x)
+{
+    __u8 buffer;
+
+    RegAddress = RegAddress & 0xff;
+    buffer = RegValue & 0xff;
+    pac7311_reg_write(spca50x->dev, RegAddress, buffer);
+    PDEBUG(0, "pac7311_WriteReg,Reg 0x%02X value = %x", RegAddress, buffer);
+    return;
+}
+#endif  /* GSPCA_ENABLE_REGISTERPLAY */
+	
+#define BLIMIT(bright) (__u8)((bright>0x1a)?0x1a:((bright < 4)? 4:bright))
+
+static void pac7311_setAutobright(struct usb_spca50x *spca50x)
+{
+    unsigned long flags;
+    __u8 luma = 0;
+    __u8 luma_mean = 128;
+    __u8 luma_delta = 20;
+    __u8 spring = 5;
+    __u8 Pxclk;
+    int Gbright = 0;
+    
+    
+    pac7311_reg_read(spca50x->dev, 0x02, &Pxclk);
+    Gbright = Pxclk;
+    spin_lock_irqsave(&spca50x->v4l_lock, flags);
+    luma = spca50x->avg_lum;
+    spin_unlock_irqrestore(&spca50x->v4l_lock, flags);
+    
+    PDEBUG(2, "Pac7311 lumamean %d", luma);
+    if ((luma < (luma_mean - luma_delta)) ||
+	(luma > (luma_mean + luma_delta))) {
+	Gbright += ((luma_mean - luma) >> spring);
+	Gbright = BLIMIT(Gbright);
+	PDEBUG(2, "Pac7311 Gbright %d", Gbright);
+	pac7311_reg_write(spca50x->dev, 0x0f,(__u8) Gbright);
+	pac7311_reg_write(spca50x->dev, 0x11, 0x01);	//load registers to sensor (Bit 0, auto clear)
+    }
+    //PDEBUG(0, "Called pac7311_setAutobright: Not implemented yet");
+}
+#undef BLIMIT
+static int pac7311_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+		
+		int sof = 0;
+		int p = 0;
+		if (*datalength < 6)
+		//if (*datalength < 5)
+		    return -1;
+		else {
+		    for (p = 0; p < *datalength - 6; p++) {
+		    //for (p = 0; p < *datalength - 5; p++) {
+			if ((cdata[0 + p] == 0xFF)
+			    && (cdata[1 + p] == 0xFF)
+			    && (cdata[2 + p] == 0x00)
+			    && (cdata[3 + p] == 0xFF)
+			    && (cdata[4 + p] == 0x96)
+			    ) {
+			    sof = 1;
+                //if (p > 28) {
+                //    PDEBUG(0, "0x%2X 0x%2X 0x%2X 0x%2X 0x%2X 0x%2X 0x%2X 0x%2X", cdata[p-28], cdata[p-27], cdata[p-26], cdata[p-25], cdata[p-24], cdata[p-23], cdata[p-22], cdata[p-21]);
+                //}
+			    break;
+			}
+		    }
+
+		    if (sof) {
+#if 1
+		spin_lock(&spca50x->v4l_lock);
+        if (p > 28) {
+    		spca50x->avg_lum = cdata[p-23];
+        }
+		spin_unlock(&spca50x->v4l_lock);
+		PDEBUG(5, "mean luma %d", spca50x->avg_lum);
+#endif
+			// copy the end of data to the current frame
+			memcpy(frame->highwater, cdata, p);
+			frame->highwater += p;
+			//totlen += p;
+			*iPix = p;	//copy to the nextframe start at p
+			*datalength -= *iPix;
+			PDEBUG(5,
+			       "Pixartcam header packet found, %d datalength %d !!",
+			       p, *datalength );
+			return 0;
+		    } else {
+		    *iPix = 0;
+			return (seqnum+1);
+		    }
+
+		}
+}
+#endif // pac7311USB_H
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sonix/sn9cxxx.h linux-2.6.21-gspca/drivers/media/video/gspca/Sonix/sn9cxxx.h
--- linux-2.6.21/drivers/media/video/gspca/Sonix/sn9cxxx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sonix/sn9cxxx.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,1148 @@
+#ifndef SONIXJPGUSB_H
+#define SONIXJPGUSB_H
+/****************************************************************************
+#	 	Sonix sn9c102p sn9c105 sn9c120 library                      #
+# 		Copyright (C) 2005 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+static int sn9cxxx_init(struct usb_spca50x *spca50x);
+static void sn9cxxx_start(struct usb_spca50x *spca50x);
+static void sn9cxxx_stopN(struct usb_spca50x *spca50x);
+static void sn9cxxx_stop0(struct usb_spca50x *spca50x);
+static void sn9cxxx_setbrightness(struct usb_spca50x *spca50x);
+static __u16 sn9cxxx_getbrightness(struct usb_spca50x *spca50x);
+static void sn9cxxx_setcontrast(struct usb_spca50x *spca50x);
+static __u16 sn9cxxx_getcontrast(struct usb_spca50x *spca50x);
+static void sn9cxxx_setcolors(struct usb_spca50x *spca50x);
+static __u16 sn9cxxx_getcolors(struct usb_spca50x *spca50x);
+static void sn9cxxx_setAutobright(struct usb_spca50x *spca50x);
+static void sn9cxxx_shutdown(struct usb_spca50x *spca50x);
+static void sn9cxxx_setquality(struct usb_spca50x *spca50x);
+static int sn9cxxx_sofdetect(struct usb_spca50x *spca50x,
+			     struct spca50x_frame *frame, unsigned char *cdata,
+			     int *iPix, int seqnum, int *datalength);
+/****************************************************************************/
+static void
+sn9cxxx_shutdown(struct usb_spca50x *spca50x)
+{
+}
+static void
+sn9cxxx_stop0(struct usb_spca50x *spca50x)
+{
+}
+static void
+sn9cxxx_setquality(struct usb_spca50x *spca50x)
+{
+}
+
+/****************************************************************************/
+static int sn9cxxx_probesensor(struct usb_spca50x *spca50x);
+//static unsigned int sn9cxxx_getexposure(struct usb_spca50x *spca50x);
+static unsigned int sn9cxxx_setexposure(struct usb_spca50x *spca50x,
+					unsigned int expo);
+
+static struct cam_operation fsn9cxx = {
+	.initialize = sn9cxxx_init,
+	.configure = sonix_config,
+	.start = sn9cxxx_start,
+	.stopN = sn9cxxx_stopN,
+	.stop0 = sn9cxxx_stop0,
+	.get_bright = sn9cxxx_getbrightness,
+	.set_bright = sn9cxxx_setbrightness,
+	.get_contrast = sn9cxxx_getcontrast,
+	.set_contrast = sn9cxxx_setcontrast,
+	.get_colors = sn9cxxx_getcolors,
+	.set_colors = sn9cxxx_setcolors,
+	.set_autobright = sn9cxxx_setAutobright,
+	.set_quality = sn9cxxx_setquality,
+	.cam_shutdown = sn9cxxx_shutdown,
+	.sof_detect = sn9cxxx_sofdetect,
+};
+enum {
+	SN9C101 = 0,
+	SN9C102,
+	SN9C102P,
+	SN9C103,
+	SN9C105,
+	SN9C110,
+	SN9C120,
+};
+
+static __u8 sn_mi0360[] = {
+	0x00, 0x61, 0x44, 0x00, 0x1A, 0x20, 0x20, 0x20, 0xB1, 0x5D, 0x07, 0x00,
+	0x00, 0x00, 0x00, 0x10, 0x03, 0x00,
+//reg0  reg1  reg2  reg3  reg4  reg5  reg6  reg7  reg8  reg9  rega  regb  regc  regd  rege  regf  reg10 reg11
+	0x00, 0x02, 0x0a, 0x28, 0x1e, 0x61, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+//reg12 reg13 reg14 reg15 reg16 reg17 reg18 reg19 reg1a reg1b reg1c reg1d reg1e reg1f reg20 reg21 reg22 reg23
+};
+
+/*Data from sn9c102p+hv71331r */
+static __u8 sn_hv7131[] = {
+	0x00, 0x03, 0x64, 0x00, 0x1A, 0x20, 0x20, 0x20, 0xA1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10, 0x03, 0x00,	//00
+//reg0  reg1  reg2  reg3  reg4  reg5  reg6  reg7  reg8  reg9  rega  regb  regc  regd  rege  regf  reg10 reg11
+	0x00, 0x01, 0x03, 0x28, 0x1e, 0x41, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+//reg12 reg13 reg14 reg15 reg16 reg17 reg18 reg19 reg1a reg1b reg1c reg1d reg1e reg1f reg20 reg21 reg22 reg23
+};
+
+static __u8 sn_mo4000[] = {
+	0x12,	0x23,	0x60,	0x00,	0x1A,	0x00,	0x20,	0x18,	0x81,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x03,	0x00,	
+	//reg0	reg1	reg2	reg3	reg4	reg5	reg6	reg7	reg8	reg9	rega	regb	regc	regd	rege	regf	reg10	reg11
+	0x0b,	0x0f,	0x14,	0x28,	0x1e,	0x40,	0x08,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x08,	0x25,	0x39,	0x4b,
+	//reg12	reg13	reg14	reg15	reg16	reg17	reg18	reg19	reg1a	reg1b	reg1c	reg1d	reg1e	reg1f	reg20	reg21	reg22	reg23
+	0x5c,	0x6b,	0x79,	0x87,	0x95,	0xa2,	0xaf,	0xbb,	0xc7,	0xd3,	0xdf,	0xea,	0xf5
+};
+
+static __u8 sn_ov7660[]	=	{
+	0x00,	0x61,	0x40,	0x00,	0x1A,	0x20,	0x20,	0x20,	0x81,	0x21,	0x07,	0x00,	0x00,	0x00,	0x00,	0x10,	0x03,	0x00,
+	//reg0	reg1	reg2	reg3	reg4	reg5	reg6	reg7	reg8	reg9	rega	regb	regc	regd	rege	regf	reg10	reg11
+	0x01,	0x01,	0x08,	0x28,	0x1e,	0x20,	0x07,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00
+	//reg12	reg13	reg14	reg15	reg16	reg17	reg18	reg19	reg1a	reg1b	reg1c	reg1d	reg1e	reg1f	reg20	reg21	reg22	reg23
+};
+	
+static __u8 reg9a[] = {
+	0x08, 0x40, 0x20, 0x10, 0x00, 0x04
+};
+
+static __u8 regsn20[] = {
+	0x00, 0x2D, 0x46, 0x5A, 0x6C, 0x7C, 0x8B, 0x99, 0xA6, 0xB2, 0xBF, 0xCA,
+	0xD5, 0xE0, 0xEB, 0xF5, 0xFF
+};
+static __u8 reg84[] = {
+	0x14, 0x00, 0x27, 0x00, 0x07, 0x00, 0xE5, 0x0F, 0xE4, 0x0F, 0x38, 0x00,
+	//0x3E, 0x00, 0xC3, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00
+	0x3E, 0x00, 0xC3, 0x0F, 0xf7, 0x0f, 0x0a, 0x00, 0x00
+};
+static __u8 hv7131r_sensor_init[][8] = {
+	{0xC1, 0x11, 0x01, 0x08, 0x01, 0x00, 0x00, 0x10},
+	{0xB1, 0x11, 0x34, 0x17, 0x7F, 0x00, 0x00, 0x10},
+	{0xD1, 0x11, 0x40, 0xFF, 0x7F, 0x7F, 0x7F, 0x10},
+	{0x91, 0x11, 0x44, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x11, 0x14, 0x01, 0xE2, 0x02, 0x82, 0x10},
+	{0x91, 0x11, 0x18, 0x00, 0x00, 0x00, 0x00, 0x10},
+//      
+	{0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10},
+	{0xC1, 0x11, 0x25, 0x00, 0x61, 0xA8, 0x00, 0x10},
+	{0xA1, 0x11, 0x30, 0x22, 0x00, 0x00, 0x00, 0x10},
+	{0xC1, 0x11, 0x31, 0x20, 0x2E, 0x20, 0x00, 0x10},
+	{0xC1, 0x11, 0x25, 0x00, 0xC3, 0x50, 0x00, 0x10},
+	{0xA1, 0x11, 0x30, 0x07, 0x00, 0x00, 0x00, 0x10},	//gain14
+	{0xC1, 0x11, 0x31, 0x10, 0x10, 0x10, 0x00, 0x10},	//r g b 101a10       
+//
+	{0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x21, 0xD0, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x22, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x23, 0x09, 0x00, 0x00, 0x00, 0x10},
+//
+	{0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x21, 0xD0, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x22, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xA1, 0x11, 0x23, 0x10, 0x00, 0x00, 0x00, 0x10},
+	{0, 0, 0, 0, 0, 0, 0, 0}
+};
+static __u8 mi0360_sensor_init[][8] = {
+	{0xB1, 0x5D, 0x07, 0x00, 0x02, 0x00, 0x00, 0x10},
+	{0xB1, 0x5D, 0x0D, 0x00, 0x01, 0x00, 0x00, 0x10},
+	{0xB1, 0x5D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x01, 0x00, 0x08, 0x00, 0x16, 0x10},
+	{0xD1, 0x5D, 0x03, 0x01, 0xE2, 0x02, 0x82, 0x10},
+	{0xD1, 0x5D, 0x05, 0x00, 0x09, 0x00, 0x53, 0x10},
+	{0xB1, 0x5D, 0x0D, 0x00, 0x02, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x14, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x16, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x18, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xB1, 0x5D, 0x32, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x20, 0x91, 0x01, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x22, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x24, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x26, 0x00, 0x00, 0x00, 0x24, 0x10},
+	{0xD1, 0x5D, 0x2F, 0xF7, 0xB0, 0x00, 0x04, 0x10},
+	{0xD1, 0x5D, 0x31, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x33, 0x00, 0x00, 0x01, 0x00, 0x10},
+	{0xB1, 0x5D, 0x3D, 0x06, 0x8F, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x40, 0x01, 0xE0, 0x00, 0xD1, 0x10},
+	{0xB1, 0x5D, 0x44, 0x00, 0x82, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x58, 0x00, 0x78, 0x00, 0x43, 0x10},
+	{0xD1, 0x5D, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x5E, 0x00, 0x00, 0xA3, 0x1D, 0x10},
+	{0xB1, 0x5D, 0x62, 0x04, 0x11, 0x00, 0x00, 0x10},
+
+	{0xB1, 0x5D, 0x20, 0x91, 0x01, 0x00, 0x00, 0x10},
+	{0xB1, 0x5D, 0x20, 0x11, 0x01, 0x00, 0x00, 0x10},
+	{0xB1, 0x5D, 0x09, 0x00, 0x64, 0x00, 0x00, 0x10},
+	{0xD1, 0x5D, 0x2B, 0x00, 0xA0, 0x00, 0xB0, 0x10},
+	{0xD1, 0x5D, 0x2D, 0x00, 0xA0, 0x00, 0xA0, 0x10},
+
+	{0xB1, 0x5D, 0x0A, 0x00, 0x02, 0x00, 0x00, 0x10},	//sensor clck ?2
+	{0xB1, 0x5D, 0x06, 0x00, 0x30, 0x00, 0x00, 0x10},
+	{0xB1, 0x5D, 0x05, 0x00, 0x0A, 0x00, 0x00, 0x10},
+	{0xB1, 0x5D, 0x09, 0x02, 0x35, 0x00, 0x00, 0x10},	// exposure 2
+
+	{0xD1, 0x5D, 0x2B, 0x00, 0xB9, 0x00, 0xE3, 0x10},
+	{0xD1, 0x5D, 0x2D, 0x00, 0x5f, 0x00, 0xB9, 0x10}, //42
+	//{0xB1, 0x5D, 0x35, 0x00, 0x67, 0x00, 0x00, 0x10},  //gain orig
+	//{0xB1, 0x5D, 0x35, 0x00, 0x20, 0x00, 0x00, 0x10},  //gain 
+	{0xB1, 0x5D, 0x07, 0x00, 0x03, 0x00, 0x00, 0x10},	//update
+	{0xB1, 0x5D, 0x07, 0x00, 0x02, 0x00, 0x00, 0x10},	//sensor on
+	{0, 0, 0, 0, 0, 0, 0, 0}
+};
+static __u8 mo4000_sensor_init[][8] = {
+	{0xa1, 0x21, 0x01, 0x02, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x04, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x05, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x05, 0x04, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x06, 0x80, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x06, 0x81, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x11, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x11, 0x20, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x11, 0x30, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x11, 0x38, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x11, 0x38, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x12, 0x00, 0x00, 0x00, 0x00, 0x10},
+ 	{0xa1, 0x21, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10},
+ 	{0xa1, 0x21, 0x0f, 0x20, 0x00, 0x00, 0x00, 0x10},
+ 	{0xa1, 0x21, 0x10, 0x20, 0x00, 0x00, 0x00, 0x10},
+ 	{0xa1, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
+ 	{0xa1, 0x21, 0x11, 0x38, 0x00, 0x00, 0x00, 0x10},
+	{0, 0, 0, 0, 0, 0, 0, 0}
+};
+static __u8 ov7660_sensor_init[][8] = {
+{0xa1, 0x21, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10},//reset SCCB
+{0xa1, 0x21, 0x12, 0x05, 0x00, 0x00, 0x00, 0x10},//  Outformat ?? rawRGB
+	{0xa1, 0x21, 0x13, 0xb8, 0x00, 0x00, 0x00, 0x10}, //init COM8
+//{0xd1, 0x21, 0x00, 0x01, 0x74, 0x92, 0x00, 0x10}, //GAIN BLUE RED VREF
+{0xd1, 0x21, 0x00, 0x01, 0x74, 0x74, 0x00, 0x10}, //GAIN BLUE RED VREF
+{0xd1, 0x21, 0x04, 0x00, 0x7d, 0x62, 0x00, 0x10},//COM 1 BAVE GEAVE AECHH
+{0xb1, 0x21, 0x08, 0x83, 0x01, 0x00, 0x00, 0x10},//RAVE COM2
+{0xd1, 0x21, 0x0c, 0x00, 0x08, 0x04, 0x4f, 0x10},//COM 3 4 5 6
+//	{0xd1, 0x21, 0x10, 0x7f, 0x40, 0x05, 0xf8, 0x10},//AECH CLKRC COM7 COM8
+{0xd1, 0x21, 0x10, 0x7f, 0x40, 0x05, 0xff, 0x10},//AECH CLKRC COM7 COM8
+{0xc1, 0x21, 0x14, 0x2c, 0x00, 0x02, 0x00, 0x10}, // COM9 COM10
+{0xd1, 0x21, 0x17, 0x10, 0x60, 0x02, 0x7b, 0x10},//HSTART HSTOP VSTRT VSTOP
+{0xa1, 0x21, 0x1b, 0x02, 0x00, 0x00, 0x00, 0x10},//PSHFT
+{0xb1, 0x21, 0x1e, 0x01, 0x0e, 0x00, 0x00, 0x10}, //MVFP LAEC
+{0xd1, 0x21, 0x20, 0x07, 0x07, 0x07, 0x07, 0x10},// BOS GBOS GROS ROS (BGGR offset)
+//	{0xd1, 0x21, 0x24, 0x68, 0x58, 0xd4, 0x80, 0x10}, //AEW AEB VPT BBIAS
+{0xd1, 0x21, 0x24, 0x78, 0x68, 0xd4, 0x80, 0x10}, //AEW AEB VPT BBIAS
+{0xd1, 0x21, 0x28, 0x80, 0x30, 0x00, 0x00, 0x10}, //GbBIAS RSVD EXHCH EXHCL
+{0xd1, 0x21, 0x2c, 0x80, 0x00, 0x00, 0x62, 0x10}, //RBIAS ADVFL ASDVFH YAVE
+{0xc1, 0x21, 0x30, 0x08, 0x30, 0xb4, 0x00, 0x10}, //HSYST HSYEN HREF 
+{0xd1, 0x21, 0x33, 0x00, 0x07, 0x84, 0x00, 0x10}, //reserved
+{0xd1, 0x21, 0x37, 0x0c, 0x02, 0x43, 0x00, 0x10}, //ADC ACOM OFON TSLB
+{0xd1, 0x21, 0x3b, 0x02, 0x6c, 0x19, 0x0e, 0x10}, //COM11 COM12 COM13 COM14
+{0xd1, 0x21, 0x3f, 0x41, 0xc1, 0x22, 0x08, 0x10}, //EDGE COM15 COM16 COM17
+{0xd1, 0x21, 0x43, 0xf0, 0x10, 0x78, 0xa8, 0x10}, //reserved
+{0xd1, 0x21, 0x47, 0x60, 0x80, 0x00, 0x00, 0x10}, //reserved
+{0xd1, 0x21, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x10}, //reserved
+{0xd1, 0x21, 0x4f, 0x46, 0x36, 0x0f, 0x17, 0x10}, //MTX 1 2 3 4
+{0xd1, 0x21, 0x53, 0x7f, 0x96, 0x40, 0x40, 0x10}, //MTX 5 6 7 8
+{0xb1, 0x21, 0x57, 0x40, 0x0f, 0x00, 0x00, 0x10}, //MTX9 MTXS
+{0xd1, 0x21, 0x59, 0xba, 0x9a, 0x22, 0xb9, 0x10}, //reserved
+{0xd1, 0x21, 0x5d, 0x9b, 0x10, 0xf0, 0x05, 0x10}, //reserved
+{0xa1, 0x21, 0x61, 0x60, 0x00, 0x00, 0x00, 0x10}, //reserved
+{0xd1, 0x21, 0x62, 0x00, 0x00, 0x50, 0x30, 0x10}, //LCC1 LCC2 LCC3 LCC4
+{0xa1, 0x21, 0x66, 0x00, 0x00, 0x00, 0x00, 0x10}, //LCC5 
+{0xd1, 0x21, 0x67, 0x80, 0x7a, 0x90, 0x80, 0x10},
+{0xa1, 0x21, 0x6b, 0x0a, 0x00, 0x00, 0x00, 0x10}, //band gap reference [0..3] DBLV
+{0xd1, 0x21, 0x6c, 0x30, 0x48, 0x80, 0x74, 0x10}, //gamma curve
+{0xd1, 0x21, 0x70, 0x64, 0x60, 0x5c, 0x58, 0x10}, //gamma curve
+{0xd1, 0x21, 0x74, 0x54, 0x4c, 0x40, 0x38, 0x10}, //gamma curve
+{0xd1, 0x21, 0x78, 0x34, 0x30, 0x2f, 0x2b, 0x10}, //gamma curve
+{0xd1, 0x21, 0x7c, 0x03, 0x07, 0x17, 0x34, 0x10}, //gamma curve
+{0xd1, 0x21, 0x80, 0x41, 0x4d, 0x58, 0x63, 0x10}, //gamma curve
+{0xd1, 0x21, 0x84, 0x6e, 0x77, 0x87, 0x95, 0x10}, //gamma curve
+{0xc1, 0x21, 0x88, 0xaf, 0xc7, 0xdf, 0x00, 0x10}, //gamma curve
+{0xc1, 0x21, 0x8b, 0x99, 0x99, 0xcf, 0x00, 0x10}, //reserved
+{0xb1, 0x21, 0x92, 0x00, 0x00, 0x00, 0x00, 0x10},
+/*******************/
+{0xa1, 0x21, 0x1e, 0x01, 0x00, 0x00, 0x00, 0x10},//bits[3..0]reserved
+{0xa1, 0x21, 0x1e, 0x01, 0x00, 0x00, 0x00, 0x10},
+{0xa1, 0x21, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10}, //VREF vertical frame ctrl
+{0xa1, 0x21, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x10, 0x20, 0x00, 0x00, 0x00, 0x10}, //0x20
+{0xa1, 0x21, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x10},
+{0xa1, 0x21, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x10},
+	{0xa1, 0x21, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x10},
+//{0xb1, 0x21, 0x01, 0x78, 0x78, 0x00, 0x00, 0x10},
+/******************/
+{0xa1, 0x21, 0x93, 0x00, 0x00, 0x00, 0x00, 0x10},//dummy line hight
+{0xa1, 0x21, 0x92, 0x25, 0x00, 0x00, 0x00, 0x10},//dummy line low
+{0xa1, 0x21, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x10},
+{0xa1, 0x21, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x10},
+	//{0xa1, 0x21, 0x02, 0x90, 0x00, 0x00, 0x00, 0x10},
+/**********startsensor boum if changed !!****/
+{0xa1, 0x21, 0x93, 0x01, 0x00, 0x00, 0x00, 0x10},
+{0xa1, 0x21, 0x92, 0xff, 0x00, 0x00, 0x00, 0x10},
+{0xa1, 0x21, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x10},
+{0xa1, 0x21, 0x2b, 0xc3, 0x00, 0x00, 0x00, 0x10},
+{0, 0, 0, 0, 0, 0, 0, 0}
+};
+//		reg0x04		reg0x07		reg 0x10
+//expo  = (COM1 & 0x02) | (AECHH & 0x2f <<10) [ (AECh << 2)
+
+#if 0
+static __u8 qtable1[] = {
+	0x0B, 0x07, 0x07, 0x0B, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0E, 0x0B,
+	0x0B, 0x0E, 0x12, 0x1D,
+	0x12, 0x12, 0x0E, 0x0E, 0x12, 0x24, 0x19, 0x19, 0x15, 0x1D, 0x2B, 0x24,
+	0x2B, 0x2B, 0x27, 0x24,
+	0x27, 0x27, 0x2F, 0x32, 0x40, 0x39, 0x2F, 0x32, 0x3D, 0x32, 0x27, 0x27,
+	0x39, 0x4F, 0x39, 0x3D,
+	0x44, 0x48, 0x4B, 0x4B, 0x4B, 0x2B, 0x36, 0x52, 0x56, 0x4F, 0x48, 0x56,
+	0x40, 0x48, 0x4B, 0x48,
+	0x0B, 0x0E, 0x0E, 0x12, 0x0E, 0x12, 0x20, 0x12, 0x12, 0x20, 0x48, 0x2F,
+	0x27, 0x2F, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48
+};
+static __u8 qtable2[] = {
+	0x09, 0x06, 0x06, 0x09, 0x06, 0x06, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x09,
+	0x09, 0x0C, 0x0F, 0x18,
+	0x0F, 0x0F, 0x0C, 0x0C, 0x0F, 0x1E, 0x15, 0x15, 0x12, 0x18, 0x24, 0x1E,
+	0x24, 0x24, 0x21, 0x1E,
+	0x21, 0x21, 0x27, 0x2A, 0x36, 0x30, 0x27, 0x2A, 0x33, 0x2A, 0x21, 0x21,
+	0x30, 0x42, 0x30, 0x33,
+	0x39, 0x3C, 0x3F, 0x3F, 0x3F, 0x24, 0x2D, 0x45, 0x48, 0x42, 0x3C, 0x48,
+	0x36, 0x3C, 0x3F, 0x3C,
+	0x09, 0x0C, 0x0C, 0x0F, 0x0C, 0x0F, 0x1B, 0x0F, 0x0F, 0x1B, 0x3C, 0x27,
+	0x21, 0x27, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C
+};
+static __u8 qtable3[] = {
+	0x07, 0x05, 0x05, 0x07, 0x05, 0x05, 0x07, 0x07, 0x07, 0x07, 0x0A, 0x07,
+	0x07, 0x0A, 0x0C, 0x14,
+	0x0C, 0x0C, 0x0A, 0x0A, 0x0C, 0x19, 0x11, 0x11, 0x0F, 0x14, 0x1E, 0x19,
+	0x1E, 0x1E, 0x1B, 0x19,
+	0x1B, 0x1B, 0x20, 0x23, 0x2D, 0x28, 0x20, 0x23, 0x2A, 0x23, 0x1B, 0x1B,
+	0x28, 0x37, 0x28, 0x2A,
+	0x2F, 0x32, 0x34, 0x34, 0x34, 0x1E, 0x25, 0x39, 0x3C, 0x37, 0x32, 0x3C,
+	0x2D, 0x32, 0x34, 0x32,
+	0x07, 0x0A, 0x0A, 0x0C, 0x0A, 0x0C, 0x16, 0x0C, 0x0C, 0x16, 0x32, 0x20,
+	0x1B, 0x20, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32
+};
+
+#endif
+static __u8 qtable4[] = {
+	0x06, 0x04, 0x04, 0x06, 0x04, 0x04, 0x06, 0x06, 0x06, 0x06, 0x08, 0x06,
+	0x06, 0x08, 0x0A, 0x11,
+	0x0A, 0x0A, 0x08, 0x08, 0x0A, 0x15, 0x0F, 0x0F, 0x0C, 0x11, 0x19, 0x15,
+	0x19, 0x19, 0x17, 0x15,
+	0x17, 0x17, 0x1B, 0x1D, 0x25, 0x21, 0x1B, 0x1D, 0x23, 0x1D, 0x17, 0x17,
+	0x21, 0x2E, 0x21, 0x23,
+	0x27, 0x29, 0x2C, 0x2C, 0x2C, 0x19, 0x1F, 0x30, 0x32, 0x2E, 0x29, 0x32,
+	0x25, 0x29, 0x2C, 0x29,
+	0x06, 0x08, 0x08, 0x0A, 0x08, 0x0A, 0x13, 0x0A, 0x0A, 0x13, 0x29, 0x1B,
+	0x17, 0x1B, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29
+};
+
+#if 0
+static __u8 qtable5[] = {
+	0x05, 0x03, 0x03, 0x05, 0x03, 0x03, 0x05, 0x05, 0x05, 0x05, 0x07, 0x05,
+	0x05, 0x07, 0x09, 0x0E,
+	0x09, 0x09, 0x07, 0x07, 0x09, 0x11, 0x0C, 0x0C, 0x0A, 0x0E, 0x15, 0x11,
+	0x15, 0x15, 0x13, 0x11,
+	0x13, 0x13, 0x16, 0x18, 0x1F, 0x1C, 0x16, 0x18, 0x1D, 0x18, 0x13, 0x13,
+	0x1C, 0x26, 0x1C, 0x1D,
+	0x21, 0x23, 0x24, 0x24, 0x24, 0x15, 0x1A, 0x28, 0x29, 0x26, 0x23, 0x29,
+	0x1F, 0x23, 0x24, 0x23,
+	0x05, 0x07, 0x07, 0x09, 0x07, 0x09, 0x10, 0x09, 0x09, 0x10, 0x23, 0x16,
+	0x13, 0x16, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23
+};
+static __u8 qtable6[] = {
+	0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x06, 0x04,
+	0x04, 0x06, 0x07, 0x0C,
+	0x07, 0x07, 0x06, 0x06, 0x07, 0x0E, 0x0A, 0x0A, 0x09, 0x0C, 0x11, 0x0E,
+	0x11, 0x11, 0x10, 0x0E,
+	0x10, 0x10, 0x13, 0x14, 0x1A, 0x17, 0x13, 0x14, 0x18, 0x14, 0x10, 0x10,
+	0x17, 0x20, 0x17, 0x18,
+	0x1B, 0x1D, 0x1E, 0x1E, 0x1E, 0x11, 0x16, 0x21, 0x23, 0x20, 0x1D, 0x23,
+	0x1A, 0x1D, 0x1E, 0x1D,
+	0x04, 0x06, 0x06, 0x07, 0x06, 0x07, 0x0D, 0x07, 0x07, 0x0D, 0x1D, 0x13,
+	0x10, 0x13, 0x1D, 0x1D,
+	0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
+	0x1D, 0x1D, 0x1D, 0x1D,
+	0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
+	0x1D, 0x1D, 0x1D, 0x1D,
+	0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
+	0x1D, 0x1D, 0x1D, 0x1D
+};
+static __u8 qtable7[] = {
+	0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x05, 0x04,
+	0x04, 0x05, 0x06, 0x0A,
+	0x06, 0x06, 0x05, 0x05, 0x06, 0x0C, 0x08, 0x08, 0x07, 0x0A, 0x0E, 0x0C,
+	0x0E, 0x0E, 0x0D, 0x0C,
+	0x0D, 0x0D, 0x10, 0x11, 0x16, 0x13, 0x10, 0x11, 0x14, 0x11, 0x0D, 0x0D,
+	0x13, 0x1A, 0x13, 0x14,
+	0x17, 0x18, 0x19, 0x19, 0x19, 0x0E, 0x12, 0x1C, 0x1D, 0x1A, 0x18, 0x1D,
+	0x16, 0x18, 0x19, 0x18,
+	0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x0B, 0x06, 0x06, 0x0B, 0x18, 0x10,
+	0x0D, 0x10, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18
+};
+static __u8 qtable8[] = {
+	0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x03,
+	0x03, 0x04, 0x05, 0x08,
+	0x05, 0x05, 0x04, 0x04, 0x05, 0x0A, 0x07, 0x07, 0x06, 0x08, 0x0C, 0x0A,
+	0x0C, 0x0C, 0x0B, 0x0A,
+	0x0B, 0x0B, 0x0D, 0x0E, 0x12, 0x10, 0x0D, 0x0E, 0x11, 0x0E, 0x0B, 0x0B,
+	0x10, 0x16, 0x10, 0x11,
+	0x13, 0x14, 0x15, 0x15, 0x15, 0x0C, 0x0F, 0x17, 0x18, 0x16, 0x14, 0x18,
+	0x12, 0x14, 0x15, 0x14,
+	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09, 0x14, 0x0D,
+	0x0B, 0x0D, 0x14, 0x14,
+	0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+	0x14, 0x14, 0x14, 0x14,
+	0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+	0x14, 0x14, 0x14, 0x14,
+	0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+	0x14, 0x14, 0x14, 0x14
+};
+
+static int
+sn9c102p_status(struct usb_device *dev)
+{
+	__u8 status = 0;
+	__u8 count = 10;
+	while (count--) {
+		status = 0;
+		sonixRegRead(dev, 0x00, 0x08, 0x0000, &status, 1);
+		if (status & 0x04)
+			return 0;
+		if (status & 0x08)
+			return -EIO;
+		wait_ms(1);
+	}
+	return -ETIMEDOUT;
+}
+#endif
+static int
+sn9c102p_i2cwrite(struct usb_spca50x *spca50x, __u8 * buffer, __u16 length)
+{
+	struct usb_device *dev = spca50x->dev;
+	__u8 mode[] = { 0x81, 0x11, 0, 0, 0, 0, 0, 0x10 };
+	/* is i2c ready */
+	__u8 i2cbase = spca50x->i2c_base;
+	__u8 i2cCtrl = spca50x->i2c_ctrl_reg;
+	mode[0] = i2cCtrl;
+	mode[1] = i2cbase;
+	if (length > 5 || !buffer)
+		return -1;
+	mode[0] = mode[0] | length << 4;
+	memcpy(&mode[2], buffer, length);
+	sonixRegWrite(dev, 0x08, 0x08, 0x0000, mode, 8);
+	return 0;
+}
+
+static void
+sn9c102p_i2cwritebuf(struct usb_device *dev, __u8 * buffer)
+{
+	sonixRegWrite(dev, 0x08, 0x08, 0x0000, buffer, 8);
+	wait_ms(1);
+}
+
+static int
+sn9c102p_i2cread(struct usb_spca50x *spca50x, __u8 reg,
+		 __u8 * buffer, __u16 length)
+{
+	struct usb_device *dev = spca50x->dev;
+	__u8 i2cbase = spca50x->i2c_base;
+	__u8 i2cCtrl = spca50x->i2c_ctrl_reg;
+	int err = 0;
+	__u8 mode[] = { 0x91, 0x11, 0, 0, 0, 0, 0, 0x10 };
+	__u8 result[] = { 0, 0, 0, 0, 0 };
+	mode[0] = i2cCtrl | 0x10;
+	mode[1] = i2cbase;
+	if (length > 5 || !buffer)
+		return -1;
+	mode[2] = reg;
+	sonixRegWrite(dev, 0x08, 0x08, 0x0000, mode, 8);
+	wait_ms(1);
+	mode[2] = 0;
+	mode[0] = i2cCtrl | length << 4 | 0x02;
+	sonixRegWrite(dev, 0x08, 0x08, 0x0000, mode, 8);
+	wait_ms(1);
+	sonixRegRead(dev, 0x00, 0x0a, 0x0000, result, 5);
+	memcpy(buffer, result, length);
+	return err;
+}
+
+static int
+sn9cxxx_probesensor(struct usb_spca50x *spca50x)
+{
+	struct usb_device *dev = spca50x->dev;
+	int err = 0;
+	__u8 reg02 = 0x66;
+	/* reg val1 val2 val3 val4 */
+	__u8 datasend[] = { 0, 0, 0, 0, 0 };
+	__u8 datarecd[] = { 0, 0, 0, 0, 0 };
+	datasend[0] = 2;	//sensor wakeup
+	err = sn9c102p_i2cwrite(spca50x, datasend, 2);
+	//should write 0xa1 0x11 0x02 0x00 0x00 0x00 0x00 the 0x10 is add by i2cw
+	wait_ms(10);
+	sonixRegWrite(dev, 0x08, 0x02, 0x0000, &reg02, 1);	//Gpio on
+	wait_ms(10);
+	err += sn9c102p_i2cread(spca50x, 0, datarecd, 5);	//read sensor id
+	if (err)
+		goto errors;
+	if (datarecd[0] == 0x02 && datarecd[1] == 0x09 && datarecd[2] == 0x01
+	    && datarecd[3] == 0x00 && datarecd[4] == 0x00) {
+		PDEBUG(1, "Find Sensor sn9c102P HV7131R");
+		spca50x->sensor = SENSOR_HV7131R;
+		return SENSOR_HV7131R;
+	}
+	PDEBUG(0, "Find Sensor %d %d %d", datarecd[0], datarecd[1],
+	       datarecd[2]);
+	PDEBUG(0, "Sensor sn9c102P Not found Contact mxhaard@free.fr ");
+	return -ENODEV;
+      errors:PDEBUG(0,
+	       "Sensor sn9c102P too many errors Contact mxhaard@free.fr ");
+	return -ENODEV;
+}
+
+static void
+hv7131R_InitSensor(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	struct usb_device *dev = spca50x->dev;
+	__u8 SetSensorClk[] = { 0xA1, 0x11, 0x01, 0x18, 0x00, 0x00, 0x00, 0x10 };	//0x08 Mclk
+
+	while (hv7131r_sensor_init[i][0]) {
+		sn9c102p_i2cwritebuf(dev, hv7131r_sensor_init[i]);
+		i++;
+	}
+	sn9c102p_i2cwritebuf(dev, SetSensorClk);
+}
+static void
+mi0360_InitSensor(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	struct usb_device *dev = spca50x->dev;
+
+	while (mi0360_sensor_init[i][0]) {
+		sn9c102p_i2cwritebuf(dev, mi0360_sensor_init[i]);
+		i++;
+	}
+}
+static void
+mo4000_InitSensor(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	struct usb_device *dev = spca50x->dev;
+
+	while (mo4000_sensor_init[i][0]) {
+		sn9c102p_i2cwritebuf(dev, mo4000_sensor_init[i]);
+		i++;
+	}
+}
+static void
+ov7660_InitSensor(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	struct usb_device *dev = spca50x->dev;
+
+	while (ov7660_sensor_init[i][0]) {
+		sn9c102p_i2cwritebuf(dev, ov7660_sensor_init[i]);
+		i++;
+	}
+}
+static int
+sn9cxxx_init(struct usb_spca50x *spca50x)
+{
+	struct usb_device *dev = spca50x->dev;
+	int err = 0;
+	__u8 *sn9c1xx = NULL;
+	__u8 regF1 = 0x01;
+	__u8 regGpio[] = { 0x29, 0x74 };
+	__u8 data = 0x00;
+	/* setup a selector by customid */
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		sn9c1xx = sn_hv7131;
+		break;
+	case SENSOR_MI0360:
+		sn9c1xx = sn_mi0360;
+		break;
+	case SENSOR_MO4000:
+		sn9c1xx = sn_mo4000;
+		break;
+	case SENSOR_OV7660:
+		sn9c1xx = sn_ov7660;
+		break;
+	}
+	if (sn9c1xx == NULL)
+		return -ENODEV;
+	sonixRegWrite(dev, 0x08, 0xf1, 0x0000, &regF1, 1);
+	sonixRegRead(dev, 0x00, 0x00, 0x0000, &regF1, 1);
+	sonixRegWrite(dev, 0x08, 0xf1, 0x0000, &regF1, 1);
+	sonixRegRead(dev, 0x00, 0x00, 0x0000, &regF1, 1);
+	switch (spca50x->customid) {
+	case SN9C102P:
+		if (regF1 != 0x11)
+			return -ENODEV;
+		sonixRegWrite(dev, 0x08, 0x02, 0x0000, &regGpio[1], 1);
+	case SN9C105:
+		if (regF1 != 0x11)
+			return -ENODEV;
+		sonixRegWrite(dev, 0x08, 0x02, 0x0000, regGpio, 2);
+		break;
+	case SN9C110:
+		if (regF1 != 0x12)
+			return -ENODEV;
+		regGpio[1] = 0x62;
+		sonixRegWrite(dev, 0x08, 0x02, 0x0000, &regGpio[1], 1);
+		break;
+		break;
+	case SN9C120:
+		if (regF1 != 0x12)
+			return -ENODEV;
+		regGpio[1] = 0x70;
+		sonixRegWrite(dev, 0x08, 0x02, 0x0000, regGpio, 2);
+		break;
+	}
+
+	regF1 = 0x01;
+	sonixRegWrite(dev, 0x08, 0xf1, 0x0000, &regF1, 1);
+
+	regF1 = 0x00;
+	sonixRegWrite(dev, 0x08, 0xf1, 0x0000, &regF1, 1);
+
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &sn9c1xx[1], 1);
+
+	// configure gpio 
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &sn9c1xx[1], 2);
+
+	sonixRegWrite(dev, 0x08, 0x08, 0x0000, &sn9c1xx[8], 2);
+
+	sonixRegWrite(dev, 0x08, 0x017, 0x0000, &sn9c1xx[0x17], 3);
+
+	sonixRegWrite(dev, 0x08, 0x9a, 0x0000, reg9a, 6);
+
+	data = 0x60;
+	sonixRegWrite(dev, 0x08, 0xD4, 0x0000, &data, 1);
+
+	sonixRegWrite(dev, 0x08, 0x03, 0x0000, &sn9c1xx[3], 0x0f);
+
+	data = 0x43;
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &data, 1);
+
+	data = 0x61;
+	sonixRegWrite(dev, 0x08, 0x17, 0x0000, &data, 1);
+
+	data = 0x42;
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &data, 1);
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		// probe sensor
+		if ((err = sn9cxxx_probesensor(spca50x)) < 0)
+			return -ENODEV;
+		break;
+	}
+
+	return 0;
+}
+static void
+sn9cxxx_stopN(struct usb_spca50x *spca50x)
+{
+	struct usb_device *dev = spca50x->dev;
+	__u8 stophv7131[] = { 0xA1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10 };
+	__u8 stopmi0360[] = { 0xB1, 0x5D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10 };
+	__u8 regF1 = 0x01;
+	__u8 data = 0x0b;
+	__u8 *sn9c1xx = NULL;
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		sn9c1xx = sn_hv7131;
+		data = 0x2b;
+		sn9c102p_i2cwritebuf(dev, stophv7131);
+		break;
+	case SENSOR_MI0360:
+		sn9c1xx = sn_mi0360;
+		data = 0x29;
+		sn9c102p_i2cwritebuf(dev, stopmi0360);
+		break;
+	case SENSOR_MO4000:
+		sn9c1xx = sn_mo4000;
+		break;
+	case SENSOR_OV7660:
+		sn9c1xx = sn_ov7660;
+		break;
+	}
+	if (sn9c1xx == NULL)
+		return;
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &sn9c1xx[1], 1);
+	sonixRegWrite(dev, 0x08, 0x17, 0x0000, &sn9c1xx[0x17], 1);
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &sn9c1xx[1], 1);
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &data, 1);
+	sonixRegWrite(dev, 0x08, 0xf1, 0x0000, &regF1, 1);
+}
+static void
+sn9cxxx_start(struct usb_spca50x *spca50x)
+{
+	struct usb_device *dev = spca50x->dev;
+	int i;
+	__u8 DC29[] = { 0x6a, 0x50, 0x00, 0x00, 0x50, 0x3c };
+	__u8 C0[] = { 0x2d, 0x2d, 0x3a, 0x05, 0x04, 0x3f };
+	__u8 CA[] = { 0x28, 0xd8, 0x14, 0xec };
+	__u8 CE[] = { 0x32, 0xdd, 0x2d, 0xdd };	//MI0360
+	__u8 data = 0;
+	__u8 regF1 = 0x00;
+	__u8 reg17 = 0x61;
+	__u8 reg1 = 0x02;
+	int err = 0;
+	__u8 *sn9c1xx = NULL;
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		sn9c1xx = sn_hv7131;
+		break;
+	case SENSOR_MI0360:
+		sn9c1xx = sn_mi0360;
+		break;
+	case SENSOR_MO4000:
+		sn9c1xx = sn_mo4000;
+		break;
+	case SENSOR_OV7660:
+		sn9c1xx = sn_ov7660;
+		break;
+	}
+	if (sn9c1xx == NULL)
+		return;
+	sonixRegWrite(dev, 0x08, 0xf1, 0x0000, &regF1, 1);
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &sn9c1xx[1], 1);
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &sn9c1xx[1], 2);
+	sonixRegWrite(dev, 0x08, 0x08, 0x0000, &sn9c1xx[8], 2);
+	sonixRegWrite(dev, 0x08, 0x17, 0x0000, &sn9c1xx[0x17], 3);
+
+	sonixRegWrite(dev, 0x08, 0x9a, 0x0000, reg9a, 6);
+	data = 0x60;
+	sonixRegWrite(dev, 0x08, 0xD4, 0x0000, &data, 1);
+
+	sonixRegWrite(dev, 0x08, 0x03, 0x0000, &sn9c1xx[3], 0x0f);
+	data = 0x43;
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &data, 1);
+	data = 0x61;
+	sonixRegWrite(dev, 0x08, 0x17, 0x0000, &data, 1);
+	data = 0x42;
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &data, 1);
+
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		if ((err = sn9cxxx_probesensor(spca50x)) < 0)
+			return;
+		break;
+	}
+
+	sonixRegWrite(dev, 0x08, 0x15, 0x0000, &sn9c1xx[0x15], 1);
+	sonixRegWrite(dev, 0x08, 0x16, 0x0000, &sn9c1xx[0x16], 1);
+	sonixRegWrite(dev, 0x08, 0x12, 0x0000, &sn9c1xx[0x12], 1);
+	sonixRegWrite(dev, 0x08, 0x13, 0x0000, &sn9c1xx[0x13], 1);
+	sonixRegWrite(dev, 0x08, 0x18, 0x0000, &sn9c1xx[0x18], 1);
+	sonixRegWrite(dev, 0x08, 0xd2, 0x0000, &DC29[0], 1);
+	sonixRegWrite(dev, 0x08, 0xd3, 0x0000, &DC29[1], 1);
+	sonixRegWrite(dev, 0x08, 0xc6, 0x0000, &DC29[2], 1);
+	sonixRegWrite(dev, 0x08, 0xc7, 0x0000, &DC29[3], 1);
+	sonixRegWrite(dev, 0x08, 0xc8, 0x0000, &DC29[4], 1);
+	sonixRegWrite(dev, 0x08, 0xc9, 0x0000, &DC29[5], 1);
+	sonixRegWrite(dev, 0x08, 0x18, 0x0000, &sn9c1xx[0x18], 1);
+	data = 0x60;
+	sonixRegWrite(dev, 0x08, 0x17, 0x0000, &data, 1);
+	sonixRegWrite(dev, 0x08, 0x05, 0x0000, &sn9c1xx[5], 1);
+	sonixRegWrite(dev, 0x08, 0x07, 0x0000, &sn9c1xx[7], 1);
+	sonixRegWrite(dev, 0x08, 0x06, 0x0000, &sn9c1xx[6], 1);
+	sonixRegWrite(dev, 0x08, 0x14, 0x0000, &sn9c1xx[0x14], 1);
+	sonixRegWrite(dev, 0x08, 0x20, 0x0000, regsn20, 0x11);
+	for (i = 0; i < 8; i++)
+		sonixRegWrite(dev, 0x08, 0x84, 0x0000, reg84, 0x15);
+	data = 0x08;
+	sonixRegWrite(dev, 0x08, 0x9a, 0x0000, &data, 1);
+	data = 0x59;
+	sonixRegWrite(dev, 0x08, 0x99, 0x0000, &data, 1);
+
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		hv7131R_InitSensor(spca50x);
+		if (spca50x->mode)
+		reg1 = 0x46;	//320 clk 48Mhz
+	else {
+		reg1 = 0x06;	//640 clk 24Mz
+	}
+		break;
+	case SENSOR_MI0360:
+		mi0360_InitSensor(spca50x);
+		if (spca50x->mode)
+		reg1 = 0x46;	//320 clk 48Mhz
+	else {
+		reg1 = 0x06;	//640 clk 24Mz
+	}
+		break;
+	case SENSOR_MO4000:
+		mo4000_InitSensor(spca50x);
+		if (spca50x->mode)
+		//reg1 = 0x46;	//320 clk 48Mhz 60fp/s
+		reg1 = 0x06;	// clk 24Mz
+	else {
+		reg17 = 0x22;	//640 MCKSIZE
+		reg1 = 0x06;	//640 clk 24Mz
+	}
+		break;
+	case SENSOR_OV7660:
+		//reg1 = 0x44;
+		reg1 = 0x46;
+	ov7660_InitSensor(spca50x);
+	if (spca50x->mode){
+		//reg17 = 0x21;	//320 
+		reg1 = 0x46;
+	} else {
+		reg17 = 0x22;	//640 MCKSIZE
+		reg1 = 0x06;
+	}
+		
+		break;
+	}
+	sonixRegWrite(dev, 0x08, 0xc0, 0x0000, C0, 6);
+	sonixRegWrite(dev, 0x08, 0xca, 0x0000, CA, 4);
+	sonixRegWrite(dev, 0x08, 0xce, 0x0000, CE, 4);	//?? {0x1e,0xdd,0x2d,0xe7}
+
+	// here change size mode 0 -> VGA; 1 -> CIF
+	data = 0x40 | sn9c1xx[0x18] | (spca50x->mode << 4);
+	sonixRegWrite(dev, 0x08, 0x18, 0x0000, &data, 1);
+
+	sonixRegWrite(dev, 0x08, 0x100, 0x0000, qtable4, 0x40);
+	sonixRegWrite(dev, 0x08, 0x140, 0x0000, qtable4 + 0x40, 0x40);
+
+	data = sn9c1xx[0x18] | (spca50x->mode << 4);
+	sonixRegWrite(dev, 0x08, 0x18, 0x0000, &data, 1);
+
+	sonixRegWrite(dev, 0x08, 0x17, 0x0000, &reg17, 1);
+	
+	sonixRegWrite(dev, 0x08, 0x01, 0x0000, &reg1, 1);
+	
+	sn9cxxx_setbrightness(spca50x);
+	sn9cxxx_setcontrast(spca50x);
+}
+
+
+static unsigned int
+sn9cxxx_getexposure(struct usb_spca50x *spca50x)
+{
+	__u8 hexpo,mexpo,lexpo;
+	__u8 expo[] = { 0, 0, 0, 0, 0 };
+	int err = 0;
+	
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		err += sn9c102p_i2cread(spca50x, 0x25, expo, 5);	//read sensor exposure
+		return (unsigned int) (expo[0] << 16 | expo[1] << 8 | expo[2]);
+	break;
+	case SENSOR_MI0360:
+		err += sn9c102p_i2cread(spca50x, 0x09, expo, 5);	//read sensor exposure
+		return (unsigned int) (expo[0] << 8 | expo[1]);
+	break;
+	case SENSOR_OV7660:
+	case SENSOR_OV7630:
+		err += sn9c102p_i2cread(spca50x, 0x04, expo, 5);	//read sensor exposure
+		hexpo = expo[3] & 0x2f;
+		lexpo = expo[0] & 0x02;
+		err += sn9c102p_i2cread(spca50x, 0x08, expo, 5);	
+		mexpo = expo[2];
+		return (unsigned int) ((hexpo << 10) | (mexpo << 2) | (lexpo));
+	break;
+	case SENSOR_MO4000:
+		err += sn9c102p_i2cread(spca50x, 0x0e, expo, 5);
+		hexpo = 0;// expo[1] & 0x07;
+		mexpo = 0x40;// expo[2] &0xff;
+		lexpo =expo[1] & 0x30 >> 4;
+		PDEBUG(4,"exposure %d",(unsigned int) ((hexpo << 10) | (mexpo << 2) | (lexpo)) );
+		return (unsigned int) ((hexpo << 10) | (mexpo << 2) | (lexpo));
+	break;
+	}
+	return 0;
+}
+
+static unsigned int
+sn9cxxx_setexposure(struct usb_spca50x *spca50x, unsigned int expo)
+{
+	__u8 Expodoit[] = { 0xc1, 0x11, 0x25, 0x07, 0x27, 0xc0, 0x00, 0x16 };
+	__u8 doit[] = { 0xB1, 0x5D, 0x07, 0x00, 0x03, 0x00, 0x00, 0x10 };	//update sensor
+	__u8 sensorgo[] = { 0xB1, 0x5D, 0x07, 0x00, 0x02, 0x00, 0x00, 0x10 };	//sensor on
+	__u8 expoMi[] = { 0xB1, 0x5D, 0x09, 0x06, 0x35, 0x00, 0x00, 0x16 };	// exposure 0x0635 -> 4 fp/s 0x10
+	__u8 expoMof[] = { 0xa1, 0x21, 0x0f, 0x20, 0x00, 0x00, 0x00, 0x10 };
+	__u8 expoMo10[] = { 0xa1, 0x21, 0x10, 0x20, 0x00, 0x00, 0x00, 0x10 };
+	__u8 gainMo[] = { 0xa1, 0x21, 0x00, 0x10, 0x00, 0x00, 0x00, 0x1d };
+	unsigned int expotimes = expo;
+
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		Expodoit[3] = (expotimes >> 16) & 0xff;
+		Expodoit[4] = (expotimes >> 8) & 0xff;
+		Expodoit[5] = (expotimes & 0xff);
+		sn9c102p_i2cwritebuf(spca50x->dev, Expodoit);
+		break;
+	case SENSOR_MI0360:
+		if (expo > 0x0635)
+			expo = 0x0635;
+		if (expo < 0x0001)
+			expo = 0x0001;
+		expoMi[3] = (expo >> 8) & 0xFF;
+		expoMi[4] = expo & 0xff;
+		sn9c102p_i2cwritebuf(spca50x->dev, expoMi);
+		sn9c102p_i2cwritebuf(spca50x->dev, doit);
+		sn9c102p_i2cwritebuf(spca50x->dev, sensorgo);
+		break;
+	case SENSOR_MO4000:
+		if(expo > 0x1fff)
+		 	expo = 0x1fff;
+		 if (expo < 0x0001)
+			expo = 0x0001;
+		expoMof[3] = (expo & 0x03fc) >> 2;
+		sn9c102p_i2cwritebuf(spca50x->dev, expoMof);
+		expoMo10[3] = ((expo & 0x1c00) >> 10) | ((expo & 0x0003) << 4);
+		sn9c102p_i2cwritebuf(spca50x->dev, expoMo10);
+		sn9c102p_i2cwritebuf(spca50x->dev, gainMo);	
+		PDEBUG(4,"set exposure %d ", ((expoMo10[3] & 0x07) << 10) | (expoMof[3] << 2) |((expoMo10[3] & 0x30) >> 4));
+		break;
+	}
+	
+	return expo;
+}
+
+static void
+sn9cxxx_setbrightness(struct usb_spca50x *spca50x)
+{
+	unsigned int expo, expotimesret;
+	__u8 k2;
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		expo = spca50x->brightness << 4;
+		if (expo > 0x002dc6c0)
+			expo = 0x002dc6c0;
+		if (expo < 0x02a0)
+			expo = 0x02a0;
+		expotimesret = sn9cxxx_setexposure(spca50x, expo);
+		spca50x->exposure = expotimesret;
+		break;
+	case SENSOR_MI0360:
+		expo = spca50x->brightness >> 4;
+		expotimesret = sn9cxxx_setexposure(spca50x, expo);
+		spca50x->exposure = expotimesret;
+		break;
+	case SENSOR_MO4000:
+		expo = spca50x->brightness >> 4;
+		expotimesret = sn9cxxx_setexposure(spca50x, expo);
+		spca50x->exposure = expotimesret;
+		break;
+	}
+
+	k2 = spca50x->brightness >> 10;
+	sonixRegWrite(spca50x->dev, 0x08, 0x96, 0x0000, &k2, 1);
+
+}
+
+static __u16
+sn9cxxx_getbrightness(struct usb_spca50x *spca50x)
+{
+	/* hardcoded registers seem not readable */
+	switch (spca50x->sensor) {
+	case SENSOR_HV7131R:
+		//spca50x->brightness = 0x7fff;
+		spca50x->brightness = sn9cxxx_getexposure(spca50x) >> 4;
+		break;
+	case SENSOR_MI0360:
+		spca50x->brightness = sn9cxxx_getexposure(spca50x) << 4;
+		break;
+	case SENSOR_MO4000:
+		//spca50x->brightness = 0x1fff;
+		spca50x->brightness = sn9cxxx_getexposure(spca50x) << 4;
+		break;
+	}
+	return spca50x->brightness;
+}
+
+static void
+sn9cxxx_setcontrast(struct usb_spca50x *spca50x)
+{
+	__u8 k2;
+	__u8 contrast[] = { 0x14, 0x00, 0x28, 0x00, 0x07, 0x00 };
+	k2 = spca50x->contrast >> 8;
+	if (k2 > 0x7f)
+		k2 = 0x7f;
+	contrast[2] = k2;
+	contrast[0] = (k2 + 1) >> 1;
+	contrast[4] = (k2 + 1) / 5;
+	sonixRegWrite(spca50x->dev, 0x08, 0x84, 0x0000, contrast, 6);
+}
+static __u16
+sn9cxxx_getcontrast(struct usb_spca50x *spca50x)
+{
+	/* hardcoded registers seem not readable */
+	spca50x->contrast = 0x3f << 8;	//0x28
+	return spca50x->contrast;
+}
+static int
+sn9cxxx_sofdetect(struct usb_spca50x *spca50x, struct spca50x_frame *frame,
+		  unsigned char *cdata, int *iPix, int seqnum, int *datalength)
+{
+	int sof;
+	sof = *datalength - 64;
+	if (sof < 0) {
+		*iPix = 0;
+		return (seqnum + 1);
+	} else if (cdata[sof] == 0xff && cdata[sof + 1] == 0xd9) {
+		// copy the end of data frame
+		memcpy(frame->highwater, cdata, sof + 2);
+		frame->highwater += (sof + 2);
+		//      totlen += (sof + 2);
+// w1 w2 w3
+// w4 w5 w6
+// w7 w8
+		spin_lock(&spca50x->v4l_lock);
+		spca50x->avg_lum = ((cdata[sof + 29] << 8) | cdata[sof + 30]) >> 6;	//w4
+		spca50x->avg_lum += ((cdata[sof + 33] << 8) | cdata[sof + 34]) >> 6;	//w6
+		spca50x->avg_lum += ((cdata[sof + 25] << 8) | cdata[sof + 26]) >> 6;	//w2
+		spca50x->avg_lum += ((cdata[sof + 37] << 8) | cdata[sof + 38]) >> 6;	//w8               
+		spca50x->avg_lum += ((cdata[sof + 31] << 8) | cdata[sof + 32]) >> 4;	//w5
+		spca50x->avg_lum = spca50x->avg_lum >> 4;
+
+		spin_unlock(&spca50x->v4l_lock);
+		PDEBUG(4,"mean luma %d", spca50x->avg_lum);
+		// setting to skip the rest of the packet
+		*iPix = *datalength;
+		*datalength = 0;
+		return 0;	//start of frame
+	} else
+		*iPix = 0;
+	return (seqnum + 1);
+}
+static __u16
+sn9cxxx_getcolors(struct usb_spca50x *spca50x)
+{
+//__u8 red,green,blue;
+
+//sonixRegRead(spca50x->dev, 0x00, 0x05, 0x0000, &red, 1);
+//sonixRegRead(spca50x->dev, 0x00, 0x06, 0x0000, &blue, 1);
+//sonixRegRead(spca50x->dev, 0x00, 0x07, 0x0000, &green, 1);
+//PDEBUG(0,"Colors gain red %d green %d blue %d", red & 0x7f,green & 0x7f,blue & 0x7f);
+	spca50x->colour = (0x80) << 8;
+	return spca50x->colour;
+}
+
+static void
+sn9cxxx_setcolors(struct usb_spca50x *spca50x)
+{
+	__u8 red, blue;
+	int colour;
+	colour = (spca50x->colour >> 8) - 128;
+	if (colour > 0) {
+		blue = (colour + 32) & 0x7f;
+		sonixRegWrite(spca50x->dev, 0x08, 0x06, 0x0000, &blue, 1);
+	} else {
+		red = (-colour + 32) & 0x7f;
+		sonixRegWrite(spca50x->dev, 0x08, 0x05, 0x0000, &red, 1);
+	}
+}
+static void
+sn9cxxx_setAutobright(struct usb_spca50x *spca50x)
+{
+	// Thanks S., without your advice, autobright should not work :) 
+	int delta;
+	int expotimes = 0;
+	unsigned int expotimesret = 0;
+	__u8 luma_mean = 130;
+	__u8 luma_delta = 20;
+
+	spin_lock_irq(&spca50x->v4l_lock);
+	delta = spca50x->avg_lum;
+	spin_unlock_irq(&spca50x->v4l_lock);
+	if ((delta < (luma_mean - luma_delta)) ||
+	    (delta > (luma_mean + luma_delta))) {
+		switch (spca50x->sensor) {
+		case SENSOR_HV7131R:
+			expotimes = spca50x->exposure >> 8;
+			expotimes += ((luma_mean - delta) >> 4);
+			if (expotimes < 0)
+				expotimes = 0;
+			expotimesret =
+			    sn9cxxx_setexposure(spca50x,
+						(unsigned int) (expotimes <<
+								8));
+			spca50x->exposure = expotimes << 8;
+			break;
+		case SENSOR_MO4000:	
+		case SENSOR_MI0360:
+			expotimes = spca50x->exposure;
+			expotimes += ((luma_mean - delta) >> 6);
+			if (expotimes < 0)
+				expotimes = 0;
+			expotimesret =
+			    sn9cxxx_setexposure(spca50x,
+						(unsigned int) expotimes);
+			spca50x->exposure = expotimes;
+			sn9cxxx_setcolors(spca50x);
+			break;
+		}
+	}
+
+}
+
+#endif				//SONIXJPGUSB
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sonix/sonix.h linux-2.6.21-gspca/drivers/media/video/gspca/Sonix/sonix.h
--- linux-2.6.21/drivers/media/video/gspca/Sonix/sonix.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sonix/sonix.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,717 @@
+
+#ifndef SONIXUSB_H
+#define SONIXUSB_H
+/****************************************************************************
+#	 	sonix sn9c102 library                                       #
+# 		Copyright (C) 2003 2004 Michel Xhaard   mxhaard@magic.fr    #
+# Add Pas106 Stefano Mozzi (C) 2004 	 				    #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+#define COMP2 0x8F
+#define COMP 0xC7		//0x87 //0x07
+#define COMP1 0xC9		//0x89 //0x09
+
+#define MCK_INIT 0x63
+#define MCK_INIT1 0x20
+
+#define SYS_CLK 0x04
+/*******************     Camera Interface   ***********************/
+static int sonix_init(struct usb_spca50x *spca50x);
+static void sonix_start(struct usb_spca50x *spca50x);
+static void sonix_stopN(struct usb_spca50x *spca50x);
+static void sonix_stop0(struct usb_spca50x *spca50x);
+static __u16 sonix_getbrightness(struct usb_spca50x *spca50x);
+static void sonix_setbrightness(struct usb_spca50x *spca50x);
+static void sonix_setcontrast(struct usb_spca50x *spca50x);
+static __u16 sonix_getcontrast(struct usb_spca50x *spca50x);
+static void sonix_setcolors(struct usb_spca50x *spca50x);
+static __u16 sonix_getcolors(struct usb_spca50x *spca50x);
+static int sonix_config(struct usb_spca50x *spca50x);
+static void sonix_shutdown(struct usb_spca50x *spca50x);
+static void sonix_setAutobright(struct usb_spca50x *spca50x);
+static void sonix_setquality(struct usb_spca50x *spca50x);
+static int sonix_sofdetect(struct usb_spca50x *spca50x,
+			   struct spca50x_frame *frame, unsigned char *cdata,
+			   int *iPix, int seqnum, int *datalength);
+/******************************************************************/
+static void
+sonix_setcolors(struct usb_spca50x *spca50x)
+{
+}
+static __u16
+sonix_getcolors(struct usb_spca50x *spca50x)
+{
+	return 0;
+}
+static void
+sonix_shutdown(struct usb_spca50x *spca50x)
+{
+}
+static void
+sonix_setAutobright(struct usb_spca50x *spca50x)
+{
+}
+static void
+sonix_setquality(struct usb_spca50x *spca50x)
+{
+}
+static void
+sonix_stop0(struct usb_spca50x *spca50x)
+{
+}
+
+/*****************************************************************/
+#include "sn9cxxx.h"
+static struct cam_operation fsonix = {
+	.initialize = sonix_init,
+	.configure = sonix_config,
+	.start = sonix_start,
+	.stopN = sonix_stopN,
+	.stop0 = sonix_stop0,
+	.get_bright = sonix_getbrightness,
+	.set_bright = sonix_setbrightness,
+	.get_contrast = sonix_getcontrast,
+	.set_contrast = sonix_setcontrast,
+	.get_colors = sonix_getcolors,
+	.set_colors = sonix_setcolors,
+	.set_autobright = sonix_setAutobright,
+	.set_quality = sonix_setquality,
+	.cam_shutdown = sonix_shutdown,
+	.sof_detect = sonix_sofdetect,
+};
+static void
+set_sonixVGA(struct usb_spca50x *spca50x)
+{
+	memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof (struct mwebcam));
+	spca50x->mode_cam[VGA].width = 640;
+	spca50x->mode_cam[VGA].height = 480;
+	spca50x->mode_cam[VGA].t_palette =
+	    P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	if (spca50x->customid == SN9C102P || spca50x->customid == SN9C105
+	    || spca50x->customid == SN9C120)
+		spca50x->mode_cam[VGA].t_palette |= P_JPEG;
+	spca50x->mode_cam[VGA].pipe = 1023;
+	spca50x->mode_cam[VGA].method = 0;
+	spca50x->mode_cam[VGA].mode = 0;
+	spca50x->mode_cam[PAL].width = 384;
+	spca50x->mode_cam[PAL].height = 288;
+	spca50x->mode_cam[PAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[PAL].pipe = 1023;
+	spca50x->mode_cam[PAL].method = 1;
+	spca50x->mode_cam[PAL].mode = 0;
+	spca50x->mode_cam[SIF].width = 352;
+	spca50x->mode_cam[SIF].height = 288;
+	spca50x->mode_cam[SIF].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[SIF].pipe = 1023;
+	spca50x->mode_cam[SIF].method = 1;
+	spca50x->mode_cam[SIF].mode = 0;
+	spca50x->mode_cam[CIF].width = 320;
+	spca50x->mode_cam[CIF].height = 240;
+	spca50x->mode_cam[CIF].t_palette =
+	    P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	if (spca50x->customid == SN9C102P || spca50x->customid == SN9C105
+	    || spca50x->customid == SN9C120)
+		spca50x->mode_cam[CIF].t_palette |= P_JPEG;
+	spca50x->mode_cam[CIF].pipe = 1023;
+	spca50x->mode_cam[CIF].method = 0;
+	spca50x->mode_cam[CIF].mode = 1;
+	spca50x->mode_cam[QPAL].width = 192;
+	spca50x->mode_cam[QPAL].height = 144;
+	spca50x->mode_cam[QPAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QPAL].pipe = 1023;
+	spca50x->mode_cam[QPAL].method = 1;
+	spca50x->mode_cam[QPAL].mode = 1;
+	spca50x->mode_cam[QSIF].width = 176;
+	spca50x->mode_cam[QSIF].height = 144;
+	spca50x->mode_cam[QSIF].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QSIF].pipe = 1023;
+	spca50x->mode_cam[QSIF].method = 1;
+	spca50x->mode_cam[QSIF].mode = 1;
+	spca50x->mode_cam[QCIF].width = 160;
+	spca50x->mode_cam[QCIF].height = 120;
+	spca50x->mode_cam[QCIF].t_palette =
+	    P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QCIF].pipe = 1023;
+	spca50x->mode_cam[QCIF].method = 0;
+	spca50x->mode_cam[QCIF].mode = 2;
+	if (spca50x->customid == SN9C102P || spca50x->customid == SN9C105
+	    || spca50x->customid == SN9C120)
+		spca50x->mode_cam[QCIF].t_palette |= P_JPEG;
+}
+static void
+set_sonixSIF(struct usb_spca50x *spca50x)
+{
+	memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof (struct mwebcam));
+	spca50x->mode_cam[SIF].width = 352;
+	spca50x->mode_cam[SIF].height = 288;
+	spca50x->mode_cam[SIF].t_palette =
+	    P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[SIF].pipe = 1023;
+	spca50x->mode_cam[SIF].method = 0;
+	spca50x->mode_cam[SIF].mode = 0;
+	spca50x->mode_cam[CIF].width = 320;
+	spca50x->mode_cam[CIF].height = 240;
+	spca50x->mode_cam[CIF].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[CIF].pipe = 1023;
+	spca50x->mode_cam[CIF].method = 1;
+	spca50x->mode_cam[CIF].mode = 0;
+	spca50x->mode_cam[QPAL].width = 192;
+	spca50x->mode_cam[QPAL].height = 144;
+	spca50x->mode_cam[QPAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QPAL].pipe = 1023;
+	spca50x->mode_cam[QPAL].method = 1;
+	spca50x->mode_cam[QPAL].mode = 0;
+	spca50x->mode_cam[QSIF].width = 176;
+	spca50x->mode_cam[QSIF].height = 144;
+	spca50x->mode_cam[QSIF].t_palette =
+	    P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QSIF].pipe = 1023;
+	spca50x->mode_cam[QSIF].method = 0;
+	spca50x->mode_cam[QSIF].mode = 1;
+	spca50x->mode_cam[QCIF].width = 160;
+	spca50x->mode_cam[QCIF].height = 120;
+	spca50x->mode_cam[QCIF].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QCIF].pipe = 1023;
+	spca50x->mode_cam[QCIF].method = 1;
+	spca50x->mode_cam[QCIF].mode = 1;
+}
+
+static __u8 initTas5130[] = {
+	0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+	0x00, 0x01, 0x00, 0x69, 0x0c, 0x0a,
+	0x28, 0x1e, 0x60, COMP, MCK_INIT,
+	0x18, 0x10, 0x04, 0x03, 0x11, 0x0c
+};
+
+static __u8 initPas106[] = {
+	0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x40, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+	0x00, 0x00, 0x00, 0x05, 0x01, 0x00,
+	0x16, 0x12, 0x28, COMP1, MCK_INIT1,
+	0x18, 0x10, 0x04, 0x03, 0x11, 0x0c
+};
+
+static __u8 initOv7630[] = {
+	0x04, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x21, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+	0x00, 0x00, 0x00, 0x02, 0x03, 0x0a,	//shift one pixel 0x02 is 0x01 at start
+	0x28, 0x1e, 0x68, COMP1, MCK_INIT1,
+	0x1d, 0x10, 0x02, 0x03, 0x0f, 0x0c
+};
+static __u8 initHv7131[] = {
+	0x46, 0x77, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+	0x00, 0x00, 0x00, 0x03, 0x01, 0x00,	// shift from 0x02 0x01 0x00
+	0x28, 0x1e, 0x60, 0x8a, 0x20,
+	0x1d, 0x10, 0x02, 0x03, 0x0f, 0x0c
+};
+static __u8 initTas5110[] = {
+	0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+	0x00, 0x01, 0x00, 0x46, 0x09, 0x0a,	// shift from 0x45 0x09 0x0a
+	0x16, 0x12, 0x60, 0x86, 0x2b,
+	0x14, 0x0a, 0x02, 0x02, 0x09, 0x07
+};
+static __u8 initPas202[] = {
+	0x44, 0x44, 0x21, 0x30, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00,
+	0x00, 0x00,
+	0x00, 0x00, 0x00, 0x07, 0x03, 0x0A,	//6
+	0x28, 0x1e, 0x28, 0x89, 0x30,
+	0x00, 0x00, 0x02, 0x03, 0x0F, 0x0C
+};
+
+//compression 0x86 mckinit1 0x2b
+static __u8 pas106_data[][2] = {
+	{0x02, 0x04},		/* Pixel Clock Divider 6 */
+	{0x03, 0x13},		/* Frame Time MSB */
+	//{ 0x03, 0x12}, /* Frame Time MSB */
+	{0x04, 0x06},		/* Frame Time LSB */
+	//{ 0x04, 0x05}, /* Frame Time LSB */
+	{0x05, 0x65},		/* Shutter Time Line Offset */
+	//{ 0x05, 0x6d}, /* Shutter Time Line Offset */
+	//{ 0x06, 0xB1}, /* Shutter Time Pixel Offset */
+	{0x06, 0xcd},		/* Shutter Time Pixel Offset */
+	{0x07, 0xC1},		/* Black Level Subtract Sign */
+	//{ 0x07, 0x00}, /* Black Level Subtract Sign */
+	{0x08, 0x06}, /* Black Level Subtract Level */ {0x08, 0x06},	/* Black Level Subtract Level */
+	//{ 0x08, 0x01}, /* Black Level Subtract Level */
+	{0x09, 0x05},		/* Color Gain B Pixel 5 a */
+	{0x0A, 0x04},		/* Color Gain G1 Pixel 1 5 */
+	{0x0B, 0x04},		/* Color Gain G2 Pixel 1 0 5 */
+	{0x0C, 0x05},		/* Color Gain R Pixel 3 1 */
+	{0x0D, 0x00},		/* Color GainH  Pixel */
+	{0x0E, 0x0E},		/* Global Gain */
+	{0x0F, 0x00},		/* Contrast */
+	{0x10, 0x06},		/* H&V synchro polarity */
+	{0x11, 0x06},		/* ?default */
+	{0x12, 0x06},		/* DAC scale */
+	{0x14, 0x02},		/* ?default */
+	{0x13, 0x01},		/* Validate Settings */
+	{0, 0}			/* The end */
+};
+static __u8 ov7630_sensor_init[][8] = {
+	{0xa0, 0x21, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10},
+	{0xb0, 0x21, 0x01, 0x77, 0x3a, 0x00, 0x00, 0x10},
+	{0xd0, 0x21, 0x12, 0x78, 0x00, 0x80, 0x34, 0x10},
+	{0xa0, 0x21, 0x1b, 0x04, 0x00, 0x80, 0x34, 0x10},
+	{0xa0, 0x21, 0x20, 0x44, 0x00, 0x80, 0x34, 0x10},
+	{0xa0, 0x21, 0x23, 0xee, 0x00, 0x80, 0x34, 0x10},
+	{0xd0, 0x21, 0x26, 0xa0, 0x9a, 0xa0, 0x30, 0x10},
+	{0xb0, 0x21, 0x2a, 0x80, 0x00, 0xa0, 0x30, 0x10},
+	{0xb0, 0x21, 0x2f, 0x3d, 0x24, 0xa0, 0x30, 0x10},
+	{0xa0, 0x21, 0x32, 0x86, 0x24, 0xa0, 0x30, 0x10},
+	{0xb0, 0x21, 0x60, 0xa9, 0x42, 0xa0, 0x30, 0x10},
+	{0xa0, 0x21, 0x65, 0x00, 0x42, 0xa0, 0x30, 0x10},
+	{0xa0, 0x21, 0x69, 0x38, 0x42, 0xa0, 0x30, 0x10},
+	{0xc0, 0x21, 0x6f, 0x88, 0x0b, 0x00, 0x30, 0x10},
+	{0xc0, 0x21, 0x74, 0x21, 0x8e, 0x00, 0x30, 0x10},
+	{0xa0, 0x21, 0x7d, 0xf7, 0x8e, 0x00, 0x30, 0x10},
+	{0xd0, 0x21, 0x17, 0x1c, 0xbd, 0x06, 0xf6, 0x10},	//
+	{0xa0, 0x21, 0x10, 0x36, 0xbd, 0x06, 0xf6, 0x16},	// exposure
+	{0xa0, 0x21, 0x76, 0x03, 0xbd, 0x06, 0xf6, 0x16},
+	{0xa0, 0x21, 0x11, 0x01, 0xbd, 0x06, 0xf6, 0x16},
+	{0xa0, 0x21, 0x00, 0x10, 0xbd, 0x06, 0xf6, 0x15},	//gain
+//{ 0xb0, 0x21, 0x2a, 0xc0, 0x3c, 0x06, 0xf6, 0x1d},//a0 1c,a0 1f,c0 3c frame rate ?line interval from ov6630
+	{0xb0, 0x21, 0x2a, 0xa0, 0x1f, 0x06, 0xf6, 0x1d},
+	{0, 0, 0, 0, 0, 0, 0, 0}
+};
+static __u8 tas5110_sensor_init[][8] = {
+	{0x30, 0x11, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x10},
+	{0x30, 0x11, 0x02, 0x20, 0xa9, 0x00, 0x00, 0x10},
+	{0, 0, 0, 0, 0, 0, 0, 0}
+};
+static __u8 hv7131_sensor_init[][8] = {
+	{0xc0, 0x11, 0x31, 0x38, 0x2a, 0x2e, 0x00, 0x10},
+	{0xa0, 0x11, 0x01, 0x08, 0x2a, 0x2e, 0x00, 0x10},
+	{0xb0, 0x11, 0x20, 0x00, 0xd0, 0x2e, 0x00, 0x10},
+	{0xc0, 0x11, 0x25, 0x03, 0x0e, 0x28, 0x00, 0x16},
+	{0xa0, 0x11, 0x30, 0x10, 0x0e, 0x28, 0x00, 0x15},
+	{0, 0, 0, 0, 0, 0, 0, 0}
+};
+static __u8 pas202_sensor_init[][8] = {
+	{0xA0, 0x40, 0x02, 0x03, 0x00, 0x00, 0x00, 0x10},
+	{0xD0, 0x40, 0x04, 0x07, 0x34, 0x00, 0x09, 0x10},
+	{0xD0, 0x40, 0x08, 0x01, 0x00, 0x00, 0x01, 0x10},
+	{0xD0, 0x40, 0x0C, 0x00, 0x0C, 0x00, 0x32, 0x10},
+	{0xD0, 0x40, 0x10, 0x00, 0x01, 0x00, 0x63, 0x10},
+	{0xA0, 0x40, 0x15, 0x70, 0x01, 0x00, 0x63, 0x10},
+	{0xA0, 0x40, 0x18, 0x00, 0x01, 0x00, 0x63, 0x10},
+	{0xA0, 0x40, 0x11, 0x01, 0x01, 0x00, 0x63, 0x10},
+	{0xA0, 0x40, 0x03, 0x56, 0x01, 0x00, 0x63, 0x10},
+	{0xA0, 0x40, 0x11, 0x01, 0x01, 0x00, 0x63, 0x10},
+	{0xB0, 0x40, 0x04, 0x07, 0x2A, 0x00, 0x63, 0x10},
+	{0xB0, 0x40, 0x0E, 0x00, 0x3D, 0x00, 0x63, 0x10},
+
+	{0xA0, 0x40, 0x11, 0x01, 0x3D, 0x00, 0x63, 0x16},
+	{0xA0, 0x40, 0x10, 0x08, 0x3D, 0x00, 0x63, 0x15},
+	{0xA0, 0x40, 0x02, 0x04, 0x3D, 0x00, 0x63, 0x16},
+	{0xA0, 0x40, 0x11, 0x01, 0x3D, 0x00, 0x63, 0x16},
+	{0xB0, 0x40, 0x0E, 0x00, 0x31, 0x00, 0x63, 0x16},
+	{0xA0, 0x40, 0x11, 0x01, 0x31, 0x00, 0x63, 0x16},
+	{0xA0, 0x40, 0x10, 0x0E, 0x31, 0x00, 0x63, 0x15},
+	{0xA0, 0x40, 0x11, 0x01, 0x31, 0x00, 0x63, 0x16},
+	{0, 0, 0, 0, 0, 0, 0, 0}
+};
+
+static int
+sonix_i2cwrite(struct usb_device *dev, __u8 * buffer, __u16 length)
+{
+	int retry = 60;
+	__u8 ByteReceive = 0x00;
+	/* is i2c ready */
+	if (length > 8 || !buffer)
+		return -1;
+	sonixRegWrite(dev, 0x08, 0x08, 0x0000, buffer, length);
+	while (retry--) {
+		wait_ms(10);
+		sonixRegRead(dev, 0x00, 0x08, 0x0000, &ByteReceive, 1);
+		if (ByteReceive == 4)
+			return 0;
+	}
+	return -1;
+}
+
+static __u16
+sonix_getbrightness(struct usb_spca50x *spca50x)
+{				/*FIXME hardcoded as we need to read register of the tasc */
+	spca50x->brightness = 0x80 << 8;
+	spca50x->contrast = 0x80 << 8;
+	return spca50x->brightness;
+}
+static __u16
+sonix_getcontrast(struct usb_spca50x *spca50x)
+{				/*FIXME hardcoded as we need to read register of the tasc */
+
+	spca50x->contrast = 0x80 << 8;
+	return spca50x->contrast;
+}
+static void
+sonix_setbrightness(struct usb_spca50x *spca50x)
+{
+	__u8 value;
+	__u8 i2c[] = { 0x30, 0x11, 0x02, 0x20, 0x70, 0x00, 0x00, 0x10 };
+	__u8 i2c1[] = { 0xA1, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14 };
+	__u8 i2cOV[] = { 0xa0, 0x21, 0x06, 0x36, 0xbd, 0x06, 0xf6, 0x16 };
+	__u8 i2cp202[] = { 0xA0, 0x40, 0x10, 0x0E, 0x31, 0x00, 0x63, 0x15 };
+	__u8 i2cpdoit[] = { 0xA0, 0x40, 0x11, 0x01, 0x31, 0x00, 0x63, 0x16 };
+	//__u8 i2cpexpo1[] = { 0xB0,0x40,0x04,0x07,0x2A,0x00,0x63,0x16 };
+	__u8 i2cpexpo[] = { 0xB0, 0x40, 0x0e, 0x01, 0xab, 0x00, 0x63, 0x16 };
+	if (spca50x->sensor == SENSOR_TAS5130CXX ||
+	    spca50x->sensor == SENSOR_TAS5110) {
+		value = (0xFF - (spca50x->brightness >> 8));
+		i2c[4] = value & 0xFF;
+		PDEBUG(4, "brightness %d :%d ", value, i2c[4]);
+		if (sonix_i2cwrite(spca50x->dev, i2c, 8) < 0)
+			PDEBUG(0, "i2c error brightness");
+	} else if (spca50x->sensor == SENSOR_PAS106) {
+		i2c1[3] = spca50x->brightness >> 11;
+		i2c1[2] = 0x0e;;
+		if (sonix_i2cwrite(spca50x->dev, i2c1, 8) < 0)
+			PDEBUG(0, "i2c error brightness");
+		i2c1[3] = 0x01;
+		i2c1[2] = 0x13;;
+		if (sonix_i2cwrite(spca50x->dev, i2c1, 8) < 0)
+			PDEBUG(0, "i2c error brightness");
+	} else if (spca50x->sensor == SENSOR_OV7630) {
+		// change reg 0x06
+		i2cOV[3] = (spca50x->brightness >> 8);
+		if (sonix_i2cwrite(spca50x->dev, i2cOV, 8) < 0)
+			PDEBUG(0, "i2c error brightness");
+	} else if (spca50x->sensor == SENSOR_PAS202) {
+		// change reg 0x10
+		i2cpexpo[4] = 0xff - (spca50x->brightness >> 8);
+		//if(sonix_i2cwrite(spca50x->dev,i2cpexpo1,8) < 0) PDEBUG(0,"i2c error brightness");
+		//if(sonix_i2cwrite(spca50x->dev,i2cpdoit,8) < 0) PDEBUG(0,"i2c error brightness");
+		if (sonix_i2cwrite(spca50x->dev, i2cpexpo, 8) < 0)
+			PDEBUG(0, "i2c error brightness");
+		if (sonix_i2cwrite(spca50x->dev, i2cpdoit, 8) < 0)
+			PDEBUG(0, "i2c error brightness");
+		i2cp202[3] = (spca50x->brightness >> 11);
+		if (sonix_i2cwrite(spca50x->dev, i2cp202, 8) < 0)
+			PDEBUG(0, "i2c error brightness");
+		if (sonix_i2cwrite(spca50x->dev, i2cpdoit, 8) < 0)
+			PDEBUG(0, "i2c error brightness");
+	}
+}
+static void
+sonix_setcontrast(struct usb_spca50x *spca50x)
+{
+	__u8 gain = 0;
+	__u8 rgb_value = 0;
+	gain = (spca50x->contrast >> 13) & 0x0F;
+	/* red and blue gain */
+	rgb_value = gain << 4 | gain;
+	sonixRegWrite(spca50x->dev, 0x08, 0x10, 0x0000, &rgb_value, 1);
+	/* green gain */
+	rgb_value = gain;
+	sonixRegWrite(spca50x->dev, 0x08, 0x11, 0x0000, &rgb_value, 1);
+}
+static int
+sonix_init(struct usb_spca50x *spca50x)
+{
+	__u8 ByteReceive = 0x00;
+	sonixRegRead(spca50x->dev, 0x00, 0x00, 0x0000, &ByteReceive, 1);
+	if (ByteReceive != 0x10)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int
+tas5130_I2cinit(struct usb_spca50x *spca50x)
+{
+
+	//__u8 i2c10[]= { 0x30,0x11,0x00,0x40,0x47,0x00,0x00,0x10 }; // shutter 0x47 short exposure?
+	__u8 i2c10[] = { 0x30, 0x11, 0x00, 0x40, 0x01, 0x00, 0x00, 0x10 };	// shutter 0x01 long exposure 
+	__u8 i2c2[] = { 0x30, 0x11, 0x02, 0x20, 0x70, 0x00, 0x00, 0x10 };
+
+	if (sonix_i2cwrite(spca50x->dev, i2c10, 8) < 0)
+		PDEBUG(0, "i2c error i2c10");
+	if (sonix_i2cwrite(spca50x->dev, i2c2, 8) < 0)
+		PDEBUG(0, "i2c error i2c2");
+
+	return 0;
+}
+
+static int
+pas106_I2cinit(struct usb_spca50x *spca50x)
+{
+	__u8 i2c1[] = { 0xA1, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14 };
+	int i = 0;
+	while (pas106_data[i][0]) {
+		memcpy(&i2c1[2], &pas106_data[i++][0], 2);	//copy 2 bytes from the template
+		if (sonix_i2cwrite(spca50x->dev, i2c1, 8) < 0)
+			PDEBUG(0, "i2c error pas106");
+	}
+	return 0;
+}
+static int
+ov7630_I2cinit(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	while (ov7630_sensor_init[i][0]) {
+		if (sonix_i2cwrite(spca50x->dev, ov7630_sensor_init[i], 8) < 0)
+			PDEBUG(0, "i2c error ov7630");
+		i++;
+	}
+	return 0;
+}
+static int
+tas5110_I2cinit(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	while (tas5110_sensor_init[i][0]) {
+		if (sonix_i2cwrite(spca50x->dev, tas5110_sensor_init[i], 8) < 0)
+			PDEBUG(0, "i2c error tas5110");
+		i++;
+	}
+	return 0;
+}
+static int
+hv7131_I2cinit(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	while (hv7131_sensor_init[i][0]) {
+		if (sonix_i2cwrite(spca50x->dev, hv7131_sensor_init[i], 8) < 0)
+			PDEBUG(0, "i2c error hv7131");
+		i++;
+	}
+	return 0;
+}
+static int
+pas202_I2cinit(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	while (pas202_sensor_init[i][0]) {
+		if (sonix_i2cwrite(spca50x->dev, pas202_sensor_init[i], 8) < 0)
+			PDEBUG(0, "i2c error pas202");
+		i++;
+	}
+	return 0;
+}
+static void
+sonix_start(struct usb_spca50x *spca50x)
+{
+
+	__u8 compress = 0;
+	__u8 MCK_SIZE = 0x33;
+	__u8 frmult = 0x28;
+	__u8 *sn9c10x = NULL;
+	__u8 CompressCtrl[] = { 0, 0 };
+	int err = 0;
+	switch (spca50x->sensor) {
+	case SENSOR_OV7630:
+		sn9c10x = initOv7630;
+		compress = spca50x->mode << 4 | COMP2;
+		CompressCtrl[0] = compress;
+		frmult = 0x68;
+		CompressCtrl[1] = 0x20;
+		MCK_SIZE = 0x20;
+		break;
+	case SENSOR_TAS5130CXX:
+		sn9c10x = initTas5130;
+		compress = spca50x->mode << 4 | COMP;
+		CompressCtrl[0] = compress;
+		frmult = 0x60;
+		switch (spca50x->mode) {
+		case 0:	/* 640x480 3fp/s */
+			CompressCtrl[1] = 0x43;	//0xA3 3fp/s ;// 0xF3;
+			MCK_SIZE = 0x43;	// 0xA3;//0xF3;
+			break;
+		case 1:	/* 320x240 0x33 10fp/s */
+			CompressCtrl[1] = 0x23;
+			MCK_SIZE = 0x23;
+			break;
+		case 2:	/* 160x120 15fp/s */
+			CompressCtrl[1] = 0x23;
+			MCK_SIZE = 0x23;
+			break;
+		default:
+			break;
+		}
+		break;
+	case SENSOR_PAS106:
+		sn9c10x = initPas106;;
+		compress = spca50x->mode << 4 | COMP1;
+		CompressCtrl[0] = compress;
+		frmult = 0x24;	//0x28
+		CompressCtrl[1] = 0x20;	//0xF3;
+		MCK_SIZE = 0x20;	//0xF3;
+		break;
+	case SENSOR_TAS5110:
+		sn9c10x = initTas5110;
+		compress = spca50x->mode << 4 | 0x86;
+		CompressCtrl[0] = compress;
+		frmult = 0x60;
+		CompressCtrl[1] = 0x2b;	//0xF3;
+		MCK_SIZE = 0x2b;	//0xF3;
+		break;
+	case SENSOR_HV7131R:
+		sn9c10x = initHv7131;
+		compress = spca50x->mode << 4 | 0x8a;
+		CompressCtrl[0] = compress;
+		frmult = 0x60;
+		CompressCtrl[1] = 0x20;
+		MCK_SIZE = 0x20;
+		break;
+	case SENSOR_PAS202:
+		sn9c10x = initPas202;
+		compress = spca50x->mode << 4 | 0x89;
+		CompressCtrl[0] = compress;
+		frmult = 0x20;	//reg17 // 7 fp/s VGA
+		if (spca50x->mode)
+			frmult = 0x24;	// 0x28->11fp/s SIF 0x24
+		CompressCtrl[1] = 0x20;	//reg19 30
+		MCK_SIZE = 0x20;
+		break;
+	}
+	/* reg 0x01 bit 2 video transfert on */
+
+	sonixRegWrite(spca50x->dev, 0x08, 0x01, 0x0000, &sn9c10x[0], 1);
+	/* reg 0x17 SensorClk enable inv Clk 0x60 */
+	sonixRegWrite(spca50x->dev, 0x08, 0x17, 0x0000, &sn9c10x[0x17 - 1], 1);
+	/* Set the whole registers from the template */
+	sonixRegWrite(spca50x->dev, 0x08, 0x01, 0x0000, sn9c10x, 0x1f);
+	switch (spca50x->sensor) {
+	case SENSOR_TAS5130CXX:
+		err = tas5130_I2cinit(spca50x);
+		break;
+	case SENSOR_PAS106:
+		err = pas106_I2cinit(spca50x);
+		break;
+	case SENSOR_OV7630:
+		err = ov7630_I2cinit(spca50x);
+		break;
+	case SENSOR_HV7131R:
+		err = hv7131_I2cinit(spca50x);
+		break;
+	case SENSOR_TAS5110:
+		err = tas5110_I2cinit(spca50x);
+		break;
+	case SENSOR_PAS202:
+		err = pas202_I2cinit(spca50x);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	/* H_size V_size  0x28,0x1e maybe 640x480 */
+	sonixRegWrite(spca50x->dev, 0x08, 0x15, 0x0000, &sn9c10x[0x15 - 1],
+		      0x02);
+	/* compression register */
+	sonixRegWrite(spca50x->dev, 0x08, 0x18, 0x0000, &compress, 1);
+	// H_start      
+	sonixRegWrite(spca50x->dev, 0x08, 0x12, 0x0000, &sn9c10x[0x12 - 1], 1);
+	// V_START      
+	sonixRegWrite(spca50x->dev, 0x08, 0x13, 0x0000, &sn9c10x[0x13 - 1], 1);
+	/* re set 0x17 SensorClk enable inv Clk 0x60 */
+	sonixRegWrite(spca50x->dev, 0x08, 0x17, 0x0000, &frmult, 1);
+	/*MCKSIZE ->3 */
+	sonixRegWrite(spca50x->dev, 0x08, 0x19, 0x0000, &MCK_SIZE, 1);
+	/* AE_STRX AE_STRY AE_ENDX AE_ENDY */
+	sonixRegWrite(spca50x->dev, 0x08, 0x1c, 0x0000, &sn9c10x[0x1c - 1], 4);
+	/* Enable video transfert */
+	sonixRegWrite(spca50x->dev, 0x08, 0x01, 0x0000, &sn9c10x[0], 1);
+	/* Compression */
+	sonixRegWrite(spca50x->dev, 0x08, 0x18, 0x0000, CompressCtrl, 2);
+
+	sonix_setcontrast(spca50x);
+	sonix_setbrightness(spca50x);
+
+}
+static int
+sonix_config(struct usb_spca50x *spca50x)
+{
+	switch (spca50x->sensor) {
+	case SENSOR_OV7660:
+	case SENSOR_MO4000:
+	case SENSOR_OV7630:
+	case SENSOR_TAS5130CXX:
+	case SENSOR_HV7131R:
+	case SENSOR_MI0360:
+	case SENSOR_PAS202:
+		set_sonixVGA(spca50x);
+		break;
+	case SENSOR_PAS106:
+	case SENSOR_TAS5110:
+		set_sonixSIF(spca50x);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	spca50x->qindex = 4;	//set the quantization table
+	return 0;
+}
+static void
+sonix_stopN(struct usb_spca50x *spca50x)
+{
+	__u8 ByteSend = 0;
+
+	ByteSend = 0x09;	// 0X00
+	sonixRegWrite(spca50x->dev, 0x08, 0x01, 0x0000, &ByteSend, 1);
+}
+static int
+sonix_sofdetect(struct usb_spca50x *spca50x, struct spca50x_frame *frame,
+		unsigned char *cdata, int *iPix, int seqnum, int *datalength)
+{
+
+	int sof = 0;
+	int j = 0;
+	int p = 0;
+
+	if (*datalength < 24) {
+		if (*datalength > 6) {
+			j = *datalength - 6;
+		} else {
+			j = 0;
+		}
+		if (j > 0) {
+			for (p = 0; p < j; p++) {
+				if ((cdata[0 + p] == 0xFF)
+				    && (cdata[1 + p] == 0xFF)
+				    && (cdata[2 + p] == 0x00)
+				    && (cdata[3 + p] == 0xC4)
+				    && (cdata[4 + p] == 0xC4)
+				    && (cdata[5 + p] == 0x96)) {
+					sof = 1;
+					break;
+				}
+			}
+		}
+	}
+	if (sof) {
+		*iPix = p + 12;
+		*datalength -= *iPix;
+		return 0;
+		PDEBUG(5,
+		       "Sonix header packet found %d datalength %d !!",
+		       p, *datalength);
+	} else
+		*iPix = 0;
+	return seqnum + 1;
+}
+#endif				/* SONIXUSB_H */
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus/spca501.dat linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca501.dat
--- linux-2.6.21/drivers/media/video/gspca/Sunplus/spca501.dat	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca501.dat	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,1645 @@
+/* Data for video camera initialization before capturing */
+static __u16 spca501_open_data[][3] = {
+    /* bmRequest,value,index */
+
+    {0x2, 0x50, 0x0},		//C/S enable soft reset
+    {0x2, 0x40, 0x0},		//C/S disable soft reset
+    {0x2, 0x02, 0x5},		//C/S general purpose I/O data
+    {0x2, 0x03, 0x5},		//C/S general purpose I/O data
+
+#ifdef CCDSP_SET
+    {0x1, 0x38, 0x1},		// CCDSP options
+    {0x1, 0x05, 0x2},		// CCDSP Optical black level for user settings
+    {0x1, 0xC0, 0x3},		// CCDSP Optical black settings
+
+    {0x1, 0x67, 0x7},
+    {0x1, 0x63, 0x3f},		// CCDSP CCD gamma enable
+    {0x1, 0x03, 0x56},		// Add gamma correction
+
+    {0x1, 0xFF, 0x15},		//CCDSP High luminance for white balance
+    {0x1, 0x01, 0x16},		//CCDSP Low luminance for white balance
+
+    /* Color correction and RGB-to-YUV transformation coefficients changing */
+#ifdef ALTER_GAMA
+    {0x0, 0x00, 0x08},		//A11
+    {0x0, 0x00, 0x09},		//A12
+    {0x0, 0x90, 0x0A},		//A13
+    {0x0, 0x12, 0x0B},		//A21
+    {0x0, 0x00, 0x0C},		//A22
+    {0x0, 0x00, 0x0D},		//A23
+    {0x0, 0x00, 0x0E},		//A31
+    {0x0, 0x02, 0x0F},		//A32
+    {0x0, 0x00, 0x10},		//A33
+#else
+    {0x1, 0x2a, 0x08},		//A11 0x31
+    {0x1, 0xf8, 0x09},		//A12 f8
+    {0x1, 0xf8, 0x0A},		//A13 f8
+    {0x1, 0xf8, 0x0B},		//A21 f8
+    {0x1, 0x14, 0x0C},		//A22 0x14
+    {0x1, 0xf8, 0x0D},		//A23 f8
+    {0x1, 0xf8, 0x0E},		//A31 f8
+    {0x1, 0xf8, 0x0F},		//A32 f8
+    {0x1, 0x20, 0x10},		//A33 0x20
+#endif
+    {0x1, 0x00, 0x11},		// R offset
+    {0x1, 0x00, 0x12},		// G offset
+    {0x1, 0x00, 0x13},		// B offset
+    {0x1, 0x00, 0x14},		// GB offset
+
+#endif
+
+#ifdef TG_SET
+    /* Time generator manipulations */
+    {0x0, 0xfc, 0x0},		// Set up high bits of shutter speed
+    {0x0, 0x01, 0x1},		// Set up low bits of shutter speed
+
+    {0x0, 0xe4, 0x04},		// DCLK*2 clock phase adjustment
+    {0x0, 0x08, 0x05},		// ADCK phase adjustment, inv. ext. VB
+    {0x0, 0x03, 0x06},		// FR phase adjustment
+    {0x0, 0x01, 0x07},		// FCDS phase adjustment
+    {0x0, 0x39, 0x08},		// FS phase adjustment
+    {0x0, 0x88, 0x0a},		// FH1 phase and delay adjustment
+    {0x0, 0x03, 0x0f},		// pixel identification
+    {0x0, 0x00, 0x11},		// clock source selection (default)
+
+    /*VERY strange manipulations with 
+     * select DMCLP or OBPX to be ADCLP output (0x0C)
+     * OPB always toggle or not (0x0D) but they allow
+     * us to set up brightness
+     */
+    {0x0, 0x01, 0x0c},
+    {0x0, 0xe0, 0x0d},
+    /* Done */
+#endif
+
+#ifdef DSPWIN_SET
+    {0x1, 0xa0, 0x01},		//Setting image processing parameters
+    {0x1, 0x1c, 0x17},		//Changing Windows positions X1
+    {0x1, 0xe2, 0x19},		//X2
+    {0x1, 0x1c, 0x1b},		//X3
+    {0x1, 0xe2, 0x1d},		//X4
+    {0x1, 0x5f, 0x1f},		//X5
+    {0x1, 0x32, 0x20},		//Y5
+    {0x1, 0x01, 0x10},		//Changing A33
+#endif
+
+    {0x2, 0x204a, 0x07},	//Setting video compression & resolution 160x120
+    {0x2, 0x94, 0x06},		//Setting video no compression
+    {0, 0, 0}
+};
+
+/*
+   The SPCAxxx docs from Sunplus document these values
+   in tables, one table per register number.  In the data
+   below, dmRequest is the register number, index is the Addr,
+   and value is a combination of Bit values.  
+   Bit  Value (hex)
+   0    01
+   1    02
+   2    04
+   3    08
+   4    10
+   5    20
+   6    40
+   7    80
+ */
+
+/* Data for chip initialization (set default values) */
+static __u16 spca501_init_data[][3] = {
+    /* Set all the values to powerup defaults */
+    /* bmRequest,value,index */
+    {0x0, 0xAA, 0x00},
+    {0x0, 0x02, 0x01},
+    {0x0, 0x01, 0x02},
+    {0x0, 0x02, 0x03},
+    {0x0, 0xCE, 0x04},
+    {0x0, 0x00, 0x05},
+    {0x0, 0x00, 0x06},
+    {0x0, 0x00, 0x07},
+    {0x0, 0x00, 0x08},
+    {0x0, 0x00, 0x09},
+    {0x0, 0x90, 0x0A},
+    {0x0, 0x12, 0x0B},
+    {0x0, 0x00, 0x0C},
+    {0x0, 0x00, 0x0D},
+    {0x0, 0x00, 0x0E},
+    {0x0, 0x02, 0x0F},
+    {0x0, 0x00, 0x10},
+    {0x0, 0x00, 0x11},
+    {0x0, 0x00, 0x12},
+    {0x0, 0x00, 0x13},
+    {0x0, 0x00, 0x14},
+    {0x0, 0x00, 0x15},
+    {0x0, 0x00, 0x16},
+    {0x0, 0x00, 0x17},
+    {0x0, 0x00, 0x18},
+    {0x0, 0x00, 0x19},
+    {0x0, 0x00, 0x1A},
+    {0x0, 0x00, 0x1B},
+    {0x0, 0x00, 0x1C},
+    {0x0, 0x00, 0x1D},
+    {0x0, 0x00, 0x1E},
+    {0x0, 0x00, 0x1F},
+    {0x0, 0x00, 0x20},
+    {0x0, 0x00, 0x21},
+    {0x0, 0x00, 0x22},
+    {0x0, 0x00, 0x23},
+    {0x0, 0x00, 0x24},
+    {0x0, 0x00, 0x25},
+    {0x0, 0x00, 0x26},
+    {0x0, 0x00, 0x27},
+    {0x0, 0x00, 0x28},
+    {0x0, 0x00, 0x29},
+    {0x0, 0x00, 0x2A},
+    {0x0, 0x00, 0x2B},
+    {0x0, 0x00, 0x2C},
+    {0x0, 0x00, 0x2D},
+    {0x0, 0x00, 0x2E},
+    {0x0, 0x00, 0x2F},
+    {0x0, 0x00, 0x30},
+    {0x0, 0x00, 0x31},
+    {0x0, 0x00, 0x32},
+    {0x0, 0x00, 0x33},
+    {0x0, 0x00, 0x34},
+    {0x0, 0x00, 0x35},
+    {0x0, 0x00, 0x36},
+    {0x0, 0x00, 0x37},
+    {0x0, 0x00, 0x38},
+    {0x0, 0x00, 0x39},
+    {0x0, 0x00, 0x3A},
+    {0x0, 0x00, 0x3B},
+    {0x0, 0x00, 0x3C},
+    {0x0, 0x00, 0x3D},
+    {0x0, 0x00, 0x3E},
+    {0x0, 0x00, 0x3F},
+    {0x0, 0x00, 0x40},
+    {0x0, 0x00, 0x41},
+    {0x0, 0x00, 0x42},
+    {0x0, 0x00, 0x43},
+    {0x0, 0x00, 0x44},
+    {0x0, 0x00, 0x45},
+    {0x0, 0x00, 0x46},
+    {0x0, 0x00, 0x47},
+    {0x0, 0x00, 0x48},
+    {0x0, 0x00, 0x49},
+    {0x0, 0x00, 0x4A},
+    {0x0, 0x00, 0x4B},
+    {0x0, 0x00, 0x4C},
+    {0x0, 0x00, 0x4D},
+    {0x0, 0x00, 0x4E},
+    {0x0, 0x00, 0x4F},
+    {0x0, 0x00, 0x50},
+    {0x0, 0x00, 0x51},
+    {0x0, 0x00, 0x52},
+    {0x0, 0x00, 0x53},
+    {0x0, 0x00, 0x54},
+    {0x0, 0x00, 0x55},
+    {0x0, 0x00, 0x56},
+    {0x0, 0x00, 0x57},
+    {0x0, 0x00, 0x58},
+    {0x0, 0x00, 0x59},
+    {0x0, 0x00, 0x5A},
+    {0x0, 0x00, 0x5B},
+    {0x0, 0x00, 0x5C},
+    {0x0, 0x00, 0x5D},
+    {0x0, 0x00, 0x5E},
+    {0x0, 0x00, 0x5F},
+    {0x0, 0x00, 0x60},
+    {0x0, 0x00, 0x61},
+    {0x0, 0x00, 0x62},
+    {0x0, 0x00, 0x63},
+    {0x0, 0x00, 0x64},
+    {0x0, 0x00, 0x65},
+    {0x0, 0x00, 0x66},
+    {0x0, 0x00, 0x67},
+    {0x0, 0x00, 0x68},
+    {0x0, 0x00, 0x69},
+    {0x0, 0x00, 0x6A},
+    {0x0, 0x00, 0x6B},
+    {0x0, 0x00, 0x6C},
+    {0x0, 0x00, 0x6D},
+    {0x0, 0x00, 0x6E},
+    {0x0, 0x00, 0x6F},
+    {0x0, 0x00, 0x70},
+    {0x0, 0x00, 0x71},
+    {0x0, 0x00, 0x72},
+    {0x0, 0x00, 0x73},
+    {0x0, 0x00, 0x74},
+    {0x0, 0x00, 0x75},
+    {0x0, 0x00, 0x76},
+    {0x0, 0x00, 0x77},
+    {0x0, 0x00, 0x78},
+    {0x0, 0x00, 0x79},
+    {0x0, 0x00, 0x7A},
+    {0x0, 0x00, 0x7B},
+    {0x0, 0x00, 0x7C},
+    {0x0, 0x00, 0x7D},
+    {0x0, 0x00, 0x7E},
+    {0x0, 0x00, 0x7F},
+    {0x0, 0x00, 0x80},
+    {0x0, 0x00, 0x81},
+    {0x0, 0x00, 0x82},
+    {0x0, 0x00, 0x83},
+    {0x0, 0x00, 0x84},
+    {0x0, 0x00, 0x85},
+    {0x0, 0x00, 0x86},
+    {0x0, 0x00, 0x87},
+    {0x0, 0x00, 0x88},
+    {0x0, 0x00, 0x89},
+    {0x0, 0x00, 0x8A},
+    {0x0, 0x00, 0x8B},
+    {0x0, 0x00, 0x8C},
+    {0x0, 0x00, 0x8D},
+    {0x0, 0x00, 0x8E},
+    {0x0, 0x00, 0x8F},
+    {0x0, 0x00, 0x90},
+    {0x0, 0x00, 0x91},
+    {0x0, 0x00, 0x92},
+    {0x0, 0x00, 0x93},
+    {0x0, 0x00, 0x94},
+    {0x0, 0x00, 0x95},
+    {0x0, 0x00, 0x96},
+    {0x0, 0x00, 0x97},
+    {0x0, 0x00, 0x98},
+    {0x0, 0x00, 0x99},
+    {0x0, 0x00, 0x9A},
+    {0x0, 0x00, 0x9B},
+    {0x0, 0x00, 0x9C},
+    {0x0, 0x00, 0x9D},
+    {0x0, 0x00, 0x9E},
+    {0x0, 0x00, 0x9F},
+    {0x0, 0x00, 0xA0},
+    {0x0, 0x00, 0xA1},
+    {0x0, 0x00, 0xA2},
+    {0x0, 0x00, 0xA3},
+    {0x0, 0x00, 0xA4},
+    {0x0, 0x00, 0xA5},
+    {0x0, 0x00, 0xA6},
+    {0x0, 0x00, 0xA7},
+    {0x0, 0x00, 0xA8},
+    {0x0, 0x00, 0xA9},
+    {0x0, 0x00, 0xAA},
+    {0x0, 0x00, 0xAB},
+    {0x0, 0x00, 0xAC},
+    {0x0, 0x00, 0xAD},
+    {0x0, 0x00, 0xAE},
+    {0x0, 0x00, 0xAF},
+    {0x0, 0x00, 0xB0},
+    {0x0, 0x00, 0xB1},
+    {0x0, 0x00, 0xB2},
+    {0x0, 0x00, 0xB3},
+    {0x0, 0x00, 0xB4},
+    {0x0, 0x00, 0xB5},
+    {0x0, 0x00, 0xB6},
+    {0x0, 0x00, 0xB7},
+    {0x0, 0x00, 0xB8},
+    {0x0, 0x00, 0xB9},
+    {0x0, 0x00, 0xBA},
+    {0x0, 0x00, 0xBB},
+    {0x0, 0x00, 0xBC},
+    {0x0, 0x00, 0xBD},
+    {0x0, 0x00, 0xBE},
+    {0x0, 0x00, 0xBF},
+    {0x0, 0x00, 0xC0},
+    {0x0, 0x00, 0xC1},
+    {0x0, 0x00, 0xC2},
+    {0x0, 0x00, 0xC3},
+    {0x0, 0x00, 0xC4},
+    {0x0, 0x00, 0xC5},
+    {0x0, 0x00, 0xC6},
+    {0x0, 0x00, 0xC7},
+    {0x0, 0x00, 0xC8},
+    {0x0, 0x00, 0xC9},
+    {0x0, 0x00, 0xCA},
+    {0x0, 0x00, 0xCB},
+    {0x0, 0x00, 0xCC},
+    {0x1, 0xF4, 0x00},
+    {0x1, 0x38, 0x01},
+    {0x1, 0x40, 0x02},
+    {0x1, 0x0A, 0x03},
+    {0x1, 0x40, 0x04},
+    {0x1, 0x40, 0x05},
+    {0x1, 0x40, 0x06},
+    {0x1, 0x67, 0x07},
+    {0x1, 0x31, 0x08},
+    {0x1, 0x00, 0x09},
+    {0x1, 0x00, 0x0A},
+    {0x1, 0x00, 0x0B},
+    {0x1, 0x14, 0x0C},
+    {0x1, 0x00, 0x0D},
+    {0x1, 0x00, 0x0E},
+    {0x1, 0x00, 0x0F},
+    {0x1, 0x1E, 0x10},
+    {0x1, 0x00, 0x11},
+    {0x1, 0x00, 0x12},
+    {0x1, 0x00, 0x13},
+    {0x1, 0x00, 0x14},
+    {0x1, 0xFF, 0x15},
+    {0x1, 0x01, 0x16},
+    {0x1, 0x32, 0x17},
+    {0x1, 0x23, 0x18},
+    {0x1, 0xCE, 0x19},
+    {0x1, 0x23, 0x1A},
+    {0x1, 0x32, 0x1B},
+    {0x1, 0x8D, 0x1C},
+    {0x1, 0xCE, 0x1D},
+    {0x1, 0x8D, 0x1E},
+    {0x1, 0x00, 0x1F},
+    {0x1, 0x00, 0x20},
+    {0x1, 0xFF, 0x3E},
+    {0x1, 0x02, 0x3F},
+    {0x1, 0x00, 0x40},
+    {0x1, 0x00, 0x41},
+    {0x1, 0x00, 0x42},
+    {0x1, 0x00, 0x43},
+    {0x1, 0x00, 0x44},
+    {0x1, 0x00, 0x45},
+    {0x1, 0x00, 0x46},
+    {0x1, 0x00, 0x47},
+    {0x1, 0x00, 0x48},
+    {0x1, 0x00, 0x49},
+    {0x1, 0x00, 0x4A},
+    {0x1, 0x00, 0x4B},
+    {0x1, 0x00, 0x4C},
+    {0x1, 0x00, 0x4D},
+    {0x1, 0x00, 0x4E},
+    {0x1, 0x00, 0x4F},
+    {0x1, 0x00, 0x50},
+    {0x1, 0x00, 0x51},
+    {0x1, 0x00, 0x52},
+    {0x1, 0x00, 0x53},
+    {0x1, 0x00, 0x54},
+    {0x1, 0x00, 0x55},
+    {0x1, 0x00, 0x56},
+    {0x1, 0x00, 0x57},
+    {0x1, 0x00, 0x58},
+    {0x1, 0x00, 0x59},
+    {0x1, 0x00, 0x5A},
+    {0x2, 0x03, 0x00},
+    {0x2, 0x00, 0x01},
+    {0x2, 0x00, 0x05},
+    {0x2, 0x00, 0x06},
+    {0x2, 0x00, 0x07},
+    {0x2, 0x00, 0x10},
+    {0x2, 0x00, 0x11},
+    /* Strange - looks like the 501 driver doesn't do anything 
+     * at insert time except read the EEPROM 
+     */
+    {0x0, 0x0, 0x0}
+};
+
+/* Data for video camera init before capture.
+ * Capture and decoding by Colin Peart.
+ * This is is for the 3com HomeConnect Lite which is spca501a based.
+ */
+static __u16 spca501_3com_open_data[][3] = {
+    /* bmRequest,value,index */
+    {0x2, 0x0050, 0x0000},	//C/S Enable TG soft reset, timing mode=010
+    {0x2, 0x0043, 0x0000},	//C/S Disable TG soft reset, timing mode=010
+    {0x2, 0x0002, 0x0005},	//C/S GPIO
+    {0x2, 0x0003, 0x0005},	//C/S GPIO
+
+#ifdef CCDSP_SET
+    {0x1, 0x0020, 0x0001},	//CCDSP Options
+
+    {0x1, 0x0020, 0x0002},	//CCDSP Black Level
+    {0x1, 0x006e, 0x0007},	//CCDSP Gamma options
+    {0x1, 0x0090, 0x0015},	//CCDSP Luminance Low
+    {0x1, 0x00ff, 0x0016},	//CCDSP Luminance High
+    {0x1, 0x0003, 0x003F},	//CCDSP Gamma correction toggle
+
+#ifdef ALTER_GAMMA
+    {0x1, 0x0010, 0x0008},	//CCDSP YUV A11 
+    {0x1, 0x0000, 0x0009},	//CCDSP YUV A12 
+    {0x1, 0x0000, 0x000a},	//CCDSP YUV A13 
+    {0x1, 0x0000, 0x000b},	//CCDSP YUV A21 
+    {0x1, 0x0010, 0x000c},	//CCDSP YUV A22 
+    {0x1, 0x0000, 0x000d},	//CCDSP YUV A23 
+    {0x1, 0x0000, 0x000e},	//CCDSP YUV A31 
+    {0x1, 0x0000, 0x000f},	//CCDSP YUV A32 
+    {0x1, 0x0010, 0x0010},	//CCDSP YUV A33 
+    {0x1, 0x0000, 0x0011},	//CCDSP R Offset
+    {0x1, 0x0000, 0x0012},	//CCDSP G Offset
+    {0x1, 0x0001, 0x0013},	//CCDSP B Offset
+    {0x1, 0x0001, 0x0014},	//CCDSP BG Offset
+    {0x1, 0x003f, 0x00C1},	//CCDSP Gamma Correction Enable
+#endif
+#endif
+
+#ifdef TG_SET
+    {0x0, 0x00fc, 0x0000},	//TG Shutter Speed High Bits
+    {0x0, 0x0000, 0x0001},	//TG Shutter Speed Low Bits
+    {0x0, 0x00e4, 0x0004},	//TG DCLK*2 Adjust
+    {0x0, 0x0008, 0x0005},	//TG ADCK Adjust
+    {0x0, 0x0003, 0x0006},	//TG FR Phase Adjust
+    {0x0, 0x0001, 0x0007},	//TG FCDS Phase Adjust
+    {0x0, 0x0039, 0x0008},	//TG FS Phase Adjust
+    {0x0, 0x0088, 0x000a},	//TG MH1
+    {0x0, 0x0003, 0x000f},	//TG Pixel ID
+
+    /* Like below, unexplained toglleing */
+    {0x0, 0x0080, 0x000c},
+    {0x0, 0x0000, 0x000d},
+    {0x0, 0x0080, 0x000c},
+    {0x0, 0x0004, 0x000d},
+    {0x0, 0x0000, 0x000c},
+    {0x0, 0x0000, 0x000d},
+    {0x0, 0x0040, 0x000c},
+    {0x0, 0x0017, 0x000d},
+    {0x0, 0x00c0, 0x000c},
+    {0x0, 0x0000, 0x000d},
+    {0x0, 0x0080, 0x000c},
+    {0x0, 0x0006, 0x000d},
+    {0x0, 0x0080, 0x000c},
+    {0x0, 0x0004, 0x000d},
+    {0x0, 0x0002, 0x0003},
+#endif
+
+#ifdef DSPWIN_SET
+    {0x1, 0x001c, 0x0017},	//CCDSP W1 Start X
+    {0x1, 0x00e2, 0x0019},	//CCDSP W2 Start X
+    {0x1, 0x001c, 0x001b},	//CCDSP W3 Start X
+    {0x1, 0x00e2, 0x001d},	//CCDSP W4 Start X
+    {0x1, 0x00aa, 0x001f},	//CCDSP W5 Start X
+    {0x1, 0x0070, 0x0020},	//CCDSP W5 Start Y
+#endif
+    {0x0, 0x0001, 0x0010},	//TG Start Clock
+
+//{0x2, 0x006a, 0x0001},                //C/S Enable ISOSYNCH Packet Engine
+    {0x2, 0x0068, 0x0001},	//C/S Diable ISOSYNCH Packet Engine
+    {0x2, 0x0000, 0x0005},
+    {0x2, 0x0043, 0x0000},	//C/S Set Timing Mode, Disable TG soft reset
+    {0x2, 0x0043, 0x0000},	//C/S Set Timing Mode, Disable TG soft reset
+    {0x2, 0x0002, 0x0005},	//C/S GPIO
+    {0x2, 0x0003, 0x0005},	//C/S GPIO
+
+    {0x2, 0x006a, 0x0001},	//C/S Enable ISOSYNCH Packet Engine
+    {0, 0, 0}
+};
+
+/*
+ * Data used to initialize a SPCA501C with HV7131B sensor.
+ * From a capture file taken with USBSnoop v 1.5
+ * I have a "SPCA501C pc camera chipset" manual by sunplus, but some
+ * of the value meanings are obscure or simply "reserved".
+ * to do list:
+ * 1) Understand what every value means
+ * 2) Understand why some values seem to appear more than once
+ * 3) Write a small comment for each line of the following arrays.
+ */
+
+static __u16 spca501c_arowana_open_data[][3] = {
+    /* bmRequest,value,index */
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x01, 0x0006, 0x0011},
+    {0x01, 0x00ff, 0x0012},
+    {0x01, 0x0014, 0x0013},
+    {0x01, 0x0000, 0x0014},
+    {0x01, 0x0042, 0x0051},
+    {0x01, 0x0040, 0x0052},
+    {0x01, 0x0051, 0x0053},
+    {0x01, 0x0040, 0x0054},
+    {0x01, 0x0000, 0x0055},
+    {0x00, 0x0025, 0x0000},
+    {0x00, 0x0026, 0x0000},
+    {0x00, 0x0001, 0x0000},
+    {0x00, 0x0027, 0x0000},
+    {0x00, 0x008a, 0x0000},
+    {0x00, 0x0000, 0x0000}
+};
+
+static __u16 spca501c_arowana_init_data[][3] = {
+    /* bmRequest,value,index */
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x01, 0x0006, 0x0011},
+    {0x01, 0x00ff, 0x0012},
+    {0x01, 0x0014, 0x0013},
+    {0x01, 0x0000, 0x0014},
+    {0x01, 0x0042, 0x0051},
+    {0x01, 0x0040, 0x0052},
+    {0x01, 0x0051, 0x0053},
+    {0x01, 0x0040, 0x0054},
+    {0x01, 0x0000, 0x0055},
+    {0x00, 0x0025, 0x0000},
+    {0x00, 0x0026, 0x0000},
+    {0x00, 0x0001, 0x0000},
+    {0x00, 0x0027, 0x0000},
+    {0x00, 0x008a, 0x0000},
+    {0x02, 0x0000, 0x0005},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x2000, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0015, 0x0001},
+    {0x05, 0x00ea, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0023, 0x0001},
+    {0x05, 0x0003, 0x0000},
+    {0x05, 0x0030, 0x0001},
+    {0x05, 0x002b, 0x0000},
+    {0x05, 0x0031, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0032, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0033, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0034, 0x0001},
+    {0x05, 0x0002, 0x0000},
+    {0x05, 0x0050, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0051, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0052, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0054, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x00, 0x0000, 0x0001},
+    {0x00, 0x0000, 0x0002},
+    {0x00, 0x000c, 0x0003},
+    {0x00, 0x0000, 0x0004},
+    {0x00, 0x0090, 0x0005},
+    {0x00, 0x0000, 0x0006},
+    {0x00, 0x0040, 0x0007},
+    {0x00, 0x00c0, 0x0008},
+    {0x00, 0x004a, 0x0009},
+    {0x00, 0x0000, 0x000a},
+    {0x00, 0x0000, 0x000b},
+    {0x00, 0x0001, 0x000c},
+    {0x00, 0x0001, 0x000d},
+    {0x00, 0x0000, 0x000e},
+    {0x00, 0x0002, 0x000f},
+    {0x00, 0x0001, 0x0010},
+    {0x00, 0x0000, 0x0011},
+    {0x00, 0x0000, 0x0012},
+    {0x00, 0x0002, 0x0020},
+    {0x00, 0x0080, 0x0021},
+    {0x00, 0x0001, 0x0022},
+    {0x00, 0x00e0, 0x0023},
+    {0x00, 0x0000, 0x0024},
+    {0x00, 0x00d5, 0x0025},
+    {0x00, 0x0000, 0x0026},
+    {0x00, 0x000b, 0x0027},
+    {0x00, 0x0000, 0x0046},
+    {0x00, 0x0000, 0x0047},
+    {0x00, 0x0000, 0x0048},
+    {0x00, 0x0000, 0x0049},
+    {0x00, 0x0008, 0x004a},
+    {0xff, 0x0000, 0x00d0},
+    {0xff, 0x00d8, 0x00d1},
+    {0xff, 0x0000, 0x00d4},
+    {0xff, 0x0000, 0x00d5},
+    {0x01, 0x00a6, 0x0000},
+    {0x01, 0x0028, 0x0001},
+    {0x01, 0x0000, 0x0002},
+    {0x01, 0x000a, 0x0003},
+    {0x01, 0x0040, 0x0004},
+    {0x01, 0x0066, 0x0007},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0x00fd, 0x000a},
+    {0x01, 0x0038, 0x000b},
+    {0x01, 0x00d1, 0x000c},
+    {0x01, 0x00f7, 0x000d},
+    {0x01, 0x00ed, 0x000e},
+    {0x01, 0x00d8, 0x000f},
+    {0x01, 0x0038, 0x0010},
+    {0x01, 0x00ff, 0x0015},
+    {0x01, 0x0001, 0x0016},
+    {0x01, 0x0032, 0x0017},
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x0000, 0x001f},
+    {0x01, 0x0000, 0x0020},
+    {0x01, 0x00ff, 0x003e},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0000, 0x0040},
+    {0x01, 0x0035, 0x0041},
+    {0x01, 0x0053, 0x0042},
+    {0x01, 0x0069, 0x0043},
+    {0x01, 0x007c, 0x0044},
+    {0x01, 0x008c, 0x0045},
+    {0x01, 0x009a, 0x0046},
+    {0x01, 0x00a8, 0x0047},
+    {0x01, 0x00b4, 0x0048},
+    {0x01, 0x00bf, 0x0049},
+    {0x01, 0x00ca, 0x004a},
+    {0x01, 0x00d4, 0x004b},
+    {0x01, 0x00dd, 0x004c},
+    {0x01, 0x00e7, 0x004d},
+    {0x01, 0x00ef, 0x004e},
+    {0x01, 0x00f8, 0x004f},
+    {0x01, 0x00ff, 0x0050},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0060, 0x0057},
+    {0x01, 0x0040, 0x0058},
+    {0x01, 0x0011, 0x0059},
+    {0x01, 0x0001, 0x005a},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x0015, 0x0006},
+    {0x02, 0x100a, 0x0007},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x000f, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0025, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0001, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0020, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x00, 0x0090, 0x0005},
+    {0x01, 0x00a6, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x2000, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0015, 0x0001},
+    {0x05, 0x00ea, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0023, 0x0001},
+    {0x05, 0x0003, 0x0000},
+    {0x05, 0x0030, 0x0001},
+    {0x05, 0x002b, 0x0000},
+    {0x05, 0x0031, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0032, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0033, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0034, 0x0001},
+    {0x05, 0x0002, 0x0000},
+    {0x05, 0x0050, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0051, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0052, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0054, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x00, 0x0000, 0x0001},
+    {0x00, 0x0000, 0x0002},
+    {0x00, 0x000c, 0x0003},
+    {0x00, 0x0000, 0x0004},
+    {0x00, 0x0090, 0x0005},
+    {0x00, 0x0000, 0x0006},
+    {0x00, 0x0040, 0x0007},
+    {0x00, 0x00c0, 0x0008},
+    {0x00, 0x004a, 0x0009},
+    {0x00, 0x0000, 0x000a},
+    {0x00, 0x0000, 0x000b},
+    {0x00, 0x0001, 0x000c},
+    {0x00, 0x0001, 0x000d},
+    {0x00, 0x0000, 0x000e},
+    {0x00, 0x0002, 0x000f},
+    {0x00, 0x0001, 0x0010},
+    {0x00, 0x0000, 0x0011},
+    {0x00, 0x0000, 0x0012},
+    {0x00, 0x0002, 0x0020},
+    {0x00, 0x0080, 0x0021},
+    {0x00, 0x0001, 0x0022},
+    {0x00, 0x00e0, 0x0023},
+    {0x00, 0x0000, 0x0024},
+    {0x00, 0x00d5, 0x0025},
+    {0x00, 0x0000, 0x0026},
+    {0x00, 0x000b, 0x0027},
+    {0x00, 0x0000, 0x0046},
+    {0x00, 0x0000, 0x0047},
+    {0x00, 0x0000, 0x0048},
+    {0x00, 0x0000, 0x0049},
+    {0x00, 0x0008, 0x004a},
+    {0xff, 0x0000, 0x00d0},
+    {0xff, 0x00d8, 0x00d1},
+    {0xff, 0x0000, 0x00d4},
+    {0xff, 0x0000, 0x00d5},
+    {0x01, 0x00a6, 0x0000},
+    {0x01, 0x0028, 0x0001},
+    {0x01, 0x0000, 0x0002},
+    {0x01, 0x000a, 0x0003},
+    {0x01, 0x0040, 0x0004},
+    {0x01, 0x0066, 0x0007},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0x00fd, 0x000a},
+    {0x01, 0x0038, 0x000b},
+    {0x01, 0x00d1, 0x000c},
+    {0x01, 0x00f7, 0x000d},
+    {0x01, 0x00ed, 0x000e},
+    {0x01, 0x00d8, 0x000f},
+    {0x01, 0x0038, 0x0010},
+    {0x01, 0x00ff, 0x0015},
+    {0x01, 0x0001, 0x0016},
+    {0x01, 0x0032, 0x0017},
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x0000, 0x001f},
+    {0x01, 0x0000, 0x0020},
+    {0x01, 0x00ff, 0x003e},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0000, 0x0040},
+    {0x01, 0x0035, 0x0041},
+    {0x01, 0x0053, 0x0042},
+    {0x01, 0x0069, 0x0043},
+    {0x01, 0x007c, 0x0044},
+    {0x01, 0x008c, 0x0045},
+    {0x01, 0x009a, 0x0046},
+    {0x01, 0x00a8, 0x0047},
+    {0x01, 0x00b4, 0x0048},
+    {0x01, 0x00bf, 0x0049},
+    {0x01, 0x00ca, 0x004a},
+    {0x01, 0x00d4, 0x004b},
+    {0x01, 0x00dd, 0x004c},
+    {0x01, 0x00e7, 0x004d},
+    {0x01, 0x00ef, 0x004e},
+    {0x01, 0x00f8, 0x004f},
+    {0x01, 0x00ff, 0x0050},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0060, 0x0057},
+    {0x01, 0x0040, 0x0058},
+    {0x01, 0x0011, 0x0059},
+    {0x01, 0x0001, 0x005a},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x0015, 0x0006},
+    {0x02, 0x100a, 0x0007},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x000f, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0025, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0001, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0020, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x00, 0x0090, 0x0005},
+    {0x01, 0x00a6, 0x0000},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0xfffd, 0x000a},
+    {0x01, 0x0023, 0x000b},
+    {0x01, 0xffea, 0x000c},
+    {0x01, 0xfff4, 0x000d},
+    {0x01, 0xfffc, 0x000e},
+    {0x01, 0xffe3, 0x000f},
+    {0x01, 0x001f, 0x0010},
+    {0x01, 0x00a8, 0x0001},
+    {0x01, 0x0067, 0x0007},
+    {0x01, 0x0032, 0x0017},
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x00c8, 0x0015},
+    {0x01, 0x0032, 0x0016},
+    {0x01, 0x0000, 0x0011},
+    {0x01, 0x0000, 0x0012},
+    {0x01, 0x0000, 0x0013},
+    {0x01, 0x000a, 0x0003},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xc000, 0x0001},
+    {0x02, 0x0000, 0x0005},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x2000, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0015, 0x0001},
+    {0x05, 0x00ea, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0023, 0x0001},
+    {0x05, 0x0003, 0x0000},
+    {0x05, 0x0030, 0x0001},
+    {0x05, 0x002b, 0x0000},
+    {0x05, 0x0031, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0032, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0033, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0034, 0x0001},
+    {0x05, 0x0002, 0x0000},
+    {0x05, 0x0050, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0051, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0052, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0054, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x00, 0x0000, 0x0001},
+    {0x00, 0x0000, 0x0002},
+    {0x00, 0x000c, 0x0003},
+    {0x00, 0x0000, 0x0004},
+    {0x00, 0x0090, 0x0005},
+    {0x00, 0x0000, 0x0006},
+    {0x00, 0x0040, 0x0007},
+    {0x00, 0x00c0, 0x0008},
+    {0x00, 0x004a, 0x0009},
+    {0x00, 0x0000, 0x000a},
+    {0x00, 0x0000, 0x000b},
+    {0x00, 0x0001, 0x000c},
+    {0x00, 0x0001, 0x000d},
+    {0x00, 0x0000, 0x000e},
+    {0x00, 0x0002, 0x000f},
+    {0x00, 0x0001, 0x0010},
+    {0x00, 0x0000, 0x0011},
+    {0x00, 0x0000, 0x0012},
+    {0x00, 0x0002, 0x0020},
+    {0x00, 0x0080, 0x0021},
+    {0x00, 0x0001, 0x0022},
+    {0x00, 0x00e0, 0x0023},
+    {0x00, 0x0000, 0x0024},
+    {0x00, 0x00d5, 0x0025},
+    {0x00, 0x0000, 0x0026},
+    {0x00, 0x000b, 0x0027},
+    {0x00, 0x0000, 0x0046},
+    {0x00, 0x0000, 0x0047},
+    {0x00, 0x0000, 0x0048},
+    {0x00, 0x0000, 0x0049},
+    {0x00, 0x0008, 0x004a},
+    {0xff, 0x0000, 0x00d0},
+    {0xff, 0x00d8, 0x00d1},
+    {0xff, 0x0000, 0x00d4},
+    {0xff, 0x0000, 0x00d5},
+    {0x01, 0x00a6, 0x0000},
+    {0x01, 0x0028, 0x0001},
+    {0x01, 0x0000, 0x0002},
+    {0x01, 0x000a, 0x0003},
+    {0x01, 0x0040, 0x0004},
+    {0x01, 0x0066, 0x0007},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0x00fd, 0x000a},
+    {0x01, 0x0038, 0x000b},
+    {0x01, 0x00d1, 0x000c},
+    {0x01, 0x00f7, 0x000d},
+    {0x01, 0x00ed, 0x000e},
+    {0x01, 0x00d8, 0x000f},
+    {0x01, 0x0038, 0x0010},
+    {0x01, 0x00ff, 0x0015},
+    {0x01, 0x0001, 0x0016},
+    {0x01, 0x0032, 0x0017},
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x0000, 0x001f},
+    {0x01, 0x0000, 0x0020},
+    {0x01, 0x00ff, 0x003e},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0000, 0x0040},
+    {0x01, 0x0035, 0x0041},
+    {0x01, 0x0053, 0x0042},
+    {0x01, 0x0069, 0x0043},
+    {0x01, 0x007c, 0x0044},
+    {0x01, 0x008c, 0x0045},
+    {0x01, 0x009a, 0x0046},
+    {0x01, 0x00a8, 0x0047},
+    {0x01, 0x00b4, 0x0048},
+    {0x01, 0x00bf, 0x0049},
+    {0x01, 0x00ca, 0x004a},
+    {0x01, 0x00d4, 0x004b},
+    {0x01, 0x00dd, 0x004c},
+    {0x01, 0x00e7, 0x004d},
+    {0x01, 0x00ef, 0x004e},
+    {0x01, 0x00f8, 0x004f},
+    {0x01, 0x00ff, 0x0050},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0060, 0x0057},
+    {0x01, 0x0040, 0x0058},
+    {0x01, 0x0011, 0x0059},
+    {0x01, 0x0001, 0x005a},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x0015, 0x0006},
+    {0x02, 0x100a, 0x0007},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x000f, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0025, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0001, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0020, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x00, 0x0090, 0x0005},
+    {0x01, 0x00a6, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x2000, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0015, 0x0001},
+    {0x05, 0x00ea, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0023, 0x0001},
+    {0x05, 0x0003, 0x0000},
+    {0x05, 0x0030, 0x0001},
+    {0x05, 0x002b, 0x0000},
+    {0x05, 0x0031, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0032, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0033, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0034, 0x0001},
+    {0x05, 0x0002, 0x0000},
+    {0x05, 0x0050, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0051, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0052, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0054, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x00, 0x0000, 0x0001},
+    {0x00, 0x0000, 0x0002},
+    {0x00, 0x000c, 0x0003},
+    {0x00, 0x0000, 0x0004},
+    {0x00, 0x0090, 0x0005},
+    {0x00, 0x0000, 0x0006},
+    {0x00, 0x0040, 0x0007},
+    {0x00, 0x00c0, 0x0008},
+    {0x00, 0x004a, 0x0009},
+    {0x00, 0x0000, 0x000a},
+    {0x00, 0x0000, 0x000b},
+    {0x00, 0x0001, 0x000c},
+    {0x00, 0x0001, 0x000d},
+    {0x00, 0x0000, 0x000e},
+    {0x00, 0x0002, 0x000f},
+    {0x00, 0x0001, 0x0010},
+    {0x00, 0x0000, 0x0011},
+    {0x00, 0x0000, 0x0012},
+    {0x00, 0x0002, 0x0020},
+    {0x00, 0x0080, 0x0021},
+    {0x00, 0x0001, 0x0022},
+    {0x00, 0x00e0, 0x0023},
+    {0x00, 0x0000, 0x0024},
+    {0x00, 0x00d5, 0x0025},
+    {0x00, 0x0000, 0x0026},
+    {0x00, 0x000b, 0x0027},
+    {0x00, 0x0000, 0x0046},
+    {0x00, 0x0000, 0x0047},
+    {0x00, 0x0000, 0x0048},
+    {0x00, 0x0000, 0x0049},
+    {0x00, 0x0008, 0x004a},
+    {0xff, 0x0000, 0x00d0},
+    {0xff, 0x00d8, 0x00d1},
+    {0xff, 0x0000, 0x00d4},
+    {0xff, 0x0000, 0x00d5},
+    {0x01, 0x00a6, 0x0000},
+    {0x01, 0x0028, 0x0001},
+    {0x01, 0x0000, 0x0002},
+    {0x01, 0x000a, 0x0003},
+    {0x01, 0x0040, 0x0004},
+    {0x01, 0x0066, 0x0007},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0x00fd, 0x000a},
+    {0x01, 0x0038, 0x000b},
+    {0x01, 0x00d1, 0x000c},
+    {0x01, 0x00f7, 0x000d},
+    {0x01, 0x00ed, 0x000e},
+    {0x01, 0x00d8, 0x000f},
+    {0x01, 0x0038, 0x0010},
+    {0x01, 0x00ff, 0x0015},
+    {0x01, 0x0001, 0x0016},
+    {0x01, 0x0032, 0x0017},
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x0000, 0x001f},
+    {0x01, 0x0000, 0x0020},
+    {0x01, 0x00ff, 0x003e},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0000, 0x0040},
+    {0x01, 0x0035, 0x0041},
+    {0x01, 0x0053, 0x0042},
+    {0x01, 0x0069, 0x0043},
+    {0x01, 0x007c, 0x0044},
+    {0x01, 0x008c, 0x0045},
+    {0x01, 0x009a, 0x0046},
+    {0x01, 0x00a8, 0x0047},
+    {0x01, 0x00b4, 0x0048},
+    {0x01, 0x00bf, 0x0049},
+    {0x01, 0x00ca, 0x004a},
+    {0x01, 0x00d4, 0x004b},
+    {0x01, 0x00dd, 0x004c},
+    {0x01, 0x00e7, 0x004d},
+    {0x01, 0x00ef, 0x004e},
+    {0x01, 0x00f8, 0x004f},
+    {0x01, 0x00ff, 0x0050},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0060, 0x0057},
+    {0x01, 0x0040, 0x0058},
+    {0x01, 0x0011, 0x0059},
+    {0x01, 0x0001, 0x005a},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x0015, 0x0006},
+    {0x02, 0x100a, 0x0007},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x000f, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0025, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0001, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0020, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x00, 0x0090, 0x0005},
+    {0x01, 0x00a6, 0x0000},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x000f, 0x0000},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0xfffd, 0x000a},
+    {0x01, 0x0023, 0x000b},
+    {0x01, 0xffea, 0x000c},
+    {0x01, 0xfff4, 0x000d},
+    {0x01, 0xfffc, 0x000e},
+    {0x01, 0xffe3, 0x000f},
+    {0x01, 0x001f, 0x0010},
+    {0x01, 0x00a8, 0x0001},
+    {0x01, 0x0067, 0x0007},
+    {0x01, 0x0042, 0x0051},
+    {0x01, 0x0051, 0x0053},
+    {0x01, 0x000a, 0x0003},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xc000, 0x0001},
+    {0x02, 0x0000, 0x0005},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x2000, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0015, 0x0001},
+    {0x05, 0x00ea, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0023, 0x0001},
+    {0x05, 0x0003, 0x0000},
+    {0x05, 0x0030, 0x0001},
+    {0x05, 0x002b, 0x0000},
+    {0x05, 0x0031, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0032, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0033, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0034, 0x0001},
+    {0x05, 0x0002, 0x0000},
+    {0x05, 0x0050, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0051, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0052, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0054, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x00, 0x0000, 0x0001},
+    {0x00, 0x0000, 0x0002},
+    {0x00, 0x000c, 0x0003},
+    {0x00, 0x0000, 0x0004},
+    {0x00, 0x0090, 0x0005},
+    {0x00, 0x0000, 0x0006},
+    {0x00, 0x0040, 0x0007},
+    {0x00, 0x00c0, 0x0008},
+    {0x00, 0x004a, 0x0009},
+    {0x00, 0x0000, 0x000a},
+    {0x00, 0x0000, 0x000b},
+    {0x00, 0x0001, 0x000c},
+    {0x00, 0x0001, 0x000d},
+    {0x00, 0x0000, 0x000e},
+    {0x00, 0x0002, 0x000f},
+    {0x00, 0x0001, 0x0010},
+    {0x00, 0x0000, 0x0011},
+    {0x00, 0x0000, 0x0012},
+    {0x00, 0x0002, 0x0020},
+    {0x00, 0x0080, 0x0021},
+    {0x00, 0x0001, 0x0022},
+    {0x00, 0x00e0, 0x0023},
+    {0x00, 0x0000, 0x0024},
+    {0x00, 0x00d5, 0x0025},
+    {0x00, 0x0000, 0x0026},
+    {0x00, 0x000b, 0x0027},
+    {0x00, 0x0000, 0x0046},
+    {0x00, 0x0000, 0x0047},
+    {0x00, 0x0000, 0x0048},
+    {0x00, 0x0000, 0x0049},
+    {0x00, 0x0008, 0x004a},
+    {0xff, 0x0000, 0x00d0},
+    {0xff, 0x00d8, 0x00d1},
+    {0xff, 0x0000, 0x00d4},
+    {0xff, 0x0000, 0x00d5},
+    {0x01, 0x00a6, 0x0000},
+    {0x01, 0x0028, 0x0001},
+    {0x01, 0x0000, 0x0002},
+    {0x01, 0x000a, 0x0003},
+    {0x01, 0x0040, 0x0004},
+    {0x01, 0x0066, 0x0007},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0x00fd, 0x000a},
+    {0x01, 0x0038, 0x000b},
+    {0x01, 0x00d1, 0x000c},
+    {0x01, 0x00f7, 0x000d},
+    {0x01, 0x00ed, 0x000e},
+    {0x01, 0x00d8, 0x000f},
+    {0x01, 0x0038, 0x0010},
+    {0x01, 0x00ff, 0x0015},
+    {0x01, 0x0001, 0x0016},
+    {0x01, 0x0032, 0x0017},
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x0000, 0x001f},
+    {0x01, 0x0000, 0x0020},
+    {0x01, 0x00ff, 0x003e},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0000, 0x0040},
+    {0x01, 0x0035, 0x0041},
+    {0x01, 0x0053, 0x0042},
+    {0x01, 0x0069, 0x0043},
+    {0x01, 0x007c, 0x0044},
+    {0x01, 0x008c, 0x0045},
+    {0x01, 0x009a, 0x0046},
+    {0x01, 0x00a8, 0x0047},
+    {0x01, 0x00b4, 0x0048},
+    {0x01, 0x00bf, 0x0049},
+    {0x01, 0x00ca, 0x004a},
+    {0x01, 0x00d4, 0x004b},
+    {0x01, 0x00dd, 0x004c},
+    {0x01, 0x00e7, 0x004d},
+    {0x01, 0x00ef, 0x004e},
+    {0x01, 0x00f8, 0x004f},
+    {0x01, 0x00ff, 0x0050},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0060, 0x0057},
+    {0x01, 0x0040, 0x0058},
+    {0x01, 0x0011, 0x0059},
+    {0x01, 0x0001, 0x005a},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x0015, 0x0006},
+    {0x02, 0x100a, 0x0007},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x000f, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0025, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0001, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0020, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x00, 0x0090, 0x0005},
+    {0x01, 0x00a6, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x2000, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0015, 0x0001},
+    {0x05, 0x00ea, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0023, 0x0001},
+    {0x05, 0x0003, 0x0000},
+    {0x05, 0x0030, 0x0001},
+    {0x05, 0x002b, 0x0000},
+    {0x05, 0x0031, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0032, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0033, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0034, 0x0001},
+    {0x05, 0x0002, 0x0000},
+    {0x05, 0x0050, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0051, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0052, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0054, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x00, 0x0000, 0x0001},
+    {0x00, 0x0000, 0x0002},
+    {0x00, 0x000c, 0x0003},
+    {0x00, 0x0000, 0x0004},
+    {0x00, 0x0090, 0x0005},
+    {0x00, 0x0000, 0x0006},
+    {0x00, 0x0040, 0x0007},
+    {0x00, 0x00c0, 0x0008},
+    {0x00, 0x004a, 0x0009},
+    {0x00, 0x0000, 0x000a},
+    {0x00, 0x0000, 0x000b},
+    {0x00, 0x0001, 0x000c},
+    {0x00, 0x0001, 0x000d},
+    {0x00, 0x0000, 0x000e},
+    {0x00, 0x0002, 0x000f},
+    {0x00, 0x0001, 0x0010},
+    {0x00, 0x0000, 0x0011},
+    {0x00, 0x0000, 0x0012},
+    {0x00, 0x0002, 0x0020},
+    {0x00, 0x0080, 0x0021},
+    {0x00, 0x0001, 0x0022},
+    {0x00, 0x00e0, 0x0023},
+    {0x00, 0x0000, 0x0024},
+    {0x00, 0x00d5, 0x0025},
+    {0x00, 0x0000, 0x0026},
+    {0x00, 0x000b, 0x0027},
+    {0x00, 0x0000, 0x0046},
+    {0x00, 0x0000, 0x0047},
+    {0x00, 0x0000, 0x0048},
+    {0x00, 0x0000, 0x0049},
+    {0x00, 0x0008, 0x004a},
+    {0xff, 0x0000, 0x00d0},
+    {0xff, 0x00d8, 0x00d1},
+    {0xff, 0x0000, 0x00d4},
+    {0xff, 0x0000, 0x00d5},
+    {0x01, 0x00a6, 0x0000},
+    {0x01, 0x0028, 0x0001},
+    {0x01, 0x0000, 0x0002},
+    {0x01, 0x000a, 0x0003},
+    {0x01, 0x0040, 0x0004},
+    {0x01, 0x0066, 0x0007},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0x00fd, 0x000a},
+    {0x01, 0x0038, 0x000b},
+    {0x01, 0x00d1, 0x000c},
+    {0x01, 0x00f7, 0x000d},
+    {0x01, 0x00ed, 0x000e},
+    {0x01, 0x00d8, 0x000f},
+    {0x01, 0x0038, 0x0010},
+    {0x01, 0x00ff, 0x0015},
+    {0x01, 0x0001, 0x0016},
+    {0x01, 0x0032, 0x0017},
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x0000, 0x001f},
+    {0x01, 0x0000, 0x0020},
+    {0x01, 0x00ff, 0x003e},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0000, 0x0040},
+    {0x01, 0x0035, 0x0041},
+    {0x01, 0x0053, 0x0042},
+    {0x01, 0x0069, 0x0043},
+    {0x01, 0x007c, 0x0044},
+    {0x01, 0x008c, 0x0045},
+    {0x01, 0x009a, 0x0046},
+    {0x01, 0x00a8, 0x0047},
+    {0x01, 0x00b4, 0x0048},
+    {0x01, 0x00bf, 0x0049},
+    {0x01, 0x00ca, 0x004a},
+    {0x01, 0x00d4, 0x004b},
+    {0x01, 0x00dd, 0x004c},
+    {0x01, 0x00e7, 0x004d},
+    {0x01, 0x00ef, 0x004e},
+    {0x01, 0x00f8, 0x004f},
+    {0x01, 0x00ff, 0x0050},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0060, 0x0057},
+    {0x01, 0x0040, 0x0058},
+    {0x01, 0x0011, 0x0059},
+    {0x01, 0x0001, 0x005a},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x0015, 0x0006},
+    {0x02, 0x100a, 0x0007},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x000f, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0025, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0001, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0020, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x00, 0x0090, 0x0005},
+    {0x01, 0x00a6, 0x0000},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x001e, 0x0000},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x0011, 0x0008},
+    {0x01, 0x0032, 0x0009},
+    {0x01, 0xfffd, 0x000a},
+    {0x01, 0x0023, 0x000b},
+    {0x01, 0xffea, 0x000c},
+    {0x01, 0xfff4, 0x000d},
+    {0x01, 0xfffc, 0x000e},
+    {0x01, 0xffe3, 0x000f},
+    {0x01, 0x001f, 0x0010},
+    {0x01, 0x00a8, 0x0001},
+    {0x01, 0x0067, 0x0007},
+    {0x01, 0x0042, 0x0051},
+    {0x01, 0x0051, 0x0053},
+    {0x01, 0x000a, 0x0003},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x0007, 0x0005},
+    {0x01, 0x0042, 0x0051},
+    {0x01, 0x0051, 0x0053},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x002d, 0x0000},
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0001, 0x0056},
+    {0x02, 0xc000, 0x0001},
+    {0x02, 0x0000, 0x0005},
+    {0x00, 0x0000, 0x0000}
+};
+
+/* Unknow camera from Ori Usbid 0x0000:0x0000 */
+static __u16 spca501c_mysterious_open_data[][3] = {	/* Based on snoops from Ori Cohen */
+    {0x02, 0x000f, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+/* DSP Registers     */
+    {0x01, 0x0016, 0x0011},	//RGB offset
+    {0x01, 0x0000, 0x0012},
+    {0x01, 0x0006, 0x0013},
+    {0x01, 0x0078, 0x0051},
+    {0x01, 0x0040, 0x0052},
+    {0x01, 0x0046, 0x0053},
+    {0x01, 0x0040, 0x0054},
+    {0x00, 0x0025, 0x0000},
+//{0x00, 0x0000, 0x0000 },
+/* Part 2            */
+/* TG Registers      */
+    {0x00, 0x0026, 0x0000},
+    {0x00, 0x0001, 0x0000},
+    {0x00, 0x0027, 0x0000},
+    {0x00, 0x008a, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x2000, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0015, 0x0001},
+    {0x05, 0x00ea, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0023, 0x0001},
+    {0x05, 0x0003, 0x0000},
+    {0x05, 0x0030, 0x0001},
+    {0x05, 0x002b, 0x0000},
+    {0x05, 0x0031, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0032, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0033, 0x0001},
+    {0x05, 0x0023, 0x0000},
+    {0x05, 0x0034, 0x0001},
+    {0x05, 0x0002, 0x0000},
+    {0x05, 0x0050, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0051, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0052, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0054, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0, 0, 0}
+};
+
+static __u16 spca501c_mysterious_init_data[][3] = {	/* Based on snoops from Ori Cohen */
+/* Part 3 */
+/* TG registers       */
+//{0x00, 0x0000, 0x0000 },
+    {0x00, 0x0000, 0x0001},
+    {0x00, 0x0000, 0x0002},
+    {0x00, 0x0006, 0x0003},
+    {0x00, 0x0000, 0x0004},
+    {0x00, 0x0090, 0x0005},
+    {0x00, 0x0000, 0x0006},
+    {0x00, 0x0040, 0x0007},
+    {0x00, 0x00c0, 0x0008},
+    {0x00, 0x004a, 0x0009},
+    {0x00, 0x0000, 0x000a},
+    {0x00, 0x0000, 0x000b},
+    {0x00, 0x0001, 0x000c},
+    {0x00, 0x0001, 0x000d},
+    {0x00, 0x0000, 0x000e},
+    {0x00, 0x0002, 0x000f},
+    {0x00, 0x0001, 0x0010},
+    {0x00, 0x0000, 0x0011},
+    {0x00, 0x0001, 0x0012},
+    {0x00, 0x0002, 0x0020},
+    {0x00, 0x0080, 0x0021},	//640
+    {0x00, 0x0001, 0x0022},
+    {0x00, 0x00e0, 0x0023},	//480
+    {0x00, 0x0000, 0x0024},	// Offset H hight
+    {0x00, 0x00d3, 0x0025},	// low
+    {0x00, 0x0000, 0x0026},	// Offset V
+    {0x00, 0x000d, 0x0027},	// low
+    {0x00, 0x0000, 0x0046},
+    {0x00, 0x0000, 0x0047},
+    {0x00, 0x0000, 0x0048},
+    {0x00, 0x0000, 0x0049},
+    {0x00, 0x0008, 0x004a},
+/* DSP Registers     */
+    {0x01, 0x00a6, 0x0000},
+    {0x01, 0x0028, 0x0001},
+    {0x01, 0x0000, 0x0002},
+    {0x01, 0x000a, 0x0003},	// Level Calc bit7 ->1 Auto
+    {0x01, 0x0040, 0x0004},
+    {0x01, 0x0066, 0x0007},
+    {0x01, 0x000f, 0x0008},	// A11 Color correction coeff
+    {0x01, 0x002d, 0x0009},	// A12
+    {0x01, 0x0005, 0x000a},	// A13
+    {0x01, 0x0023, 0x000b},	// A21
+    {0x01, 0x00e0, 0x000c},	// A22
+    {0x01, 0x00fd, 0x000d},	// A23
+    {0x01, 0x00f4, 0x000e},	// A31
+    {0x01, 0x00e4, 0x000f},	// A32
+    {0x01, 0x0028, 0x0010},	// A33
+    {0x01, 0x00ff, 0x0015},	// Reserved
+    {0x01, 0x0001, 0x0016},	// Reserved
+    {0x01, 0x0032, 0x0017},	// Win1 Start begin
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x0000, 0x001f},
+    {0x01, 0x0000, 0x0020},	//Win1 Start end
+    {0x01, 0x00ff, 0x003e},	//Reserved begin
+    {0x01, 0x0002, 0x003f},
+    {0x01, 0x0000, 0x0040},
+    {0x01, 0x0035, 0x0041},
+    {0x01, 0x0053, 0x0042},
+    {0x01, 0x0069, 0x0043},
+    {0x01, 0x007c, 0x0044},
+    {0x01, 0x008c, 0x0045},
+    {0x01, 0x009a, 0x0046},
+    {0x01, 0x00a8, 0x0047},
+    {0x01, 0x00b4, 0x0048},
+    {0x01, 0x00bf, 0x0049},
+    {0x01, 0x00ca, 0x004a},
+    {0x01, 0x00d4, 0x004b},
+    {0x01, 0x00dd, 0x004c},
+    {0x01, 0x00e7, 0x004d},
+    {0x01, 0x00ef, 0x004e},
+    {0x01, 0x00f8, 0x004f},
+    {0x01, 0x00ff, 0x0050},
+    {0x01, 0x0003, 0x0056},	// Reserved end
+    {0x01, 0x0060, 0x0057},	//Edge Gain
+    {0x01, 0x0040, 0x0058},	//
+    {0x01, 0x0011, 0x0059},	//Edge Bandwidth
+    {0x01, 0x0001, 0x005a},	//
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0x0007, 0x0005},
+    {0x02, 0x0015, 0x0006},
+    {0x02, 0x200a, 0x0007},
+    {0x02, 0xa048, 0x0000},
+    {0x02, 0xc000, 0x0001},
+    {0x02, 0x000f, 0x0005},
+    {0x02, 0xa048, 0x0000},
+    {0x05, 0x0022, 0x0004},
+    {0x05, 0x0025, 0x0001},
+    {0x05, 0x0000, 0x0000},
+/* Part 4             */
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0001, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x05, 0x0021, 0x0001},
+    {0x05, 0x00d2, 0x0000},
+    {0x05, 0x0020, 0x0001},
+    {0x05, 0x0000, 0x0000},
+    {0x00, 0x0090, 0x0005},
+    {0x01, 0x00a6, 0x0000},
+    {0x02, 0x0000, 0x0005},
+    {0x05, 0x0026, 0x0001},
+    {0x05, 0x0001, 0x0000},
+    {0x05, 0x0027, 0x0001},
+    {0x05, 0x004e, 0x0000},
+/* Part 5             */
+    {0x01, 0x0003, 0x003f},
+    {0x01, 0x0001, 0x0056},
+    {0x01, 0x000f, 0x0008},
+    {0x01, 0x002d, 0x0009},
+    {0x01, 0x0005, 0x000a},
+    {0x01, 0x0023, 0x000b},
+    {0x01, 0xffe0, 0x000c},
+    {0x01, 0xfffd, 0x000d},
+    {0x01, 0xfff4, 0x000e},
+    {0x01, 0xffe4, 0x000f},
+    {0x01, 0x0028, 0x0010},
+    {0x01, 0x00a8, 0x0001},
+    {0x01, 0x0066, 0x0007},
+    {0x01, 0x0032, 0x0017},
+    {0x01, 0x0023, 0x0018},
+    {0x01, 0x00ce, 0x0019},
+    {0x01, 0x0023, 0x001a},
+    {0x01, 0x0032, 0x001b},
+    {0x01, 0x008d, 0x001c},
+    {0x01, 0x00ce, 0x001d},
+    {0x01, 0x008d, 0x001e},
+    {0x01, 0x00c8, 0x0015},	//c8 Poids fort Luma
+    {0x01, 0x0032, 0x0016},	//32
+    {0x01, 0x0016, 0x0011},	//R 00
+    {0x01, 0x0016, 0x0012},	//G 00
+    {0x01, 0x0016, 0x0013},	//B 00
+    {0x01, 0x000a, 0x0003},
+    {0x02, 0xc002, 0x0001},
+    {0x02, 0x0007, 0x0005},
+    {0, 0, 0}
+};
+ 
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus/spca501_init.h linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca501_init.h
--- linux-2.6.21/drivers/media/video/gspca/Sunplus/spca501_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca501_init.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,309 @@
+/* 
+ * SPCA501 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA501_INIT_H
+#define SPCA501_INIT_H
+
+/*
+ * Data to initialize a SPCA501. From a capture file provided by Bill Roehl
+ * With SPCA501 chip description
+ */
+
+#define CCDSP_SET		// set CCDSP parameters
+#define TG_SET			// set time generator set
+#undef DSPWIN_SET		// set DSP windows parameters
+#undef ALTER_GAMA		// Set alternate set to YUV transform coeffs.
+#define SPCA501_SNAPBIT 0x80
+#define SPCA501_SNAPCTRL 0x10
+/* Frame packet header offsets for the spca501 */
+#define SPCA501_OFFSET_GPIO   1
+#define SPCA501_OFFSET_TYPE   2
+#define SPCA501_OFFSET_TURN3A 3
+#define SPCA501_OFFSET_FRAMSEQ 4
+#define SPCA501_OFFSET_COMPRESS 5
+#define SPCA501_OFFSET_QUANT 6
+#define SPCA501_OFFSET_QUANT2 7
+#define SPCA501_OFFSET_DATA 8
+
+#define SPCA501_PROP_COMP_ENABLE(d) ( (d) & 1 )
+#define SPCA501_PROP_SNAP(d) ( (d) & 0x40 )
+#define SPCA501_PROP_SNAP_CTRL(d) ( (d) & 0x10)
+#define SPCA501_PROP_COMP_THRESH(d) ( ((d) & 0xE ) >> 1)
+#define SPCA501_PROP_COMP_QUANT(d) ( ((d) & 0x70 ) >> 4)
+
+/* SPCA501 CCDSP control */
+#define SPCA501_REG_CCDSP 0x1
+/* SPCA501 control/status registers */
+#define SPCA501_REG_CTLRL 0x2
+
+//registers for color correction and YUV transformation
+#define SPCA501_A11 0x08
+#define SPCA501_A12 0x09
+#define SPCA501_A13 0x0A
+#define SPCA501_A21 0x0B
+#define SPCA501_A22 0x0C
+#define SPCA501_A23 0x0D
+#define SPCA501_A31 0x0E
+#define SPCA501_A32 0x0F
+#define SPCA501_A33 0x10
+
+#include "spca501.dat"
+
+/*******************     Camera Interface   ***********************/
+static __u16 spca501_getbrightness(struct usb_spca50x *spca50x);
+static __u16 spca501_getcontrast(struct usb_spca50x *spca50x);
+static __u16 spca501_getcolors(struct usb_spca50x *spca50x);
+static void spca501_setbrightness(struct usb_spca50x *spca50x);
+static void spca501_setcontrast(struct usb_spca50x *spca50x);
+static void spca501_setcolors(struct usb_spca50x *spca50x);
+static int spca501_init(struct usb_spca50x *spca50x);
+static void spca501_start(struct usb_spca50x *spca50x);
+static void spca501_stopN(struct usb_spca50x *spca50x);
+static void spca501_stop0(struct usb_spca50x *spca50x);
+static int spca501_config(struct usb_spca50x *spca50x);
+static void spca501_shutdown(struct usb_spca50x *spca50x);
+static void spca501_setAutobright(struct usb_spca50x *spca50x);
+static void spca501_setquality(struct usb_spca50x *spca50x);
+static int spca501_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum,int *datalength);
+/******************************************************************/
+static void spca501_stop0(struct usb_spca50x *spca50x){}
+static void spca501_setAutobright(struct usb_spca50x *spca50x){}
+static void spca501_setquality(struct usb_spca50x *spca50x){}
+/*****************************************************************/
+static struct cam_operation fspca501 = {
+ 	.initialize = spca501_init,
+	.configure = spca501_config,
+	.start = spca501_start,
+	.stopN = spca501_stopN,
+	.stop0 = spca501_stop0,
+	.get_bright = spca501_getbrightness,
+	.set_bright = spca501_setbrightness,
+	.get_contrast = spca501_getcontrast,
+	.set_contrast = spca501_setcontrast,
+	.get_colors = spca501_getcolors,
+	.set_colors = spca501_setcolors,
+	.set_autobright = spca501_setAutobright,
+	.set_quality = spca501_setquality,
+	.cam_shutdown = spca501_shutdown,
+	.sof_detect = spca501_sofdetect,
+ };
+static void spca501_shutdown(struct usb_spca50x *spca50x)
+{
+// This maybe reset or power control
+	    spca50x_reg_write(spca50x->dev, SPCA501_REG_CTLRL, 0x5, 0x0);
+}
+static __u16 spca501_getbrightness(struct usb_spca50x *spca50x)
+{
+__u16 brightness;
+ brightness =
+		spca50x_reg_read(spca50x->dev,SPCA501_REG_CCDSP , 0x11, 2) & 0xFF;
+	    brightness <<= 8;
+	    spca50x->brightness = brightness;
+  return spca50x->brightness;
+}
+static __u16 spca501_getcontrast(struct usb_spca50x *spca50x)
+{
+#if 0
+ __u8 byte = 0;
+ 	byte =(spca50x_reg_read(spca50x->dev,
+						     0x00,
+						     0x00,
+						     1) & 0xFF) << 8;
+	spca50x->contrast = byte | (spca50x_reg_read(spca50x->dev,
+						     0x00,
+						     0x01,
+						     1) & 0xFF);
+#endif
+spca50x->contrast = 0xaa01;						     
+PDEBUG(0, "SPCA501 Getcontrast %d",spca50x->contrast);
+return spca50x->contrast;
+}
+static void spca501_setbrightness(struct usb_spca50x *spca50x)
+{
+	spca50x_reg_write(spca50x->dev, SPCA501_REG_CCDSP, 0x11,
+			      spca50x->brightness >> 9);
+	spca50x_reg_write(spca50x->dev, SPCA501_REG_CCDSP, 0x12,
+			      spca50x->brightness >> 9);
+	spca50x_reg_write(spca50x->dev, SPCA501_REG_CCDSP, 0x13,
+			      spca50x->brightness >> 9);
+}
+static void spca501_setcontrast(struct usb_spca50x *spca50x)
+{
+spca50x_reg_write(spca50x->dev,0x00, 0x00,
+			      (spca50x->contrast >> 8) & 0xff);
+spca50x_reg_write(spca50x->dev,0x00, 0x01,
+			      spca50x->contrast & 0xff);			      
+}
+static int spca501_init(struct usb_spca50x *spca50x)
+{
+	    PDEBUG(2, "Initializing SPCA501 started");
+	    if (spca50x->dev->descriptor.idVendor == 0x0506
+		&& spca50x->dev->descriptor.idProduct == 0x00df) {
+		/* Special handling for 3com data */
+		spca50x_write_vector(spca50x, spca501_3com_open_data);
+	    } else if (spca50x->desc == Arowana300KCMOSCamera ||
+		       spca50x->desc == SmileIntlCamera) {
+		/* Arowana 300k CMOS Camera data */
+		spca50x_write_vector(spca50x, spca501c_arowana_open_data);
+	    } else if (spca50x->desc == MystFromOriUnknownCamera) {
+		/* UnKnow  CMOS Camera data */
+		spca50x_write_vector(spca50x,
+				     spca501c_mysterious_init_data);
+	    } else {
+		/* Generic 501 open data */
+		spca50x_write_vector(spca50x, spca501_open_data);
+	    }
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	    spca50x->a_blue = spca50x_reg_read(spca50x->dev,
+					       SPCA501_REG_CCDSP,
+					       SPCA501_A11, 2) & 0xFF;
+	    spca50x->a_green =
+		spca50x_reg_read(spca50x->dev, SPCA501_REG_CCDSP,
+				 SPCA501_A21, 2) & 0xFF;
+	    spca50x->a_red =
+		spca50x_reg_read(spca50x->dev, SPCA501_REG_CCDSP,
+				 SPCA501_A31, 2) & 0xFF;
+#endif				/* SPCA50X_ENABLE_EXPERIMENTAL */
+	    PDEBUG(2, "Initializing SPCA501 finished");
+return 0;
+}
+static void spca501_start(struct usb_spca50x *spca50x)
+{
+int err_code = 0;
+struct usb_device *dev = spca50x->dev;
+	    /* Enable ISO packet machine CTRL reg=2,
+	     * index=1 bitmask=0x2 (bit ordinal 1) */
+	spca50x_reg_write(dev, SPCA50X_REG_USB, 0x6, 0x94);
+	switch (spca50x->mode){
+	case 0: //640x480
+	spca50x_reg_write(dev, SPCA50X_REG_USB, 0x7,0x004a);
+	break;
+	case 1: //320x240
+	spca50x_reg_write(dev, SPCA50X_REG_USB, 0x7, 0x104a);
+	break;
+	case 2: //160x120
+	spca50x_reg_write(dev, SPCA50X_REG_USB, 0x7, 0x204a);
+	break;
+	default:
+	spca50x_reg_write(dev, SPCA50X_REG_USB, 0x7, 0x204a);
+	break;
+	}
+	err_code = spca50x_reg_write(dev, SPCA501_REG_CTLRL,
+					 (__u16) 0x1, (__u16) 0x2);
+}
+static void spca501_stopN(struct usb_spca50x *spca50x)
+{
+	    /* Disable ISO packet machine CTRL reg=2, index=1 bitmask=0x0 (bit ordinal 1) */
+	    spca50x_reg_write(spca50x->dev, SPCA501_REG_CTLRL,
+			      (__u16) 0x1, (__u16) 0x0);
+}
+static int spca501_config(struct usb_spca50x *spca50x)
+{
+   memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1023;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 0;
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1023;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 0;
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 1;
+    spca50x->mode_cam[SIF].mode = 0;
+    
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+        P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 896;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 1;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 896;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 1;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 896;
+    spca50x->mode_cam[QSIF].method = 1;
+    spca50x->mode_cam[QSIF].mode = 1;
+    
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+        P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 384;
+    spca50x->mode_cam[QCIF].method = 0;
+    spca50x->mode_cam[QCIF].mode = 2;
+    
+    	    if (spca50x->desc == Arowana300KCMOSCamera ||
+		spca50x->desc == SmileIntlCamera) {
+		/* Arowana 300k CMOS Camera data */
+		if (spca50x_write_vector
+		    (spca50x, spca501c_arowana_init_data))
+		    goto error;
+	    } else if (spca50x->desc == MystFromOriUnknownCamera) {
+		/* UnKnow Ori CMOS Camera data */
+		if (spca50x_write_vector
+		    (spca50x, spca501c_mysterious_open_data))
+		    goto error;
+	    } else {
+		/* generic spca501 init data */
+		if (spca50x_write_vector(spca50x, spca501_init_data))
+		    goto error;
+	    }
+return 0;
+error:
+return -EINVAL;
+}
+
+
+static __u16 spca501_getcolors(struct usb_spca50x *spca50x)
+{
+             spca50x->colour = (spca50x_reg_read(spca50x->dev,SPCA501_REG_CCDSP, 0x0c,
+			           2) & 0xFF) << 10;
+	     spca50x->hue = (spca50x_reg_read (spca50x->dev, SPCA501_REG_CCDSP, 0x13,
+			  2) & 0xFF) << 8;
+return spca50x->colour;
+}
+static void spca501_setcolors(struct usb_spca50x *spca50x)
+{
+             spca50x_reg_write(spca50x->dev,SPCA501_REG_CCDSP, 0x0c,
+			           spca50x->colour >> 10);
+}
+static int spca501_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum,int *datalength)
+{
+	switch (cdata[0]){
+	   case 0:
+	   	*iPix = SPCA501_OFFSET_DATA;
+		*datalength -= *iPix;
+	   	return 0;
+	   case SPCA50X_SEQUENCE_DROP:
+	   	return -1;
+	   default:
+	        *iPix = 1;
+	        *datalength -= *iPix;
+	   	return seqnum+1 ;
+	   }
+}
+
+			/* SPCA501_INIT_H */
+#endif
+//eof
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus/spca505.dat linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca505.dat
--- linux-2.6.21/drivers/media/video/gspca/Sunplus/spca505.dat	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca505.dat	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,540 @@
+/*
+ * Data to initialize a SPCA505. Common to the CCD and external modes
+ */
+static __u16 spca505_init_data[][3] = {
+    /* line       bmRequest,value,index */
+    /* 1819 */ {SPCA50X_REG_GLOBAL, SPCA50X_GMISC3_SAA7113RST, SPCA50X_GLOBAL_MISC3},
+    /* Sensor reset */
+    /* 1822 */ {SPCA50X_REG_GLOBAL, 0x0, SPCA50X_GLOBAL_MISC3},
+    /* 1825 */ {SPCA50X_REG_GLOBAL, 0x0, SPCA50X_GLOBAL_MISC1},
+    /* Block USB reset */
+    /* 1828 */ {SPCA50X_REG_GLOBAL, SPCA50X_GMISC0_IDSEL,
+		SPCA50X_GLOBAL_MISC0},
+
+    /* 1831 */ {0x5, 0x1, 0x10},
+					/* Maybe power down some stuff */
+    /* 1834 */ {0x5, 0xf, 0x11},
+
+    /* Setup internal CCD  ? */
+    /* 1837 */ {0x6, 0x10, 0x8},
+    /* 1840 */ {0x6, 0x0, 0x9},
+    /* 1843 */ {0x6, 0x0, 0x0a},
+    /* 1846 */ {0x6, 0x0, 0x0b},
+    /* 1849 */ {0x6, 0x10, 0xc},
+    /* 1852 */ {0x6, 0x0, 0xd},
+    /* 1855 */ {0x6, 0x0, 0xe},
+    /* 1858 */ {0x6, 0x0, 0xf},
+    /* 1861 */ {0x6, 0x10, 0x10},
+    /* 1864 */ {0x6, 0x2, 0x11},
+    /* 1867 */ {0x6, 0x0, 0x12},
+    /* 1870 */ {0x6, 0x4, 0x13},
+    /* 1873 */ {0x6, 0x2, 0x14},
+    /* 1876 */ {0x6, 0x8a, 0x51},
+    /* 1879 */ {0x6, 0x40, 0x52},
+    /* 1882 */ {0x6, 0xb6, 0x53},
+    /* 1885 */ {0x6, 0x3d, 0x54},
+    {0, 0, 0}
+};
+
+/*
+ * Data to initialize the camera using the internal CCD
+ */
+static __u16 spca505_open_data_ccd[][3] = {
+    /* line       bmRequest,value,index */
+    /* Internal CCD data set */
+				/* 1891 */ {0x3, 0x4, 0x1},
+				/* This could be a reset */
+    /* 1894 */ {0x3, 0x0, 0x1},
+
+    /* Setup compression and image registers. 0x6 and 0x7 seem to be
+       related to H&V hold, and are resolution mode specific */
+					/* 1897 */ {0x4, 0x10, 0x1},
+					/* DIFF(0x50), was (0x10) */
+    /* 1900 */ {0x4, 0x0, 0x4},
+    /* 1903 */ {0x4, 0x0, 0x5},
+    /* 1906 */ {0x4, 0x20, 0x6},
+    /* 1909 */ {0x4, 0x20, 0x7},
+
+				/* 1912 */ {0x8, 0xa, 0x0},
+				/* DIFF (0x4a), was (0xa) */
+
+    /* 1915 */ {0x5, 0x0, 0x10},
+    /* 1918 */ {0x5, 0x0, 0x11},
+				/* 1921 */ {0x5, 0x0, 0x0},
+				/* DIFF not written */
+				/* 1924 */ {0x5, 0x0, 0x1},
+				/* DIFF not written */
+				/* 1927 */ {0x5, 0x0, 0x2},
+				/* DIFF not written */
+				/* 1930 */ {0x5, 0x0, 0x3},
+				/* DIFF not written */
+				/* 1933 */ {0x5, 0x0, 0x4},
+				/* DIFF not written */
+					/* 1936 */ {0x5, 0x80, 0x5},
+					/* DIFF not written */
+					/* 1939 */ {0x5, 0xe0, 0x6},
+					/* DIFF not written */
+					/* 1942 */ {0x5, 0x20, 0x7},
+					/* DIFF not written */
+					/* 1945 */ {0x5, 0xa0, 0x8},
+					/* DIFF not written */
+					/* 1948 */ {0x5, 0x0, 0x12},
+					/* DIFF not written */
+				/* 1951 */ {0x5, 0x2, 0xf},
+				/* DIFF not written */
+					/* 1954 */ {0x5, 0x10, 0x46},
+					/* DIFF not written */
+					/* 1957 */ {0x5, 0x8, 0x4a},
+					/* DIFF not written */
+
+    /* 1960 */ {0x3, 0x8, 0x3},
+    /* DIFF (0x3,0x28,0x3) */
+    /* 1963 */ {0x3, 0x8, 0x1},
+				/* 1966 */ {0x3, 0xc, 0x3},
+				/* DIFF not written */
+					/* 1969 */ {0x3, 0x21, 0x0},
+					/* DIFF (0x39) */
+
+    /* Extra block copied from init to hopefully ensure CCD is in a sane state */
+    /* 1837 */ {0x6, 0x10, 0x8},
+    /* 1840 */ {0x6, 0x0, 0x9},
+    /* 1843 */ {0x6, 0x0, 0x0a},
+    /* 1846 */ {0x6, 0x0, 0x0b},
+    /* 1849 */ {0x6, 0x10, 0xc},
+    /* 1852 */ {0x6, 0x0, 0xd},
+    /* 1855 */ {0x6, 0x0, 0xe},
+    /* 1858 */ {0x6, 0x0, 0xf},
+    /* 1861 */ {0x6, 0x10, 0x10},
+    /* 1864 */ {0x6, 0x2, 0x11},
+    /* 1867 */ {0x6, 0x0, 0x12},
+    /* 1870 */ {0x6, 0x4, 0x13},
+    /* 1873 */ {0x6, 0x2, 0x14},
+    /* 1876 */ {0x6, 0x8a, 0x51},
+    /* 1879 */ {0x6, 0x40, 0x52},
+    /* 1882 */ {0x6, 0xb6, 0x53},
+    /* 1885 */ {0x6, 0x3d, 0x54},
+    /* End of extra block */
+
+					/* 1972 */ {0x6, 0x3f, 0x1},
+					/* Block skipped */
+    /* 1975 */ {0x6, 0x10, 0x2},
+    /* 1978 */ {0x6, 0x64, 0x7},
+    /* 1981 */ {0x6, 0x10, 0x8},
+    /* 1984 */ {0x6, 0x0, 0x9},
+    /* 1987 */ {0x6, 0x0, 0xa},
+    /* 1990 */ {0x6, 0x0, 0xb},
+    /* 1993 */ {0x6, 0x10, 0xc},
+    /* 1996 */ {0x6, 0x0, 0xd},
+    /* 1999 */ {0x6, 0x0, 0xe},
+    /* 2002 */ {0x6, 0x0, 0xf},
+    /* 2005 */ {0x6, 0x10, 0x10},
+    /* 2008 */ {0x6, 0x2, 0x11},
+    /* 2011 */ {0x6, 0x0, 0x12},
+    /* 2014 */ {0x6, 0x4, 0x13},
+    /* 2017 */ {0x6, 0x2, 0x14},
+    /* 2020 */ {0x6, 0x8a, 0x51},
+    /* 2023 */ {0x6, 0x40, 0x52},
+    /* 2026 */ {0x6, 0xb6, 0x53},
+    /* 2029 */ {0x6, 0x3d, 0x54},
+    /* 2032 */ {0x6, 0x60, 0x57},
+    /* 2035 */ {0x6, 0x20, 0x58},
+    /* 2038 */ {0x6, 0x15, 0x59},
+    /* 2041 */ {0x6, 0x5, 0x5a},
+
+    /* 2044 */ {0x5, 0x1, 0xc0},
+    /* 2047 */ {0x5, 0x10, 0xcb},
+					/* 2050 */ {0x5, 0x80, 0xc1},
+					/* */
+					/* 2053 */ {0x5, 0x0, 0xc2},
+					/* 4 was 0 */
+    /* 2056 */ {0x5, 0x0, 0xca},
+					/* 2059 */ {0x5, 0x80, 0xc1},
+					/*  */
+    /* 2062 */ {0x5, 0x4, 0xc2},
+    /* 2065 */ {0x5, 0x0, 0xca},
+					/* 2068 */ {0x5, 0x0, 0xc1},
+					/*  */
+    /* 2071 */ {0x5, 0x0, 0xc2},
+    /* 2074 */ {0x5, 0x0, 0xca},
+					/* 2077 */ {0x5, 0x40, 0xc1},
+					/* */
+    /* 2080 */ {0x5, 0x17, 0xc2},
+    /* 2083 */ {0x5, 0x0, 0xca},
+					/* 2086 */ {0x5, 0x80, 0xc1},
+					/* */
+    /* 2089 */ {0x5, 0x6, 0xc2},
+    /* 2092 */ {0x5, 0x0, 0xca},
+					/* 2095 */ {0x5, 0x80, 0xc1},
+					/* */
+    /* 2098 */ {0x5, 0x4, 0xc2},
+    /* 2101 */ {0x5, 0x0, 0xca},
+
+    /* 2104 */ {0x3, 0x4c, 0x3},
+    /* 2107 */ {0x3, 0x18, 0x1},
+
+    /* 2110 */ {0x6, 0x70, 0x51},
+    /* 2113 */ {0x6, 0xbe, 0x53},
+    /* 2116 */ {0x6, 0x71, 0x57},
+    /* 2119 */ {0x6, 0x20, 0x58},
+    /* 2122 */ {0x6, 0x5, 0x59},
+    /* 2125 */ {0x6, 0x15, 0x5a},
+
+				/* 2128 */ {0x4, 0x0, 0x8},
+				/* Compress = OFF (0x1 to turn on) */
+    /* 2131 */ {0x4, 0x12, 0x9},
+    /* 2134 */ {0x4, 0x21, 0xa},
+    /* 2137 */ {0x4, 0x10, 0xb},
+    /* 2140 */ {0x4, 0x21, 0xc},
+				/* 2143 */ {0x4, 0x5, 0x0},
+				/* was 5 (Image Type ? ) */
+    /* 2146 */ {0x4, 0x0, 0x1},
+
+    /* 2149 */ {0x6, 0x3f, 0x1},
+
+    /* 2152 */ {0x4, 0x0, 0x4},
+    /* 2155 */ {0x4, 0x0, 0x5},
+    /* 2158 */ {0x4, 0x40, 0x6},
+    /* 2161 */ {0x4, 0x40, 0x7},
+
+    /* 2164 */ {0x6, 0x1c, 0x17},
+    /* 2167 */ {0x6, 0xe2, 0x19},
+    /* 2170 */ {0x6, 0x1c, 0x1b},
+    /* 2173 */ {0x6, 0xe2, 0x1d},
+    /* 2176 */ {0x6, 0xaa, 0x1f},
+    /* 2179 */ {0x6, 0x70, 0x20},
+
+    /* 2182 */ {0x5, 0x1, 0x10},
+    /* 2185 */ {0x5, 0x0, 0x11},
+    /* 2188 */ {0x5, 0x1, 0x0},
+    /* 2191 */ {0x5, 0x5, 0x1},
+					/* 2194 */ {0x5, 0x0, 0xc1},
+					/* */
+    /* 2197 */ {0x5, 0x0, 0xc2},
+    /* 2200 */ {0x5, 0x0, 0xca},
+
+    /* 2203 */ {0x6, 0x70, 0x51},
+    /* 2206 */ {0x6, 0xbe, 0x53},
+    {0, 0, 0}
+};
+
+#if 0
+/*
+ * Data to initialize the camera in external video mode
+ */
+static __u16 spca505_open_data_ext[][3] = {
+    /* line       bmRequest,value,index */
+    /* External video input dataset */
+    /* 0808 */ {0x3, 0x4, 0x1},
+    /* 0809 */ {0x3, 0x0, 0x1},
+
+    /* 0810 */ {0x4, 0x50, 0x1},
+    /* 0811 */ {0x4, 0x0, 0x4},
+    /* 0812 */ {0x4, 0xa, 0x5},
+    /* 0813 */ {0x4, 0x20, 0x6},
+    /* 0814 */ {0x4, 0x20, 0x7},
+
+    /* 0815 */ {0x8, 0x4a, 0x0},
+
+    /* 0816 */ {0x5, 0x0, 0x10},
+    /* 0817 */ {0x5, 0x0, 0x11},
+
+    /* 0818 */ {0x3, 0x8, 0x3},
+    /* 0819 */ {0x3, 0x28, 0x3},
+    /* 0820 */ {0x3, 0x8, 0x1},
+    /* 0821 */ {0x3, 0x39, 0x0},
+
+    /* 0822 */ {0x5, 0x1, 0xc0},
+    /* 0823 */ {0x5, 0x10, 0xcb},
+    /* 0824 */ {0x5, 0x80, 0xc1},
+    /* 0825 */ {0x5, 0x5, 0xc2},
+    /* 0826 */ {0x5, 0x0, 0xca},
+    /* 0827 */ {0x5, 0x0, 0xc1},
+    /* 0828 */ {0x5, 0x1, 0xc2},
+    /* 0829 */ {0x5, 0x0, 0xca},
+    /* 0830 */ {0x5, 0x1, 0x10},
+    /* 0831 */ {0x5, 0xf, 0x11},
+
+    {0, 0, 0}
+
+};
+
+/*
+ * Additional data needed to initialze the camera in external mode
+ */
+static __u16 spca505_open_data2[][3] = {
+    /* line       bmRequest,value,index */
+    /* 1384 */ {0x3, 0x68, 0x3},
+    /* 1385 */ {0x3, 0x10, 0x1},
+    /* 1386 */ {0x8, 0x4a, 0x0},
+				/* 1387 */ {0x4, 0x0, 0x8},
+				/* was 1 COMPRESSION ENABLE ! */
+					/* 1388 */ {0x4, 0x12, 0x9},
+					/* Think these are the compression registers */
+    /* 1389 */ {0x4, 0x21, 0xa},
+    /* 1390 */ {0x4, 0x10, 0xb},
+    /* 1391 */ {0x4, 0x21, 0xc},
+				/* 1392 */ {0x4, 0x5, 0x0},
+				/* This may be the picture type code (5=160x120 as YUV4:2:0) */
+    /* 1393 */ {0x4, 0x0, 0x1},
+    /* 1394 */ {0x6, 0x3f, 0x1},
+    /* 1395 */ {0x4, 0x0, 0x4},
+    /* 1396 */ {0x4, 0xa, 0x5},
+					/* 1397 */ {0x4, 0x40, 0x6},
+					/* was 40 */
+					/* 1398 */ {0x4, 0x40, 0x7},
+					/* was 50 */
+    /* 1399 */ {0x4, 0x2, 0x5},
+    /* 1400 */ {0x4, 0x0, 0x4},
+    {0, 0, 0}
+};
+#endif
+/*
+   Made by Tomasz Zablocki (skalamandra@poczta.onet.pl)
+ * SPCA505b chip based cameras initialization data
+ *
+ */
+#define initial_brightness 0x0	//0x0(white)-0xff(black)
+/*
+ * Data to initialize a SPCA505. Common to the CCD and external modes
+ */
+static __u16 spca505b_init_data[][3] = {
+//start
+
+    {0x02, 0x00, 0x00},		//init 
+    {0x02, 0x00, 0x01},
+    {0x02, 0x00, 0x02},
+    {0x02, 0x00, 0x03},
+    {0x02, 0x00, 0x04},
+    {0x02, 0x00, 0x05},
+    {0x02, 0x00, 0x06},
+    {0x02, 0x00, 0x07},
+    {0x02, 0x00, 0x08},
+    {0x02, 0x00, 0x09},
+    {0x03, 0x00, 0x00},
+    {0x03, 0x00, 0x01},
+    {0x03, 0x00, 0x02},
+    {0x03, 0x00, 0x03},
+    {0x03, 0x00, 0x04},
+    {0x03, 0x00, 0x05},
+    {0x03, 0x00, 0x06},
+    {0x04, 0x00, 0x00},
+    {0x04, 0x00, 0x02},
+    {0x04, 0x00, 0x04},
+    {0x04, 0x00, 0x05},
+    {0x04, 0x00, 0x06},
+    {0x04, 0x00, 0x07},
+    {0x04, 0x00, 0x08},
+    {0x04, 0x00, 0x09},
+    {0x04, 0x00, 0x0a},
+    {0x04, 0x00, 0x0b},
+    {0x04, 0x00, 0x0c},
+    {0x07, 0x00, 0x00},
+    {0x07, 0x00, 0x03},
+    {0x08, 0x00, 0x00},
+    {0x08, 0x00, 0x01},
+    {0x08, 0x00, 0x02},
+    {0x00, 0x01, 0x00},
+    {0x00, 0x01, 0x01},
+    {0x00, 0x01, 0x34},
+    {0x00, 0x01, 0x35},
+    {0x06, 0x18, 0x08},
+    {0x06, 0xfc, 0x09},
+    {0x06, 0xfc, 0x0a},
+    {0x06, 0xfc, 0x0b},
+    {0x06, 0x18, 0x0c},
+    {0x06, 0xfc, 0x0d},
+    {0x06, 0xfc, 0x0e},
+    {0x06, 0xfc, 0x0f},
+    {0x06, 0x18, 0x10},
+    {0x06, 0xfe, 0x12},
+    {0x06, 0x00, 0x11},
+    {0x06, 0x00, 0x14},
+    {0x06, 0x00, 0x13},
+    {0x06, 0x28, 0x51},
+    {0x06, 0xff, 0x53},
+    {0x02, 0x00, 0x08},
+
+    {0x03, 0x00, 0x03},
+    {0x03, 0x10, 0x03},
+
+    {0, 0, 0}
+};
+
+
+/*
+ * Data to initialize the camera using the internal CCD
+ */
+static __u16 spca505b_open_data_ccd[][3] = {
+
+//{0x02,0x00,0x00},
+
+    {0x03, 0x04, 0x01},		//rst
+    {0x03, 0x00, 0x01},
+    {0x03, 0x00, 0x00},
+    {0x03, 0x21, 0x00},
+    {0x03, 0x00, 0x04},
+    {0x03, 0x00, 0x03},
+    {0x03, 0x18, 0x03},
+    {0x03, 0x08, 0x01},
+    {0x03, 0x1c, 0x03},
+    {0x03, 0x5c, 0x03},
+    {0x03, 0x5c, 0x03},
+    {0x03, 0x18, 0x01},
+
+//same as 505
+    {0x04, 0x10, 0x01},
+    {0x04, 0x00, 0x04},
+    {0x04, 0x00, 0x05},
+    {0x04, 0x20, 0x06},
+    {0x04, 0x20, 0x07},
+
+    {0x08, 0x0a, 0x00},
+
+    {0x05, 0x00, 0x10},
+    {0x05, 0x00, 0x11},
+    {0x05, 0x00, 0x12},
+    {0x05, 0x6f, 0x00},
+    {0x05, initial_brightness >> 6, 0x00},
+    {0x05, initial_brightness << 2, 0x01},
+    {0x05, 0x00, 0x02},
+    {0x05, 0x01, 0x03},
+    {0x05, 0x00, 0x04},
+    {0x05, 0x03, 0x05},
+    {0x05, 0xe0, 0x06},
+    {0x05, 0x20, 0x07},
+    {0x05, 0xa0, 0x08},
+    {0x05, 0x00, 0x12},
+    {0x05, 0x02, 0x0f},
+    {0x05, 128, 0x14},		//max exposure off (0=on)     
+    {0x05, 0x01, 0xb0},
+    {0x05, 0x01, 0xbf},
+    {0x03, 0x02, 0x06},
+    {0x05, 0x10, 0x46},
+    {0x05, 0x08, 0x4a},
+
+    {0x06, 0x00, 0x01},
+    {0x06, 0x10, 0x02},
+    {0x06, 0x64, 0x07},
+    {0x06, 0x18, 0x08},
+    {0x06, 0xfc, 0x09},
+    {0x06, 0xfc, 0x0a},
+    {0x06, 0xfc, 0x0b},
+    {0x04, 0x00, 0x01},
+    {0x06, 0x18, 0x0c},
+    {0x06, 0xfc, 0x0d},
+    {0x06, 0xfc, 0x0e},
+    {0x06, 0xfc, 0x0f},
+    {0x06, 0x11, 0x10},		//contrast
+    {0x06, 0x00, 0x11},
+    {0x06, 0xfe, 0x12},
+    {0x06, 0x00, 0x13},
+    {0x06, 0x00, 0x14},
+    {0x06, 0x9d, 0x51},
+    {0x06, 0x40, 0x52},
+    {0x06, 0x7c, 0x53},
+    {0x06, 0x40, 0x54},
+    {0x06, 0x02, 0x57},
+    {0x06, 0x03, 0x58},
+    {0x06, 0x15, 0x59},
+    {0x06, 0x05, 0x5a},
+    {0x06, 0x03, 0x56},
+    {0x06, 0x02, 0x3f},
+    {0x06, 0x00, 0x40},
+    {0x06, 0x39, 0x41},
+    {0x06, 0x69, 0x42},
+    {0x06, 0x87, 0x43},
+    {0x06, 0x9e, 0x44},
+    {0x06, 0xb1, 0x45},
+    {0x06, 0xbf, 0x46},
+    {0x06, 0xcc, 0x47},
+    {0x06, 0xd5, 0x48},
+    {0x06, 0xdd, 0x49},
+    {0x06, 0xe3, 0x4a},
+    {0x06, 0xe8, 0x4b},
+    {0x06, 0xed, 0x4c},
+    {0x06, 0xf2, 0x4d},
+    {0x06, 0xf7, 0x4e},
+    {0x06, 0xfc, 0x4f},
+    {0x06, 0xff, 0x50},
+
+    {0x05, 0x01, 0xc0},
+    {0x05, 0x10, 0xcb},
+    {0x05, 0x40, 0xc1},
+    {0x05, 0x4, 0xc2},
+    {0x05, 0x00, 0xca},
+    {0x05, 0x40, 0xc1},
+    {0x05, 0x09, 0xc2},
+    {0x05, 0x00, 0xca},
+    {0x05, 0xc0, 0xc1},
+    {0x05, 0x09, 0xc2},
+    {0x05, 0x00, 0xca},
+    {0x05, 0x40, 0xc1},
+    {0x05, 0x59, 0xc2},
+    {0x05, 0x00, 0xca},
+    {0x04, 0x00, 0x01},
+    {0x05, 0x80, 0xc1},
+    {0x05, 0xec, 0xc2},
+    {0x05, 0x0, 0xca},
+
+    {0x06, 0x02, 0x57},
+    {0x06, 0x01, 0x58},
+    {0x06, 0x15, 0x59},
+    {0x06, 0x0a, 0x5a},
+    {0x06, 0x01, 0x57},
+    {0x06, 0x8a, 0x03},
+    {0x06, 0x0a, 0x6c},
+    {0x06, 0x30, 0x01},
+    {0x06, 0x20, 0x02},
+    {0x06, 0x00, 0x03},
+
+    {0x05, 0x8c, 0x25},
+
+    {0x06, 0x4d, 0x51},		//maybe saturation (4d)
+    {0x06, 0x84, 0x53},		//making green (84)
+    {0x06, 0x0, 0x57},		//sharpness (1)
+    {0x06, 0x18, 0x08},
+    {0x06, 0xfc, 0x09},
+    {0x06, 0xfc, 0x0a},
+    {0x06, 0xfc, 0x0b},
+    {0x06, 0x18, 0x0c},		//maybe hue (18)
+    {0x06, 0xfc, 0x0d},
+    {0x06, 0xfc, 0x0e},
+    {0x06, 0xfc, 0x0f},
+    {0x06, 0x18, 0x10},		//maybe contrast (18)
+
+    {0x05, 0x01, 0x02},
+
+    {0x04, 0x0, 0x08},		//compression
+    {0x04, 0x12, 0x09},
+    {0x04, 0x21, 0x0a},
+    {0x04, 0x10, 0x0b},
+    {0x04, 0x21, 0x0c},
+    {0x04, 0x1d, 0x00},		//imagetype (1d)
+    {0x04, 0x41, 0x01},		//hardware snapcontrol 
+
+
+    {0x04, 0x00, 0x04},
+    {0x04, 0x00, 0x05},
+    {0x04, 0x10, 0x06},
+    {0x04, 0x10, 0x07},
+    {0x04, 0x40, 0x06},
+    {0x04, 0x40, 0x07},
+    {0x04, 0x00, 0x04},
+    {0x04, 0x00, 0x05},
+
+    {0x06, 0x1c, 0x17},
+    {0x06, 0xe2, 0x19},
+    {0x06, 0x1c, 0x1b},
+    {0x06, 0xe2, 0x1d},
+    {0x06, 0x5f, 0x1f},
+    {0x06, 0x32, 0x20},
+
+    {0x05, initial_brightness >> 6, 0x00},
+    {0x05, initial_brightness << 2, 0x01},
+    {0x05, 0x06, 0xc1},
+    {0x05, 0x58, 0xc2},
+    {0x05, 0x0, 0xca},
+    {0x05, 0x0, 0x11},
+    {0, 0, 0}
+};
+ 
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus/spca505_init.h linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca505_init.h
--- linux-2.6.21/drivers/media/video/gspca/Sunplus/spca505_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca505_init.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,290 @@
+/*
+ * SPCA505 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA505_INIT_H
+#define SPCA505_INIT_H
+
+#define SPCA50X_USB_CTRL 0x0 // spca505
+#define SPCA50X_CUSB_ENABLE 0x1 // spca505
+#define SPCA50X_REG_GLOBAL 0x3 // spca505
+#define SPCA50X_GMISC0_IDSEL 0x1	// Global control device ID select spca505
+#define SPCA50X_GLOBAL_MISC0 0x0	// Global control miscellaneous 0 spca505
+
+#define SPCA50X_GLOBAL_MISC1 0x1 // 505
+#define SPCA50X_GLOBAL_MISC3 0x3 // 505
+#define SPCA50X_GMISC3_SAA7113RST 0x20	/* Not sure about this one spca505 */
+
+#include "spca505.dat"
+static int spca505_init(struct usb_spca50x *spca50x);
+static void spca505_start(struct usb_spca50x *spca50x);
+static void spca505_stopN(struct usb_spca50x *spca50x);
+static void spca505_stop0(struct usb_spca50x *spca50x);
+static __u16 spca505_getbrightness(struct usb_spca50x *spca50x);
+static __u16 spca505_getcontrast(struct usb_spca50x *spca50x);
+static __u16 spca505_getcolors(struct usb_spca50x *spca50x);
+static void spca505_setbrightness(struct usb_spca50x *spca50x);
+static void spca505_setcontrast(struct usb_spca50x *spca50x);
+static void spca505_setcolors(struct usb_spca50x *spca50x);
+static int spca505_config(struct usb_spca50x *spca50x);
+static void spca505_shutdown(struct usb_spca50x *spca50x);
+static void spca505_setAutobright(struct usb_spca50x *spca50x);
+static void spca505_setquality(struct usb_spca50x *spca50x);
+static int spca505_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/***************************************************************/
+static void spca505_stop0(struct usb_spca50x *spca50x){}
+static void spca505_setAutobright(struct usb_spca50x *spca50x){}
+static void spca505_setquality(struct usb_spca50x *spca50x){}
+/**************************************************************/
+static struct cam_operation fspca505 = {
+ 	.initialize = spca505_init,
+	.configure = spca505_config,
+	.start = spca505_start,
+	.stopN = spca505_stopN,
+	.stop0 = spca505_stop0,
+	.get_bright = spca505_getbrightness,
+	.set_bright = spca505_setbrightness,
+	.get_contrast = spca505_getcontrast,
+	.set_contrast = spca505_setcontrast,
+	.get_colors = spca505_getcolors,
+	.set_colors = spca505_setcolors,
+	.set_autobright = spca505_setAutobright,
+	.set_quality = spca505_setquality,
+	.cam_shutdown = spca505_shutdown,
+	.sof_detect = spca505_sofdetect,
+ };
+static int spca505_init(struct usb_spca50x *spca50x)
+{
+int err_code = 0;
+	    PDEBUG(2, "Initializing SPCA505");
+	    if (spca50x->desc == Nxultra) {
+
+		spca50x_write_vector(spca50x, spca505b_open_data_ccd);
+
+	    } else {
+
+		spca50x_write_vector(spca50x, spca505_open_data_ccd);
+
+	    }
+	    err_code = 0;
+	    err_code = spca50x_reg_read(spca50x->dev, 6, (__u16) 0x16, 2);
+
+	    if (err_code < 0) {
+		PDEBUG(1,
+		       "register read failed for after vector read err = %d",
+		       err_code);
+		return -EIO;
+	    } else {
+		PDEBUG(3,
+		       "After vector read returns : 0x%x should be 0x0101",
+		       err_code & 0xFFFF);
+	    }
+
+	    err_code =
+		spca50x_reg_write(spca50x->dev, 6, (__u16) 0x16, (__u16) 0xa);
+	    if (err_code < 0) {
+		PDEBUG(1, "register write failed for (6,0xa,0x16) err=%d",
+		       err_code);
+		return -EIO;
+	    }
+
+	    spca50x_reg_write(spca50x->dev, 5, 0xc2, 18);
+
+return 0;
+}
+static void spca505_start(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    int err_code;
+	    //nessesary because without it we can see stream only once after loading module
+	    //stopping usb registers Tomasz change
+	    spca50x_reg_write(dev, 0x2, 0x0, 0x0);
+switch(spca50x->mode){
+    case 0:
+    spca50x_reg_write(dev, 0x04, 0x0,
+			  0);
+    spca50x_reg_write(dev, 0x04, 0x06,
+			  0x10);
+    spca50x_reg_write(dev, 0x04, 0x07,
+			  0x10);			    
+    break;
+    case 1:
+    spca50x_reg_write(dev, 0x04, 0x0,
+			  1);
+    spca50x_reg_write(dev, 0x04, 0x06,
+			  0x1a);
+    spca50x_reg_write(dev, 0x04, 0x07,
+			  0x1a);	
+    break;
+    case 2:
+    spca50x_reg_write(dev, 0x04, 0x0,
+			  2);
+    spca50x_reg_write(dev, 0x04, 0x06,
+			  0x1c);
+    spca50x_reg_write(dev, 0x04, 0x07,
+			  0x1d);	
+    break;
+    case 4:
+    spca50x_reg_write(dev, 0x04, 0x0,
+			  4);
+    spca50x_reg_write(dev, 0x04, 0x06,
+			  0x34);
+    spca50x_reg_write(dev, 0x04, 0x07,
+			  0x34);	
+    break;
+    case 5:
+    spca50x_reg_write(dev, 0x04, 0x0,
+			  5);
+    spca50x_reg_write(dev, 0x04, 0x06,
+			  0x40);
+    spca50x_reg_write(dev, 0x04, 0x07,
+			  0x40);	
+    break;
+    default:
+     spca50x_reg_write(dev, 0x04, 0x0,
+			  5);
+    spca50x_reg_write(dev, 0x04, 0x06,
+			  0x40);
+    spca50x_reg_write(dev, 0x04, 0x07,
+			  0x40);	
+    break;
+    }
+	    /* Enable ISO packet machine - should we do this here or in ISOC init ? */
+	    err_code = spca50x_reg_write(dev, SPCA50X_REG_USB,
+					 SPCA50X_USB_CTRL,
+					 SPCA50X_CUSB_ENABLE);
+
+//                      spca50x_reg_write(dev, 0x5, 0x0, 0x0);
+//                      spca50x_reg_write(dev, 0x5, 0x0, 0x1);
+//                      spca50x_reg_write(dev, 0x5, 0x11, 0x2);
+}
+static void spca505_stopN(struct usb_spca50x *spca50x)
+{
+	    spca50x_reg_write(spca50x->dev, 0x2, 0x0, 0x0);	//Disable ISO packet machine
+}
+static __u16 spca505_getbrightness(struct usb_spca50x *spca50x)
+{
+        spca50x->brightness =
+	    65535 - ((spca50x_reg_read(spca50x->dev, 5, 0x01, 1) >> 2) +
+		     (spca50x_reg_read(spca50x->dev, 5, 0x0, 1) << 6));
+return spca50x->brightness;
+}
+static __u16 spca505_getcontrast(struct usb_spca50x *spca50x)
+{
+spca50x->contrast = 0;
+return spca50x->contrast;
+}
+static __u16 spca505_getcolors(struct usb_spca50x *spca50x)
+{
+spca50x->colour = 0;
+return spca50x->colour;
+}
+static void spca505_setbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 brightness = spca50x->brightness >> 8;
+	    spca50x_reg_write(spca50x->dev, 5, 0x0,
+			      (255 - brightness) >> 6);
+	    spca50x_reg_write(spca50x->dev, 5, 0x01,
+			      (255 - brightness) << 2);
+
+}
+static void spca505_setcontrast(struct usb_spca50x *spca50x)
+{
+}
+static void spca505_setcolors(struct usb_spca50x *spca50x)
+{
+}
+static int spca505_config(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+  if (spca50x->desc == Nxultra) {  
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1023;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 0;
+    
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1023;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 0;
+    }
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 1;
+    
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 896;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 2;
+    
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 896;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 2;
+    
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 512;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 4;
+    
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 384;
+    spca50x->mode_cam[QCIF].method = 0;
+    spca50x->mode_cam[QCIF].mode = 5;
+    
+    	    if (spca50x->desc == Nxultra) {
+		if (spca50x_write_vector(spca50x, spca505b_init_data))
+		    return -EIO;
+	    } else {
+		if (spca50x_write_vector(spca50x, spca505_init_data))
+		    return -EIO;
+	    }
+    return 0;
+}
+static void spca505_shutdown(struct usb_spca50x *spca50x)
+{
+	    spca50x_reg_write(spca50x->dev, 0x3, 0x3, 0x20);	// This maybe reset or power control
+	    spca50x_reg_write(spca50x->dev, 0x3, 0x1, 0x0);
+	    spca50x_reg_write(spca50x->dev, 0x3, 0x0, 0x1);
+	    spca50x_reg_write(spca50x->dev, 0x5, 0x10, 0x1);
+	    spca50x_reg_write(spca50x->dev, 0x5, 0x11, 0xF);
+}
+static int spca505_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+	switch (cdata[0]){
+	   case 0:
+	   	*iPix = SPCA50X_OFFSET_DATA;
+		*datalength -= *iPix;
+	   	return 0;
+	   case SPCA50X_SEQUENCE_DROP:
+	   	return -1;
+	   default:
+	        *iPix = 1;
+	        *datalength -= *iPix;
+	   	return seqnum+1 ;
+	   }
+}
+#endif				/* SPCA505_INIT_H */
+//eof
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus/spca506.h linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca506.h
--- linux-2.6.21/drivers/media/video/gspca/Sunplus/spca506.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca506.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,534 @@
+/*
+ * SPCA506 chip based cameras function
+ * M Xhaard 15/04/2004 based on different work Mark Taylor and others
+ * and my own snoopy file on a pv-321c donate by a german compagny
+ *                "Firma Frank Gmbh" from  Saarbruecken
+ */
+#ifndef SPCA506_INIT_H
+#define SPCA506_INIT_H
+
+#define SAA7113_bright 0x0A	// defaults 0x80
+#define SAA7113_contrast 0x0B	// defaults 0x47
+#define SAA7113_saturation 0x0C	//defaults 0x40
+#define SAA7113_hue 0x0D	//defaults 0x00
+#define SAA7113_I2C_BASE_WRITE 0x4A
+
+/* define from v4l */
+//#define VIDEO_MODE_PAL                0
+//#define VIDEO_MODE_NTSC               1
+//#define VIDEO_MODE_SECAM              2
+//#define VIDEO_MODE_AUTO               3
+/**************************     Camera interface    ************************/
+static int spca506_init(struct usb_spca50x *spca50x);
+static void spca506_start(struct usb_spca50x *spca50x);
+static void spca506_stopN(struct usb_spca50x *spca50x);
+static void spca506_stop0(struct usb_spca50x *spca50x);
+static __u16 spca506_getbrightness(struct usb_spca50x *spca50x);
+static __u16 spca506_getcontrast(struct usb_spca50x *spca50x);
+static __u16 spca506_getcolors(struct usb_spca50x *spca50x);
+static void spca506_setbrightness(struct usb_spca50x *spca50x);
+static void spca506_setcontrast(struct usb_spca50x *spca50x);
+static void spca506_setcolors(struct usb_spca50x *spca50x);
+static int spca506_config(struct usb_spca50x *spca50x);
+static void spca506_shutdown(struct usb_spca50x *spca50x);
+static void spca506_setAutobright(struct usb_spca50x *spca50x);
+static void spca506_setquality(struct usb_spca50x *spca50x);
+static int spca506_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum,int *datalength);
+/****************************************************************************/
+static void spca506_stop0(struct usb_spca50x *spca50x){}
+static void spca506_shutdown(struct usb_spca50x *spca50x){}
+static void spca506_setAutobright(struct usb_spca50x *spca50x){}
+static void spca506_setquality(struct usb_spca50x *spca50x){}
+/*********************** Specific spca506 Usbgrabber ************************/
+static void spca506_SetNormeInput(struct usb_spca50x *spca50x, __u16 norme,
+				  __u16 channel);
+static void spca506_GetNormeInput(struct usb_spca50x *spca50x,
+				  __u16 * norme, __u16 * channel);
+/****************************   Private     *********************************/
+static void spca506_Setsize(struct usb_spca50x *spca50x, __u16 code,
+			    __u16 xmult, __u16 ymult);
+
+/****************************************************************************/
+static struct cam_operation fspca506 = {
+ 	.initialize = spca506_init,
+	.configure = spca506_config,
+	.start = spca506_start,
+	.stopN = spca506_stopN,
+	.stop0 = spca506_stop0,
+	.get_bright = spca506_getbrightness,
+	.set_bright = spca506_setbrightness,
+	.get_contrast = spca506_getcontrast,
+	.set_contrast = spca506_setcontrast,
+	.get_colors = spca506_getcolors,
+	.set_colors = spca506_setcolors,
+	.set_autobright = spca506_setAutobright,
+	.set_quality = spca506_setquality,
+	.cam_shutdown = spca506_shutdown,
+	.sof_detect = spca506_sofdetect,
+ };
+static void spca506_Initi2c(struct usb_spca50x *spca50x)
+{
+    spca5xxRegWrite(spca50x->dev, 0x07, SAA7113_I2C_BASE_WRITE, 0x0004,
+		    NULL, 0);
+}
+
+static void spca506_WriteI2c(struct usb_spca50x *spca50x, __u16 valeur,
+			     __u16 registre)
+{
+    int retry = 60;
+    unsigned char Data[2];
+    spca5xxRegWrite(spca50x->dev, 0x07, registre, 0x0001, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x07, valeur, 0x0000, NULL, 0);
+    while (retry--) {
+	spca5xxRegRead(spca50x->dev, 0x07, 0, 0x0003, Data, 2);
+	if ((Data[0] | Data[1]) == 0x00)
+	    break;
+    }
+}
+
+static int spca506_ReadI2c(struct usb_spca50x *spca50x, __u16 registre)
+{
+    int retry = 60;
+    unsigned char Data[2];
+    unsigned char value = 0;
+    spca5xxRegWrite(spca50x->dev, 0x07, SAA7113_I2C_BASE_WRITE, 0x0004,
+		    NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x07, registre, 0x0001, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x07, 0x01, 0x0002, NULL, 0);
+    while (retry--) {
+	spca5xxRegRead(spca50x->dev, 0x07, 0, 0x0003, Data, 2);
+	if ((Data[0] | Data[1]) == 0x00)
+	    break;
+    }
+    if (retry == 0)
+	return -1;
+    spca5xxRegRead(spca50x->dev, 0x07, 0, 0x0000, &value, 1);
+    return (int) value;
+}
+
+static void spca506_SetNormeInput(struct usb_spca50x *spca50x, __u16 norme,
+				  __u16 channel)
+{
+    __u8 setbit0 = 0x00;
+    __u8 setbit1 = 0x00;
+    __u8 videomask = 0x00;
+    PDEBUG(3, "************ Open Set Norme  **************");
+    spca506_Initi2c(spca50x);
+    /* NTSC bit0 -> 1(525 l) PAL SECAM bit0 -> 0 (625 l) */
+    /* Composite channel bit1 -> 1 S-video bit 1 -> 0 */
+    /* and exclude SAA7113 reserved channel set default 0 otherwise */
+    if (norme == VIDEO_MODE_NTSC)
+	setbit0 = 0x01;
+    if ((channel == 4) || (channel == 5) || (channel > 9))
+	channel = 0;
+    if (channel < 4)
+	setbit1 = 0x02;
+    videomask = (0x48 | setbit0 | setbit1);
+    spca5xxRegWrite(spca50x->dev, 0x08, videomask, 0x0000, NULL, 0);
+    spca506_WriteI2c(spca50x, (0xc0 | (channel & 0x0F)), 0x02);
+
+    switch (norme) {
+    case VIDEO_MODE_PAL:
+	spca506_WriteI2c(spca50x, 0x03, 0x0e);	//Chrominance Control PAL BGHIV
+	break;
+    case VIDEO_MODE_NTSC:
+	spca506_WriteI2c(spca50x, 0x33, 0x0e);	//Chrominance Control NTSC N
+	break;
+    case VIDEO_MODE_SECAM:
+	spca506_WriteI2c(spca50x, 0x53, 0x0e);	//Chrominance Control SECAM
+	break;
+    default:
+	spca506_WriteI2c(spca50x, 0x03, 0x0e);	//Chrominance Control PAL BGHIV
+	break;
+    }
+    spca50x->norme = norme;
+    spca50x->channel = channel;
+    PDEBUG(3, "Set Video Byte to 0x%2X ", videomask);
+    PDEBUG(3, "Set Norme : %d Channel %d ", norme, channel);
+    PDEBUG(3, "************ Close SetNorme  **************");
+
+
+}
+
+static void spca506_GetNormeInput(struct usb_spca50x *spca50x,
+				  __u16 * norme, __u16 * channel)
+{
+
+    PDEBUG(3, "************ Open Get Norme  **************");
+    /* Read the register is not so good value change so
+       we use your own copy in spca50x struct          */
+    *norme = spca50x->norme;
+    *channel = spca50x->channel;
+    PDEBUG(3, "Get Norme  : %d Channel %d ", *norme, *channel);
+    PDEBUG(3, "************ Close Get Norme  **************");
+}
+
+static int spca506_init(struct usb_spca50x *spca50x)
+{
+    PDEBUG(3, "************ Open Init spca506  **************");
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0004, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0xFF, 0x0003, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0000, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x1c, 0x0001, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x18, 0x0001, NULL, 0);
+    /* Init on PAL and composite input0 */
+    spca506_SetNormeInput(spca50x, 0, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x1c, 1, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x18, 0x0001, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x05, 0x00, 0x0000, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x05, 0xef, 0x0001, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x05, 0x00, 0x00c1, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x05, 0x00, 0x00c2, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0x18, 0x0002, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0xf5, 0x0011, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0x02, 0x0012, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0xfb, 0x0013, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0x00, 0x0014, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0xa4, 0x0051, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0x40, 0x0052, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0x71, 0x0053, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x06, 0x40, 0x0054, NULL, 0);
+	/***********************************************************/
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0004, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0003, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0004, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0xFF, 0x0003, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x02, 0x00, 0x0000, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x60, 0x0000, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x18, 0x0001, NULL, 0);
+    /* for a better reading mx :)      */
+    /*spca506_WriteI2c(value,register) */
+    spca506_Initi2c(spca50x);
+    spca506_WriteI2c(spca50x, 0x08, 0x01);
+    spca506_WriteI2c(spca50x, 0xc0, 0x02);	// input composite video
+    spca506_WriteI2c(spca50x, 0x33, 0x03);
+    spca506_WriteI2c(spca50x, 0x00, 0x04);
+    spca506_WriteI2c(spca50x, 0x00, 0x05);
+    spca506_WriteI2c(spca50x, 0x0d, 0x06);
+    spca506_WriteI2c(spca50x, 0xf0, 0x07);
+    spca506_WriteI2c(spca50x, 0x98, 0x08);
+    spca506_WriteI2c(spca50x, 0x03, 0x09);
+    spca506_WriteI2c(spca50x, 0x80, 0x0a);
+    spca506_WriteI2c(spca50x, 0x47, 0x0b);
+    spca506_WriteI2c(spca50x, 0x48, 0x0c);
+    spca506_WriteI2c(spca50x, 0x00, 0x0d);
+    spca506_WriteI2c(spca50x, 0x03, 0x0e);	// Chroma Pal adjust
+    spca506_WriteI2c(spca50x, 0x2a, 0x0f);
+    spca506_WriteI2c(spca50x, 0x00, 0x10);
+    spca506_WriteI2c(spca50x, 0x0c, 0x11);
+    spca506_WriteI2c(spca50x, 0xb8, 0x12);
+    spca506_WriteI2c(spca50x, 0x01, 0x13);
+    spca506_WriteI2c(spca50x, 0x00, 0x14);
+    spca506_WriteI2c(spca50x, 0x00, 0x15);
+    spca506_WriteI2c(spca50x, 0x00, 0x16);
+    spca506_WriteI2c(spca50x, 0x00, 0x17);
+    spca506_WriteI2c(spca50x, 0x00, 0x18);
+    spca506_WriteI2c(spca50x, 0x00, 0x19);
+    spca506_WriteI2c(spca50x, 0x00, 0x1a);
+    spca506_WriteI2c(spca50x, 0x00, 0x1b);
+    spca506_WriteI2c(spca50x, 0x00, 0x1c);
+    spca506_WriteI2c(spca50x, 0x00, 0x1d);
+    spca506_WriteI2c(spca50x, 0x00, 0x1e);
+    spca506_WriteI2c(spca50x, 0xa1, 0x1f);
+    spca506_WriteI2c(spca50x, 0x02, 0x40);
+    spca506_WriteI2c(spca50x, 0xff, 0x41);
+    spca506_WriteI2c(spca50x, 0xff, 0x42);
+    spca506_WriteI2c(spca50x, 0xff, 0x43);
+    spca506_WriteI2c(spca50x, 0xff, 0x44);
+    spca506_WriteI2c(spca50x, 0xff, 0x45);
+    spca506_WriteI2c(spca50x, 0xff, 0x46);
+    spca506_WriteI2c(spca50x, 0xff, 0x47);
+    spca506_WriteI2c(spca50x, 0xff, 0x48);
+    spca506_WriteI2c(spca50x, 0xff, 0x49);
+    spca506_WriteI2c(spca50x, 0xff, 0x4a);
+    spca506_WriteI2c(spca50x, 0xff, 0x4b);
+    spca506_WriteI2c(spca50x, 0xff, 0x4c);
+    spca506_WriteI2c(spca50x, 0xff, 0x4d);
+    spca506_WriteI2c(spca50x, 0xff, 0x4e);
+    spca506_WriteI2c(spca50x, 0xff, 0x4f);
+    spca506_WriteI2c(spca50x, 0xff, 0x50);
+    spca506_WriteI2c(spca50x, 0xff, 0x51);
+    spca506_WriteI2c(spca50x, 0xff, 0x52);
+    spca506_WriteI2c(spca50x, 0xff, 0x53);
+    spca506_WriteI2c(spca50x, 0xff, 0x54);
+    spca506_WriteI2c(spca50x, 0xff, 0x55);
+    spca506_WriteI2c(spca50x, 0xff, 0x56);
+    spca506_WriteI2c(spca50x, 0xff, 0x57);
+    spca506_WriteI2c(spca50x, 0x00, 0x58);
+    spca506_WriteI2c(spca50x, 0x54, 0x59);
+    spca506_WriteI2c(spca50x, 0x07, 0x5a);
+    spca506_WriteI2c(spca50x, 0x83, 0x5b);
+    spca506_WriteI2c(spca50x, 0x00, 0x5c);
+    spca506_WriteI2c(spca50x, 0x00, 0x5d);
+    spca506_WriteI2c(spca50x, 0x00, 0x5e);
+    spca506_WriteI2c(spca50x, 0x00, 0x5f);
+    spca506_WriteI2c(spca50x, 0x00, 0x60);
+    spca506_WriteI2c(spca50x, 0x05, 0x61);
+    spca506_WriteI2c(spca50x, 0x9f, 0x62);
+    PDEBUG(3, "************ Close Init spca506  **************");
+    return 0;
+}
+static void spca506_start(struct usb_spca50x *spca50x)
+{
+    __u16 norme = 0;
+    __u16 channel = 0;
+    unsigned char Data[2];
+    PDEBUG(3, "************ Open Start spca506  **************");
+	/***********************************************************/
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0004, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0003, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0004, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0xFF, 0x0003, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x02, 0x00, 0x0000, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x60, 0x0000, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x18, 0x0001, NULL, 0);
+
+    /*spca506_WriteI2c(value,register) */
+    spca506_Initi2c(spca50x);
+    spca506_WriteI2c(spca50x, 0x08, 0x01);	//Increment Delay
+    //spca506_WriteI2c(spca50x,0xc0,0x02);//Analog Input Control 1
+    spca506_WriteI2c(spca50x, 0x33, 0x03);	//Analog Input Control 2
+    spca506_WriteI2c(spca50x, 0x00, 0x04);	//Analog Input Control 3
+    spca506_WriteI2c(spca50x, 0x00, 0x05);	//Analog Input Control 4
+    spca506_WriteI2c(spca50x, 0x0d, 0x06);	//Horizontal Sync Start 0xe9-0x0d
+    spca506_WriteI2c(spca50x, 0xf0, 0x07);	//Horizontal Sync Stop  0x0d-0xf0
+
+    spca506_WriteI2c(spca50x, 0x98, 0x08);	//Sync Control
+    /*                      Defaults value                       */
+    spca506_WriteI2c(spca50x, 0x03, 0x09);	//Luminance Control
+    spca506_WriteI2c(spca50x, 0x80, 0x0a);	//Luminance Brightness
+    spca506_WriteI2c(spca50x, 0x47, 0x0b);	//Luminance Contrast
+    spca506_WriteI2c(spca50x, 0x48, 0x0c);	//Chrominance Saturation
+    spca506_WriteI2c(spca50x, 0x00, 0x0d);	//Chrominance Hue Control
+    spca506_WriteI2c(spca50x, 0x2a, 0x0f);	//Chrominance Gain Control
+	/*************************************************************/
+    spca506_WriteI2c(spca50x, 0x00, 0x10);	//Format/Delay Control
+    spca506_WriteI2c(spca50x, 0x0c, 0x11);	//Output Control 1
+    spca506_WriteI2c(spca50x, 0xb8, 0x12);	//Output Control 2
+    spca506_WriteI2c(spca50x, 0x01, 0x13);	//Output Control 3
+    spca506_WriteI2c(spca50x, 0x00, 0x14);	//reserved
+    spca506_WriteI2c(spca50x, 0x00, 0x15);	//VGATE START
+    spca506_WriteI2c(spca50x, 0x00, 0x16);	//VGATE STOP
+    spca506_WriteI2c(spca50x, 0x00, 0x17);	//VGATE Control (MSB)
+    spca506_WriteI2c(spca50x, 0x00, 0x18);
+    spca506_WriteI2c(spca50x, 0x00, 0x19);
+    spca506_WriteI2c(spca50x, 0x00, 0x1a);
+    spca506_WriteI2c(spca50x, 0x00, 0x1b);
+    spca506_WriteI2c(spca50x, 0x00, 0x1c);
+    spca506_WriteI2c(spca50x, 0x00, 0x1d);
+    spca506_WriteI2c(spca50x, 0x00, 0x1e);
+    spca506_WriteI2c(spca50x, 0xa1, 0x1f);
+    spca506_WriteI2c(spca50x, 0x02, 0x40);
+    spca506_WriteI2c(spca50x, 0xff, 0x41);
+    spca506_WriteI2c(spca50x, 0xff, 0x42);
+    spca506_WriteI2c(spca50x, 0xff, 0x43);
+    spca506_WriteI2c(spca50x, 0xff, 0x44);
+    spca506_WriteI2c(spca50x, 0xff, 0x45);
+    spca506_WriteI2c(spca50x, 0xff, 0x46);
+    spca506_WriteI2c(spca50x, 0xff, 0x47);
+    spca506_WriteI2c(spca50x, 0xff, 0x48);
+    spca506_WriteI2c(spca50x, 0xff, 0x49);
+    spca506_WriteI2c(spca50x, 0xff, 0x4a);
+    spca506_WriteI2c(spca50x, 0xff, 0x4b);
+    spca506_WriteI2c(spca50x, 0xff, 0x4c);
+    spca506_WriteI2c(spca50x, 0xff, 0x4d);
+    spca506_WriteI2c(spca50x, 0xff, 0x4e);
+    spca506_WriteI2c(spca50x, 0xff, 0x4f);
+    spca506_WriteI2c(spca50x, 0xff, 0x50);
+    spca506_WriteI2c(spca50x, 0xff, 0x51);
+    spca506_WriteI2c(spca50x, 0xff, 0x52);
+    spca506_WriteI2c(spca50x, 0xff, 0x53);
+    spca506_WriteI2c(spca50x, 0xff, 0x54);
+    spca506_WriteI2c(spca50x, 0xff, 0x55);
+    spca506_WriteI2c(spca50x, 0xff, 0x56);
+    spca506_WriteI2c(spca50x, 0xff, 0x57);
+    spca506_WriteI2c(spca50x, 0x00, 0x58);
+    spca506_WriteI2c(spca50x, 0x54, 0x59);
+    spca506_WriteI2c(spca50x, 0x07, 0x5a);
+    spca506_WriteI2c(spca50x, 0x83, 0x5b);
+    spca506_WriteI2c(spca50x, 0x00, 0x5c);
+    spca506_WriteI2c(spca50x, 0x00, 0x5d);
+    spca506_WriteI2c(spca50x, 0x00, 0x5e);
+    spca506_WriteI2c(spca50x, 0x00, 0x5f);
+    spca506_WriteI2c(spca50x, 0x00, 0x60);
+    spca506_WriteI2c(spca50x, 0x05, 0x61);
+    spca506_WriteI2c(spca50x, 0x9f, 0x62);
+	/***********************************************************/
+    spca5xxRegWrite(spca50x->dev, 0x05, 0x00, 0x0003, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x05, 0x00, 0x0004, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x10, 0x0001, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x78, 0x0000, NULL, 0);
+    switch(spca50x->mode){
+    case 0:
+    spca506_Setsize(spca50x, 0,
+			    0x10, 0x10);
+    break;
+    case 1:
+    spca506_Setsize(spca50x, 1,
+			    0x1a, 0x1a);
+    break;
+    case 2:
+    spca506_Setsize(spca50x, 2,
+			    0x1c, 0x1c);
+    break;
+    case 4:
+    spca506_Setsize(spca50x, 4,
+			    0x34, 0x34);
+    break;
+    case 5:
+    spca506_Setsize(spca50x, 5,
+			    0x40, 0x40);
+    break;
+    default:
+    spca506_Setsize(spca50x, 5,
+			    0x40, 0x40);
+    break;
+    }
+    /* compress setting and size */
+    /* set i2c luma */
+    spca5xxRegWrite(spca50x->dev, 0x02, 0x01, 0x0000, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x12, 0x0001, NULL, 0);
+    spca5xxRegRead(spca50x->dev, 0x04, 0, 0x0001, Data, 2);
+    PDEBUG(3, "************ Close Start spca506  **************");
+    spca506_GetNormeInput(spca50x, &norme, &channel);
+    spca506_SetNormeInput(spca50x, norme, channel);
+}
+static void spca506_stopN(struct usb_spca50x *spca50x)
+{
+    spca5xxRegWrite(spca50x->dev, 0x02, 0x00, 0x0000, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0004, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x03, 0x00, 0x0003, NULL, 0);
+}
+static void spca506_Setsize(struct usb_spca50x *spca50x, __u16 code,
+			    __u16 xmult, __u16 ymult)
+{
+    PDEBUG(3, "************ Open SetSize spca506  **************");
+    spca5xxRegWrite(spca50x->dev, 0x04, (0x18 | (code & 0x07)), 0x0000,
+		    NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x41, 0x0001, NULL, 0);	// Soft snap 0x40 Hard 0x41
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x00, 0x0002, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x00, 0x0003, NULL, 0);	//reserved
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x00, 0x0004, NULL, 0);	//reserved
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x01, 0x0005, NULL, 0);	//reserved
+    spca5xxRegWrite(spca50x->dev, 0x04, xmult, 0x0006, NULL, 0);	//reserced
+    spca5xxRegWrite(spca50x->dev, 0x04, ymult, 0x0007, NULL, 0);	//reserved
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x00, 0x0008, NULL, 0);	// compression 1
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x00, 0x0009, NULL, 0);	//T=64 -> 2
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x21, 0x000a, NULL, 0);	//threshold2D
+    spca5xxRegWrite(spca50x->dev, 0x04, 0x00, 0x000b, NULL, 0);	//quantization
+    PDEBUG(3, "************ Close SetSize spca506  **************");
+}
+
+static __u16 spca506_getbrightness(struct usb_spca50x *spca50x)
+{
+spca50x->brightness = (spca506_ReadI2c(spca50x, SAA7113_bright)) << 8;
+return spca50x->brightness;
+}
+static __u16 spca506_getcontrast(struct usb_spca50x *spca50x)
+{
+spca50x->contrast = (spca506_ReadI2c(spca50x, SAA7113_contrast)) << 8;
+return spca50x->contrast;
+}
+static __u16 spca506_getcolors(struct usb_spca50x *spca50x)
+{
+spca50x->hue = (spca506_ReadI2c(spca50x, SAA7113_hue)) << 8;
+spca50x->colour = (spca506_ReadI2c(spca50x, SAA7113_saturation)) << 8;
+return spca50x->colour;
+}
+static void spca506_setbrightness(struct usb_spca50x *spca50x)
+{
+    spca506_Initi2c(spca50x);
+    spca506_WriteI2c(spca50x, ((spca50x->brightness >> 8) & 0xFF), SAA7113_bright);
+    spca506_WriteI2c(spca50x, 0x01, 0x09);
+}
+static void spca506_setcontrast(struct usb_spca50x *spca50x)
+{
+ spca506_Initi2c(spca50x);
+ spca506_WriteI2c(spca50x, ((spca50x->contrast >> 8) & 0xFF), SAA7113_contrast);
+ spca506_WriteI2c(spca50x, 0x01, 0x09);
+}
+static void spca506_setcolors(struct usb_spca50x *spca50x)
+{
+    spca506_Initi2c(spca50x);
+    spca506_WriteI2c(spca50x, ((spca50x->hue >> 8) & 0xFF), SAA7113_hue);
+    spca506_WriteI2c(spca50x, ((spca50x->colour >> 8) & 0xFF), SAA7113_saturation);
+    spca506_WriteI2c(spca50x, 0x01, 0x09);
+}
+static int spca506_config(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1023;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 0;
+    
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1023;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 0;
+    
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 1;
+    
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 896;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 2;
+    
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 896;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 2;
+    
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 512;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 4;
+    
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 384;
+    spca50x->mode_cam[QCIF].method = 0;
+    spca50x->mode_cam[QCIF].mode = 5;
+    return 0;
+}
+static int spca506_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum,int *datalength)
+{
+           switch (cdata[0]){
+	   case 0:
+	   	*iPix = SPCA50X_OFFSET_DATA;
+		*datalength -= *iPix;
+	   	return 0;
+	   case SPCA50X_SEQUENCE_DROP:
+	   	return -1;
+	   default:
+	        *iPix = 1;
+	        *datalength -= *iPix;
+	   	return seqnum+1 ;
+	   }
+}
+
+#endif				/* SPCA506_INIT_H */
+//eof
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus/spca508.dat linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca508.dat
--- linux-2.6.21/drivers/media/video/gspca/Sunplus/spca508.dat	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca508.dat	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,1515 @@
+/*
+   Initialization data: this is the first set-up data written to the
+   device (before the open data).
+ */
+static __u16 spca508_init_data[][3] =
+#define IGN(x)			/* nothing */
+{
+    /*  line   URB    req,  value, index */
+    /*    22     1 *//* READ { 0, 0x0 IGN(URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:), 0x00   } ->
+       0000: 12 01 10 01 00 00 00 08 33 07 10 01 00 00 01 02
+       0010: 00 01  */
+    /*    44     2 *//* READ { 0, 0x0 IGN(URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:), 0x00   } ->
+       0000: 09 02 89 00 01 01 00 80 32 09 04 00 00 01 ff 00
+       0010: 00 00 07 05 81 01 00 00 01 09 04 00 01 01 ff 00
+       0020: 00 00 07 05 81 01 80 00 01 09 04 00 02 01 ff 00
+       0030: 00 00 07 05 81 01 80 01 01 09 04 00 03 01 ff 00  */
+    /*    68     3 *//* READ { 0, 0x0 IGN(URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:), 0x00   } ->
+       0000: 09 02 89 00 01 01 00 80 32 09 04 00 00 01 ff 00
+       0010: 00 00 07 05 81 01 00 00 01 09 04 00 01 01 ff 00
+       0020: 00 00 07 05 81 01 80 00 01 09 04 00 02 01 ff 00
+       0030: 00 00 07 05 81 01 80 01 01 09 04 00 03 01 ff 00
+       0040: 00 00 07 05 81 01 00 02 01 09 04 00 04 01 ff 00
+       0050: 00 00 07 05 81 01 80 02 01 09 04 00 05 01 ff 00
+       0060: 00 00 07 05 81 01 00 03 01 09 04 00 06 01 ff 00
+       0070: 00 00 07 05 81 01 80 03 01 09 04 00 07 01 ff 00
+       0080: 00 00 07 05 81 01 ff 03 01  */
+    /*   104     4 *//* UNKNOWN DIRECTION (URB_FUNCTION_SELECT_CONFIGURATION:) */
+						/* 44274  1804 */ {0, 0x0000, 0x870b},
+						// 
+
+
+
+						/* 44299  1805 */ {0, 0x0020, 0x8112},
+						// Video drop enable, ISO streaming disable
+						/* 44324  1806 */ {0, 0x0003, 0x8111},
+						// Reset compression & memory
+						/* 44349  1807 */ {0, 0x0000, 0x8110},
+						// Disable all outputs
+    /* 44372  1808 *//* READ { 0, 0x0000, 0x8114 } ->
+       0000: 00  */
+						/* 44398  1809 */ {0, 0x0000, 0x8114},
+						// SW GPIO data
+						/* 44423  1810 */ {0, 0x0008, 0x8110},
+						// Enable charge pump output
+						/* 44527  1811 */ {0, 0x0002, 0x8116},
+						// 200 kHz pump clock
+    /* 44555  1812 *//* UNKNOWN DIRECTION (URB_FUNCTION_SELECT_INTERFACE:) */
+						/* 44590  1813 */ {0, 0x0003, 0x8111},
+						// Reset compression & memory
+						/* 44615  1814 */ {0, 0x0000, 0x8111},
+						// Normal mode (not reset)
+						/* 44640  1815 */ {0, 0x0098, 0x8110},
+						// Enable charge pump output, sync.serial,external 2x clock
+						/* 44665  1816 */ {0, 0x000d, 0x8114},
+						// SW GPIO data
+						/* 44690  1817 */ {0, 0x0002, 0x8116},
+						// 200 kHz pump clock
+						/* 44715  1818 */ {0, 0x0020, 0x8112},
+						// Video drop enable, ISO streaming disable
+
+
+    // ---------------------------------------
+						/* 44740  1819 */ {0, 0x000f, 0x8402},
+						// memory bank
+						/* 44765  1820 */ {0, 0x0000, 0x8403},
+						// ... address
+
+
+    // ---------------------------------------
+    // 0x88__ is Synchronous Serial Interface.
+    // TBD: This table could be expressed more compactly
+    // using spca508_write_i2c_vector().
+    // TBD: Should see if the values in spca50x_i2c_data
+    // would work with the VQ110 instead of the values
+    // below.
+
+						/* 44790  1821 */ {0, 0x00c0, 0x8804},
+						// SSI slave addr
+						/* 44815  1822 */ {0, 0x0008, 0x8802},
+						// 375 Khz SSI clock
+    /* 44838  1823 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 44862  1824 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+						/* 44888  1825 */ {0, 0x0008, 0x8802},
+						// 375 Khz SSI clock
+						/* 44913  1826 */ {0, 0x0012, 0x8801},
+						// SSI reg addr
+						/* 44938  1827 */ {0, 0x0080, 0x8800},
+						// SSI data to write
+    /* 44961  1828 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 44985  1829 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45009  1830 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+						/* 45035  1831 */ {0, 0x0008, 0x8802},
+						// 375 Khz SSI clock
+						/* 45060  1832 */ {0, 0x0012, 0x8801},
+						// SSI reg addr
+						/* 45085  1833 */ {0, 0x0000, 0x8800},
+						// SSI data to write
+    /* 45108  1834 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45132  1835 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45156  1836 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+						/* 45182  1837 */ {0, 0x0008, 0x8802},
+						// 375 Khz SSI clock
+						/* 45207  1838 */ {0, 0x0011, 0x8801},
+						// SSI reg addr
+						/* 45232  1839 */ {0, 0x0040, 0x8800},
+						// SSI data to write
+    /* 45255  1840 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45279  1841 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45303  1842 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 45329  1843 */ {0, 0x0008, 0x8802},
+    /* 45354  1844 */ {0, 0x0013, 0x8801},
+    /* 45379  1845 */ {0, 0x0000, 0x8800},
+    /* 45402  1846 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45426  1847 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45450  1848 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 45476  1849 */ {0, 0x0008, 0x8802},
+    /* 45501  1850 */ {0, 0x0014, 0x8801},
+    /* 45526  1851 */ {0, 0x0000, 0x8800},
+    /* 45549  1852 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45573  1853 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45597  1854 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 45623  1855 */ {0, 0x0008, 0x8802},
+    /* 45648  1856 */ {0, 0x0015, 0x8801},
+    /* 45673  1857 */ {0, 0x0001, 0x8800},
+    /* 45696  1858 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45720  1859 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45744  1860 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 45770  1861 */ {0, 0x0008, 0x8802},
+    /* 45795  1862 */ {0, 0x0016, 0x8801},
+    /* 45820  1863 */ {0, 0x0003, 0x8800},
+    /* 45843  1864 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45867  1865 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 45891  1866 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 45917  1867 */ {0, 0x0008, 0x8802},
+    /* 45942  1868 */ {0, 0x0017, 0x8801},
+    /* 45967  1869 */ {0, 0x0036, 0x8800},
+    /* 45990  1870 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46014  1871 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46038  1872 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 46064  1873 */ {0, 0x0008, 0x8802},
+    /* 46089  1874 */ {0, 0x0018, 0x8801},
+    /* 46114  1875 */ {0, 0x00ec, 0x8800},
+    /* 46137  1876 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46161  1877 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46185  1878 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 46211  1879 */ {0, 0x0008, 0x8802},
+    /* 46236  1880 */ {0, 0x001a, 0x8801},
+    /* 46261  1881 */ {0, 0x0094, 0x8800},
+    /* 46284  1882 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46308  1883 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46332  1884 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 46358  1885 */ {0, 0x0008, 0x8802},
+    /* 46383  1886 */ {0, 0x001b, 0x8801},
+    /* 46408  1887 */ {0, 0x0000, 0x8800},
+    /* 46431  1888 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46455  1889 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46479  1890 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 46505  1891 */ {0, 0x0008, 0x8802},
+    /* 46530  1892 */ {0, 0x0027, 0x8801},
+    /* 46555  1893 */ {0, 0x00a2, 0x8800},
+    /* 46578  1894 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46602  1895 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46626  1896 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 46652  1897 */ {0, 0x0008, 0x8802},
+    /* 46677  1898 */ {0, 0x0028, 0x8801},
+    /* 46702  1899 */ {0, 0x0040, 0x8800},
+    /* 46725  1900 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46749  1901 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46773  1902 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 46799  1903 */ {0, 0x0008, 0x8802},
+    /* 46824  1904 */ {0, 0x002a, 0x8801},
+    /* 46849  1905 */ {0, 0x0084, 0x8800},
+    /* 46872  1906 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46896  1907 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 46920  1908 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 46946  1909 */ {0, 0x0008, 0x8802},
+    /* 46971  1910 */ {0, 0x002b, 0x8801},
+    /* 46996  1911 */ {0, 0x00a8, 0x8800},
+    /* 47019  1912 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47043  1913 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47067  1914 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 47093  1915 */ {0, 0x0008, 0x8802},
+    /* 47118  1916 */ {0, 0x002c, 0x8801},
+    /* 47143  1917 */ {0, 0x00fe, 0x8800},
+    /* 47166  1918 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47190  1919 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47214  1920 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 47240  1921 */ {0, 0x0008, 0x8802},
+    /* 47265  1922 */ {0, 0x002d, 0x8801},
+    /* 47290  1923 */ {0, 0x0003, 0x8800},
+    /* 47313  1924 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47337  1925 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47361  1926 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 47387  1927 */ {0, 0x0008, 0x8802},
+    /* 47412  1928 */ {0, 0x0038, 0x8801},
+    /* 47437  1929 */ {0, 0x0083, 0x8800},
+    /* 47460  1930 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47484  1931 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47508  1932 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 47534  1933 */ {0, 0x0008, 0x8802},
+    /* 47559  1934 */ {0, 0x0033, 0x8801},
+    /* 47584  1935 */ {0, 0x0081, 0x8800},
+    /* 47607  1936 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47631  1937 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47655  1938 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 47681  1939 */ {0, 0x0008, 0x8802},
+    /* 47706  1940 */ {0, 0x0034, 0x8801},
+    /* 47731  1941 */ {0, 0x004a, 0x8800},
+    /* 47754  1942 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47778  1943 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47802  1944 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 47828  1945 */ {0, 0x0008, 0x8802},
+    /* 47853  1946 */ {0, 0x0039, 0x8801},
+    /* 47878  1947 */ {0, 0x0000, 0x8800},
+    /* 47901  1948 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47925  1949 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 47949  1950 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 47975  1951 */ {0, 0x0008, 0x8802},
+    /* 48000  1952 */ {0, 0x0010, 0x8801},
+    /* 48025  1953 */ {0, 0x00a8, 0x8800},
+    /* 48048  1954 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48072  1955 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48096  1956 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 48122  1957 */ {0, 0x0008, 0x8802},
+    /* 48147  1958 */ {0, 0x0006, 0x8801},
+    /* 48172  1959 */ {0, 0x0058, 0x8800},
+    /* 48195  1960 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48219  1961 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48243  1962 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 48269  1963 */ {0, 0x0008, 0x8802},
+    /* 48294  1964 */ {0, 0x0000, 0x8801},
+    /* 48319  1965 */ {0, 0x0004, 0x8800},
+    /* 48342  1966 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48366  1967 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48390  1968 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 48416  1969 */ {0, 0x0008, 0x8802},
+    /* 48441  1970 */ {0, 0x0040, 0x8801},
+    /* 48466  1971 */ {0, 0x0080, 0x8800},
+    /* 48489  1972 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48513  1973 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48537  1974 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 48563  1975 */ {0, 0x0008, 0x8802},
+    /* 48588  1976 */ {0, 0x0041, 0x8801},
+    /* 48613  1977 */ {0, 0x000c, 0x8800},
+    /* 48636  1978 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48660  1979 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48684  1980 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 48710  1981 */ {0, 0x0008, 0x8802},
+    /* 48735  1982 */ {0, 0x0042, 0x8801},
+    /* 48760  1983 */ {0, 0x000c, 0x8800},
+    /* 48783  1984 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48807  1985 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48831  1986 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 48857  1987 */ {0, 0x0008, 0x8802},
+    /* 48882  1988 */ {0, 0x0043, 0x8801},
+    /* 48907  1989 */ {0, 0x0028, 0x8800},
+    /* 48930  1990 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48954  1991 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 48978  1992 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 49004  1993 */ {0, 0x0008, 0x8802},
+    /* 49029  1994 */ {0, 0x0044, 0x8801},
+    /* 49054  1995 */ {0, 0x0080, 0x8800},
+    /* 49077  1996 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49101  1997 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49125  1998 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 49151  1999 */ {0, 0x0008, 0x8802},
+    /* 49176  2000 */ {0, 0x0045, 0x8801},
+    /* 49201  2001 */ {0, 0x0020, 0x8800},
+    /* 49224  2002 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49248  2003 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49272  2004 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 49298  2005 */ {0, 0x0008, 0x8802},
+    /* 49323  2006 */ {0, 0x0046, 0x8801},
+    /* 49348  2007 */ {0, 0x0020, 0x8800},
+    /* 49371  2008 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49395  2009 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49419  2010 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 49445  2011 */ {0, 0x0008, 0x8802},
+    /* 49470  2012 */ {0, 0x0047, 0x8801},
+    /* 49495  2013 */ {0, 0x0080, 0x8800},
+    /* 49518  2014 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49542  2015 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49566  2016 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 49592  2017 */ {0, 0x0008, 0x8802},
+    /* 49617  2018 */ {0, 0x0048, 0x8801},
+    /* 49642  2019 */ {0, 0x004c, 0x8800},
+    /* 49665  2020 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49689  2021 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49713  2022 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 49739  2023 */ {0, 0x0008, 0x8802},
+    /* 49764  2024 */ {0, 0x0049, 0x8801},
+    /* 49789  2025 */ {0, 0x0084, 0x8800},
+    /* 49812  2026 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49836  2027 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49860  2028 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 49886  2029 */ {0, 0x0008, 0x8802},
+    /* 49911  2030 */ {0, 0x004a, 0x8801},
+    /* 49936  2031 */ {0, 0x0084, 0x8800},
+    /* 49959  2032 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 49983  2033 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 50007  2034 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 50033  2035 */ {0, 0x0008, 0x8802},
+    /* 50058  2036 */ {0, 0x004b, 0x8801},
+    /* 50083  2037 */ {0, 0x0084, 0x8800},
+    /* 50106  2038 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    // ---------------------------------------
+						/* 50132  2039 */ {0, 0x0012, 0x8700},
+						// Clock speed 48Mhz/(2+2)/2= 6 Mhz
+						/* 50157  2040 */ {0, 0x0000, 0x8701},
+						// CKx1 clock delay adj
+						/* 50182  2041 */ {0, 0x0000, 0x8701},
+						// CKx1 clock delay adj
+						/* 50207  2042 */ {0, 0x0001, 0x870c},
+						// CKOx2 output
+
+    // ---------------------------------------
+						/* 50232  2043 */ {0, 0x0080, 0x8600},
+						// Line memory read counter (L)
+						/* 50257  2044 */ {0, 0x0001, 0x8606},
+						// reserved
+						/* 50282  2045 */ {0, 0x0064, 0x8607},
+						// Line memory read counter (H) 0x6480=25,728
+						/* 50307  2046 */ {0, 0x002a, 0x8601},
+						// CDSP sharp interpolation mode, line sel for color sep, edge enhance enab
+						/* 50332  2047 */ {0, 0x0000, 0x8602},
+						// optical black level for user settng = 0
+						/* 50357  2048 */ {0, 0x0080, 0x8600},
+						// Line memory read counter (L)
+						/* 50382  2049 */ {0, 0x000a, 0x8603},
+						// optical black level calc mode: auto; optical black offset = 10
+						/* 50407  2050 */ {0, 0x00df, 0x865b},
+						// Horiz offset for valid pixels (L)=0xdf
+						/* 50432  2051 */ {0, 0x0012, 0x865c},
+						// Vert offset for valid lines (L)=0x12
+
+    // The following two lines seem to be the "wrong" resolution.
+    // But perhaps these indicate the actual size of the sensor
+    // rather than the size of the current video mode.
+						/* 50457  2052 */ {0, 0x0058, 0x865d},
+						// Horiz valid pixels (*4) (L) = 352
+						/* 50482  2053 */ {0, 0x0048, 0x865e},
+						// Vert valid lines (*4) (L) = 288
+
+						/* 50507  2054 */ {0, 0x0015, 0x8608},
+						// A11 Coef ...
+    /* 50532  2055 */ {0, 0x0030, 0x8609},
+    /* 50557  2056 */ {0, 0x00fb, 0x860a},
+    /* 50582  2057 */ {0, 0x003e, 0x860b},
+    /* 50607  2058 */ {0, 0x00ce, 0x860c},
+    /* 50632  2059 */ {0, 0x00f4, 0x860d},
+    /* 50657  2060 */ {0, 0x00eb, 0x860e},
+    /* 50682  2061 */ {0, 0x00dc, 0x860f},
+    /* 50707  2062 */ {0, 0x0039, 0x8610},
+						/* 50732  2063 */ {0, 0x0001, 0x8611},
+						// R offset for white balance ...
+    /* 50757  2064 */ {0, 0x0000, 0x8612},
+    /* 50782  2065 */ {0, 0x0001, 0x8613},
+    /* 50807  2066 */ {0, 0x0000, 0x8614},
+						/* 50832  2067 */ {0, 0x005b, 0x8651},
+						// R gain for white balance ...
+    /* 50857  2068 */ {0, 0x0040, 0x8652},
+    /* 50882  2069 */ {0, 0x0060, 0x8653},
+    /* 50907  2070 */ {0, 0x0040, 0x8654},
+    /* 50932  2071 */ {0, 0x0000, 0x8655},
+						/* 50957  2072 */ {0, 0x0001, 0x863f},
+						// Fixed gamma correction enable, USB control, lum filter disable, lum noise clip disable
+						/* 50982  2073 */ {0, 0x00a1, 0x8656},
+						// Window1 size 256x256, Windows2 size 64x64, gamma look-up disable, new edge enhancement enable
+						/* 51007  2074 */ {0, 0x0018, 0x8657},
+						// Edge gain high thresh
+						/* 51032  2075 */ {0, 0x0020, 0x8658},
+						// Edge gain low thresh
+						/* 51057  2076 */ {0, 0x000a, 0x8659},
+						// Edge bandwidth high threshold
+						/* 51082  2077 */ {0, 0x0005, 0x865a},
+						// Edge bandwidth low threshold
+
+    //--------------------------------
+						/* 51107  2078 */ {0, 0x0030, 0x8112},
+						// Video drop enable, ISO streaming enable
+    /* 51130  2079 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 51154  2080 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 51180  2081 */ {0, 0xa908, 0x8802},
+						/* 51205  2082 */ {0, 0x0034, 0x8801},
+						// SSI reg addr
+						/* 51230  2083 */ {0, 0x00ca, 0x8800},
+						// SSI data to write
+    /* 51253  2084 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 51277  2085 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 51301  2086 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 51327  2087 */ {0, 0x1f08, 0x8802},
+    /* 51352  2088 */ {0, 0x0006, 0x8801},
+    /* 51377  2089 */ {0, 0x0080, 0x8800},
+    /* 51400  2090 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+
+    //----- Read back coefs we wrote earlier.
+    /* 51424  2091 *//* READ { 0, 0x0000, 0x8608 } ->
+       0000: 15  */
+    /* 51448  2092 *//* READ { 0, 0x0000, 0x8609 } ->
+       0000: 30  */
+    /* 51472  2093 *//* READ { 0, 0x0000, 0x860a } ->
+       0000: fb  */
+    /* 51496  2094 *//* READ { 0, 0x0000, 0x860b } ->
+       0000: 3e  */
+    /* 51520  2095 *//* READ { 0, 0x0000, 0x860c } ->
+       0000: ce  */
+    /* 51544  2096 *//* READ { 0, 0x0000, 0x860d } ->
+       0000: f4  */
+    /* 51568  2097 *//* READ { 0, 0x0000, 0x860e } ->
+       0000: eb  */
+    /* 51592  2098 *//* READ { 0, 0x0000, 0x860f } ->
+       0000: dc  */
+    /* 51616  2099 *//* READ { 0, 0x0000, 0x8610 } ->
+       0000: 39  */
+    /* 51640  2100 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 51664  2101 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 08  */
+    /* 51690  2102 */ {0, 0xb008, 0x8802},
+    /* 51715  2103 */ {0, 0x0006, 0x8801},
+    /* 51740  2104 */ {0, 0x007d, 0x8800},
+    /* 51763  2105 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+#if 0
+    /* experimental.  dark version. */
+    {0, 0xba, 0x8705},		/* total pixel clocks per hsync cycle (L) */
+    {0, 0x00, 0x8706},		/* total pixel clocks per hsync cycle (H in 2:0) */
+    {0, 0x5a, 0x8707},		/* total pixel clocks per hsync blank period (L) */
+#elif 0
+    /* experimental.  factory default. */
+    {0, 0x8e, 0x8705},		/* total pixel clocks per hsync cycle (L) */
+    {0, 0x03, 0x8706},		/* total pixel clocks per hsync cycle (H in 2:0) */
+    {0, 0x5a, 0x8707},		/* total pixel clocks per hsync blank period (L) */
+#elif 0
+    /* experimental.  light. */
+    {0, 0xba, 0x8705},		/* total pixel clocks per hsync cycle (L) */
+    {0, 0x01, 0x8706},		/* total pixel clocks per hsync cycle (H in 2:0) */
+    {0, 0x10, 0x8707},		/* total pixel clocks per hsync blank period (L) */
+#endif
+
+#if 1
+    // This chunk is seemingly redundant with
+    // earlier commands (A11 Coef...), but if I disable it,
+    // the image appears too dark.  Maybe there was some kind of
+    // reset since the earlier commands, so this is necessary again.
+    /* 51789  2106 */ {0, 0x0015, 0x8608},
+    /* 51814  2107 */ {0, 0x0030, 0x8609},
+    /* 51839  2108 */ {0, 0xfffb, 0x860a},
+    /* 51864  2109 */ {0, 0x003e, 0x860b},
+    /* 51889  2110 */ {0, 0xffce, 0x860c},
+    /* 51914  2111 */ {0, 0xfff4, 0x860d},
+    /* 51939  2112 */ {0, 0xffeb, 0x860e},
+    /* 51964  2113 */ {0, 0xffdc, 0x860f},
+    /* 51989  2114 */ {0, 0x0039, 0x8610},
+    /* 52014  2115 */ {0, 0x0018, 0x8657},
+#endif
+
+						/* 52039  2116 */ {0, 0x0000, 0x8508},
+						// Disable compression.
+    // Previous line was: /* 52039  2116 */ { 0, 0x0021, 0x8508 }, // Enable compression.
+						/* 52064  2117 */ {0, 0x0032, 0x850b},
+						// compression stuff
+						/* 52089  2118 */ {0, 0x0003, 0x8509},
+						// compression stuff
+						/* 52114  2119 */ {0, 0x0011, 0x850a},
+						// compression stuff
+						/* 52139  2120 */ {0, 0x0021, 0x850d},
+						// compression stuff
+						/* 52164  2121 */ {0, 0x0010, 0x850c},
+						// compression stuff
+						/* 52189  2122 */ {0, 0x0003, 0x8500},
+						// *** Video mode: 160x120
+						/* 52214  2123 */ {0, 0x0001, 0x8501},
+						// Hardware-dominated snap control
+						/* 52239  2124 */ {0, 0x0061, 0x8656},
+						// Window1 size 128x128, Windows2 size 128x128, gamma look-up disable, new edge enhancement enable
+						/* 52264  2125 */ {0, 0x0018, 0x8617},
+						// Window1 start X (*2)
+						/* 52289  2126 */ {0, 0x0008, 0x8618},
+						// Window1 start Y (*2)
+						/* 52314  2127 */ {0, 0x0061, 0x8656},
+						// Window1 size 128x128, Windows2 size 128x128, gamma look-up disable, new edge enhancement enable
+						/* 52339  2128 */ {0, 0x0058, 0x8619},
+						// Window2 start X (*2)
+						/* 52364  2129 */ {0, 0x0008, 0x861a},
+						// Window2 start Y (*2)
+						/* 52389  2130 */ {0, 0x00ff, 0x8615},
+						// High lum thresh for white balance
+						/* 52414  2131 */ {0, 0x0000, 0x8616},
+						// Low lum thresh for white balance
+						/* 52439  2132 */ {0, 0x0012, 0x8700},
+						// Clock speed 48Mhz/(2+2)/2= 6 Mhz
+						/* 52464  2133 */ {0, 0x0012, 0x8700},
+						// Clock speed 48Mhz/(2+2)/2= 6 Mhz
+    /* 52487  2134 *//* READ { 0, 0x0000, 0x8656 } ->
+       0000: 61  */
+
+
+						/* 52513  2135 */ {0, 0x0028, 0x8802},
+						// 375 Khz SSI clock, SSI r/w sync with VSYNC
+    /* 52536  2136 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 52560  2137 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 28  */
+						/* 52586  2138 */ {0, 0x1f28, 0x8802},
+						// 375 Khz SSI clock, SSI r/w sync with VSYNC
+						/* 52611  2139 */ {0, 0x0010, 0x8801},
+						// SSI reg addr
+						/* 52636  2140 */ {0, 0x003e, 0x8800},
+						// SSI data to write
+    /* 52659  2141 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 52685  2142 */ {0, 0x0028, 0x8802},
+    /* 52708  2143 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 52732  2144 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 28  */
+    /* 52758  2145 */ {0, 0x1f28, 0x8802},
+    /* 52783  2146 */ {0, 0x0000, 0x8801},
+    /* 52808  2147 */ {0, 0x001f, 0x8800},
+    /* 52831  2148 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+						/* 52857  2149 */ {0, 0x0001, 0x8602},
+						// optical black level for user settning = 1
+
+#if 0
+    // NOTE: Code like this case lets this driver (often) work
+    // in 352x288 resolution, apparently by slowing down the
+    // clock.
+
+						/* 52464  2133 */ {0, 0x002F, 0x8700},
+						// Clock speed 
+#else
+    // Original:
+						/* 52882  2150 */ {0, 0x0023, 0x8700},
+						// Clock speed 48Mhz/(3+2)/4= 2.4 Mhz
+#endif
+
+						/* 52907  2151 */ {0, 0x000f, 0x8602},
+						// optical black level for user settning = 15
+
+    /* 52932  2152 */ {0, 0x0028, 0x8802},
+    /* 52955  2153 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* 52979  2154 *//* READ { 0, 0x0001, 0x8802 } ->
+       0000: 28  */
+    /* 53005  2155 */ {0, 0x1f28, 0x8802},
+    /* 53030  2156 */ {0, 0x0010, 0x8801},
+    /* 53055  2157 */ {0, 0x007b, 0x8800},
+    /* 53078  2158 *//* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+						/* 53104  2159 */ {0, 0x002f, 0x8651},
+						// R gain for white balance ...
+    /* 53129  2160 */ {0, 0x0080, 0x8653},
+    /* 53152  2161 *//* READ { 0, 0x0000, 0x8655 } ->
+       0000: 00  */
+    /* 53178  2162 */ {0, 0x0000, 0x8655},
+
+						/* 53203  2163 */ {0, 0x0030, 0x8112},
+						// Video drop enable, ISO streaming enable
+						/* 53228  2164 */ {0, 0x0020, 0x8112},
+						// Video drop enable, ISO streaming disable
+    /* 53252  2165 *//* UNKNOWN DIRECTION (URB_FUNCTION_SELECT_INTERFACE: (ALT=0) ) */
+
+    {0, 0, 0}
+};
+
+/*
+ * Data to initialize the camera using the internal CCD
+ */
+static __u16 spca508_open_data[][3] = {
+    /* line       bmRequest,value,index */
+    {0, 0, 0}
+};
+
+/*
+ * Initialization data for Intel EasyPC Camera CS110
+ */
+static __u16 spca508cs110_init_data[][3] = {
+    {0, 0x0000, 0x870b},	/* Reset CTL3 */
+    {0, 0x0003, 0x8111},	/* Soft Reset compression, memory, TG & CDSP */
+    {0, 0x0000, 0x8111},	/* Normal operation on reset */
+    {0, 0x0090, 0x8110},	/* External Clock 2x & Synchronous Serial Interface Output */
+    {0, 0x0020, 0x8112},	/* Video Drop packet enable */
+    {0, 0x0000, 0x8114},	/* Software GPIO output data */
+    {0, 0x0001, 0x8114},
+    {0, 0x0001, 0x8114},
+    {0, 0x0001, 0x8114},
+    {0, 0x0003, 0x8114},
+
+    /* Initial sequence Synchronous Serial Interface */
+    {0, 0x000f, 0x8402},	/* Memory bank Address */
+    {0, 0x0000, 0x8403},	/* Memory bank Address */
+    {0, 0x00ba, 0x8804},	/* SSI Slave address */
+    {0, 0x0010, 0x8802},	/* 93.75kHz SSI Clock Two DataByte */
+    {0, 0x0010, 0x8802},	/* 93.75kHz SSI Clock two DataByte */
+
+    {0, 0x0001, 0x8801},
+    {0, 0x000a, 0x8805},	/* a - NWG: Dunno what this is about */
+    {0, 0x0000, 0x8800},
+    {0, 0x0010, 0x8802},
+
+    {0, 0x0002, 0x8801},
+    {0, 0x0000, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0010, 0x8802},
+
+    {0, 0x0003, 0x8801},
+    {0, 0x0027, 0x8805},
+    {0, 0x0001, 0x8800},
+    {0, 0x0010, 0x8802},
+
+    {0, 0x0004, 0x8801},
+    {0, 0x0065, 0x8805},
+    {0, 0x0001, 0x8800},
+    {0, 0x0010, 0x8802},
+
+    {0, 0x0005, 0x8801},
+    {0, 0x0003, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0010, 0x8802},
+
+    {0, 0x0006, 0x8801},
+    {0, 0x001c, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0010, 0x8802},
+
+    {0, 0x0007, 0x8801},
+    {0, 0x002a, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0010, 0x8802},
+
+
+
+    {0, 0x0002, 0x8704},	/* External input CKIx1 */
+    {0, 0x0001, 0x8606},	/* 1 Line memory Read Counter (H) Result: (d)410 */
+    {0, 0x009a, 0x8600},	/* Line memory Read Counter (L) */
+    {0, 0x0001, 0x865b},	/* 1 Horizontal Offset for Valid Pixel(L) */
+    {0, 0x0003, 0x865c},	/* 3 Vertical Offset for Valid Lines(L) */
+    {0, 0x0058, 0x865d},	/* 58 Horizontal Valid Pixel Window(L) */
+
+
+    {0, 0x0006, 0x8660},	/* Nibble data + input order */
+
+
+    {0, 0x000a, 0x8602},	/* Optical black level set to 0x0a */
+					/* 1945 */ {0, 0x0000, 0x8603},
+					/* Optical black level Offset */
+
+    /* 1962 */// { 0, 0x0000, 0x8611 }, /* 0 R  Offset for white Balance */
+    /* 1963 */// { 0, 0x0000, 0x8612 }, /* 1 Gr Offset for white Balance */
+    /* 1964 */// { 0, 0x0000, 0x8613 }, /* 1f B  Offset for white Balance */
+    /* 1965 */// { 0, 0x0000, 0x8614 }, /* f0 Gb Offset for white Balance */
+
+    {0, 0x0040, 0x8651},	/* 2b BLUE gain for white balance  good at all 60 */
+    {0, 0x0030, 0x8652},	/* 41 Gr Gain for white Balance (L) */
+    {0, 0x0035, 0x8653},	/* 26 RED gain for white balance */
+    {0, 0x0035, 0x8654},	/* 40Gb Gain for white Balance (L) */
+    {0, 0x0041, 0x863f},	/* Fixed Gamma correction enabled (makes colours look better) */
+
+					/* 2422 */ {0, 0x0000, 0x8655},
+					/* High bits for white balance*****brightness control*** */
+
+    {0, 0, 0}
+};
+
+static __u16 spca508_sightcam_init_data[][3] = {
+/* This line seems to setup the frame/canvas */
+    /*368  */ {0, 0x000f, 0x8402},
+
+/* Theese 6 lines are needed to startup the webcam */
+    /*398  */ {0, 0x0090, 0x8110},
+    /*399  */ {0, 0x0001, 0x8114},
+    /*400  */ {0, 0x0001, 0x8114},
+    /*401  */ {0, 0x0001, 0x8114},
+    /*402  */ {0, 0x0003, 0x8114},
+    /*403  */ {0, 0x0080, 0x8804},
+
+/* This part seems to make the pictures darker? (autobrightness?) */
+    /*436  */ {0, 0x0001, 0x8801},
+    /*437  */ {0, 0x0004, 0x8800},
+    /*439  */ {0, 0x0003, 0x8801},
+    /*440  */ {0, 0x00e0, 0x8800},
+    /*442  */ {0, 0x0004, 0x8801},
+    /*443  */ {0, 0x00b4, 0x8800},
+    /*445  */ {0, 0x0005, 0x8801},
+    /*446  */ {0, 0x0000, 0x8800},
+
+    /*448  */ {0, 0x0006, 0x8801},
+    /*449  */ {0, 0x00e0, 0x8800},
+    /*451  */ {0, 0x0007, 0x8801},
+    /*452  */ {0, 0x000c, 0x8800},
+
+/* This section is just needed, it probably
+ * does something like the previous section,
+ * but the cam won't start if it's not included.
+ */
+    /*484  */ {0, 0x0014, 0x8801},
+    /*485  */ {0, 0x0008, 0x8800},
+    /*487  */ {0, 0x0015, 0x8801},
+    /*488  */ {0, 0x0067, 0x8800},
+    /*490  */ {0, 0x0016, 0x8801},
+    /*491  */ {0, 0x0000, 0x8800},
+    /*493  */ {0, 0x0017, 0x8801},
+    /*494  */ {0, 0x0020, 0x8800},
+    /*496  */ {0, 0x0018, 0x8801},
+    /*497  */ {0, 0x0044, 0x8800},
+
+/* Makes the picture darker - and the
+ * cam won't start if not included
+ */
+    /*505  */ {0, 0x001e, 0x8801},
+    /*506  */ {0, 0x00ea, 0x8800},
+    /*508  */ {0, 0x001f, 0x8801},
+    /*509  */ {0, 0x0001, 0x8800},
+    /*511  */ {0, 0x0003, 0x8801},
+    /*512  */ {0, 0x00e0, 0x8800},
+
+/* seems to place the colors ontop of each other #1 */
+    /*517  */ {0, 0x0006, 0x8704},
+    /*518  */ {0, 0x0001, 0x870c},
+    /*519  */ {0, 0x0016, 0x8600},
+    /*520  */ {0, 0x0002, 0x8606},
+
+/* if not included the pictures becomes _very_ dark */
+    /*521  */ {0, 0x0064, 0x8607},
+    /*522  */ {0, 0x003a, 0x8601},
+    /*523  */ {0, 0x0000, 0x8602},
+
+/* seems to place the colors ontop of each other #2 */
+    /*524  */ {0, 0x0016, 0x8600},
+    /*525  */ {0, 0x0018, 0x8617},
+    /*526  */ {0, 0x0008, 0x8618},
+    /*527  */ {0, 0x00a1, 0x8656},
+
+/* webcam won't start if not included */
+    /*528  */ {0, 0x0007, 0x865b},
+    /*529  */ {0, 0x0001, 0x865c},
+    /*530  */ {0, 0x0058, 0x865d},
+    /*531  */ {0, 0x0048, 0x865e},
+
+/* adjusts the colors */
+    /*541  */ {0, 0x0049, 0x8651},
+    /*542  */ {0, 0x0040, 0x8652},
+    /*543  */ {0, 0x004c, 0x8653},
+    /*544  */ {0, 0x0040, 0x8654},
+
+    {0, 0, 0}
+};
+
+static __u16 spca508_sightcam2_init_data[][3] = {
+#if 1
+/* 35 */ {0, 0x0020, 0x8112},
+
+/* 36 */ {0, 0x000f, 0x8402},
+/* 37 */ {0, 0x0000, 0x8403},
+
+/* 38 */ {0, 0x0008, 0x8201},
+/* 39 */ {0, 0x0008, 0x8200},
+/* 40 */ {0, 0x0001, 0x8200},
+/* 43 */ {0, 0x0009, 0x8201},
+/* 44 */ {0, 0x0008, 0x8200},
+/* 45 */ {0, 0x0001, 0x8200},
+/* 48 */ {0, 0x000a, 0x8201},
+/* 49 */ {0, 0x0008, 0x8200},
+/* 50 */ {0, 0x0001, 0x8200},
+/* 53 */ {0, 0x000b, 0x8201},
+/* 54 */ {0, 0x0008, 0x8200},
+/* 55 */ {0, 0x0001, 0x8200},
+/* 58 */ {0, 0x000c, 0x8201},
+/* 59 */ {0, 0x0008, 0x8200},
+/* 60 */ {0, 0x0001, 0x8200},
+/* 63 */ {0, 0x000d, 0x8201},
+/* 64 */ {0, 0x0008, 0x8200},
+/* 65 */ {0, 0x0001, 0x8200},
+/* 68 */ {0, 0x000e, 0x8201},
+/* 69 */ {0, 0x0008, 0x8200},
+/* 70 */ {0, 0x0001, 0x8200},
+/* 73 */ {0, 0x0007, 0x8201},
+/* 74 */ {0, 0x0008, 0x8200},
+/* 75 */ {0, 0x0001, 0x8200},
+/* 78 */ {0, 0x000f, 0x8201},
+/* 79 */ {0, 0x0008, 0x8200},
+/* 80 */ {0, 0x0001, 0x8200},
+
+/* 84 */ {0, 0x0018, 0x8660},
+/* 85 */ {0, 0x0010, 0x8201},
+
+/* 86 */ {0, 0x0008, 0x8200},
+/* 87 */ {0, 0x0001, 0x8200},
+/* 90 */ {0, 0x0011, 0x8201},
+/* 91 */ {0, 0x0008, 0x8200},
+/* 92 */ {0, 0x0001, 0x8200},
+
+/* 95 */ {0, 0x0000, 0x86b0},
+/* 96 */ {0, 0x0034, 0x86b1},
+/* 97 */ {0, 0x0000, 0x86b2},
+/* 98 */ {0, 0x0049, 0x86b3},
+/* 99 */ {0, 0x0000, 0x86b4},
+/* 100 */ {0, 0x0000, 0x86b4},
+
+/* 101 */ {0, 0x0012, 0x8201},
+/* 102 */ {0, 0x0008, 0x8200},
+/* 103 */ {0, 0x0001, 0x8200},
+/* 106 */ {0, 0x0013, 0x8201},
+/* 107 */ {0, 0x0008, 0x8200},
+/* 108 */ {0, 0x0001, 0x8200},
+
+/* 111 */ {0, 0x0001, 0x86b0},
+/* 112 */ {0, 0x00aa, 0x86b1},
+/* 113 */ {0, 0x0000, 0x86b2},
+/* 114 */ {0, 0x00e4, 0x86b3},
+/* 115 */ {0, 0x0000, 0x86b4},
+/* 116 */ {0, 0x0000, 0x86b4},
+
+/* 118 */ {0, 0x0018, 0x8660},
+
+/* 119 */ {0, 0x0090, 0x8110},
+/* 120 */ {0, 0x0001, 0x8114},
+/* 121 */ {0, 0x0001, 0x8114},
+/* 122 */ {0, 0x0001, 0x8114},
+/* 123 */ {0, 0x0003, 0x8114},
+
+/* 124 */ {0, 0x0080, 0x8804},
+/* 157 */ {0, 0x0003, 0x8801},
+/* 158 */ {0, 0x0012, 0x8800},
+/* 160 */ {0, 0x0004, 0x8801},
+/* 161 */ {0, 0x0005, 0x8800},
+/* 163 */ {0, 0x0005, 0x8801},
+/* 164 */ {0, 0x0000, 0x8800},
+/* 166 */ {0, 0x0006, 0x8801},
+/* 167 */ {0, 0x0000, 0x8800},
+/* 169 */ {0, 0x0007, 0x8801},
+/* 170 */ {0, 0x0000, 0x8800},
+/* 172 */ {0, 0x0008, 0x8801},
+/* 173 */ {0, 0x0005, 0x8800},
+/* 175 */ {0, 0x000a, 0x8700},
+/* 176 */ {0, 0x000e, 0x8801},
+/* 177 */ {0, 0x0004, 0x8800},
+/* 179 */ {0, 0x0005, 0x8801},
+/* 180 */ {0, 0x0047, 0x8800},
+/* 182 */ {0, 0x0006, 0x8801},
+/* 183 */ {0, 0x0000, 0x8800},
+/* 185 */ {0, 0x0007, 0x8801},
+/* 186 */ {0, 0x00c0, 0x8800},
+/* 188 */ {0, 0x0008, 0x8801},
+/* 189 */ {0, 0x0003, 0x8800},
+/* 191 */ {0, 0x0013, 0x8801},
+/* 192 */ {0, 0x0001, 0x8800},
+/* 194 */ {0, 0x0009, 0x8801},
+/* 195 */ {0, 0x0000, 0x8800},
+/* 197 */ {0, 0x000a, 0x8801},
+/* 198 */ {0, 0x0000, 0x8800},
+/* 200 */ {0, 0x000b, 0x8801},
+/* 201 */ {0, 0x0000, 0x8800},
+/* 203 */ {0, 0x000c, 0x8801},
+/* 204 */ {0, 0x0000, 0x8800},
+/* 206 */ {0, 0x000e, 0x8801},
+/* 207 */ {0, 0x0004, 0x8800},
+/* 209 */ {0, 0x000f, 0x8801},
+/* 210 */ {0, 0x0000, 0x8800},
+/* 212 */ {0, 0x0010, 0x8801},
+/* 213 */ {0, 0x0006, 0x8800},
+/* 215 */ {0, 0x0011, 0x8801},
+/* 216 */ {0, 0x0006, 0x8800},
+/* 218 */ {0, 0x0012, 0x8801},
+/* 219 */ {0, 0x0000, 0x8800},
+/* 221 */ {0, 0x0013, 0x8801},
+/* 222 */ {0, 0x0001, 0x8800},
+
+/* 224 */ {0, 0x000a, 0x8700},
+/* 225 */ {0, 0x0000, 0x8702},
+/* 226 */ {0, 0x0000, 0x8703},
+/* 227 */ {0, 0x00c2, 0x8704},
+/* 228 */ {0, 0x0001, 0x870c},
+
+/* 229 */ {0, 0x0044, 0x8600},
+/* 230 */ {0, 0x0002, 0x8606},
+/* 231 */ {0, 0x0064, 0x8607},
+/* 232 */ {0, 0x003a, 0x8601},
+/* 233 */ {0, 0x0008, 0x8602},
+/* 234 */ {0, 0x0044, 0x8600},
+/* 235 */ {0, 0x0018, 0x8617},
+/* 236 */ {0, 0x0008, 0x8618},
+/* 237 */ {0, 0x00a1, 0x8656},
+/* 238 */ {0, 0x0004, 0x865b},
+/* 239 */ {0, 0x0002, 0x865c},
+/* 240 */ {0, 0x0058, 0x865d},
+/* 241 */ {0, 0x0048, 0x865e},
+/* 242 */ {0, 0x0012, 0x8608},
+/* 243 */ {0, 0x002c, 0x8609},
+/* 244 */ {0, 0x0002, 0x860a},
+/* 245 */ {0, 0x002c, 0x860b},
+/* 246 */ {0, 0x00db, 0x860c},
+/* 247 */ {0, 0x00f9, 0x860d},
+/* 248 */ {0, 0x00f1, 0x860e},
+/* 249 */ {0, 0x00e3, 0x860f},
+/* 250 */ {0, 0x002c, 0x8610},
+/* 251 */ {0, 0x006c, 0x8651},
+/* 252 */ {0, 0x0041, 0x8652},
+/* 253 */ {0, 0x0059, 0x8653},
+/* 254 */ {0, 0x0040, 0x8654},
+/* 255 */ {0, 0x00fa, 0x8611},
+/* 256 */ {0, 0x00ff, 0x8612},
+/* 257 */ {0, 0x00f8, 0x8613},
+/* 258 */ {0, 0x0000, 0x8614},
+/* 259 */ {0, 0x0001, 0x863f},
+/* 260 */ {0, 0x0000, 0x8640},
+/* 261 */ {0, 0x0026, 0x8641},
+/* 262 */ {0, 0x0045, 0x8642},
+/* 263 */ {0, 0x0060, 0x8643},
+/* 264 */ {0, 0x0075, 0x8644},
+/* 265 */ {0, 0x0088, 0x8645},
+/* 266 */ {0, 0x009b, 0x8646},
+/* 267 */ {0, 0x00b0, 0x8647},
+/* 268 */ {0, 0x00c5, 0x8648},
+/* 269 */ {0, 0x00d2, 0x8649},
+/* 270 */ {0, 0x00dc, 0x864a},
+/* 271 */ {0, 0x00e5, 0x864b},
+/* 272 */ {0, 0x00eb, 0x864c},
+/* 273 */ {0, 0x00f0, 0x864d},
+/* 274 */ {0, 0x00f6, 0x864e},
+/* 275 */ {0, 0x00fa, 0x864f},
+/* 276 */ {0, 0x00ff, 0x8650},
+/* 277 */ {0, 0x0060, 0x8657},
+/* 278 */ {0, 0x0010, 0x8658},
+/* 279 */ {0, 0x0018, 0x8659},
+/* 280 */ {0, 0x0005, 0x865a},
+/* 281 */ {0, 0x0018, 0x8660},
+/* 282 */ {0, 0x0003, 0x8509},
+/* 283 */ {0, 0x0011, 0x850a},
+/* 284 */ {0, 0x0032, 0x850b},
+/* 285 */ {0, 0x0010, 0x850c},
+/* 286 */ {0, 0x0021, 0x850d},
+/* 287 */ {0, 0x0001, 0x8500},
+/* 288 */ {0, 0x0000, 0x8508},
+/* 289 */ {0, 0x0012, 0x8608},
+/* 290 */ {0, 0x002c, 0x8609},
+/* 291 */ {0, 0x0002, 0x860a},
+/* 292 */ {0, 0x0039, 0x860b},
+/* 293 */ {0, 0x00d0, 0x860c},
+/* 294 */ {0, 0x00f7, 0x860d},
+/* 295 */ {0, 0x00ed, 0x860e},
+/* 296 */ {0, 0x00db, 0x860f},
+/* 297 */ {0, 0x0039, 0x8610},
+/* 298 */ {0, 0x0012, 0x8657},
+/* 299 */ {0, 0x000c, 0x8619},
+/* 300 */ {0, 0x0004, 0x861a},
+/* 301 */ {0, 0x00a1, 0x8656},
+/* 302 */ {0, 0x00c8, 0x8615},
+/* 303 */ {0, 0x0032, 0x8616},
+
+/* 306 */ {0, 0x0030, 0x8112},
+/* 313 */ {0, 0x0020, 0x8112},
+/* 314 */ {0, 0x0020, 0x8112},
+/* 315 */ {0, 0x000f, 0x8402},
+/* 316 */ {0, 0x0000, 0x8403},
+
+/* 317 */ {0, 0x0090, 0x8110},
+/* 318 */ {0, 0x0001, 0x8114},
+/* 319 */ {0, 0x0001, 0x8114},
+/* 320 */ {0, 0x0001, 0x8114},
+/* 321 */ {0, 0x0003, 0x8114},
+/* 322 */ {0, 0x0080, 0x8804},
+
+/* 355 */ {0, 0x0003, 0x8801},
+/* 356 */ {0, 0x0012, 0x8800},
+/* 358 */ {0, 0x0004, 0x8801},
+/* 359 */ {0, 0x0005, 0x8800},
+/* 361 */ {0, 0x0005, 0x8801},
+/* 362 */ {0, 0x0047, 0x8800},
+/* 364 */ {0, 0x0006, 0x8801},
+/* 365 */ {0, 0x0000, 0x8800},
+/* 367 */ {0, 0x0007, 0x8801},
+/* 368 */ {0, 0x00c0, 0x8800},
+/* 370 */ {0, 0x0008, 0x8801},
+/* 371 */ {0, 0x0003, 0x8800},
+/* 373 */ {0, 0x000a, 0x8700},
+/* 374 */ {0, 0x000e, 0x8801},
+/* 375 */ {0, 0x0004, 0x8800},
+/* 377 */ {0, 0x0005, 0x8801},
+/* 378 */ {0, 0x0047, 0x8800},
+/* 380 */ {0, 0x0006, 0x8801},
+/* 381 */ {0, 0x0000, 0x8800},
+/* 383 */ {0, 0x0007, 0x8801},
+/* 384 */ {0, 0x00c0, 0x8800},
+/* 386 */ {0, 0x0008, 0x8801},
+/* 387 */ {0, 0x0003, 0x8800},
+/* 389 */ {0, 0x0013, 0x8801},
+/* 390 */ {0, 0x0001, 0x8800},
+/* 392 */ {0, 0x0009, 0x8801},
+/* 393 */ {0, 0x0000, 0x8800},
+/* 395 */ {0, 0x000a, 0x8801},
+/* 396 */ {0, 0x0000, 0x8800},
+/* 398 */ {0, 0x000b, 0x8801},
+/* 399 */ {0, 0x0000, 0x8800},
+/* 401 */ {0, 0x000c, 0x8801},
+/* 402 */ {0, 0x0000, 0x8800},
+/* 404 */ {0, 0x000e, 0x8801},
+/* 405 */ {0, 0x0004, 0x8800},
+/* 407 */ {0, 0x000f, 0x8801},
+/* 408 */ {0, 0x0000, 0x8800},
+/* 410 */ {0, 0x0010, 0x8801},
+/* 411 */ {0, 0x0006, 0x8800},
+/* 413 */ {0, 0x0011, 0x8801},
+/* 414 */ {0, 0x0006, 0x8800},
+/* 416 */ {0, 0x0012, 0x8801},
+/* 417 */ {0, 0x0000, 0x8800},
+/* 419 */ {0, 0x0013, 0x8801},
+/* 420 */ {0, 0x0001, 0x8800},
+/* 422 */ {0, 0x000a, 0x8700},
+/* 423 */ {0, 0x0000, 0x8702},
+/* 424 */ {0, 0x0000, 0x8703},
+/* 425 */ {0, 0x00c2, 0x8704},
+/* 426 */ {0, 0x0001, 0x870c},
+/* 427 */ {0, 0x0044, 0x8600},
+/* 428 */ {0, 0x0002, 0x8606},
+/* 429 */ {0, 0x0064, 0x8607},
+/* 430 */ {0, 0x003a, 0x8601},
+/* 431 */ {0, 0x0008, 0x8602},
+/* 432 */ {0, 0x0044, 0x8600},
+/* 433 */ {0, 0x0018, 0x8617},
+/* 434 */ {0, 0x0008, 0x8618},
+/* 435 */ {0, 0x00a1, 0x8656},
+/* 436 */ {0, 0x0004, 0x865b},
+/* 437 */ {0, 0x0002, 0x865c},
+/* 438 */ {0, 0x0058, 0x865d},
+/* 439 */ {0, 0x0048, 0x865e},
+/* 440 */ {0, 0x0012, 0x8608},
+/* 441 */ {0, 0x002c, 0x8609},
+/* 442 */ {0, 0x0002, 0x860a},
+/* 443 */ {0, 0x002c, 0x860b},
+/* 444 */ {0, 0x00db, 0x860c},
+/* 445 */ {0, 0x00f9, 0x860d},
+/* 446 */ {0, 0x00f1, 0x860e},
+/* 447 */ {0, 0x00e3, 0x860f},
+/* 448 */ {0, 0x002c, 0x8610},
+/* 449 */ {0, 0x006c, 0x8651},
+/* 450 */ {0, 0x0041, 0x8652},
+/* 451 */ {0, 0x0059, 0x8653},
+/* 452 */ {0, 0x0040, 0x8654},
+/* 453 */ {0, 0x00fa, 0x8611},
+/* 454 */ {0, 0x00ff, 0x8612},
+/* 455 */ {0, 0x00f8, 0x8613},
+/* 456 */ {0, 0x0000, 0x8614},
+/* 457 */ {0, 0x0001, 0x863f},
+/* 458 */ {0, 0x0000, 0x8640},
+/* 459 */ {0, 0x0026, 0x8641},
+/* 460 */ {0, 0x0045, 0x8642},
+/* 461 */ {0, 0x0060, 0x8643},
+/* 462 */ {0, 0x0075, 0x8644},
+/* 463 */ {0, 0x0088, 0x8645},
+/* 464 */ {0, 0x009b, 0x8646},
+/* 465 */ {0, 0x00b0, 0x8647},
+/* 466 */ {0, 0x00c5, 0x8648},
+/* 467 */ {0, 0x00d2, 0x8649},
+/* 468 */ {0, 0x00dc, 0x864a},
+/* 469 */ {0, 0x00e5, 0x864b},
+/* 470 */ {0, 0x00eb, 0x864c},
+/* 471 */ {0, 0x00f0, 0x864d},
+/* 472 */ {0, 0x00f6, 0x864e},
+/* 473 */ {0, 0x00fa, 0x864f},
+/* 474 */ {0, 0x00ff, 0x8650},
+/* 475 */ {0, 0x0060, 0x8657},
+/* 476 */ {0, 0x0010, 0x8658},
+/* 477 */ {0, 0x0018, 0x8659},
+/* 478 */ {0, 0x0005, 0x865a},
+/* 479 */ {0, 0x0018, 0x8660},
+/* 480 */ {0, 0x0003, 0x8509},
+/* 481 */ {0, 0x0011, 0x850a},
+/* 482 */ {0, 0x0032, 0x850b},
+/* 483 */ {0, 0x0010, 0x850c},
+/* 484 */ {0, 0x0021, 0x850d},
+/* 485 */ {0, 0x0001, 0x8500},
+/* 486 */ {0, 0x0000, 0x8508},
+
+/* 487 */ {0, 0x0012, 0x8608},
+/* 488 */ {0, 0x002c, 0x8609},
+/* 489 */ {0, 0x0002, 0x860a},
+/* 490 */ {0, 0x0039, 0x860b},
+/* 491 */ {0, 0x00d0, 0x860c},
+/* 492 */ {0, 0x00f7, 0x860d},
+/* 493 */ {0, 0x00ed, 0x860e},
+/* 494 */ {0, 0x00db, 0x860f},
+/* 495 */ {0, 0x0039, 0x8610},
+/* 496 */ {0, 0x0012, 0x8657},
+/* 497 */ {0, 0x0064, 0x8619},
+
+/* This line starts it all, it is not needed here */
+/* since it has been build into the driver*/
+    /*590  */ {0, 0x0030, 0x8112},
+#endif
+
+    {0, 0, 0}
+};
+
+/*
+ * Initialization data for Creative Webcam Vista
+ */
+static __u16 spca508_vista_init_data[][3] = {
+    {0, 0x0008, 0x8200},	/* Clear register */
+    {0, 0x0000, 0x870b},	/* Reset CTL3 */
+    {0, 0x0020, 0x8112},	/* Video Drop packet enable */
+    {0, 0x0003, 0x8111},	/* Soft Reset compression, memory, TG & CDSP */
+    {0, 0x0000, 0x8110},	/* Disable everything */
+    {0, 0x0000, 0x8114},	/* Software GPIO output data */
+    {0, 0x0000, 0x8114},
+
+    {0, 0x0003, 0x8111},
+    {0, 0x0000, 0x8111},
+    {0, 0x0090, 0x8110},	/* Enable: SSI output, External 2X clock output */
+    {0, 0x0020, 0x8112},
+    {0, 0x0000, 0x8114},
+    {0, 0x0001, 0x8114},
+    {0, 0x0001, 0x8114},
+    {0, 0x0001, 0x8114},
+    {0, 0x0003, 0x8114},
+
+    {0, 0x000f, 0x8402},	/* Memory bank Address */
+    {0, 0x0000, 0x8403},	/* Memory bank Address */
+    {0, 0x00ba, 0x8804},	/* SSI Slave address */
+    {0, 0x0010, 0x8802},	/* 93.75kHz SSI Clock Two DataByte */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},	/* Will write 2 bytes (DATA1+DATA2) */
+    {0, 0x0020, 0x8801},	/* Register address for SSI read/write */
+    {0, 0x0044, 0x8805},	/* DATA2 */
+    {0, 0x0004, 0x8800},	/* DATA1 -> write triggered */
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0009, 0x8801},
+    {0, 0x0042, 0x8805},
+    {0, 0x0001, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x003c, 0x8801},
+    {0, 0x0001, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0001, 0x8801},
+    {0, 0x000a, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0002, 0x8801},
+    {0, 0x0000, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0003, 0x8801},
+    {0, 0x0027, 0x8805},
+    {0, 0x0001, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0004, 0x8801},
+    {0, 0x0065, 0x8805},
+    {0, 0x0001, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0005, 0x8801},
+    {0, 0x0003, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0006, 0x8801},
+    {0, 0x001c, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0007, 0x8801},
+    {0, 0x002a, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x000e, 0x8801},
+    {0, 0x0000, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0028, 0x8801},
+    {0, 0x002e, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0039, 0x8801},
+    {0, 0x0013, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x003b, 0x8801},
+    {0, 0x000c, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0035, 0x8801},
+    {0, 0x0028, 0x8805},
+    {0, 0x0000, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+    /* READ { 0, 0x0001, 0x8802 } ->
+       0000: 10  */
+    {0, 0x0010, 0x8802},
+    {0, 0x0009, 0x8801},
+    {0, 0x0042, 0x8805},
+    {0, 0x0001, 0x8800},
+    /* READ { 0, 0x0001, 0x8803 } ->
+       0000: 00  */
+
+    {0, 0x0050, 0x8703},
+    {0, 0x0002, 0x8704},	/* External input CKIx1 */
+    {0, 0x0001, 0x870C},	/* Select CKOx2 output */
+    {0, 0x009A, 0x8600},	/* Line memory Read Counter (L) */
+    {0, 0x0001, 0x8606},	/* 1 Line memory Read Counter (H) Result: (d)410 */
+    {0, 0x0023, 0x8601},
+    {0, 0x0010, 0x8602},
+    {0, 0x000A, 0x8603},
+    {0, 0x009A, 0x8600},
+    {0, 0x0001, 0x865B},	/* 1 Horizontal Offset for Valid Pixel(L) */
+    {0, 0x0003, 0x865C},	/* Vertical offset for valid lines (L) */
+    {0, 0x0058, 0x865D},	/* Horizontal valid pixels window (L) */
+    {0, 0x0048, 0x865E},	/* Vertical valid lines window (L) */
+    {0, 0x0000, 0x865F},
+
+    {0, 0x0006, 0x8660},	/* Enable nibble data input, select nibble input order */
+
+    {0, 0x0013, 0x8608},	/* A11 Coeficients for color correction */
+    {0, 0x0028, 0x8609},	/* Note: these values are confirmed at the end of array */
+    {0, 0x0005, 0x860A},	/* ... */
+    {0, 0x0025, 0x860B},
+    {0, 0x00E1, 0x860C},
+    {0, 0x00FA, 0x860D},
+    {0, 0x00F4, 0x860E},
+    {0, 0x00E8, 0x860F},
+    {0, 0x0025, 0x8610},	/* A33 Coef. */
+    {0, 0x00FC, 0x8611},	/* White balance offset: R */
+    {0, 0x0001, 0x8612},	/* White balance offset: Gr */
+    {0, 0x00FE, 0x8613},	/* White balance offset: B */
+    {0, 0x0000, 0x8614},	/* White balance offset: Gb */
+
+    {0, 0x0064, 0x8651},	/* R gain for white balance (L) */
+    {0, 0x0040, 0x8652},	/* Gr gain for white balance (L) */
+    {0, 0x0066, 0x8653},	/* B gain for white balance (L) */
+    {0, 0x0040, 0x8654},	/* Gb gain for white balance (L) */
+    {0, 0x0001, 0x863F},	/* Enable fixed gamma correction */
+
+    {0, 0x00A1, 0x8656},	/* Size - Window1: 256x256, Window2: 128x128 */
+    /* UV division: UV no change, Enable New edge enhancement */
+    {0, 0x0018, 0x8657},	/* Edge gain high threshold */
+    {0, 0x0020, 0x8658},	/* Edge gain low threshold */
+    {0, 0x000A, 0x8659},	/* Edge bandwidth high threshold */
+    {0, 0x0005, 0x865A},	/* Edge bandwidth low threshold */
+    {0, 0x0064, 0x8607},	/* UV filter enable */
+
+    {0, 0x0016, 0x8660},
+    {0, 0x0000, 0x86B0},	/* Bad pixels compensation address */
+    {0, 0x00DC, 0x86B1},	/* X coord for bad pixels compensation (L) */
+    {0, 0x0000, 0x86B2},
+    {0, 0x0009, 0x86B3},	/* Y coord for bad pixels compensation (L) */
+    {0, 0x0000, 0x86B4},
+
+    {0, 0x0001, 0x86B0},
+    {0, 0x00F5, 0x86B1},
+    {0, 0x0000, 0x86B2},
+    {0, 0x00C6, 0x86B3},
+    {0, 0x0000, 0x86B4},
+
+    {0, 0x0002, 0x86B0},
+    {0, 0x001C, 0x86B1},
+    {0, 0x0001, 0x86B2},
+    {0, 0x00D7, 0x86B3},
+    {0, 0x0000, 0x86B4},
+
+    {0, 0x0003, 0x86B0},
+    {0, 0x001C, 0x86B1},
+    {0, 0x0001, 0x86B2},
+    {0, 0x00D8, 0x86B3},
+    {0, 0x0000, 0x86B4},
+
+    {0, 0x0004, 0x86B0},
+    {0, 0x001D, 0x86B1},
+    {0, 0x0001, 0x86B2},
+    {0, 0x00D8, 0x86B3},
+    {0, 0x0000, 0x86B4},
+    {0, 0x001E, 0x8660},
+
+    /* READ { 0, 0x0000, 0x8608 } ->
+       0000: 13  */
+    /* READ { 0, 0x0000, 0x8609 } ->
+       0000: 28  */
+    /* READ { 0, 0x0000, 0x8610 } ->
+       0000: 05  */
+    /* READ { 0, 0x0000, 0x8611 } ->
+       0000: 25  */
+    /* READ { 0, 0x0000, 0x8612 } ->
+       0000: e1  */
+    /* READ { 0, 0x0000, 0x8613 } ->
+       0000: fa  */
+    /* READ { 0, 0x0000, 0x8614 } ->
+       0000: f4  */
+    /* READ { 0, 0x0000, 0x8615 } ->
+       0000: e8  */
+    /* READ { 0, 0x0000, 0x8616 } ->
+       0000: 25  */
+
+    {0, 0, 0}
+};
+ 
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus/spca508_init.h linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca508_init.h
--- linux-2.6.21/drivers/media/video/gspca/Sunplus/spca508_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca508_init.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,237 @@
+/* 
+ * SPCA508 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA508_INIT_H
+#define SPCA508_INIT_H
+
+/* Frame packet header offsets for the spca508 */
+#define SPCA508_OFFSET_TYPE 1
+#define SPCA508_OFFSET_COMPRESS 2
+#define SPCA508_OFFSET_FRAMSEQ 8
+#define SPCA508_OFFSET_WIN1LUM 11
+#define SPCA508_OFFSET_DATA 37
+
+#define SPCA508_SNAPBIT 0x20
+#define SPCA508_SNAPCTRL 0x40
+/*************** I2c ****************/
+#define SPCA508_INDEX_I2C_BASE 0x8800
+
+#include "spca508.dat"
+/*******************     Camera Interface   ***********************/
+static __u16 spca508_getbrightness(struct usb_spca50x *spca50x);
+static __u16 spca508_getcontrast(struct usb_spca50x *spca50x);
+static __u16 spca508_getcolors(struct usb_spca50x *spca50x);
+static void spca508_setbrightness(struct usb_spca50x *spca50x);
+static void spca508_setcontrast(struct usb_spca50x *spca50x);
+static void spca508_setcolors(struct usb_spca50x *spca50x);
+static int spca508_init(struct usb_spca50x *spca50x);
+static void spca508_start(struct usb_spca50x *spca50x);
+static void spca508_stopN(struct usb_spca50x *spca50x);
+static void spca508_stop0(struct usb_spca50x *spca50x);
+static int spca508_config(struct usb_spca50x *spca50x);
+static void spca508_shutdown(struct usb_spca50x *spca50x);
+static void spca508_setAutobright(struct usb_spca50x *spca50x);
+static void spca508_setquality(struct usb_spca50x *spca50x);
+static int spca508_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum,int *datalength);
+/******************************************************************/
+static void spca508_stop0(struct usb_spca50x *spca50x){}
+static void spca508_shutdown(struct usb_spca50x *spca50x){}
+static void spca508_setAutobright(struct usb_spca50x *spca50x){}
+static void spca508_setquality(struct usb_spca50x *spca50x){}
+static void spca508_setcontrast(struct usb_spca50x *spca50x){}
+static void spca508_setcolors(struct usb_spca50x *spca50x){}
+/*****************************************************************/
+static struct cam_operation fspca508 = {
+ 	.initialize = spca508_init,
+	.configure = spca508_config,
+	.start = spca508_start,
+	.stopN = spca508_stopN,
+	.stop0 = spca508_stop0,
+	.get_bright = spca508_getbrightness,
+	.set_bright = spca508_setbrightness,
+	.get_contrast = spca508_getcontrast,
+	.set_contrast = spca508_setcontrast,
+	.get_colors = spca508_getcolors,
+	.set_colors = spca508_setcolors,
+	.set_autobright = spca508_setAutobright,
+	.set_quality = spca508_setquality,
+	.cam_shutdown = spca508_shutdown,
+	.sof_detect = spca508_sofdetect,
+ };
+static __u16 spca508_getbrightness(struct usb_spca50x *spca50x)
+{
+__u8 brightness;
+brightness = spca50x_reg_read(spca50x->dev, 0, 0x8651, 1);
+	spca50x->brightness = brightness << 8;
+return spca50x->brightness;
+}
+static __u16 spca508_getcontrast(struct usb_spca50x *spca50x)
+{
+return spca50x->contrast;
+}
+static __u16 spca508_getcolors(struct usb_spca50x *spca50x)
+{
+return spca50x->colour;
+}
+static void spca508_setbrightness(struct usb_spca50x *spca50x)
+{
+__u8 brightness = spca50x->brightness >> 8;
+/* MX seem contrast */
+            spca50x_reg_write(spca50x->dev, 0, 0x8651, brightness);
+	    spca50x_reg_write(spca50x->dev, 0, 0x8652, brightness);
+	    spca50x_reg_write(spca50x->dev, 0, 0x8653, brightness);
+	    spca50x_reg_write(spca50x->dev, 0, 0x8654, brightness);
+}
+
+static int spca508_init(struct usb_spca50x *spca50x)
+{
+      spca50x_write_vector(spca50x, spca508_open_data);
+      return 0;
+}
+static void spca508_start(struct usb_spca50x *spca50x)
+{
+int err_code = 0;
+        spca50x_reg_write(spca50x->dev, 0, 0x8500, spca50x->mode);	// mode
+	switch (spca50x->mode){
+	case 0:
+	case 1:
+	spca50x_reg_write(spca50x->dev, 0, 0x8700, 0x28);	// clock
+	break;
+	case 2:
+	case 3:
+	spca50x_reg_write(spca50x->dev, 0, 0x8700, 0x23);	// clock
+	break;
+	default:
+	spca50x_reg_write(spca50x->dev, 0, 0x8700, 0x28);	// clock
+	break;
+	}
+    err_code = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x10 | 0x20);
+}
+static void spca508_stopN(struct usb_spca50x *spca50x)
+{
+ // Video ISO disable, Video Drop Packet enable:
+	    spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x20);
+}
+
+static int spca508_config(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    int data1, data2;
+
+    // Read frm global register the USB product and vendor IDs, just to
+    // prove that we can communicate with the device.  This works, which
+    // confirms at we are communicating properly and that the device
+    // is a 508.
+    data1 = spca50x_reg_read(dev, 0, 0x8104, 1);
+    if (data1 < 0)
+	PDEBUG(1, "Error reading USB Vendor ID from Global register");
+    data2 = spca50x_reg_read(dev, 0, 0x8105, 1);
+    if (data2 < 0)
+	PDEBUG(1, "Error reading USB Vendor ID from Global register");
+    PDEBUG(1, "Read from GLOBAL: USB Vendor ID 0x%02x%02x", data2, data1);
+
+    data1 = spca50x_reg_read(dev, 0, 0x8106, 1);
+    if (data1 < 0)
+	PDEBUG(1, "Error reading USB Product ID from Global register");
+    data2 = spca50x_reg_read(dev, 0, 0x8107, 1);
+    if (data2 < 0)
+	PDEBUG(1, "Error reading USB Product ID from Global register");
+    PDEBUG(1, "Read from GLOBAL: USB Product ID 0x%02x%02x", data2, data1);
+
+    data1 = spca50x_reg_read(dev, 0, 0x8621, 1);
+    if (data1 < 0)
+	PDEBUG(1,
+	       "Error reading Window 1 Average Luminance from Global register");
+    PDEBUG(1, "Read from GLOBAL: Window 1 average luminance %3d", data1);
+   
+       memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 0;
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 1;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 1;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 2;
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 1023;
+    spca50x->mode_cam[QCIF].method = 0;
+    spca50x->mode_cam[QCIF].mode = 3;
+    
+       switch (spca50x->desc) {
+    case ViewQuestVQ110:
+	{
+	    if (spca50x_write_vector(spca50x, spca508_init_data))
+		return -1;
+	    break;
+	}
+    case MicroInnovationIC200:
+    case IntelEasyPCCamera:
+	{
+	    if (spca50x_write_vector(spca50x, spca508cs110_init_data))
+		return -1;
+	    break;
+	}
+    case HamaUSBSightcam:
+	{
+	    if (spca50x_write_vector(spca50x, spca508_sightcam_init_data))
+		return -1;
+	    break;
+	}
+    case HamaUSBSightcam2:
+	{
+	    if (spca50x_write_vector(spca50x, spca508_sightcam2_init_data))
+		return -1;
+	    break;
+	}
+    case CreativeVista:
+	{
+	    if (spca50x_write_vector(spca50x, spca508_vista_init_data))
+		return -1;
+	    break;
+	}
+    default:
+	return -1;
+    }
+    return 0;			// success     
+}
+static int spca508_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum,int *datalength)
+{
+           switch (cdata[0]){
+	   case 0:
+	        *iPix = SPCA508_OFFSET_DATA;
+		*datalength -= *iPix;
+	   	return 0;
+	   case SPCA50X_SEQUENCE_DROP:
+	   	return -1;
+	   default:
+	   	*iPix = 1;
+		*datalength -= *iPix;
+	   	return seqnum+1 ;
+           }
+}
+#endif				/* SPCA508_INIT_H */
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus/spca561.h linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca561.h
--- linux-2.6.21/drivers/media/video/gspca/Sunplus/spca561.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus/spca561.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,895 @@
+
+#ifndef SPCA561_INIT_H
+#define SPCA561_INIT_H
+
+/****************************************************************************
+#	 	Sunplus spca561 library                                     #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+/* Initialization data
+   I'm not very sure how to split initialization from open data
+   chunks. For now, we'll consider everything as initialization
+ */
+/* Frame packet header offsets for the spca561 */
+#define SPCA561_OFFSET_SNAP 1
+#define SPCA561_OFFSET_TYPE 2
+#define SPCA561_OFFSET_COMPRESS 3
+#define SPCA561_OFFSET_FRAMSEQ   4
+#define SPCA561_OFFSET_GPIO 5
+#define SPCA561_OFFSET_USBBUFF 6
+#define SPCA561_OFFSET_WIN2GRAVE 7
+#define SPCA561_OFFSET_WIN2RAVE 8
+#define SPCA561_OFFSET_WIN2BAVE 9
+#define SPCA561_OFFSET_WIN2GBAVE 10
+#define SPCA561_OFFSET_WIN1GRAVE 11
+#define SPCA561_OFFSET_WIN1RAVE 12
+#define SPCA561_OFFSET_WIN1BAVE 13
+#define SPCA561_OFFSET_WIN1GBAVE 14
+#define SPCA561_OFFSET_FREQ 15
+#define SPCA561_OFFSET_VSYNC 16
+#define SPCA561_OFFSET_DATA 1
+#define SPCA561_INDEX_I2C_BASE 0x8800
+#define SPCA561_SNAPBIT 0x20
+#define SPCA561_SNAPCTRL 0x40
+enum {
+    Rev072A = 0,
+    Rev012A,
+};
+/*******************     Camera Interface   ***********************/
+static int spca561_init(struct usb_spca50x *spca50x);
+static void spca561_start(struct usb_spca50x *spca50x);
+static void spca561_stopN(struct usb_spca50x *spca50x);
+static void spca561_stop0(struct usb_spca50x *spca50x);
+static void spca561_setbrightness(struct usb_spca50x *spca50x);
+static __u16 spca561_getbrightness(struct usb_spca50x *spca50x);
+static void spca561_setcontrast(struct usb_spca50x *spca50x);
+static __u16 spca561_getcontrast(struct usb_spca50x *spca50x);
+static void spca561_setcolors(struct usb_spca50x *spca50x);
+static __u16 spca561_getcolors(struct usb_spca50x *spca50x);
+static void spca561_setAutobright(struct usb_spca50x *spca50x);
+static int spca561_config(struct usb_spca50x *spca50x);
+static void spca561_shutdown(struct usb_spca50x *spca50x);
+static void spca561_setquality(struct usb_spca50x *spca50x);
+static int spca561_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/******************************************************************/
+static void spca561_setcolors(struct usb_spca50x *spca50x){}
+static __u16 spca561_getcolors(struct usb_spca50x *spca50x){return 0;}
+static void spca561_setquality(struct usb_spca50x *spca50x){}
+static void spca561_stop0(struct usb_spca50x *spca50x){}
+//static __u16 spca561_setexposure(struct usb_spca50x *spca50x);
+//static __u16 spca561_getexposure(struct usb_spca50x *spca50x);
+/*****************************************************************/
+static struct cam_operation fspca561 = {
+ 	.initialize = spca561_init,
+	.configure = spca561_config,
+	.start = spca561_start,
+	.stopN = spca561_stopN,
+	.stop0 = spca561_stop0,
+	.get_bright = spca561_getbrightness,
+	.set_bright = spca561_setbrightness,
+	.get_contrast = spca561_getcontrast,
+	.set_contrast = spca561_setcontrast,
+	.get_colors = spca561_getcolors,
+	.set_colors = spca561_setcolors,
+	.set_autobright = spca561_setAutobright,
+	.set_quality = spca561_setquality,
+	.cam_shutdown = spca561_shutdown,
+	.sof_detect = spca561_sofdetect,
+ };
+static void spca561_InitI2c(struct usb_spca50x *spca50x, __u8 mode)
+{
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x92, 0x8804, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x00, mode, 0x8802, NULL, 0);
+}
+
+static void spca561_WriteI2c(struct usb_spca50x *spca50x, __u16 valeur,
+			     __u16 registre)
+{
+    int retry = 60;
+    __u8 DataLow = 0;
+    __u8 DataHight = 0;
+    __u8 Data = 0;
+    DataLow = valeur & 0xFF;
+    DataHight = (valeur >> 8) & 0xFF;
+    spca5xxRegWrite(spca50x->dev, 0x00, registre, 0x8801, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x00, DataLow, 0x8805, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x00, DataHight, 0x8800, NULL, 0);
+    while (retry--) {
+	spca5xxRegRead(spca50x->dev, 0x00, 0, 0x8803, &Data, 1);
+	if (!Data)
+	    break;
+    }
+}
+
+/****************** not in use **********************************/
+static int spca561_ReadI2c(struct usb_spca50x *spca50x, __u16 registre,
+			   __u8 mode)
+{
+    int retry = 60;
+
+    unsigned char value = 0;
+    unsigned char vallsb = 0;
+    __u8 Data = 0;
+    spca5xxRegWrite(spca50x->dev, 0x00, 0x92, 0x8804, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x00, registre, 0x8801, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0x00, (mode | 0x01), 0x8802, NULL, 0);
+    while (retry--) {
+	spca5xxRegRead(spca50x->dev, 0x00, 0, 0x8803, &Data, 1);
+	if (!Data)
+	    break;
+    }
+    if (retry == 0)
+	return -1;
+    spca5xxRegRead(spca50x->dev, 0x00, 0, 0x8800, &value, 1);
+    spca5xxRegRead(spca50x->dev, 0x00, 0, 0x8805, &vallsb, 1);
+    return (int) value << 8 | vallsb;
+}
+
+static __u16 spca561_init_data[][3] = {
+    {0, 0x0000, 0x8114},	// Software GPIO output data
+    {0, 0x0001, 0x8114},	// Software GPIO output data
+    {0, 0x0000, 0x8112},	// Some kind of reset
+    {0, 0x0003, 0x8701},	// PCLK clock delay adjustment
+    {0, 0x0001, 0x8703},	// HSYNC from cmos inverted
+    {0, 0x0011, 0x8118},	// Enable and conf sensor
+    {0, 0x0001, 0x8118},	// Conf sensor
+    {0, 0x0092, 0x8804},	// I know nothing about these
+    {0, 0x0010, 0x8802},	// 0x88xx registers, so I won't
+	/*********************/
+    {0, 0x000d, 0x8805},	// sensor default setting
+    {0, 0x0001, 0x8801},	// 1 <- 0x0d
+    {0, 0x0000, 0x8800},
+    {0, 0x0018, 0x8805},
+    {0, 0x0002, 0x8801},	// 2 <- 0x18
+    {0, 0x0000, 0x8800},
+    {0, 0x0065, 0x8805},
+    {0, 0x0004, 0x8801},	// 4 <- 0x01 0x65
+    {0, 0x0001, 0x8800},
+    {0, 0x0021, 0x8805},
+    {0, 0x0005, 0x8801},	// 5 <- 0x21
+    {0, 0x0000, 0x8800},
+    {0, 0x00aa, 0x8805},
+    {0, 0x0007, 0x8801},	// 7 <- 0xaa
+    {0, 0x0000, 0x8800},
+    {0, 0x0004, 0x8805},
+    {0, 0x0020, 0x8801},	// 0x20 <- 0x15 0x04
+    {0, 0x0015, 0x8800},
+    {0, 0x0002, 0x8805},
+    {0, 0x0039, 0x8801},	// 0x39 <- 0x02
+    {0, 0x0000, 0x8800},
+    {0, 0x0010, 0x8805},
+    {0, 0x0035, 0x8801},	// 0x35 <- 0x10
+    {0, 0x0000, 0x8800},
+    {0, 0x0049, 0x8805},
+    {0, 0x0009, 0x8801},	// 0x09 <- 0x10 0x49
+    {0, 0x0010, 0x8800},
+    {0, 0x000b, 0x8805},
+    {0, 0x0028, 0x8801},	// 0x28 <- 0x0b
+    {0, 0x0000, 0x8800},
+    {0, 0x000f, 0x8805},
+    {0, 0x003b, 0x8801},	// 0x3b <- 0x0f
+    {0, 0x0000, 0x8800},
+    {0, 0x0000, 0x8805},
+    {0, 0x003c, 0x8801},	// 0x3c <- 0x00
+    {0, 0x0000, 0x8800},
+	/**********************/
+    {0, 0x0018, 0x8601},	// Pixel/line selection for color separation
+    {0, 0x0000, 0x8602},	// Optical black level for user setting
+    {0, 0x0060, 0x8604},	// Optical black horizontal offset
+    {0, 0x0002, 0x8605},	// Optical black vertical offset
+    {0, 0x0000, 0x8603},	// Non-automatic optical black level
+    {0, 0x0002, 0x865b},	// Horizontal offset for valid pixels
+    {0, 0x0000, 0x865f},	// Vertical valid pixels window (x2)
+    {0, 0x00b0, 0x865d},	// Horizontal valid pixels window (x2)
+    {0, 0x0090, 0x865e},	// Vertical valid lines window (x2)
+    {0, 0x00e0, 0x8406},	// Memory buffer threshold
+    {0, 0x0000, 0x8660},	// Compensation memory stuff
+    {0, 0x0002, 0x8201},	// Output address for r/w serial EEPROM
+    {0, 0x0008, 0x8200},	// Clear valid bit for serial EEPROM
+    {0, 0x0001, 0x8200},	// OprMode to be executed by hardware
+    {0, 0x0007, 0x8201},	// Output address for r/w serial EEPROM
+    {0, 0x0008, 0x8200},	// Clear valid bit for serial EEPROM
+    {0, 0x0001, 0x8200},	// OprMode to be executed by hardware
+    {0, 0x0010, 0x8660},	// Compensation memory stuff
+    {0, 0x0018, 0x8660},	// Compensation memory stuff
+
+    {0, 0x0004, 0x8611},	// R offset for white balance
+    {0, 0x0004, 0x8612},	// Gr offset for white balance
+    {0, 0x0007, 0x8613},	// B offset for white balance
+    {0, 0x0000, 0x8614},	// Gb offset for white balance
+    {0, 0x008c, 0x8651},	// R gain for white balance
+    {0, 0x008c, 0x8652},	// Gr gain for white balance
+    {0, 0x00b5, 0x8653},	// B gain for white balance
+    {0, 0x008c, 0x8654},	// Gb gain for white balance
+    {0, 0x0002, 0x8502},	// Maximum average bit rate stuff
+
+
+    {0, 0x0011, 0x8802},
+    {0, 0x0087, 0x8700},	// Set master clock (96Mhz????)
+    {0, 0x0081, 0x8702},	// Master clock output enable
+
+    {0, 0x0000, 0x8500},	// Set image type (352x288 no compression)
+    // Originally was 0x0010 (352x288 compression)
+
+    {0, 0x0002, 0x865b},	// Horizontal offset for valid pixels
+    {0, 0x0003, 0x865c},	// Vertical offset for valid lines
+    /*************************/// sensor active
+    {0, 0x0003, 0x8801},	// 0x03 <- 0x01 0x21 //289
+    {0, 0x0021, 0x8805},
+    {0, 0x0001, 0x8800},
+    {0, 0x0004, 0x8801},	// 0x04 <- 0x01 0x65 //357
+    {0, 0x0065, 0x8805},
+    {0, 0x0001, 0x8800},
+    {0, 0x0005, 0x8801},	// 0x05 <- 0x2f
+    {0, 0x002f, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0006, 0x8801},	// 0x06 <- 0
+    {0, 0x0000, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x000a, 0x8801},	// 0x0a <- 2
+    {0, 0x0002, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0009, 0x8801},	// 0x09 <- 0x1061
+    {0, 0x0061, 0x8805},
+    {0, 0x0010, 0x8800},
+    {0, 0x0035, 0x8801},	// 0x35 <-0x14
+    {0, 0x0014, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0030, 0x8112},	// ISO and drop packet enable
+    {0, 0x0000, 0x8112},	// Some kind of reset ????
+    {0, 0x0009, 0x8118},	// Enable sensor and set standby
+    {0, 0x0000, 0x8114},	// Software GPIO output data
+    {0, 0x0000, 0x8114},	// Software GPIO output data
+    {0, 0x0001, 0x8114},	// Software GPIO output data
+    {0, 0x0000, 0x8112},	// Some kind of reset ???
+    {0, 0x0003, 0x8701},
+    {0, 0x0001, 0x8703},
+    {0, 0x0011, 0x8118},
+    {0, 0x0001, 0x8118},
+	/**************************/
+
+    {0, 0x0092, 0x8804},
+    {0, 0x0010, 0x8802},
+    {0, 0x000d, 0x8805},
+    {0, 0x0001, 0x8801},
+    {0, 0x0000, 0x8800},
+    {0, 0x0018, 0x8805},
+    {0, 0x0002, 0x8801},
+    {0, 0x0000, 0x8800},
+    {0, 0x0065, 0x8805},
+    {0, 0x0004, 0x8801},
+    {0, 0x0001, 0x8800},
+    {0, 0x0021, 0x8805},
+    {0, 0x0005, 0x8801},
+    {0, 0x0000, 0x8800},
+    {0, 0x00aa, 0x8805},
+    {0, 0x0007, 0x8801},	// mode 0xaa
+    {0, 0x0000, 0x8800},
+    {0, 0x0004, 0x8805},
+    {0, 0x0020, 0x8801},
+    {0, 0x0015, 0x8800},	//mode 0x0415
+    {0, 0x0002, 0x8805},
+    {0, 0x0039, 0x8801},
+    {0, 0x0000, 0x8800},
+    {0, 0x0010, 0x8805},
+    {0, 0x0035, 0x8801},
+    {0, 0x0000, 0x8800},
+    {0, 0x0049, 0x8805},
+    {0, 0x0009, 0x8801},
+    {0, 0x0010, 0x8800},
+    {0, 0x000b, 0x8805},
+    {0, 0x0028, 0x8801},
+    {0, 0x0000, 0x8800},
+    {0, 0x000f, 0x8805},
+    {0, 0x003b, 0x8801},
+    {0, 0x0000, 0x8800},
+    {0, 0x0000, 0x8805},
+    {0, 0x003c, 0x8801},
+    {0, 0x0000, 0x8800},
+    {0, 0x0002, 0x8502},
+    {0, 0x0039, 0x8801},
+    {0, 0x0000, 0x8805},
+    {0, 0x0000, 0x8800},
+
+    {0, 0x0087, 0x8700},	//overwrite by start
+    {0, 0x0081, 0x8702},
+    {0, 0x0000, 0x8500},
+//      { 0 , 0x0010 , 0x8500 },  -- Previous line was this
+    {0, 0x0002, 0x865b},
+    {0, 0x0003, 0x865c},
+	/************************/
+    {0, 0x0003, 0x8801},	// 0x121-> 289
+    {0, 0x0021, 0x8805},
+    {0, 0x0001, 0x8800},
+    {0, 0x0004, 0x8801},	//0x165 -> 357
+    {0, 0x0065, 0x8805},
+    {0, 0x0001, 0x8800},
+    {0, 0x0005, 0x8801},	//0x2f //blanking control colonne
+    {0, 0x002f, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0006, 0x8801},	//0x00 //blanking mode row
+    {0, 0x0000, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x000a, 0x8801},	//0x01 //0x02
+    {0, 0x0001, 0x8805},
+    {0, 0x0000, 0x8800},
+    {0, 0x0009, 0x8801},	// 0x1061 // setexposure times && pixel clock 0001 0 | 000 0110 0001
+    {0, 0x0061, 0x8805},	//61 31
+    {0, 0x0008, 0x8800},	// 08
+    {0, 0x0035, 0x8801},	// 0x14 // set gain general
+    {0, 0x001F, 0x8805},	//0x14
+    {0, 0x0000, 0x8800},
+    {0, 0x0030, 0x8112},
+    {0, 0, 0}
+};
+
+
+static void sensor_Reset(struct usb_spca50x *spca50x)
+{
+    int err;
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8631, 0xC8);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8634, 0xC8);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x00);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8114, 0x00);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8118, 0x21);
+    spca561_InitI2c(spca50x, 0x14);
+    spca561_WriteI2c(spca50x, 1, 0x0d);
+    spca561_WriteI2c(spca50x, 0, 0x0d);
+}
+
+/************************* QC Express etch2 stuff ********************/
+static __u16 Pb100_1map8300[][2] = {
+/* reg, value */
+    {0x8320, 0x3304},
+    {0x8303, 0x0125},
+    {0x8304, 0x0169},
+    {0x8328, 0x000b},
+    {0x833c, 0x0007},
+    {0x832f, 0x0f00},		//419
+    {0x8307, 0x00aa},
+    {0x8339, 0x0000},
+    {0x8335, 0x0018},
+    {0x8309, 0x2048},
+    {0x8301, 0x000d},		//3
+    {0x8302, 0x0018},		//e
+    {0, 0}
+};
+static __u16 Pb100_2map8300[][2] = {
+/* reg, value */
+    {0x8339, 0x0000},
+    {0x8307, 0x00aa},
+    {0, 0}
+};
+
+static __u16 spca561_161rev12A_data1[][3] = {
+    {0x00, 0x21, 0x8118},	//0x29 enable sensor
+    {0x00, 0x01, 0x8114},
+    {0x00, 0x00, 0x8112},
+    {0x00, 0x92, 0x8804},
+    {0x00, 0x04, 0x8802},
+};
+static __u16 spca561_161rev12A_data2[][3] = {
+    {0x00, 0x21, 0x8118},
+    //{ 0x00, 0x04, 0x8501 },
+    //
+    {0x00, 0x00, 0x8114},
+    {0x00, 0x01, 0x8114},	//
+    {0x00, 0x90, 0x8604},
+    {0x00, 0x00, 0x8605},
+    {0x00, 0xb0, 0x8603},	//b0 00
+    {0x00, 0x02, 0x8201},
+    {0x00, 0x08, 0x8200},
+    {0x00, 0x01, 0x8200},
+    {0x00, 0x07, 0x8201},
+    {0x00, 0x08, 0x8200},
+    {0x00, 0x01, 0x8200},
+    {0x00, 0x08, 0x8620},
+    {0x00, 0x0C, 0x8620},
+    {0x00, 0x00, 0x8610},	// *rouge
+    {0x00, 0x00, 0x8611},	//3f   *vert 
+    {0x00, 0x00, 0x8612},	// vert *bleu
+    {0x00, 0x00, 0x8613},	//bleu  *vert
+    {0x00, 0x35, 0x8614},	// vert *rouge
+    {0x00, 0x35, 0x8615},	//40   *vert
+    {0x00, 0x35, 0x8616},	//7a   *bleu
+    {0x00, 0x35, 0x8617},	//40 *vert
+
+    {0x00, 0xf0, 0x8505},
+    {0x00, 0x32, 0x850a},
+    {0x00, 0x10, 0x8500},	//11 
+    {0x00, 0x07, 0x8601},	//7 18
+    {0x00, 0x07, 0x8602},	//7 00
+    {0x00, 0x0c, 0x8620},	//0c
+
+    {0x00, 0x7a, 0x8616},	//7a no comments
+    {0x00, 0x40, 0x8617},	//40
+    {0x00, 0xc8, 0x8631},	//c8
+    {0x00, 0xc8, 0x8634},	//c8
+    {0x00, 0x23, 0x8635},	//23
+    {0x00, 0x1f, 0x8636},	//1f
+    {0x00, 0xdd, 0x8637},	//dd
+    {0x00, 0xe1, 0x8638},	//e1
+    {0x00, 0x1d, 0x8639},	//1d
+    {0x00, 0x21, 0x863a},	//21
+    {0x00, 0xe3, 0x863b},	//e3
+    {0x00, 0xdf, 0x863c},	//df
+
+
+    {0, 0, 0}
+};
+
+static void sensor_mapwrite(struct usb_spca50x *spca50x,
+			    __u16 sensormap[][2])
+{
+    int i = 0;
+    __u8 usbval[] = { 0, 0 };
+
+    while (sensormap[i][0]) {
+	usbval[0] = sensormap[i][1] & 0xff;
+	usbval[1] = (sensormap[i][1] >> 8) & 0xff;
+	spca5xxRegWrite(spca50x->dev, 0x00, 0x00, sensormap[i][0], usbval,
+			2);
+	i++;
+    }
+}
+static int init_161rev12A(struct usb_spca50x *spca50x)
+{
+    int err;
+    __u8 Reg8391[] = { 0x23, 0x31, 0x10, 0x00, 0x3a, 0x00, 0x00, 0x00 };	//14
+    __u8 Reg8307[] = { 0xaa, 0x00 };
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8620, 0x00);	//
+    sensor_Reset(spca50x);
+    spca50x_write_vector(spca50x, spca561_161rev12A_data1);
+    sensor_mapwrite(spca50x, Pb100_1map8300);
+    spca50x_write_vector(spca50x, spca561_161rev12A_data2);
+    sensor_mapwrite(spca50x, Pb100_2map8300);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8700, 0x85);	// 0x27 clock
+    spca5xxRegWrite(spca50x->dev, 0, 0, 0x8391, Reg8391, 8);
+    spca5xxRegWrite(spca50x->dev, 0, 0, 0x8390, Reg8391, 8);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x10 | 0x20);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x850b, 0x03);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x00);
+
+//set_alternate setting 0
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8118, 0x29);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8114, 0x00);
+//set_alternate setting 7
+
+    spca50x_write_vector(spca50x, spca561_161rev12A_data2);
+    spca5xxRegWrite(spca50x->dev, 0, 0, 0x8307, Reg8307, 2);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8700, 0x85);	// 0x27 clock
+    spca5xxRegWrite(spca50x->dev, 0, 0, 0x8391, Reg8391, 8);
+    spca5xxRegWrite(spca50x->dev, 0, 0, 0x8390, Reg8391, 8);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x10 | 0x20);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x850b, 0x03);
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x20);	//
+    return 0;
+
+}
+
+/************************* End spca561rev12A stuff **********************/
+/************************* Core spca561 stuff ************************/
+static int spca561_init(struct usb_spca50x *spca50x)
+{
+    int err;
+
+    switch (spca50x->chip_revision) {
+    case Rev072A:
+	PDEBUG(0, "Find spca561 USB Product ID %x", spca50x->customid);
+	spca50x_write_vector(spca50x, spca561_init_data);
+	break;
+    case Rev012A:
+	PDEBUG(0, "Find spca561 USB Product ID %x", spca50x->customid);
+	err = init_161rev12A(spca50x);
+	break;
+    default:
+	PDEBUG(0, "Error reading USB Product ID from Global register");
+	break;
+    }
+    return 0;
+}
+
+#if 0
+static void spca561_dumpSensor(struct usb_spca50x *spca50x)
+{
+    int i;
+    __u8 RegSens[] = { 0, 0 };
+    switch (spca50x->chip_revision) {
+    case Rev072A:
+	/*dump sensor registers */
+	for (i = 0; i < 0x36; i++) {
+	    /* mode 0x10 561, 0x14 mapped */
+	    err = spca561_ReadI2c(spca50x, i, 0x10);
+	    PDEBUG(0, "reading Sensor i2c register 0x%02X -> 0x%04X", i,
+		   err);
+	}
+	break;
+    case Rev012A:
+	/* Sensor mapped registers */
+	for (i = 0; i < 0x36; i++) {
+	    spca5xxRegRead(spca50x->dev, 0, 0, 0x8300 + i, RegSens, 2);
+	    PDEBUG(0, "reading Sensor map0x8300 register 0x%02X -> 0x%04X",
+		   i, RegSens[1] << 8 | RegSens[0]);
+	}
+	break;
+    }
+}
+#endif
+static void spca561_start(struct usb_spca50x *spca50x)
+{
+    int err;
+    int Clck = 0;
+    __u8 Reg8307[] = { 0xaa, 0x00 };
+    __u8 Reg8391[] = { 0x90, 0x31, 0x0b, 0x00, 0x25, 0x00, 0x00, 0x00 };	//90 31 0c 
+    switch (spca50x->chip_revision) {
+    case Rev072A:
+	switch (spca50x->mode) {
+	case 0:
+	case 1:
+	    Clck = 0x25;
+	    break;
+	case 2:
+	    Clck = 0x22;
+	    break;
+	case 3:
+	    Clck = 0x21;
+	    break;
+	default:
+	    Clck = 0x25;
+	    break;
+	}
+	err = spca50x_reg_write(spca50x->dev, 0, 0x8500, spca50x->mode);	// mode
+	err = spca50x_reg_write(spca50x->dev, 0, 0x8700, Clck);	// 0x27 clock
+	err = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x10 | 0x20);
+
+	break;
+    case Rev012A:
+
+	switch (spca50x->mode) {
+	case 0:
+	    //Clck =(spca50x->customid == 0x403b) ? 0x8a : 0x8f;
+	    Clck = 0x8a;
+	    break;
+	case 1:
+	    Clck = 0x8a;
+	    break;
+	case 2:
+	    Clck = 0x85;
+	    Reg8391[1] = 0x22;	// increase pixel clock increase time exposure
+	    break;
+	case 3:
+	    Clck = 0x83;
+	    Reg8391[1] = 0x22;
+	    break;
+	default:
+	    Clck = 0x25;
+	    break;
+	}
+	if (compress && spca50x->mode <= 1) {
+	    // this is correct for 320x240; it also works at 352x288
+	    // hell, I don't even know what this value means :)
+	    Clck = 0x83;
+	    err =
+		spca50x_reg_write(spca50x->dev, 0, 0x8500,
+				  0x10 + spca50x->mode);
+	} else {
+	    // I couldn't get the compression to work below 320x240
+	    // Fortunately at these resolutions the bandwidth is sufficient
+	    // to push raw frames at ~20fps
+	    err =
+		spca50x_reg_write(spca50x->dev, 0, 0x8500, spca50x->mode);
+
+	}			// -- qq@kuku.eu.org
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x8307, Reg8307, 2);
+	err = spca50x_reg_write(spca50x->dev, 0, 0x8700, Clck);	// 0x8f 0x85 0x27 clock
+
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x8391, Reg8391, 8);
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x8390, Reg8391, 8);
+	spca50x->exposure = ((Reg8391[1]) << 8) | Reg8391[0];	//set exposure with clock 
+	err = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x10 | 0x20);
+
+	err = spca50x_reg_write(spca50x->dev, 0, 0x850b, 0x03);
+
+	spca561_setcontrast(spca50x);
+
+	break;
+    default:
+	PDEBUG(0, "Error reading USB Product ID from Global register");
+	break;
+    }
+
+}
+
+static void spca561_stopN(struct usb_spca50x *spca50x)
+{
+    int err;
+    err = spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x20);	//
+}
+static void spca561_setbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 value = 0;
+    value = spca50x->brightness >> 9;
+    switch (spca50x->chip_revision) {
+    case Rev072A:
+	spca5xxRegWrite(spca50x->dev, 0, value, 0x8611, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, value, 0x8612, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, value, 0x8613, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, value, 0x8614, NULL, 0);
+	break;
+    case Rev012A:
+	spca5xxRegWrite(spca50x->dev, 0, value, 0x8615, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, value, 0x8614, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, value, 0x8616, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, value, 0x8617, NULL, 0);
+	break;
+    }
+}
+static __u16 spca561_getbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 value = 0;
+    __u16 tot = 0;
+    switch (spca50x->chip_revision) {
+    case Rev072A:
+
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8611, &value, 1);
+	tot += value;
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8612, &value, 1);
+	tot += value;
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8613, &value, 1);
+	tot += value;
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8614, &value, 1);
+	tot += value;
+	spca50x->brightness = tot << 7;
+	break;
+    case Rev012A:
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8615, &value, 1);
+	spca50x->brightness = value << 9;
+	break;
+    }
+
+    return spca50x->brightness;
+}
+static void spca561_setcontrast(struct usb_spca50x *spca50x)
+{
+
+    __u8 lowb = 0;
+    int expotimes = 0;
+    int pixelclk = 0;
+    __u8 Reg8391[] = { 0x90, 0x31, 0x0b, 0x00, 0x25, 0x00, 0x00, 0x00 };
+    switch (spca50x->chip_revision) {
+    case Rev072A:
+	lowb = (spca50x->contrast >> 8) & 0xFF;
+	spca5xxRegWrite(spca50x->dev, 0, lowb, 0x8651, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, lowb, 0x8652, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, lowb, 0x8653, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, lowb, 0x8654, NULL, 0);
+	break;
+    case Rev012A:
+	lowb = (spca50x->contrast >> 10) & 0x7F;
+	if (lowb < 4)
+	    lowb = 3;
+	pixelclk = spca50x->exposure & 0xf800;
+	spca50x->exposure = ((spca50x->contrast >> 5) & 0x07ff) | pixelclk;
+	expotimes = spca50x->exposure & 0x07ff;
+	Reg8391[0] = expotimes & 0xff;
+	Reg8391[1] = ((pixelclk >> 8) & 0xf8) | ((expotimes >> 8) & 0x07);
+	Reg8391[2] = lowb;
+	PDEBUG(4, "Set Exposure 0x%02x 0x%02x gain 0x%02x", Reg8391[0],
+	       Reg8391[1], Reg8391[2]);
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x8390, Reg8391, 8);
+	break;
+    }
+
+}
+static __u16 spca561_getcontrast(struct usb_spca50x *spca50x)
+{
+    __u8 value = 0;
+    __u16 tot = 0;
+    __u8 contrast = 0x0b;
+    __u8 RegSens[] = { 0, 0 };
+    switch (spca50x->chip_revision) {
+    case Rev072A:
+
+	value = 0;
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8651, &value, 1);
+	tot += value;
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8652, &value, 1);
+	tot += value;
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8653, &value, 1);
+	tot += value;
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8654, &value, 1);
+	tot += value;
+	spca50x->contrast = tot << 6;
+	break;
+    case Rev012A:
+
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x8335, &contrast, 1);
+	/* always 0x8335 return 0 */
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8335, RegSens, 2);
+	spca50x->contrast = (contrast & 0x7f) << 10;
+	PDEBUG(2, "Get constrast 0x8335 0x%04x",
+	       RegSens[1] << 8 | RegSens[0]);
+	break;
+    }
+    PDEBUG(4,"get contrast %d\n",spca50x->contrast);
+    return spca50x->contrast;
+}
+static int spca561_config(struct usb_spca50x *spca50x)
+{
+    __u8 data1, data2;
+    // Read frm global register the USB product and vendor IDs, just to     
+    // prove that we can communicate with the device.  This works, which
+    // confirms at we are communicating properly and that the device
+    // is a 561.
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x8104, &data1, 1);
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x8105, &data2, 1);
+    PDEBUG(1, "Read from GLOBAL: USB Vendor ID 0x%02x%02x", data2, data1);
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x8106, &data1, 1);
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x8107, &data2, 1);
+    PDEBUG(1, "Read from GLOBAL: USB Product ID 0x%02x%02x", data2, data1);
+    spca50x->customid = ((data2 << 8) | data1) & 0xffff;
+    switch (spca50x->customid) {
+    case 0x7004:
+    case 0xa001:
+    case 0x0815:
+    case 0x0561:
+    case 0xcdee:
+    case 0x7e50:
+    case 0x401a:
+	spca50x->chip_revision = Rev072A;
+	break;
+    case 0x0928:
+    case 0x0929:
+    case 0x092a:
+    case 0x403b:
+    case 0x092b:
+    case 0x092c:
+    case 0x092d:
+    case 0x092e:
+    case 0x092f:
+	spca50x->chip_revision = Rev012A;
+	break;
+    default:
+	PDEBUG(0, "Spca561 chip Unknow Contact the Author");
+	return -EINVAL;
+	break;
+    }
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 0;
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 1;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 1;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 2;
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 1023;
+    spca50x->mode_cam[QCIF].method = 0;
+    spca50x->mode_cam[QCIF].mode = 3;
+    return 0;			// success
+}
+static void spca561_shutdown(struct usb_spca50x *spca50x)
+{
+    spca5xxRegWrite(spca50x->dev, 0, 0, 0x8114, NULL, 0);
+}
+static void spca561_setAutobright(struct usb_spca50x *spca50x)
+{
+    int expotimes = 0;
+    int pixelclk = 0;
+    int gainG = 0;
+    __u8 R, Gr, Gb, B;
+    int y;
+    __u8 luma_mean = 110;
+    __u8 luma_delta = 20;
+    __u8 spring = 4;
+    switch (spca50x->chip_revision) {
+    case Rev072A:
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8621, &Gr, 1);
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8622, &R, 1);
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8623, &B, 1);
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x8624, &Gb, 1);
+	y = (77 * R + 75 * (Gr + Gb) + 29 * B) >> 8;
+	//u= (128*B-(43*(Gr+Gb+R))) >> 8;
+	//v= (128*R-(53*(Gr+Gb))-21*B) >> 8;
+	//PDEBUG(0,"reading Y %d U %d V %d ",y,u,v);
+
+	if ((y < (luma_mean - luma_delta)) ||
+	    (y > (luma_mean + luma_delta))) {
+	    expotimes = spca561_ReadI2c(spca50x, 0x09, 0x10);
+	    pixelclk = 0x0800;
+	    expotimes = expotimes & 0x07ff;
+	    //PDEBUG(0,"Exposition Times 0x%03X Clock 0x%04X ",expotimes,pixelclk);
+	    gainG = spca561_ReadI2c(spca50x, 0x35, 0x10);
+	    //PDEBUG(0,"reading Gain register %d",gainG);
+
+	    expotimes += ((luma_mean - y) >> spring);
+	    gainG += ((luma_mean - y) / 50);
+	    // PDEBUG(0 , "compute expotimes %d gain %d",expotimes,gainG);
+
+	    if (gainG > 0x3F)
+		gainG = 0x3f;
+	    else if (gainG < 4)
+		gainG = 3;
+	    spca561_WriteI2c(spca50x, (__u16) gainG, 0x35);
+
+
+	    if (expotimes >= 0x0256)
+		expotimes = 0x0256;
+	    else if (expotimes < 4) {
+		expotimes = 3;
+	    }
+
+	    spca561_WriteI2c(spca50x, (__u16) (expotimes | pixelclk),
+			     0x09);
+	}
+
+	break;
+    case Rev012A:
+	/* sensor registers is access and memory mapped to 0x8300 */
+	/* readind all 0x83xx block the sensor */
+	/*
+	   The data from the header seem wrong where is the luma and chroma mean value
+	   at the moment set exposure in contrast set 
+	 */
+	;
+	break;
+    default:
+	break;
+    }
+}
+static int spca561_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+	    
+	   switch (cdata[0]){
+	   case 0:
+	   	*iPix = SPCA561_OFFSET_DATA;
+		*datalength -= *iPix;
+	   	return 0;
+	   case SPCA50X_SEQUENCE_DROP:
+	   	return -1;
+	   default:
+	        *iPix = 1;
+		*datalength -= *iPix;
+	   	return seqnum+1 ;
+	   }
+}
+#endif
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/jpeg_qtables.h linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/jpeg_qtables.h
--- linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/jpeg_qtables.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/jpeg_qtables.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,98 @@
+/*
+ * JPEG Q-tables.
+ */
+
+#ifndef JPEG_QTABLES_H
+#define JPEG_QTABLES_H
+
+static unsigned char qtable_creative_pccam[2][64] = {
+    {				/* Q-table Y-components */
+     0x05, 0x03, 0x03, 0x05, 0x07, 0x0c, 0x0f, 0x12,
+     0x04, 0x04, 0x04, 0x06, 0x08, 0x11, 0x12, 0x11,
+     0x04, 0x04, 0x05, 0x07, 0x0c, 0x11, 0x15, 0x11,
+     0x04, 0x05, 0x07, 0x09, 0x0f, 0x1a, 0x18, 0x13,
+     0x05, 0x07, 0x0b, 0x11, 0x14, 0x21, 0x1f, 0x17,
+     0x07, 0x0b, 0x11, 0x13, 0x18, 0x1f, 0x22, 0x1c,
+     0x0f, 0x13, 0x17, 0x1a, 0x1f, 0x24, 0x24, 0x1e,
+     0x16, 0x1c, 0x1d, 0x1d, 0x22, 0x1e, 0x1f, 0x1e},
+    {				/* Q-table C-components */
+     0x05, 0x05, 0x07, 0x0e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x05, 0x06, 0x08, 0x14, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x07, 0x08, 0x11, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x0e, 0x14, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e}
+};
+
+static unsigned char qtable_kodak_ez200[2][64] = {
+    {				/* Q-table Y-components */
+     0x02, 0x01, 0x01, 0x02, 0x02, 0x04, 0x05, 0x06,
+     0x01, 0x01, 0x01, 0x02, 0x03, 0x06, 0x06, 0x06,
+     0x01, 0x01, 0x02, 0x02, 0x04, 0x06, 0x07, 0x06,
+     0x01, 0x02, 0x02, 0x03, 0x05, 0x09, 0x08, 0x06,
+     0x02, 0x02, 0x04, 0x06, 0x07, 0x0b, 0x0a, 0x08,
+     0x02, 0x04, 0x06, 0x06, 0x08, 0x0a, 0x0b, 0x09,
+     0x05, 0x06, 0x08, 0x09, 0x0a, 0x0c, 0x0c, 0x0a,
+     0x07, 0x09, 0x0a, 0x0a, 0x0b, 0x0a, 0x0a, 0x0a},
+    {				/* Q-table C-components */
+     0x02, 0x02, 0x02, 0x05, 0x0a, 0x0a, 0x0a, 0x0a,
+     0x02, 0x02, 0x03, 0x07, 0x0a, 0x0a, 0x0a, 0x0a,
+     0x02, 0x03, 0x06, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+     0x05, 0x07, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+     0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+     0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+     0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+     0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a}
+};
+
+/* FIXME: This Q-table is identical to the Creative PC-CAM one,
+ *        except for one byte. Possibly a typo?
+ *        NWG: 18/05/2003.
+ */
+static unsigned char qtable_spca504_default[2][64] = {
+    {				/* Q-table Y-components */
+     0x05, 0x03, 0x03, 0x05, 0x07, 0x0c, 0x0f, 0x12,
+     0x04, 0x04, 0x04, 0x06, 0x08, 0x11, 0x12, 0x11,
+     0x04, 0x04, 0x05, 0x07, 0x0c, 0x11, 0x15, 0x11,
+     0x04, 0x05, 0x07, 0x09, 0x0f, 0x1a, 0x18, 0x13,
+     0x05, 0x07, 0x0b, 0x11, 0x14, 0x21, 0x1f, 0x17,
+     0x07, 0x0b, 0x11, 0x13, 0x18, 0x1f, 0x22, 0x1c,
+     0x0f, 0x13, 0x17, 0x1a, 0x1f, 0x24, 0x24, 0x1e,
+     0x16, 0x1c, 0x1d, 0x1d, 0x1d /* 0x22 */ , 0x1e, 0x1f, 0x1e,
+     },
+    {				/* Q-table C-components */
+     0x05, 0x05, 0x07, 0x0e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x05, 0x06, 0x08, 0x14, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x07, 0x08, 0x11, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x0e, 0x14, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e}
+};
+
+static unsigned char qtable_pocketdv[2][64] = {
+    {				/* Q-table Y-components start registers 0x8800 */
+     0x06, 0x04, 0x04, 0x06, 0x0a, 0x10, 0x14, 0x18,
+     0x05, 0x05, 0x06, 0x08, 0x0a, 0x17, 0x18, 0x16,
+     0x06, 0x05, 0x06, 0x0a, 0x10, 0x17, 0x1c, 0x16,
+     0x06, 0x07, 0x09, 0x0c, 0x14, 0x23, 0x20, 0x19,
+     0x07, 0x09, 0x0f, 0x16, 0x1b, 0x2c, 0x29, 0x1f,
+     0x0a, 0x0e, 0x16, 0x1a, 0x20, 0x2a, 0x2d, 0x25,
+     0x14, 0x1a, 0x1f, 0x23, 0x29, 0x30, 0x30, 0x28,
+     0x1d, 0x25, 0x26, 0x27, 0x2d, 0x28, 0x29, 0x28,
+     },
+    {				/* Q-table C-components start registers 0x8840 */
+     0x07, 0x07, 0x0a, 0x13, 0x28, 0x28, 0x28, 0x28,
+     0x07, 0x08, 0x0a, 0x1a, 0x28, 0x28, 0x28, 0x28,
+     0x0a, 0x0a, 0x16, 0x28, 0x28, 0x28, 0x28, 0x28,
+     0x13, 0x1a, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+     0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+     0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+     0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+     0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28}
+
+};
+#endif				/* JPEG_QTABLES_H */
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/sp5xxfw2.dat linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/sp5xxfw2.dat
--- linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/sp5xxfw2.dat	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/sp5xxfw2.dat	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,253 @@
+
+/* Initialisation data for the Creative PC-CAM 600 */
+static __u16 spca504_pccam600_init_data[][3] = {
+//      {0xa0, 0x0000, 0x0503}, /* capture mode */
+    {0x00, 0x0000, 0x2000},
+    {0x00, 0x0013, 0x2301},
+    {0x00, 0x0003, 0x2000},
+    {0x00, 0x0001, 0x21ac},
+    {0x00, 0x0001, 0x21a6},
+    {0x00, 0x0000, 0x21a7},	/* brightness */
+    {0x00, 0x0020, 0x21a8},	/* contrast */
+    {0x00, 0x0001, 0x21ac},	/* sat/hue */
+    {0x00, 0x0000, 0x21ad},	/* hue */
+    {0x00, 0x001a, 0x21ae},	/* saturation */
+    {0x00, 0x0002, 0x21a3},	/* gamma */
+#if 0
+    {0xb0, 0x0000, 0x0000},	/* reset auto exposure */
+    {0x0c, 0x0000, 0x0000},	/* reset auto whiteness */
+    {0x0c, 0x0004, 0x0000},	/* enable auto whiteness */
+    {0x30, 0x020f, 0x0001},	/* exposure compensation */
+    {0x30, 0x01f7, 0x0002},	/* whiteness balance */
+#endif
+    {0x30, 0x0154, 0x0008},
+    {0x30, 0x0004, 0x0006},
+    {0x30, 0x0258, 0x0009},
+    {0x30, 0x0004, 0x0000},
+    {0x30, 0x0093, 0x0004},
+    {0x30, 0x0066, 0x0005},
+    {0x00, 0x0000, 0x2000},
+    {0x00, 0x0013, 0x2301},
+    {0x00, 0x0003, 0x2000},
+    {0x00, 0x0013, 0x2301},
+    {0x00, 0x0003, 0x2000},
+
+    {0, 0, 0}
+};
+
+/* Creative PC-CAM 600 specific open data, sent before using the
+ * generic initialisation data from spca504_open_data.
+ */
+static __u16 spca504_pccam600_open_data[][3] = {
+    {0x00, 0x0001, 0x2501},
+    {0x20, 0x0500, 0x0001},	/* snapshot mode */
+    {0x00, 0x0003, 0x2880},
+    {0x00, 0x0001, 0x2881},
+
+    {0, 0, 0}
+};
+
+/* Initialisation data for the logitech clicksmart 420 */
+static __u16 spca504A_clicksmart420_init_data[][3] = {
+//      {0xa0, 0x0000, 0x0503}, /* capture mode */
+    {0x00, 0x0000, 0x2000},
+    {0x00, 0x0013, 0x2301},
+    {0x00, 0x0003, 0x2000},
+    {0x00, 0x0001, 0x21ac},
+    {0x00, 0x0001, 0x21a6},
+    {0x00, 0x0000, 0x21a7},	/* brightness */
+    {0x00, 0x0020, 0x21a8},	/* contrast */
+    {0x00, 0x0001, 0x21ac},	/* sat/hue */
+    {0x00, 0x0000, 0x21ad},	/* hue */
+    {0x00, 0x001a, 0x21ae},	/* saturation */
+    {0x00, 0x0002, 0x21a3},	/* gamma */
+#if 1
+    {0x30, 0x0004, 0x000a},
+    {0xb0, 0x0001, 0x0000},
+#endif
+
+#if 0
+    {0xb0, 0x0000, 0x0000},	/* reset auto exposure */
+    {0x0c, 0x0000, 0x0000},	/* reset auto whiteness */
+    {0x0c, 0x0004, 0x0000},	/* enable auto whiteness */
+    {0x30, 0x020f, 0x0001},	/* exposure compensation */
+    {0x30, 0x01f7, 0x0002},	/* whiteness balance */
+#endif
+
+#if 1
+    {0x0a1, 0x0080, 0x0001},
+    {0x30, 0x0049, 0x0000},
+    {0x30, 0x0060, 0x0005},
+    {0x0c, 0x0004, 0x0000},
+    {0x00, 0x0000, 0x0000},
+    {0x00, 0x0000, 0x2000},
+    {0x00, 0x0013, 0x2301},
+    {0x00, 0x0003, 0x2000},
+    {0x00, 0x0000, 0x2000},
+#endif
+
+#if 0
+    {0x30, 0x0154, 0x0008},
+    {0x30, 0x0004, 0x0006},
+    {0x30, 0x0258, 0x0009},
+    {0x30, 0x0004, 0x0000},
+    {0x30, 0x0093, 0x0004},
+    {0x30, 0x0066, 0x0005},
+    {0x00, 0x0000, 0x2000},
+    {0x00, 0x0013, 0x2301},
+    {0x00, 0x0003, 0x2000},
+    {0x00, 0x0013, 0x2301},
+    {0x00, 0x0003, 0x2000},
+#endif
+
+    {0, 0, 0}
+};
+
+/* clicksmart 420 open data ? */
+static __u16 spca504A_clicksmart420_open_data[][3] = {
+    {0x00, 0x0001, 0x2501},
+    {0x20, 0x0502, 0x0000},
+    {0x06, 0x0000, 0x0000},
+    {0x00, 0x0004, 0x2880},
+    {0x00, 0x0001, 0x2881},
+/* look like setting a qTable */
+    {0x00, 0x0006, 0x2800},
+    {0x00, 0x0004, 0x2801},
+    {0x00, 0x0004, 0x2802},
+    {0x00, 0x0006, 0x2803},
+    {0x00, 0x000a, 0x2804},
+    {0x00, 0x0010, 0x2805},
+    {0x00, 0x0014, 0x2806},
+    {0x00, 0x0018, 0x2807},
+    {0x00, 0x0005, 0x2808},
+    {0x00, 0x0005, 0x2809},
+    {0x00, 0x0006, 0x280a},
+    {0x00, 0x0008, 0x280b},
+    {0x00, 0x000a, 0x280c},
+    {0x00, 0x0017, 0x280d},
+    {0x00, 0x0018, 0x280e},
+    {0x00, 0x0016, 0x280f},
+
+    {0x00, 0x0006, 0x2810},
+    {0x00, 0x0005, 0x2811},
+    {0x00, 0x0006, 0x2812},
+    {0x00, 0x000a, 0x2813},
+    {0x00, 0x0010, 0x2814},
+    {0x00, 0x0017, 0x2815},
+    {0x00, 0x001c, 0x2816},
+    {0x00, 0x0016, 0x2817},
+    {0x00, 0x0006, 0x2818},
+    {0x00, 0x0007, 0x2819},
+    {0x00, 0x0009, 0x281a},
+    {0x00, 0x000c, 0x281b},
+    {0x00, 0x0014, 0x281c},
+    {0x00, 0x0023, 0x281d},
+    {0x00, 0x0020, 0x281e},
+    {0x00, 0x0019, 0x281f},
+
+    {0x00, 0x0007, 0x2820},
+    {0x00, 0x0009, 0x2821},
+    {0x00, 0x000f, 0x2822},
+    {0x00, 0x0016, 0x2823},
+    {0x00, 0x001b, 0x2824},
+    {0x00, 0x002c, 0x2825},
+    {0x00, 0x0029, 0x2826},
+    {0x00, 0x001f, 0x2827},
+    {0x00, 0x000a, 0x2828},
+    {0x00, 0x000e, 0x2829},
+    {0x00, 0x0016, 0x282a},
+    {0x00, 0x001a, 0x282b},
+    {0x00, 0x0020, 0x282c},
+    {0x00, 0x002a, 0x282d},
+    {0x00, 0x002d, 0x282e},
+    {0x00, 0x0025, 0x282f},
+
+    {0x00, 0x0014, 0x2830},
+    {0x00, 0x001a, 0x2831},
+    {0x00, 0x001f, 0x2832},
+    {0x00, 0x0023, 0x2833},
+    {0x00, 0x0029, 0x2834},
+    {0x00, 0x0030, 0x2835},
+    {0x00, 0x0030, 0x2836},
+    {0x00, 0x0028, 0x2837},
+    {0x00, 0x001d, 0x2838},
+    {0x00, 0x0025, 0x2839},
+    {0x00, 0x0026, 0x283a},
+    {0x00, 0x0027, 0x283b},
+    {0x00, 0x002d, 0x283c},
+    {0x00, 0x0028, 0x283d},
+    {0x00, 0x0029, 0x283e},
+    {0x00, 0x0028, 0x283f},
+
+    {0x00, 0x0007, 0x2840},
+    {0x00, 0x0007, 0x2841},
+    {0x00, 0x000a, 0x2842},
+    {0x00, 0x0013, 0x2843},
+    {0x00, 0x0028, 0x2844},
+    {0x00, 0x0028, 0x2845},
+    {0x00, 0x0028, 0x2846},
+    {0x00, 0x0028, 0x2847},
+    {0x00, 0x0007, 0x2848},
+    {0x00, 0x0008, 0x2849},
+    {0x00, 0x000a, 0x284a},
+    {0x00, 0x001a, 0x284b},
+    {0x00, 0x0028, 0x284c},
+    {0x00, 0x0028, 0x284d},
+    {0x00, 0x0028, 0x284e},
+    {0x00, 0x0028, 0x284f},
+
+    {0x00, 0x000a, 0x2850},
+    {0x00, 0x000a, 0x2851},
+    {0x00, 0x0016, 0x2852},
+    {0x00, 0x0028, 0x2853},
+    {0x00, 0x0028, 0x2854},
+    {0x00, 0x0028, 0x2855},
+    {0x00, 0x0028, 0x2856},
+    {0x00, 0x0028, 0x2857},
+    {0x00, 0x0013, 0x2858},
+    {0x00, 0x001a, 0x2859},
+    {0x00, 0x0028, 0x285a},
+    {0x00, 0x0028, 0x285b},
+    {0x00, 0x0028, 0x285c},
+    {0x00, 0x0028, 0x285d},
+    {0x00, 0x0028, 0x285e},
+    {0x00, 0x0028, 0x285f},
+
+    {0x00, 0x0028, 0x2860},
+    {0x00, 0x0028, 0x2861},
+    {0x00, 0x0028, 0x2862},
+    {0x00, 0x0028, 0x2863},
+    {0x00, 0x0028, 0x2864},
+    {0x00, 0x0028, 0x2865},
+    {0x00, 0x0028, 0x2866},
+    {0x00, 0x0028, 0x2867},
+    {0x00, 0x0028, 0x2868},
+    {0x00, 0x0028, 0x2869},
+    {0x00, 0x0028, 0x286a},
+    {0x00, 0x0028, 0x286b},
+    {0x00, 0x0028, 0x286c},
+    {0x00, 0x0028, 0x286d},
+    {0x00, 0x0028, 0x286e},
+    {0x00, 0x0028, 0x286f},
+
+    {0x00, 0x0028, 0x2870},
+    {0x00, 0x0028, 0x2871},
+    {0x00, 0x0028, 0x2872},
+    {0x00, 0x0028, 0x2873},
+    {0x00, 0x0028, 0x2874},
+    {0x00, 0x0028, 0x2875},
+    {0x00, 0x0028, 0x2876},
+    {0x00, 0x0028, 0x2877},
+    {0x00, 0x0028, 0x2878},
+    {0x00, 0x0028, 0x2879},
+    {0x00, 0x0028, 0x287a},
+    {0x00, 0x0028, 0x287b},
+    {0x00, 0x0028, 0x287c},
+    {0x00, 0x0028, 0x287d},
+    {0x00, 0x0028, 0x287e},
+    {0x00, 0x0028, 0x287f},
+
+    {0xa0, 0x0000, 0x0503},
+
+    {0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/sp5xxfw2.h linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/sp5xxfw2.h
--- linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/sp5xxfw2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/sp5xxfw2.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,827 @@
+#ifndef SP5XXFW2_H
+#define SP5XXFW2_H
+/****************************************************************************
+#	 	Sunplus spca504(abc) spca533 spca536  library               #
+# 		Copyright (C) 2005 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+#define SPCA504_PCCAM600_OFFSET_SNAPSHOT 3
+#define SPCA504_PCCAM600_OFFSET_COMPRESS 4
+#define SPCA504_PCCAM600_OFFSET_MODE	 5
+#define SPCA504_PCCAM600_OFFSET_DATA	 14
+ /* Frame packet header offsets for the spca533 */
+#define SPCA533_OFFSET_DATA      16
+#define SPCA533_OFFSET_FRAMSEQ	15
+/* Frame packet header offsets for the spca536 */
+#define SPCA536_OFFSET_DATA      4
+#define SPCA536_OFFSET_FRAMSEQ	 1
+#include "sp5xxfw2.dat"
+static int sp5xxfw2_init(struct usb_spca50x *spca50x);
+static void sp5xxfw2_start(struct usb_spca50x *spca50x);
+static void sp5xxfw2_stopN(struct usb_spca50x *spca50x);
+static void sp5xxfw2_stop0(struct usb_spca50x *spca50x);
+static void sp5xxfw2_setbrightness(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_getbrightness(struct usb_spca50x *spca50x);
+static void sp5xxfw2_setcontrast(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_getcontrast(struct usb_spca50x *spca50x);
+static void sp5xxfw2_setcolors(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_getcolors(struct usb_spca50x *spca50x);
+static void sp5xxfw2_setAutobright (struct usb_spca50x *spca50x);
+static int sp5xxfw2_config(struct usb_spca50x *spca50x);
+static void sp5xxfw2_setquality(struct usb_spca50x *spca50x);
+static void sp5xxfw2_shutdown(struct usb_spca50x *spca50x);
+static int sp5xxfw2_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum,int *datalength);
+/************************** Virtual *************************/
+static void sp5xxfw2_shutdown(struct usb_spca50x *spca50x){}
+static void sp5xxfw2_setAutobright (struct usb_spca50x *spca50x){}
+static void sp5xxfw2_setquality(struct usb_spca50x *spca50x){}
+static void sp5xxfw2_stop0(struct usb_spca50x *spca50x){}
+//static __u16 sp5xxfw2_setexposure(struct usb_spca50x *spca50x);
+//static __u16 sp5xxfw2_getexposure(struct usb_spca50x *spca50x);
+/************************** Private *************************/
+static struct cam_operation fsp5xxfw2 = {
+ 	.initialize = sp5xxfw2_init,
+	.configure = sp5xxfw2_config,
+	.start = sp5xxfw2_start,
+	.stopN = sp5xxfw2_stopN,
+	.stop0 = sp5xxfw2_stop0,
+	.get_bright = sp5xxfw2_getbrightness,
+	.set_bright = sp5xxfw2_setbrightness,
+	.get_contrast = sp5xxfw2_getcontrast,
+	.set_contrast = sp5xxfw2_setcontrast,
+	.get_colors = sp5xxfw2_getcolors,
+	.set_colors = sp5xxfw2_setcolors,
+	.set_autobright = sp5xxfw2_setAutobright,
+	.set_quality = sp5xxfw2_setquality,
+	.cam_shutdown = sp5xxfw2_shutdown,
+	.sof_detect = sp5xxfw2_sofdetect,
+ };
+
+static void spca504B_SetSizeType(struct usb_spca50x *spca50x);
+
+static void
+spca504_acknowledged_command(struct usb_spca50x *spca50x,
+			     __u16 reg, __u16 idx, __u16 val);
+
+static void
+spca504A_acknowledged_command(struct usb_spca50x *spca50x,
+			      __u16 reg,
+			      __u16 idx, __u16 val, __u8 stat, __u8 count);
+static void spca504_wait_status(struct usb_spca50x *spca50x);
+static void spca50x_GetFirmware(struct usb_spca50x *spca50x);
+static int spca504B_PollingDataReady(struct usb_device *dev);
+static void spca504B_WaitCmdStatus(struct usb_spca50x *spca50x);
+static void spca504B_setQtable(struct usb_spca50x *spca50x);
+static void sp5xx_initContBrigHueRegisters(struct usb_spca50x *spca50x);
+/************************************************************/
+static int sp5xxfw2_init(struct usb_spca50x *spca50x)
+{
+    int rc;
+    __u8 Data = 0;
+    __u8 i;
+    __u8 info[6];
+    int err_code;
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA504B:{
+	    spca5xxRegWrite(spca50x->dev, 0x1d, 0, 0, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0, 1, 0x2306, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0, 0, 0x0d04, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0, 0, 0x2000, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0, 0x13, 0x2301, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0, 0, 0x2306, NULL, 0);
+	}			// becare no break here init follow
+    case BRIDGE_SPCA533:
+	rc = spca504B_PollingDataReady(spca50x->dev);
+	spca50x_GetFirmware(spca50x);
+	break;
+    case BRIDGE_SPCA536:
+	spca50x_GetFirmware(spca50x);
+	spca5xxRegRead(spca50x->dev, 0x00, 0, 0x5002, &Data, 1);
+	Data = 0;
+	spca5xxRegWrite(spca50x->dev, 0x24, 0, 0, &Data, 1);
+	spca5xxRegRead(spca50x->dev, 0x24, 0, 0, &Data, 1);
+	rc = spca504B_PollingDataReady(spca50x->dev);
+	spca5xxRegWrite(spca50x->dev, 0x34, 0, 0, NULL, 0);
+	spca504B_WaitCmdStatus(spca50x);
+	break;
+    case BRIDGE_SPCA504C:	//pccam600
+	PDEBUG(2, "Opening SPCA504 (PC-CAM 600)");
+	spca50x_reg_write(spca50x->dev, 0xe0, 0x0000, 0x0000);
+	spca50x_reg_write(spca50x->dev, 0xe0, 0x0000, 0x0001);	// reset
+	spca504_wait_status(spca50x);
+	if (spca50x->desc == LogitechClickSmart420) {	/* clicksmart 420 */
+	    spca50x_write_vector(spca50x,
+				 spca504A_clicksmart420_open_data);
+	} else {
+	    spca50x_write_vector(spca50x, spca504_pccam600_open_data);
+	}
+	err_code = spca50x_setup_qtable(spca50x,
+					0x00, 0x2800,
+					0x2840, qtable_creative_pccam);
+	if (err_code < 0) {
+	    PDEBUG(2, "spca50x_setup_qtable failed");
+	    return err_code;
+	}
+	break;
+    case BRIDGE_SPCA504:
+	PDEBUG(2, "Opening SPCA504");
+	if (spca50x->desc == AiptekMiniPenCam13) {
+	  /***************************************************************/
+	    for (i = 0; i < 6; i++) {
+		info[i] = spca50x_reg_read_with_value(spca50x->dev,
+						      0x20, i, 0x0000, 1);
+	    }
+	    PDEBUG(0,
+		   "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n",
+		   info[0], info[1], info[2], info[3], info[4], info[5]);
+	    /* spca504a aiptek */
+	    // Set AE AWB Banding Type 3-> 50Hz 2-> 60Hz           
+	    spca504A_acknowledged_command(spca50x, 0x24, 8, 3, 0x9e, 1);
+	    // Twice sequencial need status 0xff->0x9e->0x9d 
+	    spca504A_acknowledged_command(spca50x, 0x24, 8, 3, 0x9e, 0);
+
+	    spca504A_acknowledged_command(spca50x, 0x24, 0, 0, 0x9d, 1);
+	/**************************************************************/
+	    /* spca504a aiptek */
+	    spca504A_acknowledged_command(spca50x, 0x08, 6, 0, 0x86, 1);
+	    // spca50x_reg_write (spca50x->dev, 0, 0x2000, 0);
+	    // spca50x_reg_write (spca50x->dev, 0, 0x2883, 1);
+	    // spca504A_acknowledged_command (spca50x, 0x08, 6, 0, 0x86, 1);
+	    //spca504A_acknowledged_command (spca50x, 0x24, 0, 0, 0x9D, 1);
+	    spca50x_reg_write(spca50x->dev, 0x0, 0x270c, 0x5);	// L92 sno1t.txt 
+	    spca50x_reg_write(spca50x->dev, 0x0, 0x2310, 0x5);
+	    spca504A_acknowledged_command(spca50x, 1, 0x0f, 0, 0xFF, 0);
+	}
+	/* setup qtable */
+	spca50x_reg_write(spca50x->dev, 0, 0x2000, 0);
+	spca50x_reg_write(spca50x->dev, 0, 0x2883, 1);
+	err_code = spca50x_setup_qtable(spca50x,
+					0x00, 0x2800,
+					0x2840, qtable_spca504_default);
+	if (err_code < 0) {
+	    PDEBUG(2, "spca50x_setup_qtable failed");
+	    return err_code;
+	}
+	break;
+    }
+    return 0;
+}
+static void sp5xxfw2_start(struct usb_spca50x *spca50x)
+{
+    int rc;
+    int enable;
+    __u8 i;
+    __u8 info[6];
+    if (spca50x->bridge == BRIDGE_SPCA504B)
+	spca504B_setQtable(spca50x);
+    spca504B_SetSizeType(spca50x);
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA536:
+	if (spca50x->desc == MegapixV4 ||
+	    spca50x->desc == LogitechClickSmart820) {
+	    spca5xxRegWrite(spca50x->dev, 0xF0, 0, 0, NULL, 0);
+	    spca504B_WaitCmdStatus(spca50x);
+	    spca5xxRegRead(spca50x->dev, 0xF0, 0, 4, NULL, 0);
+	    spca504B_WaitCmdStatus(spca50x);
+	} else {
+	    spca5xxRegWrite(spca50x->dev, 0x31, 0, 4, NULL, 0);
+	    spca504B_WaitCmdStatus(spca50x);
+	    rc = spca504B_PollingDataReady(spca50x->dev);
+	}
+	break;
+    case BRIDGE_SPCA504:
+	if (spca50x->desc == AiptekMiniPenCam13) {
+	    for (i = 0; i < 6; i++) {
+		info[i] = spca50x_reg_read_with_value(spca50x->dev,
+						      0x20, i, 0x0000, 1);
+	    }
+	    PDEBUG(0,
+		   "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n",
+		   info[0], info[1], info[2], info[3], info[4], info[5]);
+	    /* spca504a aiptek */
+	    // Set AE AWB Banding Type 3-> 50Hz 2-> 60Hz           
+	    spca504A_acknowledged_command(spca50x, 0x24, 8, 3, 0x9e, 1);
+	    // Twice sequencial need status 0xff->0x9e->0x9d 
+	    spca504A_acknowledged_command(spca50x, 0x24, 8, 3, 0x9e, 0);
+
+	    spca504A_acknowledged_command(spca50x, 0x24, 0, 0, 0x9d, 1);
+	} else {
+	    spca504_acknowledged_command(spca50x, 0x24, 8, 3);
+	    for (i = 0; i < 6; i++) {
+		info[i] = spca50x_reg_read_with_value(spca50x->dev,
+						      0x20, i, 0x0000, 1);
+	    }
+	    PDEBUG(0,
+		   "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n",
+		   info[0], info[1], info[2], info[3], info[4], info[5]);
+	    spca504_acknowledged_command(spca50x, 0x24, 8, 3);
+
+	    spca504_acknowledged_command(spca50x, 0x24, 0, 0);
+	}
+
+	spca504B_SetSizeType(spca50x);
+	spca50x_reg_write(spca50x->dev, 0x0, 0x270c, 0x5);	// L92 sno1t.txt 
+
+	spca50x_reg_write(spca50x->dev, 0x0, 0x2310, 0x5);
+	break;
+    case BRIDGE_SPCA504C:
+	if (spca50x->desc == LogitechClickSmart420) {
+	    spca50x_write_vector(spca50x,
+				 spca504A_clicksmart420_init_data);
+	} else {
+	    spca50x_write_vector(spca50x, spca504_pccam600_init_data);
+	}
+	enable = (spca50x->autoexpo ? 0x4 : 0x1);
+	spca50x_reg_write(spca50x->dev, 0x0c, 0x0000, enable);	// auto exposure
+	spca50x_reg_write(spca50x->dev, 0xb0, 0x0000, enable);	// auto whiteness
+
+	/* set default exposure compensation and whiteness balance */
+	spca50x_reg_write(spca50x->dev, 0x30, 0x0001, 800);	// ~ 20 fps
+	spca50x_reg_write(spca50x->dev, 0x30, 0x0002, 1600);
+	spca504B_SetSizeType(spca50x);
+	break;
+    }
+    sp5xx_initContBrigHueRegisters(spca50x);
+}
+static void sp5xxfw2_stopN(struct usb_spca50x *spca50x)
+{
+    int rc;
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA536:
+    case BRIDGE_SPCA504B:
+	spca5xxRegWrite(spca50x->dev, 0x31, 0, 0, NULL, 0);
+	spca504B_WaitCmdStatus(spca50x);
+	rc = spca504B_PollingDataReady(spca50x->dev);
+	break;
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+	spca50x_reg_write(spca50x->dev, 0x00, 0x2000, 0x0000);
+
+	if (spca50x->desc == AiptekMiniPenCam13) {
+	    /* spca504a aiptek */
+	    // spca504A_acknowledged_command (spca50x, 0x08, 6, 0, 0x86, 1);
+	    spca504A_acknowledged_command(spca50x, 0x24, 0x0000, 0x0000,
+					  0x9d, 1);
+	    spca504A_acknowledged_command(spca50x, 0x01, 0x000f, 0x0000,
+					  0xFF, 1);
+	} else {
+	    spca504_acknowledged_command(spca50x, 0x24, 0x0000, 0x0000);
+	    spca50x_reg_write(spca50x->dev, 0x01, 0x000f, 0x0);
+	}
+	break;
+    }
+}
+static void sp5xxfw2_setbrightness(struct usb_spca50x *spca50x)
+{
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21a7,
+			  (spca50x->brightness >> 8));
+	break;
+    case BRIDGE_SPCA536:
+	spca50x_reg_write(spca50x->dev, 0x0, 0x20f0,
+			  (spca50x->brightness >> 8));
+	break;
+    }
+}
+static __u16 sp5xxfw2_getbrightness(struct usb_spca50x *spca50x)
+{
+    __u16 brightness = 0;
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+	brightness = spca50x_reg_read(spca50x->dev, 0x0, 0x21a7, 2);
+	spca50x->brightness = (((brightness & 0xFF) - 128) % 255) << 8;
+	break;
+    case BRIDGE_SPCA536:
+	brightness = spca50x_reg_read(spca50x->dev, 0x0, 0x20f0, 2);
+	spca50x->brightness = (((brightness & 0xFF) - 128) % 255) << 8;
+	break;
+    }
+    return (((brightness & 0xFF) - 128) % 255) << 8;
+}
+static void sp5xxfw2_setcontrast(struct usb_spca50x *spca50x)
+{
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21a8,
+			  spca50x->contrast >> 8);
+	break;
+    case BRIDGE_SPCA536:
+	spca50x_reg_write(spca50x->dev, 0x0, 0x20f1,
+			  spca50x->contrast >> 8);
+	break;
+    }
+}
+static __u16 sp5xxfw2_getcontrast(struct usb_spca50x *spca50x)
+{
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+	spca50x->contrast =
+	    spca50x_reg_read(spca50x->dev, 0x0, 0x21a8, 2) << 8;
+	break;
+    case BRIDGE_SPCA536:
+	spca50x->contrast =
+	    spca50x_reg_read(spca50x->dev, 0x0, 0x20f1, 2) << 8;
+	break;
+    }
+    return spca50x->contrast;
+}
+static void sp5xxfw2_setcolors(struct usb_spca50x *spca50x)
+{
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21ae, spca50x->colour >> 8);
+	break;
+    case BRIDGE_SPCA536:
+	spca50x_reg_write(spca50x->dev, 0x0, 0x20f6, spca50x->colour >> 8);
+	break;
+    }
+}
+
+
+static __u16 sp5xxfw2_getcolors(struct usb_spca50x *spca50x)
+{
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+	spca50x->colour =
+	    spca50x_reg_read(spca50x->dev, 0x0, 0x21ae, 2) << 7;
+	break;
+    case BRIDGE_SPCA536:
+	spca50x->colour =
+	    spca50x_reg_read(spca50x->dev, 0x0, 0x20f6, 2) << 7;
+	break;
+    }
+    return spca50x->colour;
+}
+static int sp5xxfw2_config(struct usb_spca50x *spca50x)
+{
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA536:
+	memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+	spca50x->mode_cam[VGA].width = 640;
+	spca50x->mode_cam[VGA].height = 480;
+	spca50x->mode_cam[VGA].t_palette =
+	    P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[VGA].pipe = 1023;
+	spca50x->mode_cam[VGA].method = 0;
+	spca50x->mode_cam[VGA].mode = 1;
+	spca50x->mode_cam[PAL].width = 384;
+	spca50x->mode_cam[PAL].height = 288;
+	spca50x->mode_cam[PAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[PAL].pipe = 1023;
+	spca50x->mode_cam[PAL].method = 1;
+	spca50x->mode_cam[PAL].mode = 1;
+	spca50x->mode_cam[SIF].width = 352;
+	spca50x->mode_cam[SIF].height = 288;
+	spca50x->mode_cam[SIF].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[SIF].pipe = 1023;
+	spca50x->mode_cam[SIF].method = 1;
+	spca50x->mode_cam[SIF].mode = 1;
+	spca50x->mode_cam[CIF].width = 320;
+	spca50x->mode_cam[CIF].height = 240;
+	spca50x->mode_cam[CIF].t_palette =
+	    P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[CIF].pipe = 896;
+	spca50x->mode_cam[CIF].method = 0;
+	spca50x->mode_cam[CIF].mode = 2;
+	spca50x->mode_cam[QPAL].width = 192;
+	spca50x->mode_cam[QPAL].height = 144;
+	spca50x->mode_cam[QPAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QPAL].pipe = 896;
+	spca50x->mode_cam[QPAL].method = 1;
+	spca50x->mode_cam[QPAL].mode = 2;
+	spca50x->mode_cam[QSIF].width = 176;
+	spca50x->mode_cam[QSIF].height = 144;
+	spca50x->mode_cam[QSIF].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QSIF].pipe = 896;
+	spca50x->mode_cam[QSIF].method = 1;
+	spca50x->mode_cam[QSIF].mode = 2;
+	break;
+    case BRIDGE_SPCA533:
+	memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+	spca50x->mode_cam[CUSTOM].width = 464;
+	spca50x->mode_cam[CUSTOM].height = 480;
+	spca50x->mode_cam[CUSTOM].t_palette =
+	    P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[CUSTOM].pipe = 1023;
+	spca50x->mode_cam[CUSTOM].method = 0;
+	spca50x->mode_cam[CUSTOM].mode = 1;
+	spca50x->mode_cam[PAL].width = 384;
+	spca50x->mode_cam[PAL].height = 288;
+	spca50x->mode_cam[PAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[PAL].pipe = 1023;
+	spca50x->mode_cam[PAL].method = 1;
+	spca50x->mode_cam[PAL].mode = 1;
+	spca50x->mode_cam[SIF].width = 352;
+	spca50x->mode_cam[SIF].height = 288;
+	spca50x->mode_cam[SIF].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[SIF].pipe = 1023;
+	spca50x->mode_cam[SIF].method = 1;
+	spca50x->mode_cam[SIF].mode = 1;
+	spca50x->mode_cam[CIF].width = 320;
+	spca50x->mode_cam[CIF].height = 240;
+	spca50x->mode_cam[CIF].t_palette =
+	    P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[CIF].pipe = 1023;
+	spca50x->mode_cam[CIF].method = 0;
+	spca50x->mode_cam[CIF].mode = 2;
+	spca50x->mode_cam[QPAL].width = 192;
+	spca50x->mode_cam[QPAL].height = 144;
+	spca50x->mode_cam[QPAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QPAL].pipe = 1023;
+	spca50x->mode_cam[QPAL].method = 1;
+	spca50x->mode_cam[QPAL].mode = 2;
+	spca50x->mode_cam[QSIF].width = 176;
+	spca50x->mode_cam[QSIF].height = 144;
+	spca50x->mode_cam[QSIF].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QSIF].pipe = 1023;
+	spca50x->mode_cam[QSIF].method = 1;
+	spca50x->mode_cam[QSIF].mode = 2;
+	break;
+    case BRIDGE_SPCA504C:
+	memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+	spca50x->mode_cam[VGA].width = 640;
+	spca50x->mode_cam[VGA].height = 480;
+	spca50x->mode_cam[VGA].t_palette =
+	    P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[VGA].pipe = 1023;
+	spca50x->mode_cam[VGA].method = 0;
+	spca50x->mode_cam[VGA].mode = 1;
+	spca50x->mode_cam[PAL].width = 384;
+	spca50x->mode_cam[PAL].height = 288;
+	spca50x->mode_cam[PAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[PAL].pipe = 1023;
+	spca50x->mode_cam[PAL].method = 1;
+	spca50x->mode_cam[PAL].mode = 1;
+	spca50x->mode_cam[SIF].width = 352;
+	spca50x->mode_cam[SIF].height = 288;
+	spca50x->mode_cam[SIF].t_palette =
+	    P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[SIF].pipe = 1023;
+	spca50x->mode_cam[SIF].method = 0;
+	spca50x->mode_cam[SIF].mode = 2;
+	spca50x->mode_cam[CIF].width = 320;
+	spca50x->mode_cam[CIF].height = 240;
+	spca50x->mode_cam[CIF].t_palette =
+	    P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[CIF].pipe = 896;
+	spca50x->mode_cam[CIF].method = 0;
+	spca50x->mode_cam[CIF].mode = 3;
+	spca50x->mode_cam[QPAL].width = 192;
+	spca50x->mode_cam[QPAL].height = 144;
+	spca50x->mode_cam[QPAL].t_palette =
+	    P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QPAL].pipe = 896;
+	spca50x->mode_cam[QPAL].method = 1;
+	spca50x->mode_cam[QPAL].mode = 3;
+	spca50x->mode_cam[QSIF].width = 176;
+	spca50x->mode_cam[QSIF].height = 144;
+	spca50x->mode_cam[QSIF].t_palette =
+	    P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+	spca50x->mode_cam[QSIF].pipe = 768;
+	spca50x->mode_cam[QSIF].method = 0;
+	spca50x->mode_cam[QSIF].mode = 4;
+	break;
+    }
+    spca50x->qindex = 5;
+    return 0;
+}
+
+/****************************************************************************************/
+static void spca504B_SetSizeType(struct usb_spca50x *spca50x)
+{
+    __u8 Size;
+    __u8 Type;
+    int rc;
+    Size = spca50x->mode;
+    Type = 0;
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA533:{
+	    spca5xxRegWrite(spca50x->dev, 0x31, 0, 0, NULL, 0);
+	    spca504B_WaitCmdStatus(spca50x);
+	    rc = spca504B_PollingDataReady(spca50x->dev);
+	    spca50x_GetFirmware(spca50x);
+
+	    Type = 2;
+	    spca5xxRegWrite(spca50x->dev, 0x24, 0, 8, &Type, 1);
+	    spca5xxRegRead(spca50x->dev, 0x24, 0, 8, &Type, 1);
+
+	    spca5xxRegWrite(spca50x->dev, 0x25, 0, 4, &Size, 1);
+	    spca5xxRegRead(spca50x->dev, 0x25, 0, 4, &Size, 1);
+	    rc = spca504B_PollingDataReady(spca50x->dev);
+
+	    /* Init the cam width height with some values get on init ? */
+	    spca5xxRegWrite(spca50x->dev, 0x31, 0, 4, NULL, 0);
+	    spca504B_WaitCmdStatus(spca50x);
+	    rc = spca504B_PollingDataReady(spca50x->dev);
+
+	}
+	break;
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA536:
+	{
+	    Type = 6;
+	    spca5xxRegWrite(spca50x->dev, 0x25, 0, 4, &Size, 1);
+	    spca5xxRegRead(spca50x->dev, 0x25, 0, 4, &Size, 1);
+	    spca5xxRegWrite(spca50x->dev, 0x27, 0, 0, &Type, 1);
+	    spca5xxRegRead(spca50x->dev, 0x27, 0, 0, &Type, 1);
+
+	    rc = spca504B_PollingDataReady(spca50x->dev);
+	}
+	break;
+    case BRIDGE_SPCA504:
+	Size += 3;
+	if (spca50x->desc == AiptekMiniPenCam13) {
+	    /* spca504a aiptek */
+	    spca504A_acknowledged_command(spca50x, 0x8, Size, 0,
+					  (0x80 | (Size & 0x0F)), 1);
+	    spca504A_acknowledged_command(spca50x, 1, 3, 0, 0x9F, 0);
+	} else {
+	    spca504_acknowledged_command(spca50x, 0x8, Size, 0);
+	}
+	break;
+    case BRIDGE_SPCA504C:
+	spca50x_reg_write(spca50x->dev, 0xa0, (0x0500 | (Size & 0x0F)), 0x0);	// capture mode
+	spca50x_reg_write(spca50x->dev, 0x20, 0x1,
+			  (0x0500 | (Size & 0x0F)));
+	break;
+    }
+    return;
+}
+static void
+spca504_acknowledged_command(struct usb_spca50x *spca50x,
+			     __u16 reg, __u16 idx, __u16 val)
+{
+    __u8 notdone = 0;
+
+    spca50x_reg_write(spca50x->dev, reg, idx, val);
+    notdone = spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+    spca50x_reg_write(spca50x->dev, reg, idx, val);
+
+    PDEBUG(5, "before wait 0x%x", notdone);
+
+    wait_ms(200);
+    notdone = spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+    PDEBUG(5, "after wait 0x%x", notdone);
+
+    return;
+}
+
+static void
+spca504A_acknowledged_command(struct usb_spca50x *spca50x,
+			      __u16 reg,
+			      __u16 idx, __u16 val, __u8 stat, __u8 count)
+{
+    __u8 status;
+    __u8 endcode;
+
+
+    spca50x_reg_write(spca50x->dev, reg, idx, val);
+    status = spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+    endcode = stat;
+    PDEBUG(5, "Status 0x%x Need 0x%x", status, stat);
+    if (count) {
+	while (1) {
+	    wait_ms(10);
+	    /* gsmart mini2 write a each wait setting 1 ms is enought */
+	    //spca50x_reg_write(spca50x->dev,reg,idx,val);
+	    status = spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+	    if (status == endcode) {
+		PDEBUG(5, "status 0x%x after wait 0x%x", status, count);
+		break;
+	    }
+	    count++;
+	    if (count > 200)
+		break;
+
+	}
+    }
+    return;
+}
+static void spca504_wait_status(struct usb_spca50x *spca50x)
+{
+    int ret = 256;
+    do {
+	/* With this we get the status, when return 0 it's all ok */
+	ret = spca50x_reg_read(spca50x->dev, 0x06, 0x00, 1);
+    } while (ret--);
+}
+static void spca50x_GetFirmware(struct usb_spca50x *spca50x)
+{
+    __u8 FW[5] = { 0, 0, 0, 0, 0 };
+    __u8 ProductInfo[64];
+
+    spca5xxRegRead(spca50x->dev, 0x20, 0, 0, FW, 5);
+    PDEBUG(0, "FirmWare : %d %d %d %d %d ", FW[0], FW[1], FW[2], FW[3],
+	   FW[4]);
+    spca5xxRegRead(spca50x->dev, 0x23, 0, 0, ProductInfo, 64);
+    spca5xxRegRead(spca50x->dev, 0x23, 0, 1, ProductInfo, 64);
+    return;
+}
+
+
+static int spca504B_PollingDataReady(struct usb_device *dev)
+{
+    __u8 DataReady = 0;
+    int count = 0;
+    while (1) {
+	spca5xxRegRead(dev, 0x21, 0, 0, &DataReady, 1);
+	if ((DataReady & 0x01) == 0)
+	    break;
+	wait_ms(10);
+	count++;
+	if (count > 10)
+	    break;
+
+    }
+    return DataReady;
+}
+
+
+static void spca504B_WaitCmdStatus(struct usb_spca50x *spca50x)
+{
+    __u8 DataReady = 0;
+    int ReqDone;
+    int count = 0;
+    while (1) {
+	spca5xxRegRead(spca50x->dev, 0x21, 0, 1, &DataReady, 1);
+
+	if (DataReady) {
+	    DataReady = 0;
+	    spca5xxRegWrite(spca50x->dev, 0x21, 0, 1, &DataReady, 1);
+	    spca5xxRegRead(spca50x->dev, 0x21, 0, 1, &DataReady, 1);
+	    ReqDone = spca504B_PollingDataReady(spca50x->dev);
+	    break;
+	}
+	wait_ms(10);
+	count++;
+	if (count > 50)
+	    break;
+
+    }
+    return;
+}
+
+
+static void spca504B_setQtable(struct usb_spca50x *spca50x)
+{
+    __u8 Data = 3;
+    int rc;
+    spca5xxRegWrite(spca50x->dev, 0x26, 0, 0, &Data, 1);
+    spca5xxRegRead(spca50x->dev, 0x26, 0, 0, &Data, 1);
+    rc = spca504B_PollingDataReady(spca50x->dev);
+    return;
+}
+static void sp5xx_initContBrigHueRegisters(struct usb_spca50x *spca50x)
+{
+    int rc;
+    int pollreg = 1;
+    switch (spca50x->bridge) {
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+	pollreg = 0;
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x21a7, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 0x20, 0x21a8, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x21ad, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 1, 0x21ac, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 0x20, 0x21ae, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x21a3, NULL, 0);
+	break;
+    case BRIDGE_SPCA536:
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x20f0, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 0x21, 0x20f1, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 0x40, 0x20f5, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 1, 0x20f4, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 0x40, 0x20f6, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0, 0, 0x2089, NULL, 0);
+	break;
+    }
+    if (pollreg)
+	rc = spca504B_PollingDataReady(spca50x->dev);
+    return;
+}
+static int sp5xxfw2_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum,int *datalength)
+{
+	switch (spca50x->bridge){
+	case BRIDGE_SPCA533:
+	    {
+		if (cdata[0] == SPCA50X_SEQUENCE_DROP) {
+		    if (cdata[1] == 0x01) {
+		        *iPix = SPCA533_OFFSET_DATA;
+		        *datalength -= *iPix;
+			return 0;
+		    } else {
+			/* drop packet */
+			return -1;
+		    }
+		} else {
+		     *iPix = 1;
+		     *datalength -= *iPix;
+		        return (seqnum+1);
+		}
+	    }
+	    break;
+	case BRIDGE_SPCA536:
+	    {
+		if (cdata[0] == SPCA50X_SEQUENCE_DROP) {
+		        *iPix = SPCA536_OFFSET_DATA;
+		        *datalength -= *iPix;
+		    return 0;
+		} else {
+		     *iPix = 2;
+		     *datalength -= *iPix;
+		    return (seqnum+1);
+		}
+	    }
+	    break;
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504B:
+	        switch (cdata[0]) {
+		case 0xfe:
+		        *iPix =SPCA50X_OFFSET_DATA;
+		        *datalength -= *iPix;
+		    return 0;
+		    break;
+		case SPCA50X_SEQUENCE_DROP:
+		    /* drop packet */
+		    return -1;
+		default:
+		     *iPix = 1;
+		     *datalength -= *iPix;
+		    return (seqnum+1);
+		    break;
+		}
+	break;
+	case BRIDGE_SPCA504C:
+	    {
+		switch (cdata[0]) {
+		case 0xfe:
+		        *iPix = SPCA504_PCCAM600_OFFSET_DATA;
+		        *datalength -= *iPix;
+		    return 0;
+		    break;
+		case SPCA50X_SEQUENCE_DROP:
+		    /* drop packet */
+		    return -1;
+		default:
+		     *iPix = 1;
+		     *datalength -= *iPix;
+		    return (seqnum+1);
+		    break;
+		}
+	    }
+	    break;
+	 default:
+	 return -1;
+	 break;
+	}
+}
+#endif				//SP5XXFW2
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/spca500.dat linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/spca500.dat
--- linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/spca500.dat	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/spca500.dat	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,173 @@
+
+#if 0
+static __u16 spca500_read_stats[][3] = {
+    {0x0c, 0x0000, 0x0000},
+    {0x30, 0x03fd, 0x0001},
+    /* possible values for following call: 0x01b3, 0x01e6, 0x01f7, 0x0218 */
+    {0x30, 0x01b3, 0x0002},
+    /* possible values for following call: 0x0000, 0x0001, 0x0002 */
+    {0x30, 0x0000, 0x0003},
+    {0x30, 0x003b, 0x0004},
+    /* possible values for following call: 0x00aa, 0x00e0 */
+    {0x30, 0x00e0, 0x0005},
+    {0x30, 0x0001, 0x0006},
+    {0x30, 0x0080, 0x0007},
+    {0x30, 0x0004, 0x0000},
+    {0, 0, 0}
+};
+#endif
+
+static __u16 spca500_visual_defaults[][3] = {
+    {0x00, 0x0003, 0x816b},	/* SSI not active sync with vsync,
+				 * hue (H byte) = 0,
+				 * saturation/hue enable,
+				 * brightness/contrast enable.
+				 */
+    {0x00, 0x0000, 0x8167},	/* brightness = 0 */
+    {0x00, 0x0020, 0x8168},	/* contrast = 0 */
+    {0x00, 0x0003, 0x816b},	/* SSI not active sync with vsync,
+				 * hue (H byte) = 0, saturation/hue enable,
+				 * brightness/contrast enable.
+				 * was 0x0003, now 0x0000.
+				 */
+    {0x00, 0x0000, 0x816a},	/* hue (L byte) = 0 */
+    {0x00, 0x0020, 0x8169},	/* saturation = 0x20 */
+    {0x00, 0x0050, 0x8157},	/* edge gain high threshold */
+    {0x00, 0x0030, 0x8158},	/* edge gain low threshold */
+    {0x00, 0x0028, 0x8159},	/* edge bandwidth high threshold */
+    {0x00, 0x000a, 0x815a},	/* edge bandwidth low threshold */
+    {0x00, 0x0001, 0x8202},	/* clock rate compensation = 1/25 sec/frame */
+    {0x0c, 0x0004, 0x0000},
+    /* set interface */
+
+    {0, 0, 0}
+};
+static __u16 Clicksmart510_defaults[][3] = {
+    {0x00, 0x00, 0x8211},
+    {0x00, 0x01, 0x82c0},
+    {0x00, 0x10, 0x82cb},
+    {0x00, 0x0f, 0x800d},
+    {0x00, 0x82, 0x8225},
+    {0x00, 0x21, 0x8228},
+    {0x00, 0x00, 0x8203},
+    {0x00, 0x00, 0x8204},
+    {0x00, 0x08, 0x8205},
+    {0x00, 0xf8, 0x8206},
+    {0x00, 0x28, 0x8207},
+    {0x00, 0xa0, 0x8208},
+    {0x00, 0x08, 0x824a},
+    {0x00, 0x08, 0x8214},
+    {0x00, 0x80, 0x82c1},
+    {0x00, 0x00, 0x82c2},
+    {0x00, 0x00, 0x82ca},
+    {0x00, 0x80, 0x82c1},
+    {0x00, 0x04, 0x82c2},
+    {0x00, 0x00, 0x82ca},
+    {0x00, 0xfc, 0x8100},
+    {0x00, 0xfc, 0x8105},
+    {0x00, 0x30, 0x8101},
+    {0x00, 0x00, 0x8102},
+    {0x00, 0x00, 0x8103},
+    {0x00, 0x66, 0x8107},
+    {0x00, 0x00, 0x816b},
+    {0x00, 0x00, 0x8155},
+    {0x00, 0x01, 0x8156},
+    {0x00, 0x60, 0x8157},
+    {0x00, 0x40, 0x8158},
+    {0x00, 0x0a, 0x8159},
+    {0x00, 0x06, 0x815a},
+    {0x00, 0x00, 0x813f},
+    {0x00, 0x00, 0x8200},
+    {0x00, 0x19, 0x8201},
+    {0x00, 0x00, 0x82c1},
+    {0x00, 0xa0, 0x82c2},
+    {0x00, 0x00, 0x82ca},
+    {0x00, 0x00, 0x8117},
+    {0x00, 0x00, 0x8118},
+    {0x00, 0x65, 0x8119},
+    {0x00, 0x00, 0x811a},
+    {0x00, 0x00, 0x811b},
+    {0x00, 0x55, 0x811c},
+    {0x00, 0x65, 0x811d},
+    {0x00, 0x55, 0x811e},
+    {0x00, 0x16, 0x811f},
+    {0x00, 0x19, 0x8120},
+    {0x00, 0x80, 0x8103},
+    {0x00, 0x83, 0x816b},
+    {0x00, 0x25, 0x8168},
+    {0x00, 0x01, 0x820f},
+    {0x00, 0xff, 0x8115},
+    {0x00, 0x48, 0x8116},
+    {0x00, 0x50, 0x8151},
+    {0x00, 0x40, 0x8152},
+    {0x00, 0x78, 0x8153},
+    {0x00, 0x40, 0x8154},
+    {0x00, 0x00, 0x8167},
+    {0x00, 0x20, 0x8168},
+    {0x00, 0x00, 0x816a},
+    {0x00, 0x03, 0x816b},
+    {0x00, 0x20, 0x8169},
+    {0x00, 0x60, 0x8157},
+    {0x00, 0x00, 0x8190},
+    {0x00, 0x00, 0x81a1},
+    {0x00, 0x00, 0x81b2},
+    {0x00, 0x27, 0x8191},
+    {0x00, 0x27, 0x81a2},
+    {0x00, 0x27, 0x81b3},
+    {0x00, 0x4b, 0x8192},
+    {0x00, 0x4b, 0x81a3},
+    {0x00, 0x4b, 0x81b4},
+    {0x00, 0x66, 0x8193},
+    {0x00, 0x66, 0x81a4},
+    {0x00, 0x66, 0x81b5},
+    {0x00, 0x79, 0x8194},
+    {0x00, 0x79, 0x81a5},
+    {0x00, 0x79, 0x81b6},
+    {0x00, 0x8a, 0x8195},
+    {0x00, 0x8a, 0x81a6},
+    {0x00, 0x8a, 0x81b7},
+    {0x00, 0x9b, 0x8196},
+    {0x00, 0x9b, 0x81a7},
+    {0x00, 0x9b, 0x81b8},
+    {0x00, 0xa6, 0x8197},
+    {0x00, 0xa6, 0x81a8},
+    {0x00, 0xa6, 0x81b9},
+    {0x00, 0xb2, 0x8198},
+    {0x00, 0xb2, 0x81a9},
+    {0x00, 0xb2, 0x81ba},
+    {0x00, 0xbe, 0x8199},
+    {0x00, 0xbe, 0x81aa},
+    {0x00, 0xbe, 0x81bb},
+    {0x00, 0xc8, 0x819a},
+    {0x00, 0xc8, 0x81ab},
+    {0x00, 0xc8, 0x81bc},
+    {0x00, 0xd2, 0x819b},
+    {0x00, 0xd2, 0x81ac},
+    {0x00, 0xd2, 0x81bd},
+    {0x00, 0xdb, 0x819c},
+    {0x00, 0xdb, 0x81ad},
+    {0x00, 0xdb, 0x81be},
+    {0x00, 0xe4, 0x819d},
+    {0x00, 0xe4, 0x81ae},
+    {0x00, 0xe4, 0x81bf},
+    {0x00, 0xed, 0x819e},
+    {0x00, 0xed, 0x81af},
+    {0x00, 0xed, 0x81c0},
+    {0x00, 0xf7, 0x819f},
+    {0x00, 0xf7, 0x81b0},
+    {0x00, 0xf7, 0x81c1},
+    {0x00, 0xff, 0x81a0},
+    {0x00, 0xff, 0x81b1},
+    {0x00, 0xff, 0x81c2},
+    {0x00, 0x03, 0x8156},
+    {0x00, 0x00, 0x8211},
+    {0x00, 0x20, 0x8168},
+    {0x00, 0x01, 0x8202},
+    {0x00, 0x30, 0x8101},
+    {0x00, 0x00, 0x8111},
+    {0x00, 0x00, 0x8112},
+    {0x00, 0x00, 0x8113},
+    {0x00, 0x00, 0x8114},
+    {0, 0, 0}
+};
+ 
diff -ruN linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/spca500_init.h linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/spca500_init.h
--- linux-2.6.21/drivers/media/video/gspca/Sunplus-jpeg/spca500_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Sunplus-jpeg/spca500_init.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,655 @@
+/*
+ * SPCA500 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA500_INIT_H
+#define SPCA500_INIT_H
+/* Frame packet header offsets for the spca500 */
+#define SPCA500_OFFSET_PADDINGLB 2
+#define SPCA500_OFFSET_PADDINGHB 3
+#define SPCA500_OFFSET_MODE      4
+#define SPCA500_OFFSET_IMGWIDTH  5
+#define SPCA500_OFFSET_IMGHEIGHT 6
+#define SPCA500_OFFSET_IMGMODE   7
+#define SPCA500_OFFSET_QTBLINDEX 8
+#define SPCA500_OFFSET_FRAMSEQ   9
+#define SPCA500_OFFSET_CDSPINFO  10
+#define SPCA500_OFFSET_GPIO      11
+#define SPCA500_OFFSET_AUGPIO    12
+#define SPCA500_OFFSET_DATA      16
+#include "spca500.dat"
+/*******************     Camera Interface   *********************/
+static __u16 spca500_getbrightness(struct usb_spca50x *spca50x);
+static __u16 spca500_getcontrast(struct usb_spca50x *spca50x);
+static __u16 spca500_getcolors(struct usb_spca50x *spca50x);
+static void spca500_setbrightness(struct usb_spca50x *spca50x);
+static void spca500_setcontrast(struct usb_spca50x *spca50x);
+static void spca500_setcolors(struct usb_spca50x *spca50x);
+static int spca500_init(struct usb_spca50x *spca50x);
+static void spca500_start(struct usb_spca50x *spca50x);
+static void spca500_stopN(struct usb_spca50x *spca50x);
+static void spca500_stop0(struct usb_spca50x *spca50x);
+static int spca500_config(struct usb_spca50x *spca50x);
+static void spca500_shutdown(struct usb_spca50x *spca50x);
+static void spca500_setAutobright(struct usb_spca50x *spca50x);
+static void spca500_setquality(struct usb_spca50x *spca50x);
+static int spca500_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame * frame,unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/****************************************************************/
+static void spca500_stop0(struct usb_spca50x *spca50x){}
+static void spca500_shutdown(struct usb_spca50x *spca50x){}
+static void spca500_setAutobright(struct usb_spca50x *spca50x){}
+static void spca500_setquality(struct usb_spca50x *spca50x){}
+/****************************************************************/
+static void spca500_clksmart310_init(struct usb_spca50x *spca50x);
+static void spca500_reinit(struct usb_spca50x *spca50x);
+static int spca500_full_reset(struct usb_spca50x *spca50x);
+/****************************************************************/
+static struct cam_operation fspca500 = {
+ 	.initialize = spca500_init,
+	.configure = spca500_config,
+	.start = spca500_start,
+	.stopN = spca500_stopN,
+	.stop0 = spca500_stop0,
+	.get_bright = spca500_getbrightness,
+	.set_bright = spca500_setbrightness,
+	.get_contrast = spca500_getcontrast,
+	.set_contrast = spca500_setcontrast,
+	.get_colors = spca500_getcolors,
+	.set_colors = spca500_setcolors,
+	.set_autobright = spca500_setAutobright,
+	.set_quality = spca500_setquality,
+	.cam_shutdown = spca500_shutdown,
+	.sof_detect = spca500_sofdetect,
+ };
+static __u16 spca500_getbrightness(struct usb_spca50x *spca50x)
+{
+	   spca50x->brightness = (spca50x_reg_read(spca50x->dev, 0x00, 0x8167, 1)+128) << 8;
+	    
+return spca50x->brightness;
+}
+static __u16 spca500_getcontrast(struct usb_spca50x *spca50x)
+{
+            spca50x->contrast = spca50x_reg_read(spca50x->dev, 0x0, 0x8168, 1) << 10;
+return spca50x->contrast;
+}
+static __u16 spca500_getcolors(struct usb_spca50x *spca50x)
+{
+            spca50x->colour = spca50x_reg_read(spca50x->dev, 0x0, 0x8169, 1) << 10;
+return spca50x->colour;
+}
+static void spca500_setbrightness(struct usb_spca50x *spca50x)
+{
+	  spca50x_reg_write(spca50x->dev, 0x00, 0x8167,(__u8) ((spca50x->brightness >> 8)-128));
+}
+static void spca500_setcontrast(struct usb_spca50x *spca50x)
+{
+          spca50x_reg_write(spca50x->dev, 0x00, 0x8168, (spca50x->contrast >> 10));
+}
+static void spca500_setcolors(struct usb_spca50x *spca50x)
+{
+          spca50x_reg_write(spca50x->dev, 0x00, 0x8169, (spca50x->colour >> 10));
+}
+static int spca500_init(struct usb_spca50x *spca50x)
+{
+	    /* initialisation of spca500 based cameras is deferred */
+	    PDEBUG(2, "Initializing SPCA500 started");
+	    if (spca50x->desc == LogitechClickSmart310) {
+		spca500_clksmart310_init(spca50x);
+	    } else {
+		//spca500_initialise(spca50x);
+	    }
+	    PDEBUG(2, "Initializing SPCA500 finished");
+return 0;
+}
+static void spca500_stopN(struct usb_spca50x *spca50x)
+{
+	int err;
+	__u8 data = 0;
+    spca50x_reg_write(spca50x->dev, 0, 0x8003, 0x00);
+    /* switch to video camera mode */
+    err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x8000, &data, 1);
+    PDEBUG(0, "Stop  SPCA500 finished reg8000 = 0x%2X",data);
+}
+static int spca500_config(struct usb_spca50x *spca50x)
+{
+   memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+   if( spca50x->desc != LogitechClickSmart310) {
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1023;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 0;
+   
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1023;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 0;
+    
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 1;
+    spca50x->mode_cam[SIF].mode = 0;
+    
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 1;
+    
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 1;
+    
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 1;
+    spca50x->mode_cam[QSIF].mode = 1;
+    } else {
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 0;
+    
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 1;
+    spca50x->mode_cam[CIF].mode = 0;
+    
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 0;
+    
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 1;
+    }
+    spca50x->qindex = 5;
+  return 0;
+}
+/***************************************************************************/
+static void spca500_ping310(struct usb_spca50x *spca50x)
+{
+    __u8 Data[2] = { 0, 0 };
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x0d04, Data, 2);
+    PDEBUG(5, "ClickSmart310 ping 0x0d04 0x%02X  0x%02X ", Data[0],
+	   Data[1]);
+}
+static int spca500_synch310(struct usb_spca50x *spca50x)
+{
+/* Synchro the Bridge with sensor */
+/* Maybe that will work on all spca500 chip */
+/* because i only own a clicksmart310 try for that chip */
+/* using spca50x_set_packet_size() cause an Ooops here */
+/* usb_set_interface from kernel 2.6.x clear all the urb stuff */
+/* up-port the same feature as in 2.4.x kernel */
+
+    __u8 Data;
+
+
+    if (spca_set_interface(spca50x->dev, spca50x->iface, 0) < 0) {
+	err("Set packet size: set interface error");
+	goto error;
+    }
+    spca500_ping310(spca50x);
+
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x0d00, &Data, 1);
+
+    /* need alt setting here */
+    PDEBUG(5, "ClickSmart310 sync pipe %d altsetting %d ",
+	   spca50x->pipe_size, spca50x->alt);
+    /* Windoze use pipe with altsetting 6 why 7 here */
+    if (spca_set_interface(spca50x->dev, spca50x->iface, spca50x->alt) < 0) {
+	err("Set packet size: set interface error");
+
+	goto error;
+
+    }
+
+    return 0;
+  error:
+
+    return -EBUSY;
+}
+
+static void spca500_clksmart310_init(struct usb_spca50x *spca50x)
+{
+    __u8 Data[2] = { 0, 0 };
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x0d05, Data, 2);
+    PDEBUG(5, "ClickSmart310 init 0x0d05 0x%02X  0x%02X ", Data[0],
+	   Data[1]);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8167, 0x5a);
+    spca500_ping310(spca50x);
+
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8168, 0x22);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x816a, 0xc0);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x816b, 0x0b);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8169, 0x25);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8157, 0x5b);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8158, 0x5b);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x813f, 0x03);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8151, 0x4a);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8153, 0x78);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x0d01, 0x04);	//00 for adjust shutter
+    spca50x_reg_write(spca50x->dev, 0x00, 0x0d02, 0x01);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8169, 0x25);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x0d01, 0x02);
+}
+
+static void spca500_reinit(struct usb_spca50x *spca50x)
+{
+    int err;
+    __u8 Data;
+
+    // some unknow command from Aiptek pocket dv and family300
+
+    spca50x_reg_write(spca50x->dev, 0x00, 0x0d01, 0x01);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x0d03, 0x00);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x0d02, 0x01);
+
+    /* enable drop packet */
+    spca50x_reg_write(spca50x->dev, 0x00, 0x850a, 0x0001);
+
+    err =
+	spca50x_setup_qtable(spca50x, 0x00, 0x8800, 0x8840,
+			     qtable_pocketdv);
+    if (err < 0) {
+	PDEBUG(2, "spca50x_setup_qtable failed on init");
+    }
+    /* set qtable index */
+    spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 2);
+    /* family cam Quicksmart stuff */
+    spca50x_reg_write(spca50x->dev, 0x00, 0x800a, 0x00);
+    //Set agc transfer: synced inbetween frames
+    spca50x_reg_write(spca50x->dev, 0x00, 0x820f, 0x01);
+    //Init SDRAM - needed for SDRAM access
+    spca50x_reg_write(spca50x->dev, 0x00, 0x870a, 0x04);
+    /*Start init sequence or stream */
+
+    spca50x_reg_write(spca50x->dev, 0, 0x8003, 0x00);
+    /* switch to video camera mode */
+    err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+    wait_ms(2000);
+    if (spca50x_reg_readwait(spca50x->dev, 0, 0x8000, 0x44) != 0)
+
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x816b, &Data, 1);
+    spca50x_reg_write(spca50x->dev, 0x00, 0x816b, Data);
+
+}
+static void spca500_setmode(struct usb_spca50x *spca50x , __u8 xmult, __u8 ymult)
+{
+	/* set x multiplier */
+	spca50x_reg_write(spca50x->dev, 0, 0x8001,xmult);
+
+	/* set y multiplier */
+	spca50x_reg_write(spca50x->dev, 0, 0x8002,ymult);
+
+	/* use compressed mode, VGA, with mode specific subsample */
+	spca50x_reg_write(spca50x->dev, 0, 0x8003,spca50x->mode << 4);
+}
+static void spca500_start(struct usb_spca50x *spca50x)
+{
+
+    int err;
+    __u8 Data;
+    __u8 xmult, ymult;
+    
+   if( spca50x->desc == LogitechClickSmart310){
+   	xmult = 0x16;
+	ymult = 0x12;
+   } else {
+        xmult = 0x28;
+	ymult = 0x1e;
+   }
+    /* is there a sensor here ? */
+    spca5xxRegRead(spca50x->dev, 0, 0, 0x8a04, &Data, 1);
+    PDEBUG(0, "Spca500 Sensor Address  0x%02X ", Data);
+PDEBUG(0, "Spca500 mode %d ,Xmult 0x%02X,  Ymult  0x%02X ", spca50x->mode,xmult,ymult);
+    /* setup qtable */
+    switch (spca50x->desc) {
+    case LogitechClickSmart310:
+	 spca500_setmode(spca50x,xmult,ymult);
+	/* enable drop packet */
+	if ((err =
+	     spca50x_reg_write(spca50x->dev, 0x00, 0x850a, 0x0001)) < 0) {
+	    PDEBUG(2, "failed to enable drop packet");
+
+	}
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 3);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write failed");
+
+	}
+	err = spca50x_setup_qtable(spca50x,
+				   0x00, 0x8800, 0x8840,
+				   qtable_creative_pccam);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_setup_qtable failed");
+
+	}
+	//Init SDRAM - needed for SDRAM access
+	spca50x_reg_write(spca50x->dev, 0x00, 0x870a, 0x04);
+
+
+
+	/* switch to video camera mode */
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write camera mode failed");
+
+	}
+	wait_ms(500);
+	if (spca50x_reg_readwait(spca50x->dev, 0, 0x8000, 0x44) != 0) {
+	    PDEBUG(2, "spca50x_reg_readwait() failed");
+
+	}
+
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x816b, &Data, 1);
+	spca50x_reg_write(spca50x->dev, 0x00, 0x816b, Data);
+
+	err = spca500_synch310(spca50x);
+
+	spca50x_write_vector(spca50x, spca500_visual_defaults);
+ spca500_setmode(spca50x,xmult,ymult);
+	/* enable drop packet */
+	if ((err =
+	     spca50x_reg_write(spca50x->dev, 0x00, 0x850a, 0x0001)) < 0) {
+	    PDEBUG(2, "failed to enable drop packet");
+
+	}
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 3);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write failed");
+
+	}
+	err = spca50x_setup_qtable(spca50x,
+				   0x00, 0x8800, 0x8840,
+				   qtable_creative_pccam);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_setup_qtable failed");
+
+	}
+	//Init SDRAM - needed for SDRAM access
+	spca50x_reg_write(spca50x->dev, 0x00, 0x870a, 0x04);
+
+
+	/* switch to video camera mode */
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write camera mode failed");
+
+	}
+
+	if (spca50x_reg_readwait(spca50x->dev, 0, 0x8000, 0x44) != 0) {
+	    PDEBUG(2, "spca50x_reg_readwait() failed");
+
+	}
+
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x816b, &Data, 1);
+	spca50x_reg_write(spca50x->dev, 0x00, 0x816b, Data);
+
+	break;
+
+    case CreativePCCam300:	/* Creative PC-CAM 300 640x480 CCD */
+    case IntelPocketPCCamera:	/* FIXME: Temporary fix for Intel Pocket PC Camera - NWG (Sat 29th March 2003) */
+
+	/* do a full reset */
+	if ((err = spca500_full_reset(spca50x)) < 0) {
+	    PDEBUG(2, "spca500_full_reset failed");
+
+	}
+	
+	/* enable drop packet */
+	if ((err =
+	     spca50x_reg_write(spca50x->dev, 0x00, 0x850a, 0x0001)) < 0) {
+	    PDEBUG(2, "failed to enable drop packet");
+
+	}
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 3);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write failed");
+
+	}
+	err = spca50x_setup_qtable(spca50x,
+				   0x00, 0x8800, 0x8840,
+				   qtable_creative_pccam);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_setup_qtable failed");
+
+	}
+ spca500_setmode(spca50x,xmult,ymult);
+	spca50x_reg_write(spca50x->dev, 0x20, 0x0001, 0x0004);
+
+	/* switch to video camera mode */
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write camera mode failed");
+
+	}
+
+	if (spca50x_reg_readwait(spca50x->dev, 0, 0x8000, 0x44) != 0) {
+	    PDEBUG(2, "spca50x_reg_readwait() failed");
+
+	}
+
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x816b, &Data, 1);
+	spca50x_reg_write(spca50x->dev, 0x00, 0x816b, Data);
+
+	//spca50x_write_vector(spca50x, spca500_visual_defaults);
+
+	break;
+    case KodakEZ200:		/* Kodak EZ200 */
+
+	/* do a full reset */
+	if ((err = spca500_full_reset(spca50x)) < 0) {
+	    PDEBUG(2, "spca500_full_reset failed");
+
+	}
+	/* enable drop packet */
+	if ((err =
+	     spca50x_reg_write(spca50x->dev, 0x00, 0x850a, 0x0001)) < 0) {
+	    PDEBUG(2, "failed to enable drop packet");
+
+	}
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 0);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write failed");
+
+	}
+	err = spca50x_setup_qtable(spca50x,
+				   0x00, 0x8800, 0x8840,
+				   qtable_kodak_ez200);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_setup_qtable failed");
+
+	}
+	 spca500_setmode(spca50x,xmult,ymult);
+	
+	spca50x_reg_write(spca50x->dev, 0x20, 0x0001, 0x0004);
+
+	/* switch to video camera mode */
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write camera mode failed");
+
+	}
+
+	if (spca50x_reg_readwait(spca50x->dev, 0, 0x8000, 0x44) != 0) {
+	    PDEBUG(2, "spca50x_reg_readwait() failed");
+
+	}
+
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x816b, &Data, 1);
+	spca50x_reg_write(spca50x->dev, 0x00, 0x816b, Data);
+
+	//spca50x_write_vector(spca50x, spca500_visual_defaults);
+
+	break;
+
+    case BenqDC1016:
+    case DLinkDSC350:		/* FamilyCam 300 */
+    case AiptekPocketDV:	/* Aiptek PocketDV */
+    case Gsmartmini:		/*Mustek Gsmart Mini */
+    case MustekGsmart300:	// Mustek Gsmart 300
+    case PalmPixDC85:
+    case Optimedia:
+    case ToptroIndus:
+    case AgfaCl20:
+
+	spca500_reinit(spca50x);
+	spca50x_reg_write(spca50x->dev, 0x00, 0x0d01, 0x01);
+	/* enable drop packet */
+	spca50x_reg_write(spca50x->dev, 0x00, 0x850a, 0x0001);
+
+	err = spca50x_setup_qtable(spca50x,
+				   0x00, 0x8800, 0x8840, qtable_pocketdv);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_setup_qtable failed");
+
+	}
+	spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 2);
+
+	/* familycam Quicksmart pocketDV stuff */
+	spca50x_reg_write(spca50x->dev, 0x00, 0x800a, 0x00);
+	//Set agc transfer: synced inbetween frames
+	spca50x_reg_write(spca50x->dev, 0x00, 0x820f, 0x01);
+	//Init SDRAM - needed for SDRAM access
+	spca50x_reg_write(spca50x->dev, 0x00, 0x870a, 0x04);
+
+ spca500_setmode(spca50x,xmult,ymult);
+	/* switch to video camera mode */
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+	
+	spca50x_reg_readwait(spca50x->dev, 0, 0x8000, 0x44);
+
+	spca5xxRegRead(spca50x->dev, 0, 0, 0x816b, &Data, 1);
+	spca50x_reg_write(spca50x->dev, 0x00, 0x816b, Data);
+
+	break;
+    case LogitechTraveler:
+    case LogitechClickSmart510:
+	{
+
+	    spca50x_reg_write(spca50x->dev, 0x02, 0x00, 0x00);
+	    /* enable drop packet */
+	    if ((err =
+		 spca50x_reg_write(spca50x->dev, 0x00, 0x850a,
+				   0x0001)) < 0) {
+		PDEBUG(2, "failed to enable drop packet");
+
+	    }
+
+	    err = spca50x_setup_qtable(spca50x,
+				       0x00, 0x8800,
+				       0x8840, qtable_creative_pccam);
+	    if (err < 0) {
+		PDEBUG(2, "spca50x_setup_qtable failed");
+
+	    }
+	    err = spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 3);
+	    if (err < 0) {
+		PDEBUG(2, "spca50x_reg_write failed");
+
+	    }
+	    spca50x_reg_write(spca50x->dev, 0x00, 0x800a, 0x00);
+	    //Init SDRAM - needed for SDRAM access
+	    spca50x_reg_write(spca50x->dev, 0x00, 0x870a, 0x04);
+	    
+	     spca500_setmode(spca50x,xmult,ymult);
+	     
+	    /* switch to video camera mode */
+	    err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+	    spca50x_reg_readwait(spca50x->dev, 0, 0x8000, 0x44);
+	    
+	    spca5xxRegRead(spca50x->dev, 0, 0, 0x816b, &Data, 1);
+	    spca50x_reg_write(spca50x->dev, 0x00, 0x816b, Data);
+	    spca50x_write_vector(spca50x, Clicksmart510_defaults);
+	}
+
+	break;
+
+    default:
+    PDEBUG(0, "UNKNOW spca500 WEBCAM  MODEL !! ");
+     break;
+    }
+}
+
+static int spca500_full_reset(struct usb_spca50x *spca50x)
+{
+    int err;
+
+    /* send the reset command */
+    err = spca50x_reg_write(spca50x->dev, 0xe0, 0x0001, 0x0000);
+    if (err < 0) {
+	return err;
+    }
+
+    /* wait for the reset to complete */
+    err = spca50x_reg_readwait(spca50x->dev, 0x06, 0x0000, 0x0000);
+    if (err < 0) {
+	return err;
+    }
+    if ((err =
+	     spca50x_reg_write(spca50x->dev, 0xe0, 0x0000, 0x0000)) < 0) {
+	    PDEBUG(2, "spca50x_reg_write() failed");
+	    return err;
+	}
+	if ((err = spca50x_reg_readwait(spca50x->dev, 0x06, 0, 0)) < 0) {
+	    PDEBUG(2, "spca50x_reg_readwait() failed");
+	    return err;
+	}
+    /* all ok */
+    return 0;
+}
+static int spca500_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+		if (cdata[0] == SPCA50X_SEQUENCE_DROP) {
+		    if (cdata[1] == 0x01) {
+		    *iPix = SPCA500_OFFSET_DATA;
+		    *datalength -= *iPix;
+			return 0;
+		    } else {
+			/* drop packet */
+			return -1;
+		    }
+		} else {
+		*iPix = 1;
+		*datalength -= *iPix;
+		        return (seqnum+1);
+		}
+}
+
+
+
+#endif				/* SPCA500_INIT_H */
diff -ruN linux-2.6.21/drivers/media/video/gspca/Transvision/tv8532.h linux-2.6.21-gspca/drivers/media/video/gspca/Transvision/tv8532.h
--- linux-2.6.21/drivers/media/video/gspca/Transvision/tv8532.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Transvision/tv8532.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,581 @@
+/* 
+ * Quickcam cameras initialization data
+ *
+ */
+
+/*
+   Initialization data: this is the first set-up data written to the
+   device (before the open data).
+ */
+#define TESTCLK 0x10		// reg 0x2c -> 0x12 //10
+#define TESTCOMP 0x90		// reg 0x28 -> 0x80
+#define TESTLINE 0x81		// reg 0x29 -> 0x81
+#define QCIFLINE 0x41		// reg 0x29 -> 0x81
+#define TESTPTL 0x14		// reg 0x2D -> 0x14
+#define TESTPTH 0x01		// reg 0x2E -> 0x01
+#define TESTPTBL 0x12		// reg 0x2F -> 0x0a
+#define TESTPTBH 0x01		// reg 0x30 -> 0x01
+#define ADWIDTHL 0xe8		// reg 0x0c -> 0xe8
+#define ADWIDTHH 0x03		// reg 0x0d -> 0x03
+#define ADHEIGHL 0x90		// reg 0x0e -> 0x91 //93
+#define ADHEIGHH 0x01		// reg 0x0f -> 0x01
+#define EXPOL 0x8f		// reg 0x1c -> 0x8f
+#define EXPOH 0x01		// reg 0x1d -> 0x01
+#define ADCBEGINL 0x44		// reg 0x10 -> 0x46 //47
+#define ADCBEGINH 0x00		// reg 0x11 -> 0x00
+#define ADRBEGINL 0x0a		// reg 0x14 -> 0x0b //0x0c
+#define ADRBEGINH 0x00		// reg 0x15 -> 0x00
+#define TV8532_CMD_UPDATE 0x84
+
+#define TV8532_EEprom_Add 0x03
+#define TV8532_EEprom_DataL 0x04
+#define TV8532_EEprom_DataM 0x05
+#define TV8532_EEprom_DataH 0x06
+#define TV8532_EEprom_TableLength 0x07
+#define TV8532_EEprom_Write 0x08
+#define TV8532_PART_CTRL 0x00
+#define TV8532_CTRL 0x01
+#define TV8532_CMD_EEprom_Open 0x30
+#define TV8532_CMD_EEprom_Close 0x29
+#define TV8532_UDP_UPDATE 0x31
+#define TV8532_GPIO 0x39
+#define TV8532_GPIO_OE 0x3B
+#define TV8532_REQ_RegWrite 0x02
+#define TV8532_REQ_RegRead 0x03
+
+#define TV8532_ADWIDTH_L 0x0C
+#define TV8532_ADWIDTH_H 0x0D
+#define TV8532_ADHEIGHT_L 0x0E
+#define TV8532_ADHEIGHT_H 0x0F
+#define TV8532_EXPOSURE 0x1C
+#define TV8532_QUANT_COMP 0x28
+#define TV8532_MODE_PACKET 0x29
+#define TV8532_SETCLK 0x2C
+#define TV8532_POINT_L 0x2D
+#define TV8532_POINT_H 0x2E
+#define TV8532_POINTB_L 0x2F
+#define TV8532_POINTB_H 0x30
+#define TV8532_BUDGET_L 0x2A
+#define TV8532_BUDGET_H 0x2B
+#define TV8532_VID_L 0x34
+#define TV8532_VID_H 0x35
+#define TV8532_PID_L 0x36
+#define TV8532_PID_H 0x37
+#define TV8532_DeviceID 0x83
+#define TV8532_AD_SLOPE 0x91
+#define TV8532_AD_BITCTRL 0x94
+#define TV8532_AD_COLBEGIN_L 0x10
+#define TV8532_AD_COLBEGIN_H 0x11
+#define TV8532_AD_ROWBEGIN_L 0x14
+#define TV8532_AD_ROWBEGIN_H 0x15
+/**************************************************************/
+static __u16 tv8532_getbrightness(struct usb_spca50x *spca50x);
+static __u16 tv8532_getcontrast(struct usb_spca50x *spca50x);
+static __u16 tv8532_getcolors(struct usb_spca50x *spca50x);
+static void tv8532_setbrightness(struct usb_spca50x *spca50x);
+static void tv8532_setcontrast(struct usb_spca50x *spca50x);
+static void tv8532_setcolors(struct usb_spca50x *spca50x);
+static int tv8532_config(struct usb_spca50x *spca50x);
+static int tv8532_init(struct usb_spca50x *spca50x);
+static void tv8532_start(struct usb_spca50x *spca50x);
+static void tv8532_stopN(struct usb_spca50x *spca50x);
+static void tv8532_stop0(struct usb_spca50x *spca50x);
+static void tv8532_shutdown(struct usb_spca50x *spca50x);
+static void tv8532_setAutobright(struct usb_spca50x *spca50x);
+static void tv8532_setquality(struct usb_spca50x *spca50x);
+static int tv8532_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/**************************************************************/
+static void tv8532_stop0(struct usb_spca50x *spca50x){}
+static void tv8532_shutdown(struct usb_spca50x *spca50x){}
+static void tv8532_setAutobright(struct usb_spca50x *spca50x){}
+static void tv8532_setquality(struct usb_spca50x *spca50x){}
+/**************************************************************/
+static struct cam_operation ftv8532 = {
+ 	.initialize = tv8532_init,
+	.configure = tv8532_config,
+	.start = tv8532_start,
+	.stopN = tv8532_stopN,
+	.stop0 = tv8532_stop0,
+	.get_bright = tv8532_getbrightness,
+	.set_bright = tv8532_setbrightness,
+	.get_contrast = tv8532_getcontrast,
+	.set_contrast = tv8532_setcontrast,
+	.get_colors = tv8532_getcolors,
+	.set_colors = tv8532_setcolors,
+	.set_autobright = tv8532_setAutobright,
+	.set_quality = tv8532_setquality,
+	.cam_shutdown = tv8532_shutdown,
+	.sof_detect = tv8532_sofdetect,
+ };
+ 
+static __u32 tv_8532_eeprom_data[] = {
+/*add dataL dataM dataH */
+    0x00010001, 0x01018011, 0x02050014, 0x0305001c,
+    0x040d001e, 0x0505001f, 0x06050519, 0x0705011b,
+    0x0805091e, 0x090d892e, 0x0a05892f, 0x0b050dd9,
+    0x0c0509f1, 0
+};
+
+static void tv8532_initPictSetting(struct usb_spca50x *spca50x);
+
+static void tv_8532WriteEEprom(struct usb_spca50x *spca50x)
+{
+    int i = 0;
+    __u8 reg, data0, data1, data2, datacmd;
+    struct usb_device *dev = spca50x->dev;
+
+    datacmd = 0xb0;;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_GPIO, &datacmd, 1);
+    datacmd = TV8532_CMD_EEprom_Open;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_CTRL, &datacmd, 1);
+//wait_ms(1);
+    while (tv_8532_eeprom_data[i]) {
+	reg = (tv_8532_eeprom_data[i] & 0xFF000000) >> 24;
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_EEprom_Add,
+			&reg, 1);
+	//wait_ms(1);
+	data0 = (tv_8532_eeprom_data[i] & 0x000000FF);
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_EEprom_DataL,
+			&data0, 1);
+	//wait_ms(1);
+	data1 = (tv_8532_eeprom_data[i] & 0x0000FF00) >> 8;
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_EEprom_DataM,
+			&data1, 1);
+	//wait_ms(1);
+	data2 = (tv_8532_eeprom_data[i] & 0x00FF0000) >> 16;
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_EEprom_DataH,
+			&data2, 1);
+	//wait_ms(1);
+	datacmd = 0;
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_EEprom_Write,
+			&datacmd, 1);
+	//wait_ms(10);
+	i++;
+    }
+    datacmd = i;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_EEprom_TableLength,
+		    &datacmd, 1);
+//wait_ms(1); //udelay(1000);
+    datacmd = TV8532_CMD_EEprom_Close;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_CTRL, &datacmd, 1);
+    wait_ms(10);
+}
+
+static void tv8532_initPictSetting(struct usb_spca50x *spca50x)
+{
+    /* set the initial value of brightness and contrast 
+       on probe */
+   spca50x->brightness = 0x018f<<6;
+    spca50x->contrast = 0x80 << 8;
+}
+
+static __u16 tv8532_getbrightness(struct usb_spca50x *spca50x)
+{
+    spca50x->brightness = 0x018f << 6;
+    return spca50x->brightness;
+}
+static __u16 tv8532_getcontrast(struct usb_spca50x *spca50x)
+{
+    spca50x->contrast = 0x80 << 8;
+    return spca50x->contrast;
+}
+static void tv8532_setbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 value[2] = { 0xfc, 0x01 };
+    __u8 data;
+
+  int brightness = spca50x->brightness >> 6 ;
+    if (brightness < 1)
+	brightness = 1;
+    value[1] = ((brightness >> 8) & 0xff);
+    value[0] = ((brightness) & 0xff);
+    spca5xxRegWrite(spca50x->dev, TV8532_REQ_RegWrite, 0, TV8532_EXPOSURE, value, 2);	//1c
+    data = TV8532_CMD_UPDATE;
+    spca5xxRegWrite(spca50x->dev, TV8532_REQ_RegWrite, 0, TV8532_PART_CTRL,
+		    &data, 1);
+}
+
+static void tv8532_setcontrast(struct usb_spca50x *spca50x)
+{
+#if 0
+    __u8 value[2] = { 0xfc, 0x01 };
+     __u8 data;
+    value[0] = (spca50x->contrast ) & 0xff;
+    value[1] = (spca50x->contrast >> 8 ) & 0xff;
+    spca5xxRegWrite(spca50x->dev, TV8532_REQ_RegWrite, 0, 0x0020, &value[1], 1);
+    spca5xxRegWrite(spca50x->dev, TV8532_REQ_RegWrite, 0, 0x0022, &value[1], 1);
+    spca5xxRegWrite(spca50x->dev, TV8532_REQ_RegWrite, 0, 0x0024, &value[1], 1);
+    spca5xxRegWrite(spca50x->dev, TV8532_REQ_RegWrite, 0, 0x0026, &value[1], 1);
+     data = TV8532_CMD_UPDATE;
+    spca5xxRegWrite(spca50x->dev, TV8532_REQ_RegWrite, 0, TV8532_PART_CTRL,
+		    &data, 1);
+#endif
+}
+
+static __u16 tv8532_getcolors(struct usb_spca50x *spca50x)
+{
+      spca50x->colour = 0;
+    return spca50x->colour;
+}
+
+static void tv8532_setcolors(struct usb_spca50x *spca50x)
+{
+
+}
+
+static int tv8532_config(struct usb_spca50x *spca50x)
+{
+    tv_8532WriteEEprom(spca50x);
+        memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 0;
+    
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 1;
+    spca50x->mode_cam[CIF].mode = 0;
+    
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 0;
+    
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 1;
+    
+    spca50x->mode_cam[QCIF].width = 160;
+    spca50x->mode_cam[QCIF].height = 120;
+    spca50x->mode_cam[QCIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QCIF].pipe = 1023;
+    spca50x->mode_cam[QCIF].method = 1;
+    spca50x->mode_cam[QCIF].mode = 1;
+    return 0;
+}
+
+
+static void tv_8532ReadRegisters(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    __u8 data = 0;
+    //__u16 vid,pid;
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, 0x0001, &data, 1);
+    PDEBUG(1, "register 0x01-> %x", data);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, 0x0002, &data, 1);
+    PDEBUG(1, "register 0x02-> %x", data);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_ADWIDTH_L, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_ADWIDTH_H, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_QUANT_COMP, &data,
+		   1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_MODE_PACKET, &data,
+		   1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_SETCLK, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_POINT_L, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_POINT_H, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_POINTB_L, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_POINTB_H, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_BUDGET_L, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_BUDGET_H, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_VID_L, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_VID_H, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_PID_L, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_PID_H, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_DeviceID, &data, 1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_AD_COLBEGIN_L, &data,
+		   1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_AD_COLBEGIN_H, &data,
+		   1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_AD_ROWBEGIN_L, &data,
+		   1);
+    spca5xxRegRead(dev, TV8532_REQ_RegRead, 0, TV8532_AD_ROWBEGIN_H, &data,
+		   1);
+}
+
+static void tv_8532_setReg(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    __u8 data = 0;
+    __u8 value[2] = { 0, 0 };
+
+    data = ADCBEGINL;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_COLBEGIN_L, &data, 1);	//0x10
+    data = ADCBEGINH;		// also digital gain
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_COLBEGIN_H,
+		    &data, 1);
+    data = TV8532_CMD_UPDATE;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_PART_CTRL, &data, 1);	//0x00<-0x84
+
+    data = 0x0a;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_GPIO_OE, &data, 1);
+	/*******************************************************************/
+    data = ADHEIGHL;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_ADHEIGHT_L, &data, 1);	//0e
+    data = ADHEIGHH;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_ADHEIGHT_H, &data, 1);	//0f
+    value[0] = EXPOL;
+    value[1] = EXPOH;		// 350d 0x014c;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_EXPOSURE, value, 2);	//1c
+    data = ADCBEGINL;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_COLBEGIN_L, &data, 1);	//0x10
+    data = ADCBEGINH;		// also digital gain
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_COLBEGIN_H,
+		    &data, 1);
+    data = ADRBEGINL;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_ROWBEGIN_L, &data, 1);	//0x14
+
+    data = 0x00;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_SLOPE, &data, 1);	//0x91
+    data = 0x02;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_BITCTRL, &data, 1);	//0x94
+
+
+    data = TV8532_CMD_EEprom_Close;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_CTRL, &data, 1);	//0x01
+
+    data = 0x00;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_SLOPE, &data, 1);	//0x91
+    data = TV8532_CMD_UPDATE;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_PART_CTRL, &data, 1);	//0x00<-0x84
+
+}
+
+static void tv_8532_PollReg(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    __u8 data = 0;
+    int i;
+    /* strange polling from tgc */
+    for (i = 0; i < 10; i++) {
+	data = TESTCLK;		//0x48; //0x08;
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_SETCLK, &data, 1);	//0x2c
+	data = TV8532_CMD_UPDATE;
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_PART_CTRL,
+			&data, 1);
+	data = 0x01;
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_UDP_UPDATE, &data, 1);	//0x31
+    }
+}
+
+static int tv8532_init(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    __u8 data = 0;
+    __u8 dataStart = 0;
+    __u8 value[2] = { 0, 0 };
+
+
+    data = 0x32;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_SLOPE, &data,
+		    1);
+
+    data = 0;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_BITCTRL, &data,
+		    1);
+
+    tv_8532ReadRegisters(spca50x);
+
+    data = 0x0b;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_GPIO_OE, &data, 1);
+
+    value[0] = ADHEIGHL;
+    value[1] = ADHEIGHH;	// 401d 0x0169;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_ADHEIGHT_L, value, 2);	//0e
+
+    value[0] = EXPOL;
+    value[1] = EXPOH;		// 350d 0x014c;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_EXPOSURE, value, 2);	//1c
+
+    data = ADWIDTHL;		// 0x20;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_ADWIDTH_L, &data, 1);	//0x0c
+    data = ADWIDTHH;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_ADWIDTH_H, &data, 1);	// 0x0d
+
+	/*******************************************************************/
+    data = TESTCOMP;		//0x72 compressed mode
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_QUANT_COMP, &data, 1);	//0x28
+    data = TESTLINE;		//0x84; // CIF | 4 packet
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_MODE_PACKET, &data, 1);	//0x29
+
+	/*******************************************************************/
+    data = TESTCLK;		//0x48; //0x08;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_SETCLK, &data, 1);	//0x2c
+    data = TESTPTL;		// 0x38; 
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_POINT_L, &data, 1);	//0x2d
+    data = TESTPTH;		// 0x04;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_POINT_H, &data, 1);	// 0x2e
+    dataStart = TESTPTBL;	//0x04; 
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_POINTB_L, &dataStart, 1);	//0x2f
+    data = TESTPTBH;		//0x04; 
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_POINTB_H, &data, 1);	//0x30
+    data = TV8532_CMD_UPDATE;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_PART_CTRL, &data, 1);	//0x00<-0x84
+	/********************************************************************/
+    data = 0x01;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_UDP_UPDATE, &data, 1);	//0x31
+    wait_ms(200);
+    data = 0x00;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_UDP_UPDATE, &data, 1);	//0x31
+	/********************************************************************/
+    tv_8532_setReg(spca50x);
+	/*******************************************************************/
+    data = 0x0b;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_GPIO_OE, &data, 1);
+	/*******************************************************************/
+    tv_8532_setReg(spca50x);
+	/********************************************************************/
+    tv_8532_PollReg(spca50x);
+    return 0;
+}
+
+static void tv8532_start(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    __u8 data = 0;
+    __u8 dataStart = 0;
+    __u8 value[2] = { 0, 0 };
+
+    data = 0x32;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_SLOPE, &data,
+		    1);
+
+    data = 0;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_AD_BITCTRL, &data,
+		    1);
+
+    tv_8532ReadRegisters(spca50x);
+
+    data = 0x0b;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_GPIO_OE, &data, 1);
+
+    value[0] = ADHEIGHL;
+    value[1] = ADHEIGHH;	// 401d 0x0169;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_ADHEIGHT_L, value, 2);	//0e
+    tv8532_initPictSetting(spca50x);
+    //value[0] = EXPOL; value[1] =EXPOH; // 350d 0x014c;
+    //spca5xxRegWrite(dev,TV8532_REQ_RegWrite,0,TV8532_EXPOSURE,value,2); //1c
+    tv8532_setbrightness(spca50x);
+
+    data = ADWIDTHL;		// 0x20;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_ADWIDTH_L, &data, 1);	//0x0c
+    data = ADWIDTHH;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_ADWIDTH_H, &data, 1);	// 0x0d
+
+	/*******************************************************************/
+    data = TESTCOMP;		//0x72 compressed mode
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_QUANT_COMP, &data, 1);	//0x28
+    if (spca50x->mode) {
+	data = QCIFLINE;	//0x84; // CIF | 4 packet
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_MODE_PACKET, &data, 1);	//0x29
+    } else {
+	data = TESTLINE;	//0x84; // CIF | 4 packet
+	spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_MODE_PACKET, &data, 1);	//0x29
+    }
+	/*******************************************************************/
+    data = TESTCLK;		//0x48; //0x08;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_SETCLK, &data, 1);	//0x2c
+    data = TESTPTL;		// 0x38; 
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_POINT_L, &data, 1);	//0x2d
+    data = TESTPTH;		// 0x04;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_POINT_H, &data, 1);	// 0x2e
+    dataStart = TESTPTBL;	//0x04; 
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_POINTB_L, &dataStart, 1);	//0x2f
+    data = TESTPTBH;		//0x04; 
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_POINTB_H, &data, 1);	//0x30
+    data = TV8532_CMD_UPDATE;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_PART_CTRL, &data, 1);	//0x00<-0x84
+	/********************************************************************/
+    data = 0x01;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_UDP_UPDATE, &data, 1);	//0x31
+    wait_ms(200);
+    data = 0x00;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_UDP_UPDATE, &data, 1);	//0x31
+	/********************************************************************/
+    tv_8532_setReg(spca50x);
+	/*******************************************************************/
+    data = 0x0b;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_GPIO_OE, &data, 1);
+	/*******************************************************************/
+    tv_8532_setReg(spca50x);
+	/********************************************************************/
+    tv_8532_PollReg(spca50x);
+
+    data = 0x00;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_UDP_UPDATE, &data, 1);	//0x31
+
+}
+
+static void tv8532_stopN(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    __u8 data = 0;
+
+    data = 0x0b;
+    spca5xxRegWrite(dev, TV8532_REQ_RegWrite, 0, TV8532_GPIO_OE, &data, 1);
+}
+
+static int tv8532_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+		
+		*iPix = 0;
+		PDEBUG(1, "icm532, sequenceNumber: 0x%02x packet %d ",
+		       seqnum, spca50x->packet);
+		/* here we detect 0x80 */
+		if (cdata[0] == 0x80) {
+		    /* counter is limited so we need few header for a frame :) */
+
+		    /* header 0x80 0x80 0x80 0x80 0x80 */
+		    /* packet  00   63  127  145  00   */
+		    /* sof     0     1   1    0    0   */
+		    /* update sequence */
+		    if ((spca50x->packet == 63)
+			|| (spca50x->packet == 127))
+			spca50x->synchro = 1;
+		    /* is there a frame start ? */
+		    if (spca50x->packet >= ((spca50x->hdrheight >> 1) - 1)) {
+			PDEBUG(1, "SOF > %d seqnumber %d packet %d",
+			       spca50x->synchro, seqnum, spca50x->packet);
+			if (!spca50x->synchro) {
+			    spca50x->packet = 0;
+			    return 0; //frame start
+			}
+		    } else {
+
+			if (!spca50x->synchro) {
+			    // Drop packet frame corrupt
+			    PDEBUG(1, "DROP SOF %d seqnumber %d packet %d",
+				   spca50x->synchro, seqnum,
+				   spca50x->packet);
+			    frame->last_packet = 0;
+			    seqnum = 0 ;
+			    spca50x->packet = 0;
+			    return -1;
+			}
+			spca50x->synchro = 1;
+			spca50x->packet++;
+			return (seqnum+1);
+		    }
+
+		} else { 
+		    spca50x->packet++;
+		    return (seqnum+1);
+		}
+   PDEBUG(0, "Warning wrong TV8532 frame detection %d",
+				   spca50x->packet);
+   return -1;
+}
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/cs2102.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/cs2102.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/cs2102.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/cs2102.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,808 @@
+
+#ifndef CS2102USB_H
+#define CS2102USB_H
+/****************************************************************************
+#	 	Century Semiconductor CS2102    library                     #
+# 		Copyright (C) 2004 2005 Michel Xhaard   mxhaard@magic.fr    #
+#               Copyright (C) 2005 Alvaro Salmador naplam33 at msn.com      #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 cs2102_start_data[][3] = {
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x10, 0x0002},
+    {0xa0, 0x00, 0x0010},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x20, 0x0080},
+    {0xa0, 0x21, 0x0081},
+    {0xa0, 0x30, 0x0083},
+    {0xa0, 0x31, 0x0084},
+    {0xa0, 0x32, 0x0085},
+    {0xa0, 0x23, 0x0086},
+    {0xa0, 0x24, 0x0087},
+    {0xa0, 0x25, 0x0088},
+    {0xa0, 0xb3, 0x008b},
+    {0xa0, 0x03, 0x0008},	//00
+    {0xa0, 0x03, 0x0012},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0x02, 0x0092},
+    {0xa0, 0x08, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x11, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x12, 0x0092},
+    {0xa0, 0x89, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x13, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x14, 0x0092},
+    {0xa0, 0xe9, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x22, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0b, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x30, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x31, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x32, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x37, 0x0101},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x10, 0x01ae},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa0, 0x68, 0x018d},
+    {0xa0, 0x00, 0x01ad},
+    {0xa1, 0x01, 0x0002},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},	//00
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+    {0xa0, 0x24, 0x0120},
+    {0xa0, 0x44, 0x0121},
+    {0xa0, 0x64, 0x0122},
+    {0xa0, 0x84, 0x0123},
+    {0xa0, 0x9d, 0x0124},
+    {0xa0, 0xb2, 0x0125},
+    {0xa0, 0xc4, 0x0126},
+    {0xa0, 0xd3, 0x0127},
+    {0xa0, 0xe0, 0x0128},
+    {0xa0, 0xeb, 0x0129},
+    {0xa0, 0xf4, 0x012a},
+    {0xa0, 0xfb, 0x012b},
+    {0xa0, 0xff, 0x012c},
+    {0xa0, 0xff, 0x012d},
+    {0xa0, 0xff, 0x012e},
+    {0xa0, 0xff, 0x012f},
+    {0xa0, 0x18, 0x0130},
+    {0xa0, 0x20, 0x0131},
+    {0xa0, 0x20, 0x0132},
+    {0xa0, 0x1c, 0x0133},
+    {0xa0, 0x16, 0x0134},
+    {0xa0, 0x13, 0x0135},
+    {0xa0, 0x10, 0x0136},
+    {0xa0, 0x0e, 0x0137},
+    {0xa0, 0x0b, 0x0138},
+    {0xa0, 0x09, 0x0139},
+    {0xa0, 0x07, 0x013a},
+    {0xa0, 0x06, 0x013b},
+    {0xa0, 0x00, 0x013c},
+    {0xa0, 0x00, 0x013d},
+    {0xa0, 0x00, 0x013e},
+    {0xa0, 0x01, 0x013f},
+    {0xa0, 0x58, 0x010a},
+    {0xa0, 0xf4, 0x010b},
+    {0xa0, 0xf4, 0x010c},
+    {0xa0, 0xf4, 0x010d},
+    {0xa0, 0x58, 0x010e},
+    {0xa0, 0xf4, 0x010f},
+    {0xa0, 0xf4, 0x0110},
+    {0xa0, 0xf4, 0x0111},
+    {0xa0, 0x58, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x23, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x24, 0x0092},
+    {0xa0, 0x55, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x25, 0x0092},
+    {0xa0, 0xcc, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x21, 0x0092},
+    {0xa0, 0x3f, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x02, 0x0190},
+    {0xa0, 0xab, 0x0191},
+    {0xa0, 0x98, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x30, 0x0196},
+    {0xa0, 0xd4, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x10, 0x01a9},
+    {0xa0, 0x24, 0x01aa},
+    {0xa0, 0x39, 0x001d},
+    {0xa0, 0x70, 0x001e},
+    {0xa0, 0xb0, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0, 0, 0}
+};
+
+
+static __u16 cs2102_scale_data[][3] = {
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x00, 0x0002},
+    {0xa0, 0x00, 0x0010},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x20, 0x0080},
+    {0xa0, 0x21, 0x0081},
+    {0xa0, 0x30, 0x0083},
+    {0xa0, 0x31, 0x0084},
+    {0xa0, 0x32, 0x0085},
+    {0xa0, 0x23, 0x0086},
+    {0xa0, 0x24, 0x0087},
+    {0xa0, 0x25, 0x0088},
+    {0xa0, 0xb3, 0x008b},
+    {0xa0, 0x03, 0x0008},	//00
+    {0xa0, 0x03, 0x0012},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0x02, 0x0092},
+    {0xa0, 0x08, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x11, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x12, 0x0092},
+    {0xa0, 0x87, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x13, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x14, 0x0092},
+    {0xa0, 0xe7, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x22, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0b, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x30, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x31, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x32, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x77, 0x0101},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa0, 0x68, 0x018d},
+    {0xa0, 0x00, 0x01ad},
+    {0xa1, 0x01, 0x0002},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},	//00
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+    {0xa0, 0x24, 0x0120},
+    {0xa0, 0x44, 0x0121},
+    {0xa0, 0x64, 0x0122},
+    {0xa0, 0x84, 0x0123},
+    {0xa0, 0x9d, 0x0124},
+    {0xa0, 0xb2, 0x0125},
+    {0xa0, 0xc4, 0x0126},
+    {0xa0, 0xd3, 0x0127},
+    {0xa0, 0xe0, 0x0128},
+    {0xa0, 0xeb, 0x0129},
+    {0xa0, 0xf4, 0x012a},
+    {0xa0, 0xfb, 0x012b},
+    {0xa0, 0xff, 0x012c},
+    {0xa0, 0xff, 0x012d},
+    {0xa0, 0xff, 0x012e},
+    {0xa0, 0xff, 0x012f},
+    {0xa0, 0x18, 0x0130},
+    {0xa0, 0x20, 0x0131},
+    {0xa0, 0x20, 0x0132},
+    {0xa0, 0x1c, 0x0133},
+    {0xa0, 0x16, 0x0134},
+    {0xa0, 0x13, 0x0135},
+    {0xa0, 0x10, 0x0136},
+    {0xa0, 0x0e, 0x0137},
+    {0xa0, 0x0b, 0x0138},
+    {0xa0, 0x09, 0x0139},
+    {0xa0, 0x07, 0x013a},
+    {0xa0, 0x06, 0x013b},
+    {0xa0, 0x00, 0x013c},
+    {0xa0, 0x00, 0x013d},
+    {0xa0, 0x00, 0x013e},
+    {0xa0, 0x01, 0x013f},
+    {0xa0, 0x58, 0x010a},
+    {0xa0, 0xf4, 0x010b},
+    {0xa0, 0xf4, 0x010c},
+    {0xa0, 0xf4, 0x010d},
+    {0xa0, 0x58, 0x010e},
+    {0xa0, 0xf4, 0x010f},
+    {0xa0, 0xf4, 0x0110},
+    {0xa0, 0xf4, 0x0111},
+    {0xa0, 0x58, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x23, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x24, 0x0092},
+    {0xa0, 0xaa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x25, 0x0092},
+    {0xa0, 0xe6, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x21, 0x0092},
+    {0xa0, 0x3f, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x01, 0x0190},
+    {0xa0, 0x55, 0x0191},
+    {0xa0, 0xcc, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x18, 0x0196},
+    {0xa0, 0x6a, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x10, 0x01a9},
+    {0xa0, 0x24, 0x01aa},
+    {0xa0, 0x3f, 0x001d},
+    {0xa0, 0xa5, 0x001e},
+    {0xa0, 0xf0, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0, 0, 0}
+};
+static __u16 cs2102_50HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000f, 0x0092}, //00,0f,8c,aa
+    {0xa0, 0x008c, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0003, 0x0092}, //00,03,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,ac,aa
+    {0xa0, 0x00ac, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0010, 0x0092}, //00,10,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0011, 0x0092}, //00,11,ac,aa
+    {0xa0, 0x00ac, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001b, 0x0092}, //00,1b,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,ac,aa
+    {0xa0, 0x00ac, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x003f, 0x0191}, //01,91,3f,cc
+    {0xa0, 0x00f0, 0x0192}, //01,92,f0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0042, 0x0197}, //01,97,42,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0010, 0x01a9}, //01,a9,10,cc
+    {0xa0, 0x0024, 0x01aa}, //01,aa,24,cc
+    {0xa0, 0x008c, 0x001d}, //00,1d,8c,cc
+    {0xa0, 0x00b0, 0x001e}, //00,1e,b0,cc
+    {0xa0, 0x00d0, 0x001f}, //00,1f,d0,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 cs2102_50HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000f, 0x0092}, //00,0f,93,aa
+    {0xa0, 0x0093, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0003, 0x0092}, //00,03,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,a1,aa
+    {0xa0, 0x00a1, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0010, 0x0092}, //00,10,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0011, 0x0092}, //00,11,a1,aa
+    {0xa0, 0x00a1, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001b, 0x0092}, //00,1b,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,a1,aa
+    {0xa0, 0x00a1, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x003f, 0x0191}, //01,91,3f,cc
+    {0xa0, 0x00f7, 0x0192}, //01,92,f7,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0083, 0x0197}, //01,97,83,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0010, 0x01a9}, //01,a9,10,cc
+    {0xa0, 0x0024, 0x01aa}, //01,aa,24,cc
+    {0xa0, 0x0093, 0x001d}, //00,1d,93,cc
+    {0xa0, 0x00b0, 0x001e}, //00,1e,b0,cc
+    {0xa0, 0x00d0, 0x001f}, //00,1f,d0,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 cs2102_60HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000f, 0x0092}, //00,0f,5d,aa
+    {0xa0, 0x005d, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0003, 0x0092}, //00,03,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,aa,aa
+    {0xa0, 0x00aa, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0010, 0x0092}, //00,10,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0011, 0x0092}, //00,11,aa,aa
+    {0xa0, 0x00aa, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001b, 0x0092}, //00,1b,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,aa,aa
+    {0xa0, 0x00aa, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x003f, 0x0191}, //01,91,3f,cc
+    {0xa0, 0x00e4, 0x0192}, //01,92,e4,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x003a, 0x0197}, //01,97,3a,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0010, 0x01a9}, //01,a9,10,cc
+    {0xa0, 0x0024, 0x01aa}, //01,aa,24,cc
+    {0xa0, 0x005d, 0x001d}, //00,1d,5d,cc
+    {0xa0, 0x0090, 0x001e}, //00,1e,90,cc
+    {0xa0, 0x00d0, 0x00c8}, //00,c8,d0,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 cs2102_60HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000f, 0x0092}, //00,0f,b7,aa
+    {0xa0, 0x00b7, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0003, 0x0092}, //00,03,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,be,aa
+    {0xa0, 0x00be, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0010, 0x0092}, //00,10,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0011, 0x0092}, //00,11,be,aa
+    {0xa0, 0x00be, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001b, 0x0092}, //00,1b,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,be,aa
+    {0xa0, 0x00be, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x003f, 0x0191}, //01,91,3f,cc
+    {0xa0, 0x00fc, 0x0192}, //01,92,fc,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0069, 0x0197}, //01,97,69,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0010, 0x01a9}, //01,a9,10,cc
+    {0xa0, 0x0024, 0x01aa}, //01,aa,24,cc
+    {0xa0, 0x00b7, 0x001d}, //00,1d,b7,cc
+    {0xa0, 0x00d0, 0x001e}, //00,1e,d0,cc
+    {0xa0, 0x00e8, 0x001f}, //00,1f,e8,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 cs2102_NoFliker[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000f, 0x0092}, //00,0f,59,aa
+    {0xa0, 0x0059, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0003, 0x0092}, //00,03,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0010, 0x0092}, //00,10,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0011, 0x0092}, //00,11,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001b, 0x0092}, //00,1b,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x003f, 0x0191}, //01,91,3f,cc
+    {0xa0, 0x00f0, 0x0192}, //01,92,f0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x0059, 0x001d}, //00,1d,59,cc
+    {0xa0, 0x0090, 0x001e}, //00,1e,90,cc
+    {0xa0, 0x00c8, 0x001f}, //00,1f,c8,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 cs2102_NoFlikerScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000f, 0x0092}, //00,0f,59,aa
+    {0xa0, 0x0059, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0003, 0x0092}, //00,03,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0010, 0x0092}, //00,10,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0011, 0x0092}, //00,11,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001b, 0x0092}, //00,1b,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x003f, 0x0191}, //01,91,3f,cc
+    {0xa0, 0x00f0, 0x0192}, //01,92,f0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x0059, 0x001d}, //00,1d,59,cc
+    {0xa0, 0x0090, 0x001e}, //00,1e,90,cc
+    {0xa0, 0x00c8, 0x001f}, //00,1f,c8,cc
+/*******************/
+{0, 0, 0}
+};
+#endif				//CS2102USB_H
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/hdcs2020.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/hdcs2020.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/hdcs2020.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/hdcs2020.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,1160 @@
+
+/****************************************************************************
+#	 	Agilent HDCS2020 library                                    #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+/* play poker with registers at your own risk !! */
+static __u16 hdcs2020xx_start_data[][3] = {
+    {0xA0, 0x01, 0x0000},
+    {0xA0, 0x03, 0x0008},
+    {0xA0, 0x0E, 0x0010},
+    {0xA0, 0x10, 0x0002},
+    {0xA0, 0x02, 0x0003},
+    {0xA0, 0x80, 0x0004},
+    {0xA0, 0x01, 0x0005},
+    {0xA0, 0xD0, 0x0006},	//D0 ?? E0 did not start
+    {0xA0, 0x01, 0x0001},
+    {0xA0, 0x03, 0x0012},
+    {0xA0, 0x01, 0x0012},
+    {0xA0, 0x08, 0x008D},
+    {0xA0, 0x08, 0x0098},
+    {0xA0, 0x02, 0x009A},
+    {0xA0, 0x08, 0x011A},
+    {0xA0, 0x02, 0x011C},
+    {0xA0, 0x01, 0x009B},
+    {0xA0, 0xD8, 0x009C},
+    {0xA0, 0x02, 0x009D},
+    {0xA0, 0x88, 0x009E},
+    {0xA0, 0x02, 0x0092},
+    {0xA0, 0x02, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x07, 0x0092},
+    {0xA0, 0x06, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x08, 0x0092},
+    {0xA0, 0x02, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x09, 0x0092},
+    {0xA0, 0x06, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0A, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0B, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0C, 0x0092},
+    {0xA0, 0x08, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0D, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x10, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x12, 0x0092},
+    {0xA0, 0x05, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x13, 0x0092},
+    {0xA0, 0x63, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x15, 0x0092},
+    {0xA0, 0x70, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x37, 0x0101},
+    {0xA0, 0x0D, 0x0100},
+    {0xA0, 0x06, 0x0189},
+    {0xA0, 0x00, 0x01AD},
+    {0xA0, 0x03, 0x01C5},
+    {0xA0, 0x13, 0x01CB},
+    {0xA0, 0x08, 0x0250},
+    {0xA0, 0x08, 0x0301},
+    {0xA0, 0x70, 0x018D},
+    {0xA1, 0x01, 0x0002},
+    {0xA1, 0x01, 0x0008},
+    {0xA0, 0x03, 0x0008},
+    {0xA0, 0x04, 0x01C6},
+    {0xA1, 0x01, 0x01C8},
+    {0xA1, 0x01, 0x01C9},
+    {0xA1, 0x01, 0x01CA},
+    {0xA0, 0x07, 0x01CB},
+    {0xA0, 0x11, 0x0120},
+    {0xA0, 0x37, 0x0121},
+    {0xA0, 0x58, 0x0122},
+    {0xA0, 0x79, 0x0123},
+    {0xA0, 0x91, 0x0124},
+    {0xA0, 0xA6, 0x0125},
+    {0xA0, 0xB8, 0x0126},
+    {0xA0, 0xC7, 0x0127},
+    {0xA0, 0xD3, 0x0128},
+    {0xA0, 0xDE, 0x0129},
+    {0xA0, 0xE6, 0x012A},
+    {0xA0, 0xED, 0x012B},
+    {0xA0, 0xF3, 0x012C},
+    {0xA0, 0xF8, 0x012D},
+    {0xA0, 0xFB, 0x012E},
+    {0xA0, 0xFF, 0x012F},
+    {0xA0, 0x26, 0x0130},
+    {0xA0, 0x23, 0x0131},
+    {0xA0, 0x20, 0x0132},
+    {0xA0, 0x1C, 0x0133},
+    {0xA0, 0x16, 0x0134},
+    {0xA0, 0x13, 0x0135},
+    {0xA0, 0x10, 0x0136},
+    {0xA0, 0x0D, 0x0137},
+    {0xA0, 0x0B, 0x0138},
+    {0xA0, 0x09, 0x0139},
+    {0xA0, 0x07, 0x013A},
+    {0xA0, 0x06, 0x013B},
+    {0xA0, 0x05, 0x013C},
+    {0xA0, 0x04, 0x013D},
+    {0xA0, 0x03, 0x013E},
+    {0xA0, 0x02, 0x013F},
+    
+    {0xA0, 0x4C, 0x010A},
+    {0xA0, 0xF5, 0x010B},
+    {0xA0, 0xFF, 0x010C},
+    {0xA0, 0xF9, 0x010D},
+    {0xA0, 0x51, 0x010E},
+    {0xA0, 0xF5, 0x010F},
+    {0xA0, 0xFB, 0x0110},
+    {0xA0, 0xED, 0x0111},
+    {0xA0, 0x5F, 0x0112},
+    
+    {0xA1, 0x01, 0x0180},
+    {0xA0, 0x00, 0x0180},
+    {0xA0, 0x00, 0x0019},
+    {0xA0, 0x20, 0x0087},
+    {0xA0, 0x21, 0x0088},
+    {0xA0, 0x20, 0x0092},
+    {0xA0, 0x04, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x21, 0x0092},
+    {0xA0, 0x3D, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x03, 0x0092},
+    {0xA0, 0x41, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x04, 0x0092},
+    {0xA0, 0x10, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x05, 0x0092},
+    {0xA0, 0x3D, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0E, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0F, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x14, 0x01A9},
+    {0xA0, 0x24, 0x01AA},
+    {0xA0, 0x00, 0x0190},
+    {0xA0, 0x04, 0x0191},
+    {0xA0, 0x3D, 0x0192},
+    {0xA0, 0x00, 0x0195},
+    {0xA0, 0x00, 0x0196},
+    {0xA0, 0x9B, 0x0197},
+    {0xA0, 0x10, 0x018C},
+    {0xA0, 0x20, 0x018F},
+    {0xA0, 0x41, 0x001D},
+    {0xA0, 0x6F, 0x001E},
+    {0xA0, 0xAD, 0x001F},
+    {0xA0, 0xFF, 0x0020},
+    {0xA0, 0x0F, 0x0087},
+    {0xA0, 0x0E, 0x0088},
+    {0xA0, 0x40, 0x0180},
+    {0xA1, 0x01, 0x0195},
+    {0xA1, 0x01, 0x0196},
+    {0xA1, 0x01, 0x0197},
+    {0xA0, 0x3D, 0x0192},
+    {0xA0, 0x04, 0x0191},
+    {0xA0, 0x00, 0x0190},
+    {0xA0, 0x1D, 0x0116},
+    {0xA0, 0x40, 0x0117},
+    {0xA0, 0x85, 0x0118},
+    {0xA1, 0x01, 0x0116},
+    {0xA1, 0x01, 0x0118},
+    {0xA1, 0x01, 0x0180},
+    {0xA0, 0x42, 0x0180},
+    {0xA0, 0x1D, 0x0116},
+    {0xA0, 0x40, 0x0117},
+    {0xA0, 0x85, 0x0118},
+    {0xA1, 0x01, 0x0116},
+    {0xA1, 0x01, 0x0118},
+    //{ 0xA0, 0x02, 0x0008},
+    {0xA0, 0x00, 0x0007},
+    {0, 0, 0}
+};
+
+static __u16 hdcs2020xx_scale_data[][3] = {
+    {0xA0, 0x01, 0x0000},
+    {0xA0, 0x03, 0x0008},
+    {0xA0, 0x0E, 0x0010},
+    {0xA0, 0x00, 0x0002},
+    {0xA0, 0x02, 0x0003},
+    {0xA0, 0x80, 0x0004},
+    {0xA0, 0x01, 0x0005},
+    {0xA0, 0xE0, 0x0006},
+    {0xA0, 0x01, 0x0001},
+    {0xA0, 0x03, 0x0012},
+    {0xA0, 0x01, 0x0012},
+    {0xA0, 0x08, 0x008D},
+    {0xA0, 0x00, 0x0098},
+    {0xA0, 0x03, 0x009A},
+    {0xA0, 0x00, 0x011A},
+    {0xA0, 0x03, 0x011C},
+    {0xA0, 0x01, 0x009B},
+    {0xA0, 0xE6, 0x009C},
+    {0xA0, 0x02, 0x009D},
+    {0xA0, 0x86, 0x009E},
+    {0xA0, 0x02, 0x0092},
+    {0xA0, 0x02, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x07, 0x0092},
+    {0xA0, 0x06, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x08, 0x0092},
+    {0xA0, 0x02, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x09, 0x0092},
+    {0xA0, 0x06, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0A, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0B, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0C, 0x0092},
+    {0xA0, 0x08, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0D, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x10, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x12, 0x0092},
+    {0xA0, 0x05, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x13, 0x0092},
+    {0xA0, 0x63, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x15, 0x0092},
+    {0xA0, 0x70, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0xB7, 0x0101},
+    {0xA0, 0x0D, 0x0100},
+    {0xA0, 0x06, 0x0189},
+    {0xA0, 0x00, 0x01AD},
+    {0xA0, 0x03, 0x01C5},
+    {0xA0, 0x13, 0x01CB},
+    {0xA0, 0x08, 0x0250},
+    {0xA0, 0x08, 0x0301},
+    {0xA0, 0x70, 0x018D},
+    {0xA1, 0x01, 0x0002},
+    {0xA1, 0x01, 0x0008},
+    {0xA0, 0x03, 0x0008},
+    {0xA0, 0x04, 0x01C6},
+    {0xA1, 0x01, 0x01C8},
+    {0xA1, 0x01, 0x01C9},
+    {0xA1, 0x01, 0x01CA},
+    {0xA0, 0x07, 0x01CB},
+    {0xA0, 0x11, 0x0120},
+    {0xA0, 0x37, 0x0121},
+    {0xA0, 0x58, 0x0122},
+    {0xA0, 0x79, 0x0123},
+    {0xA0, 0x91, 0x0124},
+    {0xA0, 0xA6, 0x0125},
+    {0xA0, 0xB8, 0x0126},
+    {0xA0, 0xC7, 0x0127},
+    {0xA0, 0xD3, 0x0128},
+    {0xA0, 0xDE, 0x0129},
+    {0xA0, 0xE6, 0x012A},
+    {0xA0, 0xED, 0x012B},
+    {0xA0, 0xF3, 0x012C},
+    {0xA0, 0xF8, 0x012D},
+    {0xA0, 0xFB, 0x012E},
+    {0xA0, 0xFF, 0x012F},
+    {0xA0, 0x26, 0x0130},
+    {0xA0, 0x23, 0x0131},
+    {0xA0, 0x20, 0x0132},
+    {0xA0, 0x1C, 0x0133},
+    {0xA0, 0x16, 0x0134},
+    {0xA0, 0x13, 0x0135},
+    {0xA0, 0x10, 0x0136},
+    {0xA0, 0x0D, 0x0137},
+    {0xA0, 0x0B, 0x0138},
+    {0xA0, 0x09, 0x0139},
+    {0xA0, 0x07, 0x013A},
+    {0xA0, 0x06, 0x013B},
+    {0xA0, 0x05, 0x013C},
+    {0xA0, 0x04, 0x013D},
+    {0xA0, 0x03, 0x013E},
+    {0xA0, 0x02, 0x013F},
+#if 0    
+    {0xA0, 0x4C, 0x010A},
+    {0xA0, 0xF5, 0x010B},
+    {0xA0, 0xFF, 0x010C},
+    {0xA0, 0xF9, 0x010D},
+    {0xA0, 0x51, 0x010E},
+    {0xA0, 0xF5, 0x010F},
+    {0xA0, 0xFB, 0x0110},
+    {0xA0, 0xED, 0x0111},
+    {0xA0, 0x5F, 0x0112},
+#endif  
+    {0xA0, 0x60, 0x010A},
+    {0xA0, 0xff, 0x010B},
+    {0xA0, 0xff, 0x010C},
+    {0xA0, 0xFf, 0x010D},
+    {0xA0, 0x60, 0x010E},
+    {0xA0, 0xFf, 0x010F},
+    {0xA0, 0xFf, 0x0110},
+    {0xA0, 0xff, 0x0111},
+    {0xA0, 0x60, 0x0112},
+      
+    {0xA1, 0x01, 0x0180},
+    {0xA0, 0x00, 0x0180},
+    {0xA0, 0x00, 0x0019},
+    {0xA0, 0x20, 0x0087},
+    {0xA0, 0x21, 0x0088},
+    {0xA0, 0x20, 0x0092},
+    {0xA0, 0x02, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x21, 0x0092},
+    {0xA0, 0x1B, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x03, 0x0092},
+    {0xA0, 0x44, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x04, 0x0092},
+    {0xA0, 0x08, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x05, 0x0092},
+    {0xA0, 0x1B, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0E, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x0F, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x14, 0x01A9},
+    {0xA0, 0x24, 0x01AA},
+    {0xA0, 0x00, 0x0190},
+    {0xA0, 0x02, 0x0191},
+    {0xA0, 0x1B, 0x0192},
+    {0xA0, 0x00, 0x0195},
+    {0xA0, 0x00, 0x0196},
+    {0xA0, 0x4D, 0x0197},
+    {0xA0, 0x10, 0x018C},
+    {0xA0, 0x20, 0x018F},
+    {0xA0, 0x44, 0x001D},
+    {0xA0, 0x6F, 0x001E},
+    {0xA0, 0xAD, 0x001F},
+    {0xA0, 0xEB, 0x0020},
+    {0xA0, 0x0F, 0x0087},
+    {0xA0, 0x0E, 0x0088},
+    {0xA0, 0x40, 0x0180},
+    {0xA1, 0x01, 0x0195},
+    {0xA1, 0x01, 0x0196},
+    {0xA1, 0x01, 0x0197},
+    {0xA0, 0x1B, 0x0192},
+    {0xA0, 0x02, 0x0191},
+    {0xA0, 0x00, 0x0190},
+    {0xA0, 0x1D, 0x0116},
+    {0xA0, 0x40, 0x0117},
+    {0xA0, 0x99, 0x0118},
+    {0xA1, 0x01, 0x0116},
+    {0xA1, 0x01, 0x0118},
+    {0xA1, 0x01, 0x0180},
+    {0xA0, 0x42, 0x0180},
+    {0xA0, 0x1D, 0x0116},
+    {0xA0, 0x40, 0x0117},
+    {0xA0, 0x99, 0x0118},
+// { 0xA0, 0x02, 0x0008},
+    {0xA0, 0x00, 0x0007},
+    //{ 0xA0, 0x18, 0x00FE},
+    {0, 0, 0}
+};
+static __u16 hdcs2020xb_start_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x11, 0x0002},
+    {0xa0, 0x03, 0x0008},	// qtable 0x05
+    {0xa0, 0x08, 0x0010},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x03, 0x0012},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0xe8, 0x009c},
+    {0xa0, 0x88, 0x009e},
+    {0xa0, 0x1c, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0a, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0b, 0x0092},
+    {0xa0, 0x06, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0c, 0x0092},
+    {0xa0, 0x7b, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0d, 0x0092},
+    {0xa0, 0xa7, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0xfb, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x03, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x09, 0x0092},
+    {0xa0, 0x08, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+
+    {0xa0, 0x0f, 0x0092},	// set sensor gain
+    {0xa0, 0x18, 0x0093},	//0x18
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0092},
+    {0xa0, 0x18, 0x0093},	//0x18
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x11, 0x0092},
+    {0xa0, 0x18, 0x0093},	//0x18
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x12, 0x0092},
+    {0xa0, 0x18, 0x0093},	//0x18
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+
+    {0xa0, 0x15, 0x0092},
+    {0xa0, 0x4e, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x1c, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0xb7, 0x0101},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x70, 0x018d},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa1, 0x01, 0x0002},
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x02, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},	//
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+    {0xa0, 0x13, 0x0120},
+    {0xa0, 0x38, 0x0121},
+    {0xa0, 0x59, 0x0122},
+    {0xa0, 0x79, 0x0123},
+    {0xa0, 0x92, 0x0124},
+    {0xa0, 0xa7, 0x0125},
+    {0xa0, 0xb9, 0x0126},
+    {0xa0, 0xc8, 0x0127},
+    {0xa0, 0xd4, 0x0128},
+    {0xa0, 0xdf, 0x0129},
+    {0xa0, 0xe7, 0x012a},
+    {0xa0, 0xee, 0x012b},
+    {0xa0, 0xf4, 0x012c},
+    {0xa0, 0xf9, 0x012d},
+    {0xa0, 0xfc, 0x012e},
+    {0xa0, 0xff, 0x012f},
+    {0xa0, 0x26, 0x0130},
+    {0xa0, 0x22, 0x0131},
+    {0xa0, 0x20, 0x0132},
+    {0xa0, 0x1c, 0x0133},
+    {0xa0, 0x16, 0x0134},
+    {0xa0, 0x13, 0x0135},
+    {0xa0, 0x10, 0x0136},
+    {0xa0, 0x0d, 0x0137},
+    {0xa0, 0x0b, 0x0138},
+    {0xa0, 0x09, 0x0139},
+    {0xa0, 0x07, 0x013a},
+    {0xa0, 0x06, 0x013b},
+    {0xa0, 0x05, 0x013c},
+    {0xa0, 0x04, 0x013d},
+    {0xa0, 0x03, 0x013e},
+    {0xa0, 0x02, 0x013f},
+ /********************/
+    {0xa0, 0x66, 0x010a},	//66
+    {0xa0, 0xed, 0x010b},	//ed
+    {0xa0, 0xed, 0x010c},	//ed
+    {0xa0, 0xed, 0x010d},	//ed
+    {0xa0, 0x66, 0x010e},	//66
+    {0xa0, 0xed, 0x010f},	//ed
+    {0xa0, 0xed, 0x0110},	//ed
+    {0xa0, 0xed, 0x0111},	//ed
+    {0xa0, 0x66, 0x0112},	//66
+
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x13, 0x0092},
+    {0xa0, 0x31, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x14, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0e, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x19, 0x0092},
+    {0xa0, 0xcd, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x02, 0x0191},
+    {0xa0, 0x62, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x3d, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+ /********************/
+    {0xa0, 0x0c, 0x01a9},	//0x14
+    {0xa0, 0x28, 0x01aa},
+ /********************/
+    {0xa0, 0x04, 0x001d},
+    {0xa0, 0x18, 0x001e},
+    {0xa0, 0x2c, 0x001f},
+    {0xa0, 0x41, 0x0020},
+    {0xa0, 0x60, 0x011d},
+    {0xa0, 0x42, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0, 0, 0}
+};
+static __u16 hdcs2020xb_scale_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x00, 0x0002},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x0010},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x03, 0x0012},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0xe8, 0x009c},
+    {0xa0, 0x88, 0x009e},
+    {0xa0, 0x1c, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0a, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0b, 0x0092},
+    {0xa0, 0x06, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0c, 0x0092},
+    {0xa0, 0x7a, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0d, 0x0092},
+    {0xa0, 0xa7, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0xfb, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x03, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x09, 0x0092},
+    {0xa0, 0x08, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+#if 0
+    {0xa0, 0x0f, 0x0092},	// set sensor gain
+    {0xa0, 0x4f, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0092},
+    {0xa0, 0x4f, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x11, 0x0092},
+    {0xa0, 0x4f, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x12, 0x0092},
+    {0xa0, 0x4f, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+#endif
+    {0xa0, 0x0f, 0x0092},	// original setting
+    {0xa0, 0x18, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0092},
+    {0xa0, 0x18, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x11, 0x0092},
+    {0xa0, 0x18, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x12, 0x0092},
+    {0xa0, 0x18, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+/**********************/
+    {0xa0, 0x15, 0x0092},
+    {0xa0, 0x4e, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x1c, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0xf7, 0x0101},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x70, 0x018d},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa1, 0x01, 0x0002},
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x02, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+    {0xa0, 0x13, 0x0120},
+    {0xa0, 0x38, 0x0121},
+    {0xa0, 0x59, 0x0122},
+    {0xa0, 0x79, 0x0123},
+    {0xa0, 0x92, 0x0124},
+    {0xa0, 0xa7, 0x0125},
+    {0xa0, 0xb9, 0x0126},
+    {0xa0, 0xc8, 0x0127},
+    {0xa0, 0xd4, 0x0128},
+    {0xa0, 0xdf, 0x0129},
+    {0xa0, 0xe7, 0x012a},
+    {0xa0, 0xee, 0x012b},
+    {0xa0, 0xf4, 0x012c},
+    {0xa0, 0xf9, 0x012d},
+    {0xa0, 0xfc, 0x012e},
+    {0xa0, 0xff, 0x012f},
+    {0xa0, 0x26, 0x0130},
+    {0xa0, 0x22, 0x0131},
+    {0xa0, 0x20, 0x0132},
+    {0xa0, 0x1c, 0x0133},
+    {0xa0, 0x16, 0x0134},
+    {0xa0, 0x13, 0x0135},
+    {0xa0, 0x10, 0x0136},
+    {0xa0, 0x0d, 0x0137},
+    {0xa0, 0x0b, 0x0138},
+    {0xa0, 0x09, 0x0139},
+    {0xa0, 0x07, 0x013a},
+    {0xa0, 0x06, 0x013b},
+    {0xa0, 0x05, 0x013c},
+    {0xa0, 0x04, 0x013d},
+    {0xa0, 0x03, 0x013e},
+    {0xa0, 0x02, 0x013f},
+    {0xa0, 0x66, 0x010a},
+    {0xa0, 0xed, 0x010b},
+    {0xa0, 0xed, 0x010c},
+    {0xa0, 0xed, 0x010d},
+    {0xa0, 0x66, 0x010e},
+    {0xa0, 0xed, 0x010f},
+    {0xa0, 0xed, 0x0110},
+    {0xa0, 0xed, 0x0111},
+    {0xa0, 0x66, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+ /**** set exposure ***/
+    {0xa0, 0x13, 0x0092},
+    {0xa0, 0x31, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x14, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0e, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x19, 0x0092},
+    {0xa0, 0xcd, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x02, 0x0191},
+    {0xa0, 0x62, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x3d, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x0c, 0x01a9},
+    {0xa0, 0x28, 0x01aa},
+    {0xa0, 0x04, 0x001d},
+    {0xa0, 0x18, 0x001e},
+    {0xa0, 0x2c, 0x001f},
+    {0xa0, 0x41, 0x0020},
+    {0xa0, 0x60, 0x011d},
+    {0xa0, 0x42, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0, 0, 0}
+};
+static __u16 hdcs2020b_50HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0013, 0x0092}, //00,13,18,aa
+    {0xa0, 0x0018, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0014, 0x0092}, //00,14,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0019, 0x0092}, //00,19,1f,aa
+    {0xa0, 0x001f, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0002, 0x0191}, //01,91,02,cc
+    {0xa0, 0x0076, 0x0192}, //01,92,76,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0046, 0x0197}, //01,97,46,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0028, 0x01aa}, //01,aa,28,cc
+    {0xa0, 0x0005, 0x001d}, //00,1d,05,cc
+    {0xa0, 0x001a, 0x001e}, //00,1e,1a,cc
+    {0xa0, 0x002f, 0x001f}, //00,1f,2f,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 hdcs2020b_50HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0013, 0x0092}, //00,13,18,aa
+    {0xa0, 0x0018, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0014, 0x0092}, //00,14,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,05,aa
+    {0xa0, 0x0005, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0019, 0x0092}, //00,19,1f,aa
+    {0xa0, 0x001f, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0002, 0x0191}, //01,91,02,cc
+    {0xa0, 0x0076, 0x0192}, //01,92,76,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0046, 0x0197}, //01,97,46,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0028, 0x01aa}, //01,aa,28,cc
+    {0xa0, 0x0005, 0x001d}, //00,1d,05,cc
+    {0xa0, 0x001a, 0x001e}, //00,1e,1a,cc
+    {0xa0, 0x002f, 0x001f}, //00,1f,2f,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 hdcs2020b_60HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0013, 0x0092}, //00,13,31,aa
+    {0xa0, 0x0031, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0014, 0x0092}, //00,14,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,04,aa
+    {0xa0, 0x0004, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0019, 0x0092}, //00,19,cd,aa
+    {0xa0, 0x00cd, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0002, 0x0191}, //01,91,02,cc
+    {0xa0, 0x0062, 0x0192}, //01,92,62,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x003d, 0x0197}, //01,97,3d,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0028, 0x01aa}, //01,aa,28,cc
+    {0xa0, 0x0004, 0x001d}, //00,1d,04,cc
+    {0xa0, 0x0018, 0x001e}, //00,1e,18,cc
+    {0xa0, 0x002c, 0x001f}, //00,1f,2c,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 hdcs2020b_60HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0013, 0x0092}, //00,13,31,aa
+    {0xa0, 0x0031, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0014, 0x0092}, //00,14,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,04,aa
+    {0xa0, 0x0004, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0019, 0x0092}, //00,19,cd,aa
+    {0xa0, 0x00cd, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0002, 0x0191}, //01,91,02,cc
+    {0xa0, 0x0062, 0x0192}, //01,92,62,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x003d, 0x0197}, //01,97,3d,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0028, 0x01aa}, //01,aa,28,cc
+    {0xa0, 0x0004, 0x001d}, //00,1d,04,cc
+    {0xa0, 0x0018, 0x001e}, //00,1e,18,cc
+    {0xa0, 0x002c, 0x001f}, //00,1f,2c,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 hdcs2020b_NoFliker[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0013, 0x0092}, //00,13,10,aa
+    {0xa0, 0x0010, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0014, 0x0092}, //00,14,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,04,aa
+    {0xa0, 0x0004, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0019, 0x0092}, //00,19,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0002, 0x0191}, //01,91,02,cc
+    {0xa0, 0x0070, 0x0192}, //01,92,70,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x0004, 0x001d}, //00,1d,04,cc
+    {0xa0, 0x0017, 0x001e}, //00,1e,17,cc
+    {0xa0, 0x002a, 0x001f}, //00,1f,2a,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 hdcs2020b_NoFlikerScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0013, 0x0092}, //00,13,10,aa
+    {0xa0, 0x0010, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0014, 0x0092}, //00,14,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,04,aa
+    {0xa0, 0x0004, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0019, 0x0092}, //00,19,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0002, 0x0191}, //01,91,02,cc
+    {0xa0, 0x0070, 0x0192}, //01,92,70,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x0004, 0x001d}, //00,1d,04,cc
+    {0xa0, 0x0017, 0x001e}, //00,1e,17,cc
+    {0xa0, 0x002a, 0x001f}, //00,1f,2a,cc
+/*******************/
+{0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/hv7131b.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/hv7131b.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/hv7131b.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/hv7131b.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,398 @@
+
+/****************************************************************************
+#	 	Hynix HV7131b library                                       #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 hv7131bxx_start_data[][3] = {
+    {0xA0, 0x01, 0x0000},
+    {0xA0, 0x10, 0x0002},
+    {0xA0, 0x00, 0x0010},
+    {0xA0, 0x01, 0x0001},
+    {0xA0, 0x77, 0x0101},
+    {0xA0, 0x03, 0x0008},	//00
+    {0xA0, 0x03, 0x0012},
+    {0xA0, 0x01, 0x0012},
+    {0xA0, 0x02, 0x0003},
+    {0xA0, 0x80, 0x0004},
+    {0xA0, 0x01, 0x0005},
+    {0xA0, 0xE0, 0x0006},
+    {0xA0, 0x00, 0x0098},
+    {0xA0, 0x00, 0x009A},
+    {0xA0, 0x00, 0x011A},
+    {0xA0, 0x00, 0x011C},
+    {0xA0, 0x30, 0x0092},
+    {0xA0, 0x2D, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x01, 0x0092},
+    {0xA0, 0x05, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x11, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x13, 0x0092},
+// { 0xA0, 0x00, 0x0093},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x14, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x15, 0x0092},
+    {0xA0, 0xE8, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x16, 0x0092},
+    {0xA0, 0x02, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x17, 0x0092},
+    {0xA0, 0x86, 0x0093},	//88
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x31, 0x0092},
+    {0xA0, 0x38, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x32, 0x0092},
+    {0xA0, 0x38, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x33, 0x0092},
+    {0xA0, 0x38, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x5B, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x00, 0x0019},
+    {0xA0, 0x05, 0x0012},
+    {0xA0, 0x0D, 0x0100},
+    {0xA0, 0x68, 0x018D},
+    {0xA0, 0x60, 0x01A8},
+    {0xA0, 0x00, 0x01AD},
+    {0xA0, 0xC0, 0x019B},
+    {0xA0, 0xA0, 0x019C},
+    {0xA0, 0x02, 0x0188},
+    {0xA0, 0x06, 0x0189},
+    {0xA0, 0x03, 0x01C5},
+    {0xA0, 0x13, 0x01CB},
+    {0xA0, 0x08, 0x0250},
+    {0xA0, 0x08, 0x0301},
+    {0xA0, 0x02, 0x0092},
+// { 0xA0, 0x80, 0x0093},
+    {0xA0, 0x90, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA1, 0x01, 0x0002},
+    {0xA0, 0x00, 0x0092},
+    {0xA0, 0x02, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA1, 0x01, 0x0095},
+    {0xA1, 0x01, 0x0096},
+
+    {0xA1, 0x01, 0x0008},
+    {0xA0, 0x03, 0x0008},	//00
+    {0xA0, 0x08, 0x01C6},
+    {0xA1, 0x01, 0x01C8},
+    {0xA1, 0x01, 0x01C9},
+    {0xA1, 0x01, 0x01CA},
+    {0xA0, 0x0F, 0x01CB},
+
+    {0xA0, 0x50, 0x010A},
+    {0xA0, 0xF8, 0x010B},
+    {0xA0, 0xF8, 0x010C},
+    {0xA0, 0xF8, 0x010D},
+    {0xA0, 0x50, 0x010E},
+    {0xA0, 0xF8, 0x010F},
+    {0xA0, 0xF8, 0x0110},
+    {0xA0, 0xF8, 0x0111},
+    {0xA0, 0x50, 0x0112},
+    {0xA1, 0x01, 0x0180},
+    {0xA0, 0x10, 0x0180},
+    {0xA0, 0x00, 0x0019},
+    {0xA0, 0x25, 0x0092},
+    {0xA0, 0x07, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x26, 0x0092},
+    {0xA0, 0xA1, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x27, 0x0092},
+    {0xA0, 0x20, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x20, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x21, 0x0092},
+    {0xA0, 0xA0, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x22, 0x0092},
+    {0xA0, 0x16, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x23, 0x0092},
+    {0xA0, 0x40, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+
+    {0xA0, 0x10, 0x0190},	//2F
+    {0xA0, 0x04, 0x0191},	//4d
+    {0xA0, 0x60, 0x0192},
+    {0xA0, 0x01, 0x0195},
+    {0xA0, 0x86, 0x0196},
+    {0xA0, 0xA0, 0x0197},
+    {0xA0, 0x07, 0x018C},
+    {0xA0, 0x0F, 0x018F},
+    {0xA0, 0x18, 0x01A9},
+    {0xA0, 0x24, 0x01AA},
+    {0xA0, 0x00, 0x001D},
+    {0xA0, 0xA0, 0x001E},
+    {0xA0, 0x16, 0x001F},
+    {0xA0, 0x40, 0x0020},
+    {0xA0, 0x60, 0x011D},
+    {0xA1, 0x01, 0x001D},
+    {0xA1, 0x01, 0x001E},
+    {0xA1, 0x01, 0x001F},
+    {0xA1, 0x01, 0x0020},
+    {0xA0, 0x40, 0x0180},
+    {0xA1, 0x01, 0x0180},
+    {0xA0, 0x42, 0x0180},
+    {0xA0, 0x40, 0x0116},
+    {0xA0, 0x40, 0x0117},
+    {0xA0, 0x40, 0x0118},
+// { 0xA0, 0x02, 0x0008},
+    {0, 0, 0}
+};
+
+static __u16 hv7131bxx_scale_data[][3] = {
+    {0xA0, 0x01, 0x0000},
+    {0xA0, 0x00, 0x0002},
+    {0xA0, 0x00, 0x0010},
+    {0xA0, 0x01, 0x0001},
+    {0xA0, 0x37, 0x0101},
+    {0xA0, 0x03, 0x0008},	//00
+    {0xA0, 0x03, 0x0012},
+    {0xA0, 0x01, 0x0012},
+    {0xA0, 0x02, 0x0003},
+    {0xA0, 0x80, 0x0004},
+    {0xA0, 0x01, 0x0005},
+    {0xA0, 0xE0, 0x0006},
+    {0xA0, 0x00, 0x0098},
+    {0xA0, 0x00, 0x009A},
+    {0xA0, 0x00, 0x011A},
+    {0xA0, 0x00, 0x011C},
+    {0xA0, 0x30, 0x0092},
+    {0xA0, 0x2D, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x01, 0x0092},
+    {0xA0, 0x05, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x11, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x13, 0x0092},
+    //{ 0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x14, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x15, 0x0092},
+    {0xA0, 0xE6, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x16, 0x0092},
+    {0xA0, 0x02, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x17, 0x0092},
+    {0xA0, 0x86, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x31, 0x0092},
+    {0xA0, 0x38, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x32, 0x0092},
+    {0xA0, 0x38, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x33, 0x0092},
+    {0xA0, 0x38, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x5B, 0x0092},
+    {0xA0, 0x01, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x00, 0x0019},
+    {0xA0, 0x05, 0x0012},
+    {0xA0, 0x0D, 0x0100},
+    {0xA0, 0x70, 0x018D},
+    {0xA0, 0x60, 0x01A8},
+    {0xA0, 0x00, 0x01AD},
+    {0xA0, 0xC0, 0x019B},
+    {0xA0, 0xA0, 0x019C},
+    {0xA0, 0x02, 0x0188},
+    {0xA0, 0x06, 0x0189},
+    {0xA0, 0x03, 0x01C5},
+    {0xA0, 0x13, 0x01CB},
+    {0xA0, 0x08, 0x0250},
+    {0xA0, 0x08, 0x0301},
+    {0xA0, 0x02, 0x0092},
+// { 0xA0, 0x80, 0x0093},
+    {0xA0, 0x90, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA1, 0x01, 0x0002},
+    {0xA0, 0x00, 0x0092},
+    {0xA0, 0x02, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA1, 0x01, 0x0095},
+    {0xA1, 0x01, 0x0096},
+    {0xA1, 0x01, 0x0008},
+    {0xA0, 0x03, 0x0008},	//00
+    {0xA0, 0x08, 0x01C6},
+    {0xA1, 0x01, 0x01C8},
+    {0xA1, 0x01, 0x01C9},
+    {0xA1, 0x01, 0x01CA},
+    {0xA0, 0x0F, 0x01CB},
+
+    {0xA0, 0x50, 0x010A},
+    {0xA0, 0xF8, 0x010B},
+    {0xA0, 0xF8, 0x010C},
+    {0xA0, 0xF8, 0x010D},
+    {0xA0, 0x50, 0x010E},
+    {0xA0, 0xF8, 0x010F},
+    {0xA0, 0xF8, 0x0110},
+    {0xA0, 0xF8, 0x0111},
+    {0xA0, 0x50, 0x0112},
+    {0xA1, 0x01, 0x0180},
+    {0xA0, 0x10, 0x0180},
+    {0xA0, 0x00, 0x0019},
+    {0xA0, 0x25, 0x0092},
+    {0xA0, 0x07, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x26, 0x0092},
+    {0xA0, 0xA1, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x27, 0x0092},
+    {0xA0, 0x20, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x20, 0x0092},
+    {0xA0, 0x00, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x21, 0x0092},
+    {0xA0, 0x40, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x22, 0x0092},
+    {0xA0, 0x13, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x23, 0x0092},
+    {0xA0, 0x4C, 0x0093},
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},
+    {0xA0, 0x10, 0x0190},	//2f
+    {0xA0, 0x04, 0x0191},	//4d
+    {0xA0, 0x60, 0x0192},	//60
+    {0xA0, 0x00, 0x0195},
+    {0xA0, 0xC3, 0x0196},
+    {0xA0, 0x50, 0x0197},
+    {0xA0, 0x0C, 0x018C},
+    {0xA0, 0x18, 0x018F},
+    {0xA0, 0x18, 0x01A9},
+    {0xA0, 0x24, 0x01AA},
+    {0xA0, 0x00, 0x001D},
+    {0xA0, 0x40, 0x001E},
+    {0xA0, 0x13, 0x001F},
+    {0xA0, 0x4C, 0x0020},
+    {0xA0, 0x60, 0x011D},
+    {0xA1, 0x01, 0x001D},
+    {0xA1, 0x01, 0x001E},
+    {0xA1, 0x01, 0x001F},
+    {0xA1, 0x01, 0x0020},
+    {0xA0, 0x40, 0x0180},
+    {0xA1, 0x01, 0x0180},
+    {0xA0, 0x42, 0x0180},
+    {0xA0, 0x40, 0x0116},
+    {0xA0, 0x40, 0x0117},
+    {0xA0, 0x40, 0x0118},
+// { 0xA0, 0x02, 0x0008},
+    {0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/hv7131c.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/hv7131c.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/hv7131c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/hv7131c.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,295 @@
+
+/****************************************************************************
+#	 	Hynix HV7131b library                                       #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+static __u16 hv7131cxx_start_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x10, 0x0002},
+    {0xa0, 0x01, 0x0010},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x77, 0x0101},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x07, 0x0012},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x01, 0x009b},
+    {0xa0, 0xe8, 0x009c},
+    {0xa0, 0x02, 0x009d},
+    {0xa0, 0x88, 0x009e},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x0c, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x11, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x13, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x14, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x15, 0x0092},
+    {0xa0, 0xe8, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x16, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x17, 0x0092},
+    {0xa0, 0x88, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x89, 0x018d},
+    {0xa0, 0x50, 0x01a8},
+    {0xa0, 0x00, 0x01ad},
+    {0xa0, 0xc0, 0x019b},
+    {0xa0, 0xa0, 0x019c},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa1, 0x01, 0x0002},
+    {0xa0, 0x00, 0x0092},
+    {0xa0, 0x02, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa1, 0x01, 0x0095},
+    {0xa1, 0x01, 0x0096},
+
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+
+    {0xa0, 0x60, 0x010a},
+    {0xa0, 0xf0, 0x010b},
+    {0xa0, 0xf0, 0x010c},
+    {0xa0, 0xf0, 0x010d},
+    {0xa0, 0x60, 0x010e},
+    {0xa0, 0xf0, 0x010f},
+    {0xa0, 0xf0, 0x0110},
+    {0xa0, 0xf0, 0x0111},
+    {0xa0, 0x60, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x10, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x25, 0x0092},
+    {0xa0, 0x07, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x26, 0x0092},
+    {0xa0, 0x53, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x27, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+
+    {0xa0, 0x10, 0x0190},	//2f
+    {0xa0, 0x04, 0x0191},	//9b
+    {0xa0, 0x60, 0x0192},	//80
+    {0xa0, 0x01, 0x0195},
+    {0xa0, 0xd4, 0x0196},
+    {0xa0, 0xc0, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x60, 0x01a8},
+    {0xa0, 0x10, 0x01a9},
+    {0xa0, 0x13, 0x01aa},
+    {0xa1, 0x01, 0x001d},
+    {0xa1, 0x01, 0x001e},
+    {0xa1, 0x01, 0x001f},
+    {0xa1, 0x01, 0x0020},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0, 0, 0}
+};
+
+static __u16 hv7131cxx_scale_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+
+    {0xa0, 0x00, 0x0002},	//diff 
+    {0xa0, 0x01, 0x0010},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x77, 0x0101},
+    {0xa0, 0x03, 0x0008},
+
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x07, 0x0012},
+
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},	//1e0
+
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x01, 0x009b},
+    {0xa0, 0xe8, 0x009c},
+    {0xa0, 0x02, 0x009d},
+    {0xa0, 0x88, 0x009e},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x0c, 0x0093},	//0c
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x11, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x13, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x14, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x15, 0x0092},
+    {0xa0, 0xe8, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x16, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x17, 0x0092},
+    {0xa0, 0x88, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+
+    {0xa0, 0x00, 0x0019},	//00
+
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x89, 0x018d},
+    {0xa0, 0x50, 0x01a8},
+    {0xa0, 0x00, 0x01ad},
+    {0xa0, 0xc0, 0x019b},
+    {0xa0, 0xa0, 0x019c},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa1, 0x01, 0x0002},
+    {0xa0, 0x00, 0x0092},	//read the i2c chips ident
+    {0xa0, 0x02, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa1, 0x01, 0x0095},
+    {0xa1, 0x01, 0x0096},
+
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+
+    {0xa0, 0x60, 0x010a},
+    {0xa0, 0xf0, 0x010b},
+    {0xa0, 0xf0, 0x010c},
+    {0xa0, 0xf0, 0x010d},
+    {0xa0, 0x60, 0x010e},
+    {0xa0, 0xf0, 0x010f},
+    {0xa0, 0xf0, 0x0110},
+    {0xa0, 0xf0, 0x0111},
+    {0xa0, 0x60, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x10, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x25, 0x0092},
+    {0xa0, 0x07, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x26, 0x0092},
+    {0xa0, 0x53, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x27, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+
+    {0xa0, 0x10, 0x0190},	//2f
+    {0xa0, 0x04, 0x0191},	//9b
+    {0xa0, 0x60, 0x0192},	//80
+
+    {0xa0, 0x01, 0x0195},
+    {0xa0, 0xd4, 0x0196},
+    {0xa0, 0xc0, 0x0197},
+
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x60, 0x01a8},
+    {0xa0, 0x10, 0x01a9},
+    {0xa0, 0x13, 0x01aa},
+    {0xa1, 0x01, 0x001d},
+    {0xa1, 0x01, 0x001e},
+    {0xa1, 0x01, 0x001f},
+    {0xa1, 0x01, 0x0020},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+
+    {0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/icm105a.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/icm105a.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/icm105a.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/icm105a.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,1635 @@
+/****************************************************************************
+#	 	Ic-media ICM105A library                                    #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+
+static __u16 icm105axx_start_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x10, 0x0002},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x0c, 0x0010},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x03, 0x0012},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0xa1, 0x008b},
+    {0xa0, 0x00, 0x0097},
+    {0xa0, 0x01, 0x0098},
+    {0xa0, 0x00, 0x0099},
+    {0xa0, 0x01, 0x009a},
+    {0xa0, 0x01, 0x011a},
+    {0xa0, 0x01, 0x011c},
+    {0xa0, 0x01, 0x009b},
+    {0xa0, 0xe8, 0x009c},
+    {0xa0, 0x02, 0x009d},
+    {0xa0, 0x88, 0x009e},
+    {0xa0, 0x37, 0x0101},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x10, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0xa0, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x13, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x03, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x15, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x17, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x0d, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x19, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x06, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x17, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x26, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x07, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x19, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x22, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x08, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x21, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0xaa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x09, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x23, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0xaa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x0d, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x0a, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x25, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0xaa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x0b, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0xec, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x2e, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x0c, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0xfa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x2a, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x07, 0x0092},
+    {0xa0, 0x0d, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x94, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x90, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x91, 0x0092},
+    {0xa0, 0x1f, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0092},
+    {0xa0, 0x64, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x9b, 0x0092},
+    {0xa0, 0xf0, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x9c, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x14, 0x0092},
+    {0xa0, 0x1a, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x22, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x24, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x26, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x00, 0x0092},
+    {0xa0, 0x84, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa0, 0xa8, 0x0092},
+    {0xa0, 0xc0, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa1, 0x01, 0x0002},
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x02, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+    {0xa0, 0x52, 0x010a},
+    {0xa0, 0xf7, 0x010b},
+    {0xa0, 0xf7, 0x010c},
+    {0xa0, 0xf7, 0x010d},
+    {0xa0, 0x52, 0x010e},
+    {0xa0, 0xf7, 0x010f},
+    {0xa0, 0xf7, 0x0110},
+    {0xa0, 0xf7, 0x0111},
+    {0xa0, 0x52, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x0d, 0x0092},
+    {0xa0, 0x03, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0c, 0x0092},
+    {0xa0, 0x8c, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0e, 0x0092},
+    {0xa0, 0x95, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0f, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x1c, 0x0092},
+    {0xa0, 0x94, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x1d, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x22, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x24, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x26, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x00, 0x0092},
+    {0xa0, 0x84, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x02, 0x00a3},
+    {0xa0, 0x94, 0x00a4},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x04, 0x0191},
+    {0xa0, 0x20, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x84, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x10, 0x01a9},
+    {0xa0, 0x12, 0x01aa},
+    {0xa0, 0xe3, 0x001d},
+    {0xa0, 0xec, 0x001e},
+    {0xa0, 0xf5, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x00, 0x01a7},
+    {0xa0, 0xc0, 0x01a8},
+    {0xa0, 0xc0, 0x011d},
+    {0xa0, 0x42, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0, 0, 0},
+};
+
+static __u16 icm105axx_scale_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x00, 0x0002},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x0c, 0x0010},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x03, 0x0012},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0xa1, 0x008b},
+    {0xa0, 0x00, 0x0097},
+    {0xa0, 0x02, 0x0098},
+    {0xa0, 0x00, 0x0099},
+    {0xa0, 0x02, 0x009a},
+    {0xa0, 0x02, 0x011a},
+    {0xa0, 0x02, 0x011c},
+    {0xa0, 0x01, 0x009b},
+    {0xa0, 0xe6, 0x009c},
+    {0xa0, 0x02, 0x009d},
+    {0xa0, 0x86, 0x009e},
+    {0xa0, 0x77, 0x0101},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x10, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0xa0, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x13, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x03, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x15, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x17, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x0d, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x19, 0x0093},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x06, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x17, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x26, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x07, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x19, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x22, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x08, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x21, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0xaa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x09, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x23, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0xaa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x0d, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x0a, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x25, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0xaa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x0b, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0xec, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x2e, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0x0c, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0xfa, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x2a, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x07, 0x0092},
+    {0xa0, 0x0d, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x94, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x90, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x91, 0x0092},
+    {0xa0, 0x10, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0092},
+    {0xa0, 0x64, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x9b, 0x0092},
+    {0xa0, 0xf0, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x9c, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x14, 0x0092},
+    {0xa0, 0x1a, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x22, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x24, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x26, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x00, 0x0092},
+    {0xa0, 0x84, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa0, 0xa8, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x78, 0x018d},
+    {0xa1, 0x01, 0x0002},
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x02, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+
+    {0xa0, 0x52, 0x010a},
+    {0xa0, 0xf7, 0x010b},
+    {0xa0, 0xf7, 0x010c},
+    {0xa0, 0xf7, 0x010d},
+    {0xa0, 0x52, 0x010e},
+    {0xa0, 0xf7, 0x010f},
+    {0xa0, 0xf7, 0x0110},
+    {0xa0, 0xf7, 0x0111},
+    {0xa0, 0x52, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x0d, 0x0092},
+    {0xa0, 0x03, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0c, 0x0092},
+    {0xa0, 0x20, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0e, 0x0092},
+    {0xa0, 0x0e, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x0f, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x1c, 0x0092},
+    {0xa0, 0x0d, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x1d, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x22, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x24, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x26, 0x0092},
+    {0xa0, 0x80, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x00, 0x0092},
+    {0xa0, 0x84, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x02, 0x00a3},
+    {0xa0, 0x0d, 0x00a4},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x04, 0x0191},
+    {0xa0, 0x1a, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x4b, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x10, 0x01a9},
+    {0xa0, 0x12, 0x01aa},
+    {0xa0, 0xc8, 0x001d},
+    {0xa0, 0xd8, 0x001e},
+    {0xa0, 0xea, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x00, 0x01a7},
+    {0xa0, 0x42, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0xa0, 0x40, 0x0116},
+    {0xa0, 0x40, 0x0117},
+    {0xa0, 0x40, 0x0118},
+    {0, 0, 0}
+};
+static __u16 icm105a_50HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000d, 0x0092}, //00,0d,03,aa
+    {0xa0, 0x0003, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000c, 0x0092}, //00,0c,20,aa
+    {0xa0, 0x0020, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,0e,aa
+    {0xa0, 0x000e, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000f, 0x0092}, //00,0f,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,0d,aa
+    {0xa0, 0x000d, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0020, 0x0092}, //00,20,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0022, 0x0092}, //00,22,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0024, 0x0092}, //00,24,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0026, 0x0092}, //00,26,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0092}, //00,00,84,aa
+    {0xa0, 0x0084, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0002, 0x00a3}, //00,a3,02,cc
+    {0xa0, 0x000d, 0x00a4}, //00,a4,0d,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0004, 0x0191}, //01,91,04,cc
+    {0xa0, 0x001a, 0x0192}, //01,92,1a,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x004b, 0x0197}, //01,97,4b,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0010, 0x01a9}, //01,a9,10,cc
+    {0xa0, 0x0012, 0x01aa}, //01,aa,12,cc
+    {0xa0, 0x00c8, 0x001d}, //00,1d,c8,cc
+    {0xa0, 0x00d8, 0x001e}, //00,1e,d8,cc
+    {0xa0, 0x00ea, 0x001f}, //00,1f,ea,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 icm105a_50HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000d, 0x0092}, //00,0d,03,aa
+    {0xa0, 0x0003, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000c, 0x0092}, //00,0c,8c,aa
+    {0xa0, 0x008c, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,95,aa
+    {0xa0, 0x0095, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000f, 0x0092}, //00,0f,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,94,aa
+    {0xa0, 0x0094, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0020, 0x0092}, //00,20,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0022, 0x0092}, //00,22,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0024, 0x0092}, //00,24,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0026, 0x0092}, //00,26,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0092}, //00,00,84,aa
+    {0xa0, 0x0084, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0002, 0x00a3}, //00,a3,02,cc
+    {0xa0, 0x0094, 0x00a4}, //00,a4,94,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0004, 0x0191}, //01,91,04,cc
+    {0xa0, 0x0020, 0x0192}, //01,92,20,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0084, 0x0197}, //01,97,84,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0010, 0x01a9}, //01,a9,10,cc
+    {0xa0, 0x0012, 0x01aa}, //01,aa,12,cc
+    {0xa0, 0x00e3, 0x001d}, //00,1d,e3,cc
+    {0xa0, 0x00ec, 0x001e}, //00,1e,ec,cc
+    {0xa0, 0x00f5, 0x001f}, //00,1f,f5,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0000, 0x01a7}, //01,a7,00,cc
+    {0xa0, 0x00c0, 0x01a8}, //01,a8,c0,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 icm105a_60HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000d, 0x0092}, //00,0d,03,aa
+    {0xa0, 0x0003, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000c, 0x0092}, //00,0c,04,aa
+    {0xa0, 0x0004, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,0d,aa
+    {0xa0, 0x000d, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000f, 0x0092}, //00,0f,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,08,aa
+    {0xa0, 0x0008, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0020, 0x0092}, //00,20,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0022, 0x0092}, //00,22,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0024, 0x0092}, //00,24,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0026, 0x0092}, //00,26,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0092}, //00,00,84,aa
+    {0xa0, 0x0084, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0002, 0x00a3}, //00,a3,02,cc
+    {0xa0, 0x0008, 0x00a4}, //00,a4,08,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0004, 0x0191}, //01,91,04,cc
+    {0xa0, 0x0010, 0x0192}, //01,92,10,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0041, 0x0197}, //01,97,41,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0010, 0x01a9}, //01,a9,10,cc
+    {0xa0, 0x0012, 0x01aa}, //01,aa,12,cc
+    {0xa0, 0x00c1, 0x001d}, //00,1d,c1,cc
+    {0xa0, 0x00d4, 0x001e}, //00,1e,d4,cc
+    {0xa0, 0x00e8, 0x001f}, //00,1f,e8,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 icm105a_60HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000d, 0x0092}, //00,0d,03,aa
+    {0xa0, 0x0003, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000c, 0x0092}, //00,0c,08,aa
+    {0xa0, 0x0008, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,86,aa
+    {0xa0, 0x0086, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000f, 0x0092}, //00,0f,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,85,aa
+    {0xa0, 0x0085, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0020, 0x0092}, //00,20,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0022, 0x0092}, //00,22,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0024, 0x0092}, //00,24,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0026, 0x0092}, //00,26,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0092}, //00,00,84,aa
+    {0xa0, 0x0084, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0002, 0x00a3}, //00,a3,02,cc
+    {0xa0, 0x0085, 0x00a4}, //00,a4,85,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0004, 0x0191}, //01,91,04,cc
+    {0xa0, 0x0008, 0x0192}, //01,92,08,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0081, 0x0197}, //01,97,81,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0010, 0x01a9}, //01,a9,10,cc
+    {0xa0, 0x0012, 0x01aa}, //01,aa,12,cc
+    {0xa0, 0x00c2, 0x001d}, //00,1d,c2,cc
+    {0xa0, 0x00d6, 0x001e}, //00,1e,d6,cc
+    {0xa0, 0x00ea, 0x001f}, //00,1f,ea,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0000, 0x01a7}, //01,a7,00,cc
+    {0xa0, 0x00c0, 0x01a8}, //01,a8,c0,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 icm105a_NoFliker[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000d, 0x0092}, //00,0d,03,aa
+    {0xa0, 0x0003, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000c, 0x0092}, //00,0c,04,aa
+    {0xa0, 0x0004, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,0d,aa
+    {0xa0, 0x000d, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000f, 0x0092}, //00,0f,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0020, 0x0092}, //00,20,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0022, 0x0092}, //00,22,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0024, 0x0092}, //00,24,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0026, 0x0092}, //00,26,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0092}, //00,00,84,aa
+    {0xa0, 0x0084, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0002, 0x00a3}, //00,a3,02,cc
+    {0xa0, 0x0000, 0x00a4}, //00,a4,00,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0004, 0x0191}, //01,91,04,cc
+    {0xa0, 0x0020, 0x0192}, //01,92,20,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x00c1, 0x001d}, //00,1d,c1,cc
+    {0xa0, 0x00d4, 0x001e}, //00,1e,d4,cc
+    {0xa0, 0x00e8, 0x001f}, //00,1f,e8,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 icm105a_NoFlikerScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x000d, 0x0092}, //00,0d,03,aa
+    {0xa0, 0x0003, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000c, 0x0092}, //00,0c,04,aa
+    {0xa0, 0x0004, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000e, 0x0092}, //00,0e,81,aa
+    {0xa0, 0x0081, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x000f, 0x0092}, //00,0f,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001c, 0x0092}, //00,1c,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x001d, 0x0092}, //00,1d,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0020, 0x0092}, //00,20,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0022, 0x0092}, //00,22,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0024, 0x0092}, //00,24,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0026, 0x0092}, //00,26,80,aa
+    {0xa0, 0x0080, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x0092}, //00,00,84,aa
+    {0xa0, 0x0084, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0002, 0x00a3}, //00,a3,02,cc
+    {0xa0, 0x0080, 0x00a4}, //00,a4,80,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0004, 0x0191}, //01,91,04,cc
+    {0xa0, 0x0020, 0x0192}, //01,92,20,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x00c1, 0x001d}, //00,1d,c1,cc
+    {0xa0, 0x00d4, 0x001e}, //00,1e,d4,cc
+    {0xa0, 0x00e8, 0x001f}, //00,1f,e8,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0000, 0x01a7}, //01,a7,00,cc
+    {0xa0, 0x00c0, 0x01a8}, //01,a8,c0,cc
+/*******************/
+{0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/ov7630c.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/ov7630c.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/ov7630c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/ov7630c.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,758 @@
+
+/****************************************************************************
+#	 	Omnivision OV7630c library                                  #
+# 		Copyright (C) 2006 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 ov7630c_start_data[][3] = {
+    {0xa0, 0x0001, 0x0000},
+    {0xa0, 0x0010, 0x0002},
+    { 0xa0, 0x01, 0x0000 },
+{ 0xa0, 0x10, 0x0002 },
+{ 0xa0, 0x03, 0x0008 },
+{ 0xa0, 0x01, 0x0001 },
+{ 0xa0, 0x06, 0x0010 },
+{ 0xa0, 0xa1, 0x008b },
+{ 0xa0, 0x08, 0x008d },
+{ 0xa0, 0x02, 0x0003 },
+{ 0xa0, 0x80, 0x0004 },
+{ 0xa0, 0x01, 0x0005 },
+{ 0xa0, 0xe0, 0x0006 },
+{ 0xa0, 0x01, 0x0012 },
+{ 0xa0, 0x12, 0x0092 },
+{ 0xa0, 0x80, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+
+ 
+{ 0xa1, 0x01, 0x0091 },
+{ 0xa0, 0x02, 0x0083 },
+{ 0xa0, 0x01, 0x0085 },
+{ 0xa0, 0x90, 0x0086 },
+{ 0xa0, 0x91, 0x0087 },
+{ 0xa0, 0x10, 0x0088 },
+{ 0xa0, 0x00, 0x0098 },
+{ 0xa0, 0x00, 0x009a },
+{ 0xa0, 0x00, 0x011a },
+{ 0xa0, 0x00, 0x011c },
+{ 0xa0, 0xd8, 0x009c },
+{ 0xa0, 0x88, 0x009e },
+
+{ 0xa0, 0x12, 0x0092 },
+{ 0xa0, 0x69, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x04, 0x0092 },
+{ 0xa0, 0x20, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x06, 0x0092 },
+{ 0xa0, 0x50, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x13, 0x0092 },
+{ 0xa0, 0x83, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x14, 0x0092 },
+{ 0xa0, 0x00, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x15, 0x0092 },
+{ 0xa0, 0x24, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x17, 0x0092 },
+{ 0xa0, 0x18, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x18, 0x0092 },
+{ 0xa0, 0xba, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x19, 0x0092 },
+{ 0xa0, 0x02, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x1a, 0x0092 },
+{ 0xa0, 0xf6, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x1b, 0x0092 },
+{ 0xa0, 0x02, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x20, 0x0092 },
+{ 0xa0, 0xc2, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x24, 0x0092 },
+{ 0xa0, 0x60, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x25, 0x0092 },
+{ 0xa0, 0x40, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x26, 0x0092 },
+{ 0xa0, 0x30, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x27, 0x0092 },
+{ 0xa0, 0xea, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x28, 0x0092 },
+{ 0xa0, 0xa0, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x21, 0x0092 },
+{ 0xa0, 0x00, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x2a, 0x0092 },
+{ 0xa0, 0x81, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x2b, 0x0092 },
+{ 0xa0, 0x96, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x2d, 0x0092 },
+{ 0xa0, 0x94, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x2f, 0x0092 },
+{ 0xa0, 0x3d, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x30, 0x0092 },
+{ 0xa0, 0x24, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x60, 0x0092 },
+{ 0xa0, 0x00, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x61, 0x0092 },
+{ 0xa0, 0x40, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x68, 0x0092 },
+{ 0xa0, 0x7c, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x6f, 0x0092 },
+{ 0xa0, 0x15, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x75, 0x0092 },
+{ 0xa0, 0x88, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x77, 0x0092 },
+{ 0xa0, 0xb5, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x01, 0x0092 },
+{ 0xa0, 0x60, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x02, 0x0092 },
+{ 0xa0, 0x60, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x05, 0x0012 },
+{ 0xa0, 0x77, 0x0101 },
+{ 0xa0, 0x0d, 0x0100 },
+{ 0xa0, 0x06, 0x0189 },
+{ 0xa0, 0x04, 0x01a7 },
+{ 0xa0, 0x00, 0x01ad },
+{ 0xa0, 0x03, 0x01c5 },
+{ 0xa0, 0x13, 0x01cb },
+{ 0xa0, 0x08, 0x0250 },
+{ 0xa0, 0x08, 0x0301 },
+{ 0xa0, 0x60, 0x0116 },
+{ 0xa0, 0x46, 0x0118 },
+{ 0xa0, 0x04, 0x0113 },
+
+//0x10, 
+{ 0xa1, 0x01, 0x0002 },
+{ 0xa0, 0x50, 0x010a },
+{ 0xa0, 0xf8, 0x010b },
+{ 0xa0, 0xf8, 0x010c },
+{ 0xa0, 0xf8, 0x010d },
+{ 0xa0, 0x50, 0x010e },
+{ 0xa0, 0xf8, 0x010f },
+{ 0xa0, 0xf8, 0x0110 },
+{ 0xa0, 0xf8, 0x0111 },
+{ 0xa0, 0x50, 0x0112 },
+
+//0x03, 
+{ 0xa1, 0x01, 0x0008 },
+{ 0xa0, 0x03, 0x0008 },
+{ 0xa0, 0x08, 0x01c6 },
+
+//0x05, 
+{ 0xa1, 0x01, 0x01c8 },
+//0x07, 
+{ 0xa1, 0x01, 0x01c9 },
+
+//0x0f, 
+{ 0xa1, 0x01, 0x01ca },
+{ 0xa0, 0x0f, 0x01cb },
+{ 0xa0, 0x01, 0x0120 },
+{ 0xa0, 0x0c, 0x0121 },
+{ 0xa0, 0x1f, 0x0122 },
+{ 0xa0, 0x3a, 0x0123 },
+{ 0xa0, 0x53, 0x0124 },
+{ 0xa0, 0x6d, 0x0125 },
+{ 0xa0, 0x85, 0x0126 },
+{ 0xa0, 0x9c, 0x0127 },
+{ 0xa0, 0xb0, 0x0128 },
+{ 0xa0, 0xc2, 0x0129 },
+{ 0xa0, 0xd1, 0x012a },
+{ 0xa0, 0xde, 0x012b },
+{ 0xa0, 0xe9, 0x012c },
+{ 0xa0, 0xf2, 0x012d },
+{ 0xa0, 0xf9, 0x012e },
+{ 0xa0, 0xff, 0x012f },
+{ 0xa0, 0x05, 0x0130 },
+{ 0xa0, 0x0f, 0x0131 },
+{ 0xa0, 0x16, 0x0132 },
+{ 0xa0, 0x1a, 0x0133 },
+{ 0xa0, 0x19, 0x0134 },
+{ 0xa0, 0x19, 0x0135 },
+{ 0xa0, 0x17, 0x0136 },
+{ 0xa0, 0x15, 0x0137 },
+{ 0xa0, 0x12, 0x0138 },
+{ 0xa0, 0x10, 0x0139 },
+{ 0xa0, 0x0e, 0x013a },
+{ 0xa0, 0x0b, 0x013b },
+{ 0xa0, 0x09, 0x013c },
+{ 0xa0, 0x08, 0x013d },
+{ 0xa0, 0x06, 0x013e },
+{ 0xa0, 0x03, 0x013f },
+{ 0xa0, 0x50, 0x010a },
+{ 0xa0, 0xf8, 0x010b },
+{ 0xa0, 0xf8, 0x010c },
+{ 0xa0, 0xf8, 0x010d },
+{ 0xa0, 0x50, 0x010e },
+{ 0xa0, 0xf8, 0x010f },
+{ 0xa0, 0xf8, 0x0110 },
+{ 0xa0, 0xf8, 0x0111 },
+{ 0xa0, 0x50, 0x0112 },
+
+{ 0xa1, 0x01, 0x0180 },
+{ 0xa0, 0x00, 0x0180 },
+
+{ 0xa0, 0x10, 0x0092 },
+{ 0xa0, 0x1b, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x76, 0x0092 },
+{ 0xa0, 0x02, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 }, 
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x2a, 0x0092 },
+{ 0xa0, 0x81, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x2b, 0x0092 },
+{ 0xa0, 0x00, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+{ 0xa1, 0x01, 0x0091 },
+
+{ 0xa0, 0x00, 0x0190 },
+{ 0xa0, 0x01, 0x0191 },
+{ 0xa0, 0xb8, 0x0192 },
+{ 0xa0, 0x00, 0x0195 },
+{ 0xa0, 0x00, 0x0196 },
+{ 0xa0, 0x37, 0x0197 },
+{ 0xa0, 0x10, 0x018c },
+{ 0xa0, 0x20, 0x018f },
+{ 0xa0, 0x10, 0x01a9 },
+{ 0xa0, 0x26, 0x01aa },
+{ 0xa0, 0x50, 0x011d },
+{ 0xa0, 0x02, 0x0180 },
+{ 0xa0, 0x40, 0x0180 },
+{ 0xa0, 0x13, 0x0092 },
+{ 0xa0, 0x83, 0x0093 },
+{ 0xa0, 0x00, 0x0094 },
+{ 0xa0, 0x01, 0x0090 },
+ 
+{ 0xa1, 0x01, 0x0091 },
+//40
+{ 0xa1, 0x01, 0x0180 },
+{ 0xa0, 0x42, 0x0180 }, 
+    {0, 0, 0}
+};
+
+static __u16 ov7630c_scale_data[][3] = {
+
+    {0xa0, 0x0001, 0x0000},
+    {0xa0, 0x0000, 0x0002},
+    {0xa0, 0x0003, 0x0008},
+    {0xa0, 0x0001, 0x0001},
+    {0xa0, 0x0006, 0x0010},
+    {0xa0, 0x00a1, 0x008b},
+    {0xa0, 0x0008, 0x008d},
+    {0xa0, 0x0002, 0x0003},
+    {0xa0, 0x0080, 0x0004},
+    {0xa0, 0x0001, 0x0005},
+    {0xa0, 0x00e0, 0x0006},
+    {0xa0, 0x0001, 0x0012},
+
+    {0xa0, 0x0012, 0x0092},
+    {0xa0, 0x0080, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0002, 0x0083},
+    {0xa0, 0x0001, 0x0085},
+    {0xa0, 0x0090, 0x0086},
+    {0xa0, 0x0091, 0x0087},
+    {0xa0, 0x0010, 0x0088},
+    {0xa0, 0x0000, 0x0098},
+    {0xa0, 0x0000, 0x009a},
+    {0xa0, 0x0000, 0x011a},
+    {0xa0, 0x0000, 0x011c},
+    {0xa0, 0x00e6, 0x009c},
+    {0xa0, 0x0086, 0x009e},
+/* i2c */
+    {0xa0, 0x0012, 0x0092},
+    {0xa0, 0x0069, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0004, 0x0092},
+    {0xa0, 0x0020, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0006, 0x0092},
+    {0xa0, 0x0050, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0013, 0x0092},
+    {0xa0, 0x00c3, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0014, 0x0092},
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0015, 0x0092},
+    {0xa0, 0x0024, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0019, 0x0092},
+    {0xa0, 0x0003, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x001a, 0x0092},
+    {0xa0, 0x00f6, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x001b, 0x0092},
+    {0xa0, 0x0002, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0020, 0x0092},
+    {0xa0, 0x00c2, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0024, 0x0092},
+    {0xa0, 0x0060, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0025, 0x0092},
+    {0xa0, 0x0040, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0026, 0x0092},
+    {0xa0, 0x0030, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0027, 0x0092},
+    {0xa0, 0x00ea, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0028, 0x0092},
+    {0xa0, 0x00a0, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0021, 0x0092},
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x002a, 0x0092},
+    {0xa0, 0x0081, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x002b, 0x0092},
+    {0xa0, 0x0096, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x002d, 0x0092},
+    {0xa0, 0x0084, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x002f, 0x0092},
+    {0xa0, 0x003d, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0030, 0x0092},
+    {0xa0, 0x0024, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0060, 0x0092},
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0061, 0x0092},
+    {0xa0, 0x0040, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0068, 0x0092},
+    {0xa0, 0x007c, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x006f, 0x0092},
+    {0xa0, 0x0015, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0075, 0x0092},
+    {0xa0, 0x0088, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0077, 0x0092},
+    {0xa0, 0x00b5, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0001, 0x0092},
+    {0xa0, 0x0060, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0002, 0x0092},
+    {0xa0, 0x0060, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0017, 0x0092},
+    {0xa0, 0x0018, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0018, 0x0092},
+    {0xa0, 0x00ba, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0005, 0x0012},
+    {0xa0, 0x0077, 0x0101},
+    {0xa0, 0x000d, 0x0100},
+    {0xa0, 0x0006, 0x0189},
+    {0xa0, 0x0004, 0x01a7},
+    {0xa0, 0x0000, 0x01ad},
+    {0xa0, 0x0003, 0x01c5},
+    {0xa0, 0x0013, 0x01cb},
+    {0xa0, 0x0008, 0x0250},
+    {0xa0, 0x0008, 0x0301},
+    {0xa0, 0x0060, 0x0116},
+    {0xa0, 0x0046, 0x0118},
+    {0xa0, 0x0004, 0x0113},
+
+
+    {0xa1, 0x0001, 0x0002},
+    {0xa0, 0x004e, 0x010a},
+    {0xa0, 0x00fe, 0x010b},
+    {0xa0, 0x00f4, 0x010c},
+    {0xa0, 0x00f7, 0x010d},
+    {0xa0, 0x004d, 0x010e},
+    {0xa0, 0x00fc, 0x010f},
+    {0xa0, 0x0000, 0x0110},
+    {0xa0, 0x00f6, 0x0111},
+    {0xa0, 0x004a, 0x0112},
+
+    {0xa1, 0x0001, 0x0008},
+    {0xa0, 0x0003, 0x0008},
+    {0xa0, 0x0008, 0x01c6},
+
+    {0xa1, 0x0001, 0x01c8},
+
+
+    {0xa1, 0x0001, 0x01c9},
+
+    {0xa1, 0x0001, 0x01ca},
+    {0xa0, 0x000f, 0x01cb},
+    {0xa0, 0x0016, 0x0120},
+    {0xa0, 0x003a, 0x0121},
+    {0xa0, 0x005b, 0x0122},
+    {0xa0, 0x007c, 0x0123},
+    {0xa0, 0x0094, 0x0124},
+    {0xa0, 0x00a9, 0x0125},
+    {0xa0, 0x00bb, 0x0126},
+    {0xa0, 0x00ca, 0x0127},
+    {0xa0, 0x00d7, 0x0128},
+    {0xa0, 0x00e1, 0x0129},
+    {0xa0, 0x00ea, 0x012a},
+    {0xa0, 0x00f1, 0x012b},
+    {0xa0, 0x00f7, 0x012c},
+    {0xa0, 0x00fc, 0x012d},
+    {0xa0, 0x00ff, 0x012e},
+    {0xa0, 0x00ff, 0x012f},
+    {0xa0, 0x0020, 0x0130},
+    {0xa0, 0x0022, 0x0131},
+    {0xa0, 0x0020, 0x0132},
+    {0xa0, 0x001c, 0x0133},
+    {0xa0, 0x0016, 0x0134},
+    {0xa0, 0x0013, 0x0135},
+    {0xa0, 0x0010, 0x0136},
+    {0xa0, 0x000d, 0x0137},
+    {0xa0, 0x000b, 0x0138},
+    {0xa0, 0x0009, 0x0139},
+    {0xa0, 0x0007, 0x013a},
+    {0xa0, 0x0006, 0x013b},
+    {0xa0, 0x0005, 0x013c},
+    {0xa0, 0x0004, 0x013d},
+    {0xa0, 0x0000, 0x013e},
+    {0xa0, 0x0001, 0x013f},
+    {0xa0, 0x004e, 0x010a},
+    {0xa0, 0x00fe, 0x010b},
+    {0xa0, 0x00f4, 0x010c},
+    {0xa0, 0x00f7, 0x010d},
+    {0xa0, 0x004d, 0x010e},
+    {0xa0, 0x00fc, 0x010f},
+    {0xa0, 0x0000, 0x0110},
+    {0xa0, 0x00f6, 0x0111},
+    {0xa0, 0x004a, 0x0112},
+
+
+    {0xa1, 0x0001, 0x0180},
+    {0xa0, 0x0000, 0x0180},
+    {0xa0, 0x0010, 0x0092},
+    {0xa0, 0x000d, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0076, 0x0092},
+    {0xa0, 0x0002, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x002a, 0x0092},
+    {0xa0, 0x0081, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x002b, 0x0092},
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+
+
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0000, 0x0190},
+    {0xa0, 0x0000, 0x0191},
+    {0xa0, 0x00d8, 0x0192},
+    {0xa0, 0x0000, 0x0195},
+    {0xa0, 0x0000, 0x0196},
+    {0xa0, 0x001b, 0x0197},
+    {0xa0, 0x0010, 0x018c},
+    {0xa0, 0x0020, 0x018f},
+    {0xa0, 0x0010, 0x01a9},
+    {0xa0, 0x0026, 0x01aa},
+    {0xa0, 0x0050, 0x011d},
+    {0xa0, 0x0002, 0x0180},
+    {0xa0, 0x0040, 0x0180},
+    {0xa0, 0x0013, 0x0092},
+    {0xa0, 0x00c3, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+
+    {0xa1, 0x0001, 0x0180},
+    {0xa0, 0x0042, 0x0180},
+
+    {0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/pas106b.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/pas106b.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/pas106b.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/pas106b.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,503 @@
+
+/****************************************************************************
+#	PAS106B library                                                     #
+# 	Copyright (C) 2005 Thomas Kaiser thomas@kaiser.linux-site.net       #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 pas106b_com_data[][3] = {
+/* 352x288 */
+/* Sream and Sensor specific */
+    {0xA1, 0x01, 0x0010},	//CMOSSensorSelect
+/* System */
+    {0xA0, 0x01, 0x0000},	//SystemControl
+    {0xA0, 0x01, 0x0000},	//SystemControl
+/* Picture size */
+    {0xA0, 0x00, 0x0002},	//ClockSelect
+    {0xA0, 0x03, 0x003a},
+    {0xA0, 0x0c, 0x003b},
+    {0xa0, 0x04, 0x0038},
+        {0, 0, 0}
+    };
+    
+static __u16 pas106b_start_data[][3] = {
+/* 176x144 */
+/* JPEG control */
+    {0xA0, 0x03, 0x0008},	//ClockSetting
+/* Sream and Sensor specific */
+    {0xA0, 0x0F, 0x0010},	//CMOSSensorSelect
+/* Picture size */
+    {0xA0, 0x00, 0x0003},	//FrameWidthHigh 00
+    {0xA0, 0xB0, 0x0004},	//FrameWidthLow B0
+    {0xA0, 0x00, 0x0005},	//FrameHeightHigh 00
+    {0xA0, 0x90, 0x0006},	//FrameHightLow 90
+/* System */
+    {0xA0, 0x01, 0x0001},	//SystemOperating
+/* Sream and Sensor specific */
+    {0xA0, 0x03, 0x0012},	//VideoControlFunction
+    {0xA0, 0x01, 0x0012},	//VideoControlFunction
+/* Sensor Interface */
+    {0xA0, 0x08, 0x008D},	//Compatibily Mode
+/* Window inside sensor array */
+    {0xA0, 0x03, 0x009A},	//WinXStartLow
+    {0xA0, 0x00, 0x011A},	//FirstYLow
+    {0xA0, 0x03, 0x011C},	//FirstxLow
+    {0xA0, 0x28, 0x009C},	//WinHeightLow
+    {0xA0, 0x68, 0x009E},	//WinWidthLow
+/* Init the sensor */
+    {0xA0, 0x02, 0x0092},	//write register 0x02 to sensor (i2c)
+    {0xA0, 0x04, 0x0093},	//Value 0x04
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x08, 0x0092},	//write register 0x08 to sensor (i2c)
+    {0xA0, 0x00, 0x0093},	//Value 0x00
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x09, 0x0092},	//write register 0x09 to sensor (i2c)
+    {0xA0, 0x05, 0x0093},	//Value 0x05
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0A, 0x0092},	//write register 0x0A to sensor (i2c)
+    {0xA0, 0x02, 0x0093},	//Value 0x02
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0B, 0x0092},	//write register 0x0B to sensor (i2c)
+    {0xA0, 0x02, 0x0093},	//Value 0x02
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0C, 0x0092},	//write register 0x0C to sensor (i2c)
+    {0xA0, 0x05, 0x0093},	//Value 0x05
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0D, 0x0092},	//write register 0x0D to sensor (i2c)
+    {0xA0, 0x00, 0x0093},	//Value 0x00
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0E, 0x0092},	//write register 0x0E to sensor (i2c)
+    {0xA0, 0x02, 0x0093},	//Value 0x02
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x14, 0x0092},	//write register 0x14 to sensor (i2c)
+    {0xA0, 0x81, 0x0093},	//Value 0x81
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    
+/* Other registors */
+    {0xA0, 0x37, 0x0101},	//SensorCorrection
+/* Frame retreiving */
+    {0xA0, 0x00, 0x0019},	//AutoAdjustFPS
+/* Gains */
+    {0xA0, 0xa0, 0x01A8},	//DigitalGain
+/* Unknown */
+    {0xA0, 0x00, 0x01Ad},
+/* Sharpness */
+    {0xA0, 0x03, 0x01C5},	//SharpnessMode
+    {0xA0, 0x13, 0x01CB},	//Sharpness05
+/* Other registors */
+    {0xA0, 0x0D, 0x0100},	//OperationMode
+/* Auto exposure and white balance */
+    {0xA0, 0x06, 0x0189},	// AWBStatus
+/*Dead pixels */
+    {0xA0, 0x08, 0x0250},	//DeadPixelsMode
+/* EEPROM */
+    {0xA0, 0x08, 0x0301},	//EEPROMAccess
+/* JPEG control */
+    {0xA0, 0x03, 0x0008},	//ClockSetting
+/* Unknown */
+    {0xA0, 0x08, 0x01C6},
+/* Sharpness */
+    {0xA0, 0x0F, 0x01CB},	//Sharpness05
+/* Other registers */
+    {0xA0, 0x0D, 0x0100},	//OperationMode
+/* Auto exposure and white balance */
+    {0xA0, 0x06, 0x0189},	// AWBStatus
+/*Dead pixels */
+    {0xA0, 0x08, 0x0250},	//DeadPixelsMode
+/* EEPROM */
+    {0xA0, 0x08, 0x0301},	//EEPROMAccess
+/* JPEG control */
+    {0xA0, 0x03, 0x0008},	//ClockSetting
+/* Sharpness */
+    {0xA0, 0x08, 0x01C6},	//Sharpness00
+    {0xA0, 0x0F, 0x01CB},	//Sharpness05
+
+/* Color matrix */
+    {0xA0, 0x58, 0x010A},
+    {0xA0, 0xF4, 0x010B},
+    {0xA0, 0xF4, 0x010C},
+    {0xA0, 0xF4, 0x010D},
+    {0xA0, 0x58, 0x010E},
+    {0xA0, 0xF4, 0x010F},
+    {0xA0, 0xF4, 0x0110},
+    {0xA0, 0xF4, 0x0111},
+    {0xA0, 0x58, 0x0112},
+/* Auto correction */
+    {0xA0, 0x03, 0x0181},	//WinXstart
+    {0xA0, 0x08, 0x0182},	//WinXWidth
+    {0xA0, 0x16, 0x0183},	//WinXCenter
+    {0xA0, 0x03, 0x0184},	//WinYStart
+    {0xA0, 0x05, 0x0185},	//WinYWidth
+    {0xA0, 0x14, 0x0186},	//WinYCenter
+    {0xA0, 0x00, 0x0180},	//AutoCorrectEnable
+    
+/* Auto exposure and white balance */
+    {0xA0, 0x00, 0x0190},	//ExposureLimitHigh
+    {0xA0, 0x03, 0x0191},	//ExposureLimitMid
+    {0xA0, 0xB1, 0x0192},	//ExposureLimitLow
+    {0xA0, 0x00, 0x0195},	//AntiFlickerHigh
+    {0xA0, 0x00, 0x0196},	//AntiFlickerLow
+    {0xA0, 0x87, 0x0197},	//AntiFlickerLow
+    {0xA0, 0x0C, 0x018C},	//AEBFreeze
+    {0xA0, 0x18, 0x018F},	//AEBUnfreeze
+/* sensor on */
+{0xA0, 0x07, 0x0092},	//write register 0x07 to sensor (i2c)
+    {0xA0, 0xB1, 0x0093},	//Value 0xB1
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x05, 0x0092},	//write register 0x05 to sensor (i2c)
+    {0xA0, 0x03, 0x0093},	//Value 0x03
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x04, 0x0092},	//write register 0x04 to sensor (i2c)
+    {0xA0, 0x01, 0x0093},	//Value 0x01
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x03, 0x0092},	//write register 0x03 to sensor (i2c)
+    {0xA0, 0x3B, 0x0093},	//Value 0x3B
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+/* Gains */
+    {0xA0, 0x20, 0x01A9},	//DigitalLimitDiff
+    {0xA0, 0x26, 0x01AA},	//DigitalGainStep
+    {0xA0, 0xA0, 0x011D},	//GlobalGain
+    {0xA0, 0x60, 0x011D},	//GlobalGain
+/* Auto correction */
+    {0xA0, 0x40, 0x0180},	//AutoCorrectEnable
+    {0xa1, 0x01, 0x0180},	//AutoCorrectEnable
+    {0xA0, 0x42, 0x0180},	//AutoCorrectEnable
+/* Gains */
+    {0xA0, 0x40, 0x0116},	//RGain
+    {0xA0, 0x40, 0x0117},	//GGain
+    {0xA0, 0x40, 0x0118},	//BGain
+    {0, 0, 0}
+};
+
+static __u16 pas106b_scale_data[][3] = {
+/* 352x288 */
+/* JPEG control */
+    {0xA0, 0x03, 0x0008},	//ClockSetting
+/* Sream and Sensor specific */
+    {0xA0, 0x0F, 0x0010},	//CMOSSensorSelect
+/* Picture size */
+    {0xA0, 0x01, 0x0003},	//FrameWidthHigh
+    {0xA0, 0x60, 0x0004},	//FrameWidthLow
+    {0xA0, 0x01, 0x0005},	//FrameHeightHigh
+    {0xA0, 0x20, 0x0006},	//FrameHightLow
+/* System */
+    {0xA0, 0x01, 0x0001},	//SystemOperating
+/* Sream and Sensor specific */
+    {0xA0, 0x03, 0x0012},	//VideoControlFunction
+    {0xA0, 0x01, 0x0012},	//VideoControlFunction
+/* Sensor Interface */
+    {0xA0, 0x08, 0x008D},	//Compatibily Mode
+/* Window inside sensor array */
+    {0xA0, 0x03, 0x009A},	//WinXStartLow
+    {0xA0, 0x00, 0x011A},	//FirstYLow
+    {0xA0, 0x03, 0x011C},	//FirstxLow
+    {0xA0, 0x28, 0x009C},	//WinHeightLow
+    {0xA0, 0x68, 0x009E},	//WinWidthLow
+/* Init the sensor */
+    {0xA0, 0x02, 0x0092},	//write register 0x02 to sensor (i2c)
+    {0xA0, 0x04, 0x0093},	//Value 0x04
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x08, 0x0092},	//write register 0x08 to sensor (i2c)
+    {0xA0, 0x00, 0x0093},	//Value 0x00
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x09, 0x0092},	//write register 0x09 to sensor (i2c)
+    {0xA0, 0x05, 0x0093},	//Value 0x05
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0A, 0x0092},	//write register 0x0A to sensor (i2c)
+    {0xA0, 0x02, 0x0093},	//Value 0x02
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0B, 0x0092},	//write register 0x0B to sensor (i2c)
+    {0xA0, 0x02, 0x0093},	//Value 0x02
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0C, 0x0092},	//write register 0x0C to sensor (i2c)
+    {0xA0, 0x05, 0x0093},	//Value 0x05
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0D, 0x0092},	//write register 0x0D to sensor (i2c)
+    {0xA0, 0x00, 0x0093},	//Value 0x00
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x0E, 0x0092},	//write register 0x0E to sensor (i2c)
+    {0xA0, 0x02, 0x0093},	//Value 0x02
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x14, 0x0092},	//write register 0x14 to sensor (i2c)
+    {0xA0, 0x81, 0x0093},	//Value 0x81
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+   
+/* Other registors */
+    {0xA0, 0x37, 0x0101},	//SensorCorrection
+/* Frame retreiving */
+    {0xA0, 0x00, 0x0019},	//AutoAdjustFPS
+/* Gains */
+    {0xA0, 0xa0, 0x01A8},	//DigitalGain
+/* Unknown */
+    {0xA0, 0x00, 0x01Ad},
+/* Sharpness */
+    {0xA0, 0x03, 0x01C5},	//SharpnessMode
+    {0xA0, 0x13, 0x01CB},	//Sharpness05
+/* Other registors */
+    {0xA0, 0x0D, 0x0100},	//OperationMode
+/* Auto exposure and white balance */
+    {0xA0, 0x06, 0x0189},	// AWBStatus
+    {0xA0, 0x80, 0x018D},	// ?????????
+/*Dead pixels */
+    {0xA0, 0x08, 0x0250},	//DeadPixelsMode
+/* EEPROM */
+    {0xA0, 0x08, 0x0301},	//EEPROMAccess
+/* JPEG control */
+    {0xA0, 0x03, 0x0008},	//ClockSetting
+/* Unknown */
+    {0xA0, 0x08, 0x01C6},
+/* Sharpness */
+    {0xA0, 0x0F, 0x01CB},	//Sharpness05
+/* Other registers */
+    {0xA0, 0x0D, 0x0100},	//OperationMode
+/* Auto exposure and white balance */
+    {0xA0, 0x06, 0x0189},	// AWBStatus
+/*Dead pixels */
+    {0xA0, 0x08, 0x0250},	//DeadPixelsMode
+/* EEPROM */
+    {0xA0, 0x08, 0x0301},	//EEPROMAccess
+/* JPEG control */
+    {0xA0, 0x03, 0x0008},	//ClockSetting
+/* Sharpness */
+    {0xA0, 0x08, 0x01C6},	//Sharpness00
+    {0xA0, 0x0F, 0x01CB},	//Sharpness05
+
+/* Color matrix */
+    {0xA0, 0x58, 0x010A},
+    {0xA0, 0xF4, 0x010B},
+    {0xA0, 0xF4, 0x010C},
+    {0xA0, 0xF4, 0x010D},
+    {0xA0, 0x58, 0x010E},
+    {0xA0, 0xF4, 0x010F},
+    {0xA0, 0xF4, 0x0110},
+    {0xA0, 0xF4, 0x0111},
+    {0xA0, 0x58, 0x0112},
+/* Auto correction */
+    {0xA0, 0x03, 0x0181},	//WinXstart
+    {0xA0, 0x08, 0x0182},	//WinXWidth
+    {0xA0, 0x16, 0x0183},	//WinXCenter
+    {0xA0, 0x03, 0x0184},	//WinYStart
+    {0xA0, 0x05, 0x0185},	//WinYWidth
+    {0xA0, 0x14, 0x0186},	//WinYCenter
+    {0xA0, 0x00, 0x0180},	//AutoCorrectEnable
+    
+/* Auto exposure and white balance */
+    {0xA0, 0x00, 0x0190},	//ExposureLimitHigh 0
+    {0xA0, 0x03, 0x0191},	//ExposureLimitMid
+    {0xA0, 0xb1, 0x0192},	//ExposureLimitLow 0xb1
+    
+    {0xA0, 0x00, 0x0195},	//AntiFlickerHigh 0x00
+    {0xA0, 0x00, 0x0196},	//AntiFlickerLow 0x00
+    {0xA0, 0x87, 0x0197},	//AntiFlickerLow 0x87
+    
+    {0xA0, 0x10, 0x018C},	//AEBFreeze 0x10 0x0c
+    {0xA0, 0x20, 0x018F},	//AEBUnfreeze 0x30 0x18
+    /* sensor on */
+    {0xA0, 0x07, 0x0092},	//write register 0x07 to sensor (i2c)
+    {0xA0, 0xB1, 0x0093},	//Value 0xB1
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x05, 0x0092},	//write register 0x05 to sensor (i2c)
+    {0xA0, 0x03, 0x0093},	//Value 0x03
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x04, 0x0092},	//write register 0x04 to sensor (i2c)
+    {0xA0, 0x01, 0x0093},	//Value 0x01
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+    {0xA0, 0x03, 0x0092},	//write register 0x03 to sensor (i2c)
+    {0xA0, 0x3b, 0x0093},	//Value 0x3B
+    {0xA0, 0x00, 0x0094},
+    {0xA0, 0x01, 0x0090},
+    {0xA1, 0x01, 0x0091},	//end write i2c
+ 
+/* Gains */
+    {0xA0, 0x20, 0x01A9},	//DigitalLimitDiff
+    {0xA0, 0x26, 0x01AA},	//DigitalGainStep
+    {0xA0, 0xA0, 0x011D},	//GlobalGain
+    {0xA0, 0x60, 0x011D},	//GlobalGain
+/* Auto correction */
+    {0xA0, 0x40, 0x0180},	//AutoCorrectEnable
+    {0xa1, 0x01, 0x0180},	//AutoCorrectEnable
+    {0xA0, 0x42, 0x0180},	//AutoCorrectEnable
+/* Gains */
+    {0xA0, 0x40, 0x0116},	//RGain
+    {0xA0, 0x40, 0x0117},	//GGain
+    {0xA0, 0x40, 0x0118},	//BGain
+    
+    {0xA0, 0x00, 0x0007},	//AutoCorrectEnable
+    {0xA0, 0xFF, 0x0018},	//Frame adjust
+    {0, 0, 0}
+};
+static __u16 pas106b_50HZ[][3] = {
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0006, 0x0191}, //01,91,06,cc
+    {0xa0, 0x0054, 0x0192}, //01,92,54,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0087, 0x0197}, //01,97,87,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0030, 0x018f}, //01,8f,30,cc
+    {0xa0, 0x0003, 0x0092}, //00,03,21,aa
+    {0xa0, 0x0021, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,0c,aa
+    {0xa0, 0x000c, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0005, 0x0092}, //00,05,02,aa
+    {0xa0, 0x0002, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0007, 0x0092}, //00,07,1c,aa
+    {0xa0, 0x001c, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x01a9}, //01,a9,04,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 pas106b_60HZ[][3] = {
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0006, 0x0191}, //01,91,06,cc
+    {0xa0, 0x002e, 0x0192}, //01,92,2e,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0071, 0x0197}, //01,97,71,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0030, 0x018f}, //01,8f,30,cc
+    {0xa0, 0x0003, 0x0092}, //00,03,1c,aa
+    {0xa0, 0x001c, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,04,aa
+    {0xa0, 0x0004, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0005, 0x0092}, //00,05,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0007, 0x0092}, //00,07,c4,aa
+    {0xa0, 0x00c4, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x01a9}, //01,a9,04,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 pas106b_NoFliker[][3] = {
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0006, 0x0191}, //01,91,06,cc
+    {0xa0, 0x0050, 0x0192}, //01,92,50,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0003, 0x0092}, //00,03,13,aa
+    {0xa0, 0x0013, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0004, 0x0092}, //00,04,00,aa
+    {0xa0, 0x0000, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0005, 0x0092}, //00,05,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0007, 0x0092}, //00,07,30,aa
+    {0xa0, 0x0030, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+/*******************/
+{0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/pb0330.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/pb0330.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/pb0330.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/pb0330.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,1015 @@
+
+/****************************************************************************
+#	 	Photobit Pb0330 MI0360 library                              #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+/* Aurelien setting from snoop */
+static __u16 pb03303x_start_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x0a, 0x0010},
+    {0xa0, 0x10, 0x0002},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0xdc, 0x008b},	//8b -> dc
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x03, 0x0012},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0xdc, 0x008b},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x83, 0x0093},
+    {0xa0, 0x04, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x06, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x02, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0xe7, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x87, 0x0093},
+    {0xa0, 0x02, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x07, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x30, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x11, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x35, 0x0092},
+    {0xa0, 0x50, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x30, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x31, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x58, 0x0092},
+    {0xa0, 0x78, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x62, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x04, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2b, 0x0092},
+    {0xa0, 0x28, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2c, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2d, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2e, 0x0092},
+    {0xa0, 0x28, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0087},
+    {0xa0, 0x37, 0x0101},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x00, 0x01ad},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa0, 0x60, 0x01a8},
+    {0xa0, 0x78, 0x018d},
+    {0xa0, 0x61, 0x0116},
+    {0xa0, 0x65, 0x0118},
+
+    {0xa1, 0x01, 0x0002},
+    {0xa0, 0x09, 0x01ad},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x0d, 0x003a},
+    {0xa0, 0x02, 0x003b},
+    {0xa0, 0x00, 0x0038},
+    {0xa0, 0x50, 0x010a},
+    {0xa0, 0xf8, 0x010b},
+    {0xa0, 0xf8, 0x010c},
+    {0xa0, 0xf8, 0x010d},
+    {0xa0, 0x50, 0x010e},
+    {0xa0, 0xf8, 0x010f},
+    {0xa0, 0xf8, 0x0110},
+    {0xa0, 0xf8, 0x0111},
+    {0xa0, 0x50, 0x0112},
+
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x01c6},
+
+    {0xa1, 0x01, 0x01c8},
+
+    {0xa1, 0x01, 0x01c9},
+
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+    {0xa0, 0x13, 0x0120},
+    {0xa0, 0x38, 0x0121},
+    {0xa0, 0x59, 0x0122},
+    {0xa0, 0x79, 0x0123},
+    {0xa0, 0x92, 0x0124},
+    {0xa0, 0xa7, 0x0125},
+    {0xa0, 0xb9, 0x0126},
+    {0xa0, 0xc8, 0x0127},
+    {0xa0, 0xd4, 0x0128},
+    {0xa0, 0xdf, 0x0129},
+    {0xa0, 0xe7, 0x012a},
+    {0xa0, 0xee, 0x012b},
+    {0xa0, 0xf4, 0x012c},
+    {0xa0, 0xf9, 0x012d},
+    {0xa0, 0xfc, 0x012e},
+    {0xa0, 0xff, 0x012f},
+    {0xa0, 0x26, 0x0130},
+    {0xa0, 0x22, 0x0131},
+    {0xa0, 0x20, 0x0132},
+    {0xa0, 0x1c, 0x0133},
+    {0xa0, 0x16, 0x0134},
+    {0xa0, 0x13, 0x0135},
+    {0xa0, 0x10, 0x0136},
+    {0xa0, 0x0d, 0x0137},
+    {0xa0, 0x0b, 0x0138},
+    {0xa0, 0x09, 0x0139},
+    {0xa0, 0x07, 0x013a},
+    {0xa0, 0x06, 0x013b},
+    {0xa0, 0x05, 0x013c},
+    {0xa0, 0x04, 0x013d},
+    {0xa0, 0x03, 0x013e},
+    {0xa0, 0x02, 0x013f},
+    {0xa0, 0x50, 0x010a},
+    {0xa0, 0xf8, 0x010b},
+    {0xa0, 0xf8, 0x010c},
+    {0xa0, 0xf8, 0x010d},
+    {0xa0, 0x50, 0x010e},
+    {0xa0, 0xf8, 0x010f},
+    {0xa0, 0xf8, 0x0110},
+    {0xa0, 0xf8, 0x0111},
+    {0xa0, 0x50, 0x0112},
+
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x09, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x09, 0x0092},
+    {0xa0, 0x34, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x07, 0x0191},
+    {0xa0, 0xec, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x9c, 0x0197},
+    {0xa0, 0x0e, 0x018c},
+    {0xa0, 0x1c, 0x018f},
+    {0xa0, 0x14, 0x01a9},
+    {0xa0, 0x24, 0x01aa},
+    {0xa0, 0xd7, 0x001d},
+    {0xa0, 0xf4, 0x001e},
+    {0xa0, 0xf9, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x42, 0x0180},
+    {0xa0, 0x09, 0x01ad},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0, 0, 0}
+};
+
+static __u16 pb03303x_scale_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x0a, 0x0010},
+    {0xa0, 0x00, 0x0002},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0xdc, 0x008b},	//8b -> dc
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x03, 0x0012},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0xdc, 0x008b},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x83, 0x0093},
+    {0xa0, 0x04, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x04, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x08, 0x0092},
+    {0xa0, 0x06, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x02, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0xe7, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x87, 0x0093},
+    {0xa0, 0x02, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x07, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x30, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x11, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x35, 0x0092},
+    {0xa0, 0x50, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x30, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x31, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x58, 0x0092},
+    {0xa0, 0x78, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x62, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x04, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2b, 0x0092},
+    {0xa0, 0x28, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2c, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2d, 0x0092},
+    {0xa0, 0x30, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2e, 0x0092},
+    {0xa0, 0x28, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0087},
+    {0xa0, 0x37, 0x0101},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x00, 0x01ad},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa0, 0x60, 0x01a8},
+    {0xa0, 0x78, 0x018d},
+    {0xa0, 0x61, 0x0116},
+    {0xa0, 0x65, 0x0118},
+
+    {0xa1, 0x01, 0x0002},
+    {0xa0, 0x09, 0x01ad},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x0d, 0x003a},
+    {0xa0, 0x02, 0x003b},
+    {0xa0, 0x00, 0x0038},
+    {0xa0, 0x50, 0x010a},
+    {0xa0, 0xf8, 0x010b},
+    {0xa0, 0xf8, 0x010c},
+    {0xa0, 0xf8, 0x010d},
+    {0xa0, 0x50, 0x010e},
+    {0xa0, 0xf8, 0x010f},
+    {0xa0, 0xf8, 0x0110},
+    {0xa0, 0xf8, 0x0111},
+    {0xa0, 0x50, 0x0112},
+
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x01c6},
+
+    {0xa1, 0x01, 0x01c8},
+
+    {0xa1, 0x01, 0x01c9},
+
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+    {0xa0, 0x13, 0x0120},
+    {0xa0, 0x38, 0x0121},
+    {0xa0, 0x59, 0x0122},
+    {0xa0, 0x79, 0x0123},
+    {0xa0, 0x92, 0x0124},
+    {0xa0, 0xa7, 0x0125},
+    {0xa0, 0xb9, 0x0126},
+    {0xa0, 0xc8, 0x0127},
+    {0xa0, 0xd4, 0x0128},
+    {0xa0, 0xdf, 0x0129},
+    {0xa0, 0xe7, 0x012a},
+    {0xa0, 0xee, 0x012b},
+    {0xa0, 0xf4, 0x012c},
+    {0xa0, 0xf9, 0x012d},
+    {0xa0, 0xfc, 0x012e},
+    {0xa0, 0xff, 0x012f},
+    {0xa0, 0x26, 0x0130},
+    {0xa0, 0x22, 0x0131},
+    {0xa0, 0x20, 0x0132},
+    {0xa0, 0x1c, 0x0133},
+    {0xa0, 0x16, 0x0134},
+    {0xa0, 0x13, 0x0135},
+    {0xa0, 0x10, 0x0136},
+    {0xa0, 0x0d, 0x0137},
+    {0xa0, 0x0b, 0x0138},
+    {0xa0, 0x09, 0x0139},
+    {0xa0, 0x07, 0x013a},
+    {0xa0, 0x06, 0x013b},
+    {0xa0, 0x05, 0x013c},
+    {0xa0, 0x04, 0x013d},
+    {0xa0, 0x03, 0x013e},
+    {0xa0, 0x02, 0x013f},
+    {0xa0, 0x50, 0x010a},
+    {0xa0, 0xf8, 0x010b},
+    {0xa0, 0xf8, 0x010c},
+    {0xa0, 0xf8, 0x010d},
+    {0xa0, 0x50, 0x010e},
+    {0xa0, 0xf8, 0x010f},
+    {0xa0, 0xf8, 0x0110},
+    {0xa0, 0xf8, 0x0111},
+    {0xa0, 0x50, 0x0112},
+
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x09, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x09, 0x0092},
+    {0xa0, 0x34, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x07, 0x0191},
+    {0xa0, 0xec, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x9c, 0x0197},
+    {0xa0, 0x0e, 0x018c},
+    {0xa0, 0x1c, 0x018f},
+    {0xa0, 0x14, 0x01a9},
+    {0xa0, 0x24, 0x01aa},
+    {0xa0, 0xd7, 0x001d},
+    {0xa0, 0xf4, 0x001e},
+    {0xa0, 0xf9, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x42, 0x0180},
+    {0xa0, 0x09, 0x01ad},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0, 0, 0}
+};
+static __u16 pb0330xx_start_data[][3] = {
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x03, 0x0008},	//00
+    {0xa0, 0x0a, 0x0010},
+    {0xa0, 0x10, 0x0002},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x07, 0x0012},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x06, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x02, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0xe7, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x87, 0x0093},
+    {0xa0, 0x02, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x03, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x07, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x30, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x11, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2f, 0x0092},
+    {0xa0, 0xb0, 0x0093},
+    {0xa0, 0xf7, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x30, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x31, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x34, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x35, 0x0092},
+    {0xa0, 0x60, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x3d, 0x0092},
+    {0xa0, 0x8f, 0x0093},
+    {0xa0, 0x06, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x40, 0x0092},
+    {0xa0, 0xe0, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x58, 0x0092},
+    {0xa0, 0x78, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x62, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x04, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0087},
+    {0xa0, 0x37, 0x0101},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x00, 0x01ad},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa0, 0x60, 0x01a8},
+    {0xa0, 0x6c, 0x018d},
+    {0xa1, 0x01, 0x0002},
+    {0xa0, 0x09, 0x01ad},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x00, 0x0092},
+    {0xa0, 0x02, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa1, 0x01, 0x0095},
+    {0xa1, 0x01, 0x0096},
+    {0xa0, 0x50, 0x010a},
+    {0xa0, 0xf8, 0x010b},
+    {0xa0, 0xf8, 0x010c},
+    {0xa0, 0xf8, 0x010d},
+    {0xa0, 0x50, 0x010e},
+    {0xa0, 0xf8, 0x010f},
+    {0xa0, 0xf8, 0x0110},
+    {0xa0, 0xf8, 0x0111},
+    {0xa0, 0x50, 0x0112},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},	//00
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+
+    {0xa0, 0x50, 0x010a},
+    {0xa0, 0xf8, 0x010b},
+    {0xa0, 0xf8, 0x010c},
+    {0xa0, 0xf8, 0x010d},
+    {0xa0, 0x50, 0x010e},
+    {0xa0, 0xf8, 0x010f},
+    {0xa0, 0xf8, 0x0110},
+    {0xa0, 0xf8, 0x0111},
+    {0xa0, 0x50, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x66, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x09, 0x0092},
+    {0xa0, 0xb2, 0x0093},
+    {0xa0, 0x02, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+
+    {0xa0, 0x60, 0x011d},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x07, 0x0191},
+    {0xa0, 0x8c, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x8a, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x14, 0x01a9},
+    {0xa0, 0x24, 0x01aa},
+    {0xa0, 0xd7, 0x001d},
+    {0xa0, 0xf0, 0x001e},
+    {0xa0, 0xf8, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x09, 0x01ad},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0007},
+// { 0xa0, 0x30, 0x0007},
+// { 0xa0, 0x00, 0x0007},
+    {0, 0, 0}
+};
+
+static __u16 pb0330xx_scale_data[][3] = {
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x03, 0x0008},	//00
+    {0xa0, 0x0a, 0x0010},
+    {0xa0, 0x00, 0x0002},	// 10
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x07, 0x0012},
+    {0xa0, 0x00, 0x0098},
+    {0xa0, 0x00, 0x009a},
+    {0xa0, 0x00, 0x011a},
+    {0xa0, 0x00, 0x011c},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x01, 0x0092},
+    {0xa0, 0x06, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x02, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x03, 0x0092},
+    {0xa0, 0xe7, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x04, 0x0092},
+    {0xa0, 0x87, 0x0093},
+    {0xa0, 0x02, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x06, 0x0092},
+    {0xa0, 0x03, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x07, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x30, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x20, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x11, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x2f, 0x0092},
+    {0xa0, 0xb0, 0x0093},
+    {0xa0, 0xf7, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x30, 0x0092},
+    {0xa0, 0x05, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x31, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x34, 0x0092},
+    {0xa0, 0x00, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x35, 0x0092},
+    {0xa0, 0x60, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x3d, 0x0092},
+    {0xa0, 0x8f, 0x0093},
+    {0xa0, 0x06, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x40, 0x0092},
+    {0xa0, 0xe0, 0x0093},
+    {0xa0, 0x01, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x58, 0x0092},
+    {0xa0, 0x78, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x62, 0x0092},
+    {0xa0, 0x11, 0x0093},
+    {0xa0, 0x04, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0087},
+    {0xa0, 0x37, 0x0101},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x00, 0x01ad},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa0, 0x60, 0x01a8},
+    {0xa0, 0x6c, 0x018d},
+    {0xa1, 0x01, 0x0002},
+    {0xa0, 0x09, 0x01ad},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x00, 0x0092},
+    {0xa0, 0x02, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa1, 0x01, 0x0095},
+    {0xa1, 0x01, 0x0096},
+    {0xa0, 0x50, 0x010a},
+    {0xa0, 0xf8, 0x010b},
+    {0xa0, 0xf8, 0x010c},
+    {0xa0, 0xf8, 0x010d},
+    {0xa0, 0x50, 0x010e},
+    {0xa0, 0xf8, 0x010f},
+    {0xa0, 0xf8, 0x0110},
+    {0xa0, 0xf8, 0x0111},
+    {0xa0, 0x50, 0x0112},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},	//00
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+
+    {0xa0, 0x50, 0x010a},
+    {0xa0, 0xf8, 0x010b},
+    {0xa0, 0xf8, 0x010c},
+    {0xa0, 0xf8, 0x010d},
+    {0xa0, 0x50, 0x010e},
+    {0xa0, 0xf8, 0x010f},
+    {0xa0, 0xf8, 0x0110},
+    {0xa0, 0xf8, 0x0111},
+    {0xa0, 0x50, 0x0112},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0x05, 0x0092},
+    {0xa0, 0x66, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x09, 0x0092},
+    {0xa0, 0xb2, 0x0093},
+    {0xa0, 0x02, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x10, 0x0092},
+    {0xa0, 0x02, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x60, 0x011d},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x07, 0x0191},
+    {0xa0, 0x8c, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x8a, 0x0197},
+    {0xa0, 0x10, 0x018c},
+    {0xa0, 0x20, 0x018f},
+    {0xa0, 0x14, 0x01a9},
+    {0xa0, 0x24, 0x01aa},
+    {0xa0, 0xd7, 0x001d},
+    {0xa0, 0xf0, 0x001e},
+    {0xa0, 0xf8, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x09, 0x01ad},
+    {0xa0, 0x15, 0x01ae},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+    {0xa1, 0x01, 0x0008},
+    {0xa1, 0x01, 0x0007},
+// { 0xa0, 0x30, 0x0007},
+// { 0xa0, 0x00, 0x0007},
+    {0, 0, 0}
+};
+static __u16 pb0330_50HZ[][3] = {
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0007, 0x0191}, //01,91,07,cc
+    {0xa0, 0x00ee, 0x0192}, //01,92,ee,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0046, 0x0197}, //01,97,46,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0026, 0x01aa}, //01,aa,26,cc
+    {0xa0, 0x0068, 0x001d}, //00,1d,68,cc
+    {0xa0, 0x0090, 0x001e}, //00,1e,90,cc
+    {0xa0, 0x00c8, 0x001f}, //00,1f,c8,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 pb0330_50HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0007, 0x0191}, //01,91,07,cc
+    {0xa0, 0x00a0, 0x0192}, //01,92,a0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x007a, 0x0197}, //01,97,7a,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0026, 0x01aa}, //01,aa,26,cc
+    {0xa0, 0x00e5, 0x001d}, //00,1d,e5,cc
+    {0xa0, 0x00f0, 0x001e}, //00,1e,f0,cc
+    {0xa0, 0x00f8, 0x001f}, //00,1f,f8,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 pb0330_60HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0007, 0x0191}, //01,91,07,cc
+    {0xa0, 0x00dd, 0x0192}, //01,92,dd,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x003d, 0x0197}, //01,97,3d,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0026, 0x01aa}, //01,aa,26,cc
+    {0xa0, 0x0043, 0x001d}, //00,1d,43,cc
+    {0xa0, 0x0050, 0x001e}, //00,1e,50,cc
+    {0xa0, 0x0090, 0x001f}, //00,1f,90,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 pb0330_60HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0007, 0x0191}, //01,91,07,cc
+    {0xa0, 0x00a0, 0x0192}, //01,92,a0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x007a, 0x0197}, //01,97,7a,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0026, 0x01aa}, //01,aa,26,cc
+    {0xa0, 0x0041, 0x001d}, //00,1d,41,cc
+    {0xa0, 0x0050, 0x001e}, //00,1e,50,cc
+    {0xa0, 0x0090, 0x001f}, //00,1f,90,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 pb0330_NoFliker[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0007, 0x0191}, //01,91,07,cc
+    {0xa0, 0x00f0, 0x0192}, //01,92,f0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x0009, 0x001d}, //00,1d,09,cc
+    {0xa0, 0x0040, 0x001e}, //00,1e,40,cc
+    {0xa0, 0x0090, 0x001f}, //00,1f,90,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 pb0330_NoFlikerScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0007, 0x0191}, //01,91,07,cc
+    {0xa0, 0x00f0, 0x0192}, //01,92,f0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x0009, 0x001d}, //00,1d,09,cc
+    {0xa0, 0x0040, 0x001e}, //00,1e,40,cc
+    {0xa0, 0x0090, 0x001f}, //00,1f,90,cc
+/*******************/
+{0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/tas5130c.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/tas5130c.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/tas5130c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/tas5130c.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,421 @@
+/****************************************************************************
+#	 	TAS5130C      library                                       #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+static __u16 tas5130cxx_start_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x50, 0x0002},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x02, 0x0010},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x00, 0x0001},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x07, 0x00a5},
+    {0xa0, 0x02, 0x00a6},
+ /********************/
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+ /********************/
+    {0xa0, 0x04, 0x0098},
+    {0xa0, 0x0f, 0x009a},
+    {0xa0, 0x04, 0x011a},
+    {0xa0, 0x0f, 0x011c},
+    {0xa0, 0xe8, 0x009c},
+    {0xa0, 0x02, 0x009d},
+    {0xa0, 0x88, 0x009e},
+    {0xa0, 0x06, 0x008d},
+    {0xa0, 0xf7, 0x0101},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x68, 0x018d},
+    {0xa0, 0x60, 0x01a8},
+    {0xa0, 0x00, 0x01ad},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa1, 0x01, 0x0002},
+    {0xa1, 0x01, 0x0008},
+    {0xa0, 0x03, 0x0008},
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+
+    {0xa0, 0x68, 0x010a},
+    {0xa0, 0xec, 0x010b},
+    {0xa0, 0xec, 0x010c},
+    {0xa0, 0xec, 0x010d},
+    {0xa0, 0x68, 0x010e},
+    {0xa0, 0xec, 0x010f},
+    {0xa0, 0xec, 0x0110},
+    {0xa0, 0xec, 0x0111},
+    {0xa0, 0x68, 0x0112},
+ /****** MATRIXT *****/
+    {0xa1, 0x01, 0x018d},
+    {0xa0, 0x90, 0x018d},	//90
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+
+    {0xa0, 0xa3, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0xa4, 0x0092},
+    {0xa0, 0x77, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x01, 0x00a3},
+    {0xa0, 0x77, 0x00a4},
+
+    {0xa0, 0x00, 0x0190},	//00
+    {0xa0, 0x03, 0x0191},	//03
+    {0xa0, 0xe8, 0x0192},	//e8
+    {0xa0, 0x0, 0x0195},	//0
+    {0xa0, 0x0, 0x0196},	//0
+    {0xa0, 0x7d, 0x0197},	//7d
+
+    {0xa0, 0x0c, 0x018c},
+    {0xa0, 0x18, 0x018f},
+    {0xa0, 0x08, 0x01a9},	//08
+    {0xa0, 0x24, 0x01aa},	//24
+    {0xa0, 0xf0, 0x001d},
+    {0xa0, 0xf4, 0x001e},
+    {0xa0, 0xf8, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x03, 0x009f},
+    {0xa0, 0xc0, 0x00a0},
+    {0xa0, 0x50, 0x011d},	//50
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+ /********************/
+    {0, 0, 0},
+};
+static __u16 tas5130cxx_scale_data[][3] = {
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x01, 0x0000},
+    {0xa0, 0x40, 0x0002},
+  /*******************/
+    {0xa0, 0x03, 0x0008},
+    {0xa1, 0x01, 0x0008},
+ /*******************/
+    {0xa0, 0x02, 0x0010},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x00, 0x0001},
+    {0xa0, 0x01, 0x0012},
+    {0xa0, 0x01, 0x0001},
+    {0xa0, 0x05, 0x0012},
+    {0xa0, 0x07, 0x00a5},
+    {0xa0, 0x02, 0x00a6},
+    {0xa0, 0x02, 0x0003},
+    {0xa0, 0x80, 0x0004},
+    {0xa0, 0x01, 0x0005},
+    {0xa0, 0xe0, 0x0006},
+    {0xa0, 0x05, 0x0098},
+    {0xa0, 0x0f, 0x009a},
+    {0xa0, 0x05, 0x011a},
+    {0xa0, 0x0f, 0x011c},
+    {0xa0, 0xe6, 0x009c},
+    {0xa0, 0x02, 0x009d},
+    {0xa0, 0x86, 0x009e},
+    {0xa0, 0x06, 0x008d},
+    {0xa0, 0x37, 0x0101},
+    {0xa0, 0x0d, 0x0100},
+    {0xa0, 0x06, 0x0189},
+    {0xa0, 0x68, 0x018d},
+    {0xa0, 0x60, 0x01a8},
+    {0xa0, 0x00, 0x01ad},
+    {0xa0, 0x03, 0x01c5},
+    {0xa0, 0x13, 0x01cb},
+    {0xa0, 0x08, 0x0250},
+    {0xa0, 0x08, 0x0301},
+    {0xa1, 0x01, 0x0002},
+    {0xa1, 0x01, 0x0008},
+ /*******************/
+    {0xa0, 0x03, 0x0008},
+    {0xa1, 0x01, 0x0008},
+ /*******************/
+    {0xa0, 0x08, 0x01c6},
+    {0xa1, 0x01, 0x01c8},
+    {0xa1, 0x01, 0x01c9},
+    {0xa1, 0x01, 0x01ca},
+    {0xa0, 0x0f, 0x01cb},
+ /*******************/
+    {0xa0, 0x68, 0x010a},
+    {0xa0, 0xec, 0x010b},
+    {0xa0, 0xec, 0x010c},
+    {0xa0, 0xec, 0x010d},
+    {0xa0, 0x68, 0x010e},
+    {0xa0, 0xec, 0x010f},
+    {0xa0, 0xec, 0x0110},
+    {0xa0, 0xec, 0x0111},
+    {0xa0, 0x68, 0x0112},
+ /*******************/
+    {0xa1, 0x01, 0x018d},
+    {0xa0, 0x90, 0x018d},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x00, 0x0180},
+    {0xa0, 0x00, 0x0019},
+    {0xa0, 0xa3, 0x0092},
+    {0xa0, 0x01, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0xa4, 0x0092},
+    {0xa0, 0x63, 0x0093},
+    {0xa0, 0x00, 0x0094},
+    {0xa0, 0x01, 0x0090},
+    {0xa1, 0x01, 0x0091},
+    {0xa0, 0x01, 0x00a3},
+    {0xa0, 0x63, 0x00a4},
+    {0xa0, 0x00, 0x0190},
+    {0xa0, 0x02, 0x0191},
+    {0xa0, 0x38, 0x0192},
+    {0xa0, 0x00, 0x0195},
+    {0xa0, 0x00, 0x0196},
+    {0xa0, 0x47, 0x0197},
+    {0xa0, 0x0c, 0x018c},
+    {0xa0, 0x18, 0x018f},
+    {0xa0, 0x08, 0x01a9},
+    {0xa0, 0x24, 0x01aa},
+    {0xa0, 0xd3, 0x001d},
+    {0xa0, 0xda, 0x001e},
+    {0xa0, 0xea, 0x001f},
+    {0xa0, 0xff, 0x0020},
+    {0xa0, 0x03, 0x009f},
+    {0xa0, 0x4c, 0x00a0},
+    {0xa0, 0x50, 0x011d},
+    {0xa0, 0x40, 0x0180},
+    {0xa1, 0x01, 0x0180},
+    {0xa0, 0x42, 0x0180},
+ /********************/
+    {0, 0, 0},
+};
+static __u16 tas5130cxx_50HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x00a3, 0x0092}, //00,a3,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x00a4, 0x0092}, //00,a4,63,aa
+    {0xa0, 0x0063, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0001, 0x00a3}, //00,a3,01,cc
+    {0xa0, 0x0063, 0x00a4}, //00,a4,63,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0002, 0x0191}, //01,91,02,cc
+    {0xa0, 0x0038, 0x0192}, //01,92,38,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0047, 0x0197}, //01,97,47,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0026, 0x01aa}, //01,aa,26,cc
+    {0xa0, 0x00d3, 0x001d}, //00,1d,d3,cc
+    {0xa0, 0x00da, 0x001e}, //00,1e,da,cc
+    {0xa0, 0x00ea, 0x001f}, //00,1f,ea,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0003, 0x009f}, //00,9f,03,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 tas5130cxx_50HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x00a3, 0x0092}, //00,a3,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x00a4, 0x0092}, //00,a4,77,aa
+    {0xa0, 0x0077, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0001, 0x00a3}, //00,a3,01,cc
+    {0xa0, 0x0077, 0x00a4}, //00,a4,77,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0003, 0x0191}, //01,91,03,cc
+    {0xa0, 0x00e8, 0x0192}, //01,92,e8,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x007d, 0x0197}, //01,97,7d,cc
+    {0xa0, 0x0014, 0x018c}, //01,8c,14,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0026, 0x01aa}, //01,aa,26,cc
+    {0xa0, 0x00f0, 0x001d}, //00,1d,f0,cc
+    {0xa0, 0x00f4, 0x001e}, //00,1e,f4,cc
+    {0xa0, 0x00f8, 0x001f}, //00,1f,f8,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0003, 0x009f}, //00,9f,03,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 tas5130cxx_60HZ[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x00a3, 0x0092}, //00,a3,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x00a4, 0x0092}, //00,a4,36,aa
+    {0xa0, 0x0036, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0001, 0x00a3}, //00,a3,01,cc
+    {0xa0, 0x0036, 0x00a4}, //00,a4,36,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0001, 0x0191}, //01,91,01,cc
+    {0xa0, 0x00f0, 0x0192}, //01,92,f0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x003e, 0x0197}, //01,97,3e,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0026, 0x01aa}, //01,aa,26,cc
+    {0xa0, 0x00ca, 0x001d}, //00,1d,ca,cc
+    {0xa0, 0x00d0, 0x001e}, //00,1e,d0,cc
+    {0xa0, 0x00e0, 0x001f}, //00,1f,e0,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0003, 0x009f}, //00,9f,03,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 tas5130cxx_60HZScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x00a3, 0x0092}, //00,a3,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x00a4, 0x0092}, //00,a4,77,aa
+    {0xa0, 0x0077, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0001, 0x00a3}, //00,a3,01,cc
+    {0xa0, 0x0077, 0x00a4}, //00,a4,77,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0003, 0x0191}, //01,91,03,cc
+    {0xa0, 0x00e8, 0x0192}, //01,92,e8,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x007d, 0x0197}, //01,97,7d,cc
+    {0xa0, 0x0014, 0x018c}, //01,8c,14,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x000c, 0x01a9}, //01,a9,0c,cc
+    {0xa0, 0x0026, 0x01aa}, //01,aa,26,cc
+    {0xa0, 0x00c8, 0x001d}, //00,1d,c8,cc
+    {0xa0, 0x00d0, 0x001e}, //00,1e,d0,cc
+    {0xa0, 0x00e0, 0x001f}, //00,1f,e0,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0003, 0x009f}, //00,9f,03,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 tas5130cxx_NoFliker[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x00a3, 0x0092}, //00,a3,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x00a4, 0x0092}, //00,a4,40,aa
+    {0xa0, 0x0040, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0001, 0x00a3}, //00,a3,01,cc
+    {0xa0, 0x0040, 0x00a4}, //00,a4,40,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0001, 0x0191}, //01,91,01,cc
+    {0xa0, 0x00f0, 0x0192}, //01,92,f0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x00bc, 0x001d}, //00,1d,bc,cc
+    {0xa0, 0x00d0, 0x001e}, //00,1e,d0,cc
+    {0xa0, 0x00e0, 0x001f}, //00,1f,e0,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0002, 0x009f}, //00,9f,02,cc
+/*******************/
+{0, 0, 0}
+};
+static __u16 tas5130cxx_NoFlikerScale[][3] = {
+    {0xa0, 0x0000, 0x0019}, //00,19,00,cc
+    {0xa0, 0x00a3, 0x0092}, //00,a3,01,aa
+    {0xa0, 0x0001, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x00a4, 0x0092}, //00,a4,90,aa
+    {0xa0, 0x0090, 0x0093}, //
+    {0xa0, 0x0000, 0x0094}, //
+    {0xa0, 0x0001, 0x0090}, //
+    {0xa1, 0x0001, 0x0091}, //
+/**********************/
+    {0xa0, 0x0001, 0x00a3}, //00,a3,01,cc
+    {0xa0, 0x0090, 0x00a4}, //00,a4,90,cc
+    {0xa0, 0x0000, 0x0190}, //01,90,00,cc
+    {0xa0, 0x0003, 0x0191}, //01,91,03,cc
+    {0xa0, 0x00f0, 0x0192}, //01,92,f0,cc
+    {0xa0, 0x0000, 0x0195}, //01,95,00,cc
+    {0xa0, 0x0000, 0x0196}, //01,96,00,cc
+    {0xa0, 0x0010, 0x0197}, //01,97,10,cc
+    {0xa0, 0x0010, 0x018c}, //01,8c,10,cc
+    {0xa0, 0x0020, 0x018f}, //01,8f,20,cc
+    {0xa0, 0x0000, 0x01a9}, //01,a9,00,cc
+    {0xa0, 0x0000, 0x01aa}, //01,aa,00,cc
+    {0xa0, 0x00bc, 0x001d}, //00,1d,bc,cc
+    {0xa0, 0x00d0, 0x001e}, //00,1e,d0,cc
+    {0xa0, 0x00e0, 0x001f}, //00,1f,e0,cc
+    {0xa0, 0x00ff, 0x0020}, //00,20,ff,cc
+    {0xa0, 0x0002, 0x009f}, //00,9f,02,cc
+/*******************/
+{0, 0, 0}
+};
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/tas5130c_vf0250.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/tas5130c_vf0250.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/tas5130c_vf0250.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/tas5130c_vf0250.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,567 @@
+/****************************************************************************
+#    		TAS5130C library, firmware version from			    #
+#		Creative Live!Cam Notebook Pro (VF0250)			    #
+# 	Copyright (C) 2004 Michel Xhaard  mxhaard@magic.fr          	    #
+#  	Copyright (C) 2006 Serge Suchkov  Serge.A.S@tochka.ru	    	    #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+static __u16 tas5130c_vf0250_start_data[][3] = {
+    {0xa0, 0x0001, 0x0000},           //00,00,01,cc,
+    {0xa0, 0x0002, 0x0008},           //00,08,02,cc,
+    {0xa0, 0x0001, 0x0010},           //00,10,01,cc, 
+    {0xa0, 0x0010, 0x0002},           //00,02,00,cc,  0<->10
+    {0xa0, 0x0002, 0x0003},           //00,03,02,cc, 
+    {0xa0, 0x0080, 0x0004},           //00,04,80,cc, 
+    {0xa0, 0x0001, 0x0005},           //00,05,01,cc, 
+    {0xa0, 0x00e0, 0x0006},           //00,06,e0,cc, 
+    {0xa0, 0x0098, 0x008b},           //00,8b,98,cc, 
+    {0xa0, 0x0001, 0x0001},           //00,01,01,cc, 
+    {0xa0, 0x0003, 0x0012},           //00,12,03,cc, 
+    {0xa0, 0x0001, 0x0012},           //00,12,01,cc, 
+    {0xa0, 0x0000, 0x0098},           //00,98,00,cc, 
+    {0xa0, 0x0000, 0x009a},           //00,9a,00,cc, 
+    {0xa0, 0x0000, 0x011a},           //01,1a,00,cc, 
+    {0xa0, 0x0000, 0x011c},           //01,1c,00,cc, 
+    {0xa0, 0x00e8, 0x009c},           //00,9c,e6,cc,  6<->8
+    {0xa0, 0x0088, 0x009e},           //00,9e,86,cc,  6<->8
+    {0xa0, 0x0010, 0x0087},           //00,87,10,cc, 
+    {0xa0, 0x0098, 0x008b},           //00,8b,98,cc, 
+    {0xa0, 0x001b, 0x0092},           //00,1b,24,aa, 
+    {0xa0, 0x0024, 0x0093},            
+    {0xa0, 0x0000, 0x0094},           
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0000, 0x0039},           //00,00,80,dd, ???
+    {0xa1, 0x0001, 0x0037},           //             ???
+    {0xa0, 0x001b, 0x0092},           //00,1b,00,aa,   
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0013, 0x0092},           //00,13,02,aa, 
+    {0xa0, 0x0002, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0015, 0x0092},           //00,15,04,aa
+    {0xa0, 0x0004, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0001, 0x0092},
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},          //00,01,00,aa,   
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0001, 0x0092},            
+    {0xa0, 0x0000, 0x0093},            
+    {0xa0, 0x0000, 0x0094},            
+    {0xa0, 0x0001, 0x0090},            
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x001a, 0x0092},          //00,1a,00,aa,  
+    {0xa0, 0x0000, 0x0093},            
+    {0xa0, 0x0000, 0x0094},            
+    {0xa0, 0x0001, 0x0090},            
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x001c, 0x0092},          //00,1c,17,aa,  
+    {0xa0, 0x0017, 0x0093},           
+    {0xa0, 0x0000, 0x0094},           
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0082, 0x0086},           //00,86,82,cc,  
+    {0xa0, 0x0083, 0x0087},           //00,87,83,cc,  
+    {0xa0, 0x0084, 0x0088},           //00,88,84,cc,  
+    {0xa0, 0x0005, 0x0092},           //00,05,10,aa,  
+    {0xa0, 0x0010, 0x0093},           
+    {0xa0, 0x0000, 0x0094},           
+    {0xa0, 0x0001, 0x0090},           
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x000a, 0x0092},           //00,0a,00,aa, 
+    {0xa0, 0x0000, 0x0093},                          
+    {0xa0, 0x0000, 0x0094},          
+    {0xa0, 0x0001, 0x0090},          
+    {0xa1, 0x0001, 0x0091},          
+    {0xa0, 0x000b, 0x0092},           //00,0b,a0,aa, 
+    {0xa0, 0x00a0, 0x0093},                          
+    {0xa0, 0x0000, 0x0094},            
+    {0xa1, 0x0001, 0x0091},           
+    {0xa0, 0x0001, 0x0090},            
+    {0xa0, 0x000c, 0x0092},           //00,0c,00,aa, 
+    {0xa0, 0x0000, 0x0093},           
+    {0xa0, 0x0000, 0x0094},           
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x000d, 0x0092},           //00,0d,a0,aa, 
+    {0xa0, 0x00a0, 0x0093},           
+    {0xa0, 0x0000, 0x0094},                          
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x000e, 0x0092},           //00,0e,00,aa, 
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x000f, 0x0092},           //00,0f,a0,aa,
+    {0xa0, 0x00a0, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0010, 0x0092},           //00,10,00,aa,
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0011, 0x0092},           //00,11,a0,aa,
+    {0xa0, 0x00a0, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0000, 0x0039},
+    {0xa1, 0x0001, 0x0037},
+    {0xa0, 0x0016, 0x0092},           //00,16,01,aa,
+    {0xa0, 0x0001, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa0, 0x0017, 0x0092},           //00,17,e6,aa,
+    {0xa0, 0x00e8, 0x0093},           //  6<->8 
+    {0xa0, 0x0000, 0x0094},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0001, 0x0090},
+    {0xa0, 0x0018, 0x0092},           //00,18,02,aa,
+    {0xa0, 0x0002, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0001, 0x0090},
+    {0xa0, 0x0019, 0x0092},           //00,19,86,aa,
+    {0xa0, 0x0088, 0x0093},           //  6<->8
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0020, 0x0092},           //00,20,20,aa,
+    {0xa0, 0x0020, 0x0093},           
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x00b7, 0x0101},           //01,01,b7,cc,
+    {0xa0, 0x0005, 0x0012},           //00,12,05,cc, 
+    {0xa0, 0x000d, 0x0100},           //01,00,0d,cc, 
+    {0xa0, 0x0076, 0x0189},           //01,89,76,cc,
+    {0xa0, 0x0009, 0x01ad},           //01,ad,09,cc,
+    {0xa0, 0x0003, 0x01c5},           //01,c5,03,cc,
+    {0xa0, 0x0013, 0x01cb},           //01,cb,13,cc,
+    {0xa0, 0x0008, 0x0250},           //02,50,08,cc,
+    {0xa0, 0x0008, 0x0301},           //03,01,08,cc,
+    {0xa0, 0x0060, 0x01a8},           //01,a8,60,cc,
+    {0xa0, 0x0061, 0x0116},           //01,16,61,cc,
+    {0xa0, 0x0065, 0x0118},           //01,18,65,cc  
+ /********************/
+    {0, 0, 0}
+};
+
+static __u16 tas5130c_vf0250_scale_data[][3] = {
+    {0xa0, 0x0001, 0x0000},          //00,00,01,cc,
+    {0xa0, 0x0002, 0x0008},          //00,08,02,cc,
+    {0xa0, 0x0001, 0x0010},          //00,10,01,cc,
+    {0xa0, 0x0000, 0x0002},          //00,02,10,cc, 
+    {0xa0, 0x0002, 0x0003},          //00,03,02,cc, 
+    {0xa0, 0x0080, 0x0004},          //00,04,80,cc, 
+    {0xa0, 0x0001, 0x0005},          //00,05,01,cc, 
+    {0xa0, 0x00e0, 0x0006},          //00,06,e0,cc, 
+    {0xa0, 0x0098, 0x008b},          //00,8b,98,cc, 
+    {0xa0, 0x0001, 0x0001},          //00,01,01,cc, 
+    {0xa0, 0x0003, 0x0012},          //00,12,03,cc, 
+    {0xa0, 0x0001, 0x0012},          //00,12,01,cc, 
+    {0xa0, 0x0000, 0x0098},          //00,98,00,cc, 
+    {0xa0, 0x0000, 0x009a},          //00,9a,00,cc, 
+    {0xa0, 0x0000, 0x011a},          //01,1a,00,cc, 
+    {0xa0, 0x0000, 0x011c},          //01,1c,00,cc, 
+    {0xa0, 0x00e8, 0x009c},          //00,9c,e8,cc, 8<->6 
+    {0xa0, 0x0088, 0x009e},          //00,9e,88,cc, 8<->6 
+    {0xa0, 0x0010, 0x0087},          //00,87,10,cc,      
+    {0xa0, 0x0098, 0x008b},          //00,8b,98,cc,      
+    {0xa0, 0x001b, 0x0092},          //00,1b,24,aa,      
+    {0xa0, 0x0024, 0x0093},             
+    {0xa0, 0x0000, 0x0094},                              
+    {0xa0, 0x0001, 0x0090},                              
+    {0xa1, 0x0001, 0x0091},                              
+    {0xa0, 0x0000, 0x0039},          //00,00,80,dd, ??                   
+    {0xa1, 0x0001, 0x0037},          //             ??        
+    {0xa0, 0x001b, 0x0092},          //00,1b,00,aa,                    
+    {0xa0, 0x0000, 0x0093},                              
+    {0xa0, 0x0000, 0x0094},                              
+    {0xa0, 0x0001, 0x0090},                
+    {0xa1, 0x0001, 0x0091},                              
+    {0xa0, 0x0013, 0x0092},          //00,13,02,aa,                    
+    {0xa0, 0x0002, 0x0093},                              
+    {0xa0, 0x0000, 0x0094},                
+    {0xa0, 0x0001, 0x0090},                              
+    {0xa1, 0x0001, 0x0091},                              
+    {0xa0, 0x0015, 0x0092},          //00,15,04,aa                     
+    {0xa0, 0x0004, 0x0093},                              
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0001, 0x0092},            
+    {0xa0, 0x0000, 0x0093},         //00,01,00,aa,   
+    {0xa0, 0x0000, 0x0094},           
+    {0xa0, 0x0001, 0x0090},           
+    {0xa1, 0x0001, 0x0091},           
+    {0xa0, 0x0001, 0x0092},           
+    {0xa0, 0x0000, 0x0093},           
+    {0xa0, 0x0000, 0x0094},           
+    {0xa0, 0x0001, 0x0090},           
+    {0xa1, 0x0001, 0x0091},           
+    {0xa0, 0x001a, 0x0092},         //00,1a,00,aa, 
+    {0xa0, 0x0000, 0x0093},          
+    {0xa0, 0x0000, 0x0094},           
+    {0xa0, 0x0001, 0x0090},         
+    {0xa1, 0x0001, 0x0091},            
+    {0xa0, 0x001c, 0x0092},         //00,1c,17,aa,  
+    {0xa0, 0x0017, 0x0093},           
+    {0xa0, 0x0000, 0x0094},          
+    {0xa0, 0x0001, 0x0090},           
+    {0xa1, 0x0001, 0x0091},          
+    {0xa0, 0x0082, 0x0086},          //00,86,82,cc, 
+    {0xa0, 0x0083, 0x0087},          //00,87,83,cc, 
+    {0xa0, 0x0084, 0x0088},          //00,88,84,cc, 
+    {0xa0, 0x0005, 0x0092},          //00,05,10,aa,
+    {0xa0, 0x0010, 0x0093},          
+    {0xa0, 0x0000, 0x0094},          
+    {0xa0, 0x0001, 0x0090},          
+    {0xa1, 0x0001, 0x0091},          
+    {0xa0, 0x000a, 0x0092},          //00,0a,00,aa, 
+    {0xa0, 0x0000, 0x0093},                         
+    {0xa0, 0x0000, 0x0094},         
+    {0xa0, 0x0001, 0x0090},         
+    {0xa1, 0x0001, 0x0091},         
+    {0xa0, 0x000b, 0x0092},          //00,0b,a0,aa, 
+    {0xa0, 0x00a0, 0x0093},          
+    {0xa0, 0x0000, 0x0094},          
+    {0xa1, 0x0001, 0x0091},          
+    {0xa0, 0x0001, 0x0090},            
+    {0xa0, 0x000c, 0x0092},          //00,0c,00,aa,  
+    {0xa0, 0x0000, 0x0093},           
+    {0xa0, 0x0000, 0x0094},          
+    {0xa0, 0x0001, 0x0090},           
+    {0xa1, 0x0001, 0x0091},           
+    {0xa0, 0x000d, 0x0092},          //00,0d,a0,aa, 
+    {0xa0, 0x00a0, 0x0093},          
+    {0xa0, 0x0000, 0x0094},          
+    {0xa0, 0x0001, 0x0090},          
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x000e, 0x0092},          //00,0e,00,aa,
+    {0xa0, 0x0000, 0x0093},          
+    {0xa0, 0x0000, 0x0094},          
+    {0xa0, 0x0001, 0x0090},          
+    {0xa1, 0x0001, 0x0091},          
+    {0xa0, 0x000f, 0x0092},          //00,0f,a0,aa, 
+    {0xa0, 0x00a0, 0x0093},          
+    {0xa0, 0x0000, 0x0094},          
+    {0xa0, 0x0001, 0x0090},           
+    {0xa1, 0x0001, 0x0091},          
+    {0xa0, 0x0010, 0x0092},          //00,10,00,aa,                
+    {0xa0, 0x0000, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},         
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0011, 0x0092},          //00,11,a0,aa,
+    {0xa0, 0x00a0, 0x0093},         
+    {0xa0, 0x0000, 0x0094},         
+    {0xa0, 0x0001, 0x0090},          
+    {0xa1, 0x0001, 0x0091},         
+    {0xa0, 0x0000, 0x0039},         
+    {0xa1, 0x0001, 0x0037},          
+    {0xa0, 0x0016, 0x0092},          //00,16,01,aa, 
+    {0xa0, 0x0001, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},          
+    {0xa0, 0x0017, 0x0092},          //00,17,e6,aa
+    {0xa0, 0x00e8, 0x0093},          // 8<->6         
+    {0xa0, 0x0000, 0x0094},          
+    {0xa1, 0x0001, 0x0091},          
+    {0xa0, 0x0001, 0x0090},          
+    {0xa0, 0x0018, 0x0092},          //00,18,02,aa,
+    {0xa0, 0x0002, 0x0093},          
+    {0xa0, 0x0000, 0x0094},          
+    {0xa1, 0x0001, 0x0091},          
+    {0xa0, 0x0001, 0x0090},          
+    {0xa0, 0x0019, 0x0092},          //00,19,88,aa,
+    {0xa0, 0x0088, 0x0093},          //  8<->6          
+    {0xa0, 0x0000, 0x0094},          
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x0020, 0x0092},          //00,20,20,aa,
+    {0xa0, 0x0020, 0x0093},
+    {0xa0, 0x0000, 0x0094},
+    {0xa0, 0x0001, 0x0090},
+    {0xa1, 0x0001, 0x0091},
+    {0xa0, 0x00b7, 0x0101},          //01,01,b7,cc, 
+    {0xa0, 0x0005, 0x0012},          //00,12,05,cc, 
+    {0xa0, 0x000d, 0x0100},          //01,00,0d,cc, 
+    {0xa0, 0x0076, 0x0189},          //01,89,76,cc, 
+    {0xa0, 0x0009, 0x01ad},          //01,ad,09,cc, 
+    {0xa0, 0x0003, 0x01c5},          //01,c5,03,cc, 
+    {0xa0, 0x0013, 0x01cb},          //01,cb,13,cc, 
+    {0xa0, 0x0008, 0x0250},          //02,50,08,cc, 
+    {0xa0, 0x0008, 0x0301},          //03,01,08,cc, 
+    {0xa0, 0x0060, 0x01a8},          //01,a8,60,cc, 
+    {0xa0, 0x0061, 0x0116},          //01,16,61,cc, 
+    {0xa0, 0x0065, 0x0118},          //01,18,65,cc  
+ /********************/                                                           
+    {0, 0, 0}                                                                       
+};                                                                                
+/* "50HZ" light frequency banding filter */
+static __u16 tas5130c_vf0250_50HZ[][3] = {
+    {0xa0, 0x0082, 0x0092},          //00,82,00,aa
+    {0xa0, 0x0000, 0x0093},          //
+    {0xa0, 0x0000, 0x0094},          //
+    {0xa0, 0x0001, 0x0090},          //
+    {0xa1, 0x0001, 0x0091},          //
+/************************/          
+    {0xa0, 0x0083, 0x0092},          //00,83,01,aa
+    {0xa0, 0x0001, 0x0093},          //
+    {0xa0, 0x0000, 0x0094},          //
+    {0xa0, 0x0001, 0x0090},          //
+    {0xa1, 0x0001, 0x0091},          //
+/********************/                
+    {0xa0, 0x0084, 0x0092},          //00,84,aa,aa
+    {0xa0, 0x00aa, 0x0093},          //
+    {0xa0, 0x0000, 0x0094},          //
+    {0xa0, 0x0001, 0x0090},          //
+    {0xa1, 0x0001, 0x0091},          //
+/********************/                
+    {0xa0, 0x0000, 0x0190},          //01,90,00,cc,                          
+    {0xa0, 0x0006, 0x0191},	     //01,91,0d,cc,
+    {0xa0, 0x00a8, 0x0192},	     //01,92,50,cc,
+    {0xa0, 0x0000, 0x0195},	     //01,95,00,cc,
+    {0xa0, 0x0000, 0x0196},	     //01,96,00,cc,
+    {0xa0, 0x008e, 0x0197},	     //01,97,47,cc,
+    {0xa0, 0x000e, 0x018c},	     //01,8c,0e,cc,
+    {0xa0, 0x0015, 0x018f},	     //01,8f,15,cc,
+    {0xa0, 0x0010, 0x01a9},	     //01,a9,10,cc,
+    {0xa0, 0x0024, 0x01aa},	     //01,aa,24,cc,
+    {0xa0, 0x0062, 0x001d},	     //00,1d,62,cc,
+    {0xa0, 0x0090, 0x001e},	     //00,1e,90,cc,
+    {0xa0, 0x00c8, 0x001f},	     //00,1f,c8,cc,
+    {0xa0, 0x00ff, 0x0020},	     //00,20,ff,cc,
+    {0xa0, 0x0058, 0x011d},	     //01,1d,58,cc,
+    {0xa0, 0x0042, 0x0180},          //01,80,42,cc,
+    {0xa0, 0x0078, 0x018d},	     //01,8d,78,cc
+/********************/                                                           
+{0, 0, 0}                                                                        
+};                                                                                
+
+/* "50HZScale" light frequency banding filter */
+static __u16 tas5130c_vf0250_50HZScale[][3] = {
+    {0xa0, 0x0082, 0x0092},           //00,82,00,aa
+    {0xa0, 0x0000, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/************************/
+    {0xa0, 0x0083, 0x0092},           //00,83,03,aa
+    {0xa0, 0x0003, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0084, 0x0092},           //00,84,54,aa
+    {0xa0, 0x0054, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0000, 0x0190},           //01,90,00,cc,                          
+    {0xa0, 0x000d, 0x0191},	      //01,91,0d,cc,
+    {0xa0, 0x0050, 0x0192},	      //01,92,50,cc,
+    {0xa0, 0x0000, 0x0195},	      //01,95,00,cc,
+    {0xa0, 0x0000, 0x0196},	      //01,96,00,cc,
+    {0xa0, 0x008e, 0x0197},	      //01,97,8e,cc,
+    {0xa0, 0x000e, 0x018c},	      //01,8c,0e,cc,
+    {0xa0, 0x0015, 0x018f},	      //01,8f,15,cc,
+    {0xa0, 0x0010, 0x01a9},	      //01,a9,10,cc,
+    {0xa0, 0x0024, 0x01aa},	      //01,aa,24,cc,
+    {0xa0, 0x0062, 0x001d},	      //00,1d,62,cc,
+    {0xa0, 0x0090, 0x001e},	      //00,1e,90,cc,
+    {0xa0, 0x00c8, 0x001f},	      //00,1f,c8,cc,
+    {0xa0, 0x00ff, 0x0020},	      //00,20,ff,cc,
+    {0xa0, 0x0058, 0x011d},	      //01,1d,58,cc,
+    {0xa0, 0x0042, 0x0180},           //01,80,42,cc,
+    {0xa0, 0x0078, 0x018d},	      //01,8d,78,cc
+ /********************/                                                           
+ {0, 0, 0}                                                                        
+};                                                                                
+
+/* "60HZ" light frequency banding filter */
+static __u16 tas5130c_vf0250_60HZ[][3] = {
+    {0xa0, 0x0082, 0x0092},           //00,82,00,aa
+    {0xa0, 0x0000, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/************************/
+    {0xa0, 0x0083, 0x0092},           //00,83,01,aa
+    {0xa0, 0x0001, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0084, 0x0092},           //00,84,62,aa
+    {0xa0, 0x0062, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0000, 0x0190},           //01,90,00,cc,                          
+    {0xa0, 0x0005, 0x0191},	      //01,91,05,cc,
+    {0xa0, 0x0088, 0x0192},	      //01,92,88,cc,
+    {0xa0, 0x0000, 0x0195},	      //01,95,00,cc,
+    {0xa0, 0x0000, 0x0196},	      //01,96,00,cc,
+    {0xa0, 0x003b, 0x0197},	      //01,97,3b,cc,
+    {0xa0, 0x000e, 0x018c},	      //01,8c,0e,cc,
+    {0xa0, 0x0015, 0x018f},	      //01,8f,15,cc,
+    {0xa0, 0x0010, 0x01a9},	      //01,a9,10,cc,
+    {0xa0, 0x0024, 0x01aa},	      //01,aa,24,cc,
+    {0xa0, 0x0062, 0x001d},	      //00,1d,62,cc,
+    {0xa0, 0x0090, 0x001e},	      //00,1e,90,cc,
+    {0xa0, 0x00c8, 0x001f},	      //00,1f,c8,cc,
+    {0xa0, 0x00ff, 0x0020},	      //00,20,ff,cc,
+    {0xa0, 0x0058, 0x011d},	      //01,1d,58,cc,
+    {0xa0, 0x0042, 0x0180},           //01,80,42,cc,
+    {0xa0, 0x0078, 0x018d},	      //01,8d,78,cc
+/********************/                    
+{0, 0, 0}                                                                           
+};                                                                                   
+
+/* "60HZScale" light frequency banding ilter */
+static __u16 tas5130c_vf0250_60HZScale[][3] = {
+    {0xa0, 0x0082, 0x0092},           //00,82,00,aa
+    {0xa0, 0x0000, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/************************/
+    {0xa0, 0x0083, 0x0092},           //00,83,02,aa
+    {0xa0, 0x0002, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0084, 0x0092},           //00,84,c4,aa
+    {0xa0, 0x00c4, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0000, 0x0190},           //01,90,00,cc,                          
+    {0xa0, 0x000b, 0x0191},	      //01,1,0b,cc,
+    {0xa0, 0x0010, 0x0192},	      //01,2,10,cc,
+    {0xa0, 0x0000, 0x0195},	      //01,5,00,cc,
+    {0xa0, 0x0000, 0x0196},	      //01,6,00,cc,
+    {0xa0, 0x0076, 0x0197},	      //01,7,76,cc,
+    {0xa0, 0x000e, 0x018c},	      //01,c,0e,cc,
+    {0xa0, 0x0015, 0x018f},	      //01,f,15,cc,
+    {0xa0, 0x0010, 0x01a9},	      //01,9,10,cc,
+    {0xa0, 0x0024, 0x01aa},	      //01,a,24,cc,
+    {0xa0, 0x0062, 0x001d},	      //00,d,62,cc,
+    {0xa0, 0x0090, 0x001e},	      //00,e,90,cc,
+    {0xa0, 0x00c8, 0x001f},	      //00,f,c8,cc,
+    {0xa0, 0x00ff, 0x0020},	      //00,0,ff,cc,
+    {0xa0, 0x0058, 0x011d},	      //01,d,58,cc,
+    {0xa0, 0x0042, 0x0180},           //01,80,42,cc,
+    {0xa0, 0x0078, 0x018d},	      //01,d,78,cc
+/********************/                                                          
+{0, 0, 0}                                                                       
+};                                                                               
+
+/* "NoFliker" light frequency banding flter */
+static __u16 tas5130c_vf0250_NoFliker[][3] = {
+    {0xa0, 0x00c, 0x0100},            //01,00,0c,cc,
+    {0xa0, 0x0082, 0x0092},           //00,82,00,aa
+    {0xa0, 0x0000, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/************************/
+    {0xa0, 0x0083, 0x0092},           //00,83,00,aa
+    {0xa0, 0x0000, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0084, 0x0092},           //00,84,20,aa
+    {0xa0, 0x0020, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0000, 0x0190},	      // 01,0,00,cc,
+    {0xa0, 0x0005, 0x0191},           //01,91,05,cc,
+    {0xa0, 0x0088, 0x0192},           //01,92,88,cc,
+    {0xa0, 0x0000, 0x0195},           //01,95,00,cc,
+    {0xa0, 0x0000, 0x0196},           //01,96,00,cc,
+    {0xa0, 0x0010, 0x0197},           //01,97,10,cc,
+    {0xa0, 0x000e, 0x018c},           //01,8c,0e,cc,
+    {0xa0, 0x0015, 0x018f},           //01,8f,15,cc,
+    {0xa0, 0x0062, 0x001d},           //00,1d,62,cc,
+    {0xa0, 0x0090, 0x001e},           //00,1e,90,cc,
+    {0xa0, 0x00c8, 0x001f},           //00,1f,c8,cc,
+    {0xa0, 0x00ff, 0x0020},           //00,20,ff,cc,
+    {0xa0, 0x0058, 0x011d},           //01,1d,58,cc,
+    {0xa0, 0x0003, 0x0180},           //01,80,03,cc
+/********************/                                                           
+ {0, 0, 0}                                                                        
+};                                                                                
+
+/* "NoFlikerScale" light frequency banding filter */
+static __u16 tas5130c_vf0250_NoFlikerScale[][3] = {
+    {0xa0, 0x000c, 0x0100},           // 01,00,0c,cc,
+    {0xa0, 0x0082, 0x0092},           // 00,82,00,aa
+    {0xa0, 0x0000, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/************************/
+    {0xa0, 0x0083, 0x0092},           // 00,83,00,aa
+    {0xa0, 0x0000, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0084, 0x0092},           // 00,84,20,aa
+    {0xa0, 0x0020, 0x0093},           //
+    {0xa0, 0x0000, 0x0094},           //
+    {0xa0, 0x0001, 0x0090},           //
+    {0xa1, 0x0001, 0x0091},           //
+/********************/                 
+    {0xa0, 0x0000, 0x0190},	      // 01,90,00,cc,
+    {0xa0, 0x000b, 0x0191},           // 01,91,0b,cc,
+    {0xa0, 0x0010, 0x0192},           // 01,92,10,cc,
+    {0xa0, 0x0000, 0x0195},           // 01,95,00,cc,
+    {0xa0, 0x0000, 0x0196},           // 01,96,00,cc,
+    {0xa0, 0x0010, 0x0197},           // 01,97,10,cc,
+    {0xa0, 0x000e, 0x018c},           // 01,8c,0e,cc,
+    {0xa0, 0x0015, 0x018f},           // 01,8f,15,cc,
+    {0xa0, 0x0062, 0x001d},           // 00,1d,62,cc,
+    {0xa0, 0x0090, 0x001e},           // 00,1e,90,cc,
+    {0xa0, 0x00c8, 0x001f},           // 00,1f,c8,cc,
+    {0xa0, 0x00ff, 0x0020},           // 00,20,ff,cc,
+    {0xa0, 0x0058, 0x011d},           // 01,1d,58,cc,
+    {0xa0, 0x0003, 0x0180},           // 01,80,03,cc
+/********************/                                                           
+{0, 0, 0}                                                                        
+};                                                                                
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/vc032x.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/vc032x.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/vc032x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/vc032x.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,568 @@
+
+#ifndef VC032XUSB_H
+#define VC032XUSB_H
+/****************************************************************************
+#	 	Z-star vc0321 library                                       #
+# 		Copyright (C) 2006 Koninski Artur    takeshi87@o2.pl        #
+# 		Copyright (C) 2006 Michel Xhaard                            #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+#include "vc032x_sensor.h"
+
+/*******************     Camera Interface   ***********************/
+static int vc0321_init(struct usb_spca50x *spca50x);
+static void vc0321_start(struct usb_spca50x *spca50x);
+static void vc0321_stop0(struct usb_spca50x *spca50x);
+static void vc0321_stopN(struct usb_spca50x *spca50x);
+static int vc0321_config(struct usb_spca50x *spca50x);
+static void vc0321_shutdown(struct usb_spca50x *spca50x);
+
+static __u16 vc0321_getbrightness(struct usb_spca50x *spca50x);
+static __u16 vc0321_getcontrast(struct usb_spca50x *spca50x);
+static __u16 vc0321_getcolors(struct usb_spca50x *spca50x);
+static void vc0321_setbrightness(struct usb_spca50x *spca50x);
+static void vc0321_setcontrast(struct usb_spca50x *spca50x);
+static void vc0321_setcolors(struct usb_spca50x *spca50x);
+static void vc0321_setAutobright(struct usb_spca50x *spca50x);
+static void vc0321_setquality(struct usb_spca50x *spca50x);
+static int vc0321_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/*******************      Banding flilter   ***********************/
+static void vc0321_set50HZ(struct usb_spca50x *spca50x);
+static void vc0321_set60HZ(struct usb_spca50x *spca50x);
+static void vc0321_setNoFliker(struct usb_spca50x *spca50x);
+/*******************     Camera Private     ***********************/
+
+/******************************************************************/
+static struct cam_operation fvc0321 = {
+ 	.initialize = vc0321_init,
+	.configure = vc0321_config,
+	.start = vc0321_start,
+	.stopN = vc0321_stopN,
+	.stop0 = vc0321_stop0,
+	.get_bright = vc0321_getbrightness,
+	.set_bright = vc0321_setbrightness,
+	.get_contrast = vc0321_getcontrast,
+	.set_contrast = vc0321_setcontrast,
+	.get_colors = vc0321_getcolors,
+	.set_colors = vc0321_setcolors,
+	.set_autobright = vc0321_setAutobright,
+	.set_quality = vc0321_setquality,
+	.cam_shutdown = vc0321_shutdown,
+	.sof_detect = vc0321_sofdetect,
+	.set_50HZ   = vc0321_set50HZ,
+	.set_60HZ   = vc0321_set60HZ,
+	.set_50HZScale   = vc0321_set50HZ,
+	.set_60HZScale   = vc0321_set60HZ,
+	.set_NoFliker    = vc0321_setNoFliker,
+	.set_NoFlikerScale    = vc0321_setNoFliker,
+ };
+ typedef struct {
+	int sensorId;
+ 	__u8 I2cAdd;
+	__u8 IdAdd;
+	__u16 VpId;
+	__u8 m1;
+	__u8 m2;
+	__u8 op;
+	} sensor_info;
+	
+static sensor_info sensor_info_data[] = {
+//      sensorId,         I2cAdd,     IdAdd,  VpId,  m1,    m2,  op
+	{SENSOR_HV7131R, 0x80 | 0x11, 0x00, 0x0209, 0x24, 0x25, 0x01},
+	{SENSOR_OV7660, 0x80 | 0x21 , 0x0a, 0x7660, 0x26, 0x26, 0x05},
+	{SENSOR_PO3130NC,0x80 | 0x76, 0x00, 0x3130, 0x24, 0x25, 0x01},
+};
+static void vc032x_read_sensor_register( struct usb_device *dev,
+	__u16 address, __u16 *value)
+{
+	__u8	ldata, mdata, hdata;
+	__u8 tmpvalue = 0;
+	int retry = 50;
+	ldata = 0;
+	mdata = 0;
+	hdata = 0;
+	*value = 0;
+	
+	spca5xxRegRead( dev, 0xa1, 0x01, 0xb33f, &tmpvalue, 1 );
+	//PDEBUG(0, " I2c Bus Busy Wait  0x%02X ", tmpvalue);
+	if(!(tmpvalue & 0x02)) {
+		PDEBUG(0, " I2c Bus Busy Wait  %d ", tmpvalue & 0x02);
+		return;
+	}
+	spca5xxRegWrite( dev, 0xa0, address, 0xb33a, NULL, 0 );
+	spca5xxRegWrite( dev, 0xa0, 0x02, 0xb339, NULL, 0 );
+	
+	tmpvalue = 0;
+	spca5xxRegRead( dev, 0xa1, 0x01, 0xb33b, &tmpvalue, 1 );
+	while( retry-- && tmpvalue){
+		spca5xxRegRead( dev, 0xa1, 0x01, 0xb33b, &tmpvalue, 1 );
+		//PDEBUG(0, "Read again 0xb33b  %d ", tmpvalue);
+		udelay( 1000 );
+	}
+	spca5xxRegRead ( dev, 0xa1, 0x01, 0xb33e, &hdata, 1 );
+	spca5xxRegRead ( dev, 0xa1, 0x01, 0xb33d, &mdata, 1 );
+	spca5xxRegRead ( dev, 0xa1, 0x01, 0xb33c, &ldata, 1 );
+	//PDEBUG(0, "Read Sensor h (0x%02X) m (0x%02X) l (0x%02X) ", hdata,mdata,ldata);
+	tmpvalue = 0;
+	spca5xxRegRead( dev, 0xa1, 0x01, 0xb334, &tmpvalue, 1 );
+	if(tmpvalue == 0x02)
+		*value = (ldata << 8) + mdata;
+	else 
+		*value = ldata;
+}
+static int vc032x_probe_sensor(struct usb_spca50x *spca50x)
+{
+	int i;
+	__u8 data;
+	__u16	value;
+	sensor_info *ptsensor_info;
+	int sensor_id = -1;
+	int VCSENSOR_TOT= 3;
+	spca5xxRegRead ( spca50x->dev, 0xa1, 0x01, 0xbfcf, &data, 1 );
+	PDEBUG(0,"check sensor header %d",data);
+	for(i= 0; i < VCSENSOR_TOT; i++){
+		ptsensor_info = &sensor_info_data[i];
+		spca5xxRegWrite( spca50x->dev, 0xa0, 0x02, 0xb334, NULL, 0);
+		spca5xxRegWrite( spca50x->dev, 0xa0, ptsensor_info->m1, 0xb300, NULL, 0);
+		spca5xxRegWrite( spca50x->dev, 0xa0, ptsensor_info->m2, 0xb300, NULL, 0);
+		spca5xxRegWrite( spca50x->dev, 0xa0, 0x01, 0xb308, NULL, 0);
+		spca5xxRegWrite( spca50x->dev, 0xa0, 0x0c, 0xb309, NULL, 0);
+		spca5xxRegWrite( spca50x->dev, 0xa0, ptsensor_info->I2cAdd, 0xb335, NULL, 0);
+	// PDEBUG(0,"check sensor VC032X -> %d Add -> ox%02X!", i, ptsensor_info->I2cAdd);
+		spca5xxRegWrite( spca50x->dev, 0xa0, ptsensor_info->op, 0xb301, NULL, 0);
+		vc032x_read_sensor_register ( spca50x->dev, ptsensor_info->IdAdd, &value );
+		if(value == ptsensor_info->VpId) {
+			// PDEBUG(0,"find sensor VC032X -> ox%04X!",ptsensor_info->VpId);
+			sensor_id = ptsensor_info->sensorId;
+			break;
+		}
+	}
+return sensor_id;
+}
+/*
+static __u8 vc0321_i2cWrite(struct usb_device *dev, __u8 reg, __u8 val)
+{
+    __u8 retbyte = 0;
+    
+    spca5xxRegRead (dev, 0xa1, 0x01, 0xb33f, &retbyte, 1);	    udelay(10);
+    spca5xxRegWrite(dev, 0xa0, reg , 0xb33a, NULL    , 0);	    udelay(10);
+    spca5xxRegRead (dev, 0xa1, 0x01, 0xb334, &retbyte, 1);	    udelay(10);
+    spca5xxRegWrite(dev, 0xa0, val , 0xb336, NULL    , 0);	    udelay(10);
+    spca5xxRegWrite(dev, 0xa0, 0x01, 0xb339, NULL    , 0);	    udelay(10);
+    spca5xxRegRead (dev, 0xa1, 0x01, 0xb33b, &retbyte, 1);	    udelay(10);
+    return (retbyte==0);
+}
+*/
+static __u8 vc0321_i2cWrite(struct usb_device *dev, __u8 reg, __u8 *val, __u8 size)
+{
+    __u8 retbyte = 0;
+    if(size > 3 || size < 1)
+    	return -EINVAL;
+	spca5xxRegRead (dev, 0xa1, 0x01, 0xb33f, &retbyte, 1);	    udelay(10);
+	spca5xxRegWrite(dev, 0xa0, size , 0xb334, NULL    , 0);
+	spca5xxRegWrite(dev, 0xa0, reg , 0xb33a, NULL    , 0);	    udelay(10);
+	switch (size){
+	case 1:
+	spca5xxRegWrite(dev, 0xa0, val[0] , 0xb336, NULL    , 0);	    udelay(10);
+	break;
+	case 2:
+	spca5xxRegWrite(dev, 0xa0, val[0] , 0xb336, NULL    , 0);	    udelay(10);
+	spca5xxRegWrite(dev, 0xa0, val[1] , 0xb337, NULL    , 0);	    udelay(10);
+	break;
+	case 3:
+	spca5xxRegWrite(dev, 0xa0, val[0] , 0xb336, NULL    , 0);	    udelay(10);
+	spca5xxRegWrite(dev, 0xa0, val[1] , 0xb337, NULL    , 0);	    udelay(10);
+	spca5xxRegWrite(dev, 0xa0, val[2] , 0xb338, NULL    , 0);	    udelay(10);
+	break;
+	default:
+		spca5xxRegWrite(dev, 0xa0, 0x01, 0xb334, NULL    , 0);
+		return -EINVAL;
+	break;
+	}
+    spca5xxRegWrite(dev, 0xa0, 0x01, 0xb339, NULL    , 0);	    udelay(10);
+    spca5xxRegRead (dev, 0xa1, 0x01, 0xb33b, &retbyte, 1);	    udelay(10);
+    return (retbyte==0);
+}
+
+static void put_tab_to_reg(struct usb_spca50x *spca50x, __u8 *tab, __u8 tabsize, __u16 addr)
+{
+    __u8 j;
+    __u16 ad=addr;
+	for(j=0; j < tabsize; j++)
+	{
+	    spca5xxRegWrite(spca50x->dev, 0xa0, tab[j], ad++, NULL, 0);
+	    udelay(10);
+	}
+}
+
+
+
+static __u16 vc0321WriteVector(struct usb_spca50x *spca50x, __u8 data[][4])
+{
+    struct usb_device *dev = spca50x->dev;
+    int err = 0;
+    int i = 0;
+    while (data[i][3]) {
+	if (data[i][3] == 0xcc)	{	//normal op
+		/* write registers */
+	        spca5xxRegWrite(dev, 0xa0, data[i][2], ((data[i][0])<<8) | data[i][1], NULL,
+	    		    0);
+	}
+	else if(data[i][3] == 0xaa) {  //i2c op
+		vc0321_i2cWrite(dev, data[i][1], &data[i][2],1);
+	}
+	else if(data[i][3] == 0xdd) {
+	    mdelay(data[i][2]+10);
+	}
+	i++;
+	udelay(10);
+    }
+
+    return err;
+}
+
+#define CLAMP(x) (unsigned char)(((x)>0xFF)?0xff:(((x)<1)?1:(x)))
+
+/*
+"GammaT"=hex:04,17,31,4f,6a,83,99,ad,bf,ce,da,e5,ee,f5,fb,ff,ff
+"MatrixT"=hex:60,f9,e5,e7,50,05,f3,e6,66
+*/
+
+
+
+static __u16 vc0321_getbrightness(struct usb_spca50x *spca50x)
+{
+    spca50x->brightness = 0x80 << 8;
+    spca50x->contrast = 0x80 << 8;
+    return spca50x->brightness;
+}
+static __u16 vc0321_getcontrast(struct usb_spca50x *spca50x)
+{
+    spca50x->contrast = 0x80 << 8;
+    return spca50x->contrast;
+}
+static void vc0321_setbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 brightness;
+    brightness = spca50x->brightness >> 8 ;
+
+}
+static void vc0321_setcontrast(struct usb_spca50x *spca50x)
+{
+
+    __u16 contrast;
+    contrast = vc0321_getcontrast(spca50x);
+
+}
+
+
+
+static int vc0321_init(struct usb_spca50x *spca50x)
+{
+    return 0;
+}
+
+static void set_vc0321VGA(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	 P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 3072;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 0;
+
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 3072;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 0;
+    
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 3072;
+    spca50x->mode_cam[SIF].method = 1;
+    spca50x->mode_cam[SIF].mode = 0;
+    
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	 P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 3072;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 1;
+    
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 3072;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 1;
+    
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 3072;
+    spca50x->mode_cam[QSIF].method = 1;
+    spca50x->mode_cam[QSIF].mode = 1;
+    
+}
+static int vc0321_reset(struct usb_spca50x *spca50x)
+{
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x00, 0xb04d, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0xb301, NULL, 0); 
+	msleep(100);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0xb003, NULL, 0);
+	msleep(100);
+return 0;
+}
+static int vc0321_config(struct usb_spca50x *spca50x)
+{
+ __u8 tmp2[3];
+    int sensor = 0;
+    spca50x->qindex = 1;
+    vc0321_reset(spca50x);
+    sensor = vc032x_probe_sensor(spca50x);
+    switch (sensor) {
+    	case -1:
+		PDEBUG(0,"Unknown sensor...");
+		return -EINVAL;
+	break;
+   	case SENSOR_OV7660:
+		PDEBUG(0, "Find Sensor OV7660");
+		spca50x->sensor = SENSOR_OV7660;
+		set_vc0321VGA(spca50x);
+	break;
+	case SENSOR_PO3130NC:
+		PDEBUG(0, "Find Sensor PO3130NC");
+		spca50x->sensor = SENSOR_PO3130NC;
+		set_vc0321VGA(spca50x);
+	break;
+	case SENSOR_HV7131R:
+		PDEBUG(0, "Find Sensor HV7131R");
+		spca50x->sensor = SENSOR_HV7131R;
+		set_vc0321VGA(spca50x);
+	break;
+    };
+spca5xxRegRead (spca50x->dev, 0x8a, 0x01, 0     , tmp2, 3); udelay(10);
+spca5xxRegWrite(spca50x->dev, 0x87, 0x00, 0x0f0f, NULL, 0); udelay(10);
+
+spca5xxRegRead (spca50x->dev, 0x8b, 0x01, 0     , tmp2, 3); udelay(10);
+spca5xxRegWrite(spca50x->dev, 0x88, 0x00, 0x0202, NULL, 0); udelay(10);
+    return 0;
+}
+static void vc0321_setquality(struct usb_spca50x *spca50x)
+{
+    __u8 quality = 0;
+    quality = (spca50x->qindex) & 0xff;
+//    spca5xxRegWrite(spca50x->dev, 0xa0, quality, 0x0008, NULL, 0);
+}
+static void vc0321_setAutobright(struct usb_spca50x *spca50x)
+{
+    __u8 autoval = 0;
+    if (spca50x->autoexpo)
+	autoval = 0x42;
+    else
+	autoval = 0x02;
+//    spca5xxRegWrite(spca50x->dev, 0xa0, autoval, 0x0180, NULL, 0);
+
+}
+
+static void vc0321_start(struct usb_spca50x *spca50x)
+{
+	// __u8 tmp2;
+    int err = 0;
+    __u8 *GammaT = NULL;
+    __u8 *MatrixT = NULL;
+    /* Assume start use the good resolution from spca50x->mode */
+    spca5xxRegWrite(spca50x->dev, 0xa0, 0xff, 0xbfec, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0xa0, 0xff, 0xbfed, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0xa0, 0xff, 0xbfee, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0xa0, 0xff, 0xbfef, NULL, 0);
+    switch (spca50x->sensor) {
+    	case SENSOR_OV7660:
+    		GammaT = ov7660_gamma;
+    		MatrixT = ov7660_matrix;
+		if (spca50x->mode) {
+	    		/* 320x240 */
+			 err = vc0321WriteVector(spca50x, ov7660_initQVGA_data);
+		} else {
+	    		/* 640x480 */
+	   		 err = vc0321WriteVector(spca50x, ov7660_initVGA_data);
+		}
+			
+	break;
+	case SENSOR_PO3130NC:
+		GammaT = po3130_gamma;
+    		MatrixT = po3130_matrix;
+		if (spca50x->mode) {
+	    		/* 320x240 */
+			 err = vc0321WriteVector(spca50x, po3130_initQVGA_data);
+		} else {
+	    		/* 640x480 */
+	   		 err = vc0321WriteVector(spca50x, po3130_initVGA_data);
+		}
+	err = vc0321WriteVector(spca50x, po3130_rundata);
+	break;
+	case SENSOR_HV7131R:
+		GammaT = hv7131r_gamma;
+    		MatrixT = hv7131r_matrix;
+		
+		if (spca50x->mode) {
+	    		/* 320x240 */
+			 err = vc0321WriteVector(spca50x, hv7131r_initQVGA_data);
+		} else {
+	    		/* 640x480 */
+	   		 err = vc0321WriteVector(spca50x, hv7131r_initVGA_data);
+		}
+		 
+	break;
+	default:
+		PDEBUG(0, "Damned !! no sensor found Bye");
+		return;
+	break;
+    }
+    if (GammaT && MatrixT){
+	put_tab_to_reg(spca50x, GammaT, 17, 0xb84a);
+	put_tab_to_reg(spca50x, GammaT, 17, 0xb85b);
+	put_tab_to_reg(spca50x, GammaT, 17, 0xb86c);
+	put_tab_to_reg(spca50x, MatrixT, 9, 0xb82c);
+	
+		// Seem SHARPNESS
+		/*
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0x80, 0xb80a, NULL, 0);
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0xff, 0xb80b, NULL, 0);
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0xff, 0xb80e, NULL, 0);
+		 */
+		 /* all 0x40 ??? do nothing
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0x40, 0xb822, NULL, 0);
+		  spca5xxRegWrite(spca50x->dev, 0xa0, 0x40, 0xb823, NULL, 0);
+		   spca5xxRegWrite(spca50x->dev, 0xa0, 0x40, 0xb824, NULL, 0);
+		 */
+		 /* Only works for HV7131R ?? 
+		 spca5xxRegRead (spca50x->dev, 0xa1, 0x01, 0xb881, &tmp2, 1); udelay(10);
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0xfe01, 0xb881, NULL, 0);
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0x79, 0xb801, NULL, 0);
+		 */
+		 /* only hv7131r et ov7660 
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0x20, 0xb827, NULL, 0);
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0xff, 0xb826, NULL, 0); //ISP_GAIN 80
+		 spca5xxRegWrite(spca50x->dev, 0xa0, 0x23, 0xb800, NULL, 0); // ISP CTRL_BAS
+		 */
+	// set the led on 0x0892 0x0896
+        spca5xxRegWrite(spca50x->dev, 0x89, 0xffff, 0xfdff, NULL, 0);
+	msleep(100);
+    	vc0321_setbrightness(spca50x);
+    	vc0321_setquality(spca50x);
+    	vc0321_setAutobright(spca50x);
+    }
+}
+
+static void vc0321_stopN(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    spca5xxRegWrite(dev, 0x89, 0xffff, 0xffff, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, 0x01, 0xb301, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, 0x09, 0xb003, NULL, 0);
+}
+
+static void vc0321_stop0(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    spca5xxRegWrite(dev, 0x89, 0xffff, 0xffff, NULL, 0);
+}
+
+static void vc0321_shutdown(struct usb_spca50x *spca50x)
+{
+/*    struct usb_device *dev = spca50x->dev;
+    __u8 buffread;
+    spca5xxRegWrite(dev, 0x89, 0xffff, 0xffff, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, 0x01, 0xb301, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, 0x09, 0xb303, NULL, 0);
+    spca5xxRegWrite(dev, 0x89, 0xffff, 0xffff, NULL, 0);
+*/
+}
+
+static __u16 vc0321_getcolors(struct usb_spca50x *spca50x)
+{
+//Nothing
+return spca50x->colour;
+}
+
+static void vc0321_setcolors(struct usb_spca50x *spca50x)
+{
+//Nothing
+ spca50x->colour = 0;
+}
+
+static void vc0321_set50HZ(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {
+      case SENSOR_OV7660:
+ 	  vc0321WriteVector(spca50x, ov7660_50HZ);
+      break;
+      default:     
+      break;
+     }
+ }
+ 
+static void vc0321_set60HZ(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {
+      case SENSOR_OV7660:
+ 	  vc0321WriteVector(spca50x, ov7660_60HZ);
+      break;
+      default:     
+      break;
+     }
+ }
+
+static void vc0321_setNoFliker(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {
+      case SENSOR_OV7660:
+ 	  vc0321WriteVector(spca50x, ov7660_NoFliker);
+      break;
+      default:
+      break;
+     }
+ 
+ }
+ 
+static int vc0321_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+		
+		if (cdata[0] == 0xFF && cdata[1] == 0xD8) {
+		
+			*iPix = 46 ;
+		     PDEBUG(5,
+			   "vc0321 header packet found datalength %d !!",
+			   *datalength );
+		    *datalength -= *iPix;
+		    return 0;
+		   
+		} 
+		*iPix = 0;
+		PDEBUG(5, "vc0321 process packet %d datalength %d ",seqnum+1,*datalength);
+		return (seqnum +1);
+}
+#endif				// VC032XUSB_H
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/vc032x_sensor.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/vc032x_sensor.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/vc032x_sensor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/vc032x_sensor.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,683 @@
+static __u8 po3130_gamma[17]= {
+	0x00,0x13,0x38,0x59,0x79,0x92,0xa7,0xb9,0xc8,
+	0xd4,0xdf,0xe7,0xee,0xf4,0xf9,0xfc,0xff
+};
+static __u8 po3130_matrix[9]= {
+	0x5f,0xec,0xf5,0xf1,0x5a,0xf5,0xf1,0xec,0x63
+};
+#if 0
+static __u8 po3130_initSXGA_60data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},
+{0xb3,0x00,0x04,0xcc},{0xb3,0x00,0x64,0xcc},{0xb3,0x00,0x65,0xcc},{0xb3,0x05,0x00,0xcc},
+{0xb3,0x06,0x00,0xcc},{0xb3,0x5c,0x01,0xcc},{0xb3,0x08,0x01,0xcc},{0xb3,0x09,0x0c,0xcc},
+{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0xf6,0xcc},{0xb3,0x00,0xe7,0xcc},{0xb3,0x02,0xb0,0xcc},
+{0xb3,0x03,0x18,0xcc},{0xb3,0x04,0x15,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x22,0x04,0xcc},{0xb3,0x23,0x00,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},
+{0xb3,0x16,0x04,0xcc},{0xb3,0x17,0xff,0xcc},{0xb3,0x2c,0x03,0xcc},{0xb3,0x2d,0x56,0xcc},
+{0xb3,0x2e,0x02,0xcc},{0xb3,0x2f,0x0a,0xcc},{0xb3,0x40,0x00,0xcc},{0xb3,0x41,0x34,0xcc},
+{0xb3,0x42,0x01,0xcc},{0xb3,0x43,0xe0,0xcc},{0xb3,0x00,0x65,0xcc},{0xbc,0x00,0x71,0xcc},
+{0xbc,0x01,0x01,0xcc},{0xb0,0x54,0x1d,0xcc},{0x00,0x00,0x10,0xdd},{0x00,0x4d,0x2a,0xaa},
+{0x00,0x00,0x10,0xdd},{0x00,0x20,0x44,0xaa},{0x00,0x47,0x11,0xaa},{0x00,0x48,0x67,0xaa},
+{0x00,0x49,0x0e,0xaa},{0x00,0x4a,0x80,0xaa},{0x00,0x12,0x08,0xaa},{0x00,0x17,0x41,0xaa},
+{0x00,0x19,0x41,0xaa},{0x00,0x1e,0xc6,0xaa},{0x00,0x21,0x00,0xaa},{0x00,0x36,0xc0,0xaa},
+{0x00,0x37,0xc8,0xaa},{0x00,0x3b,0x36,0xaa},{0x00,0x4b,0xfe,0xaa},{0x00,0x51,0x1c,0xaa},
+{0x00,0x52,0x01,0xaa},{0x00,0x55,0x0a,0xaa},{0x00,0x59,0x6f,0xaa},{0x00,0x5a,0x04,0xaa},
+{0x00,0x5c,0x10,0xaa},{0x00,0x5d,0x10,0xaa},{0x00,0x5e,0x10,0xaa},{0x00,0x5f,0x10,0xaa},
+{0x00,0x61,0x00,0xaa},{0x00,0x62,0x18,0xaa},{0x00,0x63,0x30,0xaa},{0x00,0x70,0x68,0xaa},
+{0x00,0x80,0x71,0xaa},{0x00,0x81,0x08,0xaa},{0x00,0x82,0x00,0xaa},{0x00,0x83,0x55,0xaa},
+{0x00,0x84,0x06,0xaa},{0x00,0x85,0x06,0xaa},{0x00,0x86,0x13,0xaa},{0x00,0x87,0x18,0xaa},
+{0x00,0xaa,0x3f,0xaa},{0x00,0xab,0x44,0xaa},{0x00,0xb0,0x78,0xaa},{0x00,0xb5,0x10,0xaa},
+{0x00,0xb8,0x20,0xaa},{0x00,0xb9,0xa0,0xaa},{0x00,0xbc,0x04,0xaa},{0x00,0x8b,0x40,0xaa},
+{0x00,0x8c,0x91,0xaa},{0x00,0x8d,0x8f,0xaa},{0x00,0x8e,0x91,0xaa},{0x00,0x8f,0x43,0xaa},
+{0x00,0x90,0x92,0xaa},{0x00,0x91,0x89,0xaa},{0x00,0x92,0x9d,0xaa},{0x00,0x93,0x46,0xaa},
+{0x00,0xd6,0x22,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},
+{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},
+{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},
+{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0x62,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},
+{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},
+{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},
+{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0xa2,0xaa},{0x00,0x73,0x00,0xaa},
+{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},
+{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},
+{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0x46,0x45,0xaa},
+{0x00,0x47,0x11,0xaa},{0x00,0x48,0x67,0xaa},{0x00,0x49,0x0e,0xaa},{0x00,0x4a,0x80,0xaa},
+{0x00,0xba,0x45,0xaa},{0x00,0xbb,0x9c,0xaa},{0x00,0x44,0x20,0xaa},{0x00,0xd5,0x0c,0xaa},
+{0xb3,0x01,0x41,0xcc},{0x00,0x00,0x00,0x00}
+};
+static __u8 po3130_initSXGA_50data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},
+{0xb3,0x00,0x04,0xcc},{0xb3,0x00,0x64,0xcc},{0xb3,0x00,0x65,0xcc},{0xb3,0x05,0x00,0xcc},
+{0xb3,0x06,0x00,0xcc},{0xb3,0x5c,0x01,0xcc},{0xb3,0x08,0x01,0xcc},{0xb3,0x09,0x0c,0xcc},
+{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0xf6,0xcc},{0xb3,0x00,0xe7,0xcc},{0xb3,0x02,0xb0,0xcc},
+{0xb3,0x03,0x18,0xcc},{0xb3,0x04,0x15,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x22,0x04,0xcc},{0xb3,0x23,0x00,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},
+{0xb3,0x16,0x04,0xcc},{0xb3,0x17,0xff,0xcc},{0xb3,0x2c,0x03,0xcc},{0xb3,0x2d,0x56,0xcc},
+{0xb3,0x2e,0x02,0xcc},{0xb3,0x2f,0x0a,0xcc},{0xb3,0x40,0x00,0xcc},{0xb3,0x41,0x34,0xcc},
+{0xb3,0x42,0x01,0xcc},{0xb3,0x43,0xe0,0xcc},{0xb3,0x00,0x65,0xcc},{0xbc,0x00,0x71,0xcc},
+{0xbc,0x01,0x01,0xcc},{0xb0,0x54,0x1d,0xcc},{0x00,0x00,0x10,0xdd},{0x00,0x4d,0x2a,0xaa},
+{0x00,0x00,0x10,0xdd},{0x00,0x20,0x44,0xaa},{0x00,0x47,0x11,0xaa},{0x00,0x48,0x67,0xaa},
+{0x00,0x49,0x0e,0xaa},{0x00,0x4a,0x80,0xaa},{0x00,0x12,0x08,0xaa},{0x00,0x17,0x41,0xaa},
+{0x00,0x19,0x41,0xaa},{0x00,0x1e,0xc6,0xaa},{0x00,0x21,0x00,0xaa},{0x00,0x36,0xc0,0xaa},
+{0x00,0x37,0xc8,0xaa},{0x00,0x3b,0x36,0xaa},{0x00,0x4b,0xfe,0xaa},{0x00,0x51,0x1c,0xaa},
+{0x00,0x52,0x01,0xaa},{0x00,0x55,0x0a,0xaa},{0x00,0x59,0x6f,0xaa},{0x00,0x5a,0x04,0xaa},
+{0x00,0x5c,0x10,0xaa},{0x00,0x5d,0x10,0xaa},{0x00,0x5e,0x10,0xaa},{0x00,0x5f,0x10,0xaa},
+{0x00,0x61,0x00,0xaa},{0x00,0x62,0x18,0xaa},{0x00,0x63,0x30,0xaa},{0x00,0x70,0x68,0xaa},
+{0x00,0x80,0x71,0xaa},{0x00,0x81,0x08,0xaa},{0x00,0x82,0x00,0xaa},{0x00,0x83,0x55,0xaa},
+{0x00,0x84,0x06,0xaa},{0x00,0x85,0x06,0xaa},{0x00,0x86,0x13,0xaa},{0x00,0x87,0x18,0xaa},
+{0x00,0xaa,0x3f,0xaa},{0x00,0xab,0x44,0xaa},{0x00,0xb0,0x78,0xaa},{0x00,0xb5,0x10,0xaa},
+{0x00,0xb8,0x20,0xaa},{0x00,0xb9,0xa0,0xaa},{0x00,0xbc,0x04,0xaa},{0x00,0x8b,0x40,0xaa},
+{0x00,0x8c,0x91,0xaa},{0x00,0x8d,0x8f,0xaa},{0x00,0x8e,0x91,0xaa},{0x00,0x8f,0x43,0xaa},
+{0x00,0x90,0x92,0xaa},{0x00,0x91,0x89,0xaa},{0x00,0x92,0x9d,0xaa},{0x00,0x93,0x46,0xaa},
+{0x00,0xd6,0x22,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},
+{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},
+{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},
+{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0x62,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},
+{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},
+{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},
+{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0xa2,0xaa},{0x00,0x73,0x00,0xaa},
+{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},
+{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},
+{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0x46,0x45,0xaa},
+{0x00,0x47,0x11,0xaa},{0x00,0x48,0x67,0xaa},{0x00,0x49,0x0e,0xaa},{0x00,0x4a,0x80,0xaa},
+{0x00,0xba,0x45,0xaa},{0x00,0xbb,0x9c,0xaa},{0x00,0x44,0x40,0xaa},{0x00,0xd5,0x0c,0xaa},
+{0xb3,0x01,0x41,0xcc},{0x00,0x00,0x00,0x00}
+};
+#endif
+static __u8 po3130_initVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},
+{0xb3,0x00,0x04,0xcc},{0xb3,0x00,0x24,0xcc},{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},
+{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},{0xb3,0x03,0x1a,0xcc},
+{0xb3,0x04,0x15,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},{0xb3,0x22,0x01,0xcc},
+{0xb3,0x23,0xe8,0xcc},{0xb8,0x08,0xe8,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0xf6,0xcc},
+{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0x71,0xcc},{0xb8,0x00,0x21,0xcc},{0xb8,0x27,0x20,0xcc},
+{0xb8,0x01,0x79,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x2c,0x50,0xcc},{0xb8,0x2d,0xf8,0xcc},
+{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},{0xb8,0x31,0xf8,0xcc},
+{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x50,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},
+{0x00,0x1e,0xc6,0xaa},{0x00,0x20,0x44,0xaa},
+{0x00,0xad,0x02,0xaa},{0x00,0xae,0x2c,0xaa},{0x00,0x12,0x08,0xaa},{0x00,0x17,0x41,0xaa},
+{0x00,0x19,0x41,0xaa},{0x00,0x1e,0x06,0xaa},
+{0x00,0x21,0x00,0xaa},{0x00,0x36,0xc0,0xaa},
+{0x00,0x37,0xc8,0xaa},{0x00,0x3b,0x36,0xaa},{0x00,0x4b,0xfe,0xaa},{0x00,0x51,0x1c,0xaa},
+{0x00,0x52,0x01,0xaa},{0x00,0x55,0x0a,0xaa},{0x00,0x59,0x02,0xaa},{0x00,0x5a,0x04,0xaa},
+{0x00,0x5c,0x10,0xaa},{0x00,0x5d,0x10,0xaa},{0x00,0x5e,0x10,0xaa},{0x00,0x5f,0x10,0xaa},
+{0x00,0x61,0x00,0xaa},{0x00,0x62,0x18,0xaa},{0x00,0x63,0x30,0xaa},{0x00,0x70,0x68,0xaa},
+{0x00,0x80,0x71,0xaa},{0x00,0x81,0x08,0xaa},{0x00,0x82,0x00,0xaa},{0x00,0x83,0x55,0xaa},
+{0x00,0x84,0x06,0xaa},{0x00,0x85,0x06,0xaa},{0x00,0x86,0x13,0xaa},{0x00,0x87,0x18,0xaa},
+{0x00,0xaa,0x3f,0xaa},{0x00,0xab,0x44,0xaa},{0x00,0xb0,0x68,0xaa},{0x00,0xb5,0x10,0xaa},
+{0x00,0xb8,0x20,0xaa},{0x00,0xb9,0xa0,0xaa},{0x00,0xbc,0x04,0xaa},{0x00,0x8b,0x40,0xaa},
+{0x00,0x8c,0x91,0xaa},{0x00,0x8d,0x8f,0xaa},{0x00,0x8e,0x91,0xaa},{0x00,0x8f,0x43,0xaa},
+{0x00,0x90,0x92,0xaa},{0x00,0x91,0x89,0xaa},{0x00,0x92,0x9d,0xaa},{0x00,0x93,0x46,0xaa},
+{0x00,0xd6,0x22,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},
+{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},
+{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},
+{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0x62,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},
+{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},
+{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},
+{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0xa2,0xaa},{0x00,0x73,0x00,0xaa},
+{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},
+{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},
+{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},
+{0x00,0x4c,0x07,0xaa},
+{0x00,0x4b,0xe0,0xaa},{0x00,0x4e,0x77,0xaa},{0x00,0x59,0x02,0xaa},{0x00,0x4d,0x0a,0xaa},
+//{0x00,0xd1,0x00,0xaa},{0x00,0x20,0xc4,0xaa},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},
+{0x00,0xd1,0x3c,0xaa},{0x00,0x20,0xc4,0xaa},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},
+{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},
+{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0x00,0x05,0x00,0xaa},
+{0xb3,0x5c,0x00,0xcc},{0xb3,0x01,0x41,0xcc},{0x00,0x00,0x00,0x00}
+};
+static __u8 po3130_rundata[][4] = {
+{0x00,0x47,0x45,0xaa},{0x00,0x48,0x9b,0xaa},{0x00,0x49,0x3a,0xaa},{0x00,0x4a,0x01,0xaa},
+{0x00,0x44,0x40,0xaa},
+//{0x00,0xd5,0x7c,0xaa},
+{0x00,0xad,0x04,0xaa},{0x00,0xae,0x00,0xaa},{0x00,0xb0,0x78,0xaa},{0x00,0x98,0x02,0xaa},
+{0x00,0x94,0x25,0xaa},{0x00,0x95,0x25,0xaa},
+{0x00,0x59,0x68,0xaa},{0x00,0x44,0x20,0xaa},{0x00,0x17,0x50,0xaa},{0x00,0x19,0x50,0xaa},
+{0x00,0xd1,0x3c,0xaa},{0x00,0xd1,0x3c,0xaa},{0x00,0x1e,0x06,0xaa},{0x00,0x1e,0x06,0xaa},
+{0x00,0x00,0x00,0x00}
+};
+#if 0
+static __u8 po3130_initVGA_slowdata[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},
+{0xb3,0x00,0x04,0xcc},{0xb3,0x00,0x24,0xcc},{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},
+{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},{0xb3,0x03,0x1a,0xcc},
+{0xb3,0x04,0x15,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},{0xb3,0x22,0x01,0xcc},
+{0xb3,0x23,0xe8,0xcc},{0xb8,0x08,0xe8,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0xf6,0xcc},
+{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0x71,0xcc},{0xb8,0x00,0x23,0xcc},{0xb8,0x27,0x20,0xcc},
+{0xb8,0x01,0x79,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x2c,0x50,0xcc},{0xb8,0x2d,0xf8,0xcc},
+{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},{0xb8,0x31,0xf8,0xcc},
+{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x50,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0x00,0x1e,0xc6,0xaa},{0x00,0x20,0x44,0xaa},
+{0x00,0xad,0x02,0xaa},{0x00,0xae,0x2c,0xaa},{0x00,0x12,0x08,0xaa},{0x00,0x17,0x41,0xaa},
+{0x00,0x19,0x41,0xaa},{0x00,0x1e,0x06,0xaa},{0x00,0x21,0x00,0xaa},{0x00,0x36,0xc0,0xaa},
+{0x00,0x37,0xc8,0xaa},{0x00,0x3b,0x36,0xaa},{0x00,0x4b,0xfe,0xaa},{0x00,0x51,0x1c,0xaa},
+{0x00,0x52,0x01,0xaa},{0x00,0x55,0x0a,0xaa},{0x00,0x59,0x6f,0xaa},{0x00,0x5a,0x04,0xaa},
+{0x00,0x5c,0x10,0xaa},{0x00,0x5d,0x10,0xaa},{0x00,0x5e,0x10,0xaa},{0x00,0x5f,0x10,0xaa},
+{0x00,0x61,0x00,0xaa},{0x00,0x62,0x18,0xaa},{0x00,0x63,0x30,0xaa},{0x00,0x70,0x68,0xaa},
+{0x00,0x80,0x71,0xaa},{0x00,0x81,0x08,0xaa},{0x00,0x82,0x00,0xaa},{0x00,0x83,0x55,0xaa},
+{0x00,0x84,0x06,0xaa},{0x00,0x85,0x06,0xaa},{0x00,0x86,0x13,0xaa},{0x00,0x87,0x18,0xaa},
+{0x00,0xaa,0x3f,0xaa},{0x00,0xab,0x44,0xaa},{0x00,0xb0,0x68,0xaa},{0x00,0xb5,0x10,0xaa},
+{0x00,0xb8,0x20,0xaa},{0x00,0xb9,0xa0,0xaa},{0x00,0xbc,0x04,0xaa},{0x00,0x8b,0x40,0xaa},
+{0x00,0x8c,0x91,0xaa},{0x00,0x8d,0x8f,0xaa},{0x00,0x8e,0x91,0xaa},{0x00,0x8f,0x43,0xaa},
+{0x00,0x90,0x92,0xaa},{0x00,0x91,0x89,0xaa},{0x00,0x92,0x9d,0xaa},{0x00,0x93,0x46,0xaa},
+{0x00,0xd6,0x22,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},
+{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},
+{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},
+{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0x62,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},
+{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},
+{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},
+{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0xa2,0xaa},{0x00,0x73,0x00,0xaa},
+{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},
+{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},
+{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0x4c,0x07,0xaa},
+{0x00,0x4b,0xe0,0xaa},{0x00,0x4e,0x77,0xaa},{0x00,0x59,0x66,0xaa},{0x00,0x4d,0x0a,0xaa},
+{0x00,0xd1,0x00,0xaa},{0x00,0x20,0xc4,0xaa},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},
+{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},
+{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0x00,0x05,0x00,0xaa},
+{0xb3,0x5c,0x00,0xcc},{0xb3,0x01,0x41,0xcc},{0x00,0x00,0x00,0x00}
+};
+#endif
+static __u8 po3130_initQVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x09,0xcc},
+{0xb3,0x00,0x04,0xcc},{0xb3,0x00,0x24,0xcc},{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},
+{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},{0xb3,0x03,0x1a,0xcc},
+{0xb3,0x04,0x15,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},{0xb3,0x22,0x01,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb8,0x08,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0xf6,0xcc},
+{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0xd1,0xcc},{0xb8,0x00,0x21,0xcc},{0xb8,0x27,0x20,0xcc},
+{0xb8,0x01,0x79,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x2c,0x50,0xcc},{0xb8,0x2d,0xf8,0xcc},
+{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},{0xb8,0x31,0xf8,0xcc},
+{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x50,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0x00,0x1e,0xc6,0xaa},{0x00,0x20,0x44,0xaa},
+{0x00,0xad,0x02,0xaa},{0x00,0xae,0x2c,0xaa},{0x00,0x12,0x08,0xaa},{0x00,0x17,0x41,0xaa},
+{0x00,0x19,0x41,0xaa},{0x00,0x1e,0x06,0xaa},{0x00,0x21,0x00,0xaa},{0x00,0x36,0xc0,0xaa},
+{0x00,0x37,0xc8,0xaa},{0x00,0x3b,0x36,0xaa},{0x00,0x4b,0xfe,0xaa},{0x00,0x51,0x1c,0xaa},
+{0x00,0x52,0x01,0xaa},{0x00,0x55,0x0a,0xaa},{0x00,0x59,0x6f,0xaa},{0x00,0x5a,0x04,0xaa},
+{0x00,0x5c,0x10,0xaa},{0x00,0x5d,0x10,0xaa},{0x00,0x5e,0x10,0xaa},{0x00,0x5f,0x10,0xaa},
+{0x00,0x61,0x00,0xaa},{0x00,0x62,0x18,0xaa},{0x00,0x63,0x30,0xaa},{0x00,0x70,0x68,0xaa},
+{0x00,0x80,0x71,0xaa},{0x00,0x81,0x08,0xaa},{0x00,0x82,0x00,0xaa},{0x00,0x83,0x55,0xaa},
+{0x00,0x84,0x06,0xaa},{0x00,0x85,0x06,0xaa},{0x00,0x86,0x13,0xaa},{0x00,0x87,0x18,0xaa},
+{0x00,0xaa,0x3f,0xaa},{0x00,0xab,0x44,0xaa},{0x00,0xb0,0x68,0xaa},{0x00,0xb5,0x10,0xaa},
+{0x00,0xb8,0x20,0xaa},{0x00,0xb9,0xa0,0xaa},{0x00,0xbc,0x04,0xaa},{0x00,0x8b,0x40,0xaa},
+{0x00,0x8c,0x91,0xaa},{0x00,0x8d,0x8f,0xaa},{0x00,0x8e,0x91,0xaa},{0x00,0x8f,0x43,0xaa},
+{0x00,0x90,0x92,0xaa},{0x00,0x91,0x89,0xaa},{0x00,0x92,0x9d,0xaa},{0x00,0x93,0x46,0xaa},
+{0x00,0xd6,0x22,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},
+{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},
+{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},
+{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0x62,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},
+{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},
+{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},
+{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0xa2,0xaa},{0x00,0x73,0x00,0xaa},
+{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},
+{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},
+{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0x4c,0x07,0xaa},
+{0x00,0x4b,0xe0,0xaa},{0x00,0x4e,0x77,0xaa},{0x00,0x59,0x66,0xaa},{0x00,0x4d,0x0a,0xaa},
+{0x00,0xd1,0x00,0xaa},{0x00,0x20,0xc4,0xaa},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},
+{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},
+{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0xbc,0x02,0x18,0xcc},
+{0xbc,0x03,0x50,0xcc},{0xbc,0x04,0x18,0xcc},{0xbc,0x05,0x00,0xcc},{0xbc,0x06,0x00,0xcc},
+{0xbc,0x08,0x30,0xcc},{0xbc,0x09,0x40,0xcc},{0xbc,0x0a,0x10,0xcc},{0xbc,0x0b,0x00,0xcc},
+{0xbc,0x0c,0x00,0xcc},{0x00,0x05,0x00,0xaa},{0xb3,0x5c,0x00,0xcc},{0xb3,0x01,0x41,0xcc},
+{0x00,0x00,0x00,0x00}
+};
+#if 0
+static __u8 po3130_initQVGA_slowdata[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x09,0xcc},
+{0xb3,0x00,0x04,0xcc},{0xb3,0x00,0x24,0xcc},{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},
+{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},{0xb3,0x03,0x1a,0xcc},
+{0xb3,0x04,0x15,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},{0xb3,0x22,0x01,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb8,0x08,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0xf6,0xcc},
+{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0xd1,0xcc},{0xb8,0x00,0x23,0xcc},{0xb8,0x27,0x20,0xcc},
+{0xb8,0x01,0x79,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x2c,0x50,0xcc},{0xb8,0x2d,0xf8,0xcc},
+{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},{0xb8,0x31,0xf8,0xcc},
+{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x50,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0x00,0x1e,0xc6,0xaa},{0x00,0x20,0x44,0xaa},
+{0x00,0xad,0x02,0xaa},{0x00,0xae,0x2c,0xaa},{0x00,0x12,0x08,0xaa},{0x00,0x17,0x41,0xaa},
+{0x00,0x19,0x41,0xaa},{0x00,0x1e,0x06,0xaa},{0x00,0x21,0x00,0xaa},{0x00,0x36,0xc0,0xaa},
+{0x00,0x37,0xc8,0xaa},{0x00,0x3b,0x36,0xaa},{0x00,0x4b,0xfe,0xaa},{0x00,0x51,0x1c,0xaa},
+{0x00,0x52,0x01,0xaa},{0x00,0x55,0x0a,0xaa},{0x00,0x59,0x6f,0xaa},{0x00,0x5a,0x04,0xaa},
+{0x00,0x5c,0x10,0xaa},{0x00,0x5d,0x10,0xaa},{0x00,0x5e,0x10,0xaa},{0x00,0x5f,0x10,0xaa},
+{0x00,0x61,0x00,0xaa},{0x00,0x62,0x18,0xaa},{0x00,0x63,0x30,0xaa},{0x00,0x70,0x68,0xaa},
+{0x00,0x80,0x71,0xaa},{0x00,0x81,0x08,0xaa},{0x00,0x82,0x00,0xaa},{0x00,0x83,0x55,0xaa},
+{0x00,0x84,0x06,0xaa},{0x00,0x85,0x06,0xaa},{0x00,0x86,0x13,0xaa},{0x00,0x87,0x18,0xaa},
+{0x00,0xaa,0x3f,0xaa},{0x00,0xab,0x44,0xaa},{0x00,0xb0,0x68,0xaa},{0x00,0xb5,0x10,0xaa},
+{0x00,0xb8,0x20,0xaa},{0x00,0xb9,0xa0,0xaa},{0x00,0xbc,0x04,0xaa},{0x00,0x8b,0x40,0xaa},
+{0x00,0x8c,0x91,0xaa},{0x00,0x8d,0x8f,0xaa},{0x00,0x8e,0x91,0xaa},{0x00,0x8f,0x43,0xaa},
+{0x00,0x90,0x92,0xaa},{0x00,0x91,0x89,0xaa},{0x00,0x92,0x9d,0xaa},{0x00,0x93,0x46,0xaa},
+{0x00,0xd6,0x22,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},
+{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},
+{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},
+{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0x62,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},
+{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},
+{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},
+{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0xa2,0xaa},{0x00,0x73,0x00,0xaa},
+{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},
+{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},
+{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0x4c,0x07,0xaa},
+{0x00,0x4b,0xe0,0xaa},{0x00,0x4e,0x77,0xaa},{0x00,0x59,0x66,0xaa},{0x00,0x4d,0x0a,0xaa},
+{0x00,0xd1,0x00,0xaa},{0x00,0x20,0xc4,0xaa},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},
+{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},
+{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0xbc,0x02,0x18,0xcc},
+{0xbc,0x03,0x50,0xcc},{0xbc,0x04,0x18,0xcc},{0xbc,0x05,0x00,0xcc},{0xbc,0x06,0x00,0xcc},
+{0xbc,0x08,0x30,0xcc},{0xbc,0x09,0x40,0xcc},{0xbc,0x0a,0x10,0xcc},{0xbc,0x0b,0x00,0xcc},
+{0xbc,0x0c,0x00,0xcc},{0x00,0x05,0x00,0xaa},{0xb3,0x5c,0x00,0xcc},{0xb3,0x01,0x41,0xcc},
+{0x00,0x00,0x00,0x00}
+};
+static __u8 po3130_initQQVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x09,0xcc},
+{0xb3,0x00,0x04,0xcc},{0xb3,0x00,0x24,0xcc},{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},
+{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},{0xb3,0x03,0x1a,0xcc},
+{0xb3,0x04,0x15,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},{0xb3,0x22,0x01,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb8,0x08,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0xf6,0xcc},
+{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0xf1,0xcc},{0xb8,0x00,0x21,0xcc},{0xb8,0x27,0x20,0xcc},
+{0xb8,0x01,0x79,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x2c,0x50,0xcc},{0xb8,0x2d,0xf8,0xcc},
+{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},{0xb8,0x31,0xf8,0xcc},
+{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x50,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0x00,0x1e,0xc6,0xaa},{0x00,0x20,0x44,0xaa},
+{0x00,0xad,0x02,0xaa},{0x00,0xae,0x2c,0xaa},{0x00,0x12,0x08,0xaa},{0x00,0x17,0x41,0xaa},
+{0x00,0x19,0x41,0xaa},{0x00,0x1e,0x06,0xaa},{0x00,0x21,0x00,0xaa},{0x00,0x36,0xc0,0xaa},
+{0x00,0x37,0xc8,0xaa},{0x00,0x3b,0x36,0xaa},{0x00,0x4b,0xfe,0xaa},{0x00,0x51,0x1c,0xaa},
+{0x00,0x52,0x01,0xaa},{0x00,0x55,0x0a,0xaa},{0x00,0x59,0x6f,0xaa},{0x00,0x5a,0x04,0xaa},
+{0x00,0x5c,0x10,0xaa},{0x00,0x5d,0x10,0xaa},{0x00,0x5e,0x10,0xaa},{0x00,0x5f,0x10,0xaa},
+{0x00,0x61,0x00,0xaa},{0x00,0x62,0x18,0xaa},{0x00,0x63,0x30,0xaa},{0x00,0x70,0x68,0xaa},
+{0x00,0x80,0x71,0xaa},{0x00,0x81,0x08,0xaa},{0x00,0x82,0x00,0xaa},{0x00,0x83,0x55,0xaa},
+{0x00,0x84,0x06,0xaa},{0x00,0x85,0x06,0xaa},{0x00,0x86,0x13,0xaa},{0x00,0x87,0x18,0xaa},
+{0x00,0xaa,0x3f,0xaa},{0x00,0xab,0x44,0xaa},{0x00,0xb0,0x68,0xaa},{0x00,0xb5,0x10,0xaa},
+{0x00,0xb8,0x20,0xaa},{0x00,0xb9,0xa0,0xaa},{0x00,0xbc,0x04,0xaa},{0x00,0x8b,0x40,0xaa},
+{0x00,0x8c,0x91,0xaa},{0x00,0x8d,0x8f,0xaa},{0x00,0x8e,0x91,0xaa},{0x00,0x8f,0x43,0xaa},
+{0x00,0x90,0x92,0xaa},{0x00,0x91,0x89,0xaa},{0x00,0x92,0x9d,0xaa},{0x00,0x93,0x46,0xaa},
+{0x00,0xd6,0x22,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},
+{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},
+{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},
+{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0x62,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},
+{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},
+{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},
+{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0xa2,0xaa},{0x00,0x73,0x00,0xaa},
+{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},
+{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},
+{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0x4c,0x07,0xaa},
+{0x00,0x4b,0xe0,0xaa},{0x00,0x4e,0x77,0xaa},{0x00,0x59,0x66,0xaa},{0x00,0x4d,0x0a,0xaa},
+{0x00,0xd1,0x00,0xaa},{0x00,0x20,0xc4,0xaa},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},
+{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},
+{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0x00,0x05,0x00,0xaa},
+{0xb3,0x5c,0x00,0xcc},{0xb3,0x01,0x41,0xcc},{0x00,0x00,0x00,0x00}
+};
+static __u8 po3130_initQQVGA_fuldata[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x09,0xcc},
+{0xb3,0x00,0x04,0xcc},{0xb3,0x00,0x24,0xcc},{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},
+{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},{0xb3,0x03,0x1a,0xcc},
+{0xb3,0x04,0x15,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},{0xb3,0x22,0x01,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb8,0x08,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0xf6,0xcc},
+{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0xf1,0xcc},{0xb8,0x00,0x23,0xcc},{0xb8,0x27,0x20,0xcc},
+{0xb8,0x01,0x79,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x2c,0x50,0xcc},{0xb8,0x2d,0xf8,0xcc},
+{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},{0xb8,0x31,0xf8,0xcc},
+{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x50,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0x00,0x1e,0xc6,0xaa},{0x00,0x20,0x44,0xaa},
+{0x00,0xad,0x02,0xaa},{0x00,0xae,0x2c,0xaa},{0x00,0x12,0x08,0xaa},{0x00,0x17,0x41,0xaa},
+{0x00,0x19,0x41,0xaa},{0x00,0x1e,0x06,0xaa},{0x00,0x21,0x00,0xaa},{0x00,0x36,0xc0,0xaa},
+{0x00,0x37,0xc8,0xaa},{0x00,0x3b,0x36,0xaa},{0x00,0x4b,0xfe,0xaa},{0x00,0x51,0x1c,0xaa},
+{0x00,0x52,0x01,0xaa},{0x00,0x55,0x0a,0xaa},{0x00,0x59,0x6f,0xaa},{0x00,0x5a,0x04,0xaa},
+{0x00,0x5c,0x10,0xaa},{0x00,0x5d,0x10,0xaa},{0x00,0x5e,0x10,0xaa},{0x00,0x5f,0x10,0xaa},
+{0x00,0x61,0x00,0xaa},{0x00,0x62,0x18,0xaa},{0x00,0x63,0x30,0xaa},{0x00,0x70,0x68,0xaa},
+{0x00,0x80,0x71,0xaa},{0x00,0x81,0x08,0xaa},{0x00,0x82,0x00,0xaa},{0x00,0x83,0x55,0xaa},
+{0x00,0x84,0x06,0xaa},{0x00,0x85,0x06,0xaa},{0x00,0x86,0x13,0xaa},{0x00,0x87,0x18,0xaa},
+{0x00,0xaa,0x3f,0xaa},{0x00,0xab,0x44,0xaa},{0x00,0xb0,0x68,0xaa},{0x00,0xb5,0x10,0xaa},
+{0x00,0xb8,0x20,0xaa},{0x00,0xb9,0xa0,0xaa},{0x00,0xbc,0x04,0xaa},{0x00,0x8b,0x40,0xaa},
+{0x00,0x8c,0x91,0xaa},{0x00,0x8d,0x8f,0xaa},{0x00,0x8e,0x91,0xaa},{0x00,0x8f,0x43,0xaa},
+{0x00,0x90,0x92,0xaa},{0x00,0x91,0x89,0xaa},{0x00,0x92,0x9d,0xaa},{0x00,0x93,0x46,0xaa},
+{0x00,0xd6,0x22,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},
+{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},
+{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},
+{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0x62,0xaa},{0x00,0x73,0x00,0xaa},{0x00,0x74,0x10,0xaa},
+{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},{0x00,0x78,0x49,0xaa},
+{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},{0x00,0x7c,0xba,0xaa},
+{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0xd6,0xa2,0xaa},{0x00,0x73,0x00,0xaa},
+{0x00,0x74,0x10,0xaa},{0x00,0x75,0x20,0xaa},{0x00,0x76,0x2b,0xaa},{0x00,0x77,0x36,0xaa},
+{0x00,0x78,0x49,0xaa},{0x00,0x79,0x5a,0xaa},{0x00,0x7a,0x7f,0xaa},{0x00,0x7b,0x9b,0xaa},
+{0x00,0x7c,0xba,0xaa},{0x00,0x7d,0xd4,0xaa},{0x00,0x7e,0xea,0xaa},{0x00,0x4c,0x07,0xaa},
+{0x00,0x4b,0xe0,0xaa},{0x00,0x4e,0x77,0xaa},{0x00,0x59,0x66,0xaa},{0x00,0x4d,0x0a,0xaa},
+{0x00,0xd1,0x00,0xaa},{0x00,0x20,0xc4,0xaa},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},
+{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},
+{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0x00,0x05,0x00,0xaa},
+{0xb3,0x5c,0x00,0xcc},{0xb3,0x01,0x41,0xcc},{0x00,0x00,0x00,0x00}
+};
+#endif
+static __u8 hv7131r_gamma[17]= {
+//	0x00,0x13,0x38,0x59,0x79,0x92,0xa7,0xb9,0xc8,
+//	0xd4,0xdf,0xe7,0xee,0xf4,0xf9,0xfc,0xff
+	0x04,0x1a,0x36,0x55,0x6f,0x87,0x9d,0xb0,0xc1,
+	0xcf,0xda,0xe4,0xec,0xf3,0xf8,0xfd,0xff
+};
+static __u8 hv7131r_matrix[9]= {
+	0x5f,0xec,0xf5,0xf1,0x5a,0xf5,0xf1,0xec,0x63
+};
+static __u8 hv7131r_initVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},{0xb3,0x00,0x24,0xcc},
+{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},
+{0xb3,0x01,0x45,0xcc},{0xb3,0x03,0x0b,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x22,0x01,0xcc},{0xb3,0x23,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},{0xb3,0x16,0x02,0xcc},
+{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0x91,0xcc},{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0x73,0xcc},
+{0xb8,0x00,0x23,0xcc},{0x00,0x01,0x0c,0xaa},{0x00,0x14,0x01,0xaa},{0x00,0x15,0xe6,0xaa},{0x00,0x16,0x02,0xaa},
+{0x00,0x17,0x86,0xaa},{0x00,0x23,0x00,0xaa},{0x00,0x25,0x09,0xaa},{0x00,0x26,0x27,0xaa},{0x00,0x27,0xc0,0xaa},
+{0xb8,0x2c,0x60,0xcc},{0xb8,0x2d,0xf8,0xcc},{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},
+{0xb8,0x31,0xf8,0xcc},{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x65,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x01,0x7d,0xcc},{0xb8,0x81,0x09,0xcc},
+{0xb3,0x01,0x41,0xcc},{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},
+{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},{0x00,0x30,0x18,0xaa},
+{0x00,0x00,0x00,0x00}
+};
+#if 0 
+static __u8 hv7131r_initVGA_slowdata[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},{0xb3,0x00,0x24,0xcc},
+{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},
+{0xb3,0x01,0x45,0xcc},{0xb3,0x03,0x0b,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x22,0x01,0xcc},{0xb3,0x23,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},{0xb3,0x16,0x02,0xcc},
+{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0x91,0xcc},{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0x73,0xcc},
+{0xb8,0x00,0x23,0xcc},{0x00,0x01,0x0c,0xaa},{0x00,0x14,0x01,0xaa},{0x00,0x15,0xe6,0xaa},{0x00,0x16,0x02,0xaa},
+{0x00,0x17,0x86,0xaa},{0x00,0x23,0x00,0xaa},{0x00,0x25,0x01,0xaa},{0x00,0x26,0xd4,0xaa},{0x00,0x27,0xc0,0xaa},
+{0xb8,0x2c,0x60,0xcc},{0xb8,0x2d,0xf8,0xcc},{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},
+{0xb8,0x31,0xf8,0xcc},{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x65,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x01,0x7d,0xcc},{0xb8,0x81,0x09,0xcc},
+{0xb3,0x01,0x41,0xcc},{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},
+{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},{0x00,0x30,0x18,0xaa},
+{0x00,0x00,0x00,0x00}
+};
+#endif
+static __u8 hv7131r_initQVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},{0xb3,0x00,0x24,0xcc},
+{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},
+{0xb3,0x03,0x0b,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},{0xb3,0x22,0x01,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},
+{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0x91,0xcc},{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0xd1,0xcc},{0xb8,0x00,0x21,0xcc},
+{0x00,0x01,0x0c,0xaa},{0x00,0x14,0x01,0xaa},{0x00,0x15,0xe6,0xaa},{0x00,0x16,0x02,0xaa},{0x00,0x17,0x86,0xaa},
+{0x00,0x23,0x00,0xaa},{0x00,0x25,0x01,0xaa},{0x00,0x26,0xd4,0xaa},{0x00,0x27,0xc0,0xaa},{0xbc,0x02,0x08,0xcc},
+{0xbc,0x03,0x70,0xcc},{0xbc,0x04,0x08,0xcc},{0xbc,0x05,0x00,0xcc},{0xbc,0x06,0x00,0xcc},{0xbc,0x08,0x3c,0xcc},
+{0xbc,0x09,0x40,0xcc},{0xbc,0x0a,0x04,0xcc},{0xbc,0x0b,0x00,0xcc},{0xbc,0x0c,0x00,0xcc},{0xb8,0xfe,0x02,0xcc},
+{0xb8,0xff,0x07,0xcc},{0xb9,0x00,0x14,0xcc},{0xb9,0x01,0x14,0xcc},{0xb9,0x02,0x14,0xcc},{0xb9,0x03,0x00,0xcc},
+{0xb9,0x04,0x02,0xcc},{0xb9,0x05,0x05,0xcc},{0xb9,0x06,0x0f,0xcc},{0xb9,0x07,0x0f,0xcc},{0xb9,0x08,0x0f,0xcc},
+{0xb8,0x2c,0x60,0xcc},{0xb8,0x2d,0xf8,0xcc},{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},
+{0xb8,0x31,0xf8,0xcc},{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x65,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x01,0x7d,0xcc},{0xb8,0x81,0x09,0xcc},
+{0xb3,0x01,0x41,0xcc},{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},
+{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},{0x00,0x30,0x18,0xaa},
+{0x00,0x00,0x00,0x00}
+};
+#if 0
+static __u8 hv7131r_initQVGA_slowdata[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},{0xb3,0x00,0x24,0xcc},
+{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},
+{0xb3,0x03,0x0b,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},{0xb3,0x22,0x01,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},
+{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0x91,0xcc},{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0xd1,0xcc},{0xb8,0x00,0x21,0xcc},
+{0x00,0x01,0x0c,0xaa},{0x00,0x14,0x01,0xaa},{0x00,0x15,0xe6,0xaa},{0x00,0x16,0x02,0xaa},{0x00,0x17,0x86,0xaa},
+{0x00,0x23,0x00,0xaa},{0x00,0x25,0x01,0xaa},{0x00,0x26,0xd4,0xaa},{0x00,0x27,0xc0,0xaa},{0xbc,0x02,0x08,0xcc},
+{0xbc,0x03,0x70,0xcc},{0xbc,0x04,0x08,0xcc},{0xbc,0x05,0x00,0xcc},{0xbc,0x06,0x00,0xcc},{0xbc,0x08,0x3c,0xcc},
+{0xbc,0x09,0x40,0xcc},{0xbc,0x0a,0x04,0xcc},{0xbc,0x0b,0x00,0xcc},{0xbc,0x0c,0x00,0xcc},{0xb8,0xfe,0x02,0xcc},
+{0xb8,0xff,0x07,0xcc},{0xb9,0x00,0x14,0xcc},{0xb9,0x01,0x14,0xcc},{0xb9,0x02,0x14,0xcc},{0xb9,0x03,0x00,0xcc},
+{0xb9,0x04,0x02,0xcc},{0xb9,0x05,0x05,0xcc},{0xb9,0x06,0x0f,0xcc},{0xb9,0x07,0x0f,0xcc},{0xb9,0x08,0x0f,0xcc},
+{0xb8,0x2c,0x60,0xcc},{0xb8,0x2d,0xf8,0xcc},{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},
+{0xb8,0x31,0xf8,0xcc},{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x65,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x01,0x7d,0xcc},{0xb8,0x81,0x09,0xcc},
+{0xb3,0x01,0x41,0xcc},{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},
+{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},{0x00,0x30,0x18,0xaa},
+{0x00,0x00,0x00,0x00}
+};
+static __u8 hv7131r_initQQVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},{0xb3,0x00,0x24,0xcc},
+{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},
+{0xb3,0x01,0x45,0xcc},{0xb3,0x03,0x0b,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x22,0x01,0xcc},{0xb3,0x23,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},{0xb3,0x16,0x02,0xcc},
+{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0x91,0xcc},{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0xf3,0xcc},
+{0xb8,0x00,0x23,0xcc},{0x00,0x01,0x0c,0xaa},{0x00,0x14,0x01,0xaa},{0x00,0x15,0xe6,0xaa},{0x00,0x16,0x02,0xaa},
+{0x00,0x17,0x86,0xaa},{0x00,0x23,0x00,0xaa},{0x00,0x25,0x01,0xaa},{0x00,0x26,0xd4,0xaa},{0x00,0x27,0xc0,0xaa},
+{0xb8,0x2c,0x60,0xcc},{0xb8,0x2d,0xf8,0xcc},{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},
+{0xb8,0x31,0xf8,0xcc},{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x65,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x01,0x7d,0xcc},{0xb8,0x81,0x09,0xcc},
+{0xb3,0x01,0x41,0xcc},{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},
+{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},{0x00,0x30,0x18,0xaa},
+{0x00,0x00,0x00,0x00}
+};
+static __u8 hv7131r_initQQVGA_fuldata[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},{0xb3,0x00,0x24,0xcc},
+{0xb3,0x00,0x25,0xcc},{0xb3,0x08,0x01,0xcc},{0xb3,0x09,0x0c,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},
+{0xb3,0x01,0x45,0xcc},{0xb3,0x03,0x0b,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x20,0x00,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x22,0x01,0xcc},{0xb3,0x23,0xe0,0xcc},{0xb3,0x14,0x00,0xcc},{0xb3,0x15,0x00,0xcc},{0xb3,0x16,0x02,0xcc},
+{0xb3,0x17,0x7f,0xcc},{0xb3,0x34,0x01,0xcc},{0xb3,0x35,0x91,0xcc},{0xb3,0x00,0x27,0xcc},{0xbc,0x00,0xf3,0xcc},
+{0xb8,0x00,0x23,0xcc},{0x00,0x01,0x0c,0xaa},{0x00,0x14,0x01,0xaa},{0x00,0x15,0xe6,0xaa},{0x00,0x16,0x02,0xaa},
+{0x00,0x17,0x86,0xaa},{0x00,0x23,0x00,0xaa},{0x00,0x25,0x01,0xaa},{0x00,0x26,0xd4,0xaa},{0x00,0x27,0xc0,0xaa},
+{0xb8,0x2c,0x60,0xcc},{0xb8,0x2d,0xf8,0xcc},{0xb8,0x2e,0xf8,0xcc},{0xb8,0x2f,0xf8,0xcc},{0xb8,0x30,0x50,0xcc},
+{0xb8,0x31,0xf8,0xcc},{0xb8,0x32,0xf8,0xcc},{0xb8,0x33,0xf8,0xcc},{0xb8,0x34,0x65,0xcc},{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},{0xb8,0x37,0x00,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x01,0x7d,0xcc},{0xb8,0x81,0x09,0xcc},
+{0xb3,0x01,0x41,0xcc},{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},
+{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},
+{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},{0x00,0x30,0x18,0xaa},
+{0x00,0x00,0x00,0x00}
+};
+#endif
+static __u8 ov7660_gamma[17]= {
+	0x00,0x13,0x38,0x59,0x79,0x92,0xa7,0xb9,0xc8,
+	0xd4,0xdf,0xe7,0xee,0xf4,0xf9,0xfc,0xff
+};
+static __u8 ov7660_matrix[9]= {
+	0x5a,0xf0,0xf6,0xf3,0x57,0xf6,0xf3,0xef,0x62
+};
+static __u8 ov7660_initVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},
+{0xb3,0x00,0x21,0xcc},{0xb3,0x00,0x26,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},
+{0xb3,0x03,0x1f,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},
+{0xb3,0x15,0x00,0xcc},// 0xb315  <-0 href startl
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb3,0x1d,0x01,0xcc},{0xb3,0x1f,0x02,0xcc},{0xb3,0x34,0x01,0xcc},
+{0xb3,0x35,0xa1,0xcc},{0xb3,0x00,0x26,0xcc},
+{0xb8,0x00,0x33,0xcc}, //13
+{0xb8,0x01,0x7d,0xcc},
+{0xbc,0x00,0x73,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x8f,0x50,0xcc},
+{0x00,0x01,0x80,0xaa},{0x00,0x02,0x80,0xaa},{0x00,0x12,0x80,0xaa},{0x00,0x12,0x05,0xaa},
+{0x00,0x1e,0x01,0xaa},
+{0x00,0x3d,0x40,0xaa}, // 0x3d <-40 gamma 01
+{0x00,0x41,0x00,0xaa}, // edge 00
+{0x00,0x0d,0x48,0xaa},{0x00,0x0e,0x04,0xaa},
+{0x00,0x13,0xa7,0xaa},
+{0x00,0x40,0xc1,0xaa},{0x00,0x35,0x00,0xaa},{0x00,0x36,0x00,0xaa},
+{0x00,0x3c,0x68,0xaa},{0x00,0x1b,0x05,0xaa},{0x00,0x39,0x43,0xaa},{0x00,0x8d,0xcf,0xaa},
+{0x00,0x8b,0xcc,0xaa},{0x00,0x8c,0xcc,0xaa},{0x00,0x0f,0x62,0xaa},{0x00,0x35,0x84,0xaa},
+{0x00,0x3b,0x08,0xaa}, // 0 //Nightframe 1/4 + 50Hz -> 0xC8
+{0x00,0x3a,0x00,0xaa}, // mx change yuyv format 00,04, 01; 08, 0c
+{0x00,0x14,0x2a,0xaa}, // agc ampli
+{0x00,0x9e,0x40,0xaa},{0xb8,0x8f,0x50,0xcc},{0x00,0x01,0x80,0xaa},
+{0x00,0x02,0x80,0xaa},
+{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},
+{0xb9,0x00,0x28,0xcc},
+{0xb9,0x01,0x28,0xcc},{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},
+{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},
+
+{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},
+/*
+{0xb8,0xc6,0x22,0xcc},{0xb8,0xc7,0x22,0xcc},
+{0xb8,0xc8,0x22,0xcc},{0xb8,0xc9,0x22,0xcc},{0xb8,0xca,0x22,0xcc},{0xb8,0xcb,0x22,0xcc},
+{0xb8,0xcc,0x22,0xcc},{0xb8,0xcd,0x22,0xcc},{0xb8,0xa0,0x30,0xcc},{0xb8,0xa1,0x04,0xcc},
+{0xb8,0xa2,0x04,0xcc},{0xb8,0xa3,0x04,0xcc},{0xb8,0xa4,0x04,0xcc},{0xb8,0xa5,0x04,0xcc},
+{0xb8,0xa6,0x06,0xcc},{0xb8,0xa7,0x06,0xcc},{0xb8,0xa8,0x06,0xcc},{0xb8,0xa9,0x06,0xcc},
+{0xb8,0xaa,0x08,0xcc},{0xb8,0xab,0x08,0xcc},{0xb8,0xac,0x0a,0xcc},{0xb8,0xad,0x0a,0xcc},
+{0xb8,0xae,0x0a,0xcc},{0xb8,0xaf,0x0a,0xcc},{0xb8,0xb0,0x08,0xcc},{0xb8,0xb1,0x04,0xcc},
+*/
+{0x00,0x29,0x3c,0xaa},{0xb3,0x01,0x45,0xcc},{0x00,0x00,0x00,0x00}
+};
+static __u8 ov7660_initQVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},
+{0xb3,0x00,0x21,0xcc},{0xb3,0x00,0x26,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},
+{0xb3,0x03,0x1f,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},
+{0xb3,0x15,0x00,0xcc},// 0xb315  <-0 href startl
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb3,0x1d,0x01,0xcc},{0xb3,0x1f,0x02,0xcc},{0xb3,0x34,0x01,0xcc},
+{0xb3,0x35,0xa1,0xcc},{0xb3,0x00,0x26,0xcc},
+{0xb8,0x00,0x33,0xcc}, //13
+{0xb8,0x01,0x7d,0xcc},
+/* sizer */
+{0xbc,0x00,0xd3,0xcc},
+{0xb8,0x81,0x09,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x8f,0x50,0xcc},
+{0x00,0x01,0x80,0xaa},{0x00,0x02,0x80,0xaa},{0x00,0x12,0x80,0xaa},{0x00,0x12,0x05,0xaa},
+{0x00,0x1e,0x01,0xaa},
+{0x00,0x3d,0x40,0xaa}, // 0x3d <-40 gamma 01
+{0x00,0x41,0x00,0xaa}, // edge 00
+{0x00,0x0d,0x48,0xaa},{0x00,0x0e,0x04,0xaa},
+{0x00,0x13,0xa7,0xaa},
+{0x00,0x40,0xc1,0xaa},{0x00,0x35,0x00,0xaa},{0x00,0x36,0x00,0xaa},
+{0x00,0x3c,0x68,0xaa},{0x00,0x1b,0x05,0xaa},{0x00,0x39,0x43,0xaa},{0x00,0x8d,0xcf,0xaa},
+{0x00,0x8b,0xcc,0xaa},{0x00,0x8c,0xcc,0xaa},{0x00,0x0f,0x62,0xaa},{0x00,0x35,0x84,0xaa},
+{0x00,0x3b,0x08,0xaa}, // 0 //Nightframe 1/4 + 50Hz -> 0xC8
+{0x00,0x3a,0x00,0xaa}, // mx change yuyv format 00,04, 01; 08, 0c
+{0x00,0x14,0x2a,0xaa}, // agc ampli
+{0x00,0x9e,0x40,0xaa},{0xb8,0x8f,0x50,0xcc},{0x00,0x01,0x80,0xaa},
+{0x00,0x02,0x80,0xaa},
+// sizer filters 
+{0xbc,0x02,0x08,0xcc},
+{0xbc,0x03,0x70,0xcc},
+{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},
+{0xb8,0x37,0x00,0xcc},
+{0xbc,0x04,0x08,0xcc},
+{0xbc,0x05,0x00,0xcc},
+{0xbc,0x06,0x00,0xcc},
+{0xbc,0x08,0x3c,0xcc},
+{0xbc,0x09,0x40,0xcc},
+{0xbc,0x0a,0x04,0xcc},
+{0xbc,0x0b,0x00,0xcc},
+{0xbc,0x0c,0x00,0xcc},
+//
+{0xb8,0xfe,0x00,0xcc},
+{0xb8,0xff,0x28,0xcc},
+//
+{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},
+{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},
+{0xb9,0x08,0x3c,0xcc},
+//
+{0xb8,0x8e,0x00,0xcc},
+{0xb8,0x8f,0xff,0xcc}, // ff
+{0x00,0x29,0x3c,0xaa},
+{0xb3,0x01,0x45,0xcc},//45
+{0x00,0x00,0x00,0x00}
+};
+#if 0
+static __u8 ov7660_initQQVGA_data[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},
+{0xb3,0x00,0x21,0xcc},{0xb3,0x00,0x26,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},
+{0xb3,0x03,0x1f,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x05,0x00,0xcc},{0xb3,0x06,0x01,0xcc},
+{0xb3,0x15,0x00,0xcc},// 0xb315  <-0 href startl
+{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb3,0x1d,0x01,0xcc},{0xb3,0x1f,0x02,0xcc},{0xb3,0x34,0x01,0xcc},
+{0xb3,0x35,0xa1,0xcc},{0xb3,0x00,0x26,0xcc},
+{0xb8,0x00,0x33,0xcc}, //13
+{0xb8,0x01,0x7d,0xcc},
+/* sizer */
+{0xbc,0x00,0xf3,0xcc},
+{0xb8,0x81,0x09,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x8f,0x50,0xcc},
+{0x00,0x01,0x80,0xaa},{0x00,0x02,0x80,0xaa},{0x00,0x12,0x80,0xaa},{0x00,0x12,0x05,0xaa},
+{0x00,0x1e,0x01,0xaa},
+{0x00,0x3d,0x40,0xaa}, // 0x3d <-40 gamma 01
+{0x00,0x41,0x00,0xaa}, // edge 00
+{0x00,0x0d,0x48,0xaa},{0x00,0x0e,0x04,0xaa},
+{0x00,0x13,0xa7,0xaa},
+{0x00,0x40,0xc1,0xaa},{0x00,0x35,0x00,0xaa},{0x00,0x36,0x00,0xaa},
+{0x00,0x3c,0x68,0xaa},{0x00,0x1b,0x05,0xaa},{0x00,0x39,0x43,0xaa},{0x00,0x8d,0xcf,0xaa},
+{0x00,0x8b,0xcc,0xaa},{0x00,0x8c,0xcc,0xaa},{0x00,0x0f,0x62,0xaa},{0x00,0x35,0x84,0xaa},
+{0x00,0x3b,0x08,0xaa}, // 0 //Nightframe 1/4 + 50Hz -> 0xC8
+{0x00,0x3a,0x00,0xaa}, // mx change yuyv format 00,04, 01; 08, 0c
+{0x00,0x14,0x2a,0xaa}, // agc ampli
+{0x00,0x9e,0x40,0xaa},{0xb8,0x8f,0x50,0xcc},{0x00,0x01,0x80,0xaa},
+{0x00,0x02,0x80,0xaa},
+// sizer filters 
+{0xbc,0x02,0x08,0xcc},
+{0xbc,0x03,0x70,0xcc},
+{0xb8,0x35,0x00,0xcc},
+{0xb8,0x36,0x00,0xcc},
+{0xb8,0x37,0x00,0xcc},
+{0xbc,0x04,0x08,0xcc},
+{0xbc,0x05,0x00,0xcc},
+{0xbc,0x06,0x00,0xcc},
+{0xbc,0x08,0x3c,0xcc},
+{0xbc,0x09,0x40,0xcc},
+{0xbc,0x0a,0x04,0xcc},
+{0xbc,0x0b,0x00,0xcc},
+{0xbc,0x0c,0x00,0xcc},
+//
+{0xb8,0xfe,0x00,0xcc},
+{0xb8,0xff,0x28,0xcc},
+//
+{0xb9,0x00,0x28,0xcc},{0xb9,0x01,0x28,0xcc},{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},
+{0xb9,0x04,0x00,0xcc},{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},
+{0xb9,0x08,0x3c,0xcc},
+//
+{0xb8,0x8e,0x00,0xcc},
+{0xb8,0x8f,0xff,0xcc}, // ff
+{0x00,0x29,0x3c,0xaa},
+{0xb3,0x01,0x45,0xcc},//45
+{0x00,0x00,0x00,0x00}
+};
+#endif
+static __u8 ov7660_50HZ[][4] = {
+   {0x00,0x3b,0x08,0xaa},
+   {0x00,0x9d,0x40,0xaa},
+   {0x00,0x13,0xa7,0xaa},
+   {0x00,0x00,0x00,0x00}
+};
+
+static __u8 ov7660_60HZ[][4] = {
+
+    {0x00,0x3b,0x00,0xaa},
+    {0x00,0x9e,0x40,0xaa},
+    {0x00,0x13,0xa7,0xaa},
+    {0x00,0x00,0x00,0x00}
+};
+
+static __u8 ov7660_NoFliker[][4] = {
+    {0x00,0x13,0x87,0xaa},
+    {0x00,0x00,0x00,0x00}
+};
+
+#if 0
+static __u8 ov7660_initQQVGA_fuldata[][4] = {
+{0xb0,0x4d,0x00,0xcc},{0xb3,0x01,0x01,0xcc},{0x00,0x00,0x50,0xdd},{0xb0,0x03,0x01,0xcc},
+{0xb3,0x00,0x21,0xcc},{0xb3,0x00,0x26,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},
+{0xb3,0x03,0x1f,0xcc},{0xb3,0x04,0x05,0xcc},{0xb3,0x05,0x01,0xcc},{0xb3,0x06,0x03,0xcc},
+{0xb3,0x15,0x00,0xcc},{0xb3,0x16,0x02,0xcc},{0xb3,0x17,0x7f,0xcc},{0xb3,0x21,0x00,0xcc},
+{0xb3,0x23,0xe0,0xcc},{0xb3,0x1d,0x01,0xcc},{0xb3,0x1f,0x02,0xcc},{0xb3,0x34,0x01,0xcc},
+{0xb3,0x35,0xa1,0xcc},{0xb3,0x00,0x26,0xcc},{0xb8,0x00,0x13,0xcc},{0xb8,0x01,0x7d,0xcc},
+{0xbc,0x00,0xf3,0xcc},{0xb8,0x81,0x09,0xcc},{0xb8,0x27,0x20,0xcc},{0xb8,0x8f,0x50,0xcc},
+{0x00,0x01,0x80,0xaa},{0x00,0x02,0x80,0xaa},{0x00,0x12,0x80,0xaa},{0x00,0x12,0x05,0xaa},
+{0x00,0x1e,0x01,0xaa},{0x00,0x3d,0x00,0xaa},{0x00,0x0d,0x48,0xaa},{0x00,0x0e,0x04,0xaa},
+{0x00,0x13,0x07,0xaa},{0x00,0x40,0xc1,0xaa},{0x00,0x35,0x00,0xaa},{0x00,0x36,0x00,0xaa},
+{0x00,0x3c,0x68,0xaa},{0x00,0x1b,0x05,0xaa},{0x00,0x39,0x43,0xaa},{0x00,0x8d,0xcf,0xaa},
+{0x00,0x8b,0xcc,0xaa},{0x00,0x8c,0xcc,0xaa},{0x00,0x0f,0x62,0xaa},{0x00,0x35,0x84,0xaa},
+{0x00,0x3b,0x00,0xaa},
+{0x00,0x3a,0x00,0xaa}, // mx change yuyv format
+{0x00,0x9e,0x40,0xaa},{0xb8,0x8f,0x50,0xcc},{0x00,0x01,0x80,0xaa},
+{0x00,0x02,0x80,0xaa},{0xb8,0xfe,0x00,0xcc},{0xb8,0xff,0x28,0xcc},{0xb9,0x00,0x28,0xcc},
+{0xb9,0x01,0x28,0xcc},{0xb9,0x02,0x28,0xcc},{0xb9,0x03,0x00,0xcc},{0xb9,0x04,0x00,0xcc},
+{0xb9,0x05,0x3c,0xcc},{0xb9,0x06,0x3c,0xcc},{0xb9,0x07,0x3c,0xcc},{0xb9,0x08,0x3c,0xcc},
+{0xb8,0x8e,0x00,0xcc},{0xb8,0x8f,0xff,0xcc},{0xb8,0xc6,0x22,0xcc},{0xb8,0xc7,0x22,0xcc},
+{0xb8,0xc8,0x22,0xcc},{0xb8,0xc9,0x22,0xcc},{0xb8,0xca,0x22,0xcc},{0xb8,0xcb,0x22,0xcc},
+{0xb8,0xcc,0x22,0xcc},{0xb8,0xcd,0x22,0xcc},{0xb8,0xa0,0x30,0xcc},{0xb8,0xa1,0x04,0xcc},
+{0xb8,0xa2,0x04,0xcc},{0xb8,0xa3,0x04,0xcc},{0xb8,0xa4,0x04,0xcc},{0xb8,0xa5,0x04,0xcc},
+{0xb8,0xa6,0x06,0xcc},{0xb8,0xa7,0x06,0xcc},{0xb8,0xa8,0x06,0xcc},{0xb8,0xa9,0x06,0xcc},
+{0xb8,0xaa,0x08,0xcc},{0xb8,0xab,0x08,0xcc},{0xb8,0xac,0x0a,0xcc},{0xb8,0xad,0x0a,0xcc},
+{0xb8,0xae,0x0a,0xcc},{0xb8,0xaf,0x0a,0xcc},{0xb8,0xb0,0x08,0xcc},{0xb8,0xb1,0x04,0xcc},
+{0x00,0x29,0x3c,0xaa},{0xb3,0x01,0x45,0xcc},{0x00,0x00,0x00,0x00}
+};
+#endif
diff -ruN linux-2.6.21/drivers/media/video/gspca/Vimicro/zc3xx.h linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/zc3xx.h
--- linux-2.6.21/drivers/media/video/gspca/Vimicro/zc3xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/Vimicro/zc3xx.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,1011 @@
+
+#ifndef ZC3XXUSB_H
+#define ZC3XXUSB_H
+/****************************************************************************
+#	 	Z-star zc301 zc302 P library                                #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+#include "tas5130c.h"
+#include "tas5130c_vf0250.h"
+#include "icm105a.h"
+#include "hdcs2020.h"
+#include "hv7131b.h"
+#include "pb0330.h"
+#include "hv7131c.h"
+#include "cs2102.h"
+#include "pas106b.h"
+#include "ov7630c.h"
+/*******************     Camera Interface   ***********************/
+static __u16 zc3xx_getbrightness(struct usb_spca50x *spca50x);
+static __u16 zc3xx_getcontrast(struct usb_spca50x *spca50x);
+static __u16 zc3xx_getcolors(struct usb_spca50x *spca50x);
+static void zc3xx_setbrightness(struct usb_spca50x *spca50x);
+static void zc3xx_setcontrast(struct usb_spca50x *spca50x);
+static void zc3xx_setcolors(struct usb_spca50x *spca50x);
+static int zc3xx_init(struct usb_spca50x *spca50x);
+static void zc3xx_start(struct usb_spca50x *spca50x);
+static void zc3xx_stop0(struct usb_spca50x *spca50x);
+static void zc3xx_stopN(struct usb_spca50x *spca50x);
+static int zc3xx_config(struct usb_spca50x *spca50x);
+static void zc3xx_shutdown(struct usb_spca50x *spca50x);
+static void zc3xx_setAutobright(struct usb_spca50x *spca50x);
+static void zc3xx_setquality(struct usb_spca50x *spca50x);
+static int zc3xx_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength);
+/*******************      Banding flilter   ***********************/
+static void zc3xx_set50HZ(struct usb_spca50x *spca50x);
+static void zc3xx_set60HZ(struct usb_spca50x *spca50x);
+static void zc3xx_set50HZScale(struct usb_spca50x *spca50x);
+static void zc3xx_set60HZScale(struct usb_spca50x *spca50x);
+static void zc3xx_setNoFliker(struct usb_spca50x *spca50x);
+static void zc3xx_setNoFlikerScale(struct usb_spca50x *spca50x);
+/*******************     Camera Private     ***********************/
+static void zc3xx_stopN(struct usb_spca50x *spca50x){}
+/******************************************************************/
+static struct cam_operation fzc3xx = {
+ 	.initialize = zc3xx_init,
+	.configure = zc3xx_config,
+	.start = zc3xx_start,
+	.stopN = zc3xx_stopN,
+	.stop0 = zc3xx_stop0,
+	.get_bright = zc3xx_getbrightness,
+	.set_bright = zc3xx_setbrightness,
+	.get_contrast = zc3xx_getcontrast,
+	.set_contrast = zc3xx_setcontrast,
+	.get_colors = zc3xx_getcolors,
+	.set_colors = zc3xx_setcolors,
+	.set_autobright = zc3xx_setAutobright,
+	.set_quality = zc3xx_setquality,
+	.cam_shutdown = zc3xx_shutdown,
+	.sof_detect = zc3xx_sofdetect,
+	.set_50HZ   = zc3xx_set50HZ,
+	.set_60HZ   = zc3xx_set60HZ,
+	.set_50HZScale   = zc3xx_set50HZScale,
+	.set_60HZScale   = zc3xx_set60HZScale,
+	.set_NoFliker    = zc3xx_setNoFliker,
+	.set_NoFlikerScale    = zc3xx_setNoFlikerScale,	
+ };
+ 
+enum {
+    SensorId = 0,
+    reg8d,
+    val8d,
+    SensorReg1,
+    valSreg1L,
+    valSreg1H,
+    SensorReg2,
+    valSreg2L,
+    valSreg2H,
+    totval,
+};
+#define VGATOT 9
+static __u8 zcxxi2cSensor[VGATOT][totval] = {
+    {0x00, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff},	// HV7131B
+    {0x04, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff},	// CS2102
+    {0x06, 0x8d, 0x08, 0x11, 0xaa, 0x00, 0xff, 0xff, 0xff},
+    {0x08, 0xff, 0xff, 0x1c, 0x00, 0x00, 0x15, 0xaa, 0x00},	// HDCS2020 ?
+    {0x0a, 0xff, 0xff, 0x07, 0xaa, 0xaa, 0xff, 0xff, 0xff},	// MI330 PB330
+    {0x0c, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff},	// ICM105
+    {0x0e, 0x8d, 0x08, 0x03, 0xaa, 0x00, 0xff, 0xff, 0xff},	// pas102
+    {0x02, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff},
+    {0x06, 0x8b, 0xa1, 0x12, 0x80, 0x00, 0x0a, 0x0b, 0xff},	// OV7630c
+};
+
+#define SIFTOT 1
+static __u8 zcxxi2cSensorSIF[SIFTOT][totval] = {
+#if 0
+    {0x01, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff},	// corrupt with 0x00 hv7131b reg 0 return 0x01 readonly
+    {0x05, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff},
+    {0x07, 0x8d, 0x08, 0x11, 0xaa, 0x00, 0xff, 0xff, 0xff},
+    {0x09, 0xff, 0xff, 0x1c, 0x00, 0x00, 0x15, 0xaa, 0x00},	// corrupt with 0x08 hdcs2020 reg 0 return 0x18 readonly
+    {0x0b, 0xff, 0xff, 0x07, 0xaa, 0xaa, 0xff, 0xff, 0xff},
+    {0x0d, 0xff, 0xff, 0x01, 0x11, 0x00, 0xff, 0xff, 0xff},	// corrupt with 0x0c ICM105 reg 0 is writable
+#endif
+    {0x0f, 0x8d, 0x08, 0x03, 0xaa, 0x00, 0xff, 0xff, 0xff},	// PAS106 reg3 did not write with 0x0e !conflict PAS102 
+};
+static __u8 zcxx3wrSensor[][5] = {
+    {0x8b, 0xb3, 0x11, 0x12, 0xff},	// HV7131R
+    {0x8b, 0x91, 0x14, 0x15, 0x16},
+    {0x8b, 0xe0, 0x14, 0x15, 0x16},
+    {0, 0, 0, 0, 0}
+};
+static __u16 zcxx_i2cRead(struct usb_device *dev, __u8 reg)
+{
+    __u8 retbyte = 0;
+    __u8 retval[] = { 0, 0 };
+
+    spca5xxRegWrite(dev, 0xa0, reg, 0x92, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, 0x02, 0x90, NULL, 0);	// <-read command
+    spca5xxRegRead(dev, 0xa1, 0x01, 0x0091, &retbyte, 1);	// read status
+    spca5xxRegRead(dev, 0xa1, 0x01, 0x0095, &retval[0], 1);	// read Lowbyte
+    spca5xxRegRead(dev, 0xa1, 0x01, 0x0096, &retval[1], 1);	// read Hightbyte
+    return ((retval[1] << 8) | retval[0]);
+}
+static __u8 zcxx_i2cWrite(struct usb_device *dev, __u8 reg, __u8 valL,
+			  __u8 valH)
+{
+    __u8 retbyte = 0;
+    spca5xxRegWrite(dev, 0xa0, reg, 0x92, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, valL, 0x93, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, valH, 0x94, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, 0x01, 0x90, NULL, 0);	// <-write command
+    spca5xxRegRead(dev, 0xa1, 0x01, 0x0091, &retbyte, 1);	// read status
+    return (retbyte);
+}
+static int zcxx_probeSensor(struct usb_spca50x *spca50x)
+{
+    int i, j;
+    __u8 retbyte = 0;
+    __u16 checkword = 0;
+   __u16 checkid = 0xffff;
+/* check i2c */
+/* check SIF */
+    for (i = 0; i < SIFTOT; i++) {
+        checkword = 0;
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0000, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, zcxxi2cSensorSIF[i][SensorId],
+			0x0010, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0001, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x03, 0x0012, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0012, NULL, 0);
+	wait_ms(2);
+	if (zcxxi2cSensorSIF[i][reg8d] == 0x8d){
+	    spca5xxRegWrite(spca50x->dev, 0xa0, zcxxi2cSensorSIF[i][val8d],
+			    0x008d, NULL, 0);
+	wait_ms(150);
+	checkword = ((zcxx_i2cRead(spca50x->dev,0x00) & 0x0f) << 4) 
+	               | ((zcxx_i2cRead(spca50x->dev,0x01) & 0xf0) >> 4 );
+	
+	    if (checkword == 0x07){
+	        spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0000, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x03, 0x003a, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x0c, 0x003b, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x08, 0x0038, NULL, 0);
+	    return zcxxi2cSensorSIF[i][SensorId];
+	    } 	    
+	}
+	retbyte =
+	    zcxx_i2cWrite(spca50x->dev, zcxxi2cSensorSIF[i][SensorReg1],
+			  zcxxi2cSensorSIF[i][valSreg1L],
+			  zcxxi2cSensorSIF[i][valSreg1H]);
+	wait_ms(2);
+	retbyte =
+	    (zcxx_i2cRead(spca50x->dev, zcxxi2cSensorSIF[i][SensorReg1])) &
+	    0xff;
+	wait_ms(2);
+	PDEBUG(1, "sensor answer1  %d ", retbyte);
+	if (retbyte != zcxxi2cSensorSIF[i][valSreg1L])
+	    continue;
+	if (zcxxi2cSensorSIF[i][SensorReg2] != 0xff) {
+	    retbyte =
+		zcxx_i2cWrite(spca50x->dev,
+			      zcxxi2cSensorSIF[i][SensorReg2],
+			      zcxxi2cSensorSIF[i][valSreg2L],
+			      zcxxi2cSensorSIF[i][valSreg2H]);
+	    retbyte =
+		(zcxx_i2cRead
+		 (spca50x->dev, zcxxi2cSensorSIF[i][SensorReg2])) & 0xff;
+	    PDEBUG(1, "sensor answer2  %d ", retbyte);
+	    if (retbyte == zcxxi2cSensorSIF[i][valSreg2L])
+		return zcxxi2cSensorSIF[i][SensorId];
+	}
+    }
+/* check VGA */
+    for (i = 0; i < VGATOT; i++) {
+	if ((zcxxi2cSensor[i][reg8d] == 0x8b)
+	    && (zcxxi2cSensor[i][val8d] == 0xa1)) {
+	    /* code for stephane sensor ov7630c */
+	    checkword = 0;
+	    spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0000, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0001, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0xa0, zcxxi2cSensor[i][SensorId],
+			    0x0010, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0xa0, zcxxi2cSensor[i][val8d],
+			    0x008b, NULL, 0);
+	    spca5xxRegWrite(spca50x->dev, 0xa0, 0x08, 0x008d, NULL, 0);
+	    wait_ms(150);
+	    spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0012, NULL, 0);
+	    retbyte =
+		zcxx_i2cWrite(spca50x->dev, zcxxi2cSensor[i][SensorReg1],
+			      zcxxi2cSensor[i][valSreg1L],
+			      zcxxi2cSensor[i][valSreg1H]);
+
+	    retbyte =
+		(zcxx_i2cRead(spca50x->dev, zcxxi2cSensor[i][SensorReg2]))
+		& 0xff;
+	    checkword = retbyte << 8;
+	    checkword |= ((zcxx_i2cRead(spca50x->dev, 0x0b)) & 0xff);
+	    if (checkword == 0x7631) {
+		PDEBUG(0, "sensor answervga  0x%04X ", checkword);
+		spca5xxRegWrite(spca50x->dev, 0xa0,
+				zcxxi2cSensor[i][SensorId], 0x0010, NULL,
+				0);
+		return zcxxi2cSensor[i][SensorId];
+	    }
+	    continue;
+	}
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0000, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, zcxxi2cSensor[i][SensorId],
+			0x0010, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0001, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x03, 0x0012, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0012, NULL, 0);
+	wait_ms(2);
+	if (zcxxi2cSensor[i][reg8d] == 0x8d)
+	    spca5xxRegWrite(spca50x->dev, 0xa0, zcxxi2cSensor[i][val8d],
+			    0x008d, NULL, 0);
+	retbyte =
+	    zcxx_i2cWrite(spca50x->dev, zcxxi2cSensor[i][SensorReg1],
+			  zcxxi2cSensor[i][valSreg1L],
+			  zcxxi2cSensor[i][valSreg1H]);
+	if (zcxxi2cSensor[i][SensorReg2] != 0xff) {
+	    retbyte =
+		zcxx_i2cWrite(spca50x->dev, zcxxi2cSensor[i][SensorReg2],
+			      zcxxi2cSensor[i][valSreg2L],
+			      zcxxi2cSensor[i][valSreg2H]);
+	    retbyte =
+		(zcxx_i2cRead(spca50x->dev, zcxxi2cSensor[i][SensorReg2]))
+		& 0xff;
+	} else {
+	checkid = (zcxx_i2cRead(spca50x->dev,0x00)) & 0xff;
+	PDEBUG(1, "check sensor id  0x%04X ", checkid);
+	    retbyte =
+		(zcxx_i2cRead(spca50x->dev, zcxxi2cSensor[i][SensorReg1]))
+		& 0xff;
+	if(checkid == 2) // Who is here, that is a surprised :)
+	        continue ;
+	}
+
+	PDEBUG(1, "sensor answervga  %d ", retbyte);
+	if (retbyte != 0)
+	    return zcxxi2cSensor[i][SensorId];
+    }
+/* check 3 wires bus */
+    i = 0;
+    while (zcxx3wrSensor[i][0]) {
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x02, 0x0010, NULL, 0);
+	spca5xxRegRead(spca50x->dev, 0xa1, 0x01, 0x0010, &retbyte, 1);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0000, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x00, 0x0010, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0001, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, zcxx3wrSensor[i][1],
+			zcxx3wrSensor[i][0], NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x03, 0x0012, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0012, NULL, 0);
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x05, 0x0012, NULL, 0);
+	for (j = 2; j < 5; j++) {
+	    if (zcxx3wrSensor[i][j] != 0xff) {
+		retbyte =
+		    (zcxx_i2cRead(spca50x->dev, zcxx3wrSensor[i][j])) &
+		    0xff;
+		if (retbyte != 0)
+		    return (i | 0x10);
+	    }
+	}
+	if (zcxx3wrSensor[i][1] == 0x91) {
+	    /* check Aurelien Jurgen sensor */
+	    checkword = 0;
+	    spca5xxRegWrite(spca50x->dev, 0xa0, 0x02, 0x0010, NULL, 0);
+	    spca5xxRegRead(spca50x->dev, 0xa1, 0x01, 0x000b, &retbyte, 1);
+	    checkword = retbyte << 8;
+	    spca5xxRegRead(spca50x->dev, 0xa1, 0x01, 0x000a, &retbyte, 1);
+	    checkword |= retbyte;
+	    PDEBUG(1, "sensor 3w Vga ??? 0x%04X ", (checkword & 0xffff));
+	    if (checkword == 0xc001 || checkword == 0xe001 || checkword == 0x8001) {
+		spca50x->chip_revision = checkword;
+		spca5xxRegRead(spca50x->dev, 0xa1, 0x01, 0x0010, &retbyte,
+			       1);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0000, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x0d, 0x003a, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x02, 0x003b, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x00, 0x0038, NULL, 0);
+		return 0x13;
+	    }
+
+	}
+	i++;
+    }
+    return (-1);
+}
+
+static __u16 zc3xxWriteVector(struct usb_spca50x *spca50x, __u16 data[][3])
+{
+    struct usb_device *dev = spca50x->dev;
+    int err = 0;
+    int i = 0;
+    __u8 buffread;
+    while (data[i][0]) {
+	if (data[i][0] == 0xa0) {
+	    /* write registers */
+	    spca5xxRegWrite(dev, data[i][0], data[i][1], data[i][2], NULL,
+			    0);
+	} else {
+	    /* read status */
+	    spca5xxRegRead(dev, data[i][0], data[i][1], data[i][2],
+			   &buffread, 1);
+	}
+	i++;
+	udelay(1000);
+    }
+
+    return err;
+}
+
+#define CLAMP(x) (unsigned char)(((x)>0xFF)?0xff:(((x)<1)?1:(x)))
+
+static __u8 Tgamma_default[16] =
+    { 0x13, 0x38, 0x59, 0x79, 0x92, 0xa7, 0xb9, 0xc8, 0xd4, 0xdf, 0xe7, 0xee, 0xf4, 0xf9, 0xfc, 0xff };
+static __u8 Tgradient_default[16] =
+    { 0x26, 0x22, 0x20, 0x1c, 0x16, 0x13, 0x10, 0x0d, 0x0b, 0x09, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02 };
+static __u8 Tgamma_VF0250[16] =
+    { 0x04, 0x16, 0x30, 0x4e, 0x68, 0x81, 0x98, 0xac, 0xbe, 0xcd, 0xda, 0xe4, 0xed, 0xf5, 0xfb, 0xff };
+static __u8 Tgradient_VF0250[16] =
+    { 0x00, 0x16, 0x1b, 0x1c, 0x19, 0x18, 0x15, 0x12, 0x10, 0x0d, 0x0b, 0x09, 0x08, 0x06, 0x05, 0x00 };
+static __u8 Tgamma_CS2102[16] =
+    { 0x24, 0x44, 0x64, 0x84, 0x9d, 0xb2, 0xc4, 0xd3, 0xe0, 0xeb, 0xf4, 0xff, 0xff, 0xff, 0xff ,0xff }; 
+static __u8 Tgradient_CS2102[16] = 
+    { 0x18, 0x20, 0x20, 0x1c, 0x16, 0x13, 0x10, 0x0e, 0x0b, 0x09, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01 };
+
+static __u16 zc3xx_getbrightness(struct usb_spca50x *spca50x)
+{
+    spca50x->brightness = 0x80 << 8;
+    spca50x->contrast = 0x80 << 8;
+    return spca50x->brightness;
+}
+static __u16 zc3xx_getcontrast(struct usb_spca50x *spca50x)
+{
+    return spca50x->contrast;
+}
+static void zc3xx_setbrightness(struct usb_spca50x *spca50x)
+{
+    __u8 brightness;
+    brightness = spca50x->brightness >> 8;
+    spca5xxRegWrite(spca50x->dev, 0xa0, brightness, 0x011d, NULL, 0);
+    if (brightness < 0x70) {
+	spca5xxRegWrite(spca50x->dev, 0xa0, brightness + 0x10, 0x018d,
+			NULL, 0);
+    } else {
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x80, 0x018d, NULL, 0);
+    }
+
+}
+static void zc3xx_setcontrast(struct usb_spca50x *spca50x)
+{
+
+    __u16 contrast;
+    __u8 *   Tgamma = Tgamma_default;
+    __u8 *   Tgradient = Tgradient_default;
+    int gm0 = 0;
+    int gr0 = 0;
+    int index = 0;
+    int i;
+
+    switch (spca50x->sensor) {
+     case SENSOR_TAS5130C_VF0250:
+       Tgamma = Tgamma_VF0250;
+       Tgradient = Tgradient_VF0250;
+     break;
+     case SENSOR_CS2102:
+       Tgamma = Tgamma_CS2102;
+       Tgradient = Tgradient_CS2102;
+     break;
+    }
+
+    /* now get the index of gamma table */
+    contrast = zc3xx_getcontrast(spca50x);
+    if ((index = contrast >> 13) > 6)
+	index = 6;
+    PDEBUG(2, "starting new table index %d ", index);
+    for (i = 0; i < 16; i++) {
+	gm0 = Tgamma[i] * index >> 2;
+	gr0 = Tgradient[i] * index >> 2;
+	spca5xxRegWrite(spca50x->dev, 0xa0, CLAMP(gm0), 0x0120 + i, NULL, 0);	//brightness
+	spca5xxRegWrite(spca50x->dev, 0xa0, CLAMP(gr0), 0x0130 + i, NULL, 0);	// contrast
+	//PDEBUG(0,"i %d gamma %d gradient %d",i ,Tgamma[i],Tgradient[i]);
+    }
+
+}
+
+
+
+static int zc3xx_init(struct usb_spca50x *spca50x)
+{
+    spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0000, NULL, 0);
+    return 0;
+}
+static void set_zc3xxVGA(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[VGA].width = 640;
+    spca50x->mode_cam[VGA].height = 480;
+    spca50x->mode_cam[VGA].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[VGA].pipe = 1023;
+    spca50x->mode_cam[VGA].method = 0;
+    spca50x->mode_cam[VGA].mode = 0;
+    spca50x->mode_cam[PAL].width = 384;
+    spca50x->mode_cam[PAL].height = 288;
+    spca50x->mode_cam[PAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[PAL].pipe = 1023;
+    spca50x->mode_cam[PAL].method = 1;
+    spca50x->mode_cam[PAL].mode = 0;
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 1;
+    spca50x->mode_cam[SIF].mode = 0;
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 0;
+    spca50x->mode_cam[CIF].mode = 1;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 1;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 1;
+    spca50x->mode_cam[QSIF].mode = 1;
+}
+static void set_zc3xxSIF(struct usb_spca50x *spca50x)
+{
+    memset(spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+    spca50x->mode_cam[SIF].width = 352;
+    spca50x->mode_cam[SIF].height = 288;
+    spca50x->mode_cam[SIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[SIF].pipe = 1023;
+    spca50x->mode_cam[SIF].method = 0;
+    spca50x->mode_cam[SIF].mode = 0;
+    spca50x->mode_cam[CIF].width = 320;
+    spca50x->mode_cam[CIF].height = 240;
+    spca50x->mode_cam[CIF].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[CIF].pipe = 1023;
+    spca50x->mode_cam[CIF].method = 1;
+    spca50x->mode_cam[CIF].mode = 0;
+    spca50x->mode_cam[QPAL].width = 192;
+    spca50x->mode_cam[QPAL].height = 144;
+    spca50x->mode_cam[QPAL].t_palette =
+	P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QPAL].pipe = 1023;
+    spca50x->mode_cam[QPAL].method = 1;
+    spca50x->mode_cam[QPAL].mode = 0;
+    spca50x->mode_cam[QSIF].width = 176;
+    spca50x->mode_cam[QSIF].height = 144;
+    spca50x->mode_cam[QSIF].t_palette =
+	P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+    spca50x->mode_cam[QSIF].pipe = 1023;
+    spca50x->mode_cam[QSIF].method = 0;
+    spca50x->mode_cam[QSIF].mode = 1;
+}
+
+static int zc3xx_config(struct usb_spca50x *spca50x)
+{
+
+    int sensor = 0;
+    __u8 bsensor = 0;
+    spca50x->qindex = 1;
+    PDEBUG(0, "Sensor ID:%d",spca50x->sensor);
+
+    sensor = zcxx_probeSensor(spca50x);
+    
+    switch (sensor) {
+    case -1:
+         if(spca50x->sensor == SENSOR_TAS5130C_VF0250) {
+            PDEBUG(0, "Find Sensor Tas5130 (VF0250)");
+	    set_zc3xxVGA(spca50x);
+        } else { 	
+	    PDEBUG(0, "Find Sensor UNKNOW_0 force Tas5130");
+	    spca50x->sensor = SENSOR_TAS5130CXX;
+	    set_zc3xxVGA(spca50x);
+	}
+	break;
+    case 0:
+	PDEBUG(0, "Find Sensor HV7131B");
+	spca50x->sensor = SENSOR_HV7131B;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 1:
+	PDEBUG(0, "Find Sensor SIF UNKNOW_1");
+	break;
+    case 0x02:
+	PDEBUG(0, "Find Sensor UNKNOW_2");
+	break;
+    case 0x04:
+	PDEBUG(0, "Find Sensor CS2102");
+	spca50x->sensor = SENSOR_CS2102;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 5:
+	PDEBUG(0, "Find Sensor SIF UNKNOW_5");
+	break;
+    case 0x06:
+	PDEBUG(0, "Find Sensor OV7630C");
+	spca50x->sensor = SENSOR_OV7630C;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 7:
+	PDEBUG(0, "Find Sensor SIF UNKNOW_7");
+	break;
+    case 0x08:
+	PDEBUG(0, "Find Sensor HDCS2020(b)");
+	spca50x->sensor = SENSOR_HDCS2020b;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 9:
+	PDEBUG(0, "Find Sensor SIF UNKNOW_9");
+	break;
+    case 0x0a:
+	PDEBUG(0, "Find Sensor PB0330");
+	spca50x->sensor = SENSOR_PB0330;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 0x0b:
+	PDEBUG(0, "Find Sensor SIF UNKNOW_b");
+	break;
+    case 0x0c:
+	PDEBUG(0, "Find Sensor ICM105T");
+	spca50x->sensor = SENSOR_ICM105A;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 0x0d:
+	PDEBUG(0, "Find Sensor SIF UNKNOW_d");
+	break;
+    case 0x0e:
+	PDEBUG(0, "Find Sensor PAS202BCB");
+	spca50x->sensor = SENSOR_HDCS2020;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 0x0f:
+	PDEBUG(0, "Find Sensor PAS106");
+	spca50x->sensor = SENSOR_PAS106;
+	set_zc3xxSIF(spca50x);
+	break;
+    case 0x10:
+	PDEBUG(0, "Find Sensor TAS5130");
+	spca50x->sensor = SENSOR_TAS5130CXX;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 0x11:
+	PDEBUG(0, "Find Sensor HV7131R(c)");
+	spca50x->sensor = SENSOR_HV7131C;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 0x12:
+	PDEBUG(0, "Find Sensor TAS5130");
+	spca50x->sensor = SENSOR_TAS5130CXX;
+	set_zc3xxVGA(spca50x);
+	break;
+    case 0x13:
+	PDEBUG(0, "Find Sensor MI0360");
+	spca50x->sensor = SENSOR_PB0330;
+	set_zc3xxVGA(spca50x);
+	break;
+    };
+
+    if ((sensor == 0x02) || (sensor == 0x01) || (sensor == 0x05)
+	|| (sensor == 0x07) || (sensor == 0x09) || (sensor == 0x0b)
+	|| (sensor == 0x0d)) {
+	PDEBUG(0,
+	       "Our Sensor is unknow at the moment please report mxhaard@free.fr ");
+	return -EINVAL;
+    }
+
+    if ((sensor == -1) || (sensor == 0x10) || (sensor == 0x12)) {
+	spca5xxRegWrite(spca50x->dev, 0xa0, 0x02, 0x0010, NULL, 0);
+	spca5xxRegRead(spca50x->dev, 0xa1, 0x01, 0x0010, &bsensor, 1);
+    } else {
+	spca5xxRegWrite(spca50x->dev, 0xa0, sensor & 0x0f, 0x0010, NULL, 0);
+	spca5xxRegRead(spca50x->dev, 0xa1, 0x01, 0x0010, &bsensor, 1);
+    }
+    /* switch the led off */
+    if( sensor == 0x06 || sensor == 0x11)
+      spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0000,NULL,0);
+
+    return 0;
+}
+static void zc3xx_setquality(struct usb_spca50x *spca50x)
+{
+    __u8 quality = 0;
+    __u8 frxt = 0x30;
+    quality = (spca50x->qindex) & 0x0f;
+    spca5xxRegWrite(spca50x->dev, 0xa0, quality, 0x0008, NULL, 0);
+    spca5xxRegWrite(spca50x->dev, 0xa0, frxt, 0x0007, NULL, 0);
+    switch (quality){
+    case 0:
+    case 1:
+    case 2:
+    frxt = 0xff;
+    break;
+    case 3:
+    frxt = 0xf0;
+    break;
+    case 4:
+    frxt = 0xe0;
+    break;
+    case 5:
+    frxt = 0x20;
+    break;
+    }
+    spca5xxRegWrite(spca50x->dev, 0xa0, frxt, 0x0018, NULL, 0);
+    
+}
+static void zc3xx_setAutobright(struct usb_spca50x *spca50x)
+{
+    __u8 autoval = 0;
+    if (spca50x->autoexpo)
+	autoval = 0x42;
+    else
+	autoval = 0x02;
+	spca5xxRegWrite(spca50x->dev, 0xa0, autoval, 0x0180, NULL, 0);
+}
+static void zc3xx_start(struct usb_spca50x *spca50x)
+{
+    int err = 0;
+    /* Assume start use the good resolution from spca50x->mode */
+    //err = zcxx_probeSensor(spca50x);
+    switch (spca50x->sensor) {
+    case SENSOR_TAS5130CXX:
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, tas5130cxx_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, tas5130cxx_scale_data);
+	}
+	break;
+    case SENSOR_TAS5130C_VF0250: // Firmware version 0250
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, tas5130c_vf0250_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, tas5130c_vf0250_scale_data);
+	}
+	break;
+    case SENSOR_ICM105A:
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, icm105axx_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, icm105axx_scale_data);
+	}
+	break;
+    case SENSOR_HDCS2020:
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, hdcs2020xx_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, hdcs2020xx_scale_data);
+	}
+	break;
+    case SENSOR_HDCS2020b:
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, hdcs2020xb_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, hdcs2020xb_scale_data);
+	}
+	break;
+    case SENSOR_HV7131B:
+    err = zcxx_probeSensor(spca50x);
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, hv7131bxx_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, hv7131bxx_scale_data);
+	}
+	break;
+    case SENSOR_HV7131C:	//HV7131R
+    err = zcxx_probeSensor(spca50x);
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, hv7131cxx_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, hv7131cxx_scale_data);
+	}
+	break;
+    case SENSOR_PB0330:
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    if ((spca50x->chip_revision == 0xc001)
+		|| (spca50x->chip_revision == 0xe001)
+		|| (spca50x->chip_revision == 0x8001))
+		err = zc3xxWriteVector(spca50x, pb03303x_start_data);
+	    else
+		err = zc3xxWriteVector(spca50x, pb0330xx_start_data);
+	} else {
+	    /* 640x480 */
+	    if ((spca50x->chip_revision == 0xc001)
+		|| (spca50x->chip_revision == 0xe001)
+		|| (spca50x->chip_revision == 0x8001))
+		err = zc3xxWriteVector(spca50x, pb03303x_scale_data);
+	    else
+		err = zc3xxWriteVector(spca50x, pb0330xx_scale_data);
+	}
+	break;
+    case SENSOR_CS2102:
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, cs2102_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, cs2102_scale_data);
+	}
+	break;
+    case SENSOR_OV7630C:
+	if (spca50x->mode) {
+	    /* 320x240 */
+	    err = zc3xxWriteVector(spca50x, ov7630c_start_data);
+	} else {
+	    /* 640x480 */
+	    err = zc3xxWriteVector(spca50x, ov7630c_scale_data);
+	}
+	break;
+    case SENSOR_PAS106:
+    err= zc3xxWriteVector(spca50x, pas106b_com_data);
+	if (spca50x->mode) {
+	    /* 176x144 */
+	    err = zc3xxWriteVector(spca50x, pas106b_start_data);	   
+	} else {
+	    /* 352x288 */
+	    err = zc3xxWriteVector(spca50x, pas106b_scale_data);   
+	}
+	break;
+    }
+    zc3xx_setbrightness(spca50x);
+    zc3xx_setquality(spca50x);
+    zc3xx_setAutobright(spca50x);
+}
+
+static void zc3xx_stop0(struct usb_spca50x *spca50x)
+{
+// Nothing todo 
+    switch (spca50x->sensor) {
+     case SENSOR_PAS106:
+                spca5xxRegWrite(spca50x->dev, 0xa0, 0x01, 0x0000, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x03, 0x003a, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x0c, 0x003b, NULL, 0);
+		spca5xxRegWrite(spca50x->dev, 0xa0, 0x08, 0x0038, NULL, 0);
+     break;
+    }
+}
+
+static void zc3xx_shutdown(struct usb_spca50x *spca50x)
+{
+    struct usb_device *dev = spca50x->dev;
+    __u8 buffread;
+    spca5xxRegRead(dev, 0xa1, 0x01, 0x0180, &buffread, 1);
+    spca5xxRegWrite(dev, 0xa0, 0x00, 0x0180, NULL, 0);
+    spca5xxRegWrite(dev, 0xa0, 0x01, 0x0000, NULL, 0);
+}
+
+static __u16 zc3xx_getcolors(struct usb_spca50x *spca50x)
+{
+//Nothing
+return spca50x->colour;
+}
+
+static void zc3xx_setcolors(struct usb_spca50x *spca50x)
+{
+//Nothing
+ spca50x->colour = 0;
+}
+
+static int zc3xx_sofdetect(struct usb_spca50x *spca50x,struct spca50x_frame *frame, unsigned char *cdata,int *iPix, int seqnum, int *datalength)
+{
+		
+		if (cdata[0] == 0xFF && cdata[1] == 0xD8) {
+		    *iPix = 2;	//18 remove 0xff 0xd8;
+		    *datalength -= *iPix;
+		    return 0;
+		    PDEBUG(5,
+			   "Zc301 header packet found datalength %d !!",
+			   *datalength );
+		} 
+		*iPix = 0;
+		return (seqnum +1);
+}
+ 
+static void zc3xx_set50HZ(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {
+      case SENSOR_TAS5130C_VF0250:
+ 	  zc3xxWriteVector(spca50x, tas5130c_vf0250_50HZ);
+      break;
+      case SENSOR_TAS5130CXX:
+ 	  zc3xxWriteVector(spca50x, tas5130cxx_50HZ);
+      case SENSOR_PB0330:
+ 	  zc3xxWriteVector(spca50x, pb0330_50HZ);
+      break;
+      case SENSOR_PAS106:
+ 	  zc3xxWriteVector(spca50x, pas106b_50HZ);
+      break;
+      case SENSOR_ICM105A:
+ 	  zc3xxWriteVector(spca50x, icm105a_50HZ);
+      break;
+      case SENSOR_HDCS2020b:
+ 	  zc3xxWriteVector(spca50x, hdcs2020b_50HZ);
+      break;
+      case SENSOR_CS2102:
+ 	  zc3xxWriteVector(spca50x, cs2102_50HZ);
+      break;
+      default:     
+      break;
+     }
+ }
+ 
+static void zc3xx_set60HZ(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {
+      case SENSOR_TAS5130C_VF0250:
+ 	  zc3xxWriteVector(spca50x, tas5130c_vf0250_60HZ);
+      break;
+      case SENSOR_TAS5130CXX:
+ 	  zc3xxWriteVector(spca50x, tas5130cxx_60HZ);
+      break;
+      case SENSOR_PB0330:
+ 	  zc3xxWriteVector(spca50x, pb0330_60HZ);
+      break;
+      case SENSOR_PAS106:
+ 	  zc3xxWriteVector(spca50x, pas106b_60HZ);
+      break;
+      case SENSOR_ICM105A:
+ 	  zc3xxWriteVector(spca50x, icm105a_60HZ);
+      break;
+      case SENSOR_HDCS2020b:
+ 	  zc3xxWriteVector(spca50x, hdcs2020b_60HZ);
+      break;
+      case SENSOR_CS2102:
+ 	  zc3xxWriteVector(spca50x, cs2102_60HZ);
+      break;
+      default:     
+      break;
+     }
+ }
+ 
+static void zc3xx_set50HZScale(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {     
+      case SENSOR_TAS5130C_VF0250:
+ 	  zc3xxWriteVector(spca50x, tas5130c_vf0250_50HZScale);
+      break;
+      case SENSOR_TAS5130CXX:
+ 	  zc3xxWriteVector(spca50x, tas5130cxx_50HZScale);
+      break;
+      case SENSOR_PB0330:
+ 	  zc3xxWriteVector(spca50x, pb0330_50HZScale);
+      break;
+      case SENSOR_PAS106:
+ 	  zc3xxWriteVector(spca50x, pas106b_50HZ);
+      break;
+      case SENSOR_ICM105A:
+ 	  zc3xxWriteVector(spca50x, icm105a_50HZScale);
+      break;
+      case SENSOR_HDCS2020b:
+ 	  zc3xxWriteVector(spca50x, hdcs2020b_50HZScale);
+      break;
+      case SENSOR_CS2102:
+ 	  zc3xxWriteVector(spca50x, cs2102_50HZScale);
+      break;
+      default:
+      break;
+     }
+ 
+ }
+ 
+static void zc3xx_set60HZScale(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {
+      case SENSOR_TAS5130C_VF0250:
+ 	  zc3xxWriteVector(spca50x, tas5130c_vf0250_60HZScale);
+      break;
+      case SENSOR_TAS5130CXX:
+ 	  zc3xxWriteVector(spca50x, tas5130cxx_60HZScale);
+      break;
+      case SENSOR_PB0330:
+ 	  zc3xxWriteVector(spca50x, pb0330_60HZScale);
+      break;
+      case SENSOR_PAS106:
+ 	  zc3xxWriteVector(spca50x, pas106b_60HZ);
+      break;
+      case SENSOR_ICM105A:
+ 	  zc3xxWriteVector(spca50x, icm105a_60HZScale);
+      break;
+      case SENSOR_HDCS2020b:
+ 	  zc3xxWriteVector(spca50x, hdcs2020b_60HZScale);
+      break;
+      case SENSOR_CS2102:
+ 	  zc3xxWriteVector(spca50x, cs2102_60HZScale);
+      break;
+      default:
+      break;
+     }
+ 
+ }
+ 
+static void zc3xx_setNoFliker(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {
+      case SENSOR_TAS5130C_VF0250:
+ 	  zc3xxWriteVector(spca50x, tas5130c_vf0250_NoFliker);
+      break;
+      case SENSOR_TAS5130CXX:
+ 	  zc3xxWriteVector(spca50x, tas5130cxx_NoFliker);
+      break;
+      case SENSOR_PB0330:
+ 	  zc3xxWriteVector(spca50x, pb0330_NoFliker);
+      break;
+      case SENSOR_PAS106:
+ 	  zc3xxWriteVector(spca50x, pas106b_NoFliker);
+      break;
+      case SENSOR_ICM105A:
+ 	  zc3xxWriteVector(spca50x, icm105a_NoFliker);
+      break;
+      case SENSOR_HDCS2020b:
+ 	  zc3xxWriteVector(spca50x, hdcs2020b_NoFliker);
+      break;
+      case SENSOR_CS2102:
+ 	  zc3xxWriteVector(spca50x, cs2102_NoFliker);
+      break;
+      default:
+      break;
+     }
+ 
+ }
+ 
+static void zc3xx_setNoFlikerScale(struct usb_spca50x *spca50x) {
+     switch (spca50x->sensor) {
+      case SENSOR_TAS5130C_VF0250:
+ 	  zc3xxWriteVector(spca50x, tas5130c_vf0250_NoFlikerScale);
+      break;
+      case SENSOR_TAS5130CXX:
+ 	  zc3xxWriteVector(spca50x, tas5130cxx_NoFlikerScale);
+      break;
+      case SENSOR_PB0330:
+ 	  zc3xxWriteVector(spca50x, pb0330_NoFlikerScale);
+      break;
+      case SENSOR_PAS106:
+ 	  zc3xxWriteVector(spca50x, pas106b_NoFliker);
+      break;
+      case SENSOR_ICM105A:
+ 	  zc3xxWriteVector(spca50x, icm105a_NoFlikerScale);
+      break;
+      case SENSOR_HDCS2020b:
+ 	  zc3xxWriteVector(spca50x, hdcs2020b_NoFlikerScale);
+      break;
+      case SENSOR_CS2102:
+ 	  zc3xxWriteVector(spca50x, cs2102_NoFlikerScale);
+      break;
+      default:
+      break;
+     }
+ }
+#endif				// ZC3XXUSB_H
diff -ruN linux-2.6.21/drivers/media/video/gspca/decoder/.gspcadecoder.o.cmd linux-2.6.21-gspca/drivers/media/video/gspca/decoder/.gspcadecoder.o.cmd
--- linux-2.6.21/drivers/media/video/gspca/decoder/.gspcadecoder.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/decoder/.gspcadecoder.o.cmd	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,460 @@
+cmd_drivers/media/video/gspca/decoder/gspcadecoder.o := gcc -m32 -Wp,-MD,drivers/media/video/gspca/decoder/.gspcadecoder.o.d  -nostdinc -isystem /usr/lib/gcc/i686-pc-linux-gnu/4.1.1/include -D__KERNEL__ -Iinclude  -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -O2 -pipe -msoft-float -mregparm=3 -freg-struct-return -mpreferred-stack-boundary=2  -march=i686 -mtune=pentium4 -ffreestanding -maccumulate-outgoing-args -DCONFIG_AS_CFI=1  -Iinclude/asm-i386/mach-default -fomit-frame-pointer  -fno-stack-protector -Wdeclaration-after-statement -Wno-pointer-sign -DGSPCA_ENABLE_COMPRESSION -DVID_HARDWARE_GSPCA=0xFF -DGSPCA_VERSION=\"01.00.18\"  -DMODULE -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(gspcadecoder)"  -D"KBUILD_MODNAME=KBUILD_STR(gspca)" -c -o drivers/media/video/gspca/decoder/gspcadecoder.o drivers/media/video/gspca/decoder/gspcadecoder.c
+
+deps_drivers/media/video/gspca/decoder/gspcadecoder.o := \
+  drivers/media/video/gspca/decoder/gspcadecoder.c \
+  include/linux/string.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/enable/must/check.h) \
+  include/linux/compiler-gcc4.h \
+    $(wildcard include/config/forced/inlining.h) \
+  include/linux/compiler-gcc.h \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbd.h) \
+    $(wildcard include/config/lsf.h) \
+    $(wildcard include/config/resources/64bit.h) \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/asm/posix_types.h \
+  include/asm/types.h \
+    $(wildcard include/config/highmem64g.h) \
+  include/asm/string.h \
+    $(wildcard include/config/x86/use/3dnow.h) \
+  drivers/media/video/gspca/decoder/gspcadecoder.h \
+  drivers/media/video/gspca/decoder/../gspca.h \
+  include/asm/uaccess.h \
+    $(wildcard include/config/x86/intel/usercopy.h) \
+    $(wildcard include/config/x86/wp/works/ok.h) \
+  include/linux/errno.h \
+  include/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/thread_info.h \
+  include/linux/bitops.h \
+  include/asm/bitops.h \
+  include/asm/alternative.h \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/paravirt.h) \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/ext2-non-atomic.h \
+  include/asm-generic/bitops/le.h \
+  include/asm/byteorder.h \
+    $(wildcard include/config/x86/bswap.h) \
+  include/linux/byteorder/little_endian.h \
+  include/linux/byteorder/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/minix.h \
+  include/asm/thread_info.h \
+    $(wildcard include/config/4kstacks.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+  include/asm/page.h \
+    $(wildcard include/config/x86/pae.h) \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/highmem4g.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/compat/vdso.h) \
+  include/asm-generic/pgtable-nopmd.h \
+  include/asm-generic/pgtable-nopud.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem.h) \
+    $(wildcard include/config/out/of/line/pfn/to/page.h) \
+  include/asm-generic/page.h \
+  include/asm/processor.h \
+    $(wildcard include/config/x86/ht.h) \
+    $(wildcard include/config/mk8.h) \
+    $(wildcard include/config/mk7.h) \
+  include/asm/vm86.h \
+    $(wildcard include/config/vm86.h) \
+  include/asm/ptrace.h \
+  include/asm/ptrace-abi.h \
+  include/asm/segment.h \
+  include/asm/math_emu.h \
+  include/asm/sigcontext.h \
+  include/asm/cpufeature.h \
+  include/asm/msr.h \
+  include/asm/system.h \
+    $(wildcard include/config/x86/cmpxchg64.h) \
+    $(wildcard include/config/x86/cmpxchg.h) \
+    $(wildcard include/config/x86/oostore.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/spinlock/sleep.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/numa.h) \
+  /usr/lib/gcc/i686-pc-linux-gnu/4.1.1/include/stdarg.h \
+  include/linux/linkage.h \
+  include/asm/linkage.h \
+    $(wildcard include/config/x86/alignment/16.h) \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+    $(wildcard include/config/x86.h) \
+  include/asm/irqflags.h \
+  include/linux/cache.h \
+  include/asm/cache.h \
+    $(wildcard include/config/x86/l1/cache/shift.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/cpumask.h \
+    $(wildcard include/config/hotplug/cpu.h) \
+  include/linux/bitmap.h \
+  include/linux/init.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/hotplug.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/acpi/hotplug/memory.h) \
+  include/linux/prefetch.h \
+  include/linux/videodev.h \
+    $(wildcard include/config/video/v4l1/compat.h) \
+  include/linux/videodev2.h \
+    $(wildcard include/config/video/adv/debug.h) \
+  include/linux/time.h \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+    $(wildcard include/config/prove/locking.h) \
+  include/asm/spinlock_types.h \
+  include/asm/spinlock.h \
+    $(wildcard include/config/x86/ppro/fence.h) \
+  include/asm/atomic.h \
+    $(wildcard include/config/m386.h) \
+  include/asm-generic/atomic.h \
+  include/asm/rwlock.h \
+  include/linux/spinlock_api_smp.h \
+  include/linux/smp_lock.h \
+    $(wildcard include/config/lock/kernel.h) \
+    $(wildcard include/config/preempt/bkl.h) \
+  include/linux/sched.h \
+    $(wildcard include/config/detect/softlockup.h) \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/debug/mutexes.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/compat.h) \
+    $(wildcard include/config/fault/injection.h) \
+  include/linux/auxvec.h \
+  include/asm/auxvec.h \
+  include/linux/rbtree.h \
+  include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/capability.h \
+  include/asm/current.h \
+  include/asm/pda.h \
+  include/linux/timex.h \
+    $(wildcard include/config/time/interpolation.h) \
+    $(wildcard include/config/no/hz.h) \
+  include/asm/timex.h \
+    $(wildcard include/config/x86/elan.h) \
+  include/asm/tsc.h \
+    $(wildcard include/config/x86/tsc.h) \
+    $(wildcard include/config/x86/generic.h) \
+  include/linux/jiffies.h \
+  include/linux/calc64.h \
+  include/asm/div64.h \
+  include/linux/nodemask.h \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/asm/semaphore.h \
+  include/linux/wait.h \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/asm/rwsem.h \
+  include/asm/mmu.h \
+  include/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/smp.h \
+  include/asm/smp.h \
+    $(wildcard include/config/x86/local/apic.h) \
+    $(wildcard include/config/x86/io/apic.h) \
+  include/asm/fixmap.h \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/x86/visws/apic.h) \
+    $(wildcard include/config/x86/f00f/bug.h) \
+    $(wildcard include/config/x86/cyclone/timer.h) \
+    $(wildcard include/config/acpi.h) \
+    $(wildcard include/config/pci/mmconfig.h) \
+  include/asm/acpi.h \
+    $(wildcard include/config/acpi/sleep.h) \
+  include/acpi/pdc_intel.h \
+  include/asm/apicdef.h \
+  include/asm/kmap_types.h \
+    $(wildcard include/config/debug/highmem.h) \
+  include/asm/mpspec.h \
+  include/asm/mpspec_def.h \
+  include/asm-i386/mach-default/mach_mpspec.h \
+  include/asm/io_apic.h \
+  include/asm/apic.h \
+    $(wildcard include/config/x86/good/apic.h) \
+  include/linux/pm.h \
+    $(wildcard include/config/software/suspend.h) \
+    $(wildcard include/config/pm.h) \
+  include/asm-i386/mach-default/mach_apicdef.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+    $(wildcard include/config/ipc/ns.h) \
+  include/asm/ipcbuf.h \
+  include/linux/kref.h \
+  include/asm/sembuf.h \
+  include/linux/signal.h \
+  include/asm/signal.h \
+  include/asm-generic/signal.h \
+  include/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/securebits.h \
+  include/linux/fs_struct.h \
+  include/linux/completion.h \
+  include/linux/pid.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/classic/rcu.h) \
+  include/linux/percpu.h \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/slab.h) \
+    $(wildcard include/config/debug/slab.h) \
+  include/linux/gfp.h \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/arch/populates/node/map.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+  include/linux/notifier.h \
+  include/linux/mutex.h \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/asm/topology.h \
+  include/asm-generic/topology.h \
+  include/asm/sparsemem.h \
+  include/linux/slab_def.h \
+  include/linux/kmalloc_sizes.h \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/large/allocs.h) \
+  include/linux/rcupreempt.h \
+    $(wildcard include/config/rcu/trace.h) \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/asm/seccomp.h \
+  include/linux/unistd.h \
+  include/asm/unistd.h \
+  include/linux/futex.h \
+    $(wildcard include/config/futex.h) \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/param.h \
+  include/linux/resource.h \
+  include/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/aio.h \
+  include/linux/workqueue.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  include/linux/sysdev.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/usb.h \
+    $(wildcard include/config/usb/mon.h) \
+    $(wildcard include/config/usb/suspend.h) \
+  include/linux/mod_devicetable.h \
+  include/linux/usb/ch9.h \
+    $(wildcard include/config/size.h) \
+    $(wildcard include/config/att/one.h) \
+    $(wildcard include/config/att/selfpower.h) \
+    $(wildcard include/config/att/wakeup.h) \
+    $(wildcard include/config/att/battery.h) \
+  include/linux/delay.h \
+  include/asm/delay.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/generic/irq/probe.h) \
+    $(wildcard include/config/proc/fs.h) \
+  include/linux/irqreturn.h \
+  include/linux/hardirq.h \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+  include/asm/hardirq.h \
+  include/linux/irq.h \
+    $(wildcard include/config/s390.h) \
+    $(wildcard include/config/irq/per/cpu.h) \
+    $(wildcard include/config/irq/release/method.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+    $(wildcard include/config/irqbalance.h) \
+    $(wildcard include/config/auto/irq/affinity.h) \
+    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
+  include/asm/irq.h \
+  include/asm-i386/mach-default/irq_vectors.h \
+  include/asm-i386/mach-default/irq_vectors_limits.h \
+  include/asm/irq_regs.h \
+  include/asm/hw_irq.h \
+  include/linux/profile.h \
+    $(wildcard include/config/profiling.h) \
+  include/asm/sections.h \
+  include/asm-generic/sections.h \
+  include/linux/irq_cpustat.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/module.h \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/kallsyms.h) \
+  include/linux/stat.h \
+  include/asm/stat.h \
+  include/linux/kmod.h \
+    $(wildcard include/config/kmod.h) \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  include/asm/elf.h \
+  include/asm/user.h \
+  include/linux/utsname.h \
+    $(wildcard include/config/uts/ns.h) \
+  include/linux/nsproxy.h \
+  include/asm/desc.h \
+  include/asm/ldt.h \
+  include/linux/moduleparam.h \
+  include/asm/local.h \
+  include/asm/module.h \
+    $(wildcard include/config/m486.h) \
+    $(wildcard include/config/m586.h) \
+    $(wildcard include/config/m586tsc.h) \
+    $(wildcard include/config/m586mmx.h) \
+    $(wildcard include/config/mcore2.h) \
+    $(wildcard include/config/m686.h) \
+    $(wildcard include/config/mpentiumii.h) \
+    $(wildcard include/config/mpentiumiii.h) \
+    $(wildcard include/config/mpentiumm.h) \
+    $(wildcard include/config/mpentium4.h) \
+    $(wildcard include/config/mk6.h) \
+    $(wildcard include/config/mcrusoe.h) \
+    $(wildcard include/config/mefficeon.h) \
+    $(wildcard include/config/mwinchipc6.h) \
+    $(wildcard include/config/mwinchip2.h) \
+    $(wildcard include/config/mwinchip3d.h) \
+    $(wildcard include/config/mcyrixiii.h) \
+    $(wildcard include/config/mviac3/2.h) \
+    $(wildcard include/config/mgeodegx1.h) \
+    $(wildcard include/config/mgeode/lx.h) \
+  include/asm/device.h \
+  include/linux/fs.h \
+    $(wildcard include/config/dnotify.h) \
+    $(wildcard include/config/quota.h) \
+    $(wildcard include/config/inotify.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/adaptive/readahead.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/fs/xip.h) \
+    $(wildcard include/config/migration.h) \
+  include/linux/limits.h \
+  include/linux/ioctl.h \
+  include/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/linux/kdev_t.h \
+  include/linux/dcache.h \
+  include/linux/namei.h \
+  include/linux/radix-tree.h \
+  include/linux/prio_tree.h \
+  include/linux/quota.h \
+  include/linux/dqblk_xfs.h \
+  include/linux/dqblk_v1.h \
+  include/linux/dqblk_v2.h \
+  include/linux/nfs_fs_i.h \
+  include/linux/nfs.h \
+  include/linux/sunrpc/msg_prot.h \
+  include/linux/fcntl.h \
+  include/asm/fcntl.h \
+  include/asm-generic/fcntl.h \
+    $(wildcard include/config/64bit.h) \
+  include/linux/err.h \
+  include/linux/version.h \
+  include/media/v4l2-common.h \
+  include/media/v4l2-dev.h \
+  include/linux/poll.h \
+  include/asm/poll.h \
+  include/linux/mm.h \
+    $(wildcard include/config/sysctl.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/shmem.h) \
+    $(wildcard include/config/debug/readahead.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/debug/pagealloc.h) \
+  include/linux/debug_locks.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/backing-dev.h \
+  include/linux/mm_types.h \
+  include/asm/pgtable.h \
+    $(wildcard include/config/highpte.h) \
+  include/asm/paravirt.h \
+  include/asm/pgtable-2level-defs.h \
+  include/asm/pgtable-2level.h \
+  include/asm-generic/pgtable.h \
+  include/linux/page-flags.h \
+    $(wildcard include/config/swap.h) \
+  include/linux/vmstat.h \
+    $(wildcard include/config/vm/event/counters.h) \
+  drivers/media/video/gspca/decoder/../utils/spcagamma.h \
+
+drivers/media/video/gspca/decoder/gspcadecoder.o: $(deps_drivers/media/video/gspca/decoder/gspcadecoder.o)
+
+$(deps_drivers/media/video/gspca/decoder/gspcadecoder.o):
diff -ruN linux-2.6.21/drivers/media/video/gspca/decoder/gspcadecoder.c linux-2.6.21-gspca/drivers/media/video/gspca/decoder/gspcadecoder.c
--- linux-2.6.21/drivers/media/video/gspca/decoder/gspcadecoder.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/decoder/gspcadecoder.c	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,4435 @@
+/*******************************************************************************
+#	 	spcadecoder: Generic decoder for various input stream yyuv	#
+# yuyv yuvy jpeg411 jpeg422 bayer rggb with gamma correct			#
+# and various output palette rgb16 rgb24 rgb32 yuv420p				#
+# various output size with crop feature						#
+# 		Copyright (C) 2003 2004 2005 Michel Xhaard			#
+# 		mxhaard@magic.fr						#
+# 		Sonix Decompressor by Bertrik.Sikken. (C) 2004			#
+# 		Pixart Decompressor by Bertrik.Sikken. Thomas Kaiser (C) 2005	#
+# 		Spca561decoder (C) 2005 Andrzej Szombierski [qq@kuku.eu.org]	#
+# This program is free software; you can redistribute it and/or modify		#
+# it under the terms of the GNU General Public License as published by		#
+# the Free Software Foundation; either version 2 of the License, or		#
+# (at your option) any later version.						#
+#										#
+# This program is distributed in the hope that it will be useful,		#
+# but WITHOUT ANY WARRANTY; without even the implied warranty of		#
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the			#
+# GNU General Public License for more details.					#
+#										#
+# You should have received a copy of the GNU General Public License		#
+# along with this program; if not, write to the Free Software			#
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA	#
+********************************************************************************/
+
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#else				/* __KERNEL__ */
+#include <linux/string.h>
+#endif				/* __KERNEL__ */
+
+
+#include "gspcadecoder.h"
+#include "../utils/spcagamma.h"
+
+#define ISHIFT 11
+
+#define IFIX(a) ((long)((a) * (1 << ISHIFT) + .5))
+#define IMULT(a, b) (((a) * (b)) >> ISHIFT)
+#define ITOINT(a) ((a) >> ISHIFT)
+
+/* special markers */
+#define M_BADHUFF	-1
+
+
+#define ERR_NO_SOI 1
+#define ERR_NOT_8BIT 2
+#define ERR_HEIGHT_MISMATCH 3
+#define ERR_WIDTH_MISMATCH 4
+#define ERR_BAD_WIDTH_OR_HEIGHT 5
+#define ERR_TOO_MANY_COMPPS 6
+#define ERR_ILLEGAL_HV 7
+#define ERR_QUANT_TABLE_SELECTOR 8
+#define ERR_NOT_YCBCR_221111 9
+#define ERR_UNKNOWN_CID_IN_SCAN 10
+#define ERR_NOT_SEQUENTIAL_DCT 11
+#define ERR_WRONG_MARKER 12
+#define ERR_NO_EOI 13
+#define ERR_BAD_TABLES 14
+#define ERR_DEPTH_MISMATCH 15
+#define ERR_CORRUPTFRAME 16
+
+#define JPEGHEADER_LENGTH 589
+
+const unsigned char JPEGHeader[JPEGHEADER_LENGTH] = {
+    0xff, 0xd8, 0xff, 0xdb, 0x00, 0x84, 0x00, 0x06, 0x04, 0x05, 0x06,
+    0x05, 0x04, 0x06, 0x06, 0x05,
+    0x06, 0x07, 0x07, 0x06, 0x08, 0x0a, 0x10, 0x0a, 0x0a, 0x09, 0x09,
+    0x0a, 0x14, 0x0e, 0x0f, 0x0c,
+    0x10, 0x17, 0x14, 0x18, 0x18, 0x17, 0x14, 0x16, 0x16, 0x1a, 0x1d,
+    0x25, 0x1f, 0x1a, 0x1b, 0x23,
+    0x1c, 0x16, 0x16, 0x20, 0x2c, 0x20, 0x23, 0x26, 0x27, 0x29, 0x2a,
+    0x29, 0x19, 0x1f, 0x2d, 0x30,
+    0x2d, 0x28, 0x30, 0x25, 0x28, 0x29, 0x28, 0x01, 0x07, 0x07, 0x07,
+    0x0a, 0x08, 0x0a, 0x13, 0x0a,
+    0x0a, 0x13, 0x28, 0x1a, 0x16, 0x1a, 0x28, 0x28, 0x28, 0x28, 0x28,
+    0x28, 0x28, 0x28, 0x28, 0x28,
+    0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+    0x28, 0x28, 0x28, 0x28, 0x28,
+    0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+    0x28, 0x28, 0x28, 0x28, 0x28,
+    0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0xff, 0xc4, 0x01,
+    0xa2, 0x00, 0x00, 0x01, 0x05,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x01, 0x02,
+    0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x01, 0x00,
+    0x03, 0x01, 0x01, 0x01, 0x01,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x01, 0x02, 0x03, 0x04, 0x05,
+    0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x10, 0x00, 0x02, 0x01, 0x03,
+    0x03, 0x02, 0x04, 0x03, 0x05,
+    0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01, 0x02, 0x03, 0x00,
+    0x04, 0x11, 0x05, 0x12, 0x21,
+    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32,
+    0x81, 0x91, 0xa1, 0x08, 0x23,
+    0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72,
+    0x82, 0x09, 0x0a, 0x16, 0x17,
+    0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35,
+    0x36, 0x37, 0x38, 0x39, 0x3a,
+    0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55,
+    0x56, 0x57, 0x58, 0x59, 0x5a,
+    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75,
+    0x76, 0x77, 0x78, 0x79, 0x7a,
+    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94,
+    0x95, 0x96, 0x97, 0x98, 0x99,
+    0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2,
+    0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
+    0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9,
+    0xca, 0xd2, 0xd3, 0xd4, 0xd5,
+    0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
+    0xe7, 0xe8, 0xe9, 0xea, 0xf1,
+    0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0x11, 0x00,
+    0x02, 0x01, 0x02, 0x04, 0x04,
+    0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00,
+    0x01, 0x02, 0x03, 0x11, 0x04,
+    0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,
+    0x22, 0x32, 0x81, 0x08, 0x14,
+    0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15,
+    0x62, 0x72, 0xd1, 0x0a, 0x16,
+    0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27,
+    0x28, 0x29, 0x2a, 0x35, 0x36,
+    0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+    0x4a, 0x53, 0x54, 0x55, 0x56,
+    0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+    0x6a, 0x73, 0x74, 0x75, 0x76,
+    0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
+    0x89, 0x8a, 0x92, 0x93, 0x94,
+    0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
+    0xa7, 0xa8, 0xa9, 0xaa, 0xb2,
+    0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4,
+    0xc5, 0xc6, 0xc7, 0xc8, 0xc9,
+    0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2,
+    0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
+    0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
+    0xfa, 0xff, 0xc0, 0x00, 0x11,
+    0x08, 0x01, 0xe0, 0x02, 0x80, 0x03, 0x01, 0x21, 0x00, 0x02, 0x11,
+    0x01, 0x03, 0x11, 0x01, 0xff,
+    0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00,
+    0x3f, 0x00
+};
+
+#define GSMART_JPG_HUFFMAN_TABLE_LENGTH 0x1A0
+
+const unsigned char GsmartJPEGHuffmanTable[GSMART_JPG_HUFFMAN_TABLE_LENGTH]
+    = {
+    0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+    0x0A, 0x0B, 0x01, 0x00, 0x03,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x01,
+    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10,
+    0x00, 0x02, 0x01, 0x03, 0x03,
+    0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D,
+    0x01, 0x02, 0x03, 0x00, 0x04,
+    0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
+    0x22, 0x71, 0x14, 0x32, 0x81,
+    0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0,
+    0x24, 0x33, 0x62, 0x72, 0x82,
+    0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
+    0x29, 0x2A, 0x34, 0x35, 0x36,
+    0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+    0x4A, 0x53, 0x54, 0x55, 0x56,
+    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+    0x6A, 0x73, 0x74, 0x75, 0x76,
+    0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
+    0x8A, 0x92, 0x93, 0x94, 0x95,
+    0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
+    0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
+    0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5,
+    0xC6, 0xC7, 0xC8, 0xC9, 0xCA,
+    0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
+    0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
+    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
+    0xF9, 0xFA, 0x11, 0x00, 0x02,
+    0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00,
+    0x01, 0x02, 0x77, 0x00, 0x01,
+    0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51,
+    0x07, 0x61, 0x71, 0x13, 0x22,
+    0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23,
+    0x33, 0x52, 0xF0, 0x15, 0x62,
+    0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18,
+    0x19, 0x1A, 0x26, 0x27, 0x28,
+    0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
+    0x46, 0x47, 0x48, 0x49, 0x4A,
+    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65,
+    0x66, 0x67, 0x68, 0x69, 0x6A,
+    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84,
+    0x85, 0x86, 0x87, 0x88, 0x89,
+    0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2,
+    0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
+    0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9,
+    0xBA, 0xC2, 0xC3, 0xC4, 0xC5,
+    0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
+    0xD8, 0xD9, 0xDA, 0xE2, 0xE3,
+    0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5,
+    0xF6, 0xF7, 0xF8, 0xF9, 0xFA
+};
+
+const unsigned char GsmartJPEGScanTable[6] = {
+    0x01, 0x00,
+    0x02, 0x11,
+    0x03, 0x11
+};
+const unsigned char GsmartQTable[][64] = {
+
+    //index0,Q40
+    {
+     20, 14, 15, 18, 15, 13, 20, 18, 16, 18, 23, 21, 20, 24, 30, 50,
+     33, 30, 28, 28, 30, 61, 44, 46, 36, 50, 73, 64, 76, 75, 71, 64,
+     70, 69, 80, 90, 115, 98, 80, 85, 109, 86, 69, 70, 100, 136, 101,
+     109,
+     119, 123, 129, 130, 129, 78, 96, 141, 151, 140, 125, 150, 115,
+     126, 129, 124},
+    {
+     21, 23, 23, 30, 26, 30, 59, 33, 33, 59, 124, 83, 70, 83, 124, 124,
+     124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124,
+     124, 124, 124,
+     124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124,
+     124, 124, 124,
+     124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124,
+     124, 124, 124},
+    //index1,Q50
+    {
+     16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40,
+     26, 24, 22, 22, 24, 49, 35, 37, 29, 40, 58, 51, 61, 60, 57, 51,
+     56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80, 109, 81, 87,
+     95, 98, 103, 104, 103, 62, 77, 113, 121, 112, 100, 120, 92, 101,
+     103, 99},
+    {
+     17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99,
+     99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+     99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+     99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99},
+    //index2,Q60
+    {
+     13, 9, 10, 11, 10, 8, 13, 11, 10, 11, 14, 14, 13, 15, 19, 32,
+     21, 19, 18, 18, 19, 39, 28, 30, 23, 32, 46, 41, 49, 48, 46, 41,
+     45, 44, 51, 58, 74, 62, 51, 54, 70, 55, 44, 45, 64, 87, 65, 70,
+     76, 78, 82, 83, 82, 50, 62, 90, 97, 90, 80, 96, 74, 81, 82, 79},
+    {
+     14, 14, 14, 19, 17, 19, 38, 21, 21, 38, 79, 53, 45, 53, 79, 79,
+     79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
+     79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
+     79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79},
+    //index3,Q70
+    {
+     10, 7, 7, 8, 7, 6, 10, 8, 8, 8, 11, 10, 10, 11, 14, 24,
+     16, 14, 13, 13, 14, 29, 21, 22, 17, 24, 35, 31, 37, 36, 34, 31,
+     34, 33, 38, 43, 55, 47, 38, 41, 52, 41, 33, 34, 48, 65, 49, 52,
+     57, 59, 62, 62, 62, 37, 46, 68, 73, 67, 60, 72, 55, 61, 62, 59},
+    {
+     10, 11, 11, 14, 13, 14, 28, 16, 16, 28, 59, 40, 34, 40, 59, 59,
+     59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
+     59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
+     59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59},
+    //index4,Q80
+    {
+     6, 4, 5, 6, 5, 4, 6, 6, 5, 6, 7, 7, 6, 8, 10, 16,
+     10, 10, 9, 9, 10, 20, 14, 15, 12, 16, 23, 20, 24, 24, 23, 20,
+     22, 22, 26, 29, 37, 31, 26, 27, 35, 28, 22, 22, 32, 44, 32, 35,
+     38, 39, 41, 42, 41, 25, 31, 45, 48, 45, 40, 48, 37, 40, 41, 40},
+    {
+     7, 7, 7, 10, 8, 10, 19, 10, 10, 19, 40, 26, 22, 26, 40, 40,
+     40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+     40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+     40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40},
+    //index5Q85
+    {
+     5, 3, 4, 4, 4, 3, 5, 4, 4, 4, 5, 5, 5, 6, 7, 12,
+     8, 7, 7, 7, 7, 15, 11, 11, 9, 12, 17, 15, 18, 18, 17, 15,
+     17, 17, 19, 22, 28, 23, 19, 20, 26, 21, 17, 17, 24, 33, 24, 26,
+     29, 29, 31, 31, 31, 19, 23, 34, 36, 34, 30, 36, 28, 30, 31, 30},
+    {
+     5, 5, 5, 7, 6, 7, 14, 8, 8, 14, 30, 20, 17, 20, 30, 30,
+     30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+     30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+     30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},
+/* Qindex= 86 */
+{ 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x04, 0x05, 0x07, 0x0B, 
+0x07, 0x07, 0x06, 0x06, 0x07, 0x0E, 0x0A, 0x0A, 0x08, 0x0B, 0x10, 0x0E, 0x11, 0x11, 0x10, 0x0E, 
+0x10, 0x0F, 0x12, 0x14, 0x1A, 0x16, 0x12, 0x13, 0x18, 0x13, 0x0F, 0x10, 0x16, 0x1F, 0x17, 0x18, 
+0x1B, 0x1B, 0x1D, 0x1D, 0x1D, 0x11, 0x16, 0x20, 0x22, 0x1F, 0x1C, 0x22, 0x1A, 0x1C, 0x1D, 0x1C, 
+},
+{0x05, 0x05, 0x05, 0x07, 0x06, 0x07, 0x0D, 0x07, 0x07, 0x0D, 0x1C, 0x12, 0x10, 0x12, 0x1C, 0x1C, 
+0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 
+0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 
+0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 
+ },
+    /* Qindex= 88 */
+{ 0x04, 0x03, 0x03, 0x03, 0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x06, 0x0A, 
+0x06, 0x06, 0x05, 0x05, 0x06, 0x0C, 0x08, 0x09, 0x07, 0x0A, 0x0E, 0x0C, 0x0F, 0x0E, 0x0E, 0x0C, 
+0x0D, 0x0D, 0x0F, 0x11, 0x16, 0x13, 0x0F, 0x10, 0x15, 0x11, 0x0D, 0x0D, 0x13, 0x1A, 0x13, 0x15, 
+0x17, 0x18, 0x19, 0x19, 0x19, 0x0F, 0x12, 0x1B, 0x1D, 0x1B, 0x18, 0x1D, 0x16, 0x18, 0x19, 0x18, 
+},
+{0x04, 0x04, 0x04, 0x06, 0x05, 0x06, 0x0B, 0x06, 0x06, 0x0B, 0x18, 0x10, 0x0D, 0x10, 0x18, 0x18, 
+0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
+0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
+0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
+ }
+
+};
+
+
+static int jpeg_decode411(struct spca50x_frame *myframe, int force_rgb);
+static int jpeg_decode422(struct spca50x_frame *myframe, int force_rgb);
+static int yuv_decode(struct spca50x_frame *myframe, int force_rgb);
+static int bayer_decode(struct spca50x_frame *myframe, int force_rgb);
+static int make_jpeg(struct spca50x_frame *myframe);
+static int make_jpeg_conexant(struct spca50x_frame *myframe);
+static int yvyu_translate(struct spca50x_frame *myframe, int force_rgb);
+
+
+#define CLIP(color) (unsigned char)(((color)>0xFF)?0xff:(((color)<0)?0:(color)))
+/****************************************************************/
+/**************      Sonix  huffman decoder      ****************/
+/****************************************************************/
+static inline unsigned char getByte(unsigned char *inp,
+				    unsigned int bitpos)
+{
+    unsigned char *addr;
+    addr = inp + (bitpos >> 3);
+    return (addr[0] << (bitpos & 7)) | (addr[1] >> (8 - (bitpos & 7)));
+}
+void init_sonix_decoder(struct usb_spca50x *spca50x)
+{
+    int i;
+    int is_abs, val, len;
+    struct code_table_t *table = spca50x->maindecode.table;
+
+    for (i = 0; i < 256; i++) {
+	is_abs = 0;
+	val = 0;
+	len = 0;
+	if ((i & 0x80) == 0) {
+	    /* code 0 */
+	    val = 0;
+	    len = 1;
+	} else if ((i & 0xE0) == 0x80) {
+	    /* code 100 */
+	    val = +4;
+	    len = 3;
+	} else if ((i & 0xE0) == 0xA0) {
+	    /* code 101 */
+	    val = -4;
+	    len = 3;
+	} else if ((i & 0xF0) == 0xD0) {
+	    /* code 1101 */
+	    val = +11;
+	    len = 4;
+	} else if ((i & 0xF0) == 0xF0) {
+	    /* code 1111 */
+	    val = -11;
+	    len = 4;
+	} else if ((i & 0xF8) == 0xC8) {
+	    /* code 11001 */
+	    val = +20;
+	    len = 5;
+	} else if ((i & 0xFC) == 0xC0) {
+	    /* code 110000 */
+	    val = -20;
+	    len = 6;
+	} else if ((i & 0xFC) == 0xC4) {
+	    /* code 110001xx: unknown */
+	    val = -1;
+	    len = 8;
+	} else if ((i & 0xF0) == 0xE0) {
+	    /* code 1110xxxx */
+	    is_abs = 1;
+	    val = (i & 0x0F) << 4;
+	    len = 8;
+	}
+	table[i].is_abs = is_abs;
+	table[i].val = val;
+	table[i].len = len;
+    }
+}
+
+static void sonix_decompress(struct spca50x_frame *myframe)
+{
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    unsigned char *inp = myframe->data;
+    unsigned char *outp = myframe->tmpbuffer;
+    struct code_table_t *table = myframe->decoder->table;
+    int row, col;
+    int val;
+    int bitpos;
+    unsigned char code;
+    bitpos = 0;
+    for (row = 0; row < height; row++) {
+	col = 0;
+	/* first two pixels in first two rows are stored as raw 8-bit */
+	if (row < 2) {
+	    code = getByte(inp, bitpos);
+	    bitpos += 8;
+	    *outp++ = code;
+	    code = getByte(inp, bitpos);
+	    bitpos += 8;
+	    *outp++ = code;
+	    col += 2;
+	}
+
+	while (col < width) {
+	    /* get bitcode from bitstream */
+
+	    code = getByte(inp, bitpos);
+	    /* update bit position */
+	    bitpos += table[code].len;
+
+	    /* calculate pixel value */
+	    val = table[code].val;
+	    /* unknowcode output nothing BS update 23:10:2005 */
+	    if (val == -1)
+		continue;
+	    if (!table[code].is_abs) {
+		/* value is relative to top and left pixel */
+		if (col < 2) {
+		    /* left column: relative to top pixel */
+		    val += outp[-2 * width];
+		} else if (row < 2) {
+		    /* top row: relative to left pixel */
+		    val += outp[-2];
+		} else {
+		    /* main area: average of left pixel and top pixel */
+		    val += (outp[-2] + outp[-2 * width]) / 2;
+		    //val += (outp[-2] + outp[-2*width] - outp[-2*width -2]);
+		}
+	    }
+
+	    /* store pixel */
+	    *outp++ = CLIP(val);
+	    col++;
+	}
+    }
+}
+
+void init_pixart_decoder(struct usb_spca50x *spca50x)
+{
+    int i;
+    int is_abs, val, len;
+    struct code_table_t *table = spca50x->maindecode.table;
+    for (i = 0; i < 256; i++) {
+	is_abs = 0;
+	val = 0;
+	len = 0;
+	if ((i & 0xC0) == 0) {
+	    /* code 00 */
+	    val = 0;
+	    len = 2;
+	} else if ((i & 0xC0) == 0x40) {
+	    /* code 01 */
+	    val = -5;
+	    len = 2;
+	} else if ((i & 0xC0) == 0x80) {
+	    /* code 10 */
+	    val = +5;
+	    len = 2;
+	} else if ((i & 0xF0) == 0xC0) {
+	    /* code 1100 */
+	    val = -10;
+	    len = 4;
+	} else if ((i & 0xF0) == 0xD0) {
+	    /* code 1101 */
+	    val = +10;
+	    len = 4;
+	} else if ((i & 0xF8) == 0xE0) {
+	    /* code 11100 */
+	    val = -15;
+	    len = 5;
+	} else if ((i & 0xF8) == 0xE8) {
+	    /* code 11101 */
+	    val = +15;
+	    len = 5;
+	} else if ((i & 0xFC) == 0xF0) {
+	    /* code 111100 */
+	    val = -20;
+	    len = 6;
+	} else if ((i & 0xFC) == 0xF4) {
+	    /* code 111101 */
+	    val = +20;
+	    len = 6;
+	} else if ((i & 0xF8) == 0xF8) {
+	    /* code 11111xxxxxx */
+	    is_abs = 1;
+	    val = 0;
+	    len = 5;
+	}
+	table[i].is_abs = is_abs;
+	table[i].val = val;
+	table[i].len = len;
+    }
+}
+
+static int
+pac_decompress_row(struct code_table_t *table, unsigned char *inp,
+		   unsigned char *outp, int width)
+{
+    int col;
+    int val;
+    int bitpos;
+    unsigned char code;
+
+
+    /* first two pixels are stored as raw 8-bit */
+    *outp++ = inp[2];
+    *outp++ = inp[3];
+    bitpos = 32;
+
+    /* main decoding loop */
+    for (col = 2; col < width; col++) {
+	/* get bitcode */
+
+	code = getByte(inp, bitpos);
+	bitpos += table[code].len;
+
+	/* calculate pixel value */
+	if (table[code].is_abs) {
+	    /* absolute value: get 6 more bits */
+	    code = getByte(inp, bitpos);
+	    bitpos += 6;
+	    *outp++ = code & 0xFC;
+	} else {
+	    /* relative to left pixel */
+	    val = outp[-2] + table[code].val;
+	    *outp++ = CLIP(val);
+	}
+    }
+
+    /* return line length, rounded up to next 16-bit word */
+    return 2 * ((bitpos + 15) / 16);
+}
+
+static void tv8532_preprocess(struct spca50x_frame *myframe)
+{
+/* we should received a whole frame with header and EOL marker
+in myframe->data and return a GBRG pattern in frame->tmpbuffer
+ sequence 2bytes header the Alternate pixels bayer GB 4 bytes
+ Alternate pixels bayer RG 4 bytes EOL */
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    int src = 0;
+    unsigned char *dst = myframe->tmpbuffer;
+    unsigned char *data = myframe->data;
+    int i;
+    int seq1, seq2;
+
+    /* precompute where is the good bayer line */
+    if ((((data[src + 3] + data[src + width + 7]) >> 1) +
+	 (data[src + 4] >> 2) + (data[src + width + 6] >> 1)) >=
+	(((data[src + 2] + data[src + width + 6]) >> 1) +
+	 (data[src + 3] >> 2) + (data[src + width + 5] >> 1))) {
+	seq1 = 3;
+	seq2 = 4;
+    } else {
+	seq1 = 2;
+	seq2 = 5;
+    }
+    for (i = 0; i < height / 2; i++) {
+	src += seq1;
+	memcpy(dst, &myframe->data[src], width);
+	src += (width + 3);
+	dst += width;
+	memcpy(dst, &myframe->data[src], width);
+	src += (width + seq2);
+	dst += width;
+    }
+}
+
+static inline unsigned short getShort(unsigned char *pt)
+{
+    return ((pt[0] << 8) | pt[1]);
+}
+
+static int pixart_decompress(struct spca50x_frame *myframe)
+{
+/* we should received a whole frame with header and EOL marker
+in myframe->data and return a GBRG pattern in frame->tmpbuffer
+remove the header then copy line by line EOL is set with 0x0f 0xf0 marker
+or 0x1e 0xe1 for compressed line*/
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    unsigned char *outp = myframe->tmpbuffer;
+    unsigned char *inp = myframe->data;
+    struct code_table_t *table = myframe->decoder->table;
+    unsigned short word;
+    int row;
+    /* skip header */
+    inp += 16;
+    /* and ask to go at pixel +1 ?? */
+    outp++;
+
+    /* iterate over all rows */
+    for (row = 0; row < height; row++) {
+	word = getShort(inp);
+	switch (word) {
+	case 0x0FF0:
+	    memcpy(outp, inp + 2, width);
+	    inp += (2 + width);
+	    break;
+	case 0x1EE1:
+	    inp += pac_decompress_row(table, inp, outp, width);
+	    break;
+
+	default:
+
+	    return -1;
+	}
+	outp += width;
+    }
+
+    return 0;
+}
+
+#define PAC7311_JPEG_HEADER_SIZE 594
+#define PAC7311_JPEG_HEADER_GEO_START 12
+
+
+const unsigned char pac7311_jpeg_header[PAC7311_JPEG_HEADER_SIZE] = {
+
+  0xff, 0xd8, 0xff, 0xe0, 0x00, 0x03, 0x20, 0xff, 0xc0, 0x00, 
+  0x11, 0x08, 0x01, 0xe0, 0x02, 0x80, 0x03, 0x01, 0x21, 0x00, 
+  0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xdb, 0x00, 0x84, 
+  0x00, 0x10, 0x0b, 0x0c, 0x0e, 0x0c, 0x0a, 0x10, 0x0e, 0x0d, 
+  0x0e, 0x12, 0x11, 0x10, 0x13, 0x18, 0x28, 0x1a, 0x18, 0x16, 
+  0x16, 0x18, 0x31, 0x23, 0x25, 0x1d, 0x28, 0x3a, 0x33, 0x3d, 
+  0x3c, 0x39, 0x33, 0x38, 0x37, 0x40, 0x48, 0x5c, 0x4e, 0x40, 
+  0x44, 0x57, 0x45, 0x37, 0x38, 0x50, 0x6d, 0x51, 0x57, 0x5f, 
+  0x62, 0x67, 0x68, 0x67, 0x3e, 0x4d, 0x71, 0x79, 0x70, 0x64, 
+  0x78, 0x5c, 0x65, 0x67, 0x63, 0x01, 0x11, 0x12, 0x12, 0x18, 
+  0x15, 0x18, 0x2f, 0x1a, 0x1a, 0x2f, 0x63, 0x42, 0x38, 0x42, 
+  0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 
+  0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 
+  0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 
+  0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 
+  0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 
+  0xff, 0xc4, 0x01, 0xa2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 
+  0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 
+  0x09, 0x0a, 0x0b, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 
+  0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 
+  0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 
+  0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 
+  0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 
+  0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 
+  0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 
+  0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 
+  0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 
+  0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 
+  0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 
+  0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 
+  0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 
+  0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 
+  0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 
+  0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 
+  0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 
+  0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 
+  0xf9, 0xfa, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 
+  0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 
+  0x0b, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 
+  0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 
+  0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 
+  0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 
+  0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 
+  0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 
+  0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 
+  0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 
+  0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 
+  0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 
+  0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 
+  0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 
+  0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 
+  0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 
+  0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 
+  0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 
+  0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 
+  0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 
+  0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 
+  0x11, 0x00, 0x3f, 0x00
+};
+
+static int pac7311_make_jpg(struct spca50x_frame *myframe)
+{
+/* we should received a whole frame with header and EOF marker
+in myframe->data and return a clean JPEG in frame->tmpbuffer
+remove the header, the stream markers and the MCU markers and
+add a correct JPEG header*/
+
+    int i;
+    int decrease_scanlenght;
+    char *pdatasave;
+    char *ptempsave;
+    pdatasave = myframe->data;
+    ptempsave = myframe->tmpbuffer;
+
+    if (*(myframe->data) != 0xFF && *(myframe->data+1) != 0xFF && *(myframe->data+2) != 0x00 && *(myframe->data+3) != 0xFF && *(myframe->data+4) != 0x96) {
+        myframe->scanlength = 0;
+        return -1;
+    }
+    
+    memcpy(myframe->tmpbuffer, pac7311_jpeg_header, PAC7311_JPEG_HEADER_SIZE);
+    myframe->tmpbuffer += PAC7311_JPEG_HEADER_SIZE;
+    myframe->data += 7;
+    myframe->scanlength -= 7;
+    decrease_scanlenght = 7;
+
+    for (i=0;i<myframe->scanlength;++i) {
+        if (i < myframe->scanlength+4) {
+            if (*(myframe->data) == 0xff && *(myframe->data+1) == 0xff && *(myframe->data+2) == 0xff) {
+                myframe->data += 4;
+                decrease_scanlenght -= 4;
+            }
+        }
+        *myframe->tmpbuffer = *myframe->data;
+        myframe->tmpbuffer++;
+        myframe->data++;
+    }
+    
+
+    myframe->data = pdatasave;
+    myframe->tmpbuffer = ptempsave;
+    myframe->scanlength += (PAC7311_JPEG_HEADER_SIZE + decrease_scanlenght);
+    memcpy(myframe->data, myframe->tmpbuffer, myframe->scanlength);
+
+    return 1;
+}
+
+static int jpeg_decode422_PAC7311(struct spca50x_frame *myframe, int force_rgb);
+
+static int pac7311_decode(struct spca50x_frame *myframe, int force_rgb)
+{
+/* we should received a whole frame with header and EOF marker
+in myframe->data and return a decoded frame in frame->tmpbuffer
+*/
+
+    int i;
+    int done;
+    char *pdatasave;
+    char *ptempsave;
+    pdatasave = myframe->data;
+    ptempsave = myframe->tmpbuffer;
+
+    if (*(myframe->data) != 0xFF && *(myframe->data+1) != 0xFF && *(myframe->data+2) != 0x00 && *(myframe->data+3) != 0xFF && *(myframe->data+4) != 0x96) {
+        myframe->scanlength = 0;
+        return -1;
+    }
+    
+    myframe->data += 7;
+    myframe->scanlength -= 7;
+
+    for (i=0;i<myframe->scanlength;++i) {
+        if (i < myframe->scanlength+4) {
+            if (*(myframe->data) == 0xff && *(myframe->data+1) == 0xff && *(myframe->data+2) == 0xff) {
+				if (*(myframe->data+3) == 0x00 || *(myframe->data+3) == 0x01 || *(myframe->data+3) == 0x02 ) {
+	                myframe->data += 4;
+				    myframe->scanlength -= 4;
+				} else {
+					PDEBUG(1, "Unknown FFFFFF marker value: 0x%2X", *(myframe->data+3));
+				}
+            }
+        }
+        *myframe->tmpbuffer = *myframe->data;
+        myframe->tmpbuffer++;
+        myframe->data++;
+    }
+    
+    myframe->data = pdatasave;
+    myframe->tmpbuffer = ptempsave;
+    done = jpeg_decode422_PAC7311(myframe, force_rgb);
+
+    return done;
+}
+
+/*
+#	Decoder for compressed spca561 images			    		#
+#	It was developed for "Labtec WebCam Elch 2(SPCA561A)" (046d:0929)	#
+#	but it might work with other spca561 cameras				#
+*/
+
+static unsigned int bit_bucket;
+static unsigned char *input_ptr;
+
+static inline void refill(int *bitfill)
+{
+    if (*bitfill < 8) {
+	bit_bucket = (bit_bucket << 8) | *(input_ptr++);
+	*bitfill += 8;
+    }
+}
+
+static inline int nbits(int *bitfill, int n)
+{
+    bit_bucket = (bit_bucket << 8) | *(input_ptr++);
+    *bitfill -= n;
+    return (bit_bucket >> (*bitfill & 0xff)) & ((1 << n) - 1);
+}
+
+static inline int _nbits(int *bitfill, int n)
+{
+    *bitfill -= n;
+    return (bit_bucket >> (*bitfill & 0xff)) & ((1 << n) - 1);
+}
+
+static int fun_A(int *bitfill)
+{
+    int ret;
+    static int tab[] =
+	{ 12, 13, 14, 15, 16, 17, 18, 19, -12, -13, -14, -15, -16, -17,
+	-18, -19, -19
+    };
+
+    ret = tab[nbits(bitfill, 4)];
+
+    refill(bitfill);
+    return ret;
+}
+static int fun_B(int *bitfill)
+{
+    static int tab1[] =
+	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 31, 31,
+	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 16, 17,
+	18,
+	19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30
+    };
+    static int tab[] =
+	{ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, -5,
+	-6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19
+    };
+    unsigned int tmp;
+
+    tmp = nbits(bitfill, 7) - 68;
+    refill(bitfill);
+    if (tmp > 47)
+	return 0xff;
+    return tab[tab1[tmp]];
+}
+static int fun_C(int *bitfill, int gkw)
+{
+    static int tab1[] =
+	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 23, 23, 23, 23, 23, 23,
+	23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 12, 13,
+	14,
+	15, 16, 17, 18, 19, 20, 21, 22
+    };
+    static int tab[] =
+	{ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, -9, -10, -11,
+	-12, -13, -14, -15, -16, -17, -18, -19
+    };
+    unsigned int tmp;
+
+    if (gkw == 0xfe) {
+
+	if (nbits(bitfill, 1) == 0)
+	    return 7;
+	else
+	    return -8;
+    }
+
+    if (gkw != 0xff)
+	return 0xff;
+
+    tmp = nbits(bitfill, 7) - 72;
+    if (tmp > 43)
+	return 0xff;
+
+    refill(bitfill);
+    return tab[tab1[tmp]];
+}
+static int fun_D(int *bitfill, int gkw)
+{
+    if (gkw == 0xfd) {
+	if (nbits(bitfill, 1) == 0)
+	    return 12;
+	else
+	    return -13;
+    }
+
+    if (gkw == 0xfc) {
+	if (nbits(bitfill, 1) == 0)
+	    return 13;
+	else
+	    return -14;
+    }
+
+    if (gkw == 0xfe) {
+	switch (nbits(bitfill, 2)) {
+	case 0:
+	    return 14;
+	case 1:
+	    return -15;
+	case 2:
+	    return 15;
+	case 3:
+	    return -16;
+	}
+
+    }
+
+    if (gkw == 0xff) {
+	switch (nbits(bitfill, 3)) {
+	case 4:
+	    return 16;
+	case 5:
+	    return -17;
+	case 6:
+	    return 17;
+	case 7:
+	    return -18;
+	case 2:
+	    return _nbits(bitfill, 1) ? 0xed : 0x12;
+	case 3:
+	    (*bitfill)--;
+	    return 18;
+	}
+
+	return 0xff;
+    }
+    return gkw;
+}
+
+static int fun_E(int cur_byte, int *bitfill)
+{
+    static int tab0[] = { 0, -1, 1, -2, 2, -3, 3, -4 };
+    static int tab1[] = { 4, -5, 5, -6, 6, -7, 7, -8 };
+    static int tab2[] = { 8, -9, 9, -10, 10, -11, 11, -12 };
+    static int tab3[] = { 12, -13, 13, -14, 14, -15, 15, -16 };
+    static int tab4[] = { 16, -17, 17, -18, 18, -19, 19, -19 };
+
+    if ((cur_byte & 0xf0) >= 0x80) {
+	*bitfill -= 4;
+	return tab0[(cur_byte >> 4) & 7];
+    } else if ((cur_byte & 0xc0) == 0x40) {
+	*bitfill -= 5;
+	return tab1[(cur_byte >> 3) & 7];
+
+    } else if ((cur_byte & 0xe0) == 0x20) {
+	*bitfill -= 6;
+	return tab2[(cur_byte >> 2) & 7];
+
+    } else if ((cur_byte & 0xf0) == 0x10) {
+	*bitfill -= 7;
+	return tab3[(cur_byte >> 1) & 7];
+
+    } else if ((cur_byte & 0xf8) == 8) {
+	*bitfill -= 8;
+	return tab4[cur_byte & 7];
+    }
+
+    return 0xff;
+}
+
+static int fun_F(int cur_byte, int *bitfill)
+{
+    *bitfill -= 5;
+    switch (cur_byte & 0xf8) {
+    case 0x80:
+	return 0;
+    case 0x88:
+	return -1;
+    case 0x90:
+	return 1;
+    case 0x98:
+	return -2;
+    case 0xa0:
+	return 2;
+    case 0xa8:
+	return -3;
+    case 0xb0:
+	return 3;
+    case 0xb8:
+	return -4;
+    case 0xc0:
+	return 4;
+    case 0xc8:
+	return -5;
+    case 0xd0:
+	return 5;
+    case 0xd8:
+	return -6;
+    case 0xe0:
+	return 6;
+    case 0xe8:
+	return -7;
+    case 0xf0:
+	return 7;
+    case 0xf8:
+	return -8;
+    }
+
+    *bitfill -= 1;
+
+    switch (cur_byte & 0xfc) {
+    case 0x40:
+	return 8;
+    case 0x44:
+	return -9;
+    case 0x48:
+	return 9;
+    case 0x4c:
+	return -10;
+    case 0x50:
+	return 10;
+    case 0x54:
+	return -11;
+    case 0x58:
+	return 11;
+    case 0x5c:
+	return -12;
+    case 0x60:
+	return 12;
+    case 0x64:
+	return -13;
+    case 0x68:
+	return 13;
+    case 0x6c:
+	return -14;
+    case 0x70:
+	return 14;
+    case 0x74:
+	return -15;
+    case 0x78:
+	return 15;
+    case 0x7c:
+	return -16;
+    }
+
+    *bitfill -= 1;
+
+    switch (cur_byte & 0xfe) {
+    case 0x20:
+	return 16;
+    case 0x22:
+	return -17;
+    case 0x24:
+	return 17;
+    case 0x26:
+	return -18;
+    case 0x28:
+	return 18;
+    case 0x2a:
+	return -19;
+    case 0x2c:
+	return 19;
+    }
+
+    *bitfill += 7;
+    return 0xff;
+}
+static
+int internal_spca561_decode(int width, int height, unsigned char *inbuf, unsigned char *outbuf)	// {{{
+{
+    // buffers
+    static int accum[8 * 8 * 8];
+    static int i_hits[8 * 8 * 8];
+
+    const static int nbits_A[] =
+	{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 7, 7, 7, 7,
+	7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+    };
+    const static int tab_A[] =
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 11, -11, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
+	255, 254, -4,
+	-4, -5, -5, -6, -6, -7, -7, -8, -8, -9, -9, -10, -10, -1, -1, -1,
+	-1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1,
+	-1, -1, -1, -1, -1, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
+	3, 3, 3,
+	-2, -2, -2, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3, -3, -3, -3, 1,
+	1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1,
+	1
+    };
+
+    const static int nbits_B[] =
+	{ 0, 8, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    };
+    const static int tab_B[] =
+	{ 0xff, -4, 3, 3, -3, -3, -3, -3, 2, 2, 2, 2, 2, 2, 2, 2, -2,
+	-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 1, 1,
+	1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1,
+	-1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0,
+    };
+
+    const static int nbits_C[] =
+	{ 0, 0, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    };
+    const static int tab_C[] =
+	{ 0xff, 0xfe, 6, -7, 5, 5, -6, -6, 4, 4, 4, 4, -5, -5, -5, -5,
+	3, 3, 3, 3, 3, 3, 3, 3, -4, -4, -4, -4, -4, -4, -4, -4, 2, 2, 2, 2,
+	2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
+	-3, -3, -3,
+	-3, -3, -3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -2, -2, -2, -2, -2, -2, -2, -2, -2,
+	-2, -2, -2,
+	-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
+	-2, -2,
+	-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    };
+
+    const static int nbits_D[] =
+	{ 0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
+    };
+    const static int tab_D[] =
+	{ 0xff, 0xfe, 0xfd, 0xfc, 10, -11, 11, -12, 8, 8, -9, -9, 9, 9,
+	-10, -10, 6, 6, 6, 6, -7, -7, -7, -7, 7, 7, 7, 7, -8, -8, -8, -8,
+	4, 4, 4, 4,
+	4, 4, 4, 4, -5, -5, -5, -5, -5, -5, -5, -5, 5, 5, 5, 5, 5, 5, 5, 5,
+	-6, -6,
+	-6, -6, -6, -6, -6, -6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, -3,
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, 3, 3,
+	3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -4, -4, -4, -4, -4, -4, -4, -4, -4,
+	-4, -4, -4,
+	-4, -4, -4, -4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1,
+	-1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
+	-2, -2, -2,
+	-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
+	-2, -2
+    };
+
+    // a_curve[19 + i] = ... [-19..19] => [-160..160]
+    const static int a_curve[] =
+	{ -160, -144, -128, -112, -98, -88, -80, -72, -64, -56, -48,
+	-40, -32, -24, -18, -12, -8, -5, -2, 0, 2, 5, 8, 12, 18, 24, 32,
+	40, 48, 56, 64,
+	72, 80, 88, 98, 112, 128, 144, 160
+    };
+    // clamp0_255[256 + i] = min(max(i,255),0)
+    const static unsigned char clamp0_255[] =
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
+	3, 4, 5, 6, 7, 8, 9, 10,
+	11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
+	28, 29, 30, 31, 32, 33,
+	34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
+	51, 52, 53, 54, 55, 56,
+	57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
+	74, 75, 76, 77, 78, 79,
+	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
+	97, 98, 99, 100, 101,
+	102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
+	115, 116, 117, 118, 119,
+	120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132,
+	133, 134, 135, 136, 137,
+	138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150,
+	151, 152, 153, 154, 155,
+	156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168,
+	169, 170, 171, 172, 173,
+	174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186,
+	187, 188, 189, 190, 191,
+	192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204,
+	205, 206, 207, 208, 209,
+	210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,
+	223, 224, 225, 226, 227,
+	228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240,
+	241, 242, 243, 244, 245,
+	246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+	255
+    };
+    // abs_clamp15[19 + i] = min(abs(i), 15)
+    const static int abs_clamp15[] =
+	{ 15, 15, 15, 15, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3,
+	2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15,
+	15
+    };
+    // diff_encoding[256 + i] = ...
+    const static int diff_encoding[] =
+	{ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 3, 3,
+	3, 3, 1, 1, 0, 2, 2, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6
+    };
+
+
+    int block;
+
+    int bitfill = 0;
+    int xwidth = width + 6;
+    int off_up_right = 2 - 2 * xwidth;
+    int off_up_left = -2 - 2 * xwidth;
+
+    int pixel_U = 0, saved_pixel_UR = 0;
+    int pixel_x = 0, pixel_y = 2;
+
+    unsigned char *output_ptr = outbuf;
+
+    memset(i_hits, 0, sizeof(i_hits));
+    memset(accum, 0, sizeof(accum));
+
+    memcpy(outbuf + xwidth * 2 + 3, inbuf + 0x14, width);
+    memcpy(outbuf + xwidth * 3 + 3, inbuf + 0x14 + width, width);
+
+    input_ptr = inbuf + 0x14 + width * 2;
+    output_ptr = outbuf + (xwidth) * 4 + 3;
+
+    bit_bucket = 0;
+
+    for (block = 0; block < ((height - 2) * width) / 32; ++block) {
+	int b_it, var_7 = 0;
+	int cur_byte;
+
+	refill(&bitfill);
+
+	cur_byte = (bit_bucket >> (bitfill & 7)) & 0xff;
+
+	if ((cur_byte & 0x80) == 0) {
+	    var_7 = 0;
+	    bitfill--;
+	} else if ((cur_byte & 0xC0) == 0x80) {
+	    var_7 = 1;
+	    bitfill -= 2;
+	} else if ((cur_byte & 0xc0) == 0xc0) {
+	    var_7 = 2;
+	    bitfill -= 2;
+	}
+
+	for (b_it = 0; b_it < 32; b_it++) {
+	    int index;
+	    int pixel_L, pixel_UR, pixel_UL;
+	    int multiplier;
+	    int dL, dC, dR;
+
+	    int gkw;		// God knows what
+
+	    refill(&bitfill);
+	    cur_byte = bit_bucket >> (bitfill & 7) & 0xff;
+
+	    pixel_L = output_ptr[-2];
+	    pixel_UR = output_ptr[off_up_right];
+	    pixel_UL = output_ptr[off_up_left];
+
+	    dL = diff_encoding[0x100 + pixel_UL - pixel_L];
+	    dC = diff_encoding[0x100 + pixel_U - pixel_UL];
+	    dR = diff_encoding[0x100 + pixel_UR - pixel_U];
+
+	    if (pixel_x < 2) {
+		pixel_L = pixel_UL = pixel_U = output_ptr[-xwidth * 2];
+		pixel_UR = output_ptr[off_up_right];
+		dL = dC = 0;
+		dR = diff_encoding[0x100 + pixel_UR - pixel_U];
+	    } else if (pixel_x > width - 3)
+		dR = 0;
+
+	    multiplier = 4;
+	    index = dR + dC * 8 + dL * 64;
+
+	    if (pixel_L + pixel_U * 2 <= 144
+		&& (pixel_y & 1) == 0
+		&& (b_it & 3) == 0 && (dR < 5) && (dC < 5) && (dL < 5)) {
+
+		multiplier = 1;
+
+	    } else if (pixel_L <= 48
+		       && dL <= 4 && dC <= 4 && dL >= 1 && dC >= 1) {
+		multiplier = 2;
+
+	    } else if (var_7 == 1) {
+		multiplier = 2;
+
+	    } else if (dC + dL >= 11 || var_7 == 2) {
+		multiplier = 8;
+	    }
+
+	    if (i_hits[index] < 7) {
+		bitfill -= nbits_A[cur_byte];
+		gkw = tab_A[cur_byte];
+		if (gkw == 0xfe)
+		    gkw = fun_A(&bitfill);
+
+	    } else if (i_hits[index] >= accum[index]) {
+		bitfill -= nbits_B[cur_byte];
+		gkw = tab_B[cur_byte];
+		if (cur_byte == 0)
+		    gkw = fun_B(&bitfill);
+
+	    } else if (i_hits[index] * 2 >= accum[index]) {
+		bitfill -= nbits_C[cur_byte];
+		gkw = tab_C[cur_byte];
+		if (cur_byte < 2)
+		    gkw = fun_C(&bitfill, gkw);
+
+	    } else if (i_hits[index] * 4 >= accum[index]) {
+		bitfill -= nbits_D[cur_byte];
+		gkw = tab_D[cur_byte];
+		if (cur_byte < 4)
+		    gkw = fun_D(&bitfill, gkw);
+
+	    } else if (i_hits[index] * 8 >= accum[index]) {
+		gkw = fun_E(cur_byte, &bitfill);
+
+	    } else {
+		gkw = fun_F(cur_byte, &bitfill);
+	    }
+
+	    if (gkw == 0xff)
+		return -3;
+
+	    {
+		int tmp1, tmp2;
+		tmp1 = (pixel_U + pixel_L) * 3 - pixel_UL * 2;
+		tmp1 += (tmp1 < 0) ? 3 : 0;
+		tmp2 = a_curve[19 + gkw] * multiplier;
+		tmp2 += (tmp2 < 0) ? 1 : 0;
+
+		*(output_ptr++) =
+		    clamp0_255[0x100 + (tmp1 >> 2) - (tmp2 >> 1)];
+	    }
+
+	    pixel_U = saved_pixel_UR;
+	    saved_pixel_UR = pixel_UR;
+
+	    if (++pixel_x == width) {
+		output_ptr += 6;
+		pixel_x = 0;
+		pixel_y++;
+	    }
+
+	    accum[index] += abs_clamp15[19 + gkw];
+
+	    if (i_hits[index]++ == 15) {
+		i_hits[index] = 8;
+		accum[index] /= 2;
+	    }
+
+	}
+
+    }
+
+    return 0;
+}
+static
+void decode_spca561(unsigned char *inbuf, char *outbuf, int width,
+		    int height)
+{
+    int i;
+    static char tmpbuf[650 * 490];
+
+    if (internal_spca561_decode(width, height, inbuf, tmpbuf) == 0) {
+	for (i = 0; i < height; i++)
+	    memcpy(outbuf + i * width,
+		   tmpbuf + (i + 2) * (width + 6) + 3, width);
+    }
+
+}
+
+/****************************************************************/
+/**************       huffman decoder             ***************/
+/****************************************************************/
+
+/*need to be on init jpeg */
+static struct comp comp_template[MAXCOMP] = {
+    {0x01, 0x22, 0x00},
+    {0x02, 0x11, 0x01},
+    {0x03, 0x11, 0x01},
+    {0x00, 0x00, 0x00}
+};
+
+/* deprecated set by webcam now in spca50x */
+//static struct scan dscans[MAXCOMP];
+//static unsigned char quant[3][64];
+//static struct in in;
+//int dquant[3][64];
+//static struct jpginfo info;
+/* table de Huffman global for all */
+static struct dec_hufftbl dhuff[4];
+#define dec_huffdc (dhuff + 0)
+#define dec_huffac (dhuff + 2)
+#define M_RST0	0xd0
+
+
+static int fillbits(struct in *, int, unsigned int);
+static int dec_rec2(struct in *, struct dec_hufftbl *, int *, int, int);
+
+static int fillbits(struct in *in, int le, unsigned int bi)
+{
+    int b;
+    int m;
+    if (in->marker) {
+	if (le <= 16)
+	    in->bits = bi << 16, le += 16;
+	return le;
+    }
+    while (le <= 24) {
+	b = *in->p++;
+	if (in->omitescape) {
+	    if (b == 0xff && (m = *in->p++) != 0) {
+		in->marker = m;
+		if (le <= 16)
+		    bi = bi << 16, le += 16;
+		break;
+	    }
+	}
+	bi = bi << 8 | b;
+	le += 8;
+    }
+    in->bits = bi;		/* tmp... 2 return values needed */
+    return le;
+}
+
+#define LEBI_GET(in)	(le = in->left, bi = in->bits)
+#define LEBI_PUT(in)	(in->left = le, in->bits = bi)
+
+#define GETBITS(in, n) (					\
+  (le < (n) ? le = fillbits(in, le, bi), bi = in->bits : 0),	\
+  (le -= (n)),							\
+  bi >> le & ((1 << (n)) - 1)					\
+)
+
+#define UNGETBITS(in, n) (	\
+  le += (n)			\
+)
+
+static void dec_initscans(struct dec_data *decode)
+{
+    struct jpginfo *info = &decode->info;
+    struct scan *dscans = decode->dscans;
+    int i;
+    info->ns = 3;		// HARDCODED  here
+    info->nm = info->dri + 1;	// macroblock count
+    info->rm = M_RST0;
+    for (i = 0; i < info->ns; i++)
+	dscans[i].dc = 0;
+}
+static int dec_readmarker(struct in *in)
+{
+    int m;
+
+    in->left = fillbits(in, in->left, in->bits);
+    if ((m = in->marker) == 0)
+	return 0;
+    in->left = 0;
+    in->marker = 0;
+    return m;
+}
+
+static int dec_checkmarker(struct dec_data *decode)
+{
+    struct jpginfo *info = &decode->info;
+    struct scan *dscans = decode->dscans;
+    struct in *in = &decode->in;
+    int i;
+
+    if (dec_readmarker(in) != info->rm)
+	return -1;
+    info->nm = info->dri;
+    info->rm = (info->rm + 1) & ~0x08;
+    for (i = 0; i < info->ns; i++)
+	dscans[i].dc = 0;
+    return 0;
+}
+static
+void
+jpeg_reset_input_context(struct dec_data *decode, unsigned char *buf,
+			 int oescap)
+{
+    /* set input context */
+    struct in *in = &decode->in;
+    in->p = buf;
+    in->omitescape = oescap;
+    in->left = 0;
+    in->bits = 0;
+    in->marker = 0;
+}
+static int
+dec_rec2(struct in *in, struct dec_hufftbl *hu, int *runp, int c, int i)
+{
+    int le, bi;
+
+    le = in->left;
+    bi = in->bits;
+    if (i) {
+	UNGETBITS(in, i & 127);
+	*runp = i >> 8 & 15;
+	i >>= 16;
+    } else {
+	for (i = DECBITS;
+	     (c = ((c << 1) | GETBITS(in, 1))) >= (hu->maxcode[i]); i++);
+	if (i >= 16) {
+	    in->marker = M_BADHUFF;
+	    return 0;
+	}
+	i = hu->vals[hu->valptr[i] + c - hu->maxcode[i - 1] * 2];
+	*runp = i >> 4;
+	i &= 15;
+    }
+    if (i == 0) {		/* sigh, 0xf0 is 11 bit */
+	LEBI_PUT(in);
+	return 0;
+    }
+    /* receive part */
+    c = GETBITS(in, i);
+    if (c < (1 << (i - 1)))
+	c += (-1 << i) + 1;
+    LEBI_PUT(in);
+    return c;
+}
+
+#define DEC_REC(in, hu, r, i)	 (	\
+  r = GETBITS(in, DECBITS),		\
+  i = hu->llvals[r],			\
+  i & 128 ?				\
+    (					\
+      UNGETBITS(in, i & 127),		\
+      r = i >> 8 & 15,			\
+      i >> 16				\
+    )					\
+  :					\
+    (					\
+      LEBI_PUT(in),			\
+      i = dec_rec2(in, hu, &r, r, i),	\
+      LEBI_GET(in),			\
+      i					\
+    )					\
+)
+
+inline static void
+decode_mcus(struct in *in, int *dct, int n, struct scan *sc, int *maxp)
+{
+    struct dec_hufftbl *hu;
+    int i, r, t;
+    int le, bi;
+
+    memset(dct, 0, n * 64 * sizeof(*dct));
+    le = in->left;
+    bi = in->bits;
+
+    while (n-- > 0) {
+	hu = sc->hudc.dhuff;
+	*dct++ = (sc->dc += DEC_REC(in, hu, r, t));
+
+	hu = sc->huac.dhuff;
+	i = 63;
+	while (i > 0) {
+	    t = DEC_REC(in, hu, r, t);
+	    if (t == 0 && r == 0) {
+		dct += i;
+		break;
+	    }
+	    dct += r;
+	    *dct++ = t;
+	    i -= r + 1;
+	}
+	*maxp++ = 64 - i;
+	if (n == sc->next)
+	    sc++;
+    }
+    LEBI_PUT(in);
+}
+
+static void
+dec_makehuff(struct dec_hufftbl *hu, int *hufflen, unsigned char *huffvals)
+{
+    int code, k, i, j, d, x, c, v;
+
+    for (i = 0; i < (1 << DECBITS); i++)
+	hu->llvals[i] = 0;
+
+/*
+ * llvals layout:
+ *
+ * value v already known, run r, backup u bits:
+ *  vvvvvvvvvvvvvvvv 0000 rrrr 1 uuuuuuu
+ * value unknown, size b bits, run r, backup u bits:
+ *  000000000000bbbb 0000 rrrr 0 uuuuuuu
+ * value and size unknown:
+ *  0000000000000000 0000 0000 0 0000000
+ */
+    code = 0;
+    k = 0;
+    for (i = 0; i < 16; i++, code <<= 1) {	/* sizes */
+	hu->valptr[i] = k;
+	for (j = 0; j < hufflen[i]; j++) {
+	    hu->vals[k] = *huffvals++;
+	    if (i < DECBITS) {
+		c = code << (DECBITS - 1 - i);
+		v = hu->vals[k] & 0x0f;	/* size */
+		for (d = 1 << (DECBITS - 1 - i); --d >= 0;) {
+		    if (v + i < DECBITS) {	/* both fit in table */
+			x = d >> (DECBITS - 1 - v - i);
+			if (v && x < (1 << (v - 1)))
+			    x += (-1 << v) + 1;
+			x = x << 16 | (hu->vals[k] & 0xf0)
+			    << 4 | (DECBITS - (i + 1 + v)) | 128;
+		    } else
+			x = v << 16 | (hu->vals[k] & 0xf0)
+			    << 4 | (DECBITS - (i + 1));
+		    hu->llvals[c | d] = x;
+		}
+	    }
+	    code++;
+	    k++;
+	}
+	hu->maxcode[i] = code;
+    }
+    hu->maxcode[16] = 0x20000;	/* always terminate decode */
+}
+
+/****************************************************************/
+/**************             idct                  ***************/
+/****************************************************************/
+
+
+#define S22 ((long)IFIX(2 * 0.382683432))
+#define C22 ((long)IFIX(2 * 0.923879532))
+#define IC4 ((long)IFIX(1 / 0.707106781))
+
+static unsigned char zig2[64] = {
+    0, 2, 3, 9, 10, 20, 21, 35,
+    14, 16, 25, 31, 39, 46, 50, 57,
+    5, 7, 12, 18, 23, 33, 37, 48,
+    27, 29, 41, 44, 52, 55, 59, 62,
+    15, 26, 30, 40, 45, 51, 56, 58,
+    1, 4, 8, 11, 19, 22, 34, 36,
+    28, 42, 43, 53, 54, 60, 61, 63,
+    6, 13, 17, 24, 32, 38, 47, 49
+};
+
+static void idct(int *in, int *out, int *quant, long off, int max)
+{
+    long t0, t1, t2, t3, t4, t5, t6, t7;	// t ;
+    long tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
+    long tmp[64], *tmpp;
+    int i, j, te;
+    unsigned char *zig2p;
+
+    t0 = off;
+    if (max == 1) {
+	t0 += in[0] * quant[0];
+	for (i = 0; i < 64; i++)
+	    out[i] = ITOINT(t0);
+	return;
+    }
+    zig2p = zig2;
+    tmpp = tmp;
+    for (i = 0; i < 8; i++) {
+	j = *zig2p++;
+	t0 += in[j] * (long) quant[j];
+	j = *zig2p++;
+	t5 = in[j] * (long) quant[j];
+	j = *zig2p++;
+	t2 = in[j] * (long) quant[j];
+	j = *zig2p++;
+	t7 = in[j] * (long) quant[j];
+	j = *zig2p++;
+	t1 = in[j] * (long) quant[j];
+	j = *zig2p++;
+	t4 = in[j] * (long) quant[j];
+	j = *zig2p++;
+	t3 = in[j] * (long) quant[j];
+	j = *zig2p++;
+	t6 = in[j] * (long) quant[j];
+
+
+	if ((t1 | t2 | t3 | t4 | t5 | t6 | t7) == 0) {
+
+	    tmpp[0 * 8] = t0;
+	    tmpp[1 * 8] = t0;
+	    tmpp[2 * 8] = t0;
+	    tmpp[3 * 8] = t0;
+	    tmpp[4 * 8] = t0;
+	    tmpp[5 * 8] = t0;
+	    tmpp[6 * 8] = t0;
+	    tmpp[7 * 8] = t0;
+
+	    tmpp++;
+	    t0 = 0;
+	    continue;
+	}
+	//IDCT;
+	tmp0 = t0 + t1;
+	t1 = t0 - t1;
+	tmp2 = t2 - t3;
+	t3 = t2 + t3;
+	tmp2 = IMULT(tmp2, IC4) - t3;
+	tmp3 = tmp0 + t3;
+	t3 = tmp0 - t3;
+	tmp1 = t1 + tmp2;
+	tmp2 = t1 - tmp2;
+	tmp4 = t4 - t7;
+	t7 = t4 + t7;
+	tmp5 = t5 + t6;
+	t6 = t5 - t6;
+	tmp6 = tmp5 - t7;
+	t7 = tmp5 + t7;
+	tmp5 = IMULT(tmp6, IC4);
+	tmp6 = IMULT((tmp4 + t6), S22);
+	tmp4 = IMULT(tmp4, (C22 - S22)) + tmp6;
+	t6 = IMULT(t6, (C22 + S22)) - tmp6;
+	t6 = t6 - t7;
+	t5 = tmp5 - t6;
+	t4 = tmp4 - t5;
+
+	tmpp[0 * 8] = tmp3 + t7;	//t0;
+	tmpp[1 * 8] = tmp1 + t6;	//t1;
+	tmpp[2 * 8] = tmp2 + t5;	//t2;
+	tmpp[3 * 8] = t3 + t4;	//t3;
+	tmpp[4 * 8] = t3 - t4;	//t4;
+	tmpp[5 * 8] = tmp2 - t5;	//t5;
+	tmpp[6 * 8] = tmp1 - t6;	//t6;
+	tmpp[7 * 8] = tmp3 - t7;	//t7;
+	tmpp++;
+	t0 = 0;
+    }
+    for (i = 0, j = 0; i < 8; i++) {
+	t0 = tmp[j + 0];
+	t1 = tmp[j + 1];
+	t2 = tmp[j + 2];
+	t3 = tmp[j + 3];
+	t4 = tmp[j + 4];
+	t5 = tmp[j + 5];
+	t6 = tmp[j + 6];
+	t7 = tmp[j + 7];
+	if ((t1 | t2 | t3 | t4 | t5 | t6 | t7) == 0) {
+	    te = ITOINT(t0);
+	    out[j + 0] = te;
+	    out[j + 1] = te;
+	    out[j + 2] = te;
+	    out[j + 3] = te;
+	    out[j + 4] = te;
+	    out[j + 5] = te;
+	    out[j + 6] = te;
+	    out[j + 7] = te;
+	    j += 8;
+	    continue;
+	}
+	//IDCT;
+	tmp0 = t0 + t1;
+	t1 = t0 - t1;
+	tmp2 = t2 - t3;
+	t3 = t2 + t3;
+	tmp2 = IMULT(tmp2, IC4) - t3;
+	tmp3 = tmp0 + t3;
+	t3 = tmp0 - t3;
+	tmp1 = t1 + tmp2;
+	tmp2 = t1 - tmp2;
+	tmp4 = t4 - t7;
+	t7 = t4 + t7;
+	tmp5 = t5 + t6;
+	t6 = t5 - t6;
+	tmp6 = tmp5 - t7;
+	t7 = tmp5 + t7;
+	tmp5 = IMULT(tmp6, IC4);
+	tmp6 = IMULT((tmp4 + t6), S22);
+	tmp4 = IMULT(tmp4, (C22 - S22)) + tmp6;
+	t6 = IMULT(t6, (C22 + S22)) - tmp6;
+	t6 = t6 - t7;
+	t5 = tmp5 - t6;
+	t4 = tmp4 - t5;
+
+	out[j + 0] = ITOINT(tmp3 + t7);
+	out[j + 1] = ITOINT(tmp1 + t6);
+	out[j + 2] = ITOINT(tmp2 + t5);
+	out[j + 3] = ITOINT(t3 + t4);
+	out[j + 4] = ITOINT(t3 - t4);
+	out[j + 5] = ITOINT(tmp2 - t5);
+	out[j + 6] = ITOINT(tmp1 - t6);
+	out[j + 7] = ITOINT(tmp3 - t7);
+	j += 8;
+    }
+
+}
+
+static unsigned char zig[64] = {
+    0, 1, 5, 6, 14, 15, 27, 28,
+    2, 4, 7, 13, 16, 26, 29, 42,
+    3, 8, 12, 17, 25, 30, 41, 43,
+    9, 11, 18, 24, 31, 40, 44, 53,
+    10, 19, 23, 32, 39, 45, 52, 54,
+    20, 22, 33, 38, 46, 51, 55, 60,
+    21, 34, 37, 47, 50, 56, 59, 61,
+    35, 36, 48, 49, 57, 58, 62, 63
+};
+
+static int aaidct[8] = {
+    IFIX(0.3535533906), IFIX(0.4903926402),
+    IFIX(0.4619397663), IFIX(0.4157348062),
+    IFIX(0.3535533906), IFIX(0.2777851165),
+    IFIX(0.1913417162), IFIX(0.0975451610)
+};
+
+
+inline static void idctqtab(unsigned char *qin, int *qout)
+{
+    int i, j;
+
+    for (i = 0; i < 8; i++)
+	for (j = 0; j < 8; j++)
+	    qout[zig[i * 8 + j]] = qin[zig[i * 8 + j]] *
+		IMULT(aaidct[i], aaidct[j]);
+}
+
+inline static void scaleidctqtab(int *q, int sc)
+{
+    int i;
+
+    for (i = 0; i < 64; i++)
+	q[i] = IMULT(q[i], sc);
+}
+
+/* Reduce to the necessary minimum. FIXME */
+void init_qTable(struct usb_spca50x *spca50x, unsigned int qIndex)
+{
+    int i, j;
+    /* set up a quantization table */
+    for (i = 0; i < 2; i++) {
+	for (j = 0; j < 64; j++) {
+	    spca50x->maindecode.quant[i][j] =
+		GsmartQTable[qIndex * 2 + i][j];
+	}
+    }
+    idctqtab(spca50x->maindecode.
+	     quant[spca50x->maindecode.dscans[0].tq],
+	     spca50x->maindecode.dquant[0]);
+    idctqtab(spca50x->maindecode.
+	     quant[spca50x->maindecode.dscans[1].tq],
+	     spca50x->maindecode.dquant[1]);
+    idctqtab(spca50x->maindecode.
+	     quant[spca50x->maindecode.dscans[2].tq],
+	     spca50x->maindecode.dquant[2]);
+    /* rescale qtab */
+    //scaleidctqtab (spca50x->maindecode.dquant[0], IFIX (0.7));
+    //scaleidctqtab (spca50x->maindecode.dquant[1], IFIX (0.7));
+    //scaleidctqtab (spca50x->maindecode.dquant[2], IFIX (0.7));    
+}
+inline static void
+decode_mcus_PAC7311(struct in *in, int *dct, int n, struct scan *sc, int *maxp)
+{
+    struct dec_hufftbl *hu;
+    int i, r, t;
+    int le, bi;
+    char trash;
+
+    memset(dct, 0, n * 64 * sizeof(*dct));
+    le = in->left;
+    bi = in->bits;
+
+    while (n-- > 0) {
+	hu = sc->hudc.dhuff;
+	*dct++ = (sc->dc += DEC_REC(in, hu, r, t));
+
+	hu = sc->huac.dhuff;
+	i = 63;
+	while (i > 0) {
+	    t = DEC_REC(in, hu, r, t);
+	    if (t == 0 && r == 0) {
+		dct += i;
+		break;
+	    }
+	    dct += r;
+	    *dct++ = t;
+	    i -= r + 1;
+	}
+	*maxp++ = 64 - i;
+	if (n == sc->next)
+	    sc++;
+    }
+    trash = GETBITS(in, 8);
+    LEBI_PUT(in);
+}
+
+static int jpeg_decode422_PAC7311(struct spca50x_frame *myframe, int force_rgb)
+{
+    int mcusx, mcusy, mx, my;
+    int *dcts = myframe->dcts;
+    int *out = myframe->out;
+    int *max = myframe->max;
+    int bpp;
+    int framesize, frameUsize;
+    int k, j;
+    int nextline, nextuv, nextblk, nextnewline;
+    unsigned char *pic0, *pic1, *outv, *outu;
+    __u16 *pix1, *pix2;
+    int picy, picx, pocx, pocy;
+    unsigned char *U, *V;
+    int *outy, *inv, *inu;
+    int outy1, outy2;
+    int v, u, y1, v1, u1, u2;
+    int r_offset, g_offset, b_offset;
+
+    unsigned char *pic = myframe->data;	/* output surface */
+    unsigned char *buf = myframe->tmpbuffer;	/* input surface */
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    int softwidth = myframe->width;
+    int softheight = myframe->height;
+    //int method = myframe->method;
+    int format = myframe->format;
+    int cropx1 = myframe->cropx1;
+    int cropx2 = myframe->cropx2;
+    int cropy1 = myframe->cropy1;
+    int cropy2 = myframe->cropy2;
+    unsigned char *red = myframe->decoder->Red;
+    unsigned char *green = myframe->decoder->Green;
+    unsigned char *blue = myframe->decoder->Blue;
+    struct dec_data *decode = myframe->decoder;
+    if ((height & 7) || (width & 7))
+	return 1;
+    if (width < softwidth || height < softheight)
+	return 1;
+
+    mcusx = width >> 4;
+    mcusy = height >> 3;
+    framesize = softwidth * softheight;
+    frameUsize = framesize >> 2;
+    jpeg_reset_input_context(decode, buf, 1);
+
+    /* for each component. Reset dc values. */
+    dec_initscans(decode);
+    /* rgb or bgr like U or V that's the question */
+    if (force_rgb) {
+	U = pic + framesize;
+	V = U + frameUsize;
+	r_offset = 2;
+	g_offset = 1;
+	b_offset = 0;
+    } else {
+	V = pic + framesize;
+	U = V + frameUsize;
+	r_offset = 0;
+	g_offset = 1;
+	b_offset = 2;
+    }
+
+    /* Decode to the correct format. */
+    switch (format) {
+    case VIDEO_PALETTE_RGB565:
+	{
+	    bpp = 2;
+	    nextline = ((softwidth << 1) - 16);	// *bpp;
+	    nextblk = bpp * (softwidth << 3);
+	    nextnewline = softwidth;	// *bpp;
+	    for (my = 0, picy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0; mx < mcusx; mx++) {
+		    if (decode->info.dri && !--decode->info.nm)
+			if (dec_checkmarker(decode))
+			    return ERR_WRONG_MARKER;
+		    decode_mcus_PAC7311(&decode->in, dcts, 4, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[2]);
+			idct(dcts + 192,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[3]);
+
+			pix1 = (__u16 *) (pic + picx + picy);
+			pix2 = pix1 + nextnewline;
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+			for (j = 0; j < 4; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels Colors are treated as 411 */
+				/* get the UV colors need to change UV order for force rgb? */
+				if (force_rgb) {
+
+				    u = *inv++;
+				    v = *inu++;
+				} else {
+
+				    v = *inv++;
+				    u = *inu++;
+				}
+				/* MX color space why not? */
+				v1 = ((v << 10)
+				      + (v << 9))
+				    >> 10;
+				u1 = ((u <<
+				       8) + (u << 7) + (v << 9) + (v << 4))
+				    >> 10;
+				u2 = ((u << 11)
+				      + (u << 4))
+				    >> 10;
+				/* top pixel Right */
+				y1 = outy[outy1++];
+				*pix1++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+				/* top pixel Left */
+				y1 = outy[outy1++];
+				*pix1++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+
+				/* bottom pixel Right */
+				y1 = outy[outy2++];
+				*pix2++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+				/* bottom pixel Left */
+				y1 = outy[outy2++];
+				*pix2++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+
+			    }
+
+			    outy += 16;
+			    outy1 = 0;
+			    outy2 = 8;
+			    pix1 += nextline;
+			    pix2 += nextline;
+
+			}
+			picx += 16 * bpp;
+		    }
+		}
+		if (my >= cropy1)
+		    picy += nextblk;
+
+	    }
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_RGB32:
+    case VIDEO_PALETTE_RGB24:
+	{
+	    bpp = (format == VIDEO_PALETTE_RGB32) ? 4 : 3;
+	    nextline = bpp * ((softwidth << 1) - 16);
+	    nextblk = bpp * (softwidth << 3);
+	    nextnewline = bpp * softwidth;
+
+	    for (my = 0, picy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0; mx < mcusx; mx++) {
+		    if (decode->info.dri && !--decode->info.nm)
+			if (dec_checkmarker(decode))
+			    return ERR_WRONG_MARKER;
+		    decode_mcus_PAC7311(&decode->in, dcts, 4, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[2]);
+			idct(dcts + 192,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[3]);
+
+			pic0 = pic + picx + picy;
+			pic1 = pic0 + nextnewline;
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+
+			for (j = 0; j < 4; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels Colors are treated as 411 */
+
+				v = *inv++;
+				u = *inu++;
+
+				/* MX color space why not? */
+				v1 = ((v << 10)
+				      + (v << 9))
+				    >> 10;
+				u1 = ((u <<
+				       8) + (u << 7) + (v << 9) + (v << 4))
+				    >> 10;
+				u2 = ((u << 11)
+				      + (u << 4))
+				    >> 10;
+				/* top pixel Right */
+				y1 = outy[outy1++];
+				pic0[r_offset] = red[CLIP((y1 + v1))];
+				pic0[g_offset] = green[CLIP((y1 - u1))];
+				pic0[b_offset] = blue[CLIP((y1 + u2))];
+				pic0 += bpp;
+				/* top pixel Left */
+				y1 = outy[outy1++];
+				pic0[r_offset] = red[CLIP((y1 + v1))];
+				pic0[g_offset] = green[CLIP((y1 - u1))];
+				pic0[b_offset] = blue[CLIP((y1 + u2))];
+				pic0 += bpp;
+				/* bottom pixel Right */
+				y1 = outy[outy2++];
+				pic1[r_offset] = red[CLIP((y1 + v1))];
+				pic1[g_offset] = green[CLIP((y1 - u1))];
+				pic1[b_offset] = blue[CLIP((y1 + u2))];
+				pic1 += bpp;
+				/* bottom pixel Left */
+				y1 = outy[outy2++];
+				pic1[r_offset] = red[CLIP((y1 + v1))];
+				pic1[g_offset] = green[CLIP((y1 - u1))];
+				pic1[b_offset] = blue[CLIP((y1 + u2))];
+				pic1 += bpp;
+
+			    }
+
+			    outy += 16;
+			    outy1 = 0;
+			    outy2 = 8;
+			    pic0 += nextline;
+			    pic1 += nextline;
+
+			}
+
+			picx += 16 * bpp;
+		    }
+		}
+		if (my >= cropy1)
+		    picy += nextblk;
+
+	    }
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_YUV420P:
+	{
+	    nextline = (softwidth << 1) - 16;
+	    nextuv = (softwidth >> 1) - 8;
+	    nextblk = softwidth << 3;
+	    nextnewline = softwidth << 1;	//2
+	    for (my = 0, picy = 0, pocy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0, pocx = 0; mx < mcusx; mx++) {
+		    if (decode->info.dri && !--decode->info.nm)
+			if (dec_checkmarker(decode))
+			    return ERR_WRONG_MARKER;
+		    decode_mcus_PAC7311(&decode->in, dcts, 4, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[2]);
+			idct(dcts + 192,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[3]);
+
+			pic0 = pic + picx + picy;
+			pic1 = pic0 + softwidth;
+			outv = V + (pocx + pocy);
+			outu = U + (pocx + pocy);
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+			for (j = 0; j < 4; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels */
+
+				*pic0++ = CLIP(outy[outy1]);
+				outy1++;
+				*pic0++ = CLIP(outy[outy1]);
+				outy1++;
+				*pic1++ = CLIP(outy[outy2]);
+				outy2++;
+				*pic1++ = CLIP(outy[outy2]);
+				outy2++;
+				/* maybe one day yuv422P */
+				*outv++ = CLIP(128 + *inv);
+				inv++;
+				*outu++ = CLIP(128 + *inu);
+				inu++;
+			    }
+
+			    outy += 16;
+			    outy1 = 0;
+			    outy2 = 8;
+			    pic0 += nextline;
+			    pic1 += nextline;
+			    outv += nextuv;
+			    outu += nextuv;
+			}
+			picx += 16;
+			pocx += 8;
+		    }
+		}
+		if (my >= cropy1) {
+		    picy += nextblk;
+		    pocy += nextnewline;
+		}
+	    }
+	}
+	myframe->scanlength = (long) ((softwidth * softheight * 3) >> 1);
+	break;
+    default:
+	break;
+    }				// end case
+    return 0;
+}
+
+void init_jpeg_decoder(struct usb_spca50x *spca50x)
+{
+    unsigned int i, j, k, l;
+    int tc, th, tt, tac, tdc;
+    const unsigned char *ptr;
+    unsigned int qIndex = spca50x->qindex;
+    memcpy(spca50x->maindecode.comps, comp_template,
+	   MAXCOMP * sizeof(struct comp));
+    /* set up the huffman table */
+    ptr = (const unsigned char *) GsmartJPEGHuffmanTable;
+    l = GSMART_JPG_HUFFMAN_TABLE_LENGTH;
+    while (l > 0) {
+	int hufflen[16];
+	unsigned char huffvals[256];
+
+	tc = *ptr++;
+	th = tc & 15;
+	tc >>= 4;
+	tt = tc * 2 + th;
+	if (tc > 1 || th > 1) {
+	    //printf("died whilst setting up huffman table.\n");
+	    //abort();
+	}
+	for (i = 0; i < 16; i++)
+	    hufflen[i] = *ptr++;
+	l -= 1 + 16;
+	k = 0;
+	for (i = 0; i < 16; i++) {
+	    for (j = 0; j < (unsigned int) hufflen[i]; j++)
+		huffvals[k++] = *ptr++;
+	    l -= hufflen[i];
+	}
+	dec_makehuff(dhuff + tt, hufflen, huffvals);
+    }
+
+    /* set up the scan table */
+    ptr = (const unsigned char *) GsmartJPEGScanTable;
+    for (i = 0; i < 3; i++) {
+	spca50x->maindecode.dscans[i].cid = *ptr++;
+	tdc = *ptr++;
+	tac = tdc & 15;
+	tdc >>= 4;
+	if (tdc > 1 || tac > 1) {
+	    //printf("died whilst setting up scan table.\n");
+	    //abort();
+	}
+	/* for each component */
+	for (j = 0; j < 3; j++)
+	    if (spca50x->maindecode.comps[j].cid ==
+		spca50x->maindecode.dscans[i].cid)
+		break;
+
+	spca50x->maindecode.dscans[i].hv = spca50x->maindecode.comps[j].hv;
+	spca50x->maindecode.dscans[i].tq = spca50x->maindecode.comps[j].tq;
+	spca50x->maindecode.dscans[i].hudc.dhuff = dec_huffdc + tdc;
+	spca50x->maindecode.dscans[i].huac.dhuff = dec_huffac + tac;
+    }
+
+    if (spca50x->maindecode.dscans[0].cid != 1 ||
+	spca50x->maindecode.dscans[1].cid != 2 ||
+	spca50x->maindecode.dscans[2].cid != 3) {
+	//printf("invalid cid found.\n");
+	//abort();
+    }
+
+    if (spca50x->maindecode.dscans[0].hv != 0x22 ||
+	spca50x->maindecode.dscans[1].hv != 0x11 ||
+	spca50x->maindecode.dscans[2].hv != 0x11) {
+	//printf("invalid hv found.\n");
+	//abort();
+    }
+    spca50x->maindecode.dscans[0].next = 6 - 4;
+    spca50x->maindecode.dscans[1].next = 6 - 4 - 1;
+    spca50x->maindecode.dscans[2].next = 6 - 4 - 1 - 1;	/* 411 encoding */
+
+    /* set up a quantization table */
+    init_qTable(spca50x, qIndex);
+
+}
+
+
+
+static int bgr = 0;
+
+
+
+
+
+/* Gamma correction setting */
+/*	Gtable[0][n] -> 2.2
+*	Gtable[1][n] -> 1.7
+*	Gtable[2][n] -> 1.45
+*	Gtable[3][n] -> 1
+*	Gtable[4][n] -> 0.6896
+*	Gtable[5][n] -> 0.5882
+*	Gtable[6][n] -> 0.4545
+*	gCor coeff 0..6
+*/
+
+int spca50x_outpicture(struct spca50x_frame *myframe)
+{				/* general idea keep a frame in the temporary buffer from the tasklet */
+    /* decode with native format at input and asked format at output */
+    /* myframe->cameratype is the native input format */
+    /* myframe->format is the asked format */
+
+    struct pictparam *gCorrect = &myframe->pictsetting;
+    unsigned char *red = myframe->decoder->Red;
+    unsigned char *green = myframe->decoder->Green;
+    unsigned char *blue = myframe->decoder->Blue;
+    int width = 0;
+    int height = 0;
+    int done = 0;
+    int i;
+    if (gCorrect->change) {
+	if (gCorrect->change == 0x01) {
+	    /* Gamma setting change compute all case */
+	    memcpy(red, &GTable[gCorrect->gamma], 256);
+	    memcpy(green, &GTable[gCorrect->gamma], 256);
+	    memcpy(blue, &GTable[gCorrect->gamma], 256);
+	    for (i = 0; i < 256; i++) {
+		red[i] =
+		    CLIP(((red[i] +
+			   gCorrect->OffRed) * gCorrect->GRed) >> 8);
+		green[i] =
+		    CLIP(((green[i] +
+			   gCorrect->OffGreen) * gCorrect->GGreen) >> 8);
+		blue[i] =
+		    CLIP(((blue[i] +
+			   gCorrect->OffBlue) * gCorrect->GBlue) >> 8);
+
+	    }
+	    bgr = gCorrect->force_rgb;
+	    gCorrect->change = 0x00;
+	}
+	if (gCorrect->change == 0x02) {
+	    /* Red setting change compute Red Value */
+	    memcpy(red, &GTable[gCorrect->gamma], 256);
+	    for (i = 0; i < 256; i++) {
+		red[i] =
+		    CLIP(((red[i] +
+			   gCorrect->OffRed) * gCorrect->GRed) >> 8);
+	    }
+	    gCorrect->change &= ~0x02;
+	}
+	if (gCorrect->change == 0x04) {
+	    /* Green setting change compute Green Value */
+	    memcpy(green, &GTable[gCorrect->gamma], 256);
+	    for (i = 0; i < 256; i++) {
+		green[i] =
+		    CLIP(((green[i] +
+			   gCorrect->OffGreen) * gCorrect->GGreen) >> 8);
+	    }
+	    gCorrect->change &= ~0x04;
+	}
+	if (gCorrect->change == 0x08) {
+	    /* Blue setting change compute Blue Value */
+	    memcpy(blue, &GTable[gCorrect->gamma], 256);
+	    for (i = 0; i < 256; i++) {
+		blue[i] =
+		    CLIP(((blue[i] +
+			   gCorrect->OffBlue) * gCorrect->GBlue) >> 8);
+	    }
+	    gCorrect->change &= ~0x08;
+	}
+	if (gCorrect->change == 0x10) {
+	    /* force_rgb setting change   */
+	    bgr = gCorrect->force_rgb;
+	    gCorrect->change &= ~0x10;
+	}
+    }
+
+    switch (myframe->cameratype) {
+    case JPGC:
+
+	height = (myframe->data[11] << 8) | myframe->data[12];
+	width = (myframe->data[13] << 8) | myframe->data[14];
+	if (myframe->hdrheight != height || myframe->hdrwidth != width)
+	    done = ERR_CORRUPTFRAME;
+	else {
+	    //set info.dri struct should be kmalloc with the
+	    // instance camera
+	    myframe->decoder->info.dri = myframe->data[5];
+	    if (myframe->format == VIDEO_PALETTE_JPEG) {
+		memcpy(myframe->tmpbuffer, myframe->data,
+		       myframe->scanlength);
+		done = make_jpeg_conexant(myframe);
+	    } else {
+		memcpy(myframe->tmpbuffer,
+		       myframe->data + 39, myframe->scanlength - 39);
+		done = jpeg_decode422(myframe, bgr);
+	    }
+	}
+	break;
+    case JPGH:
+	width = (myframe->data[10] << 8) | myframe->data[11];
+	height = (myframe->data[12] << 8) | myframe->data[13];
+	/* some camera did not respond with the good height ie:Labtec Pro 240 -> 232 */
+	if (myframe->hdrwidth != width)
+	    done = ERR_CORRUPTFRAME;
+	else {
+	    // reset info.dri
+	    myframe->decoder->info.dri = 0;
+	    memcpy(myframe->tmpbuffer, myframe->data + 16,
+		   myframe->scanlength - 16);
+	    if (myframe->format == VIDEO_PALETTE_JPEG)
+		done = make_jpeg(myframe);
+	    else
+		done = jpeg_decode422(myframe, bgr);
+	}
+	break;
+    case JPGM:
+    case JPGS:
+	// reset info.dri
+	myframe->decoder->info.dri = 0;
+	memcpy(myframe->tmpbuffer, myframe->data, myframe->scanlength);
+	if (myframe->format == VIDEO_PALETTE_JPEG)
+	    done = make_jpeg(myframe);
+	else
+	    done = jpeg_decode422(myframe, bgr);
+
+	break;
+    case JPEG:
+	memcpy(myframe->tmpbuffer, myframe->data, myframe->scanlength);
+	if (myframe->format == VIDEO_PALETTE_JPEG)
+	    done = make_jpeg(myframe);
+	else
+	    done = jpeg_decode411(myframe, bgr);
+
+	break;
+    case PJPG:
+	if (myframe->format == VIDEO_PALETTE_RAW_JPEG)
+        done = pac7311_make_jpg(myframe);
+    else
+        done = pac7311_decode(myframe, bgr);
+	break;
+    case YUVY:
+    case YUYV:
+    case YYUV:
+	memcpy(myframe->tmpbuffer, myframe->data, myframe->scanlength);
+	done = yuv_decode(myframe, bgr);
+	break;
+    case YUY2:
+    	memcpy(myframe->tmpbuffer, myframe->data, myframe->scanlength);
+    	done= yvyu_translate(myframe,bgr);
+    	break;
+    case PGBRG:
+	done = pixart_decompress(myframe);
+	if (done < 0)
+	    break;
+	done = bayer_decode(myframe, bgr);
+	break;
+    case GBGR:
+	/* translate the tv8532 stream into GBRG stream */
+	tv8532_preprocess(myframe);
+	done = bayer_decode(myframe, bgr);
+	break;
+    case GBRG:
+	memcpy(myframe->tmpbuffer, myframe->data, myframe->scanlength);
+	done = bayer_decode(myframe, bgr);
+	break;
+    case S561:
+	if (myframe->data[1] & 0x10)
+	    decode_spca561(myframe->data, myframe->tmpbuffer,
+			   myframe->width, myframe->height);
+	else
+	    memcpy(myframe->tmpbuffer, myframe->data + 20,
+		   myframe->scanlength);
+
+	done = bayer_decode(myframe, bgr);
+	break;
+    case SN9C:
+	sonix_decompress(myframe);
+	done = bayer_decode(myframe, bgr);
+	break;
+    default:
+	done = -1;
+	break;
+    }
+    return done;
+}
+
+static int yuv_decode(struct spca50x_frame *myframe, int force_rgb)
+{
+
+    int r_offset, g_offset, b_offset;
+    int my, mx;			/* scan input surface */
+    unsigned char *pic1;	/* output surface */
+    __u16 *pix1, *pix2;		/* same for 16 bits output */
+
+    unsigned char *U, *V;	/* chroma output pointer */
+    int inuv, inv, pocx;	/* offset chroma input */
+    int iny, iny1;		/* offset luma input */
+    int nextinline, nextoutline;
+    int u1, v1, rg;
+    unsigned char y, y1;
+    char u, v;
+    unsigned char *pic = myframe->data;	/* output surface */
+    unsigned char *buf = myframe->tmpbuffer;	/* input surface */
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    int softwidth = myframe->width;
+    int softheight = myframe->height;
+    //int method = myframe->method;
+    int format = myframe->format;
+    int cropx1 = myframe->cropx1;
+    int cropx2 = myframe->cropx2;
+    int cropy1 = myframe->cropy1;
+    int cropy2 = myframe->cropy2;
+    unsigned char *red = myframe->decoder->Red;
+    unsigned char *green = myframe->decoder->Green;
+    unsigned char *blue = myframe->decoder->Blue;
+    int bpp;
+    int framesize, frameUsize;
+
+    framesize = softwidth * softheight;
+    frameUsize = framesize >> 2;
+    /* rgb or bgr like U or V that's the question */
+    if (force_rgb) {
+	U = pic + framesize;
+	V = U + frameUsize;
+	r_offset = 2;
+	g_offset = 1;
+	b_offset = 0;
+    } else {
+	V = pic + framesize;
+	U = V + frameUsize;
+	r_offset = 0;
+	g_offset = 1;
+	b_offset = 2;
+    }
+    switch (myframe->cameratype) {
+    case YUVY:{
+	    iny = 0;			   /********* iny **********/
+	    inuv = width;		   /*** inuv **** inv ******/
+	    nextinline = 3 * width;
+	    inv = (nextinline >> 1);
+	    iny1 = width << 1;		   /********* iny1 *********/
+	}
+	break;
+    case YUYV:{
+	    iny = 0;			   /********* iny **********/
+	    inuv = width;		   /*** inuv **** iny1 *****/
+	    nextinline = 3 * width;
+	    iny1 = (nextinline >> 1);
+	    inv = iny1 + width;		    /*** iny1 **** inv ******/
+	}
+	break;
+    case YYUV:{
+	    iny = 0;			   /********* iny **********/
+	    iny1 = width;		   /********* iny1 *********/
+	    inuv = width << 1;		   /*** inuv **** inv ******/
+	    inv = inuv + (width >> 1);
+	    nextinline = 3 * width;
+	}
+	break;
+    default:{
+	    iny = 0;		/* make compiler happy */
+	    iny1 = 0;
+	    inuv = 0;
+	    inv = 0;
+	    nextinline = 0;
+	}
+	break;
+    }
+
+    /* Decode to the correct format. */
+    switch (format) {
+    case VIDEO_PALETTE_RGB565:
+	{
+	    bpp = 2;
+	    /* initialize */
+
+	    pix1 = (__u16 *) pic;
+	    pix2 = pix1 + softwidth;
+
+
+	    for (my = 0; my < height; my += 2) {
+		for (mx = 0, pocx = 0; mx < width; mx += 2, pocx++) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			/* yes decode */
+			if (force_rgb) {
+			    u = buf[inuv + pocx];
+			    v = buf[inv + pocx];
+			} else {
+			    v = buf[inuv + pocx];
+			    u = buf[inv + pocx];
+			}
+			v1 = ((v << 10) + (v << 9)) >> 10;
+			rg = ((u << 8) + (u << 7) +
+			      (v << 9) + (v << 4)) >> 10;
+			u1 = ((u << 11) + (u << 4)) >> 10;
+
+
+			/* top pixel Right */
+			y1 = 128 + buf[iny + mx];
+			*pix1++ = ((red[CLIP((y1 + v1))]
+				    & 0xF8) >> 3 |
+				   ((green
+				     [CLIP((y1 - rg))] &
+				     0xFC) << 3) |
+				   ((blue[CLIP((y1 + u1))] & 0xF8) << 8));
+			/* top pixel Left */
+			y1 = 128 + buf[iny + mx + 1];
+			*pix1++ = ((red[CLIP((y1 + v1))]
+				    & 0xF8) >> 3 |
+				   ((green
+				     [CLIP((y1 - rg))] &
+				     0xFC) << 3) |
+				   ((blue[CLIP((y1 + u1))] & 0xF8) << 8));
+			/* bottom pixel Right */
+			y1 = 128 + buf[iny1 + mx];
+			*pix2++ = ((red[CLIP((y1 + v1))]
+				    & 0xF8) >> 3 |
+				   ((green
+				     [CLIP((y1 - rg))] &
+				     0xFC) << 3) |
+				   ((blue[CLIP((y1 + u1))] & 0xF8) << 8));
+			/* bottom pixel Left */
+			y1 = 128 + buf[iny1 + mx + 1];
+			*pix2++ = ((red[CLIP((y1 + v1))]
+				    & 0xF8) >> 3 |
+				   ((green
+				     [CLIP((y1 - rg))] &
+				     0xFC) << 3) |
+				   ((blue[CLIP((y1 + u1))] & 0xF8) << 8));
+
+
+
+
+		    }		// end test decode
+		}		// end mx loop
+		iny += nextinline;
+		inuv += nextinline;
+		inv += nextinline;
+		iny1 += nextinline;
+		if (my >= cropy1) {
+		    /* are we in a decode surface move the output pointer */
+		    pix1 += softwidth;
+		    pix2 += softwidth;
+		}
+
+	    }			// end my loop
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_RGB32:
+    case VIDEO_PALETTE_RGB24:
+	{
+	    bpp = (format == VIDEO_PALETTE_RGB32) ? 4 : 3;
+	    /* initialize */
+	    nextoutline = bpp * softwidth;
+	    pic1 = pic + nextoutline;
+
+
+	    for (my = 0; my < height; my += 2) {
+		for (mx = 0, pocx = 0; mx < width; mx += 2, pocx++) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			/* yes decode */
+			v = buf[inuv + pocx];
+			u = buf[inv + pocx];
+
+			v1 = ((v << 10) + (v << 9)) >> 10;
+			rg = ((u << 8) + (u << 7) +
+			      (v << 9) + (v << 4)) >> 10;
+			u1 = ((u << 11) + (u << 4)) >> 10;
+
+			y = 128 + buf[iny + mx];
+			/* top pixel Right */
+
+			pic[r_offset] = red[CLIP((y + v1))];
+			pic[g_offset] = green[CLIP((y - rg))];
+			pic[b_offset] = blue[CLIP((y + u1))];
+			pic += bpp;
+			/* top pixel Left */
+			y = 128 + buf[iny + mx + 1];
+			pic[r_offset] = red[CLIP((y + v1))];
+			pic[g_offset] = green[CLIP((y - rg))];
+			pic[b_offset] = blue[CLIP((y + u1))];
+			pic += bpp;
+			/* bottom pixel Right */
+			y1 = 128 + buf[iny1 + mx];
+			pic1[r_offset] = red[CLIP((y1 + v1))];
+			pic1[g_offset] = green[CLIP((y1 - rg))];
+			pic1[b_offset] = blue[CLIP((y1 + u1))];
+			pic1 += bpp;
+			/* bottom pixel Left */
+			y1 = 128 + buf[iny1 + mx + 1];
+			pic1[r_offset] = red[CLIP((y1 + v1))];
+			pic1[g_offset] = green[CLIP((y1 - rg))];
+			pic1[b_offset] = blue[CLIP((y1 + u1))];
+			pic1 += bpp;
+
+
+
+
+		    }		// end test decode
+		}		// end mx loop
+		iny += nextinline;
+		inuv += nextinline;
+		inv += nextinline;
+		iny1 += nextinline;
+		if (my >= cropy1) {
+		    /* are we in a decode surface move the output pointer */
+		    pic += nextoutline;
+		    pic1 += nextoutline;
+		}
+
+	    }			// end my loop
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_YUV420P:
+	{
+	    /* initialize */
+	    pic1 = pic + softwidth;
+
+	    for (my = 0; my < height; my += 2) {
+		for (mx = 0, pocx = 0; mx < width; mx += 2, pocx++) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			/* yes decode */
+			*V++ = 128 + buf[inuv + pocx];
+			*U++ = 128 + buf[inv + pocx];
+			*pic++ = 128 + buf[iny + mx];
+			*pic++ = 128 + buf[iny + mx + 1];
+			*pic1++ = 128 + buf[iny1 + mx];
+			*pic1++ = 128 + buf[iny1 + mx + 1];
+
+		    }		// end test decode
+		}		// end mx loop
+		iny += nextinline;
+		inuv += nextinline;
+		inv += nextinline;
+		iny1 += nextinline;
+
+		if (my >= cropy1) {
+		    /* are we in a decode surface move the output pointer */
+		    pic += softwidth;
+		    pic1 += softwidth;
+		}
+
+	    }			// end my loop
+
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * 3) >> 1;
+	break;
+    case VIDEO_PALETTE_YUYV:
+	bpp = 2;
+	nextoutline = bpp * softwidth;
+	pic1 = pic + nextoutline;
+	for (my = 0; my < height; my += 2) {
+	    for (mx = 0, pocx = 0; mx < width; mx += 2, pocx++) {
+		/* test if we need to decode */
+		if ((my >= cropy1)
+		    && (my < height - cropy2)
+		    && (mx >= cropx1)
+		    && (mx < width - cropx2)) {
+		    /* yes decode */
+		    *pic++ = 128 + buf[iny + mx];
+		    *pic++ = 128 + buf[inuv + pocx];	//V
+		    *pic++ = 128 + buf[iny + mx + 1];
+		    *pic++ = 128 + buf[inv + pocx];	//U
+
+		    *pic1++ = 128 + buf[iny1 + mx];
+		    *pic1++ = 128 + buf[inuv + pocx];	//V   
+		    *pic1++ = 128 + buf[iny1 + mx + 1];
+		    *pic++ = 128 + buf[inv + pocx];	//U
+
+		}		// end test decode
+	    }			// end mx loop
+	    iny += nextinline;
+	    inuv += nextinline;
+	    inv += nextinline;
+	    iny1 += nextinline;
+
+	    if (my >= cropy1) {
+		/* are we in a decode surface move the output pointer */
+		pic += nextoutline;
+		pic1 += nextoutline;
+	    }
+
+	}			// end my loop
+
+	myframe->scanlength = (long) (softwidth * softheight * 2);
+	break;
+
+    default:
+	break;
+    }				// end case
+    return 0;
+}
+
+/*
+ *    linux/drivers/video/fbcon-jpegdec.c - a tiny jpeg decoder.
+ *      
+ *      (w) August 2001 by Michael Schroeder, <mls@suse.de>
+ *
+ *    I severly gutted this beast and hardcoded it to the palette and subset
+ *    of jpeg needed for the spca50x driver. Also converted it from K&R style
+ *    C to a more modern form ;). Michael can't be blamed for what is left.
+ *    All nice features are his, all bugs are mine. - till
+ *
+ *    Change color space converter for YUVP and RGB -  
+ *    Rework the IDCT implementation for best speed, cut test in the loop but instead
+ *	more copy and paste code :)
+ *    For more details about idct look at :
+ *    http://rnvs.informatik.tu-chemnitz.de/~jan/MPEG/HTML/IDCT.html 
+ *    12/12/2003 mxhaard@magic.fr
+ *	add make jpeg from header (mxhaard 20/09/2004)
+ *	add jpeg_decode for 422 stream (mxhaard 01/10/2004)       
+ */
+static int jpeg_decode411(struct spca50x_frame *myframe, int force_rgb)
+{
+    int mcusx, mcusy, mx, my;
+    int *dcts = myframe->dcts;
+    int *out = myframe->out;
+    int *max = myframe->max;
+//      int i;
+    int bpp;
+    int framesize, frameUsize;
+    int k, j;
+    int nextline, nextuv, nextblk, nextnewline;
+    unsigned char *pic0, *pic1, *outv, *outu;
+    __u16 *pix1, *pix2;
+    int picy, picx, pocx, pocy;
+    unsigned char *U, *V;
+    int *outy, *inv, *inu;
+    int outy1, outy2;
+    int v, u, y1, v1, u1, u2;
+    int r_offset, g_offset, b_offset;
+
+    unsigned char *pic = myframe->data;	/* output surface */
+    unsigned char *buf = myframe->tmpbuffer;	/* input surface */
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    int softwidth = myframe->width;
+    int softheight = myframe->height;
+    //int method = myframe->method;
+    int format = myframe->format;
+    int cropx1 = myframe->cropx1;
+    int cropx2 = myframe->cropx2;
+    int cropy1 = myframe->cropy1;
+    int cropy2 = myframe->cropy2;
+    unsigned char *red = myframe->decoder->Red;
+    unsigned char *green = myframe->decoder->Green;
+    unsigned char *blue = myframe->decoder->Blue;
+    struct dec_data *decode = myframe->decoder;
+
+    if ((height & 15) || (width & 15))
+	return 1;
+    if (width < softwidth || height < softheight)
+	return 1;
+
+    mcusx = width >> 4;
+    mcusy = height >> 4;
+    framesize = softwidth * softheight;
+    frameUsize = framesize >> 2;
+    jpeg_reset_input_context(decode, buf, 0);
+
+    /* for each component. Reset dc values. */
+    //for (i = 0; i < 3; i++)
+    //dscans[i].dc = 0;
+    dec_initscans(decode);
+    /* rgb or bgr like U or V that's the question */
+    if (force_rgb) {
+	U = pic + framesize;
+	V = U + frameUsize;
+	r_offset = 2;
+	g_offset = 1;
+	b_offset = 0;
+    } else {
+	V = pic + framesize;
+	U = V + frameUsize;
+	r_offset = 0;
+	g_offset = 1;
+	b_offset = 2;
+    }
+
+    /* Decode to the correct format. */
+    switch (format) {
+    case VIDEO_PALETTE_RGB565:
+	{
+	    bpp = 2;
+	    nextline = ((softwidth << 1) - 16);	// *bpp;
+	    nextblk = bpp * (softwidth << 4);
+	    nextnewline = softwidth;	// *bpp;
+	    for (my = 0, picy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0; mx < mcusx; mx++) {
+
+		    decode_mcus(&decode->in, dcts, 6, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 128,
+			     decode->dquant[0], IFIX(128.5), max[2]);
+			idct(dcts + 192,
+			     out + 192,
+			     decode->dquant[0], IFIX(128.5), max[3]);
+			idct(dcts + 256,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[4]);
+			idct(dcts + 320,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[5]);
+			pix1 = (__u16 *) (pic + picx + picy);
+			pix2 = pix1 + nextnewline;
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+			for (j = 0; j < 8; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels */
+				/* get the UV colors need to change UV order for force rgb? */
+				if (force_rgb) {
+				    u = *inv++;
+				    v = *inu++;
+				} else {
+				    v = *inv++;
+				    u = *inu++;
+				}
+				/* MX color space why not? */
+				v1 = ((v << 10)
+				      + (v << 9))
+				    >> 10;
+				u1 = ((u <<
+				       8) + (u << 7) + (v << 9) + (v << 4))
+				    >> 10;
+				u2 = ((u << 11)
+				      + (u << 4))
+				    >> 10;
+				/* top pixel Right */
+				y1 = outy[outy1++];
+				*pix1++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+				/* top pixel Left */
+				y1 = outy[outy1++];
+				*pix1++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+
+				/* bottom pixel Right */
+				y1 = outy[outy2++];
+				*pix2++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+				/* bottom pixel Left */
+				y1 = outy[outy2++];
+				*pix2++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+
+			    }
+			    if (j == 3) {
+				outy = out + 128;
+			    } else {
+				outy += 16;
+			    }
+			    outy1 = 0;
+			    outy2 = 8;
+			    pix1 += nextline;
+			    pix2 += nextline;
+
+			}
+			picx += 16 * bpp;
+		    }
+		}
+		if (my >= cropy1)
+		    picy += nextblk;
+
+	    }
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_RGB32:
+    case VIDEO_PALETTE_RGB24:
+	{
+	    bpp = (format == VIDEO_PALETTE_RGB32) ? 4 : 3;
+	    nextline = bpp * ((softwidth << 1) - 16);
+	    nextblk = bpp * (softwidth << 4);
+	    nextnewline = bpp * softwidth;
+	    for (my = 0, picy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0; mx < mcusx; mx++) {
+
+		    decode_mcus(&decode->in, dcts, 6, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 128,
+			     decode->dquant[0], IFIX(128.5), max[2]);
+			idct(dcts + 192,
+			     out + 192,
+			     decode->dquant[0], IFIX(128.5), max[3]);
+			idct(dcts + 256,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[4]);
+			idct(dcts + 320,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[5]);
+			pic0 = pic + picx + picy;
+			pic1 = pic0 + nextnewline;
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+			for (j = 0; j < 8; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels */
+				/* get the UV colors need to change UV order for force rgb? */
+				v = *inv++;
+				u = *inu++;
+				/* MX color space why not? */
+				v1 = ((v << 10)
+				      + (v << 9))
+				    >> 10;
+				u1 = ((u <<
+				       8) + (u << 7) + (v << 9) + (v << 4))
+				    >> 10;
+				u2 = ((u << 11)
+				      + (u << 4))
+				    >> 10;
+				/* top pixel Right */
+				y1 = outy[outy1++];
+				pic0[r_offset] = red[CLIP((y1 + v1))];
+				pic0[g_offset] = green[CLIP((y1 - u1))];
+				pic0[b_offset] = blue[CLIP((y1 + u2))];
+				pic0 += bpp;
+				/* top pixel Left */
+				y1 = outy[outy1++];
+				pic0[r_offset] = red[CLIP((y1 + v1))];
+				pic0[g_offset] = green[CLIP((y1 - u1))];
+				pic0[b_offset] = blue[CLIP((y1 + u2))];
+				pic0 += bpp;
+				/* bottom pixel Right */
+				y1 = outy[outy2++];
+				pic1[r_offset] = red[CLIP((y1 + v1))];
+				pic1[g_offset] = green[CLIP((y1 - u1))];
+				pic1[b_offset] = blue[CLIP((y1 + u2))];
+				pic1 += bpp;
+				/* bottom pixel Left */
+				y1 = outy[outy2++];
+				pic1[r_offset] = red[CLIP((y1 + v1))];
+				pic1[g_offset] = green[CLIP((y1 - u1))];
+				pic1[b_offset] = blue[CLIP((y1 + u2))];
+				pic1 += bpp;
+
+			    }
+			    if (j == 3) {
+				outy = out + 128;
+			    } else {
+				outy += 16;
+			    }
+			    outy1 = 0;
+			    outy2 = 8;
+			    pic0 += nextline;
+			    pic1 += nextline;
+
+			}
+			picx += 16 * bpp;
+		    }
+		}
+		if (my >= cropy1)
+		    picy += nextblk;
+
+	    }
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_YUV420P:
+	{
+	    nextline = (softwidth << 1) - 16;
+	    nextuv = (softwidth >> 1) - 8;
+	    nextblk = softwidth << 4;
+	    nextnewline = softwidth << 2;
+	    for (my = 0, picy = 0, pocy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0, pocx = 0; mx < mcusx; mx++) {
+		    decode_mcus(&decode->in, dcts, 6, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 128,
+			     decode->dquant[0], IFIX(128.5), max[2]);
+			idct(dcts + 192,
+			     out + 192,
+			     decode->dquant[0], IFIX(128.5), max[3]);
+			idct(dcts + 256,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[4]);
+			idct(dcts + 320,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[5]);
+
+			pic0 = pic + picx + picy;
+			pic1 = pic0 + softwidth;
+			outv = V + (pocx + pocy);
+			outu = U + (pocx + pocy);
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+			for (j = 0; j < 8; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels */
+
+				*pic0++ = CLIP(outy[outy1]);
+				outy1++;
+				*pic0++ = CLIP(outy[outy1]);
+				outy1++;
+				*pic1++ = CLIP(outy[outy2]);
+				outy2++;
+				*pic1++ = CLIP(outy[outy2]);
+				outy2++;
+				*outv++ = CLIP(128 + *inv);
+				inv++;
+				*outu++ = CLIP(128 + *inu);
+				inu++;
+			    }
+			    if (j == 3) {
+				outy = out + 128;
+			    } else {
+				outy += 16;
+			    }
+			    outy1 = 0;
+			    outy2 = 8;
+			    pic0 += nextline;
+			    pic1 += nextline;
+			    outv += nextuv;
+			    outu += nextuv;
+			}
+			picx += 16;
+			pocx += 8;
+		    }
+		}
+		if (my >= cropy1) {
+		    picy += nextblk;
+		    pocy += nextnewline;
+		}
+	    }
+	}
+	myframe->scanlength = (long) ((softwidth * softheight * 3) >> 1);
+	break;
+    default:
+	break;
+    }				// end case
+    return 0;
+}
+
+static int jpeg_decode422(struct spca50x_frame *myframe, int force_rgb)
+{
+    int mcusx, mcusy, mx, my;
+    int *dcts = myframe->dcts;
+    int *out = myframe->out;
+    int *max = myframe->max;
+    int bpp;
+    int framesize, frameUsize;
+    int k, j;
+    int nextline, nextuv, nextblk, nextnewline;
+    unsigned char *pic0, *pic1, *outv, *outu;
+    __u16 *pix1, *pix2;
+    int picy, picx, pocx, pocy;
+    unsigned char *U, *V;
+    int *outy, *inv, *inu;
+    int outy1, outy2;
+    int v, u, y1, v1, u1, u2;
+    int r_offset, g_offset, b_offset;
+
+    unsigned char *pic = myframe->data;	/* output surface */
+    unsigned char *buf = myframe->tmpbuffer;	/* input surface */
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    int softwidth = myframe->width;
+    int softheight = myframe->height;
+    //int method = myframe->method;
+    int format = myframe->format;
+    int cropx1 = myframe->cropx1;
+    int cropx2 = myframe->cropx2;
+    int cropy1 = myframe->cropy1;
+    int cropy2 = myframe->cropy2;
+    unsigned char *red = myframe->decoder->Red;
+    unsigned char *green = myframe->decoder->Green;
+    unsigned char *blue = myframe->decoder->Blue;
+    struct dec_data *decode = myframe->decoder;
+    if ((height & 7) || (width & 7))
+	return 1;
+    if (width < softwidth || height < softheight)
+	return 1;
+
+    mcusx = width >> 4;
+    mcusy = height >> 3;
+    framesize = softwidth * softheight;
+    frameUsize = framesize >> 2;
+    jpeg_reset_input_context(decode, buf, 1);
+
+    /* for each component. Reset dc values. */
+    dec_initscans(decode);
+    /* rgb or bgr like U or V that's the question */
+    if (force_rgb) {
+	U = pic + framesize;
+	V = U + frameUsize;
+	r_offset = 2;
+	g_offset = 1;
+	b_offset = 0;
+    } else {
+	V = pic + framesize;
+	U = V + frameUsize;
+	r_offset = 0;
+	g_offset = 1;
+	b_offset = 2;
+    }
+
+    /* Decode to the correct format. */
+    switch (format) {
+    case VIDEO_PALETTE_RGB565:
+	{
+	    bpp = 2;
+	    nextline = ((softwidth << 1) - 16);	// *bpp;
+	    nextblk = bpp * (softwidth << 3);
+	    nextnewline = softwidth;	// *bpp;
+	    for (my = 0, picy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0; mx < mcusx; mx++) {
+		    if (decode->info.dri && !--decode->info.nm)
+			if (dec_checkmarker(decode))
+			    return ERR_WRONG_MARKER;
+		    decode_mcus(&decode->in, dcts, 4, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[2]);
+			idct(dcts + 192,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[3]);
+
+			pix1 = (__u16 *) (pic + picx + picy);
+			pix2 = pix1 + nextnewline;
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+			for (j = 0; j < 4; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels Colors are treated as 411 */
+				/* get the UV colors need to change UV order for force rgb? */
+				if (force_rgb) {
+
+				    u = *inv++;
+				    v = *inu++;
+				} else {
+
+				    v = *inv++;
+				    u = *inu++;
+				}
+				/* MX color space why not? */
+				v1 = ((v << 10)
+				      + (v << 9))
+				    >> 10;
+				u1 = ((u <<
+				       8) + (u << 7) + (v << 9) + (v << 4))
+				    >> 10;
+				u2 = ((u << 11)
+				      + (u << 4))
+				    >> 10;
+				/* top pixel Right */
+				y1 = outy[outy1++];
+				*pix1++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+				/* top pixel Left */
+				y1 = outy[outy1++];
+				*pix1++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+
+				/* bottom pixel Right */
+				y1 = outy[outy2++];
+				*pix2++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+				/* bottom pixel Left */
+				y1 = outy[outy2++];
+				*pix2++ = ((red[CLIP((y1 + v1))]
+					    & 0xF8)
+					   >> 3 |
+					   ((green[CLIP((y1 - u1))] & 0xFC)
+					    << 3) | ((blue[CLIP((y1 + u2))]
+						      & 0xF8) << 8));
+
+			    }
+
+			    outy += 16;
+			    outy1 = 0;
+			    outy2 = 8;
+			    pix1 += nextline;
+			    pix2 += nextline;
+
+			}
+			picx += 16 * bpp;
+		    }
+		}
+		if (my >= cropy1)
+		    picy += nextblk;
+
+	    }
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_RGB32:
+    case VIDEO_PALETTE_RGB24:
+	{
+	    bpp = (format == VIDEO_PALETTE_RGB32) ? 4 : 3;
+	    nextline = bpp * ((softwidth << 1) - 16);
+	    nextblk = bpp * (softwidth << 3);
+	    nextnewline = bpp * softwidth;
+
+	    for (my = 0, picy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0; mx < mcusx; mx++) {
+		    if (decode->info.dri && !--decode->info.nm)
+			if (dec_checkmarker(decode))
+			    return ERR_WRONG_MARKER;
+		    decode_mcus(&decode->in, dcts, 4, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[2]);
+			idct(dcts + 192,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[3]);
+
+			pic0 = pic + picx + picy;
+			pic1 = pic0 + nextnewline;
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+
+			for (j = 0; j < 4; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels Colors are treated as 411 */
+
+				v = *inv++;
+				u = *inu++;
+
+				/* MX color space why not? */
+				v1 = ((v << 10)
+				      + (v << 9))
+				    >> 10;
+				u1 = ((u <<
+				       8) + (u << 7) + (v << 9) + (v << 4))
+				    >> 10;
+				u2 = ((u << 11)
+				      + (u << 4))
+				    >> 10;
+				/* top pixel Right */
+				y1 = outy[outy1++];
+				pic0[r_offset] = red[CLIP((y1 + v1))];
+				pic0[g_offset] = green[CLIP((y1 - u1))];
+				pic0[b_offset] = blue[CLIP((y1 + u2))];
+				pic0 += bpp;
+				/* top pixel Left */
+				y1 = outy[outy1++];
+				pic0[r_offset] = red[CLIP((y1 + v1))];
+				pic0[g_offset] = green[CLIP((y1 - u1))];
+				pic0[b_offset] = blue[CLIP((y1 + u2))];
+				pic0 += bpp;
+				/* bottom pixel Right */
+				y1 = outy[outy2++];
+				pic1[r_offset] = red[CLIP((y1 + v1))];
+				pic1[g_offset] = green[CLIP((y1 - u1))];
+				pic1[b_offset] = blue[CLIP((y1 + u2))];
+				pic1 += bpp;
+				/* bottom pixel Left */
+				y1 = outy[outy2++];
+				pic1[r_offset] = red[CLIP((y1 + v1))];
+				pic1[g_offset] = green[CLIP((y1 - u1))];
+				pic1[b_offset] = blue[CLIP((y1 + u2))];
+				pic1 += bpp;
+
+			    }
+
+			    outy += 16;
+			    outy1 = 0;
+			    outy2 = 8;
+			    pic0 += nextline;
+			    pic1 += nextline;
+
+			}
+
+			picx += 16 * bpp;
+		    }
+		}
+		if (my >= cropy1)
+		    picy += nextblk;
+
+	    }
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_YUV420P:
+	{
+	    nextline = (softwidth << 1) - 16;
+	    nextuv = (softwidth >> 1) - 8;
+	    nextblk = softwidth << 3;
+	    nextnewline = softwidth << 1;	//2
+	    for (my = 0, picy = 0, pocy = 0; my < mcusy; my++) {
+		for (mx = 0, picx = 0, pocx = 0; mx < mcusx; mx++) {
+		    if (decode->info.dri && !--decode->info.nm)
+			if (dec_checkmarker(decode))
+			    return ERR_WRONG_MARKER;
+		    decode_mcus(&decode->in, dcts, 4, decode->dscans, max);
+		    if ((my >= cropy1)
+			&& (my < mcusy - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < mcusx - cropx2)) {
+			idct(dcts, out,
+			     decode->dquant[0], IFIX(128.5), max[0]);
+			idct(dcts + 64,
+			     out + 64,
+			     decode->dquant[0], IFIX(128.5), max[1]);
+			idct(dcts + 128,
+			     out + 256,
+			     decode->dquant[1], IFIX(0.5), max[2]);
+			idct(dcts + 192,
+			     out + 320,
+			     decode->dquant[2], IFIX(0.5), max[3]);
+
+			pic0 = pic + picx + picy;
+			pic1 = pic0 + softwidth;
+			outv = V + (pocx + pocy);
+			outu = U + (pocx + pocy);
+			outy = out;
+			outy1 = 0;
+			outy2 = 8;
+			inv = out + 64 * 4;
+			inu = out + 64 * 5;
+			for (j = 0; j < 4; j++) {
+			    for (k = 0; k < 8; k++) {
+				if (k == 4) {
+				    outy1 += 56;
+				    outy2 += 56;
+				}
+				/* outup 4 pixels */
+
+				*pic0++ = CLIP(outy[outy1]);
+				outy1++;
+				*pic0++ = CLIP(outy[outy1]);
+				outy1++;
+				*pic1++ = CLIP(outy[outy2]);
+				outy2++;
+				*pic1++ = CLIP(outy[outy2]);
+				outy2++;
+				/* maybe one day yuv422P */
+				*outv++ = CLIP(128 + *inv);
+				inv++;
+				*outu++ = CLIP(128 + *inu);
+				inu++;
+			    }
+
+			    outy += 16;
+			    outy1 = 0;
+			    outy2 = 8;
+			    pic0 += nextline;
+			    pic1 += nextline;
+			    outv += nextuv;
+			    outu += nextuv;
+			}
+			picx += 16;
+			pocx += 8;
+		    }
+		}
+		if (my >= cropy1) {
+		    picy += nextblk;
+		    pocy += nextnewline;
+		}
+	    }
+	}
+	myframe->scanlength = (long) ((softwidth * softheight * 3) >> 1);
+	break;
+    default:
+	break;
+    }				// end case
+    return 0;
+}
+
+// y=0.656g+0.125b+0.226r
+
+#define RGB24_TO_Y(r,g,b) (CLIP(\
+	(((g) <<9)+((g)<<7)+((g)<<5)+((b)<<7)+((r)<<8)-((r)<<4)-((r)<<3))>>10))
+
+// v=(r-y)0.656
+#define YR_TO_V(r,y) (128 + \
+	(((((r)-(y)) << 9 )+(((r)-(y)) << 7 )+(((r)-(y)) << 5 )) >> 10))
+
+// u=(b-y)0.5   
+#define YB_TO_U(b,y) (128 + \
+	(((b)-(y)) >> 1))
+
+#define PACKRGB16(r,g,b) (__u16) ((((b) & 0xF8) << 8 ) | (((g) & 0xFC) << 3 ) | (((r) & 0xF8) >> 3 ))
+
+
+static int bayer_decode(struct spca50x_frame *myframe, int force_rgb)
+{
+
+    int r_offset, g_offset, b_offset;
+    int my, mx;			/* scan input surface */
+    unsigned char *pic1;	/* output surface */
+    __u16 *pix1, *pix2;		/* same for 16 bits output */
+    unsigned char *U, *V;	/* chroma output pointer */
+    unsigned char inr, ing1, ing2, inb, ing;	/* srgb input */
+    int inl, inl1;		/* offset line input */
+    int nextinline, nextoutline;
+    unsigned char r, b, y1, y2, y3, y4;
+    /*kernel matrix 4x4 */
+    unsigned char G00, R10, G20, R30, B01, G02, B03, G31, R32, G13,
+	B23, G33;
+    unsigned char r1, g1, b1, r2, g2, b2, r3, g3, b3, r4, g4, b4;
+    int bpp;
+
+    unsigned char *pic = myframe->data;	/* output surface */
+    unsigned char *buf = myframe->tmpbuffer;	/* input surface */
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    int softwidth = myframe->width;
+    int softheight = myframe->height;
+    //int method = myframe->method;
+    int format = myframe->format;
+    int cropx1 = myframe->cropx1;
+    int cropx2 = myframe->cropx2;
+    int cropy1 = myframe->cropy1;
+    int cropy2 = myframe->cropy2;
+    unsigned char *red = myframe->decoder->Red;
+    unsigned char *green = myframe->decoder->Green;
+    unsigned char *blue = myframe->decoder->Blue;
+    int framesize, frameUsize;
+    inr = ing1 = ing2 = ing = inb = r = b = 0;	//compiler maybe happy !!
+    framesize = softwidth * softheight;
+    frameUsize = framesize >> 2;
+    /* rgb or bgr like U or V that's the question */
+    if (force_rgb) {
+	V = pic + framesize;
+	U = V + frameUsize;
+	r_offset = 0;
+	g_offset = 1;
+	b_offset = 2;
+    } else {
+	U = pic + framesize;
+	V = U + frameUsize;
+	r_offset = 2;
+	g_offset = 1;
+	b_offset = 0;
+    }
+    /* initialize input pointer */
+    inl = 0;
+    inl1 = width;
+    nextinline = width << 1;
+    /* Decode to the correct format. */
+    switch (format) {
+    case VIDEO_PALETTE_RGB565:
+	{
+	    bpp = 2;
+	    /* initialize */
+	    pix1 = (__u16 *) pic;
+	    pix2 = pix1 + softwidth;
+	    for (my = 0; my < height; my += 2) {
+		for (mx = 0; mx < width; mx += 2) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			/* yes decode GBRG */
+
+			g1 = green[buf[inl + mx]];
+			b2 = blue[buf[inl + 1 + mx]];
+			r3 = red[buf[inl1 + mx]];
+			g4 = green[buf[inl1 + 1 + mx]];
+
+			if ((mx == 0) || (my == 0)
+			    || (mx == (width - 2))
+			    || (my == (height - 2))) {
+			    ing = (g1 + g4) >> 1;
+			    if (force_rgb) {
+				*pix1++ = PACKRGB16(r3, g1, b2);
+				*pix1++ = PACKRGB16(r3, ing, b2);
+				*pix2++ = PACKRGB16(r3, ing, b2);
+				*pix2++ = PACKRGB16(r3, g4, b2);
+			    } else {
+				*pix1++ = PACKRGB16(b2, g1, r3);
+				*pix1++ = PACKRGB16(b2, ing, r3);
+				*pix2++ = PACKRGB16(b2, ing, r3);
+				*pix2++ = PACKRGB16(b2, g4, r3);
+			    }
+			} else {
+			    G00 = buf[inl + mx - width - 1];
+			    R10 = buf[inl + mx - width];
+			    G20 = buf[inl + mx - width + 1];
+			    R30 = buf[inl + mx - width + 2];
+			    B01 = buf[inl + mx - 1];
+			    G31 = buf[inl + mx + 2];
+			    G02 = buf[inl1 + mx - 1];
+			    R32 = buf[inl1 + mx + 2];
+			    B03 = buf[inl1 + mx + width - 1];
+			    G13 = buf[inl1 + mx + width];
+			    B23 = buf[inl1 + mx + width + 1];
+			    G33 = buf[inl1 + mx + width + 2];
+			    b1 = blue[((B01 + b2) >> 1)];
+			    r1 = red[((R10 + r3) >> 1)];
+			    r4 = red[((r3 + R32) >> 1)];
+			    b4 = blue[((b2 + B23) >> 1)];
+			    g2 = green[((g1 + g4 + G31 + G20)
+					>> 2)];
+			    r2 = red[((R10 + R30 + r3 + R32) >> 2)];
+			    g3 = green[((g1 + g4 + G13 + G02)
+					>> 2)];
+			    b3 = blue[((B01 + b2 + B23 + B03) >> 2)];
+			    if (force_rgb) {
+				*pix1++ = PACKRGB16(r1, g1, b1);
+				*pix1++ = PACKRGB16(r2, g2, b2);
+				*pix2++ = PACKRGB16(r3, g3, b3);
+				*pix2++ = PACKRGB16(r4, g4, b4);
+			    } else {
+				*pix1++ = PACKRGB16(b1, g1, r1);
+				*pix1++ = PACKRGB16(b2, g2, r2);
+				*pix2++ = PACKRGB16(b3, g3, r3);
+				*pix2++ = PACKRGB16(b4, g4, r4);
+			    }
+			}
+
+		    }		// end test decode
+		}		// end mx loop
+		inl += nextinline;
+		inl1 += nextinline;
+		if (my >= cropy1) {
+		    /* are we in a decode surface move the output pointer */
+		    pix1 += (softwidth);
+		    pix2 += (softwidth);
+		}
+
+	    }			// end my loop
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_RGB32:
+    case VIDEO_PALETTE_RGB24:
+	{
+	    bpp = (format == VIDEO_PALETTE_RGB32) ? 4 : 3;
+	    /* initialize */
+	    nextoutline = bpp * softwidth;
+	    pic1 = pic + nextoutline;
+	    for (my = 0; my < height; my += 2) {
+		for (mx = 0; mx < width; mx += 2) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			/* yes decode GBRG */
+			g1 = green[buf[inl + mx]];
+			b2 = blue[buf[inl + 1 + mx]];
+			r3 = red[buf[inl1 + mx]];
+			g4 = green[buf[inl1 + 1 + mx]];
+
+			if ((mx == 0) || (my == 0)
+			    || (mx == (width - 2))
+			    || (my == (height - 2))) {
+			    ing = (g1 + g4) >> 1;
+			    /* top pixel Right */
+
+			    pic[r_offset] = r3;
+			    pic[g_offset] = g1;
+			    pic[b_offset] = b2;
+			    pic += bpp;
+			    /* top pixel Left */
+
+			    pic[r_offset] = r3;
+			    pic[g_offset] = ing;
+			    pic[b_offset] = b2;
+			    pic += bpp;
+			    /* bottom pixel Right */
+
+			    pic1[r_offset] = r3;
+			    pic1[g_offset] = ing;
+			    pic1[b_offset] = b2;
+			    pic1 += bpp;
+			    /* bottom pixel Left */
+
+			    pic1[r_offset] = r3;
+			    pic1[g_offset] = g4;
+			    pic1[b_offset] = b2;
+			    pic1 += bpp;
+			} else {
+			    G00 = buf[inl + mx - width - 1];
+			    R10 = buf[inl + mx - width];
+			    G20 = buf[inl + mx - width + 1];
+			    R30 = buf[inl + mx - width + 2];
+			    B01 = buf[inl + mx - 1];
+			    G31 = buf[inl + mx + 2];
+			    G02 = buf[inl1 + mx - 1];
+			    R32 = buf[inl1 + mx + 2];
+			    B03 = buf[inl1 + mx + width - 1];
+			    G13 = buf[inl1 + mx + width];
+			    B23 = buf[inl1 + mx + width + 1];
+			    G33 = buf[inl1 + mx + width + 2];
+			    b1 = blue[((B01 + b2) >> 1)];
+			    r1 = red[((R10 + r3) >> 1)];
+			    r4 = red[((r3 + R32) >> 1)];
+			    b4 = blue[((b2 + B23) >> 1)];
+			    g2 = green[((g1 + g4 + G31 + G20)
+					>> 2)];
+			    r2 = red[((R10 + R30 + r3 + R32) >> 2)];
+			    g3 = green[((g1 + g4 + G13 + G02)
+					>> 2)];
+			    b3 = blue[((B01 + b2 + B23 + B03) >> 2)];
+			    /* top pixel Right */
+
+			    pic[r_offset] = r1;
+			    pic[g_offset] = g1;
+			    pic[b_offset] = b1;
+			    pic += bpp;
+			    /* top pixel Left */
+
+			    pic[r_offset] = r2;
+			    pic[g_offset] = g2;
+			    pic[b_offset] = b2;
+			    pic += bpp;
+			    /* bottom pixel Right */
+
+			    pic1[r_offset] = r3;
+			    pic1[g_offset] = g3;
+			    pic1[b_offset] = b3;
+			    pic1 += bpp;
+			    /* bottom pixel Left */
+
+			    pic1[r_offset] = r4;
+			    pic1[g_offset] = g4;
+			    pic1[b_offset] = b4;
+			    pic1 += bpp;
+			}
+
+		    }		// end test decode
+		}		// end mx loop
+		inl += nextinline;
+		inl1 += nextinline;
+
+		if (my >= cropy1) {
+		    /* are we in a decode surface move the output pointer */
+		    pic += (nextoutline);
+		    pic1 += (nextoutline);
+		}
+
+	    }			// end my loop
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+    case VIDEO_PALETTE_YUV420P:
+	{			/* Not yet implemented */
+	    nextoutline = softwidth;
+	    pic1 = pic + nextoutline;
+	    for (my = 0; my < height; my += 2) {
+		for (mx = 0; mx < width; mx += 2) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			g1 = green[buf[inl + mx]];
+			b2 = blue[buf[inl + 1 + mx]];
+			r3 = red[buf[inl1 + mx]];
+			g4 = green[buf[inl1 + 1 + mx]];
+
+			if ((mx == 0) || (my == 0)
+			    || (mx == (width - 2))
+			    || (my == (height - 2))) {
+			    ing = (g1 + g4) >> 1;
+			    /* top pixel Right */
+			    y1 = RGB24_TO_Y(r3, g1, b2);
+			    *pic++ = y1;
+			    /* top pixel Left */
+			    y2 = RGB24_TO_Y(r3, ing, b2);
+			    *pic++ = y2;
+			    /* bottom pixel Right */
+			    y3 = RGB24_TO_Y(r3, ing, b2);
+			    *pic1++ = y3;
+			    /* bottom pixel Left */
+			    y4 = RGB24_TO_Y(r3, g4, b2);
+			    *pic1++ = y4;
+			    /* U V plane */
+			    *U++ = YB_TO_U(b2, ((y1 + y4)
+						>> 1));
+			    *V++ = YR_TO_V(r3, ((y1 + y4)
+						>> 1));
+			} else {
+			    G00 = buf[inl + mx - width - 1];
+			    R10 = buf[inl + mx - width];
+			    G20 = buf[inl + mx - width + 1];
+			    R30 = buf[inl + mx - width + 2];
+			    B01 = buf[inl + mx - 1];
+			    G31 = buf[inl + mx + 2];
+			    G02 = buf[inl1 + mx - 1];
+			    R32 = buf[inl1 + mx + 2];
+			    B03 = buf[inl1 + mx + width - 1];
+			    G13 = buf[inl1 + mx + width];
+			    B23 = buf[inl1 + mx + width + 1];
+			    G33 = buf[inl1 + mx + width + 2];
+			    b1 = blue[((B01 + b2) >> 1)];
+			    r1 = red[((R10 + r3) >> 1)];
+			    r4 = red[((r3 + R32) >> 1)];
+			    b4 = blue[((b2 + B23) >> 1)];
+			    g2 = green[((g1 + g4 + G31 + G20)
+					>> 2)];
+			    r2 = red[((R10 + R30 + r3 + R32) >> 2)];
+			    g3 = green[((g1 + g4 + G13 + G02)
+					>> 2)];
+			    b3 = blue[((B01 + b2 + B23 + B03) >> 2)];
+			    /* top pixel Right */
+			    y1 = RGB24_TO_Y(r1, g1, b1);
+			    *pic++ = y1;
+			    /* top pixel Left */
+			    y2 = RGB24_TO_Y(r2, g2, b2);
+			    *pic++ = y2;
+			    /* bottom pixel Right */
+			    y3 = RGB24_TO_Y(r3, g3, b3);
+			    *pic1++ = y3;
+			    /* bottom pixel Left */
+			    y4 = RGB24_TO_Y(r4, g4, b4);
+			    *pic1++ = y4;
+			    /* U V plane */
+			    *U++ = YB_TO_U(((b1 + b2 + b3 + b4)
+					    >> 2), ((y1 + y2 + y3 + y4)
+						    >> 2));
+			    *V++ = YR_TO_V(((r1 + r2 + r3 + r4)
+					    >> 2), ((y1 + y2 + y3 + y4)
+						    >> 2));
+			}
+
+		    }		// end test decode
+		}		// end mx loop
+		inl += nextinline;
+		inl1 += nextinline;
+
+		if (my >= cropy1) {
+		    /* are we in a decode surface move the output pointer */
+		    pic += softwidth;
+		    pic1 += softwidth;
+		}
+
+	    }			// end my loop
+
+	}
+	myframe->scanlength = (long) ((softwidth * softheight * 3) >> 1);
+	break;
+    default:
+	break;
+    }				// end case
+    return 0;
+}				// end bayer_decode
+
+
+static int yvyu_translate(struct spca50x_frame *myframe, int force_rgb)
+{
+
+    int r_offset, g_offset, b_offset;
+    int my, mx;			/* scan input surface */ 
+   __u16 *pix;		/* same for 16 bits output */
+    int bpp;
+    int inl,inl1;
+    unsigned char *pic = myframe->data;	/* output surface */
+    unsigned char *pic1;	/* output surface */
+    unsigned char *U, *V;	/* chroma output pointer */
+    unsigned char *buf = myframe->tmpbuffer;	/* input surface */
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    int softwidth = myframe->width;
+    int softheight = myframe->height;
+    //int method = myframe->method;
+    int nextinline, nextoutline;
+    int format = myframe->format;
+    int cropx1 = myframe->cropx1;
+    int cropx2 = myframe->cropx2;
+    int cropy1 = myframe->cropy1;
+    int cropy2 = myframe->cropy2;
+    unsigned char *red = myframe->decoder->Red;
+    unsigned char *green = myframe->decoder->Green;
+    unsigned char *blue = myframe->decoder->Blue;
+    int u1, v1, rg;
+    unsigned char y;
+	char u, v;
+    char r, g, b;
+    int framesize, frameUsize;
+
+    framesize = softwidth * softheight;
+    frameUsize = framesize >> 2;
+   // int framesize;
+    
+    //framesize = softwidth * softheight * 2;
+    /* rgb or bgr like U or V that's the question */
+    if (force_rgb) {
+    	U = pic + framesize;
+	V = U + frameUsize;
+	r_offset = 0;
+	g_offset = 1;
+	b_offset = 2;
+    } else {
+    	V = pic + framesize;
+	U = V + frameUsize;
+	r_offset = 2;
+	g_offset = 1;
+	b_offset = 0;
+    }
+    /* initialize input pointer */
+    inl = 0;
+    inl1= width << 1;
+    pic1= pic+softwidth;
+    nextinline = width << 1;
+    nextoutline = softwidth;
+    /* Decode to the correct format. */
+    switch (format) {
+   case VIDEO_PALETTE_RGB565:
+	{
+	    bpp = 2;
+	    /* initialize */
+	    pix = (__u16 *) pic;
+
+	    for (my = 0; my < height; my ++) {
+		for (mx = 0; mx < width; mx += 2) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			/* yes decode yvyu */
+			v=buf[inl+mx*2+1]-0x80;
+			u=buf[inl+mx*2+3]-0x80;
+			v1 = ((v << 10) + (v << 9)) >> 10;
+			rg = ((u << 8) + (u << 7) +
+			      (v << 9) + (v << 4)) >> 10;
+			u1 = ((u << 11) + (u << 4)) >> 10;
+			y = buf[inl+mx*2+0];
+			r = red[CLIP((y + v1))];
+			g = green[CLIP((y - rg))];
+			b = blue[CLIP((y + u1))];
+			if (force_rgb)
+			    *pix++ = PACKRGB16(r, g, b);
+			else
+			    *pix++ = PACKRGB16(b, g, r);
+			y = buf[inl+mx*2+2];
+			r = red[CLIP((y + v1))];
+		    	g = green[CLIP((y - rg))];
+			b = blue[CLIP((y + u1))];
+			if (force_rgb)
+			    *pix++ = PACKRGB16(r, g, b);
+			else
+			    *pix++ = PACKRGB16(b, g, r);
+			
+		    }
+		}		// end mx loop
+		inl += nextinline;
+	    }			// end my loop
+
+	}
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	break;
+   case VIDEO_PALETTE_RGB32:
+   case VIDEO_PALETTE_RGB24:
+	{
+	    bpp = (format == VIDEO_PALETTE_RGB32) ? 4 : 3;
+	    /* initialize */
+	    nextoutline = bpp * softwidth;
+	    for (my = 0; my < height; my ++ ) {
+		for (mx = 0; mx < width; mx += 2) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			/* yes decode yvyu */
+			v=buf[inl+mx*2+1]-0x80;
+			u=buf[inl+mx*2+3]-0x80;
+			v1 = ((v << 10) + (v << 9)) >> 10;
+			rg = ((u << 8) + (u << 7) +
+			      (v << 9) + (v << 4)) >> 10;
+			u1 = ((u << 11) + (u << 4)) >> 10;
+			y = buf[inl+mx*2+0];
+		
+			pic[r_offset] = red[CLIP((y + v1))];
+			pic[g_offset] = green[CLIP((y - rg))];
+			pic[b_offset] = blue[CLIP((y + u1))];
+			pic+=bpp;
+			y = buf[inl+mx*2+2];
+			pic[r_offset] = red[CLIP((y + v1))];
+		    	pic[g_offset] = green[CLIP((y - rg))];
+			pic[b_offset] = blue[CLIP((y + u1))];
+			pic+=bpp;
+		    }		// end test decode
+		}		// end mx loop
+		inl += nextinline;
+
+		if (my >= cropy1) {
+		    /* are we in a decode surface move the output pointer */
+//		    pic += (nextoutline);
+		}
+
+	    }			// end my loop
+	myframe->scanlength = (long) (softwidth * softheight * bpp);
+	}
+	break;
+   case VIDEO_PALETTE_YUV420P:
+	{			/* Not yet implemented */
+	    for (my = 0; my < height; my +=2) {
+		for (mx = 0; mx < width; mx += 2) {
+		    /* test if we need to decode */
+		    if ((my >= cropy1)
+			&& (my < height - cropy2)
+			&& (mx >= cropx1)
+			&& (mx < width - cropx2)) {
+			*pic++ = buf[inl+mx*2+0];
+			*U++=buf[inl+mx*2+1];
+			*pic++ = buf[inl+mx*2+2];
+			*V++=buf[inl+mx*2+3];
+			*pic1++ = buf[inl1+mx*2+0];
+			*pic1++ = buf[inl1+mx*2+2];
+			
+		    }		// end test decode
+		}		// end mx loop
+		inl += (nextinline << 1);
+		inl1 += (nextinline << 1);
+		if (my >= cropy1) {
+		    /* are we in a decode surface move the output pointer */
+		    pic += (nextoutline);
+		    pic1 += (nextoutline);
+		}
+
+	    }			// end my loop
+
+	
+	myframe->scanlength = (long) ((softwidth * softheight * 3) >> 1);
+	}
+	break;
+    default:
+	break;
+  }				// end case
+   return 0;
+}				// end yuyv_translate
+ 
+/* this function restore the missing header for the jpeg camera */
+/* adapted from Till Adam create_jpeg_from_data() */
+static int make_jpeg(struct spca50x_frame *myframe)
+{
+    __u8 *start;
+    int i;
+    __u8 value;
+    int width = myframe->hdrwidth;
+    int height = myframe->hdrheight;
+    long inputsize = myframe->scanlength;
+    __u8 *buf = myframe->tmpbuffer;
+    __u8 *dst = myframe->data;
+    start = dst;
+    /* set up the default header */
+    memcpy(dst, JPEGHeader, JPEGHEADER_LENGTH);
+    /* setup quantization table */
+    *(dst + 6) = 0;
+    memcpy(dst + 7, myframe->decoder->quant[0], 64);
+    *(dst + 7 + 64) = 1;
+    memcpy(dst + 8 + 64, myframe->decoder->quant[1], 64);
+
+    *(dst + 564) = width & 0xFF;	//Image width low byte
+    *(dst + 563) = width >> 8 & 0xFF;	//Image width high byte
+    *(dst + 562) = height & 0xFF;	//Image height low byte
+    *(dst + 561) = height >> 8 & 0xFF;	//Image height high byte
+    /* set the format */
+    if (myframe->cameratype == JPEG) {
+	*(dst + 567) = 0x22;
+	dst += JPEGHEADER_LENGTH;
+	for (i = 0; i < inputsize; i++) {
+	    value = *(buf + i) & 0xFF;
+	    *dst = value;
+	    dst++;
+	    if (value == 0xFF) {
+		*dst = 0;
+		dst++;
+	    }
+	}
+    } else {
+	*(dst + 567) = 0x21;
+	dst += JPEGHEADER_LENGTH;
+	memcpy(dst, buf, inputsize);
+	dst += inputsize;
+    }
+    /* Add end of image marker */
+    *(dst++) = 0xFF;
+    *(dst++) = 0xD9;
+    myframe->scanlength = (long) (dst - start);
+    return 0;
+}
+
+static int make_jpeg_conexant(struct spca50x_frame *myframe)
+{
+
+    __u8 *buf = myframe->tmpbuffer;
+    __u8 *dst = myframe->data;
+
+    memcpy(dst, JPEGHeader, JPEGHEADER_LENGTH - 33);
+    *(dst + 6) = 0;
+    memcpy(dst + 7, myframe->decoder->quant[0], 64);
+    *(dst + 7 + 64) = 1;
+    memcpy(dst + 8 + 64, myframe->decoder->quant[1], 64);
+    dst += (JPEGHEADER_LENGTH - 33);
+    memcpy(dst, buf, myframe->scanlength);
+    myframe->scanlength += (JPEGHEADER_LENGTH - 33);
+    return 0;
+}
diff -ruN linux-2.6.21/drivers/media/video/gspca/decoder/gspcadecoder.h linux-2.6.21-gspca/drivers/media/video/gspca/decoder/gspcadecoder.h
--- linux-2.6.21/drivers/media/video/gspca/decoder/gspcadecoder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/decoder/gspcadecoder.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,15 @@
+
+#ifndef SPCADECODER_H
+#define SPCADECODER_H
+
+#include "../gspca.h"
+/*********************************/
+
+
+int spca50x_outpicture(struct spca50x_frame *myframe);
+void init_jpeg_decoder(struct usb_spca50x *spca50x);
+void init_sonix_decoder(struct usb_spca50x *spca50x);
+void init_pixart_decoder(struct usb_spca50x *spca50x);
+void init_qTable(struct usb_spca50x *spca50x, unsigned int qIndex);
+
+#endif				/* SPCADECODER_H */
Files linux-2.6.21/drivers/media/video/gspca/decoder/gspcadecoder.o and linux-2.6.21-gspca/drivers/media/video/gspca/decoder/gspcadecoder.o differ
diff -ruN linux-2.6.21/drivers/media/video/gspca/gspca.h linux-2.6.21-gspca/drivers/media/video/gspca/gspca.h
--- linux-2.6.21/drivers/media/video/gspca/gspca.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/gspca.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,468 @@
+#ifndef SPCA50X_H
+#define SPCA50X_H
+/*
+* Header file for SPCA50x based camera driver. Originally copied from ov511 driver.
+* Originally by Mark W. McClelland
+* SPCA50x version by Joel Crisp; all bugs are mine, all nice features are his.
+* Spca5xx version by Michel Xhaard 
+*/
+#ifdef __KERNEL__
+#include <asm/uaccess.h>
+#include <linux/videodev.h>
+#include <linux/smp_lock.h>
+#include <linux/usb.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#include <media/v4l2-common.h>
+#endif
+/* V4L API extension for raw JPEG (=JPEG without header) and JPEG with header   
+*/
+#define VIDEO_PALETTE_RAW_JPEG  20
+#define VIDEO_PALETTE_JPEG 21
+#ifdef CONFIG_VIDEO_GSPCA_DEBUG
+#  define PDEBUG(level, fmt, args...) \
+if (debug >= level) info("[%s:%d] " fmt, __PRETTY_FUNCTION__, __LINE__ , ## args)
+#else				/* SPCA50X_ENABLE_DEBUG */
+#  define PDEBUG(level, fmt, args...) do {} while(0)
+#endif				/* SPCA50X_ENABLE_DEBUG */
+//#define FRAMES_PER_DESC               10      /* Default value, should be reasonable */
+#define FRAMES_PER_DESC  16	/* Default value, should be reasonable */
+#define MAX_FRAME_SIZE_PER_DESC 1024
+#define SPCA50X_MAX_WIDTH 640
+#define SPCA50X_MAX_HEIGHT 480
+#define SPCA50X_ENDPOINT_ADDRESS 1	/* Isoc endpoint number */
+#define PAC207_ENDPOINT_ADDRESS 5	/* Isoc endpoint number */
+/* only 2 or 4 frames are allowed here !!! */
+#define SPCA50X_NUMFRAMES 2
+#define SPCA50X_NUMSBUF 4	/* 2 is problematic on some systems */
+
+#define VENDOR_SONIX 0x0c45
+#define VENDOR_ETOMS 0x102c
+#define VENDOR_SUNPLUS 0x04fc
+#define VENDOR_AIPTEK 0x08ca
+#define VENDOR_LOGITECH 0x046d
+#define VENDOR_CREATIVE 0x041e
+#define VENDOR_KODAK 0x040a
+#define VENDOR_POLAROID 0x0546
+#define VENDOR_VIEWQUEST 0x0733
+#define VENDOR_INTEL 0x8086
+#define VENDOR_GRANDTECH 0x99FA
+#define VENDOR_MUSTEK 0x055f
+#define VENDOR_DLINK 0x084D
+#define VENDOR_3COM 0x0506
+#define VENDOR_MEGAPIX 0x052b
+#define VENDOR_HAMA 0x0af9
+#define VENDOR_AROWANA 0x1776
+#define VENDOR_GENIUS 0x0458
+#define VENDOR_PETCAM 0xabcd
+#define VENDOR_BENQ 0x04a5
+#define VENDOR_MAXELL 0x060b
+#define VENDOR_UINOVATION 0x0461
+#define VENDOR_FLYCAM 0x10fd
+#define VENDOR_ADS 0x06e1
+#define VENDOR_DIGIDREAM 0x05da
+#define VENDOR_VIMICRO 0x0ac8
+#define VENDOR_CONEXANT 0x0572
+#define VENDOR_ICMEDIA 0x0923
+#define VENDOR_VEOSTINGRAY 0x0545
+#define VENDOR_OPTIMEDIA 0x06be
+#define VENDOR_TOPTRO 0x2899
+#define VENDOR_AGFA 0x06bd
+#define VENDOR_PIXART 0x093A
+#define VENDOR_JVC 0x04f1
+#define VENDOR_SMILE 0x0497
+#define VENDOR_CTX 0x0698
+#define VENDOR_PHILIPS 0x0471
+
+#define BRIDGE_SPCA505 0
+#define BRIDGE_SPCA506 1
+#define BRIDGE_SPCA501 2
+#define BRIDGE_SPCA508 3
+#define BRIDGE_SPCA504 4
+#define BRIDGE_SPCA500 5
+#define BRIDGE_SPCA504B 6
+#define BRIDGE_SPCA533 7
+#define BRIDGE_SPCA504C 8
+#define BRIDGE_SPCA561 9
+#define BRIDGE_SPCA536 10
+#define BRIDGE_SONIX 11
+#define BRIDGE_ZC3XX 12
+#define BRIDGE_CX11646 13
+#define BRIDGE_TV8532 14
+#define BRIDGE_ETOMS 15
+#define BRIDGE_SN9CXXX 16
+#define BRIDGE_MR97311 17
+#define BRIDGE_PAC207 18
+#define BRIDGE_VC032X 19
+#define BRIDGE_PAC7311 20
+
+#define SENSOR_SAA7113 0
+#define SENSOR_INTERNAL 1
+#define SENSOR_HV7131B  2
+#define SENSOR_HDCS1020 3
+#define SENSOR_PB100_BA 4
+#define SENSOR_PB100_92 5
+#define SENSOR_PAS106_80 6
+#define SENSOR_TAS5130CXX 7
+#define SENSOR_ICM105A 8
+#define SENSOR_HDCS2020 9
+#define SENSOR_PAS106 10
+#define SENSOR_PB0330 11
+#define SENSOR_HV7131C 12
+#define SENSOR_CS2102 13
+#define SENSOR_HDCS2020b 14
+#define SENSOR_HV7131R 15
+#define SENSOR_OV7630 16
+#define SENSOR_MI0360 17
+#define SENSOR_TAS5110 18
+#define SENSOR_PAS202 19
+#define SENSOR_PAC207 20
+#define SENSOR_OV7630C 21
+#define SENSOR_TAS5130C_VF0250 22
+#define SENSOR_MO4000 23
+#define SENSOR_OV7660 24
+#define SENSOR_PO3130NC 25
+#define SENSOR_PAC7311 26
+
+/* Alternate interface transfer sizes */
+#define SPCA50X_ALT_SIZE_0       0
+#define SPCA50X_ALT_SIZE_128     1
+#define SPCA50X_ALT_SIZE_256     1
+#define SPCA50X_ALT_SIZE_384     2
+#define SPCA50X_ALT_SIZE_512     3
+#define SPCA50X_ALT_SIZE_640     4
+#define SPCA50X_ALT_SIZE_768     5
+#define SPCA50X_ALT_SIZE_896     6
+#define SPCA50X_ALT_SIZE_1023    7
+/* Sequence packet identifier for a dropped packet */
+#define SPCA50X_SEQUENCE_DROP 0xFF
+/* Offsets into the 10 byte header on the first ISO packet */
+#define SPCA50X_OFFSET_SEQUENCE 0
+#define SPCA50X_OFFSET_FRAMSEQ 6
+#define SPCA50X_OFFSET_DATA 10
+#define SPCA50X_REG_USB 0x2	// spca505 501
+/* I2C interface on an SPCA505, SPCA506, SPCA508 */
+#define SPCA50X_REG_I2C_CTRL 0x7
+#define SPCA50X_I2C_DEVICE 0x4
+#define SPCA50X_I2C_SUBADDR 0x1
+#define SPCA50X_I2C_VALUE 0x0
+#define SPCA50X_I2C_TRIGGER 0x2
+#define SPCA50X_I2C_TRIGGER_BIT 0x1
+#define SPCA50X_I2C_READ 0x0
+#define SPCA50X_I2C_STATUS 0x3
+/* Brightness autoadjustment parameters*/
+#define NSTABLE_MAX 4
+#define NUNSTABLE_MAX 600
+#define MIN_BRIGHTNESS 10
+/* Camera type jpeg yuvy yyuv yuyv grey gbrg*/
+enum {
+	JPEG = 0,		//Jpeg 4.1.1 Sunplus
+	JPGH,			//jpeg 4.2.2 Zstar
+	JPGC,			//jpeg 4.2.2 Conexant
+	JPGS,			//jpeg 4.2.2 Sonix
+	JPGM,			//jpeg 4.2.2 Mars-Semi
+	YUVY,// Sunplus packed lines
+	YYUV,// Sunplus packed lines
+	YUYV,// Sunplus packed lines
+	GREY,
+	GBRG,
+	SN9C,			// Sonix compressed stream
+	GBGR,
+	S561,			// Sunplus Compressed stream
+	PGBRG,			// Pixart RGGB bayer
+	YUY2, // YUYV packed
+    PJPG, // Pixart jpeg used with PAC7311
+};
+enum { QCIF = 1,
+	QSIF,
+	QPAL,
+	CIF,
+	SIF,
+	PAL,
+	VGA,
+	CUSTOM,
+	TOTMODE,
+};
+/* available palette */
+#define P_RGB16  1
+#define P_RGB24  (1 << 1)
+#define P_RGB32  (1 << 2)
+#define P_YUV420  (1 << 3)
+#define P_YUV422 ( 1 << 4)
+#define P_RAW  (1 << 5)
+#define P_JPEG  (1 << 6)
+struct mwebcam {
+	int width;
+	int height;
+	__u16 t_palette;
+	__u16 pipe;
+	int method;
+	int mode;
+};
+struct video_param {
+	int chg_para;
+#define CHGABRIGHT   1
+#define CHGQUALITY   2
+#define CHGLIGHTFREQ 3
+#define CHGTINTER    4
+	__u8 autobright;
+	__u8 quality;
+	__u16 time_interval;
+	__u8 light_freq;
+};
+/* Our private ioctl */
+#define SPCAGVIDIOPARAM _IOR('v',BASE_VIDIOCPRIVATE + 1,struct video_param)
+#define SPCASVIDIOPARAM _IOW('v',BASE_VIDIOCPRIVATE + 2,struct video_param)
+/* State machine for each frame in the frame buffer during capture */
+enum {
+	STATE_SCANNING,		/* Scanning for start */
+	STATE_HEADER,		/* Parsing header */
+	STATE_LINES,		/* Parsing lines */
+};
+/* Buffer states */
+enum {
+	BUF_NOT_ALLOCATED,
+	BUF_ALLOCATED,
+	BUF_PEND_DEALLOC,	/* spca50x->buf_timer is set */
+};
+struct usb_device;
+/* One buffer for the USB ISO transfers */
+struct spca50x_sbuf {
+	char *data;
+	struct urb *urb;
+};
+/* States for each frame buffer. */
+//enum {
+#define    FRAME_UNUSED 0x00	/* Unused (no MCAPTURE) */
+#define    FRAME_READY 0x01	/* Ready to start grabbing */
+#define    FRAME_GRABBING 0x02	/* In the process of being grabbed into */
+#define    FRAME_DONE 0x04	/* Finished grabbing, but not been synced yet */
+#define    FRAME_ERROR 0x08	/* Something bad happened while processing */
+#define    FRAME_ABORTING 0x10	/* Aborting everything. Caused by hot unplugging. */
+//};
+/************************ decoding data  **************************/
+struct pictparam {
+	int change;
+	int force_rgb;
+	int gamma;
+	int OffRed;
+	int OffBlue;
+	int OffGreen;
+	int GRed;
+	int GBlue;
+	int GGreen;
+};
+#define MAXCOMP 4
+struct dec_hufftbl;
+struct enc_hufftbl;
+union hufftblp {
+	struct dec_hufftbl *dhuff;
+	struct enc_hufftbl *ehuff;
+};
+struct scan {
+	int dc;			/* old dc value */
+	union hufftblp hudc;	/* pointer to huffman table dc */
+	union hufftblp huac;	/* pointer to huffman table ac */
+	int next;		/* when to switch to next scan */
+	int cid;		/* component id */
+	int hv;			/* horiz/vert, copied from comp */
+	int tq;			/* quant tbl, copied from comp */
+};
+/*********************************/
+#define DECBITS 10		/* seems to be the optimum */
+struct dec_hufftbl {
+	int maxcode[17];
+	int valptr[16];
+	unsigned char vals[256];
+	unsigned int llvals[1 << DECBITS];
+};
+/*********************************/
+struct in {
+	unsigned char *p;
+	unsigned int bits;
+	int omitescape;
+	int left;
+	int marker;
+};
+struct jpginfo {
+	int nc;			/* number of components */
+	int ns;			/* number of scans */
+	int dri;		/* restart interval */
+	int nm;			/* mcus til next marker */
+	int rm;			/* next restart marker */
+};
+struct comp {
+	int cid;
+	int hv;
+	int tq;
+};
+/* Sonix decompressor struct B.S.(2004) */
+struct code_table_t {
+	int is_abs;
+	int len;
+	int val;
+};
+struct dec_data {
+	struct in in;
+	struct jpginfo info;
+	struct comp comps[MAXCOMP];
+	struct scan dscans[MAXCOMP];
+	unsigned char quant[3][64];
+	int dquant[3][64];
+	struct code_table_t table[256];
+	unsigned char Red[256];
+	unsigned char Green[256];
+	unsigned char Blue[256];
+};
+/*************************End decoding data ********************************/
+struct spca50x_frame {
+	unsigned char *data;	/* Frame buffer */
+	unsigned char *tmpbuffer;	/* temporary buffer spca50x->tmpbuffer need for decoding */
+	struct dec_data *decoder;
+	struct usb_spca50x *spca50x_dev; /* need to find the atomic_t lock */
+/* Memory allocation for the jpeg decoders */
+	int dcts[6 * 64 + 16];
+	int out[6 * 64];
+	int max[6];
+/*******************************************/
+	int depth;		/* Bytes per pixel */
+	int width;		/* Width application is expecting */
+	int height;		/* Height */
+	int hdrwidth;		/* Width the frame actually is */
+	int hdrheight;		/* Height */
+	int method;		/* The decoding method for that frame 0 nothing 1 crop 2 div 4 mult */
+	int cropx1;		/* value to be send with the frame for decoding feature */
+	int cropx2;
+	int cropy1;
+	int cropy2;
+	int x;
+	int y;
+	unsigned int format;	/* Format asked by apps for this frame */
+	int cameratype;		/* native in frame format */
+	struct pictparam pictsetting;
+	volatile int grabstate;	/* State of grabbing */
+	int scanstate;		/* State of scanning */
+	long scanlength;	/* uncompressed, raw data length of frame */
+	int totlength;		/* length of the current reading byte in the Iso stream */
+	wait_queue_head_t wq;	/* Processes waiting */
+	int snapshot;		/* True if frame was a snapshot */
+	int last_packet;	/* sequence number for last packet */
+	unsigned char *highwater;	/* used for debugging */
+};
+struct usb_spca50x;
+typedef void (*cam_ops) (struct usb_spca50x *);
+typedef int (*intcam_ops) (struct usb_spca50x *);
+typedef __u16(*u16cam_ops) (struct usb_spca50x *);
+typedef int (*intcam_detect) (struct usb_spca50x *, struct spca50x_frame *,
+			      unsigned char *, int *, int, int *);
+struct cam_operation {
+	intcam_ops initialize;
+	intcam_ops configure;
+	cam_ops start;
+	cam_ops stopN;
+	cam_ops stop0;
+	u16cam_ops get_bright;
+	cam_ops set_bright;
+	u16cam_ops get_contrast;
+	cam_ops set_contrast;
+	u16cam_ops get_colors;
+	cam_ops set_colors;
+	cam_ops set_autobright;
+	cam_ops set_quality;
+	cam_ops cam_shutdown;
+	intcam_detect sof_detect;
+	cam_ops  set_50HZ;
+	cam_ops  set_60HZ;
+	cam_ops  set_50HZScale;
+	cam_ops  set_60HZScale;
+	cam_ops  set_NoFliker;
+	cam_ops  set_NoFlikerScale;
+};
+struct usb_spca50x {
+	struct video_device *vdev;
+	struct usb_device *dev;	/* Device structure */
+	struct tasklet_struct spca5xx_tasklet;	/* use a tasklet per device */
+	atomic_t in_use; /*tasklet list protect */
+	struct dec_data maindecode;
+	unsigned long last_times;	//timestamp
+	unsigned int dtimes;	//nexttimes to acquire
+	unsigned char iface;	/* interface in use */
+	int alt;		/* current alternate setting */
+	int epadr;		/* endpoint in used */
+	int customid;		/* product id get by probe */
+	int desc;		/* enum camera name */
+	int ccd;		/* If true, using the CCD otherwise the external input */
+	int chip_revision;	/* set when probe the camera spca561 zc0301p for vm303 */
+	struct mwebcam mode_cam[TOTMODE];	/* all available mode registers by probe */
+	int bridge;		/* Type of bridge (BRIDGE_SPCA505 or BRIDGE_SPCA506) */
+	int sensor;		/* Type of image sensor chip */
+	int packet_size;	/* Frame size per isoc desc */
+/* Determined by sensor type */
+	int maxwidth;
+	int maxheight;
+	int minwidth;
+	int minheight;
+/* What we think the hardware is currently set to */
+	int brightness;
+	int colour;
+	int contrast;
+	int hue;
+	int whiteness;
+	int exposure;		// used by spca561 
+	int autoexpo;
+	int qindex;
+	int width;		/* use here for the init of each frame */
+	int height;
+	int hdrwidth;
+	int hdrheight;
+	unsigned int format;
+	int method;		/* method ask for output pict */
+	int mode;		/* requested frame size */
+	int pipe_size;		// requested pipe size set according to mode
+	__u16 norme;		/* norme in use Pal Ntsc Secam */
+	__u16 channel;		/* input composite video1 or svideo */
+	int cameratype;		/* native in frame format */
+	struct pictparam pictsetting;
+/* Statistics variables */
+	spinlock_t v4l_lock;	/* lock to protect shared data between isoc and process context */
+	int avg_lum;		//The average luminance (if available from theframe header)
+	int avg_bg, avg_rg;	//The average B-G and R-G for white balancing 
+	struct semaphore lock;
+	int user;		/* user count for exclusive use */
+	int present;		/* driver loaded */
+	int streaming;		/* Are we streaming Isochronous? */
+	int grabbing;		/* Are we grabbing? */
+	int packet;
+	int synchro;		/* set to 0 if usb packet length = 0 */
+	int compress;		/* Should the next frame be compressed? */
+	char *fbuf;		/* Videodev buffer area */
+	int curframe;		/* Current receiving frame buffer */
+	struct spca50x_frame frame[SPCA50X_NUMFRAMES];
+	struct spca50x_sbuf sbuf[SPCA50X_NUMSBUF];
+/* Temporary jpeg decoder workspace */
+	char *tmpBuffer;
+/* Framebuffer/sbuf management */
+	int buf_state;
+	struct semaphore buf_lock;
+	wait_queue_head_t wq;	/* Processes waiting */
+	uint i2c_ctrl_reg;	// Camera I2C control register
+	uint i2c_base;		// Camera I2C address base
+	char i2c_trigger_on_write;	//do trigger bit on write
+	struct cam_operation funct;
+	__u8 force_rgb;		//Read RGB instead of BGR
+	__u8 light_freq;	//light frequency banding filter setting
+};
+struct cam_list {
+	int id;
+	const char *description;
+};
+struct palette_list {
+	int num;
+	const char *name;
+};
+struct bridge_list {
+	int num;
+	const char *name;
+};
+#endif				/* __KERNEL__ */
+#endif				/* SPCA50X_H */
diff -ruN linux-2.6.21/drivers/media/video/gspca/gspca_core.c linux-2.6.21-gspca/drivers/media/video/gspca/gspca_core.c
--- linux-2.6.21/drivers/media/video/gspca/gspca_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/gspca_core.c	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,4231 @@
+/*
+* SPCA5xx based usb camera driver (currently supports
+* yuv native stream spca501a, spca501c, spca505, spca508, spca506
+* jpeg native stream spca500, spca551, spca504a, spca504b, spca533a, spca536a, zc0301, zc0302, cx11646, sn9c102p
+* bayer native stream spca561a, sn9c101, sn9c102, tv8532 ).
+* Z-star Vimicro chips zc0301 zc0301P zc0302
+* Sunplus spca501a, spca501c, spca505, spca508, spca506, spca500, spca551, spca504a, spca504b, spca533a, spca536a
+* Sonix sn9c101, sn9c102, sn9c102p sn9c105 sn9c120
+* Conexant cx11646
+* Transvision tv_8532 
+* Etoms Et61x151 Et61x251
+* Pixart Pac207-BCA-32
+* SPCA5xx version by Michel Xhaard <mxhaard@users.sourceforge.net>
+* Based on :
+* SPCA50x version by Joel Crisp <cydergoth@users.sourceforge.net>
+* OmniVision OV511 Camera-to-USB Bridge Driver
+* Copyright (c) 1999-2000 Mark W. McClelland
+* Kernel 2.6.x port Michel Xhaard && Reza Jelveh (feb 2004)
+* Based on the Linux CPiA driver written by Peter Pregler,
+* Scott J. Bertin and Johannes Erdfelt.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+* or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+* for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software Foundation,
+* Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+static const char gspca_version[] = GSPCA_VERSION;
+#ifndef AUTOCONF_INCLUDED
+#include <linux/config.h>
+#endif
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/usb.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+#include <asm/page.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+/* only on 2.6.x */
+#include <linux/jiffies.h>
+#include <linux/param.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
+#include <linux/moduleparam.h>
+#endif
+#include "gspca.h"
+#include "decoder/gspcadecoder.h"
+/* Video Size 640 x 480 x 4 bytes for RGB */
+#define MAX_FRAME_SIZE (640 * 480 * 4)
+#define MAX_DATA_SIZE (MAX_FRAME_SIZE + sizeof(struct timeval))
+/* Hardware auto exposure / whiteness (PC-CAM 600) */
+static int autoexpo = 1;
+/* Video device number (-1 is first available) */
+static int video_nr = -1;
+/* 0=no debug messages
+* 1=init/detection/unload and other significant messages,
+* 2=some warning messages
+* 3=config/control function calls
+* 4=most function calls and data parsing messages
+* 5=highly repetitive mesgs
+* NOTE: This should be changed to 0, 1, or 2 for production kernels
+*/
+static int debug = 0;
+/* Force image to be read in RGB instead of BGR. This option allow
+* programs that expect RGB data (e.g. gqcam) to work with this driver. */
+static int force_rgb = 0;
+static int gamma = 3;
+static int OffRed = 0;
+static int OffBlue = 0;
+static int OffGreen = 0;
+static int GRed = 256;
+static int GBlue = 256;
+static int GGreen = 256;
+static int usbgrabber = 0;
+#ifdef GSPCA_ENABLE_COMPRESSION
+/* Enable compression. This is for experimentation only; compressed images
+* still cannot be decoded yet. */
+static int compress = 0;
+#endif
+/* Light frequency banding filter 50HZ/60HZ/NoFliker */
+static int lightfreq = 50;
+#ifdef GSPCA_ENABLE_REGISTERPLAY
+static int RegAddress = 0;
+static int RegValue = 0;
+static int RegStrobe = 0;
+#endif
+module_param(autoexpo, int, 0644);
+module_param(debug, int, 0644);
+module_param(force_rgb, int, 0644);
+module_param(gamma, int, 0644);
+module_param(OffRed, int, 0644);
+module_param(OffBlue, int, 0644);
+module_param(OffGreen, int, 0644);
+module_param(GRed, int, 0644);
+module_param(GBlue, int, 0644);
+module_param(GGreen, int, 0644);
+#ifdef GSPCA_ENABLE_COMPRESSION
+module_param(compress, int, 0644);
+#endif
+module_param(usbgrabber, int, 0444);
+module_param(lightfreq, int, 0644);
+#ifdef GSPCA_ENABLE_REGISTERPLAY
+module_param(RegAddress, int, 0644);
+module_param(RegValue, int, 0644);
+module_param(RegStrobe, int, 0644);
+#endif
+MODULE_PARM_DESC(autoexpo,
+		 "Enable/Disable auto exposure (default=1: enabled) (PC-CAM 600/Zc03xx/spca561a/Etoms Only !!!)");
+MODULE_PARM_DESC(debug,
+		 "Debug level: 0=none, 1=init/detection, 2=warning, 3=config/control, 4=function call, 5=max");
+MODULE_PARM_DESC(force_rgb, "Read RGB instead of BGR");
+MODULE_PARM_DESC(gamma, "gamma setting range 0 to 7 3-> gamma=1");
+MODULE_PARM_DESC(OffRed, "OffRed setting range -128 to 128");
+MODULE_PARM_DESC(OffBlue, "OffBlue setting range -128 to 128");
+MODULE_PARM_DESC(OffGreen, "OffGreen setting range -128 to 128");
+MODULE_PARM_DESC(GRed, "Gain Red setting range 0 to 512 /256 ");
+MODULE_PARM_DESC(GBlue, "Gain Blue setting range 0 to 512 /256 ");
+MODULE_PARM_DESC(GGreen, "Gain Green setting range 0 to 512 /256 ");
+#ifdef GSPCA_ENABLE_COMPRESSION
+MODULE_PARM_DESC(compress, "Turn on/off compression (not functional yet)");
+#endif				/* SPCA50X_ENABLE_COMPRESSION */
+MODULE_PARM_DESC(usbgrabber, "Is a usb grabber 0x0733:0x0430 ? (default 1) ");
+MODULE_PARM_DESC(lightfreq,  "Light frequency banding filter. Set to 50 or 60 Hz, or zero to NoFliker (default=50)");
+#ifdef GSPCA_ENABLE_REGISTERPLAY
+MODULE_PARM_DESC(RegAddress, "Register Address of PAC207");
+MODULE_PARM_DESC(RegValue, "Register Value for PAC207");
+MODULE_PARM_DESC(RegStrobe,
+		 "Strobe to read or write a register 1=write, 2=read");
+#endif				/* SPCA5XX_ENABLE_REGISTERPLAY */
+/****************/
+MODULE_AUTHOR
+    ("Michel Xhaard <mxhaard@users.sourceforge.net> based on spca50x driver by Joel Crisp <cydergoth@users.sourceforge.net>,ov511 driver by Mark McClelland <mwm@i.am>");
+MODULE_DESCRIPTION("GSPCA/SPCA5XX USB Camera Driver");
+MODULE_LICENSE("GPL");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static void
+spca50x_isoc_irq(struct urb *urb, struct pt_regs *regs);
+#else
+static void
+spca50x_isoc_irq(struct urb *urb);
+#endif
+
+static int spca50x_move_data(struct usb_spca50x *spca50x, struct urb *urb);
+static int spca5xx_set_light_freq(struct usb_spca50x *spca50x, int freq);
+
+static struct usb_driver spca5xx_driver;
+/**********************************************************************
+* List of known SPCA50X-based cameras
+**********************************************************************/
+/* Camera type jpeg yuvy yyuv yuyv grey gbrg*/
+static struct palette_list Plist[] = {
+	{JPEG, "JPEG"},
+	{JPGH, "JPEG"},
+	{JPGC, "JPEG"},
+	{JPGS, "JPEG"},
+	{JPGM, "JPEG"},
+	{YUVY, "YUVY"},
+	{YYUV, "YYUV"},
+	{YUYV, "YUYV"},
+	{GREY, "GREY"},
+	{GBRG, "GBRG"},
+	{SN9C, "SN9C"},
+	{GBGR, "GBGR"},
+	{S561, "S561"},
+	{PGBRG, "GBRG"},
+	{YUY2, "YUYV"},
+	{PJPG, "JPEG"},
+	{-1, NULL}
+};
+static struct bridge_list Blist[] = {
+	{BRIDGE_SPCA505, "SPCA505"},
+	{BRIDGE_SPCA506, "SPCA506"},
+	{BRIDGE_SPCA501, "SPCA501"},
+	{BRIDGE_SPCA508, "SPCA508"},
+	{BRIDGE_SPCA504, "SPCA504"},
+	{BRIDGE_SPCA500, "SPCA500"},
+	{BRIDGE_SPCA504B, "SPCA504B"},
+	{BRIDGE_SPCA533, "SPCA533"},
+	{BRIDGE_SPCA504C, "SPCA504C"},
+	{BRIDGE_SPCA561, "SPCA561"},
+	{BRIDGE_SPCA536, "SPCA536"},
+	{BRIDGE_SONIX, "SN9C102"},
+	{BRIDGE_ZC3XX, "ZC301-2"},
+	{BRIDGE_CX11646, "CX11646"},
+	{BRIDGE_TV8532, "TV8532"},
+	{BRIDGE_ETOMS, "ET61XX51"},
+	{BRIDGE_SN9CXXX, "SN9CXXX"},
+	{BRIDGE_MR97311, "MR97311"},
+	{BRIDGE_PAC207, "PAC207BCA"},
+	{BRIDGE_VC032X, "VC0321"},
+ 	{BRIDGE_PAC7311, "PAC7311"},
+	{-1, NULL}
+};
+/* Light frequency banding filter 50HZ/60HZ/NoFliker */
+enum { 
+       freq_50HZ=0,
+       freq_60HZ,
+       NoFliker
+};
+enum {
+	UnknownCamera = 0,	// 0
+	IntelPCCameraPro,
+	IntelCreateAndShare,
+	GrandtecVcap,
+	ViewQuestM318B,
+	ViewQuestVQ110,
+	KodakDVC325,
+	MustekGsmartMini2,
+	MustekGsmartMini3,
+	CreativePCCam300,
+	DLinkDSC350,		// 10
+	CreativePCCam600,
+	IntelPocketPCCamera,
+	IntelEasyPCCamera,
+	ThreeComHomeConnectLite,
+	KodakEZ200,
+	MaxellMaxPocket,
+	AiptekMiniPenCam2,
+	AiptekPocketDVII,
+	AiptekPenCamSD,
+	AiptekMiniPenCam13,	// 20
+	MustekGsmartLCD3,
+	MustekMDC5500Z,
+	MegapixV4,
+	AiptekPocketDV,
+	HamaUSBSightcam,
+	Arowana300KCMOSCamera,
+	MystFromOriUnknownCamera,
+	AiptekPocketDV3100,
+	AiptekPocketCam3M,
+	GeniusVideoCAMExpressV2,	// 30
+	Flexcam100Camera,
+	MustekGsmartLCD2,
+	PureDigitalDakota,
+	PetCam,
+	BenqDC1500,
+	LogitechClickSmart420,
+	LogitechClickSmart510,
+	BenqDC1300,
+	HamaUSBSightcam2,
+	MustekDV3000,		// 40
+	CreativePccam750,
+	MaxellCompactPM3,
+	BenqDC3410,
+	BenqDC1016,
+	MicroInnovationIC200,
+	LogitechTraveler,
+	Flycam100Camera,
+	UsbGrabberPV321c,
+	ADSInstantVCD,
+	Gsmartmini,		// 50
+	Jenoptikjdc21lcd,
+	LogitechClickSmart310,
+	Terratec2move13,
+	MustekDV4000,
+	AiptekDV3500,
+	LogitechClickSmart820,
+	Enigma13,
+	Sonix6025,
+	Epsilon13,
+	Nxultra,		//60
+	AiptekPocketCam2M,
+	DeMonUSBCapture,
+	CreativeVista,
+	PolaroidPDC2030,
+	CreativeNotebook,
+	CreativeMobile,
+	LabtecPro,
+	MustekWcam300A,
+	GeniusVideoCamV2,
+	GeniusVideoCamV3,
+	GeniusVideoCamExpressV2b,
+	CreativeNxPro,
+	Sonix6029,		//73 74 75
+	Vimicro,
+	Digitrex2110,
+	GsmartD30,
+	CreativeNxPro2,
+	Bs888e,
+	Zc302,
+	CreativeNoteBook2,
+	AiptekSlim3200,		/* 83 84 85 */
+	LabtecWebcam,
+	QCExpress,
+	ICM532cam,
+	MustekGsmart300,
+	CreativeLive,		//90
+	MercuryDigital,
+	Wcam300A,
+	CreativeVista3b,
+	VeoStingray1,
+	VeoStingray2,
+	TyphoonWebshotIIUSB300k,	//96
+	PolaroidPDC3070,
+	QCExpressEtch2,
+	QCforNotebook,
+	QCim,			//100
+	WebCam320,
+	AiptekPocketCam4M,
+	AiptekPocketDV5100,
+	AiptekPocketDV5300,
+	SunplusGeneric536,
+	QCimA1,
+	QCchat,
+	QCimB9,
+	Labtec929,		//109 110
+	Etoms61x151,
+	Etoms61x251,
+	PalmPixDC85,
+	Optimedia,
+	ToptroIndus,
+	AgfaCl20,
+	LogitechQC92x,
+	SonixWC311P,
+	Concord3045,
+	Mercury21,		//120
+	CreativeNX,
+	CreativeInstant1,
+	CreativeInstant2,
+	QuickCamNB,
+	WCam300AN,
+	LabtecWCPlus,
+	GeniusVideoCamMessenger,
+	Pcam,
+	GeniusDsc13,
+	MustekMDC4000,		//130
+	LogitechQCCommunicateSTX,
+	Lic200,
+	SweexTas5110,
+	Pccam168,
+	Sn535,
+	Pccam,
+	Lic300,
+	PolaroidIon80,
+	Zc0305b,
+	BtcPc380,		//140
+	LogitechNotebookDeluxe,
+	LabtecNotebook,
+	JvcGcA50,
+	SmileIntlCamera,
+	PcCam350,
+	PAC207,
+	QtecWb100,
+	GeniusGe111,
+	Vimicro303b,
+	CyberpixS550V,
+	GeniusGF112,
+	LogitechQCim,
+	AiptekSlim3000F,
+	CTXM730VCam,
+	GeniusVideoCamNB,
+	CreativeVistaPlus,
+	PhilipsSPC200NC,
+	PhilipsSPC210NC,
+	PhilipsSPC700NC,
+	SpeedNVC350K,
+	Mustek330K,
+	PhilipsSPC600NC,
+	PhilipsSPC300NC,
+	Sonix6019,
+	LogitechQCImage,
+	Sunplus500c,
+	MustekMDC3500,
+	LogitechQCCool,
+	QCimconnect,
+	QCmessenger,
+	CreativeLiveCamNotebookPro,
+	CreativeWebCamVistaPro,
+	CreativeLiveCamVideoIM,
+	AiptekDV4100M,
+	TyphoonEasyCam1_3,
+	Sonix0x613b,
+	Sonix0x60fb,
+	Sonyc002,
+	Vimicro0321,
+	Orbicam,
+	MSVX1000,
+	MSVX3000,
+	Trust610LCDPowerCamZoom,
+	Sonyc001,
+	PhilipsSPC315NC,
+	Sonix0x6138,
+	GeniusEye311Q,	
+    	PAC7311,	
+    	PAC7312,
+	PhilipsDMVC1300K,	
+	LastCamera
+};
+static struct cam_list clist[] = {
+	{UnknownCamera, "Unknown"},
+	{IntelPCCameraPro, "Intel PC Camera Pro"},
+	{IntelCreateAndShare, "Intel Create and Share"},
+	{GrandtecVcap, "Grandtec V.cap"},
+	{ViewQuestM318B, "ViewQuest M318B"},
+	{ViewQuestVQ110, "ViewQuest VQ110"},
+	{KodakDVC325, "Kodak DVC-325"},
+	{MustekGsmartMini2, "Mustek gSmart mini 2"},
+	{MustekGsmartMini3, "Mustek gSmart mini 3"},
+	{CreativePCCam300, "Creative PC-CAM 300"},
+	{DLinkDSC350, "D-Link DSC-350"},
+	{CreativePCCam600, "Creative PC-CAM 600"},
+	{IntelPocketPCCamera, "Intel Pocket PC Camera"},
+	{IntelEasyPCCamera, "Intel Easy PC Camera"},
+	{ThreeComHomeConnectLite, "3Com Home Connect Lite"},
+	{KodakEZ200, "Kodak EZ200"},
+	{MaxellMaxPocket, "Maxell Max Pocket LEdit. 1.3 MPixels"},
+	{AiptekMiniPenCam2, "Aiptek Mini PenCam  2 MPixels"},
+	{AiptekPocketDVII, "Aiptek PocketDVII  1.3 MPixels"},
+	{AiptekPenCamSD, "Aiptek Pencam SD  2 MPixels"},
+	{AiptekMiniPenCam13, "Aiptek mini PenCam 1.3 MPixels"},
+	{MustekGsmartLCD3, "Mustek Gsmart LCD 3"},
+	{MustekMDC5500Z, "Mustek MDC5500Z"},
+	{MegapixV4, "Megapix V4"},
+	{AiptekPocketDV, "Aiptek PocketDV "},
+	{HamaUSBSightcam, "Hama USB Sightcam 100"},
+	{Arowana300KCMOSCamera, "Arowana 300K CMOS Camera"},
+	{MystFromOriUnknownCamera, "Unknow Ori Camera"},
+	{AiptekPocketDV3100, "Aiptek PocketDV3100+ "},
+	{AiptekPocketCam3M, "Aiptek PocketCam  3 M "},
+	{GeniusVideoCAMExpressV2, "Genius VideoCAM Express V2"},
+	{Flexcam100Camera, "Flexcam 100 Camera"},
+	{MustekGsmartLCD2, "Mustek Gsmart LCD 2"},
+	{PureDigitalDakota, "Pure Digital Dakota"},
+	{PetCam, "PetCam"},
+	{BenqDC1500, "Benq DC1500"},
+	{LogitechClickSmart420, "Logitech Inc. ClickSmart 420"},
+	{LogitechClickSmart510, "Logitech Inc. ClickSmart 510"},
+	{BenqDC1300, "Benq DC1300"},
+	{HamaUSBSightcam2, "Hama USB Sightcam 100 (2)"},
+	{MustekDV3000, "Mustek DV 3000"},
+	{CreativePccam750, "Creative PCcam750"},
+	{MaxellCompactPM3, "Maxell Compact PC PM3"},
+	{BenqDC3410, "Benq DC3410"},
+	{BenqDC1016, "Benq DC1016"},
+	{MicroInnovationIC200, "Micro Innovation IC200"},
+	{LogitechTraveler, "Logitech QuickCam Traveler"},
+	{Flycam100Camera, "FlyCam Usb 100"},
+	{UsbGrabberPV321c, "Usb Grabber PV321c"},
+	{ADSInstantVCD, "ADS Instant VCD"},
+	{Gsmartmini, "Mustek Gsmart Mini"},
+	{Jenoptikjdc21lcd, "Jenoptik DC 21 LCD"},
+	{LogitechClickSmart310, "Logitech ClickSmart 310"},
+	{Terratec2move13, "Terratec 2 move 1.3"},
+	{MustekDV4000, "Mustek DV4000 Mpeg4"},
+	{AiptekDV3500, "Aiptek DV3500 Mpeg4"},
+	{LogitechClickSmart820, "Logitech ClickSmart 820"},
+	{Enigma13, "Digital Dream Enigma 1.3"},
+	{Sonix6025, "Xcam Shanga"},
+	{Epsilon13, "Digital Dream Epsilon 1.3"},
+	{Nxultra, "Creative Webcam NX ULTRA"},
+	{AiptekPocketCam2M, "Aiptek PocketCam 2Mega"},
+	{DeMonUSBCapture, "3DeMON USB Capture"},
+	{CreativeVista, "Creative Webcam Vista"},
+	{PolaroidPDC2030, "Polaroid PDC2030"},
+	{CreativeNotebook, "Creative Notebook PD1171"},
+	{CreativeMobile, "Creative Mobile PD1090"},
+	{LabtecPro, "Labtec Webcam Pro"},
+	{MustekWcam300A, "Mustek Wcam300A"},
+	{GeniusVideoCamV2, "Genius Videocam V2"},
+	{GeniusVideoCamV3, "Genius Videocam V3"},
+	{GeniusVideoCamExpressV2b, "Genius Videocam Express V2 Firmware 2"},
+	{CreativeNxPro, "Creative Nx Pro"},
+	{Sonix6029, "Sonix sn9c10x + Pas106 sensor"},
+	{Vimicro, "Z-star Vimicro zc0301p"},
+	{Digitrex2110, "ApexDigital Digitrex2110 spca533"},
+	{GsmartD30, "Mustek Gsmart D30 spca533"},
+	{CreativeNxPro2, "Creative NX Pro FW2"},
+	{Bs888e, "Kowa Bs888e MicroCamera"},
+	{Zc302, "Z-star Vimicro zc0302"},
+	{CreativeNoteBook2, "Creative Notebook PD1170"},
+	{AiptekSlim3200, "Aiptek Slim 3200"},
+	{LabtecWebcam, "Labtec Webcam"},
+	{QCExpress, "QC Express"},
+	{ICM532cam, "ICM532 cam"},
+	{MustekGsmart300, "Mustek Gsmart 300"},
+	{CreativeLive, "Creative Live! "},
+	{MercuryDigital, "Mercury Digital Pro 3.1Mp"},
+	{Wcam300A, "Mustek Wcamm300A 2"},
+	{CreativeVista3b, "Creative Webcam Vista 0x403b"},
+	{VeoStingray1, "Veo Stingray 1"},
+	{VeoStingray2, "Veo Stingray 2"},
+	{TyphoonWebshotIIUSB300k, " Typhoon Webshot II"},
+	{PolaroidPDC3070, " Polaroid PDC3070"},
+	{QCExpressEtch2, "Logitech QuickCam Express II"},
+	{QCforNotebook, "Logitech QuickCam for Notebook"},
+	{QCim, "Logitech QuickCam IM"},
+	{WebCam320, "Micro Innovation WebCam 320"},
+	{AiptekPocketCam4M, "Aiptek Pocket Cam 4M"},
+	{AiptekPocketDV5100, "Aiptek Pocket DV5100"},
+	{AiptekPocketDV5300, "Aiptek Pocket DV5300"},
+	{SunplusGeneric536, "Sunplus Generic spca536a"},
+	{QCimA1, "Logitech QuickCam IM + sound"},
+	{QCchat, "Logitech QuickCam chat"},
+	{QCimB9, "Logitech QuickCam IM ???"},
+	{Labtec929, "Labtec Webcam Elch2 "},
+	{Etoms61x151, "QCam Sangha"},
+	{Etoms61x251, "QCam xxxxxx"},
+	{PalmPixDC85, "PalmPix DC85"},
+	{Optimedia, "Optimedia TechnoAME"},
+	{ToptroIndus, "Toptro Industrial"},
+	{AgfaCl20, "Agfa ephoto CL20"},
+	{LogitechQC92x, "Logitech QuickCam EC"},
+	{SonixWC311P, "Sonix sn9c102P Hv7131R"},
+	{Concord3045, "Concord 3045 spca536a"},
+	{Mercury21, "Mercury Peripherals Inc."},
+	{CreativeNX, "Creative NX"},
+	{CreativeInstant1, "Creative Instant P0620"},
+	{CreativeInstant2, "Creative Instant P0620D"},
+	{QuickCamNB, "Logitech QuickCam for Notebooks"},
+	{WCam300AN, "Mustek WCam300AN "},
+	{LabtecWCPlus, "Labtec Webcam Plus"},
+	{GeniusVideoCamMessenger, "VideoCam Messenger sn9c101 Ov7630"},
+	{Pcam, "Mars-Semi Pc-Camera MR97311 MI0360"},
+	{GeniusDsc13, "Genius Dsc 1.3 Smart spca504B-P3"},
+	{MustekMDC4000, "Mustek MDC4000"},
+	{LogitechQCCommunicateSTX, "Logitech QuickCam Communicate STX"},
+	{Lic200, "LG LIC-200"},
+	{SweexTas5110, "Sweex SIF webcam"},
+	{Pccam168, "Sonix PcCam"},
+	{Sn535, "Sangha 350k"},
+	{Pccam, "Sonix Pccam +"},
+	{Lic300, "LG Lic-300"},
+	{PolaroidIon80, "Polaroid Ion 80"},
+	{Zc0305b, "Generic Zc0305b"},
+	{BtcPc380, "Sonix Btc PC380"},
+	{LogitechNotebookDeluxe, "Logitech Notebook Deluxe"},
+	{LabtecNotebook, "Labtec Webcam Notebook"},
+	{JvcGcA50, "JVC GC-A50"},
+	{SmileIntlCamera, "Smile International"},
+	{PcCam350, "PC-Cam350"},
+	{PAC207, "Pixart PAC207-BCA"},
+	{QtecWb100, "Qtec Webcam 100"},
+	{GeniusGe111, "Genius VideoCam Ge111"},
+	{Vimicro303b, "Generic Vimicro 303b"},
+	{CyberpixS550V, "Mercury Cyberpix S550V"},
+	{GeniusGF112, "Genius GF112"},
+	{LogitechQCim, "Logitech QCIM"},
+	{AiptekSlim3000F, "Aiptek Slim3000F"},
+	{CTXM730VCam, "CTX M730V built in Cam"},
+	{GeniusVideoCamNB, "Genius VideoCAM NB"},
+	{CreativeVistaPlus, "Creative Webcam Vista Plus"},
+	{PhilipsSPC200NC, "Philips SPC200NC "},
+	{PhilipsSPC210NC, "Philips SPC210NC (FB) "},
+	{PhilipsSPC700NC, "Philips SPC700NC "},
+	{SpeedNVC350K, "Speed NVC 350K "},
+	{Mustek330K, "Mustek Digicam 330K "},
+	{PhilipsSPC600NC, "Philips SPC600NC "},
+	{PhilipsSPC300NC, "Philips SPC300NC "},
+	{Sonix6019, "Sonix VGA Ov7630 "},
+	{LogitechQCImage, "Logitech QuickCam Image "},
+	{Sunplus500c, "Sunplus CA500C "},
+	{MustekMDC3500, "Mustek MDC3500"},
+	{LogitechQCCool, "Logitech QuickCam Cool"},
+	{QCimconnect, "Logitech QuickCam IM/Connect "},
+	{QCmessenger, "Logitech QuickCam Messenger "},
+	{CreativeLiveCamNotebookPro, "Creative Live!Cam Notebook Pro (VF0250)"},
+	{CreativeWebCamVistaPro, "Creative WebCam Vista Pro"},
+	{CreativeLiveCamVideoIM, "Creative Live Cam Video IM"},
+	{AiptekDV4100M, "Aiptek DV4100M"},
+	{TyphoonEasyCam1_3, "Typhoon Easy Cam 1.3 MPix"},
+	{Sonix0x613b, "Surfer model sn-206"},
+	{Sonix0x60fb, "Surfer model noname"},
+	{Sonyc002,"Vc0321"},
+	{Vimicro0321,"Vc0321"},
+	{Orbicam,"Logitech Orbicam"},
+	{MSVX1000,"MicroSoft VX1000"},
+	{MSVX3000,"MicroSoft VX3000"},
+	{Trust610LCDPowerCamZoom, "Trust 610 LCD PowerC@m Zoom"},
+	{Sonyc001,"Sony Visual Communication VGP-VCC1"},
+	{PhilipsSPC315NC, "Philips SPC315NC "},
+	{Sonix0x6138,"sn9c120+Mo4000"},
+	{GeniusEye311Q,"Genius Eye 311Q"},
+    	{PAC7311,"Pixart PAC7311"},
+    	{PAC7312,"Pixart PAC7312"},
+	{PhilipsDMVC1300K,"Philips DMVC 1300K"},
+	{-1, NULL}
+};
+static __devinitdata struct usb_device_id device_table[] = {
+	{USB_DEVICE(0x0733, 0x0430)},	/* Intel PC Camera Pro */
+	{USB_DEVICE(0x0733, 0x0401)},	/* Intel Create and Share */
+	{USB_DEVICE(0x99FA, 0x8988)},	/* Grandtec V.cap */
+	{USB_DEVICE(0x0733, 0x0402)},	/* ViewQuest M318B */
+	{USB_DEVICE(0x0733, 0x0110)},	/* ViewQuest VQ110 */
+	{USB_DEVICE(0x040A, 0x0002)},	/* Kodak DVC-325 */
+	{USB_DEVICE(0x055f, 0xc420)},	/* Mustek gSmart Mini 2 */
+	{USB_DEVICE(0x055f, 0xc520)},	/* Mustek gSmart Mini 3 */
+	{USB_DEVICE(0x041E, 0x400A)},	/* Creative PC-CAM 300 */
+	{USB_DEVICE(0x084D, 0x0003)},	/* D-Link DSC-350 */
+	{USB_DEVICE(0x041E, 0x400B)},	/* Creative PC-CAM 600 */
+	{USB_DEVICE(0x8086, 0x0630)},	/* Intel Pocket PC Camera */
+	{USB_DEVICE(0x8086, 0x0110)},	/* Intel Easy PC Camera */
+	{USB_DEVICE(0x0506, 0x00df)},	/* 3Com HomeConnect Lite */
+	{USB_DEVICE(0x040a, 0x0300)},	/* Kodak EZ200 */
+	{USB_DEVICE(0x04fc, 0x504b)},	/* Maxell MaxPocket LE 1.3 */
+	{USB_DEVICE(0x08ca, 0x2008)},	/* Aiptek Mini PenCam 2 M */
+	{USB_DEVICE(0x08ca, 0x0104)},	/* Aiptek PocketDVII 1.3 */
+	{USB_DEVICE(0x08ca, 0x2018)},	/* Aiptek Pencam SD 2M */
+	{USB_DEVICE(0x04fc, 0x504a)},	/* Aiptek Mini PenCam 1.3 */
+	{USB_DEVICE(0x055f, 0xc530)},	/* Mustek Gsmart LCD 3 */
+	{USB_DEVICE(0x055f, 0xc650)},	/* Mustek MDC5500Z */
+	{USB_DEVICE(0x052b, 0x1513)},	/* Megapix V4 */
+	{USB_DEVICE(0x08ca, 0x0103)},	/* Aiptek PocketDV */
+	{USB_DEVICE(0x0af9, 0x0010)},	/* Hama USB Sightcam 100 */
+	{USB_DEVICE(0x1776, 0x501c)},	/* Arowana 300K CMOS Camera */
+	{USB_DEVICE(0x08ca, 0x0106)},	/* Aiptek Pocket DV3100+ */
+	{USB_DEVICE(0x08ca, 0x2010)},	/* Aiptek PocketCam 3M */
+	{USB_DEVICE(0x0458, 0x7004)},	/* Genius VideoCAM Express V2 */
+	{USB_DEVICE(0x04fc, 0x0561)},	/* Flexcam 100 */
+	{USB_DEVICE(0x055f, 0xc430)},	/* Mustek Gsmart LCD 2 */
+	{USB_DEVICE(0x04fc, 0xffff)},	/* Pure DigitalDakota */
+	{USB_DEVICE(0xabcd, 0xcdee)},	/* Petcam */
+	{USB_DEVICE(0x04a5, 0x3008)},	/* Benq DC 1500 */
+	{USB_DEVICE(0x046d, 0x0960)},	/* Logitech Inc. ClickSmart 420 */
+	{USB_DEVICE(0x046d, 0x0901)},	/* Logitech Inc. ClickSmart 510 */
+	{USB_DEVICE(0x04a5, 0x3003)},	/* Benq DC 1300 */
+	{USB_DEVICE(0x0af9, 0x0011)},	/* Hama USB Sightcam 100 */
+	{USB_DEVICE(0x055f, 0xc440)},	/* Mustek DV 3000 */
+	{USB_DEVICE(0x041e, 0x4013)},	/* Creative Pccam750 */
+	{USB_DEVICE(0x060b, 0xa001)},	/* Maxell Compact Pc PM3 */
+	{USB_DEVICE(0x04a5, 0x300a)},	/* Benq DC3410 */
+	{USB_DEVICE(0x04a5, 0x300c)},	/* Benq DC1016 */
+	{USB_DEVICE(0x0461, 0x0815)},	/* Micro Innovation IC200 */
+	{USB_DEVICE(0x046d, 0x0890)},	/* Logitech QuickCam traveler */
+	{USB_DEVICE(0x10fd, 0x7e50)},	/* FlyCam Usb 100 */
+	{USB_DEVICE(0x06e1, 0xa190)},	/* ADS Instant VCD */
+	{USB_DEVICE(0x055f, 0xc220)},	/* Gsmart Mini */
+	{USB_DEVICE(0x0733, 0x2211)},	/* Jenoptik jdc 21 LCD */
+	{USB_DEVICE(0x046d, 0x0900)},	/* Logitech Inc. ClickSmart 310 */
+	{USB_DEVICE(0x055f, 0xc360)},	/* Mustek DV4000 Mpeg4  */
+	{USB_DEVICE(0x08ca, 0x2024)},	/* Aiptek DV3500 Mpeg4  */
+	{USB_DEVICE(0x046d, 0x0905)},	/* Logitech ClickSmart820  */
+	{USB_DEVICE(0x05da, 0x1018)},	/* Digital Dream Enigma 1.3 */
+	{USB_DEVICE(0x0c45, 0x6025)},	/* Xcam Shanga */
+	{USB_DEVICE(0x0733, 0x1311)},	/* Digital Dream Epsilon 1.3 */
+	{USB_DEVICE(0x041e, 0x401d)},	/* Creative Webcam NX ULTRA */
+	{USB_DEVICE(0x08ca, 0x2016)},	/* Aiptek PocketCam 2 Mega */
+	{USB_DEVICE(0x0734, 0x043b)},	/* 3DeMon USB Capture aka */
+	{USB_DEVICE(0x041E, 0x4018)},	/* Creative Webcam Vista (PD1100) */
+	{USB_DEVICE(0x0546, 0x3273)},	/* Polaroid PDC2030 */
+	{USB_DEVICE(0x041e, 0x401f)},	/* Creative Webcam Notebook PD1171 */
+	{USB_DEVICE(0x041e, 0x4017)},	/* Creative Webcam Mobile PD1090 */
+	{USB_DEVICE(0x046d, 0x08a2)},	/* Labtec Webcam Pro */
+	{USB_DEVICE(0x055f, 0xd003)},	/* Mustek WCam300A */
+	{USB_DEVICE(0x0458, 0x7007)},	/* Genius VideoCam V2 */
+	{USB_DEVICE(0x0458, 0x700c)},	/* Genius VideoCam V3 */
+	{USB_DEVICE(0x0458, 0x700f)},	/* Genius VideoCam Web V2 */
+	{USB_DEVICE(0x041e, 0x401e)},	/* Creative Nx Pro */
+	{USB_DEVICE(0x0c45, 0x6029)},	/* spcaCam@150 */
+	{USB_DEVICE(0x0c45, 0x6009)},	/* spcaCam@120 */
+	{USB_DEVICE(0x0c45, 0x600d)},	/* spcaCam@120 */
+	{USB_DEVICE(0x04fc, 0x5330)},	/* Digitrex 2110 */
+	{USB_DEVICE(0x055f, 0xc540)},	/* Gsmart D30 */
+	{USB_DEVICE(0x0ac8, 0x301b)},	/* Asam Vimicro */
+	{USB_DEVICE(0x041e, 0x403a)},	/* Creative Nx Pro 2 */
+	{USB_DEVICE(0x055f, 0xc211)},	/* Kowa Bs888e Microcamera */
+	{USB_DEVICE(0x0ac8, 0x0302)},	/* Z-star Vimicro zc0302 */
+	{USB_DEVICE(0x0572, 0x0041)},	/* Creative Notebook cx11646 */
+	{USB_DEVICE(0x08ca, 0x2022)},	/* Aiptek Slim 3200 */
+	{USB_DEVICE(0x046d, 0x0921)},	/* Labtec Webcam */
+	{USB_DEVICE(0x046d, 0x0920)},	/* QC Express */
+	{USB_DEVICE(0x0923, 0x010f)},	/* ICM532 cams */
+	{USB_DEVICE(0x055f, 0xc200)},	/* Mustek Gsmart 300 */
+	{USB_DEVICE(0x0733, 0x2221)},	/* Mercury Digital Pro 3.1p */
+	{USB_DEVICE(0x041e, 0x4036)},	/* Creative Live ! */
+	{USB_DEVICE(0x055f, 0xc005)},	/* Mustek Wcam300A */
+	{USB_DEVICE(0x041E, 0x403b)},	/* Creative Webcam Vista (VF0010) */
+	{USB_DEVICE(0x0545, 0x8333)},	/* Veo Stingray */
+	{USB_DEVICE(0x0545, 0x808b)},	/* Veo Stingray */
+	{USB_DEVICE(0x10fd, 0x8050)},	/* Typhoon Webshot II USB 300k */
+	{USB_DEVICE(0x0546, 0x3155)},	/* Polaroid PDC3070 */
+	{USB_DEVICE(0x046d, 0x0928)},	/* Logitech QC Express Etch2 */
+	{USB_DEVICE(0x046d, 0x092a)},	/* Logitech QC for Notebook */
+	{USB_DEVICE(0x046d, 0x08a0)},	/* Logitech QC IM */
+	{USB_DEVICE(0x0461, 0x0a00)},	/* MicroInnovation WebCam320 */
+	{USB_DEVICE(0x08ca, 0x2028)},	/* Aiptek PocketCam4M */
+	{USB_DEVICE(0x08ca, 0x2042)},	/* Aiptek PocketDV5100 */
+	{USB_DEVICE(0x08ca, 0x2060)},	/* Aiptek PocketDV5300 */
+	{USB_DEVICE(0x04fc, 0x5360)},	/* Sunplus Generic */
+	{USB_DEVICE(0x046d, 0x08a1)},	/* Logitech QC IM 0x08A1 +sound */
+	{USB_DEVICE(0x046d, 0x08a3)},	/* Logitech QC Chat */
+	{USB_DEVICE(0x046d, 0x08b9)},	/* Logitech QC IM ??? */
+	{USB_DEVICE(0x046d, 0x0929)},	/* Labtec Webcam Elch2 */
+	{USB_DEVICE(0x10fd, 0x0128)},	/* Typhoon Webshot II USB 300k 0x0128 */
+	{USB_DEVICE(0x102c, 0x6151)},	/* Qcam Sangha CIF */
+	{USB_DEVICE(0x102c, 0x6251)},	/* Qcam xxxxxx VGA */
+	{USB_DEVICE(0x04fc, 0x7333)},	/* PalmPixDC85 */
+	{USB_DEVICE(0x06be, 0x0800)},	/* Optimedia */
+	{USB_DEVICE(0x2899, 0x012c)},	/* Toptro Industrial */
+	{USB_DEVICE(0x06bd, 0x0404)},	/* Agfa CL20 */
+	{USB_DEVICE(0x046d, 0x092c)},	/* Logitech QC chat Elch2 */
+	{USB_DEVICE(0x0c45, 0x607c)},	/* Sonix sn9c102p Hv7131R */
+	{USB_DEVICE(0x0733, 0x3261)},	/* Concord 3045 spca536a */
+	{USB_DEVICE(0x0733, 0x1314)},	/* Mercury 2.1MEG Deluxe Classic Cam */
+	{USB_DEVICE(0x041e, 0x401c)},	/* Creative NX */
+	{USB_DEVICE(0x041e, 0x4034)},	/* Creative Instant P0620 */
+	{USB_DEVICE(0x041e, 0x4035)},	/* Creative Instant P0620D */
+	{USB_DEVICE(0x046d, 0x08ae)},	/* Logitech QuickCam for Notebooks */
+	{USB_DEVICE(0x055f, 0xd004)},	/* Mustek WCam300 AN */
+	{USB_DEVICE(0x046d, 0x092b)},	/* Labtec Webcam Plus */
+	{USB_DEVICE(0x0c45, 0x602e)},	/* Genius VideoCam Messenger */
+	{USB_DEVICE(0x0c45, 0x602c)},	/* Generic Sonix OV7630 */
+	{USB_DEVICE(0x093A, 0x050F)},	/* Mars-Semi Pc-Camera */
+	{USB_DEVICE(0x0458, 0x7006)},	/* Genius Dsc 1.3 Smart */
+	{USB_DEVICE(0x055f, 0xc630)},	/* Mustek MDC4000 */
+	{USB_DEVICE(0x046d, 0x08ad)},	/* Logitech QCCommunicate STX */
+	{USB_DEVICE(0x0c45, 0x602d)},	/* LIC-200 LG */
+	{USB_DEVICE(0x0c45, 0x6005)},	/* Sweex Tas5110 */
+	{USB_DEVICE(0x0c45, 0x613c)},	/* Sonix Pccam168 */
+	{USB_DEVICE(0x0c45, 0x6130)},	/* Sonix Pccam */
+	{USB_DEVICE(0x0c45, 0x60c0)},	/* Sangha Sn535 */
+	{USB_DEVICE(0x0c45, 0x60fc)},	/* LG-LIC300 */
+	{USB_DEVICE(0x0546, 0x3191)},	/* Polaroid Ion 80 */
+	{USB_DEVICE(0x0ac8, 0x305b)},	/* Z-star Vimicro zc0305b */
+	{USB_DEVICE(0x0c45, 0x6028)},	/* Sonix Btc Pc380 */
+	{USB_DEVICE(0x046d, 0x08a9)},	/* Logitech Notebook Deluxe */
+	{USB_DEVICE(0x046d, 0x08aa)},	/* Labtec Webcam  Notebook */
+	{USB_DEVICE(0x04f1, 0x1001)},	/* JVC GC A50 */
+	{USB_DEVICE(0x0497, 0xc001)},	/* Smile International */
+	{USB_DEVICE(0x041e, 0x4012)},	/* PC-Cam350 */
+	{USB_DEVICE(0x0ac8, 0x303b)},	/* Vimicro 0x303b */
+	{USB_DEVICE(0x093a, 0x2468)},	/* PAC207 */
+	{USB_DEVICE(0x093a, 0x2471)},	/* PAC207 Genius VideoCam ge111 */
+	{USB_DEVICE(0x093a, 0x2460)},	/* PAC207 Qtec Webcam 100 */
+	{USB_DEVICE(0x0733, 0x3281)},	/* Cyberpix S550V */
+	{USB_DEVICE(0x093a, 0x2470)},	/* Genius GF112 */
+	{USB_DEVICE(0x046d, 0x08a6)},	/* Logitech QCim */
+	{USB_DEVICE(0x08ca, 0x2020)},	/* Aiptek Slim 3000F */
+	{USB_DEVICE(0x0698, 0x2003)},	/* CTX M730V built in */
+	{USB_DEVICE(0x0c45, 0x6001)},	/* Genius VideoCAM NB */
+	{USB_DEVICE(0x041E, 0x4028)},	/* Creative Webcam Vista Plus */
+	{USB_DEVICE(0x0471, 0x0325)},	/* Philips SPC 200 NC */
+	{USB_DEVICE(0x0471, 0x0328)},	/* Philips SPC 700 NC */
+	{USB_DEVICE(0x0c45, 0x6040)},	/* Speed NVC 350K */
+	{USB_DEVICE(0x055f, 0xc230)},	/* Mustek Digicam 330K */
+	{USB_DEVICE(0x0c45, 0x6007)},	/* Sonix sn9c101 + Tas5110D */
+	{USB_DEVICE(0x0471, 0x0327)},	/* Philips SPC 600 NC */
+	{USB_DEVICE(0x0471, 0x0326)},	/* Philips SPC 300 NC */
+	{USB_DEVICE(0x0c45, 0x6019)},	/* Generic Sonix OV7630 */
+	{USB_DEVICE(0x0c45, 0x6024)},	/* Generic Sonix Tas5130c */
+	{USB_DEVICE(0x046d, 0x08a7)},	/* Logitech QuickCam Image */
+	{USB_DEVICE(0x04fc, 0x500c)},	/* Sunplus CA500C */
+	{USB_DEVICE(0x055f, 0xc232)},	/* Mustek MDC3500 */
+	{USB_DEVICE(0x046d, 0x08ac)},	/* Logitech QuickCam Cool */
+	{USB_DEVICE(0x046d, 0x08d9)},	/* Logitech QuickCam IM/Connect */
+	{USB_DEVICE(0x046d, 0x08da)},	/* Logitech QuickCam Messenger */
+	{USB_DEVICE(0x046d, 0x092d)},	/* Logitech QC  Elch2 */
+	{USB_DEVICE(0x046d, 0x092e)},	/* Logitech QC  Elch2 */
+	{USB_DEVICE(0x046d, 0x092f)},	/* Logitech QC  Elch2 */
+	{USB_DEVICE(0x041e, 0x4051)},	/* Creative Live!Cam Notebook Pro (VF0250)*/
+	{USB_DEVICE(0x041E, 0x4029)},	/* Creative WebCam Vista Pro */
+	{USB_DEVICE(0x041E, 0x041E)},	/* Creative WebCam Live! */
+	{USB_DEVICE(0x041e, 0x4053)},	/* Creative Live!Cam Video IM*/
+	{USB_DEVICE(0x046d, 0x08d7)},	/* Logitech QCam STX */
+	{USB_DEVICE(0x046d, 0x08d8)},	/* Logitech Notebook Deluxe */
+	{USB_DEVICE(0x08ca, 0x2040)},	/* Aiptek PocketDV4100M */
+	{USB_DEVICE(0x0c45, 0x612c)},	/* Typhoon Rasy Cam 1.3MPix */
+	{USB_DEVICE(0x0c45, 0x613b)},	/* Surfer SN-206 */
+	{USB_DEVICE(0x0c45, 0x60fb)},	/* Surfer NoName */
+	{USB_DEVICE(0x0ac8, 0xc002)},	/* Sony embedded vimicro*/
+	{USB_DEVICE(0x0ac8, 0x0321)},	/* Vimicro generic vc0321 */
+	{USB_DEVICE(0x046d, 0x0892)},	/* Logitech Orbicam */
+	{USB_DEVICE(0x046d, 0x0896)},	/* Logitech Orbicam */
+	{USB_DEVICE(0x045e, 0x00f7)},	/* MicroSoft VX1000 */
+	{USB_DEVICE(0x045e, 0x00f5)},	/* MicroSoft VX3000 */
+	{USB_DEVICE(0x0471, 0x032d)},	/* Philips spc210nc*/
+	{USB_DEVICE(0x06d6, 0x0031)},	/* Trust 610 LCD PowerC@m Zoom (webcam mode) */
+	{USB_DEVICE(0x0ac8, 0xc001)},	/* Sony embedded vimicro*/
+	{USB_DEVICE(0x0471, 0x032e)},	/* Philips spc315nc*/
+	{USB_DEVICE(0x0c45, 0x6138)},	/* Sn9c120 Mo4000 */
+	{USB_DEVICE(0x041E, 0x401a)},	/* Creative Webcam Vista (PD1100) */
+	{USB_DEVICE(0x0458, 0x7025)},	/* Genius Eye 311Q sn9c120+Mi360 */
+  	{USB_DEVICE(0x093a, 0x2600)},	/* PAC7311 Typhoon */
+  	{USB_DEVICE(0x093a, 0x2601)},	/* PAC7311 Phillips SPC610NC */
+  	{USB_DEVICE(0x093a, 0x2603)},	/* PAC7312  */
+  	{USB_DEVICE(0x093a, 0x2608)},	/* PAC7311 Trust WB-3300p */
+  	{USB_DEVICE(0x093a, 0x260e)},	/* PAC7311 Gigaware VGA PC Camera, Trust WB-3350p, SIGMA cam 2350 */
+  	{USB_DEVICE(0x093a, 0x260f)},   /* PAC7311 SnakeCam */
+	{USB_DEVICE(0x0471, 0x0322)},	/* Philips DMVC1300K */
+	{USB_DEVICE(0x0000, 0x0000)},	/* MystFromOri Unknow Camera */
+	{}			/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, device_table);
+/*
+Let's include the initialization data for each camera type
+*/
+#include "utils/spcausb.h"
+#include "Sunplus/spca501_init.h"
+#include "Sunplus/spca505_init.h"
+#include "Sunplus/spca506.h"
+#include "Sunplus/spca508_init.h"
+#include "Sunplus/spca561.h"
+#include "Sunplus-jpeg/jpeg_qtables.h"
+#include "Sunplus-jpeg/spca500_init.h"
+#include "Sunplus-jpeg/sp5xxfw2.h"
+#include "Sonix/sonix.h"
+#include "Vimicro/zc3xx.h"
+#include "Conexant/cx11646.h"
+#include "Transvision/tv8532.h"
+#include "Etoms/et61xx51.h"
+#include "Mars-Semi/mr97311.h"
+#include "Pixart/pac207.h"
+#include "Pixart/pac7311.h"
+#include "Vimicro/vc032x.h"
+/* function for the tasklet */
+void outpict_do_tasklet(unsigned long ptr);
+/**********************************************************************
+*
+* Memory management
+**********************************************************************/
+static inline unsigned long
+kvirt_to_pa(unsigned long adr)
+{
+	unsigned long kva, ret;
+	kva = (unsigned long) page_address(vmalloc_to_page((void *) adr));
+	kva |= adr & (PAGE_SIZE - 1);
+	ret = __pa(kva);
+	return ret;
+}
+static void *
+rvmalloc(unsigned long size)
+{
+	void *mem;
+	unsigned long adr;
+	size = PAGE_ALIGN(size);
+	mem = vmalloc_32(size);
+	if (!mem)
+		return NULL;
+	memset(mem, 0, size);	/* Clear the ram out, no junk to the user */
+	adr = (unsigned long) mem;
+	while ((long) size > 0) {
+		SetPageReserved(vmalloc_to_page((void *) adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	return mem;
+}
+static void
+rvfree(void *mem, unsigned long size)
+{
+	unsigned long adr;
+	if (!mem)
+		return;
+	adr = (unsigned long) mem;
+	while ((long) size > 0) {
+		ClearPageReserved(vmalloc_to_page((void *) adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	vfree(mem);
+}
+/* ------------------------------------------------------------------------ */
+/**
+* Endpoint management we assume one isoc endpoint per device
+* that is not true some Zoran 0x0572:0x0001 have two
+* assume ep adresse is static know 
+* FIXME as I don't know how to set the bandwith budget
+* we allow the maximum
+**/
+static struct usb_host_endpoint *
+gspca_set_isoc_ep(struct usb_spca50x *spca50x, int nbalt)
+{
+	int i, j;
+	struct usb_interface *intf;
+	struct usb_host_endpoint *ep;
+	struct usb_device *dev = spca50x->dev;
+	struct usb_host_interface *altsetting = NULL;
+	int error = 0;
+	PDEBUG(3, "enter get iso ep ");
+	intf = usb_ifnum_to_if(dev, spca50x->iface);	
+/* bandwith budget can be set here */
+	for (i = nbalt; i; i--) {
+		altsetting = &intf->altsetting[i];
+		for (j = 0; j < altsetting->desc.bNumEndpoints; ++j) {
+			ep = &altsetting->endpoint[j];
+			PDEBUG(3, "test ISO EndPoint  %d",ep->desc.bEndpointAddress);
+			if ((ep->desc.bEndpointAddress ==
+			     (spca50x->epadr | USB_DIR_IN))
+			    &&
+			    ((ep->desc.
+			      bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+			     USB_ENDPOINT_XFER_ISOC)) {
+				PDEBUG(0, "ISO EndPoint found 0x%02X AlternateSet %d",
+				       ep->desc.bEndpointAddress,i);
+				if ((error =
+				     usb_set_interface(dev, spca50x->iface,
+						       i)) < 0) {
+					PDEBUG(0, "Set interface err %d",
+					       error);
+					return NULL;
+				}
+				spca50x->alt = i;
+				return ep;
+			}
+		}
+	}
+	PDEBUG(0, "FATAL ISO EndPoint not found ");
+	return NULL;
+}
+
+static int
+gspca_set_alt0(struct usb_spca50x *spca50x)
+{
+	int error = 0;
+	if ((error = usb_set_interface(spca50x->dev, spca50x->iface, 0)) < 0) {
+		PDEBUG(0, "Set interface err %d", error);
+	}
+	spca50x->alt = 0;
+	return  error;
+}
+static int
+gspca_kill_transfert(struct usb_spca50x *spca50x)
+{
+	struct urb *urb;
+	unsigned int i;
+	spca50x->streaming = 0;
+	for (i = 0; i <  SPCA50X_NUMSBUF; ++i) {
+		if ((urb = spca50x->sbuf[i].urb) == NULL)
+			continue;
+
+		usb_kill_urb(urb);
+		/* urb->transfer_buffer_length is not touched by USB core, so
+		 * we can use it here as the buffer length.
+		 */
+		if (spca50x->sbuf[i].data) {
+			// kfree(gspca_dev->sbuf[i].data);
+		
+			usb_buffer_free(spca50x->dev,
+				urb->transfer_buffer_length,
+				spca50x->sbuf[i].data, urb->transfer_dma);
+		
+			spca50x->sbuf[i].data = NULL;
+		}
+
+		usb_free_urb(urb);
+		spca50x->sbuf[i].urb = NULL;
+	}
+	return 0;
+}
+ 
+
+
+static int
+gspca_init_transfert(struct usb_spca50x *spca50x)
+{
+	struct usb_host_endpoint *ep;
+	struct usb_interface *intf;
+	struct urb *urb;
+	__u16 psize;
+	int n,fx;
+	struct usb_device *dev = spca50x->dev;
+//	struct usb_host_interface *altsetting = NULL;
+	int error = -ENOSPC;
+	int nbalt = 0;
+	
+	if (spca50x->streaming)
+		return -EBUSY;
+	intf = usb_ifnum_to_if(dev, spca50x->iface);
+	nbalt = intf->num_altsetting - 1;
+	/* Damned Sunplus fault */
+	if(spca50x->bridge == BRIDGE_SPCA561) 
+		nbalt =7;
+	PDEBUG(3, "get iso nbalt %d",nbalt);
+	spca50x->curframe = 0;	
+while (nbalt && (error == -ENOSPC)) {
+		if ((ep = gspca_set_isoc_ep(spca50x,nbalt--)) == NULL)
+			return -EIO;
+		psize = le16_to_cpu(ep->desc.wMaxPacketSize);
+		psize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));
+		PDEBUG(3, "packet size %d", psize);
+		for (n = 0; n < SPCA50X_NUMSBUF; n++) {
+			urb = usb_alloc_urb(FRAMES_PER_DESC, GFP_KERNEL);
+			if (!urb) {
+				err("init isoc: usb_alloc_urb ret. NULL");
+				return -ENOMEM;
+			}
+			
+			spca50x->sbuf[n].data = usb_buffer_alloc(spca50x->dev,
+					psize * FRAMES_PER_DESC,
+					GFP_KERNEL, &urb->transfer_dma);
+			
+			//gspca_dev->sbuf[n].data = kmalloc((psize+1)* FRAMES_PER_DESC,GFP_KERNEL);
+			
+			if(spca50x->sbuf[n].data == NULL){
+				usb_free_urb(urb);
+				gspca_kill_transfert(spca50x);
+				return -ENOMEM;
+			}
+			spca50x->sbuf[n].urb = urb;
+			urb->dev = spca50x->dev;
+			urb->context = spca50x;
+			urb->pipe =
+			    usb_rcvisocpipe(spca50x->dev,
+					    ep->desc.bEndpointAddress);
+			urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
+			urb->interval = ep->desc.bInterval;
+			urb->transfer_buffer = spca50x->sbuf[n].data;
+			urb->complete = spca50x_isoc_irq;
+			urb->number_of_packets = FRAMES_PER_DESC;
+			urb->transfer_buffer_length = psize * FRAMES_PER_DESC;
+			for (fx = 0; fx < FRAMES_PER_DESC; fx++) {
+				urb->iso_frame_desc[fx].offset = psize * fx;
+				urb->iso_frame_desc[fx].length = psize;
+			}
+		}
+		
+	
+	/* mark all frame unused */
+	for (n = 0; n <  SPCA50X_NUMFRAMES; n++) {
+		spca50x->frame[n].grabstate = FRAME_UNUSED;
+		spca50x->frame[n].scanstate = STATE_SCANNING;
+	}
+	/* start the cam and initialize the tasklet lock */
+	spca50x->funct.start(spca50x);
+	spca50x->streaming = 1;
+	atomic_set(&spca50x->in_use,0);
+	PDEBUG(3, "Submit URB Now");
+	/* Submit the URBs. */
+	for (n = 0; n < SPCA50X_NUMSBUF; ++n) {
+		if ((error = usb_submit_urb(spca50x->sbuf[n].urb, GFP_KERNEL)) < 0) {
+			err("init isoc: usb_submit_urb(%d) ret %d", n, error);
+			gspca_kill_transfert(spca50x);
+			break;	
+		}
+	
+	}
+	}
+	return error;
+}
+
+/* Returns number of bits per pixel (regardless of where they are located; planar or
+* not), or zero for unsupported format.
+*/
+static int
+spca5xx_get_depth(struct usb_spca50x *spca50x, int palette)
+{
+	switch (palette) {
+//      case VIDEO_PALETTE_GREY:     return 8;
+	case VIDEO_PALETTE_RGB565:
+		return 16;
+	case VIDEO_PALETTE_RGB24:
+		return 24;
+//      case VIDEO_PALETTE_YUV422:   return 16;
+//      case VIDEO_PALETTE_YUYV:
+// return 16;
+//      case VIDEO_PALETTE_YUV420:   return 24;
+	case VIDEO_PALETTE_YUV420P:
+		return 12;	/* strange need 12 this break the read method for this planar mode (6*8/4) */
+//      case VIDEO_PALETTE_YUV422P:  return 24; /* Planar */
+	case VIDEO_PALETTE_RGB32:
+		return 32;
+	case VIDEO_PALETTE_RAW_JPEG:
+		return 24;	/* raw jpeg. what should we return ?? */
+	case VIDEO_PALETTE_JPEG:
+		if (spca50x->cameratype == JPEG ||
+		    spca50x->cameratype == JPGH ||
+		    spca50x->cameratype == JPGC ||
+		    spca50x->cameratype == JPGS ||
+  		    spca50x->cameratype == JPGM ||
+  		    spca50x->cameratype == PJPG) {
+			return 8;
+		} else
+			return 0;
+	default:
+		return 0;	/* Invalid format */
+	}
+}
+
+/**********************************************************************
+* spca50x_isoc_irq
+* Function processes the finish of the USB transfer by calling 
+* spca50x_move_data function to move data from USB buffer to internal
+* driver structures 
+***********************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static void
+spca50x_isoc_irq(struct urb *urb, struct pt_regs *regs)
+#else
+static void
+spca50x_isoc_irq(struct urb *urb)
+#endif
+{
+	int i;
+	struct usb_spca50x *spca50x = (struct usb_spca50x *) urb->context;
+	int len;
+	switch (urb->status) {
+	case 0:
+		break;
+	default:
+		PDEBUG(0, "Non-zero status (%d) in isoc "
+		       "completion handler.", urb->status);
+	case -ENOENT:		/* usb_kill_urb() called. */
+	case -ECONNRESET:	/* usb_unlink_urb() called. */
+	case -ESHUTDOWN:	/* The endpoint is being disabled. */
+		return;
+	}
+	if (!spca50x->dev) {
+		PDEBUG(4, "no device ");
+		return;
+	}
+	if (!spca50x->user) {
+		PDEBUG(4, "device not open");
+		return;
+	}
+	if (!spca50x->streaming) {
+/* Always get some of these after close but before packet engine stops */
+		PDEBUG(4, "hmmm... not streaming, but got interrupt");
+		return;
+	}
+	if (!spca50x->present) {
+/*  */
+		PDEBUG(4, "device disconnected ..., but got interrupt !!");
+		return;
+	}
+/* Copy the data received into our scratch buffer */
+	if (spca50x->curframe >= 0) {
+		len = spca50x_move_data(spca50x, urb);
+	} else if (waitqueue_active(&spca50x->wq)) {
+		wake_up_interruptible(&spca50x->wq);
+	}
+/* Move to the next sbuf */
+
+	urb->dev = spca50x->dev;
+	urb->status = 0;
+	if ((i = usb_submit_urb(urb, GFP_ATOMIC)) != 0)
+		err("usb_submit_urb() ret %d", i);
+	return;
+}
+
+static void
+spca50x_stop_isoc(struct usb_spca50x *spca50x)
+{
+	if (!spca50x->streaming || !spca50x->dev)
+		return;
+	PDEBUG(3, "*** Stopping capture ***");
+	spca50x->funct.stopN(spca50x);
+	gspca_kill_transfert(spca50x);
+	gspca_set_alt0(spca50x);
+	spca50x->funct.stop0(spca50x);
+	PDEBUG(3, "*** Capture stopped ***");
+}
+
+/**********************************************************************
+* spca50x_smallest_mode_index
+* Function finds the mode index in the modes table of the smallest
+* available mode.
+***********************************************************************/
+static int
+spca5xx_getDefaultMode(struct usb_spca50x *spca50x)
+{
+	int i;
+	for (i = QCIF; i < TOTMODE; i++) {
+		if (spca50x->mode_cam[i].method == 0
+		    && spca50x->mode_cam[i].width) {
+			spca50x->width = spca50x->mode_cam[i].width;
+			spca50x->height = spca50x->mode_cam[i].height;
+			spca50x->method = 0;
+			spca50x->pipe_size = spca50x->mode_cam[i].pipe;
+			spca50x->mode = spca50x->mode_cam[i].mode;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/**********************************************************************
+* spca50x_set_mode
+* Function sets up the resolution directly. 
+* Attention!!! index, the index in modes array is NOT checked. 
+***********************************************************************/
+static int
+spca5xx_getcapability(struct usb_spca50x *spca50x)
+{
+	int maxw, maxh, minw, minh;
+	int i;
+	minw = minh = 255 * 255;
+	maxw = maxh = 0;
+	for (i = QCIF; i < TOTMODE; i++) {
+		if (spca50x->mode_cam[i].width) {
+			if (maxw < spca50x->mode_cam[i].width
+			    || maxh < spca50x->mode_cam[i].height) {
+				maxw = spca50x->mode_cam[i].width;
+				maxh = spca50x->mode_cam[i].height;
+			}
+			if (minw > spca50x->mode_cam[i].width
+			    || minh > spca50x->mode_cam[i].height) {
+				minw = spca50x->mode_cam[i].width;
+				minh = spca50x->mode_cam[i].height;
+			}
+		}
+	}
+	spca50x->maxwidth = maxw;
+	spca50x->maxheight = maxh;
+	spca50x->minwidth = minw;
+	spca50x->minheight = minh;
+	PDEBUG(0, "maxw %d maxh %d minw %d minh %d", maxw, maxh, minw, minh);
+	return 0;
+}
+static int
+wxh_to_size(int width, int height)
+{
+	switch (width) {
+	case 640:
+		if (height == 480)
+			return VGA;
+		break;
+	case 384:
+		if (height == 288)
+			return PAL;
+		break;
+	case 352:
+		if (height == 288)
+			return SIF;
+		break;
+	case 320:
+		if (height == 240)
+			return CIF;
+		break;
+	case 192:
+		if (height == 144)
+			return QPAL;
+		break;
+	case 176:
+		if (height == 144)
+			return QSIF;
+		break;
+	case 160:
+		if (height == 120)
+			return QCIF;
+		break;
+	}
+	return -EINVAL;
+}
+static int
+v4l_to_spca5xx(int format)
+{
+	switch (format) {
+	case VIDEO_PALETTE_RGB565:
+		return P_RGB16;
+	case VIDEO_PALETTE_RGB24:
+		return P_RGB24;
+	case VIDEO_PALETTE_RGB32:
+		return P_RGB32;
+	case VIDEO_PALETTE_YUV422P:
+		return P_YUV422;
+	case VIDEO_PALETTE_YUV420P:
+		return P_YUV420;
+	case VIDEO_PALETTE_RAW_JPEG:
+		return P_RAW;
+	case VIDEO_PALETTE_JPEG:
+		return P_JPEG;
+	default:
+		return -EINVAL;
+	}
+}
+static inline int
+spca5xx_setMode(struct usb_spca50x *spca50x, int width, int height, int format)
+{
+	int i, j;
+	int formatIn;
+	int crop = 0, cropx1 = 0, cropx2 = 0, cropy1 = 0, cropy2 = 0, x =
+	    0, y = 0;
+/* Avoid changing to already selected mode */
+/* convert V4l format to our internal format */
+	PDEBUG(3, "spca5xx set mode asked w %d h %d p %d", width, height,
+	       format);
+	if ((formatIn = v4l_to_spca5xx(format)) < 0)
+		return -EINVAL;
+	for (i = QCIF; i < TOTMODE; i++) {
+		if ((spca50x->mode_cam[i].width == width) &&
+		    (spca50x->mode_cam[i].height == height) &&
+		    (spca50x->mode_cam[i].t_palette & formatIn)) {
+			spca50x->width = spca50x->mode_cam[i].width;
+			spca50x->height = spca50x->mode_cam[i].height;
+			spca50x->pipe_size = spca50x->mode_cam[i].pipe;
+			spca50x->mode = spca50x->mode_cam[i].mode;
+			spca50x->method = spca50x->mode_cam[i].method;
+			spca50x->format = format;	//palette in use
+			if (spca50x->method) {
+				if (spca50x->method == 1) {
+					for (j = i; j < TOTMODE; j++) {
+						if (spca50x->mode_cam[j].
+						    method == 0
+						    && spca50x->mode_cam[j].
+						    width) {
+							spca50x->hdrwidth =
+							    spca50x->
+							    mode_cam[j].width;
+							spca50x->hdrheight =
+							    spca50x->
+							    mode_cam[j].height;
+							spca50x->mode = spca50x->mode_cam[j].mode;	// overwrite by the hardware mode
+							break;
+						}
+					}	// end match hardware mode
+					if (!spca50x->hdrwidth
+					    && !spca50x->hdrheight)
+						return -EINVAL;
+				}
+			}
+/* match found */
+			break;
+		}
+	}			// end match mode
+/* initialize the hdrwidth and hdrheight for the first init_source */
+/* precompute the crop x y value for each frame */
+	if (!spca50x->method) {
+/* nothing todo hardware found stream */
+		cropx1 = cropx2 = cropy1 = cropy2 = x = y = 0;
+		spca50x->hdrwidth = spca50x->width;
+		spca50x->hdrheight = spca50x->height;
+	}
+	if (spca50x->method & 0x01) {
+/* cropping method */
+		if (spca50x->hdrwidth > spca50x->width) {
+			crop = (spca50x->hdrwidth - spca50x->width);
+			if (spca50x->cameratype == JPEG
+			    || spca50x->cameratype == JPGH
+			    || spca50x->cameratype == JPGS
+				|| spca50x->cameratype == PJPG)
+				crop = crop >> 4;
+			cropx1 = crop >> 1;
+			cropx2 = cropx1 + (crop % 2);
+		} else {
+			cropx1 = cropx2 = 0;
+		}
+		if (spca50x->hdrheight > spca50x->height) {
+			crop = (spca50x->hdrheight - spca50x->height);
+			if (spca50x->cameratype == JPEG)
+				crop = crop >> 4;
+			if (spca50x->cameratype == JPGH
+			    || spca50x->cameratype == JPGS
+			    || spca50x->cameratype == PJPG)
+				crop = crop >> 3;
+			cropy1 = crop >> 1;
+			cropy2 = cropy1 + (crop % 2);
+		} else {
+			cropy1 = cropy2 = 0;
+		}
+	}
+	if (spca50x->method & 0x02) {
+/* what can put here for div method */
+	}
+	if (spca50x->method & 0x04) {
+/* and here for mult */
+	}
+	PDEBUG(2, "Found code %d method %d", spca50x->mode, spca50x->method);
+	PDEBUG(2, "Soft Win width height %d x %d", spca50x->width,
+	       spca50x->height);
+	PDEBUG(2, "Hard Win width height %d x %d", spca50x->hdrwidth,
+	       spca50x->hdrheight);
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
+		spca50x->frame[i].method = spca50x->method;
+		spca50x->frame[i].cameratype = spca50x->cameratype;
+		spca50x->frame[i].cropx1 = cropx1;
+		spca50x->frame[i].cropx2 = cropx2;
+		spca50x->frame[i].cropy1 = cropy1;
+		spca50x->frame[i].cropy2 = cropy2;
+		spca50x->frame[i].x = x;
+		spca50x->frame[i].y = y;
+		spca50x->frame[i].hdrwidth = spca50x->hdrwidth;
+		spca50x->frame[i].hdrheight = spca50x->hdrheight;
+		spca50x->frame[i].width = spca50x->width;
+		spca50x->frame[i].height = spca50x->height;
+		spca50x->frame[i].format = spca50x->format;
+		spca50x->frame[i].scanlength =
+		    spca50x->width * spca50x->height * 3 / 2;
+// ?? assumes 4:2:0 data
+	}
+	return 0;
+}
+
+/**********************************************************************
+* spca50x_mode_init_regs
+* Function sets up the resolution with checking if it's necessary 
+***********************************************************************/
+static int
+spca5xx_restartMode(struct usb_spca50x *spca50x, int width, int height,
+		    int format)
+{
+	int was_streaming;
+	int r;
+/* Avoid changing to already selected mode */
+	if (spca50x->width == width && spca50x->height == height)
+		return 0;
+	PDEBUG(1, "Mode changing to %d,%d", width, height);
+	was_streaming = spca50x->streaming;
+/* FIXME spca500 bridge is there a way to find an init like 
+Clicksmart310 ? */
+	if (was_streaming) {
+		if ((spca50x->bridge != BRIDGE_SPCA500)
+		    || (spca50x->desc == LogitechClickSmart310))
+			spca50x_stop_isoc(spca50x);
+	}
+	r = spca5xx_setMode(spca50x, width, height, format);
+	if (r < 0)
+		goto out;
+	if (was_streaming) {
+		if ((spca50x->bridge != BRIDGE_SPCA500)
+		    || (spca50x->desc == LogitechClickSmart310)) {
+			r = gspca_init_transfert(spca50x);
+		} else {
+			spca50x->funct.start(spca50x);
+		}
+	}
+      out:
+	return r;
+}
+#if 0
+/**********************************************************************
+*
+* SPCA50X data transfer, IRQ handler
+*
+**********************************************************************/
+static struct spca50x_frame *
+spca50x_next_frame(struct usb_spca50x
+		   *spca50x, unsigned char *cdata)
+{
+	int iFrameNext;
+	struct spca50x_frame *frame = NULL;
+	PDEBUG(2, "Frame %d State %d", spca50x->curframe,
+	       spca50x->frame[spca50x->curframe].grabstate);
+	if (spca50x->frame[spca50x->curframe].grabstate == FRAME_ERROR) {
+		PDEBUG(2, "Frame %d errdrop", spca50x->curframe);
+		frame = &spca50x->frame[spca50x->curframe];
+		goto dropframe;
+	}
+/* Cycle through the frame buffer looking for a free frame to overwrite */
+	iFrameNext = (spca50x->curframe + 1) % SPCA50X_NUMFRAMES;
+	while (frame == NULL && iFrameNext != (spca50x->curframe)) {
+		if (spca50x->frame[iFrameNext].grabstate == FRAME_READY ||
+		    spca50x->frame[iFrameNext].grabstate == FRAME_UNUSED ||
+		    spca50x->frame[iFrameNext].grabstate == FRAME_ERROR) {
+			spca50x->curframe = iFrameNext;
+			frame = &spca50x->frame[iFrameNext];
+			break;
+		} else {
+			iFrameNext = (iFrameNext + 1) % SPCA50X_NUMFRAMES;
+		}
+	}
+	if (frame == NULL) {
+		PDEBUG(3, "Can't find a free frame to grab into...using next. "
+		       "This is caused by the application not reading fast enough.");
+		spca50x->curframe = (spca50x->curframe + 1) % SPCA50X_NUMFRAMES;
+		frame = &spca50x->frame[spca50x->curframe];
+	}
+
+dropframe:
+	frame->grabstate = FRAME_GRABBING;
+	if (spca50x->pictsetting.change) {
+		memcpy(&frame->pictsetting, &spca50x->pictsetting,
+		       sizeof (struct pictparam));
+/* reset flag change */
+		spca50x->pictsetting.change = 0;
+		PDEBUG(2, "Picture setting change Pass to decoding   ");
+	}
+/* Reset some per-frame variables */
+	frame->highwater = frame->data;
+	frame->scanstate = STATE_LINES;
+	frame->scanlength = 0;
+	frame->last_packet = -1;
+	frame->totlength = 0;
+	spca50x->packet = 0;
+out:
+	return frame;
+}
+#endif
+/**********************************************************************
+*
+* SPCA50X data transfer, IRQ handler
+*
+**********************************************************************/
+static struct spca50x_frame *
+spca50x_next_frame(struct usb_spca50x
+		   *spca50x, unsigned char *cdata)
+{
+	struct spca50x_frame *frame = NULL;
+	PDEBUG(2, "Frame %d State %d", spca50x->curframe,
+	       spca50x->frame[spca50x->curframe].grabstate);
+	if (spca50x->frame[spca50x->curframe].grabstate != FRAME_ERROR) 
+		spca50x->curframe = (spca50x->curframe + 1) % SPCA50X_NUMFRAMES;	
+	frame = &spca50x->frame[spca50x->curframe];
+	if (spca50x->pictsetting.change) {
+		memcpy(&frame->pictsetting, &spca50x->pictsetting,
+		       sizeof (struct pictparam));
+/* reset flag change */
+		spca50x->pictsetting.change = 0;
+		PDEBUG(2, "Picture setting change Pass to decoding   ");
+	}
+/* Reset some per-frame variables */
+	frame->grabstate = FRAME_GRABBING;
+	frame->scanstate = STATE_LINES;
+	frame->highwater = frame->data;
+	frame->scanlength = 0;
+	frame->last_packet = -1;
+	frame->totlength = 0;
+	spca50x->packet = 0;
+	return frame;
+}
+/* Tasklet function to decode */
+void
+outpict_do_tasklet(unsigned long ptr)
+{
+	int err;
+	struct spca50x_frame *taskletframe = (struct spca50x_frame *) ptr;
+	taskletframe->scanlength = taskletframe->highwater - taskletframe->data;
+	PDEBUG(2,
+	       "Tasklet ask spcadecoder hdrwidth %d hdrheight %d method %d ",
+	       taskletframe->hdrwidth, taskletframe->hdrheight,
+	       taskletframe->method);
+	if ((err = spca50x_outpicture(taskletframe)) < 0) {
+		PDEBUG(2, "frame decoder failed (%d)", err);
+		taskletframe->grabstate = FRAME_ERROR;
+	} else {
+		taskletframe->grabstate = FRAME_DONE;
+		PDEBUG(2, "Decode framestate return %d",
+		       taskletframe->grabstate);
+	}
+	if (waitqueue_active(&taskletframe->wq))
+		wake_up_interruptible(&taskletframe->wq);
+	atomic_set(&taskletframe->spca50x_dev->in_use,0);
+}
+
+/*********************************************************************
+time Helper function
+**********************************************************************/
+static inline unsigned long
+spca5xx_gettimes(void)
+{
+	u64 times_now;
+	times_now = get_jiffies_64();
+	return jiffies_to_msecs(times_now);
+}
+
+/* ******************************************************************
+* spca50x_move_data
+* Function serves for moving data from USB transfer buffers
+* to internal driver frame buffers.
+******************************************************************* */
+static int
+spca50x_move_data(struct usb_spca50x *spca50x, struct urb *urb)
+{
+	unsigned char *cdata;	//Pointer to buffer where we do store next packet
+	unsigned char *pData;	//Pointer to buffer where we do store next packet
+	int i;
+	for (i = 0; i < urb->number_of_packets; i++) {
+		int datalength = urb->iso_frame_desc[i].actual_length;
+		int st = urb->iso_frame_desc[i].status;
+		unsigned long ms_times_now;
+		unsigned long ms_times_before;
+		struct spca50x_frame *frame;	//Pointer to frame data
+		int sequenceNumber;
+		int sof;
+		int iPix;	//Offset of pixel data in the ISO packet
+		if (st) {
+			PDEBUG(0, "ISOC data error: [%d] len=%d, status=%d \n",
+			       i, datalength, st);
+			continue;
+		}
+		cdata = ((unsigned char *) urb->transfer_buffer) +
+		    urb->iso_frame_desc[i].offset;
+/* Check for zero length block or no selected frame buffer */
+		if (!datalength || spca50x->curframe == -1) {
+			spca50x->synchro = 0;
+			continue;
+		}
+		PDEBUG(5, "Packet data [%d,%d,%d] Status: %d", datalength, st,
+		       urb->iso_frame_desc[i].offset, st);
+		frame = &spca50x->frame[spca50x->curframe];
+		if (frame->last_packet == -1) {
+/*initialize a new frame */
+			sequenceNumber = 0;
+		} else {
+			sequenceNumber = frame->last_packet;
+		}
+/* check frame start */
+		if ((sof =
+		     spca50x->funct.sof_detect(spca50x, frame, cdata, &iPix,
+					       sequenceNumber,
+					       &datalength)) < 0)
+			continue;
+		sequenceNumber = sof;
+		PDEBUG(3, "spca50x: Packet seqnum = 0x%02x.  curframe=%2d",
+		       sequenceNumber, spca50x->curframe);
+		pData = cdata;
+/* Can we find a frame start */
+		if (sequenceNumber == 0) {
+			PDEBUG(3, "spca50x: Found Frame Start!, framenum = %d",
+			       spca50x->curframe);
+// Start of frame is implicit end of previous frame
+// Check for a previous frame and finish it off if one exists
+			if (frame->scanstate == STATE_LINES) {
+				if (frame->format != VIDEO_PALETTE_RAW_JPEG) {
+/* overflow ? */
+					ms_times_now = spca5xx_gettimes();
+					if (ms_times_now < spca50x->last_times)
+						spca50x->last_times = 0;
+					spin_lock(&spca50x->v4l_lock);
+					ms_times_before =
+					    spca50x->last_times +
+					    spca50x->dtimes;
+					spin_unlock(&spca50x->v4l_lock);
+					if (ms_times_now >= ms_times_before) {
+						PDEBUG(2,
+						       "Decode frame last %d",
+						       (int) (ms_times_now -
+							      spca50x->
+							      last_times));
+						spca50x->last_times =
+						    ms_times_now;
+/* Decode the frame one at a times or drop*/
+						if(!atomic_read(&spca50x->in_use)){
+						atomic_set(&spca50x->in_use,1);
+						spca50x->spca5xx_tasklet.data = (unsigned long) frame;
+						tasklet_schedule(&spca50x->
+								 spca5xx_tasklet);
+						} else
+							frame->grabstate = FRAME_ERROR;
+					} else
+						frame->grabstate = FRAME_ERROR;
+				} else {
+/* RAW DATA stream */
+					frame->grabstate = FRAME_DONE;
+					if (waitqueue_active(&frame->wq))
+						wake_up_interruptible(&frame->
+								      wq);
+				}
+// If someone decided to wait for ANY frame - wake him up 
+				if (waitqueue_active(&spca50x->wq))
+					wake_up_interruptible(&spca50x->wq);
+				frame = spca50x_next_frame(spca50x, cdata);
+			} else
+				frame->scanstate = STATE_LINES;
+		}
+/* Are we in a frame? */
+		if (frame == NULL || frame->scanstate != STATE_LINES)
+			continue;
+		frame->last_packet = sequenceNumber;
+		pData = cdata + iPix;	// Skip packet header (1 or 10 bytes)
+// Consume data
+		PDEBUG(5, "Processing packet seq  %d,length %d,totlength %d",
+		       frame->last_packet, datalength, frame->totlength);
+/* this copy consume input data from the isoc stream */
+		if ((datalength > 0)) {
+			memcpy(frame->highwater, pData, datalength);
+			frame->highwater += datalength;
+			frame->totlength += datalength;
+		}
+	}
+	return 0;
+}
+
+/****************************************************************************
+*
+* Buffer management
+*
+***************************************************************************/
+static int
+spca50x_alloc(struct usb_spca50x *spca50x)
+{
+	int i;
+	PDEBUG(4, "entered");
+	down(&spca50x->buf_lock);
+	if (spca50x->buf_state == BUF_ALLOCATED)
+		goto out;
+	spca50x->tmpBuffer = rvmalloc(MAX_FRAME_SIZE);
+	if (!spca50x->tmpBuffer)
+		goto error;
+	spca50x->fbuf = rvmalloc(SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+	if (!spca50x->fbuf)
+		goto error;
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
+		spca50x->frame[i].tmpbuffer = spca50x->tmpBuffer;
+		spca50x->frame[i].decoder = &spca50x->maindecode;	//connect each frame to the main data decoding 
+spca50x->frame[i].spca50x_dev = spca50x;	//refind the whole structure 
+		spca50x->frame[i].grabstate = FRAME_UNUSED;
+		spca50x->frame[i].scanstate = STATE_SCANNING;
+		spca50x->frame[i].data = spca50x->fbuf + i * MAX_DATA_SIZE;
+		spca50x->frame[i].highwater = spca50x->frame[i].data;
+		memset(&spca50x->frame[i].pictsetting, 0,
+		       sizeof (struct pictparam));
+		PDEBUG(4, "frame[%d] @ %p", i, spca50x->frame[i].data);
+	}
+
+	spca50x->buf_state = BUF_ALLOCATED;
+      out:
+	up(&spca50x->buf_lock);
+	PDEBUG(4, "leaving");
+	return 0;
+      error:
+	if (spca50x->fbuf) {
+		rvfree(spca50x->fbuf, SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+		spca50x->fbuf = NULL;
+	}
+	if (spca50x->tmpBuffer) {
+		rvfree(spca50x->tmpBuffer, MAX_FRAME_SIZE);
+		spca50x->tmpBuffer = NULL;
+	}
+	spca50x->buf_state = BUF_NOT_ALLOCATED;
+	up(&spca50x->buf_lock);
+	PDEBUG(1, "errored");
+	return -ENOMEM;
+}
+static void
+spca5xx_dealloc(struct usb_spca50x *spca50x)
+{
+	int i;
+	PDEBUG(2, "entered dealloc");
+	down(&spca50x->buf_lock);
+	if (spca50x->fbuf) {
+		rvfree(spca50x->fbuf, SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+		spca50x->fbuf = NULL;
+		for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+			spca50x->frame[i].data = NULL;
+	}
+	if (spca50x->tmpBuffer) {
+		rvfree(spca50x->tmpBuffer, MAX_FRAME_SIZE);
+		spca50x->tmpBuffer = NULL;
+	}
+
+	PDEBUG(2, "buffer memory deallocated");
+	spca50x->buf_state = BUF_NOT_ALLOCATED;
+	up(&spca50x->buf_lock);
+	PDEBUG(2, "leaving dealloc");
+}
+
+/**
+* Reset the camera and send the correct initialization sequence for the
+* currently selected source
+*/
+static int
+spca50x_init_source(struct usb_spca50x *spca50x)
+{
+	int err_code;
+	if ((err_code = spca50x->funct.initialize(spca50x)) < 0)
+		return -EINVAL;
+	spca50x->norme = 0;
+	spca50x->channel = 0;
+	spca50x->light_freq = lightfreq;
+	if ((err_code =
+	     spca5xx_setMode(spca50x, spca50x->width, spca50x->height,
+			     VIDEO_PALETTE_RGB24)) < 0)
+		return -EINVAL;
+	spca5xx_set_light_freq(spca50x, lightfreq); 
+
+	return 0;
+}
+
+/****************************************************************************
+*
+* V4L API
+*
+***************************************************************************/
+static inline void
+spca5xx_setFrameDecoder(struct usb_spca50x *spca50x)
+{
+	int i;
+/* configure the frame detector with default parameters */
+	memset(&spca50x->pictsetting, 0, sizeof (struct pictparam));
+	spca50x->pictsetting.change = 0x01;
+	spca50x->pictsetting.force_rgb = force_rgb;
+	spca50x->pictsetting.gamma = gamma;
+	spca50x->pictsetting.OffRed = OffRed;
+	spca50x->pictsetting.OffBlue = OffBlue;
+	spca50x->pictsetting.OffGreen = OffGreen;
+	spca50x->pictsetting.GRed = GRed;
+	spca50x->pictsetting.GBlue = GBlue;
+	spca50x->pictsetting.GGreen = GGreen;
+/* Set default sizes in case IOCTL (VIDIOCMCAPTURE) is not used
+* (using read() instead). */
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
+		spca50x->frame[i].width = spca50x->width;
+		spca50x->frame[i].height = spca50x->height;
+		spca50x->frame[i].cameratype = spca50x->cameratype;
+		spca50x->frame[i].scanlength = spca50x->width * spca50x->height * 3 / 2;	// assumes 4:2:0 data
+		spca50x->frame[i].depth = 24;
+/* Note: format reflects format of data as returned to
+* a process, not as read from camera hardware.
+* This might be a good idea for dumb programs always
+* assuming the following settings.
+*/
+		spca50x->frame[i].format = VIDEO_PALETTE_RGB24;
+	}
+	spca50x->format = VIDEO_PALETTE_RGB24;
+}
+static int
+spca5xx_isjpeg(struct usb_spca50x *spca50x)
+{
+	if (spca50x->cameratype == JPGH
+	    || spca50x->cameratype == JPGC
+	    || spca50x->cameratype == JPGS
+	    || spca50x->cameratype == JPEG
+		|| spca50x->cameratype == JPGM
+		|| spca50x->cameratype == PJPG)
+		return 1;
+	return 0;
+}
+static void
+spca5xx_initDecoder(struct usb_spca50x *spca50x)
+{
+	if (spca5xx_isjpeg(spca50x))
+		init_jpeg_decoder(spca50x);
+	if (spca50x->bridge == BRIDGE_SONIX)
+		init_sonix_decoder(spca50x);
+	if (spca50x->bridge == BRIDGE_PAC207)
+		init_pixart_decoder(spca50x);
+}
+static void
+spca5xx_chgAuto(struct usb_spca50x *spca50x, __u8 autoval)
+{
+	spca50x->autoexpo = (int) autoval;
+	spca50x->funct.set_autobright(spca50x);
+}
+static void
+spca5xx_chgQtable(struct usb_spca50x *spca50x, __u8 qtable)
+{
+	int intqtable = (int) qtable;
+/* one frame maybe corrupted  wait for the result */
+	if (spca5xx_isjpeg(spca50x) && (spca50x->qindex != intqtable)) {
+		if (spca50x->cameratype == JPGH) {
+/* only vimicro ATM */
+			spca50x->qindex = intqtable;
+			spca50x->funct.set_quality(spca50x);
+			init_jpeg_decoder(spca50x);
+		}
+	}
+}
+static inline void
+spca5xx_chgDtimes(struct usb_spca50x *spca50x, __u16 dtimes)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&spca50x->v4l_lock, flags);
+	spca50x->dtimes = (unsigned int) dtimes;
+	spin_unlock_irqrestore(&spca50x->v4l_lock, flags);
+}
+/* Matches the sensor's internal frame rate to the lighting frequency.
+ * Valid frequencies are:
+ *	50 - 50Hz, for European and Asian lighting (default)
+ *	60 - 60Hz, for American lighting
+ *       0 - No Fliker (for outdoore usage)
+ * Returns: 0 for success
+ */
+static int
+spca5xx_set_light_freq(struct usb_spca50x *spca50x, int freq)
+{
+	int freq_set;
+
+	if (freq == 50)
+		freq_set = freq_50HZ;
+	else if (freq == 60)
+		freq_set = freq_60HZ;
+	else if (freq == 0)
+		freq_set = NoFliker;
+	else {
+		PDEBUG(0,"Invalid light freq (%d Hz)", freq);
+		return -EINVAL;
+	}
+
+	switch (spca50x->sensor) {
+	case SENSOR_TAS5130C_VF0250:
+	case SENSOR_TAS5130CXX:
+	case SENSOR_PB0330:
+	case SENSOR_PAS106:
+	case SENSOR_ICM105A:
+	case SENSOR_HDCS2020b:
+	case SENSOR_CS2102:
+	case SENSOR_OV7660:
+	    break;
+	default:
+		PDEBUG(0,"Sensor currently not support light frequency banding filters.");
+		return -EINVAL;
+	}
+	
+	if (freq_set == freq_50HZ) {
+          PDEBUG(1, "Light frequency banding filter set to 50HZ mode");
+	 if (spca50x->mode && spca50x->funct.set_50HZ) {
+            spca50x->funct.set_50HZ(spca50x);
+	 }  else if (spca50x->funct.set_50HZScale) {
+            spca50x->funct.set_50HZScale(spca50x); 
+	 }   
+    	} else if (freq_set == freq_60HZ) {
+          PDEBUG(1, "Light frequency banding filter set to 60HZ mode");
+         if (spca50x->mode && spca50x->funct.set_60HZ) {
+            spca50x->funct.set_60HZ(spca50x);
+	 } else if (spca50x->funct.set_60HZScale) {
+	    spca50x->funct.set_60HZScale(spca50x);
+	 }    
+    	} else if (freq_set == NoFliker) {
+          PDEBUG(1, "Light frequency banding filter set to NoFliker mode");
+         if (spca50x->mode && spca50x->funct.set_NoFliker) {
+            spca50x->funct.set_NoFliker(spca50x);
+	} else if (spca50x->funct.set_NoFlikerScale) {
+            spca50x->funct.set_NoFlikerScale(spca50x);
+	 }    
+    	}
+	spca50x->light_freq = freq;
+	return 0;
+}
+
+static int
+spca5xx_open(struct inode *inode, struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct usb_spca50x *spca50x = video_get_drvdata(vdev);
+	int err;
+	PDEBUG(2, "opening");
+	down(&spca50x->lock);
+/* sanity check disconnect, in use, no memory available */
+	err = -ENODEV;
+	if (!spca50x->present)
+		goto out;
+	err = -EBUSY;
+	if (spca50x->user)
+		goto out;
+	err = -ENOMEM;
+	if (spca50x_alloc(spca50x))
+		goto out;
+/* initialize sensor and decoding */
+	err = spca50x_init_source(spca50x);
+	if (err != 0) {
+		PDEBUG(0, "DEALLOC error on spca50x_init_source\n");
+		up(&spca50x->lock);
+		spca5xx_dealloc(spca50x);
+		goto out2;
+	}
+	spca5xx_initDecoder(spca50x);
+/* open always start in rgb24 a bug in gqcam 
+did not select the palette nor the size  
+v4l spec need that the camera always start on the last setting */
+	spca5xx_setFrameDecoder(spca50x);
+	spca50x->user++;
+	file->private_data = vdev;
+	err = gspca_init_transfert(spca50x);
+	if (err) {
+		PDEBUG(0, " DEALLOC error on init_Isoc\n");
+		spca50x->user--;
+		gspca_kill_transfert(spca50x);
+		up(&spca50x->lock);
+		spca5xx_dealloc(spca50x);
+		file->private_data = NULL;
+		goto out2;
+	}
+/* Now, let's get brightness from the camera */
+	spca50x->brightness = spca50x->funct.get_bright(spca50x);
+	spca50x->whiteness = 0;
+      out:
+	up(&spca50x->lock);
+      out2:
+	if (err) {
+		PDEBUG(2, "Open failed");
+	} else {
+		PDEBUG(2, "Open done");
+	}
+	return err;
+}
+static void inline
+spcaCameraShutDown(struct usb_spca50x *spca50x)
+{
+	if (spca50x->dev) {
+		spca50x->funct.cam_shutdown(spca50x);
+	}
+}
+static int
+spca5xx_close(struct inode *inode, struct file *file)
+{
+	struct video_device *vdev = file->private_data;
+	struct usb_spca50x *spca50x = video_get_drvdata(vdev);
+	int i;
+	PDEBUG(2, "spca50x_close");
+	down(&spca50x->lock);
+	spca50x->user--;
+	spca50x->curframe = -1;
+	if (spca50x->present) {
+		spca50x_stop_isoc(spca50x);
+		spcaCameraShutDown(spca50x);
+		for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
+			if (waitqueue_active(&spca50x->frame[i].wq))
+				wake_up_interruptible(&spca50x->frame[i].wq);
+		}
+		if (waitqueue_active(&spca50x->wq))
+			wake_up_interruptible(&spca50x->wq);
+	}
+/* times to dealloc ressource */
+	up(&spca50x->lock);
+	spca5xx_dealloc(spca50x);
+	PDEBUG(2, "Release ressources done");
+	file->private_data = NULL;
+	return 0;
+}
+static int
+spca5xx_testPalSize(struct usb_spca50x *spca50x, int pal, int w, int h)
+{
+	int needpalette;
+	int needsize;
+	if ((needpalette = v4l_to_spca5xx(pal)) < 0)
+		return -EINVAL;
+	if ((needsize = wxh_to_size(w, h)) < 0)
+		return -EINVAL;
+	if (!(spca50x->mode_cam[needsize].t_palette & needpalette))
+		return -EINVAL;
+	return 0;
+}
+static int
+spca5xx_do_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		 void *arg)
+{
+	struct video_device *vdev = file->private_data;
+	struct usb_spca50x *spca50x = video_get_drvdata(vdev);
+	PDEBUG(2, "do_IOCtl: 0x%X", cmd);
+	if (!spca50x->dev)
+		return -EIO;
+	switch (cmd) {
+	case VIDIOCGCAP:
+		{
+			struct video_capability *b = arg;
+			PDEBUG(2, "VIDIOCGCAP %p :", b);
+			memset(b, 0, sizeof (struct video_capability));
+			snprintf(b->name, 32, "%s",
+				 clist[spca50x->desc].description);
+			b->type = VID_TYPE_CAPTURE;
+			b->channels =
+			    ((spca50x->bridge == BRIDGE_SPCA506) ? 8 : 1);
+			b->audios = 0;
+			b->maxwidth = spca50x->maxwidth;
+			b->maxheight = spca50x->maxheight;
+			b->minwidth = spca50x->minwidth;
+			b->minheight = spca50x->minheight;
+			return 0;
+		}
+	case VIDIOCGCHAN:
+		{
+			struct video_channel *v = arg;
+			switch (spca50x->bridge) {
+			case BRIDGE_SPCA505:
+				{
+					strncpy(v->name,
+						((v->channel ==
+						  0) ? "SPCA505" : "Video In"),
+						32);
+					break;
+				}
+			case BRIDGE_SPCA506:
+				{
+					spca506_GetNormeInput(spca50x,
+							      (__u16 *) & (v->
+									   norm),
+							      (__u16 *) & (v->
+									   channel));
+					if (v->channel < 4) {
+						snprintf(v->name, 32,
+							 "SPCA506-CBVS-%d",
+							 v->channel);
+					} else {
+						snprintf(v->name, 32,
+							 "SPCA506-S-Video-%d",
+							 v->channel);
+					}
+					break;
+				}
+			default:
+				snprintf(v->name, 32, "%s",
+					 Blist[spca50x->bridge].name);
+				break;
+			}
+			v->flags = 0;
+			v->tuners = 0;
+			v->type = VIDEO_TYPE_CAMERA;
+			return 0;
+		}
+	case VIDIOCSCHAN:
+		{
+			struct video_channel *v = arg;
+/* exclude hardware channel reserved */
+			if ((v->channel < 0) || (v->channel > 9)
+			    || (v->channel == 4)
+			    || (v->channel == 5))
+				return -EINVAL;
+			if (spca50x->bridge == BRIDGE_SPCA506) {
+				spca506_SetNormeInput(spca50x, v->norm,
+						      v->channel);
+			}
+			return 0;
+		}
+	case VIDIOCGPICT:
+		{
+			struct video_picture *p = arg;
+			p->depth = spca50x->frame[0].depth;
+			p->palette = spca50x->format;
+			PDEBUG(4, "VIDIOCGPICT: depth=%d, palette=%d", p->depth,
+			       p->palette);
+			p->brightness = spca50x->funct.get_bright(spca50x);
+			p->contrast = spca50x->funct.get_contrast(spca50x);
+			p->colour = spca50x->funct.get_colors(spca50x);
+			p->hue = 0;
+			p->whiteness = 0;
+			return 0;
+		}
+	case VIDIOCSPICT:
+		{
+			int i;
+			struct video_picture *p = arg;
+			PDEBUG(4, "VIDIOCSPICT");
+			if (spca5xx_testPalSize
+			    (spca50x, p->palette, spca50x->width,
+			     spca50x->height) < 0)
+				return -EINVAL;
+			if (spca50x->format != p->palette) {
+				PDEBUG(4, "Setting depth=%d, palette=%d",
+				       p->depth, p->palette);
+/* change the output palette the input stream is the same */
+/* no need to stop the camera streaming and restart */
+				for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
+					spca50x->frame[i].depth = p->depth;
+					spca50x->frame[i].format = p->palette;
+				}
+				spca50x->format = p->palette;
+			}
+			spca50x->contrast = p->contrast;
+			spca50x->brightness = p->brightness;
+			spca50x->colour = p->colour;
+			spca50x->funct.set_bright(spca50x);
+			spca50x->funct.set_contrast(spca50x);
+			spca50x->funct.set_colors(spca50x);
+			spca50x->hue = p->hue;
+			spca50x->whiteness = p->whiteness;
+			return 0;
+		}
+	case VIDIOCGCAPTURE:
+		{
+			int *vf = arg;
+			PDEBUG(4, "VIDIOCGCAPTURE");
+			*vf = 0;
+// no subcapture
+			return -EINVAL;
+		}
+	case VIDIOCSCAPTURE:
+		{
+			struct video_capture *vc = arg;
+			if (vc->flags)
+				return -EINVAL;
+			if (vc->decimation)
+				return -EINVAL;
+			return -EINVAL;
+		}
+	case VIDIOCSWIN:
+		{
+			int result;
+			struct video_window *vw = arg;
+			PDEBUG(3, "VIDIOCSWIN: width=%d, height=%d, flags=%d",
+			       vw->width, vw->height, vw->flags);
+			if (spca5xx_testPalSize
+			    (spca50x, spca50x->format, vw->width,
+			     vw->height) < 0)
+				return -EINVAL;
+			if (vw->x)
+				return -EINVAL;
+			if (vw->y)
+				return -EINVAL;
+			if (vw->width > (unsigned int) spca50x->maxwidth)
+				return -EINVAL;
+			if (vw->height > (unsigned int) spca50x->maxheight)
+				return -EINVAL;
+			if (vw->width < (unsigned int) spca50x->minwidth)
+				return -EINVAL;
+			if (vw->height < (unsigned int) spca50x->minheight)
+				return -EINVAL;
+			result =
+			    spca5xx_restartMode(spca50x, vw->width, vw->height,
+						spca50x->frame[0].format);
+			if (result == 0) {
+				spca50x->frame[0].width = vw->width;
+				spca50x->frame[0].height = vw->height;
+			}
+			return result;
+		}
+	case VIDIOCGWIN:
+		{
+			struct video_window *vw = arg;
+			memset(vw, 0, sizeof (struct video_window));
+			vw->x = 0;
+			vw->y = 0;
+			vw->width = spca50x->frame[0].width;
+			vw->height = spca50x->frame[0].height;
+			vw->flags = 0;
+			PDEBUG(4, "VIDIOCGWIN: %dx%d", vw->width, vw->height);
+			return 0;
+		}
+	case VIDIOCGMBUF:
+		{
+			struct video_mbuf *vm = arg;
+			int i;
+			PDEBUG(2, "VIDIOCGMBUF: %p ", vm);
+			memset(vm, 0, sizeof (struct video_mbuf));
+			vm->size = SPCA50X_NUMFRAMES * MAX_DATA_SIZE;
+			vm->frames = SPCA50X_NUMFRAMES;
+			for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
+				vm->offsets[i] = MAX_DATA_SIZE * i;
+			}
+			return 0;
+		}
+	case VIDIOCMCAPTURE:
+		{
+			int ret, depth;
+			struct video_mmap *vm = arg;
+			PDEBUG(4, "CMCAPTURE");
+			PDEBUG(4, "CM frame: %d, size: %dx%d, format: %d",
+			       vm->frame, vm->width, vm->height, vm->format);
+			depth = spca5xx_get_depth(spca50x, vm->format);
+			if (!depth) {
+				err("VIDIOCMCAPTURE: invalid format (%d)",
+				    vm->format);
+				return -EINVAL;
+			}
+			if ((vm->frame < 0) || (vm->frame > 3)) {
+				err("VIDIOCMCAPTURE: invalid frame (%d)",
+				    vm->frame);
+				return -EINVAL;
+			}
+			if (vm->width > spca50x->maxwidth
+			    || vm->height > spca50x->maxheight) {
+				err("VIDIOCMCAPTURE: requested dimensions too big");
+				return -EINVAL;
+			}
+			if (vm->width < spca50x->minwidth
+			    || vm->height < spca50x->minheight) {
+				err("VIDIOCMCAPTURE: requested dimensions too small");
+				return -EINVAL;
+			}
+			if (spca5xx_testPalSize
+			    (spca50x, vm->format, vm->width, vm->height) < 0)
+				return -EINVAL;
+			if ((spca50x->frame[vm->frame].width != vm->width) ||
+			    (spca50x->frame[vm->frame].height != vm->height) ||
+			    (spca50x->frame[vm->frame].format != vm->format)) {
+				ret =
+				    spca5xx_restartMode(spca50x, vm->width,
+							vm->height, vm->format);
+				if (ret < 0)
+					return ret;
+				spca50x->frame[vm->frame].width = vm->width;
+				spca50x->frame[vm->frame].height = vm->height;
+				spca50x->frame[vm->frame].format = vm->format;
+				spca50x->frame[vm->frame].depth = depth;
+			}
+			if (spca50x->autoexpo) {
+/* set the autoexpo here exept vimicro */
+				if (spca50x->cameratype != JPGH)
+					spca50x->funct.set_autobright(spca50x);
+			}
+#ifdef GSPCA_ENABLE_REGISTERPLAY
+			__u8 Rval = 0;
+			if (RegStrobe != 0) {
+				if (RegStrobe == 1) {
+					if (spca50x->bridge == BRIDGE_PAC207) {
+						pac207_RegWrite(spca50x);
+  					} else if (spca50x->bridge == BRIDGE_PAC7311) {
+  						pac7311_RegWrite(spca50x);
+					} else {
+						Rval = RegValue & 0xFF;
+						spca5xxRegWrite(spca50x->dev,
+								0xa0, Rval,
+								(__u16)
+								(RegAddress &
+								 0xFFFF), NULL,
+								0);
+					}
+				} else {
+					if (spca50x->bridge == BRIDGE_PAC207) {
+						pac207_RegRead(spca50x);
+  					} else if (spca50x->bridge == BRIDGE_PAC7311) {
+  						pac7311_RegRead(spca50x);
+					} else {
+						spca5xxRegRead(spca50x->dev, 0xa1, 0x01, (__u16) (RegAddress & 0xFFFF), &Rval, 1);	// read Lowbyte
+						RegValue = Rval;
+					}
+				}
+				RegStrobe = 0;
+			}
+#endif				/* GSPCA_ENABLE_REGISTERPLAY */
+/* Mark it as ready */
+			spca50x->frame[vm->frame].grabstate = FRAME_READY;
+			return 0;
+		}
+	case VIDIOCSYNC:
+		{
+			int ret;
+			unsigned int frame = *((unsigned int *) arg);
+			PDEBUG(4, "syncing to frame %d, grabstate = %d", frame,
+			       spca50x->frame[frame].grabstate);
+			switch (spca50x->frame[frame].grabstate) {
+			case FRAME_UNUSED:
+				return -EINVAL;
+			case FRAME_ABORTING:
+				return -ENODEV;
+			case FRAME_READY:
+			case FRAME_GRABBING:
+			case FRAME_ERROR:
+			      redo:
+				if (!spca50x->dev)
+					return -EIO;
+				ret =
+				    wait_event_interruptible(spca50x->
+							     frame[frame].wq,
+							     (spca50x->
+							      frame[frame].
+							      grabstate ==
+							      FRAME_DONE));
+				if (ret)
+					return -EINTR;
+				// ?????
+				PDEBUG(4,
+				       "Synch Ready on frame %d, grabstate = %d",
+				       frame, spca50x->frame[frame].grabstate);
+				if (spca50x->frame[frame].grabstate ==
+				    FRAME_ERROR) {
+					goto redo;
+				}
+/* Fallthrough.
+* We have waited in state FRAME_GRABBING until it
+* becomes FRAME_DONE, so now we can move along.
+*/
+			case FRAME_DONE:
+/* Release the current frame. This means that it
+* will be reused as soon as all other frames are
+* full, so the app better be done with it quickly.
+* Can this be avoided somehow?
+*/
+				spca50x->frame[frame].grabstate = FRAME_UNUSED;
+				PDEBUG(4, "Release frame %d state %d\n", frame,
+				       spca50x->frame[frame].grabstate);
+				break;
+			}	/* end switch */
+			return 0;
+		}
+	case VIDIOCGFBUF:
+		{
+			struct video_buffer *vb = arg;
+			memset(vb, 0, sizeof (struct video_buffer));
+			vb->base = NULL;	/* frame buffer not supported, not used */
+			return 0;
+		}
+	case SPCAGVIDIOPARAM:
+		{
+			struct video_param *vp = arg;
+			vp->autobright = (__u8) spca50x->autoexpo;
+			vp->quality = (__u8) spca50x->qindex;
+			vp->time_interval = (__u16) spca50x->dtimes;
+			vp->light_freq = (__u8) spca50x->light_freq;
+			return 0;
+		}
+	case SPCASVIDIOPARAM:
+		{
+			struct video_param *vp = arg;
+			switch (vp->chg_para) {
+			case CHGABRIGHT:
+				spca5xx_chgAuto(spca50x, vp->autobright);
+				break;
+			case CHGQUALITY:
+				spca5xx_chgQtable(spca50x, vp->quality);
+				break;
+			case CHGTINTER:
+				spca5xx_chgDtimes(spca50x, vp->time_interval);
+				break;
+			case CHGLIGHTFREQ:
+				spca5xx_set_light_freq(spca50x, vp->light_freq);
+				break;
+			default:
+				return -EINVAL;
+				break;
+			}
+			return 0;
+		}
+/************************************/
+	case VIDIOCKEY:
+		return 0;
+	case VIDIOCCAPTURE:
+		return -EINVAL;
+	case VIDIOCSFBUF:
+		return -EINVAL;
+	case VIDIOCGTUNER:
+	case VIDIOCSTUNER:
+		return -EINVAL;
+	case VIDIOCGFREQ:
+	case VIDIOCSFREQ:
+		return -EINVAL;
+	case VIDIOCGAUDIO:
+	case VIDIOCSAUDIO:
+		return -EINVAL;
+	default:
+		return -ENOIOCTLCMD;
+	}			/* end switch */
+	return 0;
+}
+static int
+spca5xx_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	      unsigned long arg)
+{
+	int rc;
+	rc = video_usercopy(inode, file, cmd, arg, spca5xx_do_ioctl);
+	return rc;
+}
+
+#define ISDONE4(fr1,fr2,fr3,fr4) (((fr1|fr2|fr3|fr4) & FRAME_DONE ) ? 1:0)
+#define ISDONE2(fr1,fr2) (((fr1|fr2) & FRAME_DONE) ? 1:0)
+static ssize_t
+spca5xx_read(struct file *file, char *buf, size_t cnt, loff_t * ppos)
+{
+	struct video_device *dev = file->private_data;
+	int noblock = file->f_flags & O_NONBLOCK;
+	unsigned long count = cnt;
+	struct usb_spca50x *spca50x = video_get_drvdata(dev);
+	int i;
+	int frmx = -1;
+	int rc;
+	volatile struct spca50x_frame *frame;
+	PDEBUG(4, "%ld bytes, noblock=%d", count, noblock);
+	if (down_interruptible(&spca50x->lock))
+		return -ERESTARTSYS;
+	if (!dev || !buf) {
+		up(&spca50x->lock);
+		return -EFAULT;
+	}
+	if (!spca50x->dev) {
+		up(&spca50x->lock);
+		return -EIO;
+	}
+	if (!spca50x->streaming) {
+		up(&spca50x->lock);
+		return -EIO;
+	}
+/* Wait while we're grabbing the image */
+	PDEBUG(4, "Waiting for a frame done");
+#if (SPCA50X_NUMFRAMES == 4)
+	if (noblock
+	    && !ISDONE4(spca50x->frame[0].grabstate,
+			spca50x->frame[1].grabstate,
+			spca50x->frame[2].grabstate,
+			spca50x->frame[3].grabstate)) {
+		up(&spca50x->lock);
+		return -EAGAIN;
+	}
+	if ((rc =
+	     wait_event_interruptible(spca50x->wq,
+				      ISDONE4(spca50x->frame[0].grabstate,
+					      spca50x->frame[1].grabstate,
+					      spca50x->frame[2].grabstate,
+					      spca50x->frame[3].grabstate)))) {
+		up(&spca50x->lock);
+		return rc;
+	}
+#else				// should be two
+	if (noblock
+	    && !ISDONE2(spca50x->frame[0].grabstate,
+			spca50x->frame[1].grabstate)) {
+		up(&spca50x->lock);
+		return -EAGAIN;
+	}
+	if ((rc =
+	     wait_event_interruptible(spca50x->wq,
+				      ISDONE2(spca50x->frame[0].grabstate,
+					      spca50x->frame[1].grabstate)))) {
+		up(&spca50x->lock);
+		return rc;
+	}
+#endif
+/* One frame has just been set to DONE. Find it. */
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+		if (spca50x->frame[i].grabstate == FRAME_DONE)
+			frmx = i;
+	PDEBUG(4, "Frame number: %d", frmx);
+	if (frmx < 0) {
+/* We havent found a frame that is DONE. Damn. Should
+* not happen. */
+		PDEBUG(2, "Couldnt find a frame ready to be read.");
+		up(&spca50x->lock);
+		return -EFAULT;
+	}
+	frame = &spca50x->frame[frmx];
+	if (count > frame->scanlength)
+		count = frame->scanlength;
+	if ((i = copy_to_user(buf, frame->data, count))) {
+		PDEBUG(2, "Copy failed! %d bytes not copied", i);
+		up(&spca50x->lock);
+		return -EFAULT;
+	}
+/* Release the frame */
+	frame->grabstate = FRAME_READY;
+/* set the autoexpo here */
+	if (spca50x->autoexpo) {
+/* set the autoexpo here exept vimicro*/
+		if (spca50x->cameratype != JPGH)
+			spca50x->funct.set_autobright(spca50x);
+	}
+	up(&spca50x->lock);
+	return count;
+}
+static int
+spca5xx_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *dev = file->private_data;
+	unsigned long start = vma->vm_start;
+	unsigned long size = vma->vm_end - vma->vm_start;
+	struct usb_spca50x *spca50x = video_get_drvdata(dev);
+	unsigned long page, pos;
+	if (spca50x->dev == NULL)
+		return -EIO;
+	PDEBUG(4, "mmap: %ld (%lX) bytes", size, size);
+	if (size >
+	    (((SPCA50X_NUMFRAMES * MAX_DATA_SIZE) + PAGE_SIZE -
+	      1) & ~(PAGE_SIZE - 1)))
+		return -EINVAL;
+	if (down_interruptible(&spca50x->lock))
+		return -EINTR;
+	pos = (unsigned long) spca50x->fbuf;
+	while (size > 0) {
+		page = kvirt_to_pa(pos);
+		if (remap_pfn_range
+		    (vma, start, page >> PAGE_SHIFT, PAGE_SIZE, PAGE_SHARED)) {
+			up(&spca50x->lock);
+			return -EAGAIN;
+		}
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+	up(&spca50x->lock);
+	return 0;
+}
+static struct file_operations spca5xx_fops = {
+	.owner = THIS_MODULE,
+	.open = spca5xx_open,
+	.release = spca5xx_close,
+	.read = spca5xx_read,
+	.mmap = spca5xx_mmap,
+	.ioctl = spca5xx_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = v4l_compat_ioctl32,
+#endif
+	.llseek = no_llseek,
+};
+static struct video_device spca50x_template = {
+	.owner = THIS_MODULE,
+	.name = "GSPCA USB Camera",
+	.type = VID_TYPE_CAPTURE,
+	.hardware = VID_HARDWARE_GSPCA,
+	.fops = &spca5xx_fops,
+	.release = video_device_release,
+	.minor = -1,
+};
+
+/****************************************************************************
+*
+* SPCA50X configuration
+*
+***************************************************************************/
+static int
+spca50x_configure_sensor(struct usb_spca50x *spca50x)
+{
+	return spca5xx_getcapability(spca50x);;
+}
+static int
+spca50x_configure(struct usb_spca50x *spca50x)
+{
+	PDEBUG(2, "video_register_device succeeded");
+/* Initialise the camera bridge */
+	if (spca50x->funct.configure(spca50x) < 0)
+		goto error;
+	gspca_set_alt0(spca50x);
+/* Set an initial pipe size; this will be overridden by
+* spca50x_set_mode(), called indirectly by the open routine.
+*/
+	if (spca5xx_getDefaultMode(spca50x) < 0)
+		return -EINVAL;
+	spca50x->force_rgb = force_rgb;
+	if (spca50x_configure_sensor(spca50x) < 0) {
+		err("failed to configure");
+		goto error;
+	}
+/* configure the frame detector with default parameters */
+	spca5xx_setFrameDecoder(spca50x);
+	PDEBUG(2, "Spca5xx Configure done !!");
+	return 0;
+      error:
+	return -EBUSY;
+}
+
+/************************************************************************************/
+/****************************************************************************
+*  sysfs
+***************************************************************************/
+static inline struct usb_spca50x *
+cd_to_spca50x(struct class_device *cd)
+{
+	struct video_device *vdev = to_video_device(cd);
+	return video_get_drvdata(vdev);
+}
+
+static ssize_t
+show_stream_id(struct class_device *cd, char *buf)
+{
+	struct usb_spca50x *spca50x = cd_to_spca50x(cd);
+	return snprintf(buf, 5, "%s\n", Plist[spca50x->cameratype].name);
+}
+
+static CLASS_DEVICE_ATTR(stream_id, S_IRUGO, show_stream_id, NULL);
+static ssize_t
+show_model(struct class_device *cd, char *buf)
+{
+	struct usb_spca50x *spca50x = cd_to_spca50x(cd);
+	return snprintf(buf, 32, "%s\n", (spca50x->desc) ?
+			clist[spca50x->desc].description : " Unknow ");
+}
+
+static CLASS_DEVICE_ATTR(model, S_IRUGO, show_model, NULL);
+static ssize_t
+show_pictsetting(struct class_device *cd, char *buf)
+{
+	struct usb_spca50x *spca50x = cd_to_spca50x(cd);
+	struct pictparam *gcorrect = &spca50x->pictsetting;
+	return snprintf(buf, 128,
+			"force_rgb=%d, gamma=%d, OffRed=%d, OffBlue=%d, OffGreen=%d, GRed=%d, GBlue=%d, GGreen= %d \n",
+			gcorrect->force_rgb, gcorrect->gamma, gcorrect->OffRed,
+			gcorrect->OffBlue, gcorrect->OffGreen, gcorrect->GRed,
+			gcorrect->GBlue, gcorrect->GGreen);
+}
+
+static CLASS_DEVICE_ATTR(pictsetting, S_IRUGO, show_pictsetting, NULL);
+static int
+spca50x_create_sysfs(struct video_device *vdev)
+{
+	int rc = 0 ;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)	
+	rc = video_device_create_file(vdev, &class_device_attr_stream_id);
+	if (rc) goto err_stream_id;
+	rc = video_device_create_file(vdev, &class_device_attr_model);
+	if (rc) goto err_model;
+	rc = video_device_create_file(vdev, &class_device_attr_pictsetting);
+	if (rc) goto err_pictsetting;
+
+	return 0;
+
+err_pictsetting:
+	video_device_remove_file(vdev, &class_device_attr_pictsetting);
+err_model:
+	video_device_remove_file(vdev, &class_device_attr_model);
+err_stream_id:
+	video_device_remove_file(vdev, &class_device_attr_stream_id);
+#else
+	video_device_create_file(vdev, &class_device_attr_stream_id);
+	video_device_create_file(vdev, &class_device_attr_model);
+	video_device_create_file(vdev, &class_device_attr_pictsetting);
+#endif
+	return rc;
+}
+
+/****************************************************************************
+*
+*  USB routines
+*
+***************************************************************************/
+static int
+gspca_attach_bridge(struct usb_spca50x *spca50x)
+{
+/* set the default epadr */
+	spca50x->epadr =1;
+	switch (spca50x->bridge) {
+	case BRIDGE_SPCA500:
+		spca50x->cameratype = JPEG;
+		info("USB GSPCA camera found.(SPCA500+unknown CCD)");
+		memcpy(&spca50x->funct, &fspca500,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_SPCA501:
+		spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+		spca50x->i2c_base = 0;
+		spca50x->i2c_trigger_on_write = 0;
+		spca50x->cameratype = YUYV;
+		info("USB GSPCA camera found. (SPCA501 )");
+		memcpy(&spca50x->funct, &fspca501,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_SPCA505:
+		spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+		spca50x->i2c_base = 0;
+		spca50x->i2c_trigger_on_write = 0;
+		spca50x->cameratype = YYUV;
+		info("USB GSPCA camera found.(SPCA505)");
+		memcpy(&spca50x->funct, &fspca505,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_SPCA506:
+		spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+		spca50x->i2c_base = 0;
+		spca50x->i2c_trigger_on_write = 0;
+		spca50x->cameratype = YYUV;
+		info("USB GSPCA grabber found. (SPCA506+SAA7113)");
+		memcpy(&spca50x->funct, &fspca506,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_SPCA508:
+		spca50x->i2c_ctrl_reg = 0;
+		spca50x->i2c_base = SPCA508_INDEX_I2C_BASE;
+		spca50x->i2c_trigger_on_write = 1;
+		spca50x->cameratype = YUVY;
+		info("USB GSPCA camera found.(SPCA508?)");
+		memcpy(&spca50x->funct, &fspca508,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_SPCA561:
+		spca50x->cameratype = S561;
+		info("USB GSPCA camera found.(SPCA561A)");
+		memcpy(&spca50x->funct, &fspca561,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA536:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504C:
+		spca50x->cameratype = JPEG;
+		info("USB GSPCA camera found.Sunplus FW 2");
+		memcpy(&spca50x->funct, &fsp5xxfw2,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_ZC3XX:
+		spca50x->cameratype = JPGH;
+		info("USB GSPCA camera found.(ZC3XX) ");
+		memcpy(&spca50x->funct, &fzc3xx, sizeof (struct cam_operation));
+		break;
+	case BRIDGE_VC032X:
+	spca50x->epadr = 2;
+		spca50x->cameratype = YUY2;
+		info("USB GSPCA camera found.(VC0321) ");
+		memcpy(&spca50x->funct, &fvc0321, sizeof (struct cam_operation));
+		break;
+	case BRIDGE_SONIX:
+		spca50x->cameratype = SN9C;
+		info("USB GSPCA camera found. SONIX sn9c10[1 2]");
+		memcpy(&spca50x->funct, &fsonix, sizeof (struct cam_operation));
+		break;
+	case BRIDGE_SN9CXXX:
+		spca50x->cameratype = JPGS;	// jpeg 4.2.2 whithout header ;
+		info("USB GSPCA camera found. SONIX JPEG (sn9c1xx) ");
+		memcpy(&spca50x->funct, &fsn9cxx,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_PAC207:
+	spca50x->epadr = 5;
+		spca50x->cameratype = PGBRG;
+		info("USB GSPCA camera found. (PAC207)");
+		memcpy(&spca50x->funct, &fpac207,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_PAC7311:
+	    spca50x->epadr = 5;
+		spca50x->cameratype = PJPG;
+		info("USB SPCA5XX camera found. (PAC7311)");
+		memcpy(&spca50x->funct, &fpac7311,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_TV8532:
+		spca50x->cameratype = GBGR;
+		info("USB GSPCA camera found. (TV8532)");
+		memcpy(&spca50x->funct, &ftv8532,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_ETOMS:
+		spca50x->cameratype = GBRG;
+		info("USB GSPCA camera found (ET61X51) ");
+		memcpy(&spca50x->funct, &fet61x, sizeof (struct cam_operation));
+		break;
+	case BRIDGE_CX11646:
+		spca50x->cameratype = JPGC;
+		info("USB GSPCA camera found. Conexant(CX11646) ");
+		memcpy(&spca50x->funct, &fcx11646,
+		       sizeof (struct cam_operation));
+		break;
+	case BRIDGE_MR97311:
+		spca50x->cameratype = JPGM;
+		info("USB GSPCA camera found. PIXART MR97311 ");
+		memcpy(&spca50x->funct, &fmr97311,
+		       sizeof (struct cam_operation));
+		break;
+	default:
+		return -ENODEV;
+	}
+	return 0;
+} 
+
+static int
+spcaDetectCamera(struct usb_spca50x *spca50x)
+{
+	struct usb_device *dev = spca50x->dev;
+	__u8 fw = 0;
+	__u16 vendor;
+	__u16 product;
+/* Is it a recognised camera ? */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+	vendor = le16_to_cpu(dev->descriptor.idVendor);
+	product = le16_to_cpu(dev->descriptor.idProduct);
+#else
+	vendor = dev->descriptor.idVendor;
+	product = dev->descriptor.idProduct;
+#endif
+	switch (vendor) {
+	case 0x0733:		/* Rebadged ViewQuest (Intel) and ViewQuest cameras */
+		switch (product) {
+		case 0x430:
+			if (usbgrabber) {
+				spca50x->desc = UsbGrabberPV321c;
+				spca50x->bridge = BRIDGE_SPCA506;
+				spca50x->sensor = SENSOR_SAA7113;
+			} else {
+				spca50x->desc = IntelPCCameraPro;
+				spca50x->bridge = BRIDGE_SPCA505;
+				spca50x->sensor = SENSOR_INTERNAL;;
+			}
+			break;
+		case 0x1314:
+			spca50x->desc = Mercury21;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2211:
+			spca50x->desc = Jenoptikjdc21lcd;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2221:
+			spca50x->desc = MercuryDigital;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x1311:
+			spca50x->desc = Epsilon13;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x401:
+			spca50x->desc = IntelCreateAndShare;
+			spca50x->bridge = BRIDGE_SPCA501;	
+			spca50x->sensor = SENSOR_INTERNAL;;
+			break;
+		case 0x402:
+			spca50x->desc = ViewQuestM318B;
+			spca50x->bridge = BRIDGE_SPCA501;	
+			spca50x->sensor = SENSOR_INTERNAL;;
+			break;
+		case 0x110:
+			spca50x->desc = ViewQuestVQ110;
+			spca50x->bridge = BRIDGE_SPCA508;
+			spca50x->sensor = SENSOR_INTERNAL;;
+			break;
+		case 0x3261:
+			spca50x->desc = Concord3045;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x3281:
+			spca50x->desc = CyberpixS550V;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0734:
+		switch (product) {
+		case 0x043b:
+			spca50x->desc = DeMonUSBCapture;
+			spca50x->bridge = BRIDGE_SPCA506;
+			spca50x->sensor = SENSOR_SAA7113;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x99FA:		/* GrandTec cameras */
+		switch (product) {
+		case 0x8988:
+			spca50x->desc = GrandtecVcap;
+			spca50x->bridge = BRIDGE_SPCA506;
+			spca50x->sensor = SENSOR_SAA7113;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0AF9:		/* Hama cameras */
+		switch (product) {
+		case 0x0010:
+			spca50x->desc = HamaUSBSightcam;
+			spca50x->bridge = BRIDGE_SPCA508;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0011:
+			spca50x->desc = HamaUSBSightcam2;
+			spca50x->bridge = BRIDGE_SPCA508;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x040A:		/* Kodak cameras */
+		switch (product) {
+		case 0x0002:
+			spca50x->desc = KodakDVC325;
+			spca50x->bridge = BRIDGE_SPCA501;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0300:
+			spca50x->desc = KodakEZ200;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x04a5:		/* Benq */
+	case 0x08ca:		/* Aiptek */
+	case 0x055f:		/* Mustek cameras */
+	case 0x04fc:		/* SunPlus */
+	case 0x052b:		/* ?? Megapix */
+	case 0x04f1:		/* JVC */
+		switch (product) {
+		case 0xc520:
+			spca50x->desc = MustekGsmartMini3;
+			spca50x->bridge = BRIDGE_SPCA504;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc420:
+			spca50x->desc = MustekGsmartMini2;
+			spca50x->bridge = BRIDGE_SPCA504;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc360:
+			spca50x->desc = MustekDV4000;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc211:
+			spca50x->desc = Bs888e;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc005:	// zc302 chips 
+			spca50x->desc = Wcam300A;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0xd003:	// zc302 chips 
+			spca50x->desc = MustekWcam300A;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0xd004:	// zc302 chips 
+			spca50x->desc = WCam300AN;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x504a:
+/*try to get the firmware as some cam answer 2.0.1.2.2 
+and should be a spca504b then overwrite that setting */
+			spca5xxRegRead(dev, 0x20, 0, 0, &fw, 1);
+			if (fw == 1) {
+				spca50x->desc = AiptekMiniPenCam13;
+				spca50x->bridge = BRIDGE_SPCA504;
+				spca50x->sensor = SENSOR_INTERNAL;
+			} else if (fw == 2) {
+				spca50x->desc = Terratec2move13;
+				spca50x->bridge = BRIDGE_SPCA504B;
+				spca50x->sensor = SENSOR_INTERNAL;
+			} else
+				return -ENODEV;
+			break;
+		case 0x2018:
+			spca50x->desc = AiptekPenCamSD;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x1001:
+			spca50x->desc = JvcGcA50;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2008:
+			spca50x->desc = AiptekMiniPenCam2;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x504b:
+			spca50x->desc = MaxellMaxPocket;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x500c:
+			spca50x->desc = Sunplus500c;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xffff:
+			spca50x->desc = PureDigitalDakota;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0103:
+			spca50x->desc = AiptekPocketDV;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0104:
+			spca50x->desc = AiptekPocketDVII;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0106:
+			spca50x->desc = AiptekPocketDV3100;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc232:
+			spca50x->desc = MustekMDC3500;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc630:
+			spca50x->desc = MustekMDC4000;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x5330:
+			spca50x->desc = Digitrex2110;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2020:
+			spca50x->desc = AiptekSlim3000F;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2022:
+			spca50x->desc = AiptekSlim3200;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2028:
+			spca50x->desc = AiptekPocketCam4M;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x5360:
+			spca50x->desc = SunplusGeneric536;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2024:
+			spca50x->desc = AiptekDV3500;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2042:
+			spca50x->desc = AiptekPocketDV5100;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2040:
+			spca50x->desc = AiptekDV4100M;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2060:
+			spca50x->desc = AiptekPocketDV5300;
+			spca50x->bridge = BRIDGE_SPCA536;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x3008:
+			spca50x->desc = BenqDC1500;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x3003:
+			spca50x->desc = BenqDC1300;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x300a:
+			spca50x->desc = BenqDC3410;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x300c:
+			spca50x->desc = BenqDC1016;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2010:
+			spca50x->desc = AiptekPocketCam3M;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x2016:
+			spca50x->desc = AiptekPocketCam2M;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0561:
+			spca50x->desc = Flexcam100Camera;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc200:
+			spca50x->desc = MustekGsmart300;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x7333:
+			spca50x->desc = PalmPixDC85;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc220:
+			spca50x->desc = Gsmartmini;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc230:
+			spca50x->desc = Mustek330K;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc530:
+			spca50x->desc = MustekGsmartLCD3;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc430:
+			spca50x->desc = MustekGsmartLCD2;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc440:
+			spca50x->desc = MustekDV3000;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc540:
+			spca50x->desc = GsmartD30;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0xc650:
+			spca50x->desc = MustekMDC5500Z;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x1513:
+			spca50x->desc = MegapixV4;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x045e:
+		switch(product){
+		case 0x00f7:
+			spca50x->desc = MSVX1000;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_OV7660;
+			spca50x->customid = SN9C105;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x21;
+		break;
+		case 0x00f5:
+			spca50x->desc = MSVX3000;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_OV7660;
+			spca50x->customid = SN9C105;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x21;
+		break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x046d:		/* Logitech Labtec */
+	case 0x041E:		/* Creative cameras */
+		switch (product) {
+		case 0x400A:
+			spca50x->desc = CreativePCCam300;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x4012:
+			spca50x->desc = PcCam350;
+			spca50x->bridge = BRIDGE_SPCA504C;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0890:
+			spca50x->desc = LogitechTraveler;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x08a0:
+			spca50x->desc = QCim;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x08a1:
+			spca50x->desc = QCimA1;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x08a2:	// zc302 chips 
+			spca50x->desc = LabtecPro;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_HDCS2020;
+			break;
+		case 0x08a3:
+			spca50x->desc = QCchat;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x08a6:
+			spca50x->desc = LogitechQCim;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_HV7131C;
+			break;
+		case 0x08a7:
+			spca50x->desc = LogitechQCImage;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PAS202;
+			break;
+		case 0x08d8:
+		case 0x08a9:
+			spca50x->desc = LogitechNotebookDeluxe;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_HDCS2020;
+			break;
+		case 0x08ae:
+			spca50x->desc = QuickCamNB;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_HDCS2020;
+			break;
+		case 0x08ac:
+			spca50x->desc = LogitechQCCool;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_HV7131B;
+			break;
+		case 0x08ad:
+		case 0x08d7:
+			spca50x->desc = LogitechQCCommunicateSTX;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_HV7131C;
+			break;
+		case 0x08aa:
+			spca50x->desc = LabtecNotebook;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_HDCS2020;
+			break;
+		case 0x08b9:
+			spca50x->desc = QCimB9;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x08d9:
+			spca50x->desc = QCimconnect;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x08da:
+			spca50x->desc = QCmessenger;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x0900:
+			spca50x->desc = LogitechClickSmart310;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_HDCS1020;
+			break;
+		case 0x0901:
+			spca50x->desc = LogitechClickSmart510;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0905:
+			spca50x->desc = LogitechClickSmart820;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x400B:
+			spca50x->desc = CreativePCCam600;
+			spca50x->bridge = BRIDGE_SPCA504C;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x4013:
+			spca50x->desc = CreativePccam750;
+			spca50x->bridge = BRIDGE_SPCA504C;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0960:
+			spca50x->desc = LogitechClickSmart420;
+			spca50x->bridge = BRIDGE_SPCA504C;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x4018:
+			spca50x->desc = CreativeVista;
+			spca50x->bridge = BRIDGE_SPCA508;
+			spca50x->sensor = SENSOR_PB100_BA;
+			break;
+		case 0x4028:
+			spca50x->desc = CreativeVistaPlus;
+			spca50x->bridge = BRIDGE_PAC207;
+			spca50x->sensor = SENSOR_PAC207;
+			break;
+		case 0x401d:	//here505b
+			spca50x->desc = Nxultra;
+			spca50x->bridge = BRIDGE_SPCA505;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x401c:	// zc301 chips 
+			spca50x->desc = CreativeNX;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PAS106;
+			break;
+		case 0x401e:	// zc301 chips 
+			spca50x->desc = CreativeNxPro;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_HV7131B;
+			break;
+		case 0x4029:
+			spca50x->desc = CreativeWebCamVistaPro;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PB0330;
+			break;
+		case 0x4034:	// zc301 chips 
+			spca50x->desc = CreativeInstant1;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PAS106;
+			break;
+		case 0x4035:	// zc301 chips 
+			spca50x->desc = CreativeInstant2;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PAS106;
+			break;
+		case 0x403a:
+			spca50x->desc = CreativeNxPro2;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x401a:
+		case 0x403b:
+			spca50x->desc = CreativeVista3b;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x041e:
+		case 0x4036:
+			spca50x->desc = CreativeLive;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x401f:	// zc301 chips 
+			spca50x->desc = CreativeNotebook;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x4017:	// zc301 chips 
+			spca50x->desc = CreativeMobile;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_ICM105A;
+			break;
+		case 0x4051:	// zc301 chips 
+			spca50x->desc = CreativeLiveCamVideoIM;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130C_VF0250; // VF0250
+			break;
+		case 0x4053:	// zc301 chips 
+			spca50x->desc = CreativeLiveCamNotebookPro;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130C_VF0250; // VF0250
+			break;
+		case 0x0920:
+			spca50x->desc = QCExpress;
+			spca50x->bridge = BRIDGE_TV8532;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0921:
+			spca50x->desc = LabtecWebcam;
+			spca50x->bridge = BRIDGE_TV8532;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0928:
+			spca50x->desc = QCExpressEtch2;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0929:
+			spca50x->desc = Labtec929;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x092a:
+			spca50x->desc = QCforNotebook;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x092b:
+			spca50x->desc = LabtecWCPlus;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x092c:
+		case 0x092d:
+		case 0x092e:
+		case 0x092f:
+			spca50x->desc = LogitechQC92x;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0892:
+		case 0x0896:
+			spca50x->desc = Orbicam;
+			spca50x->bridge = BRIDGE_VC032X;
+			spca50x->sensor = SENSOR_OV7660;	
+			
+		break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0AC8:		/* Vimicro z-star */
+		switch (product) {
+		case 0x301b:	/* Wasam 350r */
+			spca50x->desc = Vimicro;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PB0330;	
+			break;
+		case 0x303b:	/* Wasam 350r */
+			spca50x->desc = Vimicro303b;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PB0330;	
+			break;
+		case 0x305b:	/* Generic */
+			spca50x->desc = Zc0305b;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130C_VF0250;	//overwrite by the sensor detect routine
+			break;
+		case 0x0302:	/* Generic */
+			spca50x->desc = Zc302;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_ICM105A;	
+			break;
+		case 0x0321:
+			spca50x->desc = Vimicro0321;
+			spca50x->bridge = BRIDGE_VC032X;
+			spca50x->sensor = SENSOR_OV7660;	
+			break;
+		case 0xc001:
+			spca50x->desc = Sonyc001;
+			spca50x->bridge = BRIDGE_VC032X;
+			spca50x->sensor = SENSOR_OV7660;
+			break;
+		case 0xc002:
+			spca50x->desc = Sonyc002;
+			spca50x->bridge = BRIDGE_VC032X;
+			spca50x->sensor = SENSOR_OV7660;	
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x084D:		/* D-Link / Minton */
+		switch (product) {
+		case 0x0003:	/* DSC-350 / S-Cam F5 */
+			spca50x->desc = DLinkDSC350;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0923:		/* ICM532 cams */
+		switch (product) {
+		case 0x010f:
+			spca50x->desc = ICM532cam;
+			spca50x->bridge = BRIDGE_TV8532;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0545:		/* tv8532 cams */
+		switch (product) {
+		case 0x808b:
+			spca50x->desc = VeoStingray2;
+			spca50x->bridge = BRIDGE_TV8532;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x8333:
+			spca50x->desc = VeoStingray1;
+			spca50x->bridge = BRIDGE_TV8532;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x102c:		/* Etoms */
+		switch (product) {
+		case 0x6151:
+			spca50x->desc = Etoms61x151;
+			spca50x->bridge = BRIDGE_ETOMS;
+			spca50x->sensor = SENSOR_PAS106;
+			break;
+		case 0x6251:
+			spca50x->desc = Etoms61x251;
+			spca50x->bridge = BRIDGE_ETOMS;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x1776:		/* Arowana */
+		switch (product) {
+		case 0x501c:	/* Arowana 300k CMOS Camera */
+			spca50x->desc = Arowana300KCMOSCamera;
+			spca50x->bridge = BRIDGE_SPCA501;
+			spca50x->sensor = SENSOR_HV7131B;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0000:		/* Unknow Camera */
+		switch (product) {
+		case 0x0000:	/* UnKnow from Ori CMOS Camera */
+			spca50x->desc = MystFromOriUnknownCamera;
+			spca50x->bridge = BRIDGE_SPCA501;
+			spca50x->sensor = SENSOR_HV7131B;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x8086:		/* Intel */
+		switch (product) {
+		case 0x0110:
+			spca50x->desc = IntelEasyPCCamera;
+			spca50x->bridge = BRIDGE_SPCA508;
+			spca50x->sensor = SENSOR_PB100_BA;
+			break;
+		case 0x0630:	/* Pocket PC Camera */
+			spca50x->desc = IntelPocketPCCamera;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0506:		/* 3COM cameras */
+		switch (product) {
+		case 0x00DF:
+			spca50x->desc = ThreeComHomeConnectLite;
+			spca50x->bridge = BRIDGE_SPCA501;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0458:		/* Genius KYE cameras */
+		switch (product) {
+		case 0x7004:
+			spca50x->desc = GeniusVideoCAMExpressV2;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x7006:
+			spca50x->desc = GeniusDsc13;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x7007:	// zc301 chips 
+			spca50x->desc = GeniusVideoCamV2;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x700c:	// zc301 chips 
+			spca50x->desc = GeniusVideoCamV3;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x700f:	// zc301 chips 
+			spca50x->desc = GeniusVideoCamExpressV2b;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		case 0x7025:
+			spca50x->desc = GeniusEye311Q;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_MI0360;
+			spca50x->customid = SN9C120;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x5d;
+		break;
+		default:
+			goto error;
+		};
+		break;
+	case 0xabcd:		/* PetCam  */
+		switch (product) {
+		case 0xcdee:
+			spca50x->desc = PetCam;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x060b:		/* Maxell  */
+		switch (product) {
+		case 0xa001:
+			spca50x->desc = MaxellCompactPM3;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x10fd:		/* FlyCam usb 100  */
+		switch (product) {
+		case 0x7e50:
+			spca50x->desc = Flycam100Camera;
+			spca50x->bridge = BRIDGE_SPCA561;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0128:
+		case 0x8050:	// zc301 chips
+			spca50x->desc = TyphoonWebshotIIUSB300k;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0461:		/* MicroInnovation  */
+		switch (product) {
+		case 0x0815:
+			spca50x->desc = MicroInnovationIC200;
+			spca50x->bridge = BRIDGE_SPCA508;
+			spca50x->sensor = SENSOR_PB100_BA;
+			break;
+		case 0x0a00:	// zc301 chips 
+			spca50x->desc = WebCam320;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x06e1:		/* ADS Technologies  */
+		switch (product) {
+		case 0xa190:
+			spca50x->desc = ADSInstantVCD;
+			spca50x->bridge = BRIDGE_SPCA506;
+			spca50x->sensor = SENSOR_SAA7113;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x05da:		/* Digital Dream cameras */
+		switch (product) {
+		case 0x1018:
+			spca50x->desc = Enigma13;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0c45:		/* Sonix6025 TAS 5130d1b */
+		switch (product) {
+		case 0x6001:
+			spca50x->desc = GeniusVideoCamNB;
+			spca50x->bridge = BRIDGE_SONIX;
+			spca50x->sensor = SENSOR_TAS5110;
+			spca50x->customid = SN9C102;
+			spca50x->i2c_ctrl_reg = 0x20;
+			spca50x->i2c_base = 0x11;
+			break;
+		case 0x6007:
+		case 0x6005:
+			spca50x->desc = SweexTas5110;
+			spca50x->bridge = BRIDGE_SONIX;
+			spca50x->sensor = SENSOR_TAS5110;
+			spca50x->customid = SN9C101;
+			spca50x->i2c_ctrl_reg = 0x20;
+			spca50x->i2c_base = 0x11;
+			break;
+		case 0x6024:
+		case 0x6025:
+			spca50x->desc = Sonix6025;
+			spca50x->bridge = BRIDGE_SONIX;
+			spca50x->sensor = SENSOR_TAS5130CXX;
+			spca50x->customid = SN9C102;
+			spca50x->i2c_ctrl_reg = 0x20;
+			spca50x->i2c_base = 0x11;
+			break;
+		case 0x6028:
+			spca50x->desc = BtcPc380;
+			spca50x->bridge = BRIDGE_SONIX;
+			spca50x->sensor = SENSOR_PAS202;
+			spca50x->customid = SN9C102;
+			spca50x->i2c_ctrl_reg = 0x80;
+			spca50x->i2c_base = 0x40;
+			break;
+		case 0x6019:
+			spca50x->desc = Sonix6019;
+			spca50x->bridge = BRIDGE_SONIX;
+			spca50x->sensor = SENSOR_OV7630;
+			spca50x->customid = SN9C101;
+			spca50x->i2c_ctrl_reg = 0x80;
+			spca50x->i2c_base = 0x21;
+			break;
+		case 0x602c:
+		case 0x602e:
+			spca50x->desc = GeniusVideoCamMessenger;
+			spca50x->bridge = BRIDGE_SONIX;
+			spca50x->sensor = SENSOR_OV7630;
+			spca50x->customid = SN9C102;
+			spca50x->i2c_ctrl_reg = 0x80;
+			spca50x->i2c_base = 0x21;
+			break;
+		case 0x602d:
+			spca50x->desc = Lic200;
+			spca50x->bridge = BRIDGE_SONIX;
+			spca50x->sensor = SENSOR_HV7131R;
+			spca50x->customid = SN9C102;
+			spca50x->i2c_ctrl_reg = 0x80;
+			spca50x->i2c_base = 0x11;
+			break;
+		case 0x6009:
+		case 0x600d:
+		case 0x6029:
+			spca50x->desc = Sonix6029;
+			spca50x->bridge = BRIDGE_SONIX;
+			spca50x->sensor = SENSOR_PAS106;
+			spca50x->customid = SN9C101;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x40;
+			break;
+		case 0x6040:
+			spca50x->desc = SpeedNVC350K;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_HV7131R;
+			spca50x->customid = SN9C102P;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x11;
+			break;
+		case 0x607c:
+			spca50x->desc = SonixWC311P;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_HV7131R;
+			spca50x->customid = SN9C102P;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x11;
+			break;
+		case 0x6138:
+			spca50x->desc = Sonix0x6138;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_MO4000;
+			spca50x->customid = SN9C120;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x21;
+			break;
+		case 0x612c:
+			spca50x->desc = TyphoonEasyCam1_3;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_MO4000;
+			spca50x->customid = SN9C110;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x21;
+			break;
+		case 0x613b:
+			spca50x->desc = Sonix0x613b;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_OV7660;
+			spca50x->customid = SN9C120;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x21;
+			break;
+		case 0x613c:
+			spca50x->desc = Pccam168;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_HV7131R;
+			spca50x->customid = SN9C120;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x11;
+			break;
+		case 0x6130:
+			spca50x->desc = Pccam;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_MI0360;
+			spca50x->customid = SN9C120;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x5d;
+			break;
+		case 0x60c0:
+			spca50x->desc = Sn535;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_MI0360;
+			spca50x->customid = SN9C105;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x5d;
+			break;
+		case 0x60fb:
+			spca50x->desc = Sonix0x60fb;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_OV7660;
+			spca50x->customid = SN9C105;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x21;
+			break;
+		case 0x60fc:
+			spca50x->desc = Lic300;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_HV7131R;
+			spca50x->customid = SN9C105;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x11;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0546:		/* Polaroid */
+		switch (product) {
+		case 0x3273:
+			spca50x->desc = PolaroidPDC2030;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x3155:
+			spca50x->desc = PolaroidPDC3070;
+			spca50x->bridge = BRIDGE_SPCA533;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x3191:
+			spca50x->desc = PolaroidIon80;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0572:		/* Connexant */
+		switch (product) {
+		case 0x0041:
+			spca50x->desc = CreativeNoteBook2;
+			spca50x->bridge = BRIDGE_CX11646;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x06be:		/* Optimedia */
+		switch (product) {
+		case 0x0800:
+			spca50x->desc = Optimedia;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x2899:		/* ToptroIndustrial */
+		switch (product) {
+		case 0x012c:
+			spca50x->desc = ToptroIndus;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x06bd:		/* Agfa Cl20 */
+		switch (product) {
+		case 0x0404:
+			spca50x->desc = AgfaCl20;
+			spca50x->bridge = BRIDGE_SPCA500;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x093a:		/* Mars-semi ~ Pixart */
+		switch (product) {
+		case 0x050f:
+			spca50x->desc = Pcam;
+			spca50x->bridge = BRIDGE_MR97311;
+			spca50x->sensor = SENSOR_MI0360;
+			break;
+		case 0x2460:
+			spca50x->desc = QtecWb100;
+			spca50x->bridge = BRIDGE_PAC207;
+			spca50x->sensor = SENSOR_PAC207;
+			break;
+		case 0x2468:
+			spca50x->desc = PAC207;
+			spca50x->bridge = BRIDGE_PAC207;
+			spca50x->sensor = SENSOR_PAC207;
+			break;
+		case 0x2470:
+			spca50x->desc = GeniusGF112;
+			spca50x->bridge = BRIDGE_PAC207;
+			spca50x->sensor = SENSOR_PAC207;
+			break;
+		case 0x2471:
+			spca50x->desc = GeniusGe111;
+			spca50x->bridge = BRIDGE_PAC207;
+			spca50x->sensor = SENSOR_PAC207;
+			break;
+  		case 0x2600:
+  		case 0x2601:
+  		case 0x2608:
+  		case 0x260e:
+  		case 0x260f:
+  			spca50x->desc = PAC7311;
+  			spca50x->bridge = BRIDGE_PAC7311;
+  			spca50x->sensor = SENSOR_PAC7311;
+  			break;
+  		case 0x2603:
+  			spca50x->desc = PAC7312;
+  			spca50x->bridge = BRIDGE_PAC7311;
+  			spca50x->sensor = SENSOR_PAC7311;
+  			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0497:		/* Smile International */
+		switch (product) {
+		case 0xc001:
+// Modal NO. VA30UC2 8/nq h0 106250
+// Hone-Tec Inc. VA30UC2
+			spca50x->desc = SmileIntlCamera;
+			spca50x->bridge = BRIDGE_SPCA501;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0698:		/* Chuntex (CTX) */
+		switch (product) {
+		case 0x2003:	/* The Webcam built in the CTX M730V TFT-Display, behind an USB-HUB */
+			spca50x->desc = CTXM730VCam;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_ICM105A;	//overwrite by the sensor detect routine
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x0471:		/* Philips Product */
+		switch (product) {
+		case 0x0322:
+			spca50x->desc =PhilipsDMVC1300K;
+			spca50x->bridge = BRIDGE_SPCA504B;
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		case 0x0325:	/* Low cost Philips Webcam */
+			spca50x->desc = PhilipsSPC200NC;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PAS106;	//overwrite by the sensor detect routine
+			break;
+		case 0x032d:	/* Low cost Philips Webcam */
+			spca50x->desc = PhilipsSPC210NC;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PAS106;	//overwrite by the sensor detect routine
+			break;
+		case 0x032e:	/* Low cost Philips Webcam */
+			spca50x->desc = PhilipsSPC315NC;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PAS106;	//overwrite by the sensor detect routine
+			break;	
+		case 0x0326:	/* Low cost Philips Webcam */
+			spca50x->desc = PhilipsSPC300NC;
+			spca50x->bridge = BRIDGE_ZC3XX;
+			spca50x->sensor = SENSOR_PAS106;	//overwrite by the sensor detect routine
+			break;
+		case 0x0328:
+			spca50x->desc = PhilipsSPC700NC;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_MI0360;
+			spca50x->customid = SN9C105;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x5d;
+			break;
+		case 0x0327:
+			spca50x->desc = PhilipsSPC600NC;
+			spca50x->bridge = BRIDGE_SN9CXXX;
+			spca50x->sensor = SENSOR_MI0360;
+			spca50x->customid = SN9C105;
+			spca50x->i2c_ctrl_reg = 0x81;
+			spca50x->i2c_base = 0x5d;
+			break;
+		default:
+			goto error;
+		};
+		break;
+	case 0x06d6:	/* Trust */
+		switch (product) {
+		case 0x0031:
+			spca50x->desc = Trust610LCDPowerCamZoom;
+			spca50x->bridge = BRIDGE_SPCA533;	/* SPCA533A */
+			spca50x->sensor = SENSOR_INTERNAL;
+			break;
+		default:
+			goto error;
+		}
+		break;
+	default:
+		goto error;
+	}
+	return gspca_attach_bridge(spca50x);
+      error:
+	return -ENODEV;
+}
+static int
+spca5xx_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_interface_descriptor *interface;
+	struct usb_spca50x *spca50x;
+	int err_probe;
+	int i;
+	struct usb_device *dev = interface_to_usbdev(intf);
+/* We don't handle multi-config cameras */
+	if (dev->descriptor.bNumConfigurations != 1)
+		goto nodevice;
+	interface = &intf->cur_altsetting->desc;
+	if (interface->bInterfaceNumber > 0)
+		goto nodevice;
+	if ((spca50x =
+	     kmalloc(sizeof (struct usb_spca50x), GFP_KERNEL)) == NULL) {
+		err("couldn't kmalloc spca50x struct");
+		goto error;
+	}
+	memset(spca50x, 0, sizeof (struct usb_spca50x));
+	spca50x->dev = dev;
+	spca50x->iface = interface->bInterfaceNumber;
+	if ((err_probe = spcaDetectCamera(spca50x)) < 0) {
+		err(" Devices not found !! ");
+		goto error;
+	}
+	PDEBUG(0, "Camera type %s ", Plist[spca50x->cameratype].name);
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+		init_waitqueue_head(&spca50x->frame[i].wq);
+	init_waitqueue_head(&spca50x->wq);
+	if (!spca50x_configure(spca50x)) {
+		spca50x->user = 0;
+		spca50x->last_times = 0;
+		spca50x->dtimes = 0;
+		spca50x->autoexpo = autoexpo;
+		init_MUTEX(&spca50x->lock);	/* to 1 == available */
+		init_MUTEX(&spca50x->buf_lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10)
+		spin_lock_init(&spca50x->v4l_lock);
+#else
+		spca50x->v4l_lock = SPIN_LOCK_UNLOCKED;
+#endif
+		spca50x->buf_state = BUF_NOT_ALLOCATED;
+	} else {
+		err("Failed to configure camera");
+		goto error;
+	}
+/* Init video stuff */
+	spca50x->vdev = video_device_alloc();
+	if (!spca50x->vdev)
+		goto error;
+	memcpy(spca50x->vdev, &spca50x_template, sizeof (spca50x_template));
+	spca50x->vdev->dev = &dev->dev;
+	video_set_drvdata(spca50x->vdev, spca50x);
+	PDEBUG(2, "setting video device = %p, spca50x = %p", spca50x->vdev,
+	       spca50x);
+	if (video_register_device(spca50x->vdev, VFL_TYPE_GRABBER, video_nr) <
+	    0) {
+		err("video_register_device failed");
+		goto error;
+	}
+/* test on disconnect */
+	spca50x->present = 1;
+/* Workaround for some applications that want data in RGB
+* instead of BGR */
+	if (spca50x->force_rgb)
+		info("data format set to RGB");
+	usb_set_intfdata(intf, spca50x);
+	if (spca50x_create_sysfs(spca50x->vdev))
+		goto error;
+	tasklet_init(&spca50x->spca5xx_tasklet,
+		outpict_do_tasklet,(unsigned long) 0);
+	return 0;
+      error:
+	if (spca50x->vdev) {
+		if (spca50x->vdev->minor == -1)
+			video_device_release(spca50x->vdev);
+		else
+			video_unregister_device(spca50x->vdev);
+		spca50x->vdev = NULL;
+	}
+	if (spca50x) {
+		kfree(spca50x);
+		spca50x = NULL;
+	}
+	return -EIO;
+      nodevice:
+	return -ENODEV;
+}
+static void
+spca5xx_disconnect(struct usb_interface *intf)
+{
+	struct usb_spca50x *spca50x = usb_get_intfdata(intf);
+	int n;
+	if (!spca50x)
+		return;
+	down(&spca50x->lock);
+	spca50x->present = 0;
+	for (n = 0; n < SPCA50X_NUMFRAMES; n++)
+		spca50x->frame[n].grabstate = FRAME_ABORTING;
+	spca50x->curframe = -1;
+/* This will cause the process to request another frame */
+	for (n = 0; n < SPCA50X_NUMFRAMES; n++)
+		if (waitqueue_active(&spca50x->frame[n].wq))
+			wake_up_interruptible(&spca50x->frame[n].wq);
+	if (waitqueue_active(&spca50x->wq))
+		wake_up_interruptible(&spca50x->wq);
+	gspca_kill_transfert(spca50x);
+	PDEBUG(3, "Disconnect Kill isoc done");
+	up(&spca50x->lock);
+	while (spca50x->user)
+		schedule();
+	down(&spca50x->lock);
+	dev_set_drvdata(&intf->dev, NULL);
+/* We don't want people trying to open up the device */
+	if (spca50x->vdev)
+		video_unregister_device(spca50x->vdev);
+	spca50x->dev = NULL;
+	up(&spca50x->lock);
+/* Free the memory */
+	if (spca50x && !spca50x->user) {
+		spca5xx_dealloc(spca50x);
+		kfree(spca50x);
+		spca50x = NULL;
+	}
+	PDEBUG(3, "Disconnect complete");
+}
+static struct usb_driver spca5xx_driver = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	.owner = THIS_MODULE,
+#endif
+	.name = "gspca",
+	.id_table = device_table,
+	.probe = spca5xx_probe,
+	.disconnect = spca5xx_disconnect
+};
+
+/****************************************************************************
+*
+*  Module routines
+*
+***************************************************************************/
+static int __init
+usb_spca5xx_init(void)
+{
+	if (usb_register(&spca5xx_driver) < 0)
+		return -1;
+	info("gspca driver %s registered", gspca_version);
+	return 0;
+}
+static void __exit
+usb_spca5xx_exit(void)
+{
+	usb_deregister(&spca5xx_driver);
+	info("driver gspca deregistered");
+}
+
+module_init(usb_spca5xx_init);
+module_exit(usb_spca5xx_exit);
+//eof
diff -ruN linux-2.6.21/drivers/media/video/gspca/utils/spcaCompat.h linux-2.6.21-gspca/drivers/media/video/gspca/utils/spcaCompat.h
--- linux-2.6.21/drivers/media/video/gspca/utils/spcaCompat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/utils/spcaCompat.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,33 @@
+
+#ifndef SPCA_COMPAT_H
+#define SPCA_COMPAT_H
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 24)
+static inline void *video_get_drvdata(struct video_device *vdev)
+{
+    return vdev->priv;
+}
+
+static inline void video_set_drvdata(struct video_device *vdev, void *data)
+{
+    vdev->priv = data;
+}
+
+static inline struct video_device *video_device_alloc(void)
+{
+    struct video_device *vdev;
+
+    vdev = kmalloc(sizeof(*vdev), GFP_KERNEL);
+    if (NULL == vdev)
+	return NULL;
+    memset(vdev, 0, sizeof(*vdev));
+    return vdev;
+}
+
+static inline void video_device_release(struct video_device *vdev)
+{
+    kfree(vdev);
+}
+#endif
+
+#endif
diff -ruN linux-2.6.21/drivers/media/video/gspca/utils/spcagamma.h linux-2.6.21-gspca/drivers/media/video/gspca/utils/spcagamma.h
--- linux-2.6.21/drivers/media/video/gspca/utils/spcagamma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/utils/spcagamma.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,231 @@
+#ifndef GAMMA_TABLES_H
+#define GAMMA_TABLES_H
+/* Gamma tables for the spca5xx camera (25/12/2003) by mxhaard@magic.fr
+* Original work from
+* Adam M. Costello <amc @ cs.berkeley.edu>
+* Gamma_tables_h is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Gamma_tables_h is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+/*	Gtable[0][n] -> 2.2
+*	Gtable[1][n] -> 1.7
+*	Gtable[2][n] -> 1.45
+*	Gtable[3][n] -> 1
+*	Gtable[4][n] -> 0.6896
+*	Gtable[5][n] -> 0.5882
+*	Gtable[6][n] -> 0.4545
+*	
+*/
+static unsigned char GTable[7][256] = {
+// gamma-coeff = 2.2000
+    {
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
+     3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6,
+     6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12,
+     12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19,
+     20, 20, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 28, 28, 29,
+     30, 30, 31, 32, 33, 33, 34, 35, 35, 36, 37, 38, 39, 39, 40, 41,
+     42, 43, 43, 44, 45, 46, 47, 48, 49, 49, 50, 51, 52, 53, 54, 55,
+     56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
+     73, 74, 75, 76, 77, 78, 79, 81, 82, 83, 84, 85, 87, 88, 89, 90,
+     91, 93, 94, 95, 97, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110,
+     111,
+     113, 114, 116, 117, 119, 120, 121, 123, 124, 126, 127, 129, 130, 132,
+     133, 135,
+     137, 138, 140, 141, 143, 145, 146, 148, 149, 151, 153, 154, 156, 158,
+     159, 161,
+     163, 165, 166, 168, 170, 172, 173, 175, 177, 179, 181, 182, 184, 186,
+     188, 190,
+     192, 194, 196, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217,
+     219, 221,
+     223, 225, 227, 229, 231, 234, 236, 238, 240, 242, 244, 246, 248, 251,
+     253, 255,
+     },
+// gamma-coeff = 1.7000
+    {
+     0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2,
+     2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7,
+     7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14,
+     15, 15, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 22, 23, 24,
+     24, 25, 26, 26, 27, 28, 28, 29, 30, 30, 31, 32, 33, 33, 34, 35,
+     36, 36, 37, 38, 39, 39, 40, 41, 42, 43, 43, 44, 45, 46, 47, 48,
+     48, 49, 50, 51, 52, 53, 54, 55, 56, 56, 57, 58, 59, 60, 61, 62,
+     63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
+     79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 93, 94, 95,
+     97, 98, 99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 111, 112,
+     113, 114,
+     115, 117, 118, 119, 120, 122, 123, 124, 125, 127, 128, 129, 131, 132,
+     133, 134,
+     136, 137, 138, 140, 141, 142, 144, 145, 146, 148, 149, 151, 152, 153,
+     155, 156,
+     157, 159, 160, 162, 163, 164, 166, 167, 169, 170, 172, 173, 175, 176,
+     177, 179,
+     180, 182, 183, 185, 186, 188, 189, 191, 192, 194, 195, 197, 198, 200,
+     202, 203,
+     205, 206, 208, 209, 211, 212, 214, 216, 217, 219, 220, 222, 224, 225,
+     227, 228,
+     230, 232, 233, 235, 237, 238, 240, 242, 243, 245, 247, 248, 250, 252,
+     253, 255,
+     },
+// gamma-coeff = 1.4500
+    {
+     0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4,
+     5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12,
+     13, 13, 14, 14, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22,
+     23, 23, 24, 25, 25, 26, 27, 28, 28, 29, 30, 31, 31, 32, 33, 34,
+     34, 35, 36, 37, 38, 38, 39, 40, 41, 42, 42, 43, 44, 45, 46, 47,
+     47, 48, 49, 50, 51, 52, 53, 54, 55, 55, 56, 57, 58, 59, 60, 61,
+     62, 63, 64, 65, 66, 67, 68, 69, 69, 70, 71, 72, 73, 74, 75, 76,
+     77, 78, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 93,
+     94, 95, 96, 97, 98, 99, 100, 101, 103, 104, 105, 106, 107, 108, 109,
+     110,
+     111, 112, 114, 115, 116, 117, 118, 119, 120, 122, 123, 124, 125, 126,
+     127, 129,
+     130, 131, 132, 133, 134, 136, 137, 138, 139, 140, 142, 143, 144, 145,
+     147, 148,
+     149, 150, 151, 153, 154, 155, 156, 158, 159, 160, 161, 163, 164, 165,
+     166, 168,
+     169, 170, 172, 173, 174, 175, 177, 178, 179, 181, 182, 183, 185, 186,
+     187, 188,
+     190, 191, 192, 194, 195, 196, 198, 199, 200, 202, 203, 205, 206, 207,
+     209, 210,
+     211, 213, 214, 215, 217, 218, 220, 221, 222, 224, 225, 227, 228, 229,
+     231, 232,
+     234, 235, 236, 238, 239, 241, 242, 243, 245, 246, 248, 249, 251, 252,
+     254, 255,
+     },
+// gamma-coeff = 1.0000
+    {
+     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
+     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
+     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
+     96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
+     111,
+     112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,
+     126, 127,
+     128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141,
+     142, 143,
+     144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157,
+     158, 159,
+     160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173,
+     174, 175,
+     176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
+     190, 191,
+     192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,
+     206, 207,
+     208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221,
+     222, 223,
+     224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
+     238, 239,
+     240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
+     254, 255,
+     },
+// gamma-coeff = 0.6896
+    {
+     0, 6, 9, 12, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 34, 36,
+     38, 39, 41, 43, 44, 46, 47, 49, 50, 51, 53, 54, 56, 57, 58, 60,
+     61, 62, 64, 65, 66, 67, 69, 70, 71, 72, 74, 75, 76, 77, 78, 79,
+     81, 82, 83, 84, 85, 86, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97,
+     98, 99, 100, 101, 102, 104, 105, 106, 107, 108, 109, 110, 111, 112,
+     113, 114,
+     115, 116, 117, 118, 119, 120, 121, 121, 122, 123, 124, 125, 126, 127,
+     128, 129,
+     130, 131, 132, 133, 134, 135, 136, 136, 137, 138, 139, 140, 141, 142,
+     143, 144,
+     145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 155, 156,
+     157, 158,
+     159, 159, 160, 161, 162, 163, 164, 164, 165, 166, 167, 168, 169, 169,
+     170, 171,
+     172, 173, 174, 174, 175, 176, 177, 178, 178, 179, 180, 181, 182, 183,
+     183, 184,
+     185, 186, 187, 187, 188, 189, 190, 190, 191, 192, 193, 194, 194, 195,
+     196, 197,
+     197, 198, 199, 200, 201, 201, 202, 203, 204, 204, 205, 206, 207, 207,
+     208, 209,
+     210, 210, 211, 212, 213, 213, 214, 215, 216, 216, 217, 218, 219, 219,
+     220, 221,
+     222, 222, 223, 224, 225, 225, 226, 227, 227, 228, 229, 230, 230, 231,
+     232, 232,
+     233, 234, 235, 235, 236, 237, 237, 238, 239, 240, 240, 241, 242, 242,
+     243, 244,
+     245, 245, 246, 247, 247, 248, 249, 249, 250, 251, 252, 252, 253, 254,
+     254, 255,
+     },
+// gamma-coeff = 0.5882
+    {
+     0, 10, 15, 19, 22, 25, 28, 31, 33, 36, 38, 40, 42, 44, 46, 48,
+     50, 52, 54, 55, 57, 59, 60, 62, 64, 65, 67, 68, 70, 71, 72, 74,
+     75, 77, 78, 79, 81, 82, 83, 84, 86, 87, 88, 89, 91, 92, 93, 94,
+     95, 97, 98, 99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111,
+     112,
+     113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,
+     127, 128,
+     129, 130, 131, 132, 133, 134, 135, 135, 136, 137, 138, 139, 140, 141,
+     142, 143,
+     144, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155,
+     156, 156,
+     157, 158, 159, 160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 168,
+     168, 169,
+     170, 171, 172, 172, 173, 174, 175, 175, 176, 177, 178, 178, 179, 180,
+     181, 181,
+     182, 183, 184, 184, 185, 186, 187, 187, 188, 189, 190, 190, 191, 192,
+     192, 193,
+     194, 195, 195, 196, 197, 197, 198, 199, 200, 200, 201, 202, 202, 203,
+     204, 204,
+     205, 206, 206, 207, 208, 208, 209, 210, 210, 211, 212, 212, 213, 214,
+     214, 215,
+     216, 216, 217, 218, 218, 219, 220, 220, 221, 222, 222, 223, 224, 224,
+     225, 226,
+     226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 234,
+     235, 236,
+     236, 237, 238, 238, 239, 239, 240, 241, 241, 242, 242, 243, 244, 244,
+     245, 245,
+     246, 247, 247, 248, 248, 249, 250, 250, 251, 251, 252, 253, 253, 254,
+     254, 255,
+     },
+// gamma-coeff = 0.4545
+    {
+     0, 21, 28, 34, 39, 43, 46, 50, 53, 56, 59, 61, 64, 66, 68, 70,
+     72, 74, 76, 78, 80, 82, 84, 85, 87, 89, 90, 92, 93, 95, 96, 98,
+     99, 101, 102, 103, 105, 106, 107, 109, 110, 111, 112, 114, 115, 116,
+     117, 118,
+     119, 120, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
+     134, 135,
+     136, 137, 138, 139, 140, 141, 142, 143, 144, 144, 145, 146, 147, 148,
+     149, 150,
+     151, 151, 152, 153, 154, 155, 156, 156, 157, 158, 159, 160, 160, 161,
+     162, 163,
+     164, 164, 165, 166, 167, 167, 168, 169, 170, 170, 171, 172, 173, 173,
+     174, 175,
+     175, 176, 177, 178, 178, 179, 180, 180, 181, 182, 182, 183, 184, 184,
+     185, 186,
+     186, 187, 188, 188, 189, 190, 190, 191, 192, 192, 193, 194, 194, 195,
+     195, 196,
+     197, 197, 198, 199, 199, 200, 200, 201, 202, 202, 203, 203, 204, 205,
+     205, 206,
+     206, 207, 207, 208, 209, 209, 210, 210, 211, 212, 212, 213, 213, 214,
+     214, 215,
+     215, 216, 217, 217, 218, 218, 219, 219, 220, 220, 221, 221, 222, 223,
+     223, 224,
+     224, 225, 225, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231,
+     231, 232,
+     232, 233, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239,
+     239, 240,
+     240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246, 246, 247,
+     247, 248,
+     248, 249, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 254,
+     255, 255,
+     },
+};
+#endif				/* GAMMA_TABLES_H */
diff -ruN linux-2.6.21/drivers/media/video/gspca/utils/spcausb.h linux-2.6.21-gspca/drivers/media/video/gspca/utils/spcausb.h
--- linux-2.6.21/drivers/media/video/gspca/utils/spcausb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-gspca/drivers/media/video/gspca/utils/spcausb.h	2007-05-13 00:27:08.000000000 +0200
@@ -0,0 +1,438 @@
+
+#ifndef SPCAUSB_H
+#define SPCAUSB_INIT_H
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 6)
+#define wait_ms(a) msleep((a))
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 11)
+#define TimeOut 1000
+#else
+#define TimeOut HZ
+#endif
+/* Common functions prototype */
+static int spca50x_reg_read(struct usb_device *dev,
+			    __u16 reg, __u16 index, __u16 length);
+static int spca50x_reg_write(struct usb_device *dev,
+			     __u16 reg, __u16 index, __u16 value);
+
+static void spca5xxRegRead(struct usb_device *dev,
+			   __u16 reg,
+			   __u16 value,
+			   __u16 index, __u8 * buffer, __u16 length);
+static void spca5xxRegWrite(struct usb_device *dev,
+			    __u16 reg,
+			    __u16 value,
+			    __u16 index, __u8 * buffer, __u16 length);
+static void sonixRegRead(struct usb_device *dev,
+			 __u16 reg,
+			 __u16 value,
+			 __u16 index, __u8 * buffer, __u16 length);
+static void sonixRegWrite(struct usb_device *dev,
+			  __u16 reg,
+			  __u16 value,
+			  __u16 index, __u8 * buffer, __u16 length);
+#if 0
+static void Et_RegWrite(struct usb_device *dev,
+			__u16 reg,
+			__u16 value,
+			__u16 index, __u8 * buffer, __u16 length);
+static void Et_RegRead(struct usb_device *dev,
+		       __u16 reg,
+		       __u16 value,
+		       __u16 index, __u8 * buffer, __u16 length);
+#endif
+static int spca_set_interface(struct usb_device *dev,
+			      int interface, int alternate);
+/*
+static int spca_clear_feature(struct usb_device *dev,
+				 int endpoint)
+{
+	int inpipe;
+	inpipe = usb_rcvintpipe(dev,endpoint);
+	usb_clear_halt(dev, inpipe);
+	return 0;
+}
+*/
+
+static int spca50x_setup_qtable(struct usb_spca50x *spca50x,
+				unsigned int request,
+				unsigned int ybase,
+				unsigned int cbase,
+				unsigned char qtable[2][64]);
+/* Alias setting */
+#define pac207RegWrite(dev,req,value,index,buffer,length) sonixRegWrite(dev,req,value,index,buffer,length)
+#define pac207RegRead(dev,req,value,index,buffer,length) sonixRegRead(dev,req,value,index,buffer,length)
+#define pac7311RegWrite(dev,req,value,index,buffer,length) spca5xxRegWrite(dev,req,value,index,buffer,length)
+#define pac7311RegRead(dev,req,value,index,buffer,length) spca5xxRegRead(dev,req,value,index,buffer,length)
+#define Et_RegWrite(dev,req,value,index,buffer,length) sonixRegWrite(dev,req,value,index,buffer,length)
+#define Et_RegRead(dev,req,value,index,buffer,length) sonixRegRead(dev,req,value,index,buffer,length)
+/***************************** Implementation ****************************/
+static void spca5xxRegRead(struct usb_device *dev,
+			   __u16 reg,
+			   __u16 value,
+			   __u16 index, __u8 * buffer, __u16 length)
+{
+    int rc;
+    __u8 *kbuffer = NULL;
+    __u16 RegType;
+    if (length > 0) {
+	kbuffer = (__u8 *) kmalloc(length, GFP_KERNEL);
+	memcpy(kbuffer, buffer, length);
+    }
+    RegType = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+    rc = usb_control_msg(dev,
+			 usb_rcvctrlpipe(dev, 0),
+			 reg,
+			 RegType,
+			 (__u16) value, (__u16) index, kbuffer, length,
+			 TimeOut);
+    if (length > 0) {
+	memcpy(buffer, kbuffer, length);
+	kfree(kbuffer);
+    }
+    if (buffer) {
+	PDEBUG(5, "reg read: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+	       RegType, reg, value, index, (int) *buffer);
+    } else {
+	PDEBUG(5, "reg read: 0x%02X, 0x%02X,0x%02X, 0x%02X ", RegType, reg,
+	       value, index);
+    }
+    return;
+}
+
+
+static void spca5xxRegWrite(struct usb_device *dev,
+			    __u16 reg,
+			    __u16 value,
+			    __u16 index, __u8 * buffer, __u16 length)
+{
+    int rc;
+    __u16 RegType;
+    __u8 *kbuffer = NULL;
+    if (length > 0) {
+	kbuffer = (__u8 *) kmalloc(length, GFP_KERNEL);
+	memcpy(kbuffer, buffer, length);
+    }
+    RegType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+    rc = usb_control_msg(dev,
+			 usb_sndctrlpipe(dev, 0),
+			 reg,
+			 RegType,
+			 (__u16) value, (__u16) index, kbuffer, length,
+			 TimeOut);
+    if (length > 0) {
+	memcpy(buffer, kbuffer, length);
+	kfree(kbuffer);
+    }
+    if (buffer) {
+	PDEBUG(5, "reg write: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+	       RegType, reg, value, index, (int) *buffer);
+    } else {
+	PDEBUG(5, "reg write: 0x%02X, 0x%02X,0x%02X, 0x%02X ", RegType,
+	       reg, value, index);
+    }
+    return;
+}
+static void sonixRegRead(struct usb_device *dev,
+			 __u16 reg,
+			 __u16 value,
+			 __u16 index, __u8 * buffer, __u16 length)
+{
+    int rc;
+    __u8 *kbuffer = NULL;
+    __u16 RegType;
+    if (length > 0) {
+	kbuffer = (__u8 *) kmalloc(length, GFP_KERNEL);
+	memcpy(kbuffer, buffer, length);
+    }
+    RegType = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;
+    rc = usb_control_msg(dev,
+			 usb_rcvctrlpipe(dev, 0),
+			 reg,
+			 RegType,
+			 (__u16) value, (__u16) index, kbuffer, length,
+			 TimeOut);
+    if (length > 0) {
+	memcpy(buffer, kbuffer, length);
+	kfree(kbuffer);
+    }
+    if (buffer) {
+	PDEBUG(5, "reg read: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+	       RegType, reg, value, index, (int) *buffer);
+    } else {
+	PDEBUG(5, "reg read: 0x%02X, 0x%02X,0x%02X, 0x%02X ", RegType, reg,
+	       value, index);
+    }
+    return;
+}
+
+static void sonixRegWrite(struct usb_device *dev,
+			  __u16 reg,
+			  __u16 value,
+			  __u16 index, __u8 * buffer, __u16 length)
+{
+    int rc;
+    __u16 RegType;
+    __u8 *kbuffer = NULL;
+    if (length > 0) {
+	kbuffer = (__u8 *) kmalloc(length, GFP_KERNEL);
+	memcpy(kbuffer, buffer, length);
+    }
+    RegType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;
+    rc = usb_control_msg(dev,
+			 usb_sndctrlpipe(dev, 0),
+			 reg,
+			 RegType,
+			 (__u16) value, (__u16) index, kbuffer, length,
+			 TimeOut);
+    if (length > 0) {
+	memcpy(buffer, kbuffer, length);
+	kfree(kbuffer);
+    }
+    if (buffer) {
+	PDEBUG(5, "reg write: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+	       RegType, reg, value, index, (int) *buffer);
+    } else {
+	PDEBUG(5, "reg write: 0x%02X, 0x%02X,0x%02X, 0x%02X ", RegType,
+	       reg, value, index);
+    }
+    return;
+}
+#if 0
+static void Et_RegRead(struct usb_device *dev,
+		       __u16 reg,
+		       __u16 value,
+		       __u16 index, __u8 * buffer, __u16 length)
+{
+    int rc;
+    __u8 *kbuffer = NULL;
+    __u16 RegType;
+    if (length > 0) {
+	kbuffer = (__u8 *) kmalloc(length, GFP_KERNEL);
+	memcpy(kbuffer, buffer, length);
+    }
+    RegType = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;
+    rc = usb_control_msg(dev,
+			 usb_rcvctrlpipe(dev, 0),
+			 reg,
+			 RegType,
+			 (__u16) value, (__u16) index, kbuffer, length,
+			 TimeOut);
+    if (length > 0) {
+	memcpy(buffer, kbuffer, length);
+	kfree(kbuffer);
+    }
+    if (buffer) {
+	PDEBUG(5, "reg read: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+	       RegType, reg, value, index, (int) *buffer);
+    } else {
+	PDEBUG(5, "reg read: 0x%02X, 0x%02X,0x%02X, 0x%02X ", RegType, reg,
+	       value, index);
+    }
+    return;
+}
+
+static void Et_RegWrite(struct usb_device *dev,
+			__u16 reg,
+			__u16 value,
+			__u16 index, __u8 * buffer, __u16 length)
+{
+    int rc;
+    __u16 RegType;
+    __u8 *kbuffer = NULL;
+    if (length > 0) {
+	kbuffer = (__u8 *) kmalloc(length, GFP_KERNEL);
+	memcpy(kbuffer, buffer, length);
+    }
+    RegType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;
+    rc = usb_control_msg(dev,
+			 usb_sndctrlpipe(dev, 0),
+			 reg,
+			 RegType,
+			 (__u16) value, (__u16) index, kbuffer, length,
+			 TimeOut);
+    if (length > 0) {
+	memcpy(buffer, kbuffer, length);
+	kfree(kbuffer);
+    }
+    if (buffer) {
+	PDEBUG(5, "reg write: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+	       RegType, reg, value, index, (int) *buffer);
+    } else {
+	PDEBUG(5, "reg write: 0x%02X, 0x%02X,0x%02X, 0x%02X ", RegType,
+	       reg, value, index);
+    }
+    return;
+}
+#endif
+
+static int spca_set_interface(struct usb_device *dev, int interface,
+			      int alternate)
+{
+    struct usb_interface *iface;
+    int ret;
+
+    iface = usb_ifnum_to_if(dev, interface);
+    if (!iface) {
+	warn("selecting invalid interface %d", interface);
+	return -EINVAL;
+    }
+
+    /* 9.4.10 says devices don't need this, if the interface
+       only has one alternate setting */
+    if (iface->num_altsetting == 1) {
+	dbg("ignoring set_interface for dev %d, iface %d, alt %d",
+	    dev->devnum, interface, alternate);
+	return 0;
+    }
+
+    if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			       USB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,
+			       alternate, interface, NULL, 0,
+			       TimeOut * 5)) < 0)
+	return ret;
+
+
+    return 0;
+
+}
+
+static int spca50x_reg_write(struct usb_device *dev,
+			     __u16 reg, __u16 index, __u16 value)
+{
+    int rc;
+
+    rc = usb_control_msg(dev,
+			 usb_sndctrlpipe(dev, 0),
+			 reg,
+			 USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			 value, index, NULL, 0, TimeOut);
+
+    PDEBUG(5, "reg write: 0x%02X,0x%02X:0x%02X, 0x%x", reg, index, value,
+	   rc);
+
+    if (rc < 0)
+	err("reg write: error %d", rc);
+
+    return rc;
+}
+
+static int spca50x_reg_read_with_value(struct usb_device *dev, __u16 reg,	// bRequest
+				       __u16 value,	// wValue
+				       __u16 index,	// wIndex
+				       __u16 length)	// wLength
+{
+    int rc;
+    unsigned char buffer[4] = { 0, 0, 0, 0 };
+    /* Hope plp didn't ask for more */
+    rc = usb_control_msg(dev,
+			 usb_rcvctrlpipe(dev, 0),
+			 reg,
+			 USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			 (__u16) value, (__u16) index, buffer, length,
+			 TimeOut);
+
+    PDEBUG(5, "reg read: 0x%02X,0x%02X:0x%04X", reg, index,
+	   *(int *) &buffer[0]);
+
+    if (rc < 0) {
+	err("reg read: error %d", rc);
+	return rc;
+    } else {
+	return *(int *) &buffer[0];
+    }
+}
+
+/* returns: negative is error, pos or zero is data */
+static int spca50x_reg_read(struct usb_device *dev, __u16 reg,	// bRequest
+			    __u16 index,	// wIndex
+			    __u16 length)	// wLength
+{
+    return spca50x_reg_read_with_value(dev, reg, 0, index, length);
+}
+
+/*
+ * Simple function to wait for a given 8-bit value to be returned from
+ * a spca50x_reg_read call.
+ * Returns: negative is error or timeout, zero is success.
+ */
+static int spca50x_reg_readwait(struct usb_device *dev,
+				__u16 reg, __u16 index, __u16 value)
+{
+    int count = 0;
+    int result = 0;
+
+    while (count < 20) {
+	result = spca50x_reg_read(dev, reg, index, 1);
+	if (result == value)
+	    return 0;
+
+	wait_ms(50);
+
+	count++;
+    }
+
+    PDEBUG(2, "spca50x_reg_readwait failed");
+
+    return -EIO;
+}
+static int spca50x_write_vector(struct usb_spca50x *spca50x,
+				__u16 data[][3])
+{
+    struct usb_device *dev = spca50x->dev;
+    int err_code;
+
+    int I = 0;
+    while ((data[I][0]) != (__u16) 0 || (data[I][1]) != (__u16) 0
+	   || (data[I][2]) != (__u16) 0) {
+	err_code =
+	    spca50x_reg_write(dev, data[I][0], (__u16) (data[I][2]),
+			      (__u16) (data[I][1]));
+	if (err_code < 0) {
+	    PDEBUG(1, "Register write failed for 0x%x,0x%x,0x%x",
+		   data[I][0], data[I][1], data[I][2]);
+	    return -1;
+	}
+	I++;
+    }
+    return 0;
+}
+
+static int spca50x_setup_qtable(struct usb_spca50x *spca50x,
+				unsigned int request,
+				unsigned int ybase,
+				unsigned int cbase,
+				unsigned char qtable[2][64])
+{
+    int i;
+    int err;
+
+    /* loop over y components */
+    for (i = 0; i < 64; i++) {
+	err =
+	    spca50x_reg_write(spca50x->dev, request, ybase + i,
+			      qtable[0][i]);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write failed");
+	    return err;
+	}
+    }
+
+    /* loop over c components */
+    for (i = 0; i < 64; i++) {
+	err =
+	    spca50x_reg_write(spca50x->dev, request, cbase + i,
+			      qtable[1][i]);
+	if (err < 0) {
+	    PDEBUG(2, "spca50x_reg_write failed");
+	    return err;
+	}
+    }
+
+    /* all ok */
+    return 0;
+}
+
+
+#endif				/* SPCAUSB_H */
