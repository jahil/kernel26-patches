diff -Naur ./Makefile ../linux-2.6.18-mdb/./Makefile
--- ./Makefile	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./Makefile	2008-08-02 12:14:12.000000000 -0600
@@ -553,6 +553,7 @@
 
 ifeq ($(KBUILD_EXTMOD),)
 core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+core-$(CONFIG_MDB) += debug/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff -Naur ./arch/i386/Kconfig.debug ../linux-2.6.18-mdb/./arch/i386/Kconfig.debug
--- ./arch/i386/Kconfig.debug	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./arch/i386/Kconfig.debug	2008-08-02 12:14:12.000000000 -0600
@@ -85,4 +85,28 @@
           option saves about 4k and might cause you much additional grey
           hair.
 
+config MDB
+	bool "Merkey's Kernel Debugger"
+	depends on DEBUG_KERNEL
+	select KALLSYMS
+	help
+           NetWare style kernel debugger for Linux written by Jeffrey Vernon 
+	   Merkey.
+
+config MDB_CONSOLE_REDIRECTION
+	bool "MDB Console Redirection Support"
+	depends on MDB
+	default y
+	help
+           Reset any Console Redirection to default system settings (0) 
+           when the MDB debugger is active.  The Debugger will restore 
+           the redirection to the custom settings when the debugger 
+           is exited.  This feature is useful on systems which by default 
+           redirect printk output and the screen debugger output to a log
+           file or system device, which can prevent the debugger screen from
+           being visible.  Enabling this feature does not affect or disable 
+           remote operations via serial port.  It is recommended to enable
+           this feature by default if intensive debugging is intended for
+           the target system.
+
 endmenu
diff -Naur ./arch/i386/kernel/reboot.c ../linux-2.6.18-mdb/./arch/i386/kernel/reboot.c
--- ./arch/i386/kernel/reboot.c	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./arch/i386/kernel/reboot.c	2008-08-02 12:14:12.000000000 -0600
@@ -309,7 +309,16 @@
 	 * all of the others, and disable their local APICs.
 	 */
 
+#ifdef CONFIG_MDB
+        // do not stop the other processors if the debugger is active
+        {
+           extern atomic_t inmdb;
+           if (!atomic_read(&inmdb))
+	      smp_send_stop();
+        }
+#else
 	smp_send_stop();
+#endif
 #endif /* CONFIG_SMP */
 
 	lapic_shutdown();
diff -Naur ./arch/i386/kernel/traps.c ../linux-2.6.18-mdb/./arch/i386/kernel/traps.c
--- ./arch/i386/kernel/traps.c	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./arch/i386/kernel/traps.c	2008-08-02 12:14:12.000000000 -0600
@@ -135,7 +135,8 @@
 	unsigned long addr;
 
 #ifdef	CONFIG_FRAME_POINTER
-	while (valid_stack_ptr(tinfo, (void *)ebp)) {
+	while (valid_stack_ptr(tinfo, (void *)ebp)) 
+        {
 		addr = *(unsigned long *)(ebp + 4);
 		print_addr_and_symbol(addr, log_lvl);
 		/*
@@ -372,6 +373,17 @@
 /* This is gone through when something in the kernel
  * has done something bad and is about to be terminated.
 */
+
+#ifdef CONFIG_MDB
+#define DEBUGGER_EXCEPTION        1
+#define NMI_EXCEPTION             2
+#define BREAKPOINT_EXCEPTION      3
+#define SOFTWARE_EXCEPTION       22
+
+extern unsigned char *mdb_oops;
+extern int mdb(int reason, int error, void *frame);
+#endif
+
 void die(const char * str, struct pt_regs * regs, long err)
 {
 	static struct {
@@ -446,7 +458,10 @@
 	bust_spinlocks(0);
 	die.lock_owner = -1;
 	spin_unlock_irqrestore(&die.lock, flags);
-
+#ifdef	CONFIG_MDB
+        mdb_oops = (unsigned char *)str;
+        mdb(SOFTWARE_EXCEPTION, err, regs); 
+#endif	
 	if (!regs)
 		return;
 
@@ -554,7 +569,7 @@
 }
 
 DO_VM86_ERROR_INFO( 0, SIGFPE,  "divide error", divide_error, FPE_INTDIV, regs->eip)
-#ifndef CONFIG_KPROBES
+#if !defined(CONFIG_KPROBES) && !defined(CONFIG_MDB)
 DO_VM86_ERROR( 3, SIGTRAP, "int3", int3)
 #endif
 DO_VM86_ERROR( 4, SIGSEGV, "overflow", overflow)
@@ -690,6 +705,9 @@
 	printk(" on CPU%d, eip %08lx, registers:\n",
 		smp_processor_id(), regs->eip);
 	show_registers(regs);
+#ifdef	CONFIG_MDB
+        mdb(NMI_EXCEPTION, 0, regs); // nmi is code 2
+#endif
 	printk(KERN_EMERG "console shuts up ...\n");
 	console_silent();
 	spin_unlock(&nmi_print_lock);
@@ -713,7 +731,12 @@
 	/* Only the BSP gets external NMIs from the system.  */
 	if (!smp_processor_id())
 		reason = get_nmi_reason();
- 
+
+#if defined(CONFIG_SMP) && defined(CONFIG_MDB)
+        if (mdb(NMI_EXCEPTION, 0, regs))
+           return;
+#endif
+
 	if (!(reason & 0xc0)) {
 		if (notify_die(DIE_NMI_IPI, "nmi_ipi", regs, reason, 2, SIGINT)
 							== NOTIFY_STOP)
@@ -783,6 +806,10 @@
 #ifdef CONFIG_KPROBES
 fastcall void __kprobes do_int3(struct pt_regs *regs, long error_code)
 {
+#ifdef	CONFIG_MDB
+        if (mdb(BREAKPOINT_EXCEPTION, error_code, regs))
+           return;
+#endif
 	if (notify_die(DIE_INT3, "int3", regs, error_code, 3, SIGTRAP)
 			== NOTIFY_STOP)
 		return;
@@ -821,7 +848,10 @@
 	struct task_struct *tsk = current;
 
 	get_debugreg(condition, 6);
-
+#ifdef	CONFIG_MDB
+        if (mdb(DEBUGGER_EXCEPTION, error_code, regs))
+           return;
+#endif	
 	if (notify_die(DIE_DEBUG, "debug", regs, condition, error_code,
 					SIGTRAP) == NOTIFY_STOP)
 		return;
@@ -875,6 +905,14 @@
 	return;
 }
 
+#if defined(CONFIG_MDB) && !defined(CONFIG_KPROBES)
+fastcall void do_int3(struct pt_regs * regs, long error_code)
+{
+	if (mdb(DEBUGGER_EXCEPTION, error_code, regs))
+	   return;
+	do_trap(3, SIGTRAP, "int3", 1, regs, error_code, NULL);
+}
+#endif	/* CONFIG_KDB && !CONFIG_KPROBES */
 /*
  * Note that we play around with the 'TS' bit in an attempt to get
  * the correct behaviour even in the presence of the asynchronous
diff -Naur ./debug/Makefile ../linux-2.6.18-mdb/./debug/Makefile
--- ./debug/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/Makefile	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,5 @@
+
+#
+obj-y		:=mdb.o mdb-base.o mdb-list.o mdb-logic.o mdb-os.o mdb-ia32.o mdb-ia32-support.o 
+
+
diff -Naur ./debug/mdb-base.c ../linux-2.6.18-mdb/./debug/mdb-base.c
--- ./debug/mdb-base.c	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-base.c	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,2432 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-BASE.C
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#include "mdb.h"
+
+#ifdef CONFIG_MDB
+
+ULONG debug_deref = 0;
+ULONG full_deref_toggle = 0;
+ULONG general_toggle = TRUE;
+ULONG line_info_toggle = TRUE;
+ULONG control_toggle = 0;
+ULONG segment_toggle = TRUE;
+ULONG numeric_toggle = 0;
+ULONG reason_toggle = TRUE;
+
+ULONG enterKeyACC(ULONG key, void *stackFrame,
+  	          ACCELERATOR *accel)
+{
+    BYTE *verbBuffer = &workbuf[0][0];
+    register BYTE *verb, *pp, *vp;
+    register ULONG count;
+
+    if (key) {};
+    if (stackFrame) {};
+    if (accel) {};
+
+    if (!debugCommand[0])
+    {
+       count = 0;
+       pp = (BYTE *)lastDebugCommand;
+       vp = verb = &verbBuffer[0];
+       while (*pp && *pp == ' ' && count++ < 80)
+	  pp++;
+
+       while (*pp && *pp != ' ' && count++ < 80)
+	  *vp++ = *pp++;
+       *vp = '\0';
+
+       while (*pp && *pp == ' ' && count++ < 80)
+	  pp++;
+
+       UpcaseString(verb);
+       if (!strcmp(verb, "P") || (lastCommand == K_F8))
+	  strcpy((char *)debugCommand, "P");
+       else
+       if (!strcmp(verb, "T") || (lastCommand == K_F7))
+	  strcpy((char *)debugCommand, "T");
+       else
+       if (!strcmp(verb, "W")   || !strcmp(verb, "D")   ||
+	   !strcmp(verb, "DB")  || !strcmp(verb, "DW")  ||
+	   !strcmp(verb, "DD")  || !strcmp(verb, "DDS") ||
+	   !strcmp(verb, "DS")  || !strcmp(verb, "DL")  ||
+	   !strcmp(verb, "U")   || !strcmp(verb, "UU")  ||
+	   !strcmp(verb, "S")   || !strcmp(verb, "SS")  ||
+	   !strcmp(verb, "SSB") || !strcmp(verb, "ID"))
+       {
+	  strcpy((char *)debugCommand, verb);
+	  repeatCommand = TRUE;
+       }
+    }
+    return 0;   
+
+}
+
+
+ULONG displayDebuggerHelpHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("displays general help for all commands, or help for a specific command\n");
+    DBGPrint("HELP         <enter>  - list all commands\n");
+    DBGPrint("HELP command <enter>  - help for a specific command\n");
+
+    return TRUE;
+}
+
+ULONG displayDebuggerHelp(BYTE *commandLine,
+			 StackFrame *stackFrame, ULONG Exception,
+			 DEBUGGER_PARSER *parser)
+{
+
+    register ULONG count;
+    BYTE *verbBuffer = &workbuf[0][0];
+    register BYTE *verb, *pp, *vp;
+
+    if (stackFrame) {};
+    if (Exception) {};
+
+    commandLine = &commandLine[parser->debugCommandNameLength];
+    while (*commandLine && *commandLine == ' ') commandLine++;
+
+    count = 0;
+    pp = commandLine;
+    vp = verb = &verbBuffer[0];
+    while (*pp && *pp == ' ' && count++ < 80)
+       pp++;
+
+    while (*pp && *pp != ' ' && count++ < 80)
+       *vp++ = *pp++;
+    *vp = '\0';
+
+    while (*pp && *pp == ' ' && count++ < 80)
+       pp++;
+
+    DebuggerParserHelpRoutine(verb, commandLine);
+    return TRUE;
+
+}
+
+// BT, BTA, BTP
+    
+extern int bt_stack(struct task_struct *task, struct pt_regs *regs,
+	            unsigned long *stack);
+
+ULONG backTraceHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("bt <addr>                - display stack backtrace\n");
+    DBGPrint("bta                      - display stack backtrace all pids\n");
+    DBGPrint("btp <pid>                - display stack backtrace by pid\n");
+    return TRUE;
+}
+
+ULONG backTraceAllPID(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	          DEBUGGER_PARSER *parser)
+{
+    struct task_struct *p, *g;
+
+    if (cmd) {};
+    if (stackFrame) {};
+    if (Exception) {};
+    if (parser) {};
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ') cmd++;
+
+    do_each_thread(g, p) 
+    {
+       if (p)
+       {
+          DBGPrint("Stack backtrace for pid %d\n", p->pid);
+          if (bt_stack(p, NULL, NULL))
+             return TRUE;
+       }
+    } while_each_thread(g, p);
+    return TRUE;
+}
+
+ULONG backTracePID(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	          DEBUGGER_PARSER *parser)
+{
+    int pid;
+    ULONG valid = 0;
+    struct task_struct *p, *g;
+		
+    if (cmd) {};
+    if (stackFrame) {};
+    if (Exception) {};
+    if (parser) {};
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ') cmd++;
+
+    pid = EvaluateNumericExpression(stackFrame, &cmd, &valid);
+    if (valid)
+    {
+       do_each_thread(g, p) 
+       {
+          if (p && (p->pid == pid))
+          {
+             DBGPrint("Stack backtrace for pid %d\n", p->pid);
+             bt_stack(p, NULL, NULL);
+             return TRUE;
+          }
+       } while_each_thread(g, p);
+       DBGPrint("No process with pid %d found\n", pid);
+    }
+    else
+       DBGPrint("invalid pid entered for backtrace\n");
+
+    return TRUE;
+
+}
+
+ULONG backTraceStack(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	             DEBUGGER_PARSER *parser)
+{
+    ULONG valid = 0, address;
+
+    if (cmd) {};
+    if (stackFrame) {};
+    if (Exception) {};
+    if (parser) {};
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ') cmd++;
+
+    address = EvaluateExpression(stackFrame, &cmd, &valid);
+    if (valid)
+    {
+       DBGPrint("Stack backtrace for address 0x%08X\n", (unsigned)address);
+       bt_stack(NULL, NULL, (unsigned long *)address);
+       return TRUE;
+    }
+    else
+    {
+       DBGPrint("Stack backtrace for address 0x%08X\n", 
+                (unsigned)GetStackAddress(stackFrame));
+       bt_stack(NULL, NULL, (unsigned long *)GetStackAddress(stackFrame));
+       return TRUE;
+    }
+    return TRUE;
+}
+
+void DisplayASCIITable(void)
+{
+
+    register ULONG i;
+    union bhex
+    {
+       unsigned int i;
+       struct btemp {
+	     unsigned one : 1;
+	     unsigned two : 1;
+	     unsigned three : 1;
+	     unsigned four : 1;
+	     unsigned five : 1;
+	     unsigned six : 1;
+	     unsigned seven : 1;
+	     unsigned eight : 1;
+       } b;
+    } val;
+
+    DBGPrint("ASCII Table\n");
+    for (i=0; i < 256; i++)
+    {
+       val.i = i;
+       switch (i)
+       {
+
+	  case 0:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | NULL  |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six, 
+                (int)val.b.five,  (int)val.b.four, (int)val.b.three, 
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 8:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | BKSP  |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six, 
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three, 
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 9:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | TAB   |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six, 
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three, 
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 10:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | <CR>  |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six, 
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three, 
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 13:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | <LF>  |", (int)i, (unsigned)i, 
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six, 
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three, 
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 32:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | SPACE |", (int)i, (unsigned)i,
+	        (int)val.b.eight, (int)val.b.seven, (int)val.b.six, 
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three, 
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  default:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  |  %c    |", (int)i, (unsigned)i,
+	        (int)val.b.eight, (int)val.b.seven, (int)val.b.six, 
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three, 
+                (int)val.b.two, (int)val.b.one, (BYTE) i)) return;
+	     break;
+
+       }
+       if (DBGPrint("\n")) return;
+    }
+
+}
+
+#if defined(CONFIG_MODULES)
+
+// LSMOD, .M
+    
+ULONG listModulesHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint(".M                       - list loaded modules\n");
+    DBGPrint("lsmod                    - list loaded modules\n");
+    DBGPrint("rmmod <name>             - unload module\n");
+    return TRUE;
+}
+
+ULONG listModules(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	          DEBUGGER_PARSER *parser)
+{
+    if (cmd) {};
+    if (stackFrame) {};
+    if (Exception) {};
+    if (parser) {};
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ') cmd++;
+
+    if (*cmd)
+       mdb_modules(cmd, DBGPrint);
+    else
+       mdb_modules(NULL, DBGPrint);
+    return TRUE;
+}
+
+ULONG unloadModule(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	           DEBUGGER_PARSER *parser)
+{
+    if (cmd) {};
+    if (stackFrame) {};
+    if (Exception) {};
+    if (parser) {};
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ') cmd++;
+
+    DBGPrint("Module unload unsupported in this version\n");
+    return 0;
+}
+
+#endif	
+
+// REBOOT
+
+ULONG rebootSystemHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("reboot                   - reboot host system\n");
+    return TRUE;
+}
+
+
+ULONG rebootSystem(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	     DEBUGGER_PARSER *parser)
+{
+    extern void machine_restart(int);
+
+    if (cmd) {};
+    if (stackFrame) {};
+    if (Exception) {};
+    if (parser) {};
+
+    machine_restart(0);
+    return TRUE;
+}
+
+// SECTIONS, .S
+
+ULONG displaySectionsHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("sections                 - display kernel/module sections\n");
+    DBGPrint(".s                       - display kernel/module sections\n");
+    return TRUE;
+}
+
+ULONG displaySections(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     DBGPrint("\n");	
+
+     return TRUE;
+}
+
+// PS, .P
+
+ULONG displayKernelProcessHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("ps <addr>                - display kernel processes\n");
+    DBGPrint(".p <addr>                - display kernel processes\n");
+    return TRUE;
+}
+
+ULONG displayKernelProcess(BYTE *cmd,
+		           StackFrame *stackFrame, ULONG Exception,
+		           DEBUGGER_PARSER *parser)
+{
+     struct task_struct *p, *g;
+     ULONG valid = 0;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (*cmd)
+     {
+        p = (struct task_struct *)EvaluateExpression(stackFrame, &cmd, &valid);
+        if (valid && p)
+        {
+	   DBGPrint("%-*s      Pid   Parent [*] cpu State %-*s Command\n",
+	   	     (int)(2*sizeof(void *))+2, "Task Addr",
+		     (int)(2*sizeof(void *))+2, "Thread");
+
+	   if (DBGPrint("0x%p %8d %8d  %d %4d   %c  0x%p %s\n",
+	       (void *)p, p->pid, p->parent->pid,
+	       task_curr(p), p->thread_info->cpu,
+               (p->state == 0) ? 'R' :
+	       (p->state < 0) ? 'U' :
+	       (p->state & TASK_UNINTERRUPTIBLE) ? 'D' :
+	       (p->state & TASK_STOPPED) ? 'T' :
+	       (p->state & TASK_TRACED) ? 'C' :
+	       (p->exit_state & EXIT_ZOMBIE) ? 'Z' :
+	       (p->exit_state & EXIT_DEAD) ? 'E' :
+	       (p->state & TASK_INTERRUPTIBLE) ? 'S' : '?',
+	       (void *)(&p->thread),
+	        p->comm))
+                  return TRUE;
+            return TRUE;
+        }
+        DBGPrint("invalid task address\n");
+        return TRUE;
+     }
+     else
+     {
+	DBGPrint("%-*s      Pid   Parent [*] cpu State %-*s Command\n",
+		(int)(2*sizeof(void *))+2, "Task Addr",
+		(int)(2*sizeof(void *))+2, "Thread");
+
+        do_each_thread(g, p) 
+        {
+           if (p)
+           {
+	      if (DBGPrint("0x%p %8d %8d  %d %4d   %c  0x%p %s\n",
+		   (void *)p, p->pid, p->parent->pid,
+		   task_curr(p), p->thread_info->cpu,
+                   (p->state == 0) ? 'R' :
+		   (p->state < 0) ? 'U' :
+		   (p->state & TASK_UNINTERRUPTIBLE) ? 'D' :
+		   (p->state & TASK_STOPPED) ? 'T' :
+		   (p->state & TASK_TRACED) ? 'C' :
+		   (p->exit_state & EXIT_ZOMBIE) ? 'Z' :
+		   (p->exit_state & EXIT_DEAD) ? 'E' :
+		   (p->state & TASK_INTERRUPTIBLE) ? 'S' : '?',
+		   (void *)(&p->thread),
+		   p->comm))
+                 return TRUE;
+           }
+        } while_each_thread(g, p);
+     }
+     return TRUE;
+
+}
+
+ULONG ascTableHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("a                        - display ASCII Table\n");
+    return TRUE;
+}
+
+// A
+
+ULONG displayASCTable(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser)
+{
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     DisplayASCIITable();
+     return TRUE;
+
+}
+
+typedef struct _LINE_INFO 
+{
+   ULONG SourcePresent;
+   BYTE *SourceLine;
+   BYTE *ModuleName;
+   ULONG LineNumber;
+} LINE_INFO;
+
+void GetLineInfoFromValue(ULONG value, LINE_INFO *lineInfo, ULONG *exact)
+{
+    if (exact)
+       *exact = 0;
+
+    if (lineInfo)
+    { 
+        lineInfo->SourcePresent = 0;
+        lineInfo->SourceLine = "";
+        lineInfo->ModuleName = "";
+        lineInfo->LineNumber = 0;
+    }
+    return;
+}
+
+ULONG disassemble(StackFrame *stackFrame, ULONG p, ULONG count, ULONG use)
+{
+    register ULONG i;
+    BYTE *symbolName;
+    BYTE *moduleName;
+    ULONG exact = 0;
+    extern ULONG line_info_toggle;
+    LINE_INFO lineInfo;
+    register int c = get_processor_id();
+
+    for (i=0; i < count; i++)
+    {
+       GetLineInfoFromValue(p, &lineInfo, &exact);
+
+       if (line_info_toggle && exact)
+       {
+	  if (lineInfo.SourcePresent && lineInfo.SourceLine)
+	  {
+	     register ULONG length = strlen(lineInfo.SourceLine);
+
+	     i = length > 80 
+             ? i + 1 + (length / 80) 
+             : i + 1;
+
+	     DBGPrint("%s (%s : line %d)\n",
+				 lineInfo.SourceLine, lineInfo.ModuleName,
+				 lineInfo.LineNumber);
+
+	  }
+	  else if (line_info_toggle && lineInfo.LineNumber)
+	  {
+	     i++;
+	     DBGPrint("file %s  line %d\n",
+				 lineInfo.ModuleName, lineInfo.LineNumber);
+	  }
+       }
+
+       if (i >= count && count != 1)
+	  break;
+
+       symbolName = GetSymbolFromValue(p, &symbuf[c][0], MAX_SYMBOL_LEN);
+       if (symbolName)
+       {
+	  i++;
+          moduleName = GetModuleInfoFromSymbolValue(p, &modbuf[c][0], 
+                                                    MAX_SYMBOL_LEN);
+          if (moduleName)
+          {
+	     if (DBGPrint("%s|%s:\n", moduleName, symbolName)) return p;
+          }
+          else
+          {
+	     if (DBGPrint("%s:\n", symbolName)) return p;
+          }
+       }
+       if (i >= count && count != 1)
+	  break;
+
+       if (unassemble(stackFrame, p, use, &p)) return p;
+    }
+
+    return p;
+
+}
+
+ULONG dumpSearchResults(BYTE *p, ULONG count)
+{
+
+   BYTE *symbolName;
+   BYTE *moduleName;
+   register ULONG i, r, total;
+   BYTE ch;
+   register int c = get_processor_id();
+
+   if (DBGPrint("           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n"))
+      return 1;
+
+   for (r=0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((ULONG) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((ULONG) p, &modbuf[c][0], 
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+         {
+	    if (DBGPrint("%s|%s:\n", moduleName, symbolName)) return 1;
+         }
+         else  
+         {
+	    if (DBGPrint("%s:\n", symbolName)) return 1;
+         }
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (total = 0, i=0; i < 16; i++, total++)
+      {
+	 DBGPrint(" %02X", (unsigned) mdb_getword((ULONG)&p[i], 1));
+      }
+      DBGPrint("  ");
+      for (i=0; i < total; i++)
+      {
+         ch = mdb_getword((ULONG)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      if (DBGPrint("\n")) return 1;
+
+      p = (void *)((ULONG) p + (ULONG) total);
+   }
+   return 0;
+
+}
+
+BYTE *dump(BYTE *p, ULONG count)
+{
+
+   BYTE *symbolName;
+   BYTE *moduleName;
+   register ULONG i, r, total;
+   BYTE ch;
+   register int c = get_processor_id();
+
+   DBGPrint("           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n");
+
+   for (r=0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((ULONG) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((ULONG) p, &modbuf[c][0], 
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+	    DBGPrint("%s|%s:\n", moduleName, symbolName);
+         else
+	    DBGPrint("%s:\n", symbolName);
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (total = 0, i=0; i < 16; i++, total++)
+      {
+	 DBGPrint(" %02X", (unsigned) mdb_getword((ULONG)&p[i], 1));
+      }
+      DBGPrint("  ");
+      for (i=0; i < total; i++)
+      {
+         ch = mdb_getword((ULONG)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((ULONG) p + (ULONG) total);
+   }
+
+   return p;
+
+}
+
+ULONG dumpWordSearchResults(BYTE *p, ULONG count)
+{
+
+   register int i, r;
+   WORD *wp;
+   BYTE *symbolName;
+   BYTE *moduleName;
+   BYTE ch;
+   register int c = get_processor_id();
+
+   wp = (WORD *) p;
+   for (r=0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((ULONG) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((ULONG) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+         {
+	    if (DBGPrint("%s|%s:\n", moduleName, symbolName)) return 1;
+         }
+         else
+         {
+	    if (DBGPrint("%s:\n", symbolName)) return 1;
+         }
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (i=0; i < (16 / 2); i++)
+      {
+	 DBGPrint(" %04X", (unsigned) mdb_getword((ULONG)&wp[i], 2));
+      }
+      DBGPrint("  ");
+      for (i=0; i < 16; i++)
+      {
+         ch = mdb_getword((ULONG)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      if (DBGPrint("\n")) return 1;
+
+      p = (void *)((ULONG) p + (ULONG) 16);
+      wp = (WORD *) p;
+   }
+
+   return 0;
+
+}
+
+BYTE *dumpWord(BYTE *p, ULONG count)
+{
+
+   register int i, r;
+   WORD *wp;
+   BYTE *symbolName;
+   BYTE *moduleName;
+   BYTE ch;
+   register int c = get_processor_id();
+
+   wp = (WORD *) p;
+   for (r=0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((ULONG) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((ULONG) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+	    DBGPrint("%s|%s:\n", moduleName, symbolName);
+         else
+	    DBGPrint("%s:\n", symbolName);
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (i=0; i < (16 / 2); i++)
+      {
+	 DBGPrint(" %04X", (unsigned) mdb_getword((ULONG)&wp[i], 2));
+      }
+      DBGPrint("  ");
+      for (i=0; i < 16; i++)
+      {
+         ch = mdb_getword((ULONG)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((ULONG) p + (ULONG) 16);
+      wp = (WORD *) p;
+   }
+
+   return p;
+
+}
+
+ULONG dumpDoubleSearchResults(BYTE *p, ULONG count)
+{
+
+   register int i, r;
+   ULONG *lp;
+   BYTE *symbolName;
+   BYTE *moduleName;
+   BYTE ch;
+   register int c = get_processor_id();
+
+   lp = (ULONG *) p;
+
+   for (r=0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((ULONG) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((ULONG) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+         {
+	    if (DBGPrint("%s|%s:\n", moduleName, symbolName)) return 1;
+         }
+         else
+         { 
+	    if (DBGPrint("%s:\n", symbolName)) return 1;
+         }
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (i=0; i < (16 / 4); i++)
+      {
+	 DBGPrint(" %08X", (unsigned) mdb_getword((ULONG)&lp[i], 4));
+      }
+      DBGPrint("  ");
+      for (i=0; i < 16; i++)
+      {
+         ch = mdb_getword((ULONG)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      if (DBGPrint("\n")) return 1;
+
+      p = (void *)((ULONG) p + (ULONG) 16);
+      lp = (ULONG *) p;
+   }
+
+   return 0;
+
+}
+
+BYTE *dumpDouble(BYTE *p, ULONG count)
+{
+
+   register int i, r;
+   ULONG *lp;
+   BYTE *symbolName;
+   BYTE *moduleName;
+   BYTE ch;
+   register int c = get_processor_id();
+
+   lp = (ULONG *) p;
+
+   for (r=0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((ULONG) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((ULONG) p, &modbuf[c][0], 
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+	    DBGPrint("%s|%s:\n", moduleName, symbolName);
+         else
+	    DBGPrint("%s:\n", symbolName);
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (i=0; i < (16 / 4); i++)
+      {
+	 DBGPrint(" %08X", (unsigned) mdb_getword((ULONG)&lp[i], 4));
+      }
+      DBGPrint("  ");
+      for (i=0; i < 16; i++)
+      {
+         ch = mdb_getword((ULONG)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((ULONG) p + (ULONG) 16);
+      lp = (ULONG *) p;
+   }
+
+   return p;
+
+}
+
+BYTE *dumpLinkedList(BYTE *p, ULONG count, ULONG offset)
+{
+
+   register int i, r;
+   ULONG *lp;
+   BYTE ch;
+
+   lp = (ULONG *) p;
+
+   DBGPrint("           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n");
+   DBGPrint("Linked List -> [%08X + %X] = %08X\n", (unsigned)lp, 
+            (unsigned)offset, 
+            (unsigned)mdb_getword((ULONG)((ULONG)lp + (ULONG)offset), 4));
+
+   for (r=0; r < count; r++)
+   {
+      DBGPrint("%08X ", (unsigned) p);
+      for (i=0; i < 16; i++)
+      {
+	 DBGPrint(" %02X", (unsigned) mdb_getword((ULONG)&p[i], 1));
+      }
+      DBGPrint("  ");
+      for (i=0; i < 16; i++)
+      {
+         ch = mdb_getword((ULONG)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((ULONG) p + (ULONG) 16);
+   }
+
+   return (BYTE *)(mdb_getword((ULONG)((ULONG)lp + (ULONG)offset), 4));
+
+}
+
+BYTE *dumpDoubleStack(StackFrame *stackFrame, BYTE *p, ULONG count)
+{
+
+   register int i, r;
+   ULONG *lp;
+   BYTE ch;
+
+   lp = (ULONG *) p;
+
+   DBGPrint("Stack = %04lX:%08X\n", 
+            (unsigned long)GetStackSegment(stackFrame), 
+            (unsigned)p);
+
+   for (r=0; r < count; r++)
+   {
+      DBGPrint("%04X:", (unsigned) GetStackSegment(stackFrame));
+      DBGPrint("%08X ", (unsigned) p);
+      for (i=0; i < (16 / 4); i++)
+      {
+	 DBGPrint(" %08X", (unsigned) mdb_getword((ULONG)&lp[i], 4));
+      }
+      DBGPrint("  ");
+      for (i=0; i < 16; i++)
+      {
+         ch = mdb_getword((ULONG)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((ULONG) p + (ULONG) 16);
+      lp = (ULONG *) p;
+   }
+
+   return p;
+
+}
+
+BYTE *dumpStack(StackFrame *stackFrame, BYTE *p, ULONG count)
+{
+
+   register int r;
+   ULONG *lp;
+
+   lp = (ULONG *) p;
+
+   DBGPrint("Stack = %04X:%08X\n", (unsigned)GetStackSegment(stackFrame), 
+            (unsigned)p);
+
+   for (r=0; r < count; r++)
+   {
+      DBGPrint("%08X ", (unsigned) p);
+      DBGPrint("%08X ", (unsigned) mdb_getword((ULONG)lp, 4));
+      if (DisplayClosestSymbol(mdb_getword((ULONG)lp, 4)))
+         DBGPrint("\n");
+
+      p = (void *)((ULONG) p + (ULONG) 4);
+      lp = (ULONG *) p;
+   }
+
+   return p;
+
+}
+
+ULONG displayToggleHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint(".tc                      - toggles control registers (ON | OFF)\n");
+    DBGPrint(".tn                      - toggles coprocessor registers (ON | OFF)\n");
+    DBGPrint(".ts                      - toggles segment registers (ON | OFF)\n");
+    DBGPrint(".tg                      - toggles general registers (ON | OFF)\n");
+    DBGPrint(".tr                      - toggles display of break reason (ON | OFF)\n");
+    DBGPrint(".td                      - toggles full dereference display (ON | OFF)\n");
+    DBGPrint(".tl                      - toggles source line display (ON | OFF)\n");
+    DBGPrint(".tu                      - toggles unasm debug display (ON | OFF)\n");
+    DBGPrint(".t or .t <address>       - display task state segment (tss)\n");
+    return TRUE;
+}
+
+// .TU
+
+ULONG ProcessTUToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     (debug_deref)
+     ? (debug_deref = 0)
+     : (debug_deref = 1);
+     DBGPrint("toggle unasm debug display (%s)\n",
+				  debug_deref ? "ON" : "OFF");
+     return TRUE;
+}
+
+// .TD
+
+ULONG ProcessTDToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     (full_deref_toggle)
+     ? (full_deref_toggle = 0)
+     : (full_deref_toggle = 1);
+     DBGPrint("toggle full dereferencing info (%s) \n",
+					    full_deref_toggle ? "ON" : "OFF");
+     return TRUE;
+}
+
+
+// .TL
+
+ULONG ProcessTLToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     (line_info_toggle)
+     ? (line_info_toggle = 0)
+     : (line_info_toggle = 1);
+     DBGPrint("toggle source line info (%s) \n",
+					    line_info_toggle ? "ON" : "OFF");
+     return TRUE;
+
+}
+
+// .TG
+
+ULONG ProcessTGToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     (general_toggle)
+     ? (general_toggle = 0)
+     : (general_toggle = 1);
+     DBGPrint("toggle general registers (%s) \n",
+					    general_toggle ? "ON" : "OFF");
+     return TRUE;
+
+}
+
+// .TC
+
+ULONG ProcessTCToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     (control_toggle)
+     ? (control_toggle = 0)
+     : (control_toggle = 1);
+     DBGPrint("toggle control registers (%s) \n",
+					    control_toggle ? "ON" : "OFF");
+     return TRUE;
+
+}
+
+// .TN
+
+ULONG ProcessTNToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     (numeric_toggle)
+     ? (numeric_toggle = 0)
+     : (numeric_toggle = 1);
+     DBGPrint("toggle coprocessor registers (%s) \n",
+					    numeric_toggle ? "ON" : "OFF");
+     return TRUE;
+
+}
+
+// .TR
+
+ULONG ProcessTRToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     (reason_toggle)
+     ? (reason_toggle = 0)
+     : (reason_toggle = 1);
+     DBGPrint("toggle display break reason (%s) \n",
+					    reason_toggle ? "ON" : "OFF");
+     return TRUE;
+
+}
+
+// .TS
+
+ULONG ProcessTSToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     (segment_toggle)
+     ? (segment_toggle = 0)
+     : (segment_toggle = 1);
+     DBGPrint("toggle segment registers (%s) \n",
+					    segment_toggle ? "ON" : "OFF");
+     return TRUE;
+
+}
+
+ULONG displayDebuggerVersionHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint(".v                       - display version info\n");
+    return TRUE;
+}
+
+// .V
+
+ULONG DisplayDebuggerVersion(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     extern ULONG MajorVersion;
+     extern ULONG MinorVersion;
+     extern ULONG BuildVersion;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     DBGPrint("Merkey's Kernel Debugger\n");
+     DBGPrint("v%02d.%02d.%02d\n", 
+              (int)MajorVersion, (int)MinorVersion, (int)BuildVersion);
+     DBGPrint("Copyright (C) 2008 Jeffrey Vernon Merkey.  "
+              "All Rights Reserved.\n");
+
+     return TRUE;
+}
+
+// .Z
+
+ULONG displaySymbolsHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint(".z <name>                  - display symbol info\n");
+    return TRUE;
+}
+
+ULONG displaySymbols(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     extern void DumpOSSymbolTableMatch(BYTE *);
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (*cmd)
+	DumpOSSymbolTableMatch(cmd);
+     else
+	DumpOSSymbolTableMatch(NULL);
+
+     return TRUE;
+}
+
+// LCPU
+
+ULONG listProcessors(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register int i;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     DBGPrint("Current Processor: %d\n", smp_processor_id());
+     DBGPrint("Active Processors: \n");
+     for (i=0; i < MAX_PROCESSORS; i++) 
+     {
+        if (cpu_online(i)) 
+	   DBGPrint("   Processor %d\n", i);
+     }
+     return TRUE;
+
+}
+
+ULONG clearScreenHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("cls                      - clear the screen\n");
+    return TRUE;
+}
+
+// CLS
+
+ULONG clearDebuggerScreen(BYTE *cmd,
+			 StackFrame *stackFrame, ULONG Exception,
+			 DEBUGGER_PARSER *parser)
+{
+     extern void ClearScreen(void);
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     ClearScreen();
+     return TRUE;
+
+}
+
+ULONG SearchMemoryHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("sb                       - search for bytes at address\n");
+    DBGPrint("sw                       - search for words at address\n");
+    DBGPrint("sd                       - search for dwords at address\n");
+    return TRUE;
+}
+
+// S
+
+// use local storage and reduce stack space use.  these functions are always
+// called single threaded from the console
+
+BYTE s_changeBuffer[16];
+BYTE b_searchBuffer[16];
+BYTE b_copyBuffer[16];
+WORD w_searchBuffer[16];
+WORD w_copyBuffer[16];
+ULONG d_searchBuffer[16];
+ULONG d_copyBuffer[16];
+
+ULONG SearchMemory(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     BYTE *changeBuffer = s_changeBuffer;
+     BYTE *searchBuffer = b_searchBuffer;
+     BYTE *copyBuffer = b_copyBuffer;
+     ULONG maxlen = sizeof(searchBuffer);
+     register BYTE *changeB;
+     BYTE *pB;
+     register ULONG address, r, value, count, len, i;
+     ULONG valid, EndingAddress = (ULONG)high_memory;
+     register int key;
+     extern int mdb_getkey(void);
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     memset((ULONG *)searchBuffer, 0, sizeof(searchBuffer));
+     count = 0;
+     changeB = (BYTE *) searchBuffer;
+     changeBuffer[0] = '\0';
+     DBGPrint("enter bytes to search for, '.' to end input\n");
+     while ((changeBuffer[0] != '.') && (count < maxlen))
+     {
+	for (r=0; r < 8; r++)
+	{
+	   DBGPrint("0x");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 4);
+
+	   if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.'))
+	      break;
+
+	   pB = (BYTE *) &changeBuffer[0];
+	   len = strlen(pB);
+
+	   for (i=0; i < len; i++)
+	      DBGPrint("\b");
+
+	   value = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      *changeB = (BYTE) value;
+	   DBGPrint("%02X ", (BYTE) *changeB);
+
+	   changeB++;
+	   if (count++ > maxlen)
+	      break;
+	}
+	if (DBGPrint("\n")) return TRUE;
+     }
+
+     if (count)
+     {
+	DBGPrint("enter start address for search:  ");
+	ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	pB = (BYTE *) &changeBuffer[0];
+	address = EvaluateExpression(0, &pB, &valid);
+	if (valid)
+	{
+	   register ULONG temp;
+
+	   DBGPrint("start address = [%08X]\n", (unsigned)address);
+	   DBGPrint("enter ending address for search:  ");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	   pB = (BYTE *) &changeBuffer[0];
+	   temp = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      EndingAddress = temp;
+
+	   DBGPrint("\nsearching memory from 0x%08X to 0x%08X\n",
+                    (unsigned)address, (unsigned)EndingAddress);
+	   while (address < EndingAddress)
+	   {
+              read_memory((void *)address, copyBuffer, count);
+	      if (!memcmp(searchBuffer, copyBuffer, count))
+	      {
+		 if (DBGPrint("match at address [%08X]\n", 
+                     (unsigned)address)) return TRUE;
+		 if (dumpSearchResults((BYTE *)address, 4)) return TRUE;
+		 if (DBGPrint("searching\n")) return TRUE;
+	      }
+	      address++;
+	      if (!(address % 0x100000))
+	      {
+		  if (DBGPrint("searching memory at address 0x%08X ..."
+                        " Q or q to abort - any key to proceed\n",
+                                (unsigned)address)) return TRUE;
+                  key = mdb_getkey();
+                  if (((char)key == 'Q') || ((char)key == 'q'))
+                     break;
+	      }
+	   }
+	   if (DBGPrint("search completed.\n")) return TRUE;
+	   return TRUE;
+	}
+	if (DBGPrint("invalid start address\n")) return TRUE;
+	return TRUE;
+     }
+     if (DBGPrint("no search pattern\n")) return TRUE;
+     return TRUE;
+
+}
+
+// SB
+
+ULONG SearchMemoryB(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     BYTE *changeBuffer = s_changeBuffer;
+     BYTE *searchBuffer = b_searchBuffer;
+     BYTE *copyBuffer = b_copyBuffer;
+     ULONG maxlen = sizeof(searchBuffer);
+     register BYTE *changeB;
+     BYTE *pB;
+     register ULONG address, r, value, count, len, i;
+     ULONG valid, EndingAddress = (ULONG)high_memory;
+     register int key;
+     extern int mdb_getkey(void);
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     memset((ULONG *)searchBuffer, 0, sizeof(searchBuffer));
+     count = 0;
+     changeB = (BYTE *) searchBuffer;
+     changeBuffer[0] = '\0';
+     DBGPrint("enter bytes to search for, '.' to end input\n");
+     while (changeBuffer[0] != '.' && count < maxlen)
+     {
+	for (r=0; r < 8; r++)
+	{
+	   DBGPrint("0x");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 4);
+
+	   if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.'))
+	      break;
+
+	   pB = (BYTE *) &changeBuffer[0];
+	   len = strlen(pB);
+	   for (i=0; i < len; i++)
+	      DBGPrint("\b");
+
+	   value = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      *changeB = (BYTE) value;
+	   DBGPrint("%02X ", (BYTE) *changeB);
+
+	   changeB++;
+	   if (count++ > maxlen)
+	      break;
+	}
+	if (DBGPrint("\n")) return TRUE;
+     }
+
+     if (count)
+     {
+	DBGPrint("enter start address for search:  ");
+	ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	pB = (BYTE *) &changeBuffer[0];
+	address = EvaluateExpression(0, &pB, &valid);
+	if (valid)
+	{
+	   register ULONG temp;
+
+	   DBGPrint("start address = [%08X]\n", (unsigned)address);
+
+	   DBGPrint("enter ending address for search:  ");
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	   pB = (BYTE *) &changeBuffer[0];
+	   temp = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      EndingAddress = temp;
+
+	   DBGPrint("\nsearching memory from 0x%08X to 0x%08X\n",
+                    (unsigned)address, (unsigned)EndingAddress);
+	   while (address < EndingAddress)
+	   {
+              read_memory((void *)address, copyBuffer, count);
+	      if (!memcmp(searchBuffer, copyBuffer, count))
+	      {
+		 if (DBGPrint("match at address [%08X]\n", 
+                     (unsigned)address)) return TRUE;
+		 if (dumpSearchResults((BYTE *)address, 4)) return TRUE;
+		 if (DBGPrint("searching\n")) return TRUE;
+	      }
+	      address++;
+	      if (!(address % 0x100000))
+	      {
+		 if (DBGPrint("searching memory at address 0x%08X ..."
+                        " Q or q to abort - any key to proceed\n",
+                              (unsigned)address)) return TRUE;
+                 key = mdb_getkey();
+                 if (((char)key == 'Q') || ((char)key == 'q'))
+                    break;
+	      }
+	   }
+	   if (DBGPrint("search completed.\n")) return TRUE;
+	   return TRUE;
+	}
+	if (DBGPrint("invalid start address\n")) return TRUE;
+	return TRUE;
+     }
+     if (DBGPrint("no search pattern\n")) return TRUE;
+     return TRUE;
+}
+
+// SW
+
+ULONG SearchMemoryW(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     BYTE *changeBuffer = s_changeBuffer;
+     WORD *searchBuffer = w_searchBuffer;
+     WORD *copyBuffer = w_copyBuffer;
+     ULONG maxlen = sizeof(searchBuffer) / sizeof(WORD);
+     register WORD *changeW;
+     BYTE *pB;
+     register ULONG address, r, value, count, len, i;
+     ULONG valid, EndingAddress = (ULONG)high_memory;
+     register int key;
+     extern int mdb_getkey(void);
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     memset((ULONG *)searchBuffer, 0, sizeof(searchBuffer));
+     count = 0;
+     changeW = (WORD *) searchBuffer;
+     changeBuffer[0] = '\0';
+     DBGPrint("enter words to search for, '.' to end input\n");
+     while (changeBuffer[0] != '.' && count < maxlen)
+     {
+	for (r=0; r < 4; r++)
+	{
+	   DBGPrint("0x");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 6);
+
+	   if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.') ||
+	       (changeBuffer[2] == '.') || (changeBuffer[3] == '.'))
+	      break;
+
+	   pB = (BYTE *) &changeBuffer[0];
+	   len = strlen(pB);
+	   for (i=0; i < len; i++)
+	      DBGPrint("\b");
+
+	   value = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      *changeW = value;
+	   DBGPrint("%04X ", *changeW);
+
+	   changeW++;
+	   if (count++ > maxlen)
+	      break;
+	}
+	if (DBGPrint("\n")) return TRUE;
+     }
+
+     if (count)
+     {
+	DBGPrint("enter start address for search:  ");
+	ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	pB = (BYTE *) &changeBuffer[0];
+	address = EvaluateExpression(0, &pB, &valid);
+	if (valid)
+	{
+	   register ULONG temp;
+
+	   DBGPrint("start address = [%08X]\n", (unsigned)address);
+
+	   DBGPrint("enter ending address for search:  ");
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	   pB = (BYTE *) &changeBuffer[0];
+	   temp = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      EndingAddress = temp;
+
+	   DBGPrint("searching memory from 0x%08X to 0x%08X\n",
+                    (unsigned)address, (unsigned)EndingAddress);
+	   while (address < EndingAddress)
+	   {
+              read_memory((void *)address, copyBuffer, count * sizeof(WORD));
+	      if (!memcmp(searchBuffer, copyBuffer, count * sizeof(WORD)))
+	      {
+		 if (DBGPrint("match at address [%08X]\n", 
+                     (unsigned)address)) return TRUE;
+		 if (dumpWordSearchResults((BYTE *)address, 4)) 
+                     return TRUE;
+		 if (DBGPrint("searching\n")) return TRUE;;
+	      }
+	      address++;
+	      if (!(address % 0x100000))
+	      {
+		 if (DBGPrint("searching memory at address 0x%08X ..."
+                        " Q or q to abort - any key to proceed\n",
+                              (unsigned)address)) return TRUE;
+                  key = mdb_getkey();
+                  if (((char)key == 'Q') || ((char)key == 'q'))
+                     break;
+	      }
+	   }
+	   if (DBGPrint("search completed.\n")) return TRUE;
+	   return TRUE;
+	}
+	if (DBGPrint("invalid start address\n")) return TRUE;
+	return TRUE;
+     }
+     if (DBGPrint("no search pattern\n")) return TRUE;
+     return TRUE;
+}
+
+// SD
+
+ULONG SearchMemoryD(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register BYTE *changeBuffer = s_changeBuffer;
+     register ULONG *searchBuffer = d_searchBuffer;
+     register ULONG *copyBuffer = d_copyBuffer;
+     register ULONG maxlen = sizeof(searchBuffer) / sizeof(ULONG);
+     register ULONG *changeD;
+     BYTE *pB;
+     register ULONG address, r, value, count, len, i;
+     ULONG valid, EndingAddress = (ULONG)high_memory;
+     register int key;
+     extern int mdb_getkey(void);
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     memset((ULONG *)searchBuffer, 0, sizeof(searchBuffer));
+     count = 0;
+     changeD = (ULONG *) searchBuffer;
+     changeBuffer[0] = '\0';
+     DBGPrint("enter dwords to search for, '.' to end input\n");
+     while (changeBuffer[0] != '.' && count < maxlen)
+     {
+	for (r=0; r < 2; r++)
+	{
+	   DBGPrint("0x");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 8);
+
+	   if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.') ||
+	       (changeBuffer[2] == '.') || (changeBuffer[3] == '.') ||
+	       (changeBuffer[4] == '.') || (changeBuffer[5] == '.') ||
+	       (changeBuffer[6] == '.') || (changeBuffer[7] == '.'))
+	      break;
+
+	   pB = (BYTE *) &changeBuffer[0];
+	   len = strlen(pB);
+	   for (i=0; i < len; i++)
+	      DBGPrint("\b");
+
+	   value = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      *changeD = value;
+	   DBGPrint("%08X ", (unsigned)*changeD);
+
+	   changeD++;
+	   if (count++ > maxlen)
+	      break;
+	}
+	if (DBGPrint("\n")) return TRUE;
+     }
+
+     if (count)
+     {
+	DBGPrint("enter start address for search:  ");
+	ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	pB = (BYTE *) &changeBuffer[0];
+	address = EvaluateExpression(0, &pB, &valid);
+	if (valid)
+	{
+	   register ULONG temp;
+
+	   DBGPrint("start address = [%08X]\n", (unsigned)address);
+
+	   DBGPrint("enter ending address for search:  ");
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	   pB = (BYTE *) &changeBuffer[0];
+	   temp = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      EndingAddress = temp;
+
+	   DBGPrint("searching memory from 0x%08X to 0x%08X\n",
+                    (unsigned)address, (unsigned)EndingAddress);
+	   while (address < EndingAddress)
+	   {
+              read_memory((void *)address, copyBuffer, count * sizeof(ULONG));
+	      if (!memcmp(searchBuffer, copyBuffer, count * sizeof(ULONG)))
+	      {
+		 if (DBGPrint("match at address [%08X]\n", 
+                     (unsigned)address)) return TRUE;
+		 if (dumpDoubleSearchResults((BYTE *)address, 4)) 
+                     return TRUE;
+		 if (DBGPrint("searching\n")) return TRUE;
+	      }
+	      address++;
+	      if (!(address % 0x100000))
+	      {
+		 if (DBGPrint("searching memory at address 0x%08X ..."
+                        " Q or q to abort - any key to proceed\n",
+                              (unsigned)address)) return TRUE;
+                  key = mdb_getkey();
+                  if (((char)key == 'Q') || ((char)key == 'q'))
+                     break;
+	      }
+	   }
+	   if (DBGPrint("search completed.\n")) return TRUE;
+	   return TRUE;
+	}
+	if (DBGPrint("invalid start address\n")) return TRUE;
+	return TRUE;
+     }
+     if (DBGPrint("no search pattern\n")) return TRUE;
+     return TRUE;
+}
+
+
+ULONG changeMemoryHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("c   <address>            - change bytes at address\n");
+    DBGPrint("cb  <address>            - change bytes at address\n");
+    DBGPrint("cw  <address>            - change words at address\n");
+    DBGPrint("cd  <address>            - change dwords at address\n");
+    return TRUE;
+}
+
+// CW
+
+ULONG changeWordValue(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register BYTE *changeBuffer = &workbuf[0][0];
+     register WORD *changeW, oldW;
+     BYTE *pB;
+     register ULONG address, r, value, len, i;
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	changeW = (WORD *) address;
+	changeBuffer[0] = '\0';
+	DBGPrint("enter new value, <enter> to skip, or '.' to exit\n");
+	while (changeBuffer[0] != '.')
+	{
+	   DBGPrint("[%08X] ", (unsigned)changeW);
+	   for (r=0; r < 4; r++)
+	   {
+	      oldW = (WORD) mdb_getword((ULONG)changeW, 2);
+	      DBGPrint("(%04X)=", (unsigned) oldW);
+
+              ScreenInputFromKeyboard(&changeBuffer[0], 0, 6);
+
+	      if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.') ||
+		  (changeBuffer[2] == '.') || (changeBuffer[3] == '.'))
+		 break;
+	      pB = (BYTE *) &changeBuffer[0];
+	      len = strlen(pB);
+
+	      for (i=0; i < len; i++)
+		 DBGPrint("\b");
+
+	      value = EvaluateExpression(0, &pB, &valid);
+	      if (valid)
+		 mdb_putword((ULONG)changeW, value, 2);
+	      DBGPrint("%04X ", (unsigned) mdb_getword((ULONG)changeW, 2));
+	      changeW++;
+	   }
+	   if (DBGPrint("\n")) return TRUE;
+	}
+	return TRUE;
+     }
+     DBGPrint("invalid change (word) address\n");
+     return TRUE;
+}
+
+// CD
+
+ULONG changeDoubleValue(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register BYTE *changeBuffer = &workbuf[0][0];
+     register ULONG *changeD, oldD;
+     register ULONG address, r, value, len, i;
+     BYTE *pB;
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	changeD = (ULONG *) address;
+	changeBuffer[0] = '\0';
+	DBGPrint("enter new value, <enter> to skip, or '.' to exit\n");
+	while (changeBuffer[0] != '.')
+	{
+	   DBGPrint("[%08X] ", (unsigned)changeD);
+	   for (r=0; r < 2; r++)
+	   {
+	      oldD = (ULONG) mdb_getword((ULONG)changeD, 4);
+	      DBGPrint("(%08X)=", (unsigned) oldD);
+
+	      ScreenInputFromKeyboard(&changeBuffer[0], 0, 8);
+
+	      if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.') ||
+		  (changeBuffer[2] == '.') || (changeBuffer[3] == '.') ||
+		  (changeBuffer[4] == '.') || (changeBuffer[5] == '.') ||
+		  (changeBuffer[6] == '.') || (changeBuffer[7] == '.'))
+		 break;
+
+	      pB = (BYTE *) &changeBuffer[0];
+	      len = strlen(pB);
+
+	      for (i=0; i < len; i++)
+		 DBGPrint("\b");
+
+	      value = EvaluateExpression(0, &pB, &valid);
+	      if (valid)
+		 mdb_putword((ULONG)changeD, value, 4);
+	      DBGPrint("%08X ", (unsigned)mdb_getword((ULONG)changeD, 4));
+	      changeD++;
+	   }
+	   if (DBGPrint("\n")) return TRUE;
+	}
+	return TRUE;
+     }
+     DBGPrint("invalid change (dword) address\n");
+     return TRUE;
+}
+
+// CB
+
+ULONG changeByteValue(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     BYTE *changeBuffer = &workbuf[0][0];
+     register BYTE *changeB, oldB;
+     BYTE *pB;
+     register ULONG address, r, value, len, i;
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	changeB = (BYTE *) address;
+	changeBuffer[0] = '\0';
+	DBGPrint("enter new value, <enter> to skip, or '.' to exit\n");
+	while (changeBuffer[0] != '.')
+	{
+	   DBGPrint("[%08X] ", (unsigned)changeB);
+	   for (r=0; r < 8; r++)
+	   {
+	      oldB = (BYTE) mdb_getword((ULONG)changeB, 1);
+	      DBGPrint("(%02X)=", (unsigned) oldB);
+
+	      ScreenInputFromKeyboard(&changeBuffer[0], 0, 4);
+
+	      if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.'))
+		 break;
+
+	      pB = (BYTE *) &changeBuffer[0];
+	      len = strlen(pB);
+	      for (i=0; i < len; i++)
+		 DBGPrint("\b");
+
+	      value = EvaluateExpression(0, &pB, &valid);
+	      if (valid)
+		 mdb_putword((ULONG)changeB, value, 1);
+	      DBGPrint("%02X ", (BYTE) mdb_getword((ULONG)changeB, 1));
+	      changeB++;
+	   }
+	   if (DBGPrint("\n")) return TRUE;
+	}
+	return TRUE;
+     }
+     DBGPrint("invalid change (byte) address\n");
+     return TRUE;
+}
+
+// C
+
+ULONG changeDefaultValue(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser)
+{
+     BYTE *changeBuffer = &workbuf[0][0];
+     register BYTE *changeB, oldB;
+     BYTE *pB;
+     register ULONG address, r, value, len, i;
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	changeB = (BYTE *) address;
+	changeBuffer[0] = '\0';
+	DBGPrint("enter new value, <enter> to skip, or '.' to exit\n");
+	while (changeBuffer[0] != '.')
+	{
+	   DBGPrint("[%08X] ", (unsigned)changeB);
+	   for (r=0; r < 8; r++)
+	   {
+	      oldB = (BYTE) mdb_getword((ULONG)changeB, 1);
+	      DBGPrint("(%02X)=", (BYTE) oldB);
+
+	      ScreenInputFromKeyboard(&changeBuffer[0], 0, 4);
+
+	      if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.'))
+		 break;
+
+	      pB = (BYTE *) &changeBuffer[0];
+	      len = strlen(pB);
+
+	      for (i=0; i < len; i++)
+		 DBGPrint("\b");
+
+	      value = EvaluateExpression(0, &pB, &valid);
+	      if (valid)
+		 mdb_putword((ULONG)changeB, value, 1);
+	      DBGPrint("%02X ", (BYTE) mdb_getword((ULONG)changeB, 1));
+	      changeB++;
+	   }
+	   if (DBGPrint("\n")) return TRUE;
+	}
+	return TRUE;
+     }
+     DBGPrint("invalid change (byte) address\n");
+     return TRUE;
+
+}
+
+ULONG displayCloseHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("?   <address>            - display closest symbols to <address>\n");
+    return TRUE;
+
+}
+
+// ?
+
+ULONG displayCloseSymbols(BYTE *cmd,
+			 StackFrame *stackFrame, ULONG Exception,
+			 DEBUGGER_PARSER *parser)
+{
+     register ULONG oldD;
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     oldD = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	oldD = GetIP(stackFrame);
+     DisplayClosestSymbol(oldD);
+     return TRUE;
+
+}
+
+ULONG debuggerWalkStack(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpStack(stackFrame, 
+                          (BYTE *)lastDumpAddress, lastDisplayLength);
+	return TRUE;
+     }
+     lastDumpAddress = (BYTE *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (BYTE *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpStack(stackFrame, (BYTE *)lastDumpAddress, displayLength);
+     return TRUE;
+
+}
+
+ULONG displayDumpHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("d   <address> <#lines>   - dump memory as bytes\n");
+    DBGPrint("dw  <address> <#lines>   - dump memory as words\n");
+    DBGPrint("dd  <address> <#lines>   - dump memory as double words\n");
+    DBGPrint("dl  <address> <#lines>   - dump linked list\n");
+    DBGPrint("ds  <address> <#lines>   - dump stack\n");
+    DBGPrint("dds <address> <#lines>   - dump stack double word\n");
+    DBGPrint("w   <address>            - display symbols on the stack\n");
+
+    return TRUE;
+}
+
+// DL
+
+ULONG debuggerDumpLinkedList(BYTE *cmd,
+			    StackFrame *stackFrame, ULONG Exception,
+			    DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     extern volatile BYTE *lastLinkAddress;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastLinkAddress = dumpLinkedList((BYTE *)lastLinkAddress, lastDisplayLength, 0);
+	return TRUE;
+     }
+
+     lastLinkAddress = (BYTE *) EvaluateNumericExpression(stackFrame, &cmd, 
+                                                          &valid);
+     if (!valid)
+	lastLinkAddress = (BYTE *) GetStackAddress(stackFrame);
+
+     displayLength = EvaluateNumericExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+
+     lastLinkAddress = dumpLinkedList((BYTE *)lastLinkAddress, displayLength, 0);
+
+     return TRUE;
+
+}
+
+// DW
+
+ULONG debuggerDumpWord(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpWord((BYTE *)lastDumpAddress, lastDisplayLength);
+	return TRUE;
+     }
+     lastDumpAddress = (BYTE *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (BYTE *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpWord((BYTE *)lastDumpAddress, displayLength);
+     return TRUE;
+}
+
+// DS
+
+ULONG debuggerDumpStack(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpStack(stackFrame, (BYTE *)lastDumpAddress, lastDisplayLength);
+	return TRUE;
+     }
+     lastDumpAddress = (BYTE *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (BYTE *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpStack(stackFrame, (BYTE *)lastDumpAddress, displayLength);
+     return TRUE;
+
+}
+
+// DDS
+
+ULONG debuggerDumpDoubleStack(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpDoubleStack(stackFrame, (BYTE *)lastDumpAddress,
+						    lastDisplayLength);
+	return TRUE;
+     }
+     lastDumpAddress = (BYTE *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (BYTE *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpDoubleStack(stackFrame, (BYTE *)lastDumpAddress,
+						    displayLength);
+     return TRUE;
+
+}
+
+// DD
+
+ULONG debuggerDumpDouble(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpDouble((BYTE *)lastDumpAddress, lastDisplayLength);
+	return TRUE;
+     }
+     lastDumpAddress = (BYTE *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (BYTE *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpDouble((BYTE *)lastDumpAddress, displayLength);
+     return TRUE;
+
+}
+
+// D
+
+ULONG debuggerDumpByte(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dump((BYTE *)lastDumpAddress, lastDisplayLength);
+	return TRUE;
+     }
+     lastDumpAddress = (BYTE *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (BYTE *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dump((BYTE *)lastDumpAddress, displayLength);
+     return TRUE;
+
+}
+
+ULONG displayDisassembleHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("id  <address> <#lines>   - unassemble code (32-bit)\n");
+    DBGPrint("u   <address> <#lines>   - unassemble code (32-bit)\n");
+    DBGPrint("uu  <address> <#lines>   - unassemble code (16-bit)\n");
+    return TRUE;
+}
+
+// UU
+
+ULONG processDisassemble16(BYTE *cmd,
+			  StackFrame *stackFrame, ULONG Exception,
+			  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastUnasmAddress = disassemble(stackFrame, (ULONG)lastUnasmAddress,
+						    lastDisplayLength, 0);
+	return TRUE;
+     }
+     lastUnasmAddress = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+     {
+        if (!*cmd)
+	   lastUnasmAddress = GetIP(stackFrame);
+        else
+        {
+           DBGPrint("invalid address for unassemble\n");
+           return TRUE;
+        }
+     }
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+		     displayLength = 20;
+     lastUnasmAddress = disassemble(stackFrame, (ULONG)lastUnasmAddress,
+						 displayLength, 0);
+     return TRUE;
+}
+
+// U
+
+ULONG processDisassemble32(BYTE *cmd,
+			  StackFrame *stackFrame, ULONG Exception,
+			  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (repeatCommand)
+     {
+	lastUnasmAddress = disassemble(stackFrame, (ULONG)lastUnasmAddress,
+				       lastDisplayLength, 1);
+	return TRUE;
+     }
+     lastUnasmAddress = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+     {
+        if (!*cmd)
+	   lastUnasmAddress = GetIP(stackFrame);
+        else
+        {
+           DBGPrint("invalid address for unassemble\n");
+           return TRUE;
+        }
+     }
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastUnasmAddress = disassemble(stackFrame, (ULONG)lastUnasmAddress,
+						 displayLength, 1);
+     return TRUE;
+
+}
+
+#endif
diff -Naur ./debug/mdb-base.h ../linux-2.6.18-mdb/./debug/mdb-base.h
--- ./debug/mdb-base.h	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-base.h	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,289 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-BASE.H
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#ifndef _MDB_BASE_H
+#define _MDB_BASE_H
+
+extern ULONG enterKeyACC(ULONG key, void *stackFrame,
+		     ACCELERATOR *accel);
+extern ULONG activateRegisterDisplayACC(ULONG key, void *stackFrame,
+		     ACCELERATOR *accel);
+
+extern ULONG displayDebuggerHelpHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayDebuggerHelp(BYTE *commandLine,
+			 StackFrame *stackFrame, ULONG Exception,
+			 DEBUGGER_PARSER *parser);
+
+extern ULONG ascTableHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayASCTable(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+
+extern ULONG displayToggleHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ProcessTUToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG ProcessTDToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG ProcessTLToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG ProcessTGToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG ProcessTCToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG ProcessTNToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG ProcessTRToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG ProcessTSToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG ProcessTAToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern ULONG displayDebuggerVersionHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG DisplayDebuggerVersion(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern ULONG displayKernelProcessHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayKernelProcess(BYTE *cmd,
+			  StackFrame *stackFrame, ULONG Exception,
+			  DEBUGGER_PARSER *parser);
+
+extern ULONG displayKernelQueueHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayKernelQueue(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser);
+
+extern ULONG displaySymbolsHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displaySymbols(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser);
+
+extern ULONG displayLoaderMapHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayLoaderMap(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern ULONG displayModuleHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayModuleInfo(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayProcessesHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayProcesses(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern ULONG displayRegistersHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayControlRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser);
+extern ULONG displayAllRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser);
+extern ULONG displaySegmentRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser);
+extern ULONG displayNumericRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser);
+extern ULONG displayGeneralRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser);
+extern ULONG displayDefaultRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser);
+
+extern ULONG displayAPICHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayAPICInfo(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+
+extern ULONG listProcessors(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser);
+extern ULONG listProcessorFrame(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser);
+
+extern ULONG ReasonHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ReasonDisplay(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern ULONG displayMPSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayMPS(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern ULONG clearScreenHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG clearDebuggerScreen(BYTE *cmd,
+			 StackFrame *stackFrame, ULONG Exception,
+			 DEBUGGER_PARSER *parser);
+
+
+extern ULONG SearchMemoryHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG SearchMemory(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+extern ULONG SearchMemoryB(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+extern ULONG SearchMemoryW(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+extern ULONG SearchMemoryD(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern ULONG changeMemoryHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG changeWordValue(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+extern ULONG changeDoubleValue(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+extern ULONG changeByteValue(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+extern ULONG changeDefaultValue(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser);
+
+
+extern ULONG displayCloseHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayCloseSymbols(BYTE *cmd,
+			 StackFrame *stackFrame, ULONG Exception,
+			 DEBUGGER_PARSER *parser);
+
+
+extern ULONG displayINTRHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayInterruptTable(BYTE *cmd,
+			   StackFrame *stackFrame, ULONG Exception,
+			   DEBUGGER_PARSER *parser);
+
+
+extern ULONG viewScreensHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayScreenList(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+
+extern ULONG displayIOAPICHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayIOAPICInfo(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+
+
+extern ULONG displayDumpHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG debuggerWalkStack(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+extern ULONG debuggerDumpLinkedList(BYTE *cmd,
+			    StackFrame *stackFrame, ULONG Exception,
+			    DEBUGGER_PARSER *parser);
+extern ULONG debuggerDumpWord(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+extern ULONG debuggerDumpStack(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+extern ULONG debuggerDumpDoubleStack(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser);
+extern ULONG debuggerDumpDouble(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser);
+extern ULONG debuggerDumpByte(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+
+extern ULONG displayDisassembleHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG processDisassemble16(BYTE *cmd,
+			  StackFrame *stackFrame, ULONG Exception,
+			  DEBUGGER_PARSER *parser);
+extern ULONG processDisassemble32(BYTE *cmd,
+			  StackFrame *stackFrame, ULONG Exception,
+			  DEBUGGER_PARSER *parser);
+
+extern ULONG rebootSystemHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG rebootSystem(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	                  DEBUGGER_PARSER *parser);
+
+extern ULONG displaySectionsHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displaySections(BYTE *cmd,
+		             StackFrame *stackFrame, ULONG Exception,
+		             DEBUGGER_PARSER *parser);
+extern ULONG displayKernelProcessHelp(BYTE *commandLine, 
+                                      DEBUGGER_PARSER *parser);
+extern ULONG displayKernelProcess(BYTE *cmd,
+		                  StackFrame *stackFrame, ULONG Exception,
+		                  DEBUGGER_PARSER *parser);
+extern ULONG displayProcessorStatusHelp(BYTE *commandLine, 
+                                        DEBUGGER_PARSER *parser);
+extern ULONG displayProcessorStatus(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG backTraceHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG backTraceAllPID(BYTE *cmd, StackFrame *stackFrame, 
+                             ULONG Exception, DEBUGGER_PARSER *parser);
+extern ULONG backTracePID(BYTE *cmd, StackFrame *stackFrame, 
+                             ULONG Exception, DEBUGGER_PARSER *parser);
+extern ULONG backTraceStack(BYTE *cmd, StackFrame *stackFrame, 
+                             ULONG Exception, DEBUGGER_PARSER *parser);
+
+#if defined(CONFIG_MODULES)
+extern ULONG listModulesHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG listModules(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	                 DEBUGGER_PARSER *parser);
+extern ULONG unloadModule(BYTE *cmd, StackFrame *stackFrame, ULONG Exception,
+	                 DEBUGGER_PARSER *parser);
+#endif
+
+#endif
+
diff -Naur ./debug/mdb-ia32-proc.h ../linux-2.6.18-mdb/./debug/mdb-ia32-proc.h
--- ./debug/mdb-ia32-proc.h	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-ia32-proc.h	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,514 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-IA32-PROC.H
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#ifndef _MDB_IA32_PROC_H
+#define _MDB_IA32_PROC_H
+
+#define EXT_NMI_PORT             0x0461
+#define NMI_IO_PORT              0x0462
+#define NMI_CONTROL_PORT         0x0C6E
+#define NMI_PORT                 0x61
+#define PIC1_DEBUG_MASK          0xFC
+#define PIC2_DEBUG_MASK          0xFF
+#define EXCEPTION_ENTRIES        19
+#define RESUME                   0x00010000
+#define NESTED_TASK              0x00004000
+#define SINGLE_STEP              0x00000100
+#define INVALID_EXPRESSION       0
+#define NUMERIC_EXPRESSION       1
+#define BOOLEAN_EXPRESSION       2
+
+// DR7 Breakpoint Type and Length Fields
+
+#define BREAK_EXECUTE    0
+#define BREAK_WRITE      1
+#define BREAK_IOPORT     2
+#define BREAK_READWRITE  3
+#define ONE_BYTE_FIELD   0
+#define TWO_BYTE_FIELD   1
+#define UNDEFINED_FIELD  2
+#define FOUR_BYTE_FIELD  3
+
+// DR7 Register
+
+#define L0_BIT   0x00000001
+#define G0_BIT   0x00000002
+#define L1_BIT   0x00000004
+#define G1_BIT   0x00000008
+#define L2_BIT   0x00000010
+#define G2_BIT   0x00000020
+#define L3_BIT   0x00000040
+#define G3_BIT   0x00000080
+#define LEXACT   0x00000100
+#define GEXACT   0x00000200
+#define GDETECT  0x00002000
+#define DR7DEF   0x00000400
+
+// DR6 Register
+
+#define B0_BIT   0x00000001
+#define B1_BIT   0x00000002
+#define B2_BIT   0x00000004
+#define B3_BIT   0x00000008
+
+#define BD_BIT   0x00002000
+#define BS_BIT   0x00004000
+#define BT_BIT   0x00008000
+
+// Memory Type Range Registers (MTRR)
+
+#define MTRR_PHYS_BASE_0    0x200
+#define MTRR_PHYS_MASK_0    0x201
+#define MTRR_PHYS_BASE_1    0x202
+#define MTRR_PHYS_MASK_1    0x203
+#define MTRR_PHYS_BASE_2    0x204
+#define MTRR_PHYS_MASK_2    0x205
+#define MTRR_PHYS_BASE_3    0x206
+#define MTRR_PHYS_MASK_3    0x207
+#define MTRR_PHYS_BASE_4    0x208
+#define MTRR_PHYS_MASK_4    0x209
+#define MTRR_PHYS_BASE_5    0x20A
+#define MTRR_PHYS_MASK_5    0x20B
+#define MTRR_PHYS_BASE_6    0x20C
+#define MTRR_PHYS_MASK_6    0x20D
+#define MTRR_PHYS_BASE_7    0x20E
+#define MTRR_PHYS_MASK_7    0x20F
+
+// IA32 flags settings
+
+#define   CF_FLAG      0x00000001
+#define   PF_FLAG      0x00000004
+#define   AF_FLAG      0x00000010
+#define   ZF_FLAG      0x00000040
+#define   SF_FLAG      0x00000080
+#define   TF_FLAG      0x00000100  // ss flag
+#define   IF_FLAG      0x00000200
+#define   DF_FLAG      0x00000400
+#define   OF_FLAG      0x00000800
+#define   NT_FLAG      0x00004000
+#define   RF_FLAG      0x00010000  // resume flag
+#define   VM_FLAG      0x00020000
+#define   AC_FLAG      0x00040000
+#define   VIF_FLAG     0x00080000
+#define   VIP_FLAG     0x00100000
+#define   ID_FLAGS     0x00200000
+
+typedef struct _GDT {
+    WORD Limit;	    //	0xFFFF
+    WORD Base1;	    //  0
+    BYTE Base2;	    //	0
+    BYTE GDTType;   //	10010010b
+    BYTE OtherType; //	11001111b
+    BYTE Base3;	    //	0
+} GDT;
+
+typedef struct _IDT {
+    WORD IDTLow;     //	0
+    WORD IDTSegment; //	0x08
+    BYTE IDTSkip;    //	0
+    BYTE IDTFlags;   //	10001110b
+    WORD IDTHigh;    //	0
+} IDT;
+
+typedef struct _TSS {
+    WORD TSSLimit;	// 0x0080
+    WORD TSSBase1;	// 0
+    BYTE TSSBase2;	// 0
+    BYTE TSSType;	// 10001001b
+    BYTE TSSOtherType;	// 00000000b
+    BYTE TSSBase3;	// 0
+} TSS;
+
+typedef struct _TSS_GATE {
+    WORD TSSRes1;  	// 0
+    WORD TSSSelector;	// 0
+    BYTE TSSRes2; 	// 0
+    BYTE TSSFlags;	// 10000101b
+    WORD TSSRes3; 	// 0
+} TSS_GATE;
+
+typedef struct _LDT {
+    WORD LDTLimit;	// 0xFFFF
+    WORD LDTBase1;	// 0
+    BYTE LDTBase2;	// 0
+    BYTE LDTGDTType;	// 10000010b
+    BYTE LDTOtherType;	// 10001111b
+    BYTE LDTBase3;	// 0
+} LDT;
+
+extern ULONG ReadDR0(void);
+extern ULONG ReadDR1(void);
+extern ULONG ReadDR2(void);
+extern ULONG ReadDR3(void);
+extern ULONG ReadDR6(void);
+extern ULONG ReadDR7(void);
+extern void WriteDR0(ULONG);
+extern void WriteDR1(ULONG);
+extern void WriteDR2(ULONG);
+extern void WriteDR3(ULONG);
+extern void WriteDR6(ULONG);
+extern void WriteDR7(ULONG);
+extern ULONG ReadCR0(void);
+extern ULONG ReadCR2(void);
+extern ULONG ReadCR3(void);
+extern ULONG ReadCR4(void);
+extern void ReadGDTR(ULONG *);
+extern void ReadIDTR(ULONG *);
+extern ULONG ReadLDTR(void);
+extern ULONG ReadTR(void);
+
+extern void ReadMSR(ULONG msr, ULONG *val1, ULONG *val2);
+extern void WriteMSR(ULONG msr, ULONG *val1, ULONG *val2);
+extern void MTRROpen(void);
+extern void MTRRClose(void);
+extern void save_npx(NUMERIC_FRAME *npx);
+extern void load_npx(NUMERIC_FRAME *npx);
+
+extern ULONG get_processor_id(void);
+extern ULONG get_physical_processor(void);
+extern ULONG fpu_present(void);
+
+extern void DisplayTSS(StackFrame *stackFrame);
+extern void DisplayGeneralRegisters(StackFrame *stackFrame);
+extern void DisplaySegmentRegisters(StackFrame *stackFrame);
+extern void DisplayControlRegisters(ULONG processor, StackFrame *stackFrame);
+extern double ldexp(double v, int e);
+extern void DisplayNPXRegisters(ULONG processor);
+
+extern ULONG processProceedACC(ULONG key, void *stackFrame,
+		  ACCELERATOR *accel);
+extern ULONG processTraceACC(ULONG key, void *stackFrame,
+		  ACCELERATOR *accel);
+extern ULONG processTraceSSBACC(ULONG key, void *stackFrame,
+		  ACCELERATOR *accel);
+extern ULONG processGoACC(ULONG key, void *stackFrame,
+		  ACCELERATOR *accel);
+
+extern ULONG executeCommandHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG processProceed(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser);
+extern ULONG processTrace(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+extern ULONG processTraceSSB(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+extern ULONG processGo(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+
+
+extern ULONG processorCommandHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG breakProcessor(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser);
+extern ULONG TSSDisplayHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG TSSDisplay(BYTE *cmd, 
+                    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser);
+
+extern ULONG displayEAXHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeEAXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+extern ULONG ChangeORIGEAXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayEBXHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeEBXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayECXHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeECXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayEDXHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeEDXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayESIHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeESIRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayEDIHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeEDIRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayEBPHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeEBPRegister(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern ULONG displayESPHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeESPRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayEIPHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeEIPRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern ULONG displayCSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeCSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern ULONG displayDSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeDSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern ULONG displayESHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeESRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern ULONG displayFSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeFSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern ULONG displayGSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeGSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern ULONG displaySSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeSSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern ULONG displayRFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeRFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayTFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeTFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayZFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeZFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displaySFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeSFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayPFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangePFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayCFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeCFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayOFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeOFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayIFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeIFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayIDHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeIDFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayDFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeDFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayNTHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeNTFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayVMHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeVMFlag(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern ULONG displayVIFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeVIFFlag(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern ULONG displayVIPHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeVIPFlag(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern ULONG displayAFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeAFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayACHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG ChangeACFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern ULONG displayMTRRHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG DisplayMTRRRegisters(BYTE *cmd,
+			  StackFrame *stackFrame, ULONG Exception,
+			  DEBUGGER_PARSER *parser);
+
+extern ULONG displayGDTHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayGDT(BYTE *cmd,
+		StackFrame *stackFrame, ULONG Exception,
+		DEBUGGER_PARSER *parser);
+
+extern ULONG displayIDTHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayIDT(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern ULONG evaluateExpressionHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG evaluateExpression(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern ULONG displayDOSTableHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG displayDOSTable(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern ULONG portCommandHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG inputWordPort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG inputDoublePort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG inputBytePort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG inputPort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG outputWordPort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG outputDoublePort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG outputBytePort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG outputPort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+
+
+extern ULONG breakpointCommandHelp(BYTE *commandLine, DEBUGGER_PARSER *parser);
+extern ULONG breakpointClearAll(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser);
+extern ULONG breakpointClear(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+extern ULONG breakpointMask(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser);
+extern ULONG breakpointWord1(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+extern ULONG breakpointWord2(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+extern ULONG breakpointWord4(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+extern ULONG breakpointWord(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser);
+extern ULONG breakpointRead1(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+extern ULONG breakpointRead2(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+extern ULONG breakpointRead4(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG breakpointRead(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG breakpointIO1(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG breakpointIO2(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG breakpointIO4(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG breakpointIO(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG breakpointExecute(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser);
+extern ULONG breakpointShowTemp(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser);
+extern ULONG dump_ef(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+extern ULONG dump_uf(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser);
+
+#endif
+
diff -Naur ./debug/mdb-ia32-support.c ../linux-2.6.18-mdb/./debug/mdb-ia32-support.c
--- ./debug/mdb-ia32-support.c	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-ia32-support.c	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,2362 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-IA32-SUPPORT.C
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#include "mdb.h"
+
+#ifdef CONFIG_MDB
+
+#define mod(a)  (((a) >> 6) & 7)
+#define reg(a)  (((a) >> 3) & 7)
+#define rm(a)   ((a) & 7)
+#define ss(a)   (((a) >> 6) & 7)
+#define indx(a) (((a) >> 3) & 7)
+#define base(a) ((a) & 7)
+
+#define   CF_FLAG   0x00000001
+#define   PF_FLAG   0x00000004
+#define   AF_FLAG   0x00000010
+#define   ZF_FLAG   0x00000040
+#define   SF_FLAG   0x00000080
+#define   TF_FLAG   0x00000100
+#define   IF_FLAG   0x00000200
+#define   DF_FLAG   0x00000400
+#define   OF_FLAG   0x00000800
+#define   NT_FLAG   0x00004000
+#define   RF_FLAG   0x00010000
+#define   VM_FLAG   0x00020000
+#define   AC_FLAG   0x00040000
+#define   VIF_FLAG  0x00080000
+#define   VIP_FLAG  0x00100000
+#define   ID_FLAG   0x00200000
+
+short SegmentSize = 32;
+BYTE buf[20];
+BYTE *VirtualAddress;
+short bufp, bufe;
+BYTE ubuf[4000], *ubufp;
+short Columns;
+BYTE NoNameBuffer[100];
+short DefaultPickSign;
+short Prefix;
+signed int modrmv;
+signed int sibv;
+short OperandSize;
+short AddressSize;
+ULONG needs_proceed;
+short MODRMExtend;
+long DeRefValue = 0;
+long pSize = 0;
+extern ULONG full_deref_toggle;
+extern ULONG debug_deref;
+
+void ProcessInstruction(StackFrame *stackFrame, BYTE *s);
+
+/* Percent tokens in strings:
+   First char after '%':
+	A - direct address
+	C - reg of r/m picks control register
+	D - reg of r/m picks debug register
+        E - r/m picks operand
+        F - flags register
+	G - reg of r/m picks general register
+        I - immediate data (takes extended size, data size)
+        J - relative IP offset
+        M - r/m picks memory
+        O - no r/m, offset only
+	R - mod of r/m picks register only
+        S - reg of r/m picks segment register
+        T - reg of r/m picks test register
+        X - DS:ESI
+        Y - ES:EDI
+	2 - Prefix of two-byte opcode
+	e - put in 'e' if use32 (second char is part of reg name)
+	    put in 'w' for use16 or 'd' for use32 (second char is 'w')
+	f - floating point (second char is esc value)
+	g - do r/m group 'n'
+	p - Prefix
+	s - size override (second char is a,o)
+        + - make default signed
+   Second char after '%':
+        a - two words in memory (BOUND)
+	b - byte
+        c - byte or word
+        d - dword
+	p - 32 or 48 bit pointer
+        s - six byte pseudo-descriptor
+        v - word or dword
+	w - word
+        F - use floating regs in mod/rm
+        + - always sign
+        - - sign if negative
+	1-8 - group number, esc value, etc
+*/
+
+BYTE *opmap1[] =
+{
+  /* 0 */
+  "ADD %Eb,%Gb",   "ADD %Ev,%Gv",    "ADD %Gb,%Eb",   "ADD %Gv,%Ev",
+  "ADD AL,%I-bb",  "ADD %eAX,%I-vv", "PUSH ES",       "POP ES",
+  "OR %Eb,%Gb",    "OR %Ev,%Gv",     "OR %Gb,%Eb",    "OR %Gv,%Ev",
+  "OR AL,%Ibb",    "OR %eAX,%Ivv",   "PUSH CS",       "%2 ",
+  /* 1 */
+  "ADC %Eb,%Gb",   "ADC %Ev,%Gv",    "ADC %Gb,%Eb",   "ADC %Gv,%Ev",
+  "ADC AL,%I-bb",  "ADC %eAX,%I-vv", "PUSH SS",       "POP SS",
+  "SBB %Eb,%Gb",   "SBB %Ev,%Gv",    "SBB %Gb,%Eb",   "SBB %Gv,%Ev",
+  "SBB AL,%I-bb",  "SBB %eAX,%I-vv", "PUSH DS",       "POP DS",
+  /* 2 */
+  "AND %Eb,%Gb",   "AND %Ev,%Gv",    "AND %Gb,%Eb",   "AND %Gv,%Ev",
+  "AND AL,%Ibb",   "AND %eAX,%Ivv",  "%pe",           "DAA",
+  "SUB %Eb,%Gb",   "SUB %Ev,%Gv",    "SUB %Gb,%Eb",   "SUB %Gv,%Ev",
+  "SUB AL,%I-bb",  "SUB %eAX,%I-vv", "%pc",           "DAS",
+  /* 3 */
+  "XOR %Eb,%Gb",   "XOR %Ev,%Gv",    "XOR %Gb,%Eb",   "XOR %Gv,%Ev",
+  "XOR AL,%Ibb",   "XOR %eAX,%Ivv",  "%ps",           "AAA",
+  "CMP %Eb,%Gb",   "CMP %Ev,%Gv",    "CMP %Gb,%Eb",   "CMP %Gv,%Ev",
+  "CMP AL,%I-bb",  "CMP %eAX,%I-vv", "%pd",           "AAS",
+  /* 4 */
+  "INC %eAX",      "INC %eCX",       "INC %eDX",      "INC %eBX",
+  "INC %eSP",      "INC %eBP",       "INC %eSI",      "INC %eDI",
+  "DEC %eAX",      "DEC %eCX",       "DEC %eDX",      "DEC %eBX",
+  "DEC %eSP",      "DEC %eBP",       "DEC %eSI",      "DEC %eDI",
+  /* 5 */
+  "PUSH %eAX",     "PUSH %eCX",      "PUSH %eDX",     "PUSH %eBX",
+  "PUSH %eSP",     "PUSH %eBP",      "PUSH %eSI",     "PUSH %eDI",
+  "POP %eAX",      "POP %eCX",       "POP %eDX",      "POP %eBX",
+  "POP %eSP",      "POP %eBP",       "POP %eSI",      "POP %eDI",
+  /* 6 */
+  "PUSHA",         "POPA",           "BOUND %Gv,%Ma", "ARPL %Ew,%Rw",
+  "%pf",           "%pg",            "%so",           "%sa",
+  "PUSH %I-vv",    "IMUL %Gv=%Ev*%I-vv", "PUSH %I-vb","IMUL %Gv=%Ev*%I-vb",
+  "INSB %Yb,DX",   "INS%ew %Yv,DX",  "OUTSB DX,%Xb",  "OUTS%ew DX,%Xv",
+  /* 7 */
+  "JO %Jb",        "JNO %Jb",        "JC %Jb",        "JNC %Jb",
+  "JZ %Jb",        "JNZ %Jb",        "JBE %Jb",       "JNBE %Jb",
+  "JS %Jb",        "JNS %Jb",        "JPE %Jb",       "JPO %Jb",
+  "JL %Jb",        "JGE %Jb",        "JLE %Jb",       "JG %Jb",
+  /* 8 */
+  "%g1 %Eb,%Ibb",  "%g1 %Ev,%Ivv",   0,               "%g1 %Ev,%Ivb",
+  "TEST %Eb,%Gb",  "TEST %Ev,%Gv",   "XCHG %Eb,%Gb",  "XCHG %Ev,%Gv",
+  "MOV %Eb,%Gb",   "MOV %Ev,%Gv",    "MOV %Gb,%Eb",   "MOV %Gv,%Ev",
+  "MOV %Ew,%Sw",   "LEA %Gv,%M ",    "MOV %Sw,%Ew",   "POP %Ev",
+  /* 9 */
+  "NOP",           "XCHG %eAX,%eCX", "XCHG %eAX,%eDX","XCHG %eAX,%eBX",
+  "XCHG %eAX,%eSP","XCHG %eAX,%eBP", "XCHG %eAX,%eSI","XCHG %eAX,%eDI",
+  "CBW",           "CWD",            "CALL %Ap",      "FWAIT",
+  "PUSH %eFLAGS",  "POP %eFLAGS",    "SAHF",          "LAHF",
+  /* a */
+  "MOV AL,%Ob",    "MOV %eAX,%Ov",   "MOV %Ob,AL",    "MOV %Ov,%eAX",
+  "MOVSB %Xb,%Yb", "MOVS%ew %Xv,%Yv","CMPSB %Xb,%Yb", "CMPS%ew %Xv,%Yv",
+  "TEST AL,%Ibb",  "TEST %eAX,%Ivv", "STOSB %Yb,AL",  "STOS%ew %Yv,%eAX",
+  "LODSB AL,%Xb",  "LODS%ew %eAX,%Xv","SCASB AL,%Xb", "SCAS%ew %eAX,%Xv",
+  /* b */
+  "MOV AL,%Ibb",   "MOV CL,%Ibb",    "MOV DL,%Ibb",   "MOV BL,%Ibb",
+  "MOV AH,%Ibb",   "MOV CH,%Ibb",    "MOV DH,%Ibb",   "MOV BH,%Ibb",
+  "MOV %eAX,%I-vv","MOV %eCX,%I-vv", "MOV %eDX,%I-vv","MOV %eBX,%I-vv",
+  "MOV %eSP,%Ivv", "MOV %eBP,%Ivv",  "MOV %eSI,%I-vv","MOV %eDI,%I-vv",
+  /* c */
+  "%g2 %Eb,%Ibb",  "%g2 %Ev,%Ibb",   "RET %Iw",       "RET",
+  "LES %Gv,%Mp",   "LDS %Gv,%Mp",    "MOV %Eb,%Ibb",  "MOV %Ev,%I-vv",
+  "ENTER %Iww,%Ibb","LEAVE",         "RETF %Iww",     "RETF",
+  "INT 3",         "INT %Ibb",       "INTO",          "IRET",
+  /* d */
+  "%g2 %Eb,1",     "%g2 %Ev,1",      "%g2 %Eb,CL",    "%g2 %Ev,CL",
+  "AAM %Ibb",      "AAD %Ibb",       0,               "XLAT",
+  "%f0",           "%f1",            "%f2",           "%f3",
+  "%f4",           "%f5",            "%f6",           "%f7",
+  /* e */
+  "LOOPNE %Jb",    "LOOPE %Jb",      "LOOP %Jb",      "JCXZ %Jb",
+  "IN AL,%Ibb",    "IN %eAX,%Ibb",   "OUT %Ibb,AL",   "OUT %Ibb,%eAX",
+  "CALL %Jv",      "JMP %Jv",        "JMP %Ap",       "JMP(S) %Jb",
+  "IN AL,DX",      "IN %eAX,DX",     "OUT DX,AL",     "OUT DX,%eAX",
+  /* f */
+  "LOCK %p ",      0,                "REPNE %p ",     "REP(E) %p ",
+  "HLT",           "CMC",            "%g3",           "%g0",
+  "CLC",           "STC",            "CLI",           "STI",
+  "CLD",           "STD",            "%g4",           "%g5"
+};
+
+BYTE *second[] =
+{
+  /* 0 */
+  "%g6",           "%g7",            "LAR %Gv,%Ew",   "LSL %Gv,%Ew",
+  0,               0,                "CLTS",          0,
+  "INVD",          "WBINV",          0,               "UD2A",
+  0,               "%y0",            "FEMMS",         0,
+  /* 1 */
+  "%z8",	   "%z9",	     "MOVLPS", 	      "MOVLPS",
+  "UNPCKLPS", 	   "UNPCKHPS",	     "MOVHPS", 	      "MOVHPS",
+  "%g14",	   0, 		     0, 	      0,
+  0, 		   0, 		     0, 	      0,
+  /* 2 */
+  "MOV %Rd,%Cd",   "MOV %Rd,%Dd",    "MOV %Cd,%Rd",   "MOV %Dd,%Rd",
+  "MOV %Rd,%Td",   0,                "MOV %Td,%Rd",   0,
+  "MOVAPS",	   "MOVAPS",	     "%z2", 	      "MOVNTPS",
+  "%z4",	   "%z3", 	     "UCOMISS",       "COMISS",
+  /* 3 */
+  "WRMSR MSR[ECX],EDX:EAX", "RDTSC", "RDMSR EDX:EAX,MSR[ECX]",  "RDPMC",
+  "SYSENTER",      "SYSEXIT",	     0,		      0,
+  0, 		   0, 		     0, 	      0,
+  0,               0,                0,               0,
+  /* 4 */
+  "CMOVO %Gv,%Ev", "CMOVNO %Gv,%Ev", "CMOVB %Gv,%Ev",  "CMOVAE %Gv,%Ev", 
+  "CMOVE %Gv,%Ev", "CMOVNE %Gv,%Ev", "CMOVBE %Gv,%Ev", "CMOVA %Gv,%Ev",  
+  "CMOVS %Gv,%Ev", "CMOVNS %Gv,%Ev", "CMOVP %Gv,%Ev",  "CMOVNP %Gv,%Ev", 
+  "CMOVL %Gv,%Ev", "CMOVGE %Gv,%Ev", "CMOVLE %Gv,%Ev", "CMOVG %Gv,%Ev",
+  /* 5 */
+  "MOVMSKPS",	   "%z13",           "%z12",          "%z11",
+  "ANDPS",         "ANDNPS",         "ORPS",          "XORPS",
+  "%z0",	   "%z10",           0,               0,
+  "%z14",          "%z7",            "%z5",           "%z6",
+  /* 6 */
+  0,               0,                0,               0,
+  0,               0,                0,               0,
+  0,               0,                0,               0,
+  0,               0,               "MOVD %Pd,%Ed",  "MOVQ %Pq,%Qq",
+  /* 7 */
+  0,		   0,                0,               0,
+  0,               0,                0,               0,
+  0,		   0,                0,               0,
+  0,               0,               "MOVD %Ed,%Pd",  "MOVQ %Qq,%Pq",
+  /* 8 */
+  "JO %Jv",        "JNO %Jv",        "JC %Jv",        "JNC %Jv",
+  "JZ %Jv",        "JNZ %Jv",        "JBE %Jv",       "JNBE %Jv",
+  "JS %Jv",        "JNS %Jv",        "JPE %Jv",       "JPO %Jv",
+  "JL %Jv",        "JGE %Jv",        "JLE %Jv",       "JG %Jv",
+  /* 9 */
+  "SETO %Eb",      "SETNO %Eb",      "SETC %Eb",      "SETNC %Eb",
+  "SETZ %Eb",      "SETNZ %Eb",      "SETBE %Eb",     "SETNBE %Eb",
+  "SETS %Eb",      "SETNS %Eb",      "SETP %Eb",      "SETNP %Eb",
+  "SETL %Eb",      "SETGE %Eb",      "SETLE %Eb",     "SETG %Eb",
+  /* a */
+  "PUSH FS",       "POP FS",         "CPUID",         "BT %Ev,%Gv",
+  "SHLD %Ev,%Gv,%Ibb","SHLD %Ev,%Gv,CL", 0,           0,
+  "PUSH GS",       "POP GS",         "RSM",           "BTS %Ev,%Gv",
+  "SHRD %Ev,%Gv,%Ibb","SHRD %Ev,%Gv,CL", 0,           "IMUL %Gv,%Ev",
+
+  /* b */
+  "CMPXCHG %Eb,%Gb", "CMPXCHG %Ev,%Gv", "LSS %Mp",       "BTR %Ev,%Gv",
+  "LFS %Mp",         "LGS %Mp",         "MOVZX %Gv,%Eb", "MOVZX %Gv,%Ew",
+  0,                 "UD2B",            "%g8 %Ev,%Ibb",  "BTC %Ev,%Gv",
+  "BSF %Gv,%Ev",     "BSR %Gv,%Ev",     "MOVSX %Gv,%Eb", "MOVSX %Gv,%Ew",
+
+  /* c */
+  "XADD %Eb,%Gb",  "XADD %Ev,%Gv",   0, 	      0,
+  0,		   0,                0,               "%g9",
+  "BSWAP %eAX",    "BSWAP %eCX",     "BSWAP %eDX",    "BSWAP %eBX",
+  "BSWAP %eSP",    "BSWAP %eBP",     "BSWAP %eSI",    "BSWAP %eDI",
+  /* d */
+  0,  		   0,                0,               0,
+  0, 		   0, 		     0, 	      0,
+  0,		   0, 		     0, 	      0,
+  0, 		   0, 		     0, 	      0,
+  /* e */
+  0,		   0, 		     0, 	      0,
+  0, 		   0, 		     0, 	      0,
+  0,		   0, 		     0, 	      0,
+  0, 		   0, 		     0, 	      0,
+  /* f */
+  0,		   0, 		     0, 	      0,
+  0, 		   0, 		     0, 	      0,
+  0,		   0, 		     0, 	      0,
+  0, 		   0, 		     0, 	      0
+
+};
+
+BYTE *groups[][10] = {     /* group 0 is group 3 for %Ev set */
+// g0
+{ "TEST %Ev,%Ivv", "TEST %Ev,%Ivv,", "NOT %Ev",       "NEG %Ev",
+  "MUL %eAX,%Ev",  "IMUL %eAX,%Ev",  "DIV %eAX,%Ev",  "IDIV %eAX,%Ev" },
+
+// g1
+{ "ADD%+-",        "OR",             "ADC%+-",        "SBB%+-",
+  "AND",           "SUB%+-",         "XOR",           "CMP%+-" },
+
+// g2
+{ "ROL",           "ROR",            "RCL",           "RCR",
+  "SHL",           "SHR",            "SHL",           "SAR" },
+
+// g3
+{ "TEST %Eb,%Ibb", "TEST %Eb,%Ibb,", "NOT %Eb",       "NEG %Eb",
+  "MUL AL,%Eb",    "IMUL AL,%Eb",    "DIV AL,%Eb",    "IDIV AL,%Eb" },
+
+// g4
+{ "INC %Eb",       "DEC %Eb",        0,               0,
+  0,               0,                0,               0 },
+
+// g5
+{ "INC %Ev",       "DEC %Ev",        "CALL %Ev",      "CALL %Ep",
+  "JMP %Ev",       "JMP %Ep",        "PUSH %Ev",      0 },
+
+// g6
+{ "SLDT %Ew",      "STR %Ew",        "LLDT %Ew",      "LTR %Ew",
+  "VERR %Ew",      "VERW %Ew",       0, 0 },
+
+// g7
+{ "SGDT %Ms",      "SIDT %Ms",       "LGDT %Ms",      "LIDT %Ms",
+  "SMSW %Ew",      0,                "LMSW %Ew",      "INVLPG" },
+
+// g8
+{ 0,               0,                0, 0,
+  "BT",            "BTS",            "BTR",           "BTC" },
+
+// g9
+{ 0,               "CMPXCH8B %Mq",   0,               0,
+  0,               0,                0,               0 },
+
+// g10
+{ 0,               0,                0,               0,
+  0,               0,                0,               0 },
+
+};
+
+/* zero here means invalid.  If first entry starts with '*', use st(i) */
+/* no assumed %EFs here.  Indexed by rm(modrm()) */
+
+BYTE *f0[] = {
+  0,               0,                0,               0,
+  0, 		   0,		     0,	              0
+};
+
+BYTE *fop_9[]  = {
+  "*FXCH ST,%GF" };
+
+BYTE *fop_10[] = {
+  "FNOP", 	   0, 		      0, 	      0,
+  0, 		   0, 		      0, 	      0 };
+
+BYTE *fop_12[] = {
+  "FCHS",          "FABS",            0,              0,
+  "FTST",          "FXAM", 	      0, 	      0 };
+
+BYTE *fop_13[] = {
+  "FLD1", 	   "FLDL2T", 	      "FLDL2E",       "FLDPL",
+  "FLDLG2", 	   "FLDLN2", 	      "FLDZ", 	      0 };
+
+BYTE *fop_14[] = {
+  "F2XM1", 	   "FYL2X", 	      "FPTAN", 	      "FPATAN",
+  "FXTRACT", 	   "FPREM1", 	      "FDECSTP",      "FINCSTP" };
+
+BYTE *fop_15[] = {
+  "FPREM", 	   "FYL2XP1", 	      "FSQRT", 	      "FSINCOS",
+  "FRNDINT", 	   "FSCALE", 	      "FSIN", 	      "FCOS" };
+
+BYTE *fop_21[] = {
+   0, "FUCOMPP", 0, 0,
+   0, 0, 0, 0 };
+
+BYTE *fop_28[] = {
+   0, 0, "FCLEX", "FINIT",
+   0, 0, 0, 0 };
+
+BYTE *fop_32[] = {
+   "*FADD %GF,ST" };
+
+BYTE *fop_33[] = {
+   "*FMUL %GF,ST" };
+
+BYTE *fop_36[] = {
+   "*FSUBR %GF,ST" };
+
+BYTE *fop_37[] = {
+   "*FSUB %GF,ST" };
+
+BYTE *fop_38[] = {
+   "*FDIVR %GF,ST" };
+
+BYTE *fop_39[] = {
+   "*FDIV %GF,ST" };
+
+BYTE *fop_40[] = {
+   "*FFREE %GF" };
+
+BYTE *fop_42[] = { "*FST %GF" };
+
+BYTE *fop_43[] = { "*FSTP %GF" };
+
+BYTE *fop_44[] = { "*FUCOM %GF" };
+
+BYTE *fop_45[] = { "*FUCOMP %GF" };
+
+BYTE *fop_48[] = { "*FADDP %GF,ST" };
+
+BYTE *fop_49[] = { "*FMULP %GF,ST" };
+
+BYTE *fop_51[] = { 0, "FCOMPP", 0, 0, 0, 0, 0, 0 };
+
+BYTE *fop_52[] = { "*FSUBRP %GF,ST" };
+
+BYTE *fop_53[] = { "*FSUBP %GF,ST" };
+
+BYTE *fop_54[] = { "*FDIVRP %GF,ST" };
+
+BYTE *fop_55[] = { "*FDIVP %GF,ST" };
+
+BYTE *fop_60[] = { "FSTSW AX", 0, 0, 0, 0, 0, 0, 0 };
+
+BYTE **fspecial[] = { /* 0=use st(i), 1=undefined 0 in fop_* means undefined */
+  0, 0, 0, 0, 0, 0, 0, 0,
+  0, fop_9, fop_10, 0, fop_12, fop_13, fop_14, fop_15,
+  f0, f0, f0, f0, f0, fop_21, f0, f0,
+  f0, f0, f0, f0, fop_28, f0, f0, f0,
+  fop_32, fop_33, f0, f0, fop_36, fop_37, fop_38, fop_39,
+  fop_40, f0, fop_42, fop_43, fop_44, fop_45, f0, f0,
+  fop_48, fop_49, f0, fop_51, fop_52, fop_53, fop_54, fop_55,
+  f0, f0, f0, f0, fop_60, f0, f0, f0,
+  };
+
+BYTE *floatops[] = { /* assumed " %EF" at end of each.  mod != 3 only */
+/*00*/ "FADD", "FMUL", "FCOM", "FCOMP",
+       "FSUB", "FSUBR", "FDIV", "FDIVR",
+/*08*/ "FLD", 0, "FST", "FSTP",
+       "FLDENV", "FLDCW", "FSTENV", "FSTCW",
+/*16*/ "FIADD", "FIMUL", "FICOMW", "FICOMPW",
+       "FISUB", "FISUBR", "FIDIV", "FIDIVR",
+/*24*/ "FILD", 0, "FIST", "FISTP",
+       "FRSTOR", "FLDT", 0, "FSTPT",
+/*32*/ "FADDQ", "FMULQ", "FCOMQ", "FCOMPQ",
+       "FSUBQ", "FSUBRQ", "FDIVQ", "FDIVRQ",
+/*40*/ "FLDQ", 0, "FSTQ", "FSTPQ",
+       "FRESTOR", 0, "FSAVE", "FSTSW",
+/*48*/ "FIADDW", "FIMULW", "FICOMW", "FICOMPW",
+       "FISUBW", "FISUBRW", "FIDIVW", "FIDIVR",
+/*56*/ "FILDW", 0, "FISTW", "FISTPW",
+       "FBLDT", "FILDQ", "FBSTPT", "FISTPQ"
+};
+
+/************
+
+  // 60 
+  { "punpcklbw %MX,%EM",
+  { "punpcklwd %MX,%EM",
+  { "punpckldq %MX,%EM",
+  { "packsswb %MX,%EM",
+  { "pcmpgtb %MX,%EM",
+  { "pcmpgtw %MX,%EM",
+  { "pcmpgtd %MX,%EM",
+  { "packuswb %MX,%EM",
+  // 68 
+  { "punpckhbw", %MX, %EM,
+  { "punpckhwd", %MX, %EM,
+  { "punpckhdq", %MX, %EM,
+  { "packssdw", %MX, %EM,
+  { "(bad)", , ,  
+  { "(bad)", , ,  
+  { "movd", %MX, Ed,  
+  { "movq", %MX, %EM,  
+  // 70 
+  { "pshufw", %MX, %EM, Ib 
+  { GRP10 
+  { GRP11 
+  { GRP12 
+  { "pcmpeqb", %MX, %EM,  
+  { "pcmpeqw", %MX, %EM,  
+  { "pcmpeqd", %MX, %EM,  
+  { "emms", , ,  
+  // 78 
+  { "(bad)", , ,  
+  { "(bad)", , ,  
+  { "(bad)", , ,  
+  { "(bad)", , ,  
+  { "(bad)", , ,  
+  { "(bad)", , ,  
+  { "movd", Ed, %MX,  
+  { "movq", %EM, %MX,  
+  // a0 
+  { "push", fs, ,  
+  { "pop", fs, ,  
+  { "cpuid", , ,  
+  { "bt", Ev, Gv,  
+  { "shld", Ev, Gv, Ib 
+  { "shld", Ev, Gv, CL 
+  { "(bad)", , ,  
+  { "(bad)", , ,  
+  // a8 
+  { "push", gs, ,  
+  { "pop", gs, ,  
+  { "rsm" , , , 
+  { "bts", Ev, Gv,  
+  { "shrd", Ev, Gv, Ib 
+  { "shrd", Ev, Gv, CL 
+  { GRP13 
+  { "imul", Gv, Ev,  
+  // b0 
+  { "cmpxchg", Eb, Gb,  
+  { "cmpxchg", Ev, Gv,  
+  { "lss", Gv, Mp,  
+  { "btr", Ev, Gv,  
+  { "lfs", Gv, Mp,  
+  { "lgs", Gv, Mp,  
+  { "movzx", Gv, Eb,  
+  { "movzx", Gv, Ew,  
+  // b8 
+  { "(bad)", , ,  
+  { "ud2b", , ,  
+  { GRP8 },
+  { "btc", Ev, Gv,  
+  { "bsf", Gv, Ev,  
+  { "bsr", Gv, Ev,  
+  { "movsx", Gv, Eb,  
+  { "movsx", Gv, Ew,  
+  // c0 
+  { "xadd", Eb, Gb,  
+  { "xadd", Ev, Gv,  
+  { PREGRP1 
+  { "(bad)", , ,  
+  { "pinsrw", %MX, Ev, Ib 
+  { "pextrw", Ev, %MX, Ib 
+  { "shufps", XM, EX, Ib 
+  { GRP9 
+  // c8 
+  { "bswap", eAX, ,  
+  { "bswap", eCX, ,  
+  { "bswap", eDX, ,  
+  { "bswap", eBX, ,  
+  { "bswap", eSP, ,  
+  { "bswap", eBP, ,  
+  { "bswap", eSI, ,  
+  { "bswap", eDI, ,  
+  // d0 
+  { "(bad)", , ,  
+  { "psrlw", %MX, %EM,  
+  { "psrld", %MX, %EM,  
+  { "psrlq", %MX, %EM,  
+  { "(bad)", , ,  
+  { "pmullw", %MX, %EM,  
+  { "(bad)", , ,  
+  { "pmovmskb", Ev, %MX,  
+  // d8 
+  { "psubusb", %MX, %EM,  
+  { "psubusw", %MX, %EM,  
+  { "pminub", %MX, %EM,  
+  { "pand", %MX, %EM,  
+  { "paddusb", %MX, %EM,  
+  { "paddusw", %MX, %EM,  
+  { "pmaxub", %MX, %EM,  
+  { "pandn", %MX, %EM,  
+  // e0 
+  { "pavgb", %MX, %EM,  
+  { "psraw", %MX, %EM,  
+  { "psrad", %MX, %EM,  
+  { "pavgw", %MX, %EM,  
+  { "pmulhuw", %MX, %EM,  
+  { "pmulhw", %MX, %EM,  
+  { "(bad)", , ,  
+  { "movntq", Ev, %MX,  
+  // e8 
+  { "psubsb", %MX, %EM,  
+  { "psubsw", %MX, %EM,  
+  { "pminsw", %MX, %EM,  
+  { "por", %MX, %EM,  
+  { "paddsb", %MX, %EM,  
+  { "paddsw", %MX, %EM,  
+  { "pmaxsw", %MX, %EM,  
+  { "pxor", %MX, %EM,  
+  // f0 
+  { "(bad)", , ,  
+  { "psllw", %MX, %EM,  
+  { "pslld", %MX, %EM,  
+  { "psllq", %MX, %EM,  
+  { "(bad)", , ,  
+  { "pmaddwd", %MX, %EM,  
+  { "psadbw", %MX, %EM,  
+  { "maskmovq", %MX, %EM,  
+  // f8 
+  { "psubb", %MX, %EM,  
+  { "psubw", %MX, %EM,  
+  { "psubd", %MX, %EM,  
+  { "(bad)", , ,  
+  { "paddb", %MX, %EM,  
+  { "paddw", %MX, %EM,  
+  { "paddd", %MX, %EM,  
+  { "(bad)", , ,  
+};
+
+
+static const struct dis386 grps[][8] = {
+  //  GRP1b 
+  {
+    { "addA",	Eb, Ib,  
+    { "orA",	Eb, Ib,  
+    { "adcA",	Eb, Ib,  
+    { "sbbA",	Eb, Ib,  
+    { "andA",	Eb, Ib,  
+    { "subA",	Eb, Ib,  
+    { "xorA",	Eb, Ib,  
+    { "cmpA",	Eb, Ib,  
+  // GRP1S 
+  {
+    { "addQ",	Ev, Iv,  
+    { "orQ",	Ev, Iv,  
+    { "adcQ",	Ev, Iv,  
+    { "sbbQ",	Ev, Iv,  
+    { "andQ",	Ev, Iv,  
+    { "subQ",	Ev, Iv,  
+    { "xorQ",	Ev, Iv,  
+    { "cmpQ",	Ev, Iv,    },
+  // GRP1Ss 
+  {
+    { "addQ",	Ev, sIb,  
+    { "orQ",	Ev, sIb,  
+    { "adcQ",	Ev, sIb,  
+    { "sbbQ",	Ev, sIb,  
+    { "andQ",	Ev, sIb,  
+    { "subQ",	Ev, sIb,  
+    { "xorQ",	Ev, sIb,  
+    { "cmpQ",	Ev, sIb,    
+  // GRP2b 
+  {
+    { "rolA",	Eb, Ib,  
+    { "rorA",	Eb, Ib,  
+    { "rclA",	Eb, Ib,  
+    { "rcrA",	Eb, Ib,  
+    { "shlA",	Eb, Ib,  
+    { "shrA",	Eb, Ib,  
+    { "(bad)",	, ,  
+    { "sarA",	Eb, Ib,  
+  },
+  // GRP2S 
+  {
+    { "rolQ",	Ev, Ib,  
+    { "rorQ",	Ev, Ib,  
+    { "rclQ",	Ev, Ib,  
+    { "rcrQ",	Ev, Ib,  
+    { "shlQ",	Ev, Ib,  
+    { "shrQ",	Ev, Ib,  
+    { "(bad)",	, ,  
+    { "sarQ",	Ev, Ib,  
+  },
+  // GRP2b_one 
+  {
+    { "rolA",	Eb, ,  
+    { "rorA",	Eb, ,  
+    { "rclA",	Eb, ,  
+    { "rcrA",	Eb, ,  
+    { "shlA",	Eb, ,  
+    { "shrA",	Eb, ,  
+    { "(bad)",	, ,  
+    { "sarA",	Eb, ,  
+  },
+  // GRP2S_one 
+  {
+    { "rolQ",	Ev, ,  
+    { "rorQ",	Ev, ,  
+    { "rclQ",	Ev, ,  
+    { "rcrQ",	Ev, ,  
+    { "shlQ",	Ev, ,  
+    { "shrQ",	Ev, ,  
+    { "(bad)",	, , 
+    { "sarQ",	Ev, ,  
+  },
+  // GRP2b_cl 
+  {
+    { "rolA",	Eb, CL,  
+    { "rorA",	Eb, CL,  
+    { "rclA",	Eb, CL,  
+    { "rcrA",	Eb, CL,  
+    { "shlA",	Eb, CL,  
+    { "shrA",	Eb, CL,  
+    { "(bad)",	, ,  
+    { "sarA",	Eb, CL,  
+  },
+  // GRP2S_cl 
+  {
+    { "rolQ",	Ev, CL,  
+    { "rorQ",	Ev, CL,  
+    { "rclQ",	Ev, CL,  
+    { "rcrQ",	Ev, CL,  
+    { "shlQ",	Ev, CL,  
+    { "shrQ",	Ev, CL,  
+    { "(bad)",	, ,  
+    { "sarQ",	Ev, CL,  
+  },
+  // GRP3b 
+  {
+    { "testA",	Eb, Ib,  
+    { "(bad)",	Eb, ,  
+    { "notA",	Eb, ,  
+    { "negA",	Eb, ,  
+    { "mulB",	AL, Eb,  
+    { "imulB",	AL, Eb,  
+    { "divB",	AL, Eb,  
+    { "idivB",	AL, Eb,  
+  },
+  // GRP3S 
+  {
+    { "testQ",	Ev, Iv,  
+    { "(bad)",	, ,  
+    { "notQ",	Ev, ,  
+    { "negQ",	Ev, ,  
+    { "mulS",	eAX, Ev,  
+    { "imulS",	eAX, Ev,  
+    { "divS",	eAX, Ev,  
+    { "idivS",	eAX, Ev,  
+  },
+  // GRP4 
+  {
+    { "incA",	Eb, ,  
+    { "decA",	Eb, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+  },
+  // GRP5 
+  {
+    { "incQ",	Ev, ,  
+    { "decQ",	Ev, ,  
+    { "callP",	indirEv, ,  
+    { "lcallP",	indirEv, ,  
+    { "jmpP",	indirEv, ,  
+    { "ljmpP",	indirEv, ,  
+    { "pushQ",	Ev, ,  
+    { "(bad)",	, ,  
+  },
+  // GRP6 
+  {
+    { "sldt",	Ew, ,  
+    { "str",	Ew, ,  
+    { "lldt",	Ew, ,  
+    { "ltr",	Ew, ,  
+    { "verr",	Ew, ,  
+    { "verw",	Ew, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+  },
+  // GRP7 
+  {
+    { "sgdt", Ew, ,  
+    { "sidt", Ew, ,  
+    { "lgdt", Ew, ,  
+    { "lidt", Ew, ,  
+    { "smsw", Ew, ,  
+    { "(bad)", , ,  
+    { "lmsw", Ew, ,  
+    { "invlpg", Ew, ,  
+  },
+  // GRP8 
+  {
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "btQ",	Ev, Ib,  
+    { "btsQ",	Ev, Ib,  
+    { "btrQ",	Ev, Ib,  
+    { "btcQ",	Ev, Ib,  
+  },
+  // GRP9 
+  {
+    { "(bad)",	, ,  
+    { "cmpxchg8b", Ev, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+  },
+  // GRP10 
+  {
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "psrlw",	MS, Ib,  
+    { "(bad)",	, ,  
+    { "psraw",	MS, Ib,  
+    { "(bad)",	, ,  
+    { "psllw",	MS, Ib,  
+    { "(bad)",	, ,  
+  },
+  // GRP11 
+  {
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "psrld",	MS, Ib,  
+    { "(bad)",	, ,  
+    { "psrad",	MS, Ib,  
+    { "(bad)",	, ,  
+    { "pslld",	MS, Ib,  
+    { "(bad)",	, ,  
+  },
+  // GRP12 
+  {
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "psrlq",	MS, Ib,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "psllq",	MS, Ib,  
+    { "(bad)",	, ,  
+  },
+  // GRP13 
+  {
+    { "fxsave", Ev, ,  
+    { "fxrstor", Ev, ,  
+    { "ldmxcsr", Ev, ,  
+    { "stmxcsr", Ev, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "(bad)",	, ,  
+    { "sfence", None, ,  
+  },
+  // GRP14 
+  {
+    { "prefetchnta", Ev, ,  
+    { "prefetcht0", Ev, ,  
+    { "prefetcht1", Ev, ,  
+    { "prefetcht2", Ev, ,  
+    { "(bad)",	, ,  },
+    { "(bad)",	, ,  },
+    { "(bad)",	, ,  },
+    { "(bad)",	, ,  },
+  },
+  // GRPAMD 
+  {
+    { "prefetch", Eb, ,  
+    { "prefetchw", Eb, ,  
+    { "(bad)",	, ,  },
+    { "(bad)",	, ,  },
+    { "(bad)",	, ,  },
+    { "(bad)",	, ,  },
+    { "(bad)",	, ,  },
+    { "(bad)",	, ,  },
+  }
+
+};
+
+static const struct dis386 prefix_user_table[][2] = {
+  // PREGRP0 
+  {
+    { "addps", XM, EX,  
+    { "addss", XM, EX,  
+  },
+  // PREGRP1 
+  {
+    { "", XM, EX, OPSIMD 	
+    { "", XM, EX, OPSIMD 
+  },
+  // PREGRP2 
+  {
+    { "cvtpi2ps", XM, %EM,  
+    { "cvtsi2ss", XM, Ev,  
+  },
+  // PREGRP3 
+  {
+    { "cvtps2pi", %MX, EX,  
+    { "cvtss2si", Gv, EX,  
+  },
+  // PREGRP4 
+  {
+    { "cvttps2pi", %MX, EX, 
+    { "cvttss2si", Gv, EX,  
+  },
+  // PREGRP5 
+  {
+    { "divps", XM, EX,  
+    { "divss", XM, EX,  
+  },
+  // PREGRP6 
+  {
+    { "maxps", XM, EX,  
+    { "maxss", XM, EX,  
+  },
+  // PREGRP7 
+  {
+    { "minps", XM, EX,  
+    { "minss", XM, EX,  
+  },
+  // PREGRP8 
+  {
+    { "movups", XM, EX,  
+    { "movss", XM, EX,  
+  },
+  // PREGRP9 
+  {
+    { "movups", EX, XM,  
+    { "movss", EX, XM,  
+  },
+  // PREGRP10
+  {
+    { "mulps", XM, EX,  
+    { "mulss", XM, EX,  
+  },
+  // PREGRP11 
+  {
+    { "rcpps", XM, EX,  
+    { "rcpss", XM, EX,  
+  },
+  // PREGRP12 
+  {
+    { "rsqrtps", XM, EX,  
+    { "rsqrtss", XM, EX,  
+  },
+  // PREGRP13 
+  {
+    { "sqrtps", XM, EX,  
+    { "sqrtss", XM, EX,  
+  },
+  // PREGRP14 
+  {
+    { "subps", XM, EX,  
+    { "subss", XM, EX,  
+  }
+};
+
+*****************/
+
+BYTE *reg_names[3][8]={
+  {"AL","CL","DL","BL","AH","CH","DH","BH"},
+  {"AX","CX","DX","BX","SP","BP","SI","DI"},
+  {"EAX", // 0
+   "ECX", // 1
+   "EDX", // 2
+   "EBX", // 3
+   "ESP", // 4
+   "EBP", // 5
+   "ESI", // 6
+   "EDI"} // 7
+   };
+
+BYTE *r_str[] = {
+   "BX+SI",
+   "BX+DI",
+   "BP+SI",
+   "BP+DI",
+   "SI",
+   "DI",
+   "BP",
+   "BX"
+};
+
+BYTE *formats[5][4] = {
+    {"%08X", "%08X", "%08z", "%08z" },
+    {"%02X", "%02X", "%02z", "%02z" },
+    {"%04X", "%04X", "%04z", "%04z" },
+    {"%08X", "%08X", "%08z", "%08z" },
+    {"%08X", "%08X", "%08z", "%08z" } };
+
+BYTE *i_str[] = {
+   "+EAX", // 0
+   "+ECX", // 1
+   "+EDX", // 2
+   "+EBX", // 3
+   "",     // 4
+   "+EBP", // 5
+   "+ESI", // 6
+   "+EDI"  // 7
+};
+
+BYTE *sib_str[] = {
+   "%p:[EAX", // 0
+   "%p:[ECX", // 1
+   "%p:[EDX", // 2
+   "%p:[EBX", // 3
+   "%p:[ESP", // 4
+   0,         // 5
+   "%p:[ESI", // 6
+   "%p:[EDI"  // 7
+};
+
+long reg_get_value(ULONG index, StackFrame *stackFrame)
+{
+     if (!stackFrame)
+        return 0;
+
+     switch (index)
+     {
+	case 0:
+	   return stackFrame->tEAX;
+
+	case 1:
+	   return stackFrame->tECX;
+
+	case 2:
+	   return stackFrame->tEDX;
+
+	case 3:
+	   return stackFrame->tEBX;
+
+	case 4:
+	   return stackFrame->tESP;
+
+	case 5:
+	   return stackFrame->tEBP;
+
+	case 6:
+	   return stackFrame->tESI;
+
+	case 7:
+	   return stackFrame->tEDI;
+
+	default:
+	   return 0;
+     }
+}
+
+long sib_get_value(ULONG index, StackFrame *stackFrame)
+{
+     if (!stackFrame)
+        return 0;
+
+     switch (index)
+     {
+	case 0:
+	   return stackFrame->tEAX;
+
+	case 1:
+	   return stackFrame->tECX;
+
+	case 2:
+	   return stackFrame->tEDX;
+
+	case 3:
+	   return stackFrame->tEBX;
+
+	case 4:
+	   return stackFrame->tESP;
+
+	case 6:
+	   return stackFrame->tESI;
+
+	case 7:
+	   return stackFrame->tEDI;
+
+	case 5:
+	default:
+	   return 0;
+     }
+}
+
+long istr_get_value(ULONG index, StackFrame *stackFrame)
+{
+     if (!stackFrame)
+        return 0;
+
+     switch (index)
+     {
+	case 0:
+	   return stackFrame->tEAX;
+
+	case 1:
+	   return stackFrame->tECX;
+
+	case 2:
+	   return stackFrame->tEDX;
+
+	case 3:
+	   return stackFrame->tEBX;
+
+	case 5:
+	   return stackFrame->tEBP;
+
+	case 6:
+	   return stackFrame->tESI;
+
+	case 7:
+	   return stackFrame->tEDI;
+
+	case 4:
+	default:
+	   return 0;
+     }
+}
+
+
+BYTE *output_address(void *val, unsigned long *delta)
+{
+    BYTE *symbolName;
+    BYTE *moduleName;
+    register int c = get_processor_id();
+
+    if (delta)
+      *delta = 0;
+
+    symbolName = GetSymbolFromValue((ULONG) val, &symbuf[c][0], 
+                                    MAX_SYMBOL_LEN);
+    if (symbolName)
+    {
+       moduleName = GetModuleInfoFromSymbolValue((ULONG) val, &modbuf[c][0], 
+                                                 MAX_SYMBOL_LEN);
+       if (moduleName)
+          sprintf(NoNameBuffer, "%s|%s=%08X", moduleName, symbolName, 
+                 (unsigned)val);
+       else
+          sprintf(NoNameBuffer, "%s=%08X", symbolName, (unsigned)val);
+    }  
+    else
+       sprintf(NoNameBuffer, "%08X", (unsigned)val);
+
+    return NoNameBuffer;
+
+}
+
+BYTE *output_jmp_address(StackFrame *stackFrame, long val, long *delta)
+{
+
+    BYTE *symbolName;
+    BYTE *moduleName;
+    long va = (long) VirtualAddress;
+    long v;
+    long segment, offset, sym_offset = 0;
+    register int c = get_processor_id();
+
+    if (delta)
+      *delta = 0;
+
+    if (!stackFrame)
+       return NoNameBuffer;
+
+    if ((!strncmp(ubuf, "JBE", 3) && 
+           ((stackFrame->tSystemFlags & ZF_FLAG) || 
+            (stackFrame->tSystemFlags & CF_FLAG))) ||
+
+	(!strncmp(ubuf, "JCXZ", 4) && 
+           (!stackFrame->tECX)) ||
+
+	(!strncmp(ubuf, "JC", 2) && 
+           (stackFrame->tSystemFlags & CF_FLAG)) ||
+
+	(!strncmp(ubuf, "JLE", 3) && 
+           ((stackFrame->tSystemFlags & ZF_FLAG) || 
+           ((stackFrame->tSystemFlags & ~SF_FLAG) != 
+            (stackFrame->tSystemFlags & ~OF_FLAG)))) ||
+
+	(!strncmp(ubuf, "JL", 2) && 
+           ((stackFrame->tSystemFlags & ~SF_FLAG) != 
+            (stackFrame->tSystemFlags & ~OF_FLAG))) ||
+
+	(!strncmp(ubuf, "JMP", 3)) ||
+
+	(!strncmp(ubuf, "JGE", 3) && 
+           ((stackFrame->tSystemFlags & ~SF_FLAG) == 
+            (stackFrame->tSystemFlags & ~OF_FLAG))) ||
+
+	(!strncmp(ubuf, "JG", 2) && 
+           ((!(stackFrame->tSystemFlags & ZF_FLAG)) && 
+            ((stackFrame->tSystemFlags & ~SF_FLAG) == 
+            (stackFrame->tSystemFlags & ~OF_FLAG)))) ||
+
+	(!strncmp(ubuf, "JNBE", 4) && 
+            (!(stackFrame->tSystemFlags & CF_FLAG)) && 
+            (!(stackFrame->tSystemFlags & ZF_FLAG))) ||
+
+	(!strncmp(ubuf, "JNO", 3) && 
+           (!(stackFrame->tSystemFlags & OF_FLAG))) ||
+
+	(!strncmp(ubuf, "JNC", 3) && 
+           (!(stackFrame->tSystemFlags & CF_FLAG))) ||
+
+	(!strncmp(ubuf, "JNZ", 3) && 
+           (!(stackFrame->tSystemFlags & ZF_FLAG))) ||
+
+	(!strncmp(ubuf, "JNS", 3) && 
+           (!(stackFrame->tSystemFlags & SF_FLAG))) ||
+
+	(!strncmp(ubuf, "JO", 2) && 
+           (stackFrame->tSystemFlags & OF_FLAG)) ||
+
+	(!strncmp(ubuf, "JPE", 3) && 
+           (stackFrame->tSystemFlags & PF_FLAG)) ||
+
+	(!strncmp(ubuf, "JPO", 3) && 
+           (!(stackFrame->tSystemFlags & PF_FLAG))) ||
+
+	(!strncmp(ubuf, "JS", 2) && 
+           (stackFrame->tSystemFlags & SF_FLAG)) ||
+
+	(!strncmp(ubuf, "JZ", 2) && 
+           (stackFrame->tSystemFlags & ZF_FLAG)) ||
+
+	(!strncmp(ubuf, "LOOPNE", 6) && 
+           (stackFrame->tECX) && 
+           (!(stackFrame->tSystemFlags & ZF_FLAG))) ||
+
+	(!strncmp(ubuf, "LOOPE", 5) && 
+           (stackFrame->tECX) && 
+           (stackFrame->tSystemFlags & ZF_FLAG)) ||
+
+	(!strncmp(ubuf, "LOOP", 4)))
+    {
+       if (SegmentSize == 32)
+       {
+	  symbolName = GetSymbolFromValueWithOffset(val + va, &sym_offset,
+                                            &symbuf[c][0], MAX_SYMBOL_LEN);
+	  if (symbolName)
+          {
+	     moduleName = GetModuleInfoFromSymbolValue(val + va, &modbuf[c][0], 
+                                                       MAX_SYMBOL_LEN);
+             if (moduleName)
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s|%s+0x%X=%08X %c",  
+                     moduleName, symbolName, 
+                     (unsigned)sym_offset, (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+                else
+	           sprintf(NoNameBuffer, "%s|%s=%08X %c",  
+                     moduleName, symbolName, 
+                     (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+             }
+             else
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s+0x%X=%08X %c", symbolName, 
+                     (unsigned)sym_offset, (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+                else
+	           sprintf(NoNameBuffer, "%s=%08X %c", symbolName, 
+                     (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+             }
+          }
+	  else
+	     sprintf(NoNameBuffer, "%08X %c", 
+                    (unsigned)(val + va),
+		    ((val + va) < va) ? 0x18 : 0x19);
+       }
+       else
+       {
+	  symbolName = GetSymbolFromValueWithOffset(val + va, &sym_offset,
+                                           &symbuf[c][0], MAX_SYMBOL_LEN);
+	  if (symbolName)
+          {
+	     moduleName = GetModuleInfoFromSymbolValue(val + va, &modbuf[c][0],
+                                                       MAX_SYMBOL_LEN);
+             if (moduleName)
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s|%s+0x%X=%08X %c",  
+                     moduleName, symbolName, 
+                     (unsigned)sym_offset, (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+                else
+	           sprintf(NoNameBuffer, "%s|%s=%08X %c",  
+                     moduleName, symbolName, 
+                     (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+             }
+             else
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s+0x%X=%08X %c", symbolName, 
+                     (unsigned)sym_offset, (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+                else
+	           sprintf(NoNameBuffer, "%s=%08X %c", symbolName, 
+                     (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+             }
+          }
+	  else
+	  {
+	     v = val + va;
+	     segment = (((ULONG)v >> 4) & 0x0000FFFF);
+	     offset = ((ULONG)v & 0x0000000F);
+	     sprintf(NoNameBuffer, "%04X:%04X %c", 
+                    (unsigned)segment, (unsigned)offset,
+		    ((val + va) < va) ? 0x18 : 0x19);
+	  }
+       }
+    }
+    else
+    {
+       if (SegmentSize == 32)
+       {
+	  symbolName = GetSymbolFromValueWithOffset(val + va, &sym_offset,
+                                           &symbuf[c][0], MAX_SYMBOL_LEN);
+	  if (symbolName)
+          {
+	     moduleName = GetModuleInfoFromSymbolValue(val + va, &modbuf[c][0],
+                                                       MAX_SYMBOL_LEN);
+             if (moduleName)
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s|%s+0x%X=%08X",  
+                     moduleName, symbolName, 
+                     (unsigned)sym_offset, (unsigned)(val + va));
+                else
+	           sprintf(NoNameBuffer, "%s|%s=%08X",  
+                     moduleName, symbolName, 
+                     (unsigned)(val + va));
+             }
+             else
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s+0x%X=%08X", symbolName, 
+                     (unsigned)sym_offset, (unsigned)(val + va));
+                else
+	           sprintf(NoNameBuffer, "%s=%08X", symbolName, 
+                      (unsigned)(val + va));
+             }
+          }
+	  else
+	     sprintf(NoNameBuffer, "%08X", 
+                     (unsigned)(val + va));
+       }
+       else
+       {
+	  symbolName = GetSymbolFromValueWithOffset(val + va, &sym_offset,
+                                           &symbuf[c][0], MAX_SYMBOL_LEN);
+	  if (symbolName)
+          {
+	     moduleName = GetModuleInfoFromSymbolValue(val + va, &modbuf[c][0],
+                                                       MAX_SYMBOL_LEN);
+             if (moduleName)
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s|%s+0x%X=%08X", 
+                     moduleName, symbolName, 
+                     (unsigned)sym_offset, (unsigned)(val + va));
+                else
+	           sprintf(NoNameBuffer, "%s|%s=%08X", 
+                     moduleName, symbolName, 
+                     (unsigned)(val + va));
+             }
+             else
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s+0x%X=%08X", symbolName, 
+                     (unsigned)sym_offset, (unsigned)(val + va));
+                else
+	           sprintf(NoNameBuffer, "%s=%08X", symbolName, 
+                     (unsigned)(val + va));
+             }
+          }
+	  else
+	  {
+	     v = val + va;
+	     segment = (((ULONG)v >> 4) & 0x0000FFFF);
+	     offset = ((ULONG)v & 0x0000000F);
+	     sprintf(NoNameBuffer, "%04X:%04X", 
+                     (unsigned)segment, (unsigned)offset);
+	  }
+       }
+    }
+    return NoNameBuffer;
+
+}
+
+WORD read_memory(void *addr, void *buf, unsigned len)
+{
+    register ULONG i;
+    register BYTE *s = buf;
+   
+    for (i=0; i < len; i++)
+       if (s)
+          s[i] = (BYTE)mdb_getword((ULONG)((ULONG)addr + i), 1);
+    return 0;
+}
+
+BYTE getbyte(void)
+{
+    short s;
+
+    if (bufp >= bufe)
+    {
+       s = 4;  // byte read window is 4
+       read_memory((void *)VirtualAddress, buf, s);
+       bufe = s;
+       bufp = 0;
+    }
+    VirtualAddress = (void *)((ULONG) VirtualAddress + (ULONG) 1);
+
+    DBGPrint("%02X", buf[bufp]);
+    Columns += 2;
+
+    return buf[bufp++];
+}
+
+WORD modrm(void)
+{
+    if (modrmv == -1)
+      modrmv = getbyte();
+
+    return modrmv;
+}
+
+WORD sib(void)
+{
+    if (sibv == -1)
+      sibv = getbyte();
+
+    return sibv;
+}
+
+void DebugPrint(char *s, ...)
+{
+    char **a = &s;
+
+    vsprintf(ubufp, s, (va_list)(a+1));
+
+    while (*ubufp) ubufp++;
+}
+
+void DebugPutChar(BYTE c)
+{
+    if (c == '\t')
+    {
+      do {
+	*ubufp++ = ' ';
+      } while ((ubufp-ubuf) % 8);
+    }
+    else
+      *ubufp++ = c;
+    *ubufp = 0;
+}
+
+ULONG dereference_address(ULONG addr, ULONG width)
+{
+    register ULONG retCode;
+
+    retCode = mdb_verify_rw((void *)addr, width);
+    if (full_deref_toggle)
+    {
+       switch (retCode)
+       {
+	  case 0:
+	     if (width == 1)
+		DebugPrint("=(*%08X=%02X)", addr, (BYTE)mdb_getword(addr, 1));
+	     else
+	     if (width == 2)
+		DebugPrint("=(*%08X=%04X)", addr, (WORD)mdb_getword(addr, 2));
+	     else
+	     if (width == 4)
+		DebugPrint("=(*%08X=%08X)", addr, (ULONG)mdb_getword(addr, 4));
+	     else
+		DebugPrint("=(*%08X=?)", addr);
+	     return retCode;
+
+	  default:
+	     if (width == 1)
+		DebugPrint("=(*%08X=?)", addr);
+	     else
+	     if (width == 2)
+		DebugPrint("=(*%08X=?)", addr);
+	     else
+	     if (width == 4)
+		DebugPrint("=(*%08X=?)", addr);
+	     else
+		DebugPrint("=(*%08X=?)", addr);
+	     return retCode;
+       }
+    }
+    else
+    {
+       switch (retCode)
+       {
+	  case 0:
+	     if (width == 1)
+		DebugPrint("=%02X", (BYTE)mdb_getword(addr, 1));
+	     else
+	     if (width == 2)
+		DebugPrint("=%04X", (WORD)mdb_getword(addr, 2));
+	     else
+	     if (width == 4)
+		DebugPrint("=%08X", (ULONG)mdb_getword(addr, 4));
+	     else
+		DebugPrint("=?");
+	     return retCode;
+
+	  default:
+	     if (width == 1)
+		DebugPrint("=?");
+	     else
+	     if (width == 2)
+		DebugPrint("=?");
+	     else
+	     if (width == 4)
+		DebugPrint("=?");
+	     else
+		DebugPrint("=?");
+	     return retCode;
+       }
+    }
+
+}
+
+short bytes(char c)
+{
+    switch (c)
+    {
+      case 'b':
+	return 1;
+
+      case 'w':
+	return 2;
+
+      case 'd':
+	return 4;
+
+      case 'v':
+	if (OperandSize == 32)
+	  return 4;
+	else
+	  return 2;
+    }
+    return 0;
+
+}
+
+void OutputHex(char c, short extend, short optional, short defsize,
+	       short sign, long *deref)
+{
+
+    BYTE *fmt, *p;
+    short n=0, s=0, i;
+    long delta;
+    BYTE buf1[6];
+    BYTE *name;
+    BYTE fmt2[16];
+
+    fmt = formats[0][sign];
+
+    if (deref) {};
+
+    switch (c)
+    {
+      case 'a':
+	break;
+
+      case 'b':
+	n = 1;
+	break;
+
+      case 'w':
+	n = 2;
+	break;
+
+      case 'd':
+	n = 4;
+	break;
+
+      case 's':
+	n = 6;
+	break;
+
+      case 'c':
+      case 'v':
+	if (defsize == 32)
+	  n = 4;
+	else
+	  n = 2;
+	break;
+
+      case 'p':
+	if (defsize == 32)
+	  n = 6;
+	else
+	  n = 4;
+	s = 1;
+	break;
+
+      case 'x':
+	return;
+    }
+
+    for (i = 0; i < n; i++)
+       buf1[i] = getbyte();
+
+    for (; i < extend; i++)
+       buf1[i] = (buf[i-1] & 0x80) ? 0xff : 0;
+
+    if (s)
+    {
+       DebugPrint("%02X%02X:", buf1[n-1], buf1[n-2]);
+       n -= 2;
+    }
+    switch (n)
+    {
+       case 1:
+	  delta = *(char *)buf1;
+	  break;
+
+       case 2:
+	  delta = *(short *)buf1;
+	  break;
+
+       case 4:
+	  delta = *(long *)buf1;
+	  break;
+    }
+    if (extend > n)
+    {
+       if (delta || !optional)
+       {
+	  if (extend <= 4)
+	     fmt = formats[extend][sign];
+
+	  if (deref)
+	     *deref += delta;
+
+          p = strchr(fmt, 'z');  
+          if (p)
+          {
+             strcpy(fmt2, fmt); 
+             p = strchr(fmt2, 'z');  
+             if (delta < 0)
+                DebugPrint("-", delta);
+             else
+                DebugPrint("+", delta);
+             *p = 'X';
+             DebugPrint(fmt2, delta);
+          }
+          else
+             DebugPrint(fmt, delta);
+       }
+       return;
+    }
+    if ((n == 4) && sign < 2)
+    {
+       if (deref)
+	  *deref += delta;
+
+       name = output_address((void  *)delta, (unsigned long *) &delta);
+       if (name)
+       {
+	  DebugPrint("%s", name);
+	  if (delta)
+	     DebugPrint("+%X", delta);
+	  return;
+       }
+    }
+    switch (n)
+    {
+
+       case 1:
+	  fmt = formats[n][sign];
+
+          p = strchr(fmt, 'z');  
+          if (p)
+          {
+             strcpy(fmt2, fmt); 
+             p = strchr(fmt2, 'z');  
+             if (delta < 0)
+                DebugPrint("-", delta);
+             else
+                DebugPrint("+", delta);
+             *p = 'X';
+	     DebugPrint(fmt2, (char) delta);
+          }
+          else
+	     DebugPrint(fmt, (char) delta);
+
+	  if (deref)
+	     *deref += (delta & 0xFF);
+
+	  break;
+
+       case 2:
+	  fmt = formats[n][sign];
+
+          p = strchr(fmt, 'z');  
+          if (p)
+          {
+             strcpy(fmt2, fmt); 
+             p = strchr(fmt2, 'z');  
+             if (delta < 0)
+                DebugPrint("-", delta);
+             else
+                DebugPrint("+", delta);
+             *p = 'X';
+	     DebugPrint(fmt2, (unsigned short) delta);
+          }
+          else
+	     DebugPrint(fmt, (unsigned short) delta);
+
+	  if (deref)
+	     *deref += (delta & 0xFFFF);
+
+	  break;
+
+       case 4:
+	  fmt = formats[n][sign];
+
+          p = strchr(fmt, 'z');  
+          if (p)
+          {
+             strcpy(fmt2, fmt); 
+             p = strchr(fmt2, 'z');  
+             if (delta < 0)
+                DebugPrint("-");
+             else
+                DebugPrint("+");
+             *p = 'X';
+	     DebugPrint(fmt2, (unsigned long) delta);
+          }
+          else
+	     DebugPrint(fmt, (unsigned long) delta);
+
+	  if (deref)
+	     *deref += delta;
+
+	  break;
+    }
+
+}
+
+
+void reg_name(short which, char size)
+{
+
+    if (size == 'F')
+    {
+       DebugPrint("ST(%d)", which);
+       return;
+    }
+
+    if (((size == 'v') && (OperandSize == 32)) || (size == 'd'))
+    {
+       DebugPutChar('E');
+    }
+
+    if (size == 'b')
+    {
+       DebugPutChar("ACDBACDB"[which]);
+       DebugPutChar("LLLLHHHH"[which]);
+    }
+    else
+    {
+       DebugPutChar("ACDBSBSD"[which]);
+       DebugPutChar("XXXXPPII"[which]);
+    }
+
+}
+
+
+short do_sib(StackFrame *stackFrame, short m, long *deref)
+{
+
+    long sib_val, istr_val, factor, offset = 0;
+    short pick_signed = DefaultPickSign;
+    short s, i, b, extra=0;
+
+    s = ss(sib());
+    i = indx(sib());
+    b = base(sib());
+    if (b == 5)
+    {
+       if (m == 0)
+       {
+	  if (deref)
+	     *deref = 0;
+	  ProcessInstruction(stackFrame, "%p:[");
+	  OutputHex('d', pSize, 0, AddressSize, 1, deref);
+       }
+       else
+       {
+
+	  if (debug_deref && stackFrame)
+	     DebugPrint("<EBP=%08X>", stackFrame->tEBP);
+
+	  if (deref && stackFrame)
+	     *deref += stackFrame->tEBP;
+	  ProcessInstruction(stackFrame, "%p:[EBP");
+	  pick_signed |= 2;
+       }
+    }
+    else
+    {
+       pick_signed |= 2;
+       sib_val = sib_get_value(b, stackFrame);
+
+       if (debug_deref)
+	  DebugPrint("<sib=%08X>", sib_val);
+
+       if (deref)
+	  *deref += sib_val;
+
+       ProcessInstruction(stackFrame, sib_str[b]);
+       if ((b == i) && (b != 4) && (i != 5))
+	  extra = 1;
+    }
+    if (extra == 0)
+    {
+       pick_signed |= 2;
+       istr_val = istr_get_value(i, stackFrame);
+
+       if (debug_deref)
+	  DebugPrint("<istr=%08X>", istr_val);
+
+       offset += istr_val;
+
+       DebugPrint(i_str[i]);
+    }
+
+    if (i != 4 && s)
+    {
+       DebugPrint("*%X", (1 << s) + extra);
+       factor = (1 << s) + extra;
+
+       if (debug_deref)
+	  DebugPrint("<factor=%08X>", factor);
+
+       offset = (offset * factor);
+    }
+
+    if (deref)
+       *deref += offset;
+
+    return pick_signed;
+
+}
+
+
+void do_modrm(StackFrame *stackFrame, char t)
+{
+
+    long reg_val;
+    short m = mod(modrm());
+    short r = rm(modrm());
+    short extend = (AddressSize == 32) ? 4 : 2;
+    short pick_signed = DefaultPickSign;
+
+    if (t == 'b')
+       pSize = 1;
+    else
+    if (t == 'v' && OperandSize == 32)
+       pSize = 4;
+    else
+    if (t == 'v' && OperandSize == 16)
+       pSize = 2;
+
+    if (m == 3)
+    {
+       reg_name(r, t);
+       return;
+    }
+    if ((m == 0) && (r == 5) && (AddressSize == 32))
+    {
+       DeRefValue = 0;
+       ProcessInstruction(stackFrame, "%p:[");
+       OutputHex('d', extend, 0, AddressSize, 0, (long *) &DeRefValue);
+       DebugPutChar(']');
+       dereference_address(DeRefValue, pSize);
+       return;
+    }
+    if ((m == 0) && (r == 6) && (AddressSize == 16))
+    {
+       DeRefValue = 0;
+       ProcessInstruction(stackFrame, "%p:[");
+       OutputHex('w', extend, 0, AddressSize, 0, (long *) &DeRefValue);
+       DebugPutChar(']');
+       dereference_address(DeRefValue, pSize);
+       return;
+    }
+    if ((AddressSize != 32) || (r != 4))
+    {
+       DeRefValue = 0;
+       ProcessInstruction(stackFrame, "%p:[");
+    }
+
+    if (AddressSize == 16)
+    {
+       DebugPrint(r_str[r]);
+       pick_signed |= 2;
+    }
+    else
+    {
+       DeRefValue = 0;
+       if (r == 4)
+	  pick_signed |= do_sib(stackFrame, m, (long *)&DeRefValue);
+       else
+       {
+	  reg_val = reg_get_value(r, stackFrame);
+	  DeRefValue += reg_val;
+
+	  if (debug_deref)
+	     DebugPrint("<%s=%08X>", reg_names[2][r], reg_val);
+
+	  DebugPrint(reg_names[2][r]);
+	  pick_signed |= 2;
+       }
+    }
+    MODRMExtend = extend;
+    OutputHex("xbv"[m], extend, 1, AddressSize, pick_signed, (long *) &DeRefValue);
+    DebugPutChar(']');
+    dereference_address(DeRefValue, pSize);
+
+}
+
+
+void floating_point(StackFrame *stackFrame, short e1)
+{
+
+    short esc = e1 * 8 + reg(modrm());
+
+    if (mod(modrm()) == 3)
+    {
+       if (fspecial[esc])
+       {
+	  if (fspecial[esc][0] && (fspecial[esc][0][0] == '*'))
+	  {
+	     ProcessInstruction(stackFrame, fspecial[esc][0]+1);
+	  }
+	  else
+	  {
+	     ProcessInstruction(stackFrame, fspecial[esc][rm(modrm())]);
+	  }
+       }
+       else
+       {
+	  ProcessInstruction(stackFrame, floatops[esc]);
+	  ProcessInstruction(stackFrame, " %EF");
+       }
+    }
+    else
+    {
+       ProcessInstruction(stackFrame, floatops[esc]);
+       ProcessInstruction(stackFrame, " %EF");
+    }
+}
+
+
+void percent(StackFrame *stackFrame, char c, BYTE **tptr)
+{
+
+     long vofs, delta;
+     BYTE *name;
+     short default_signed = DefaultPickSign;
+     char t = *(*tptr)++, it;
+     short extend = (AddressSize == 32) ? 4 : 2;
+     short iextend;
+
+     if (c != '+')
+     {
+	if (t == '-')
+	{
+	   default_signed = 1;
+	   t = *(*tptr)++;
+	}
+	else if (t == '+')
+	{
+	   default_signed = 2;
+	   t = *(*tptr)++;
+	}
+     }
+     switch (c)
+     {
+
+	case 'A':
+	   OutputHex(t, extend, 0, AddressSize, 0, 0);
+	   break;
+
+	case 'C':
+	   DebugPrint("CR%d", reg(modrm()));
+	   break;
+
+	case 'D':
+	   DebugPrint("DR%d", reg(modrm()));
+	   break;
+
+	case 'E':
+	   do_modrm(stackFrame, t);
+	   break;
+
+	case 'G':
+	   if (t == 'F')
+	      reg_name(rm(modrm()), t);
+	   else
+	      reg_name(reg(modrm()), t);
+	   break;
+
+	case 'I':
+	   switch (t)
+	   {
+	      case 'b':
+		 iextend = 1;
+		 it = *(*tptr)++;
+		 OutputHex(it, iextend, 0, OperandSize, default_signed, 0);
+		 break;
+
+	      case 'v':
+		 iextend = extend;
+		 it = *(*tptr)++;
+		 OutputHex(it, iextend, 0, OperandSize, default_signed, 0);
+		 break;
+
+	      default:
+		 iextend = 0;
+		 OutputHex(t, iextend, 0, OperandSize, default_signed, 0);
+		 break;
+	   }
+	   break;
+
+	case 'J':
+	   switch (bytes(t))
+	   {
+
+	      case 1:
+		 vofs = (char) getbyte();
+		 break;
+
+	      case 2:
+		 vofs = getbyte();
+		 vofs += getbyte() << 8;
+		 vofs = (int) vofs;
+		 break;
+
+	      case 4:
+		 vofs = (long)getbyte();
+		 vofs |= (long)getbyte() << 8;
+		 vofs |= (long)getbyte() << 16;
+		 vofs |= (long)getbyte() << 24;
+		 break;
+
+	      default:
+		 vofs = 0;	/* To avoid uninit error */
+	   }
+
+	   name = output_jmp_address(stackFrame, vofs, (long *) &delta);
+	   DebugPrint("%s", name);
+
+	   if (delta)
+	      DebugPrint("+%X (%X %c)", delta, ((long)vofs + 
+                        (long)VirtualAddress),
+   		        (vofs & 0x80000000UL) ? 0x1e : 0x1f);
+	   break;
+
+	case 'M':
+	   do_modrm(stackFrame, t);
+	   break;
+
+	case 'O':
+	   if (t == 'b')
+	      pSize = 1;
+	   else
+	   if (t == 'v' && OperandSize == 32)
+	      pSize = 4;
+	   else
+	   if (t == 'v' && OperandSize == 16)
+	      pSize = 2;
+	   DeRefValue = 0;
+	   ProcessInstruction(stackFrame, "%p:[");
+	   OutputHex(t, extend, 0, AddressSize, 0, (long *) &DeRefValue);
+	   DebugPutChar(']');
+	   dereference_address(DeRefValue, pSize);
+	   break;
+
+	case 'R':
+	   do_modrm(stackFrame, t);
+	   break;
+
+	case 'S':
+	   DebugPutChar("ECSDFG"[reg(modrm())]);
+	   DebugPutChar('S');
+	   break;
+
+	case 'T':
+	   DebugPrint("TR%d", reg(modrm()));
+	   break;
+
+	case 'X':
+	   if (t == 'b')
+	      pSize = 1;
+	   else
+	   if (t == 'v' && OperandSize == 32)
+	      pSize = 4;
+	   else
+	   if (t == 'v' && OperandSize == 16)
+	      pSize = 2;
+	   DebugPrint("DS:[");
+	   if (AddressSize == 32)
+	      DebugPutChar('E');
+	   DebugPrint("SI");
+	   if (AddressSize==32 && stackFrame)
+	      DebugPrint("=%08X", stackFrame->tESI);
+	   DebugPutChar(']');
+
+	   if (debug_deref && stackFrame)
+	      DebugPrint("<ESI=%08X>", stackFrame->tESI);
+
+           if (stackFrame)
+	      dereference_address(stackFrame->tESI, pSize);
+	   break;
+
+	case 'Y':
+	   if (t == 'b')
+	      pSize = 1;
+	   else
+	   if (t == 'v' && OperandSize == 32)
+	      pSize = 4;
+	   else
+	   if (t == 'v' && OperandSize == 16)
+	      pSize = 2;
+	   DebugPrint("ES:[");
+	   if (AddressSize == 32)
+	      DebugPutChar('E');
+	   DebugPrint("DI");
+	   if (AddressSize==32 && stackFrame)
+	      DebugPrint("=%08X", stackFrame->tEDI);
+	   DebugPutChar(']');
+
+	   if (debug_deref && stackFrame)
+	      DebugPrint("<EDI=%08X>", stackFrame->tEDI);
+
+           if (stackFrame)
+	      dereference_address(stackFrame->tEDI, pSize);
+	   break;
+
+	case '2':
+	   ProcessInstruction(stackFrame, second[getbyte()]);
+	   break;
+
+	case 'e':
+	   if (OperandSize == 32)
+	   {
+	      if (t == 'w')
+		 DebugPutChar('D');
+	      else
+	      {
+		 DebugPutChar('E');
+		 DebugPutChar(toupper(t));
+	      }
+	   }
+	   else
+	      DebugPutChar(toupper(t));
+	   break;
+
+	case 'f':
+	   floating_point(stackFrame, t - '0');
+	   break;
+
+	case 'g':
+	   ProcessInstruction(stackFrame, groups[t - '0'][reg(modrm())]);
+	   break;
+
+	case 'p':
+	   switch (t)
+	   {
+	      case 'c':
+	      case 'd':
+	      case 'e':
+	      case 'f':
+	      case 'g':
+	      case 's':
+		 Prefix = t;
+		 ProcessInstruction(stackFrame, opmap1[getbyte()]);
+		 break;
+
+	      case ':':
+		 if (Prefix)
+		    DebugPrint("%cS:", toupper(Prefix));
+		 break;
+
+	      case ' ':
+		 ProcessInstruction(stackFrame, opmap1[getbyte()]);
+		 break;
+
+	   }
+	   break;
+
+	case 's':
+	   switch (t)
+	   {
+	      case 'a':
+		 AddressSize = 48 - AddressSize;
+		 ProcessInstruction(stackFrame, opmap1[getbyte()]);
+		 break;
+
+	      case 'o':
+		 OperandSize = 48 - OperandSize;
+		 ProcessInstruction(stackFrame, opmap1[getbyte()]);
+		 break;
+	   }
+	   break;
+
+	case '+':
+	   switch (t)
+	   {
+
+	      case '-':
+		 DefaultPickSign = 1;
+		 break;
+
+	      case '+':
+		 DefaultPickSign = 2;
+		 break;
+
+	      default:
+		 DefaultPickSign = 0;
+		 break;
+	   }
+     }
+}
+
+ULONG nestLevel = 0;
+
+void ProcessInstruction(StackFrame *stackFrame, BYTE *s)
+{
+
+     short c;
+
+     nestLevel++;
+     if (nestLevel > 5)
+     {
+	DebugPrint("<INVALID OPCODE [NESTED]>");
+	if (nestLevel)
+	   nestLevel--;
+	return;
+     }
+
+     if (s == 0)
+     {
+	DebugPrint("<INVALID OPCODE>");
+	if (nestLevel)
+	   nestLevel--;
+	return;
+     }
+
+     while ((c = *s++) != 0)
+     {
+	if (c == '%')
+	{
+	   c = *s++;
+	   percent(stackFrame, c, &s);
+	}
+	else
+	if (c == ' ')
+	   DebugPutChar('\t');
+	else
+	   DebugPutChar(c);
+     }
+     if (nestLevel)
+	nestLevel--;
+
+}
+
+ULONG unassemble(StackFrame *stackFrame, ULONG ip, ULONG use, ULONG *ret)
+{
+
+    long delta;
+    long segment, offset;
+    BYTE *v = (BYTE *) ip;
+
+    if (use)
+       SegmentSize = 32;
+    else
+       SegmentSize = 16;
+
+    DefaultPickSign = 0;
+    needs_proceed = 0;
+    nestLevel = 0;
+    pSize = 4;
+
+    output_address((void *)v, (unsigned long *) &delta);
+
+    if (SegmentSize == 32)
+    {
+       DBGPrint("%08X ", (unsigned)v);
+    }
+    else
+    {
+       segment = (((ULONG)v >> 4) & 0x0000FFFF);
+       offset = ((ULONG)v & 0x0000000F);
+       DBGPrint("%04X:%04X ", (unsigned)segment, (unsigned)offset);
+    }
+
+    Prefix = 0;
+    modrmv = sibv = -1;
+    OperandSize = AddressSize = SegmentSize;
+    VirtualAddress = (void *)v;
+    bufp = bufe = 0;
+    Columns = 0;
+    ubufp = ubuf;
+    ProcessInstruction(stackFrame, opmap1[getbyte()]);
+
+    do
+    {
+       DBGPrint(" ");
+       Columns++;
+    } while (Columns < 15);
+
+    Columns += strlen(ubuf);
+
+    do
+    {
+       DebugPutChar(' ');
+       Columns++;
+    } while (Columns < 43);
+
+    if (ret)
+       *ret = (ULONG)VirtualAddress;    
+
+    if (DBGPrint("%s\n", ubuf)) return 1;
+
+    //
+    //  check for CALL, REP, INT, and LOOP instructions for proceed
+    //  breakpoint
+    //
+
+    if ((strncmp(ubuf, "CALL", 4) == 0) || (strncmp(ubuf, "REP", 3) == 0) ||
+	(strncmp(ubuf, "INT", 3) == 0)  || (strncmp(ubuf, "LOOP", 4) == 0))
+       needs_proceed = 1;
+
+    return (ULONG) 0;
+
+}
+
+int mdb_unasm_length(void *ip, int use)
+{
+    BYTE *oldVAddress; 
+    BYTE *v = (BYTE *) ip;
+
+    if (use)
+       SegmentSize = 32;
+    else
+       SegmentSize = 16;
+
+    DefaultPickSign = 0;
+    needs_proceed = 0;
+    nestLevel = 0;
+    pSize = 4;
+
+    Prefix = 0;
+    modrmv = sibv = -1;
+    OperandSize = AddressSize = SegmentSize;
+    oldVAddress = VirtualAddress = (void *)v;
+    bufp = bufe = 0;
+    Columns = 0;
+    ubufp = ubuf;
+    ProcessInstruction(NULL, opmap1[getbyte()]);
+
+    return (int)((ULONG)VirtualAddress - (ULONG)oldVAddress);    
+
+}
+
+#endif
diff -Naur ./debug/mdb-ia32.c ../linux-2.6.18-mdb/./debug/mdb-ia32.c
--- ./debug/mdb-ia32.c	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-ia32.c	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,6012 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-IA32.C
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#include "mdb.h"
+
+#ifdef CONFIG_MDB
+
+ULONG MajorVersion = 8;
+ULONG MinorVersion = 8;
+ULONG BuildVersion = 8;
+
+extern ULONG needs_proceed;
+extern ULONG general_toggle;
+extern ULONG line_info_toggle;
+extern ULONG control_toggle;
+extern ULONG segment_toggle;
+extern ULONG numeric_toggle;
+extern ULONG reason_toggle;
+
+BYTE *IA32Flags[]=
+{
+   "CF", 0, "PF", 0, "AF",    0, "ZF", "SF", "TF", "IF", "DF", "OF",
+   0,    0, "NT", 0, "RF", "VM", "AC", "VIF","VIP","ID",    0,    0,
+   0,
+};
+
+BYTE *BreakDescription[]=
+{
+   "EXECUTE",  "WRITE",  "IOPORT",  "READ/WRITE",
+};
+
+BYTE *BreakLengthDescription[]={
+   ": 1 BYTE",  ": 2 BYTE",  ": ??????",  ": 4 BYTE",
+};
+
+BYTE *ExceptionDescription[]={
+   "Divide By Zero",                 //  0
+   "Debugger Exception (INT1)",      //  1
+   "Non-Maskable Interrupt",         //  2
+   "Debugger Breakpoint (INT3)",     //  3
+   "Overflow Exception",             //  4
+   "Bounds Check",                   //  5
+   "Invalid Opcode",                 //  6
+   "No Coprocessor",                 //  7
+   "Double Fault",                   //  8
+   "Cops Error",                     //  9
+   "Invalid Task State Segment",     //  10
+   "Segment Not Present",            //  11
+   "Stack Exception",                //  12
+   "General Protection",             //  13
+   "Page Fault",                     //  14
+   "InvalidInterrupt",               //  15
+   "Coprocessor Error",              //  16
+   "AlignmentCheck",                 //  17
+   "Machine Check",                  //  18
+   "Enter Debugger Request",         //  19
+   "Unvectored Exception",           //  20
+   "Directed NMI Breakpoint",        //  21
+   "Panic"                           //  22
+};
+ULONG exceptions = (sizeof(ExceptionDescription) / sizeof(BYTE *));
+
+BYTE char32spc[] = { "xxxxxxxxxxxxxxxxxxxxxxxx " };
+BYTE flset[] = { "VMRF  NT    OFDNIETFMIZR  AC  PE  CY" };
+BYTE floff[] = { "              UPID  PLNZ      PO  NC" };
+BYTE fluse[] = { 1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,0,1 };
+NUMERIC_FRAME npx[MAX_PROCESSORS];
+
+ULONG MTRR_BASE_REGS[] = {
+  MTRR_PHYS_BASE_0, MTRR_PHYS_BASE_1, MTRR_PHYS_BASE_2, MTRR_PHYS_BASE_3,
+  MTRR_PHYS_BASE_4, MTRR_PHYS_BASE_5, MTRR_PHYS_BASE_6, MTRR_PHYS_BASE_7
+};
+
+ULONG MTRR_MASK_VALUES[] = {
+  MTRR_PHYS_MASK_0, MTRR_PHYS_MASK_1, MTRR_PHYS_MASK_2, MTRR_PHYS_MASK_3,
+  MTRR_PHYS_MASK_4, MTRR_PHYS_MASK_5, MTRR_PHYS_MASK_6, MTRR_PHYS_MASK_7
+};
+
+
+
+StackFrame ReferenceFrame[MAX_PROCESSORS];
+
+typedef struct _RLOCK 
+{
+#if defined(CONFIG_SMP)
+    spinlock_t lock;
+#endif
+    long flags;
+    int processor;
+    int count;    
+} rlock_t;
+
+#define PROCESSOR_INACTIVE    0 
+#define PROCESSOR_ACTIVE      1 
+#define PROCESSOR_SUSPEND     2
+#define PROCESSOR_RESUME      3
+#define PROCESSOR_DEBUG       4
+#define PROCESSOR_SHUTDOWN    5
+#define PROCESSOR_IPI         6
+#define PROCESSOR_SWITCH      7
+#define PROCESSOR_HOLD        8
+
+#define PIC1_DEBUG_MASK    0xFC
+#define PIC2_DEBUG_MASK    0xFF
+
+#define  MAX_PICS             3
+#define  PIC_0             0x20
+#define  PIC_1             0xA0
+#define  PIC_2             0x30
+#define  MASK_0            0x21
+#define  MASK_1            0xA1
+#define  MASK_2            0x31
+
+BYTE irq_control[MAX_PICS] = { PIC_0, PIC_1, PIC_2 };
+BYTE irq_mask[MAX_PICS] = { MASK_0, MASK_1, MASK_2 };
+BYTE mask_value[MAX_PICS] = { 0xF8, 0xFF, 0xFF }; 
+
+#if defined(CONFIG_SMP)
+volatile rlock_t debug_mutex = { SPIN_LOCK_UNLOCKED, 0, -1, 0 };
+#else
+volatile rlock_t debug_mutex = { 0, -1, 0 };
+#endif
+
+volatile ULONG debuggerActive = 0;
+volatile ULONG ProcessorHold[MAX_PROCESSORS];
+volatile ULONG ProcessorState[MAX_PROCESSORS];
+volatile ULONG ProcessorMode[MAX_PROCESSORS];
+
+BYTE *procState[]={
+   "PROCESSOR_INACTIVE", "PROCESSOR_ACTIVE  ", "PROCESSOR_SUSPEND ",
+   "PROCESSOR_RESUME  ", "PROCESSOR_DEBUG   ", "PROCESSOR_SHUTDOWN", 
+   "PROCESSOR_IPI     ", "PROCESSOR_SWITCH  ", "PROCESSOR_HOLD    ", 
+   "?                 ", "?                 ", "?                 ", 
+   "?                 ", "?                 ", "?                 ", 
+   "?                 " 
+};
+
+// debugger commands
+
+DEBUGGER_PARSER backTraceAllPidPE = { 
+0, 0, backTraceAllPID, backTraceHelp, 0, "BTA", 0, 0,
+"display stack backtrace for all processes" , 0 };
+
+DEBUGGER_PARSER backTracePidPE = {
+0, 0, backTracePID, backTraceHelp, 0, "BTP", 0, 0,
+"display stack backtrace by pid" , 0 };
+
+DEBUGGER_PARSER backTraceStackPE = {
+0, 0, backTraceStack, backTraceHelp, 0, "BT", 0, 0,
+"display stack backtrace by address" , 0 };
+ 
+DEBUGGER_PARSER uFramePE = {
+0, 0, dump_uf, 0, 0, "UF", 0, 0,
+"display task eframe contents" , 0 };
+
+DEBUGGER_PARSER eFramePE = {
+0, 0, dump_ef, 0, 0, "EF", 0, 0,
+"display eframe contents" , 0 };
+
+DEBUGGER_PARSER cpuFramePE = {
+0, 0, listProcessorFrame, processorCommandHelp, 0, "LR", 0, 0,
+"display cpu registers" , 0 };
+
+DEBUGGER_PARSER ProcessorPE = {
+0, 0, displayProcessorStatus, displayProcessorStatusHelp, 0, "PROCESSORS", 0, 0,
+"display processor status" , 0 };
+
+DEBUGGER_PARSER HPE = {
+0, 0, displayDebuggerHelp, displayDebuggerHelpHelp, 0, "HELP", 0, 0,
+"this help screen (type HELP <command> for specific help)" , 0 };
+
+DEBUGGER_PARSER HelpPE = {
+0, 0, displayDebuggerHelp, displayDebuggerHelpHelp, 0, "H", 0, 0,
+"this help screen" , 0 };
+
+DEBUGGER_PARSER clearScreenPE = {
+0, 0, clearDebuggerScreen, clearScreenHelp, 0, "CLS", 0, 0,
+"clear the screen" , 0 };
+
+DEBUGGER_PARSER asciiTablePE = {
+0, 0, displayASCTable, ascTableHelp, 0, "A", 0, 0,
+"display ASCII Table" , 0 };
+
+DEBUGGER_PARSER TUTogglePE = {
+0, 0, ProcessTUToggle, displayToggleHelp, 0, ".TU", 0, 0,
+"toggles unasm debug display (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TDTogglePE = {
+0, 0, ProcessTDToggle, displayToggleHelp, 0, ".TD", 0, 0,
+"toggles full dereference display (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TLTogglePE = {
+0, 0, ProcessTLToggle, displayToggleHelp, 0, ".TL", 0, 0,
+"toggles source line display (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TGTogglePE = {
+0, 0, ProcessTGToggle, displayToggleHelp, 0, ".TG", 0, 0,
+"toggles general registers (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TCTogglePE = {
+0, 0, ProcessTCToggle, displayToggleHelp, 0, ".TC", 0, 0,
+"toggles control registers (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TNTogglePE = {
+0, 0, ProcessTNToggle, displayToggleHelp, 0, ".TN", 0, 0,
+"toggles coprocessor registers (ON | OFF)"  , 0 };
+
+DEBUGGER_PARSER TRTogglePE = {
+0, 0, ProcessTRToggle, displayToggleHelp, 0, ".TR", 0, 0,
+"toggles display of break reason (ON | OFF)"  , 0 };
+
+DEBUGGER_PARSER TSTogglePE = {
+0, 0, ProcessTSToggle, displayToggleHelp, 0, ".TS", 0, 0,
+"toggles segment registers (ON | OFF)"  , 0 };
+
+DEBUGGER_PARSER TATogglePE = {
+0, 0, ProcessTAToggle, displayToggleHelp, 0, ".TA", 0, 0,
+"toggles all registers (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER ReasonPE = {
+0, 0, ReasonDisplay, ReasonHelp, 0, ".A", 0, 0,
+"display break reason" , 0 };
+
+DEBUGGER_PARSER TTogglePE = {
+0, 0, TSSDisplay, TSSDisplayHelp, 0, ".T", 0, 0,
+"display task state segment (tss)" , 0 };
+
+DEBUGGER_PARSER versionPE = {
+0, 0, DisplayDebuggerVersion, displayDebuggerVersionHelp, 0, ".V", 0, 0,
+"display version info" , 0 };
+
+#if defined(CONFIG_MODULES)
+DEBUGGER_PARSER lsmodPE1 = {
+0, 0, listModules, listModulesHelp, 0, ".M", 0, 0,
+"list loaded modules" , 0 };
+
+DEBUGGER_PARSER lsmodPE2 = {
+0, 0, listModules, listModulesHelp, 0, "LSMOD", 0, 0,
+"list loaded modules" , 0 };
+
+DEBUGGER_PARSER rmmodPE = {
+0, 0, unloadModule, listModulesHelp, 0, "RMMOD", 0, 0,
+"unload module" , 0 };
+#endif
+
+DEBUGGER_PARSER rebootPE = {
+0, 0, rebootSystem, rebootSystemHelp, 0, "REBOOT", 0, 0,
+"reboot host system" , 0 };
+
+DEBUGGER_PARSER KernelProcessPE1 = {
+0, 0, displayKernelProcess, displayKernelProcessHelp, 0, ".P", 0, 0,
+"display kernel processes" , 0 };
+
+DEBUGGER_PARSER KernelProcessPE2 = {
+0, 0, displayKernelProcess, displayKernelProcessHelp, 0, "PS", 0, 0,
+"display kernel processes" , 0 };
+
+/*
+DEBUGGER_PARSER SectionPE1 = {
+0, 0, displaySections, displaySectionsHelp, 0, ".S", 0, 0,
+"display kernel/module sections" , 0 };
+
+DEBUGGER_PARSER SectionPE2 = {
+0, 0, displaySections, displaySectionsHelp, 0, "SECTIONS", 0, 0,
+"display kernel/module sections" , 0 };
+*/
+
+DEBUGGER_PARSER AllSymbolsPE = {
+0, 0, displaySymbols, displaySymbolsHelp, 0, "SYMBOL", 0, 0,
+"display symbol(s)" , 0 };
+
+DEBUGGER_PARSER SymbolsPE = {
+0, 0, displaySymbols, displaySymbolsHelp, 0, ".Z", 0, 0,
+"display symbol(s)" , 0 };
+
+DEBUGGER_PARSER ControlPE = {
+0, 0, displayControlRegisters, displayRegistersHelp, 0, "RC", 0, 0,
+"display control registers" , 0 };
+
+DEBUGGER_PARSER AllPE = {
+0, 0, displayAllRegisters, displayRegistersHelp, 0, "RA", 0, 0,
+"display all registers" , 0 };
+
+DEBUGGER_PARSER SegmentPE = {
+0, 0, displaySegmentRegisters, displayRegistersHelp, 0, "RS", 0, 0,
+"display segment registers" , 0 };
+
+DEBUGGER_PARSER NumericPE = {
+0, 0, displayNumericRegisters, displayRegistersHelp, 0, "RN", 0, 0,
+"display coprocessor/MMX registers" , 0 };
+
+DEBUGGER_PARSER GeneralPE = {
+0, 0, displayGeneralRegisters, displayRegistersHelp, 0, "RG", 0, 0,
+"display general registers" , 0 };
+
+DEBUGGER_PARSER DefaultPE = {
+0, 0, displayDefaultRegisters, displayRegistersHelp, 0, "R", 0, 0,
+"display registers for a processor" , 0 };
+
+DEBUGGER_PARSER SearchMemoryBPE = {
+0, 0, SearchMemoryB, SearchMemoryHelp, 0, "SB", 0, 0,
+"search memory for pattern (bytes)"  , 0 };
+
+DEBUGGER_PARSER SearchMemoryWPE = {
+0, 0, SearchMemoryW, SearchMemoryHelp, 0, "SW", 0, 0,
+"search memory for pattern (words)"  , 0 };
+
+DEBUGGER_PARSER SearchMemoryDPE = {
+0, 0, SearchMemoryD, SearchMemoryHelp, 0, "SD", 0, 0,
+"search memory for pattern (dwords)"  , 0 };
+
+DEBUGGER_PARSER ChangeWordPE = {
+0, 0, changeWordValue, changeMemoryHelp, 0, "CW", 0, 0,
+"change words at address"  , 0 };
+
+DEBUGGER_PARSER ChangeDoublePE = {
+0, 0, changeDoubleValue, changeMemoryHelp, 0, "CD", 0, 0,
+"change dwords at address"  , 0 };
+
+DEBUGGER_PARSER ChangeBytePE = {
+0, 0, changeByteValue, changeMemoryHelp, 0, "CB", 0, 0,
+"change bytes at address"  , 0 };
+
+DEBUGGER_PARSER ChangeDefaultPE = {
+0, 0, changeDefaultValue, changeMemoryHelp, 0, "C", 0, 0,
+"change bytes at address"  , 0 };
+
+DEBUGGER_PARSER CloseSymbolsPE = {
+0, 0, displayCloseSymbols, displayCloseHelp, 0, "?", 0, 0,
+"display closest symbols to <address>" , 0 };
+
+DEBUGGER_PARSER WalkPE = {
+0, 0, debuggerWalkStack, displayDumpHelp, 0, "W", 0, 0,
+"display symbols on the stack"  , 0 };
+
+DEBUGGER_PARSER DumpLinkedPE = {
+0, 0, debuggerDumpLinkedList, displayDumpHelp, 0, "DL", 0, 0,
+"dump linked list"  , 0 };
+
+DEBUGGER_PARSER DumpWordPE = {
+0, 0, debuggerDumpWord, displayDumpHelp, 0, "DW", 0, 0,
+"dump memory as words"  , 0 };
+
+DEBUGGER_PARSER DumpStackPE = {
+0, 0, debuggerDumpStack, displayDumpHelp, 0, "DS", 0, 0,
+"dump stack"  , 0 };
+
+DEBUGGER_PARSER DumpDoubleStackPE = {
+0, 0, debuggerDumpDoubleStack, displayDumpHelp, 0, "DDS", 0, 0,
+"dump stack double word"  , 0 };
+
+DEBUGGER_PARSER DumpDoublePE = {
+0, 0, debuggerDumpDouble, displayDumpHelp, 0, "DD", 0, 0,
+"dump memory as double words" , 0 };
+
+DEBUGGER_PARSER DumpBytePE = {
+0, 0, debuggerDumpByte, displayDumpHelp, 0, "DB", 0, 0,
+"dump memory as bytes"  , 0 };
+
+DEBUGGER_PARSER DumpDefaultPE = {
+0, 0, debuggerDumpByte, displayDumpHelp, 0, "D", 0, 0,
+"dump memory as bytes"  , 0 };
+
+DEBUGGER_PARSER Diss16PE = {
+0, 0, processDisassemble16, displayDisassembleHelp, 0, "UU", 0, 0,
+"unassemble code (16-bit)" , 0 };
+
+DEBUGGER_PARSER Diss32PE = {
+0, 0, processDisassemble32, displayDisassembleHelp, 0, "U", 0, 0,
+"unassemble code (32-bit)"  , 0 };
+
+DEBUGGER_PARSER Id32PE = {
+0, 0, processDisassemble32, displayDisassembleHelp, 0, "ID", 0, 0,
+"unassemble code (32-bit)"  , 0 };
+
+DEBUGGER_PARSER ProceedPE = {
+0, 0, processProceed, executeCommandHelp, 0, "P", 0, 0,
+"proceed"  , -1 };
+
+DEBUGGER_PARSER TracePE = {
+0, 0, processTrace, executeCommandHelp, 0, "T", 0, 0,
+"trace"  , -1 };
+
+DEBUGGER_PARSER SingleStepPE = {
+0, 0, processTrace, executeCommandHelp, 0, "S", 0, 0,
+"single step"  , -1 };
+
+DEBUGGER_PARSER TraceSSPE = {
+0, 0, processTrace, executeCommandHelp, 0, "SS", 0, 0,
+"single step"  , -1 };
+
+DEBUGGER_PARSER TraceSSBPE = {
+0, 0, processTraceSSB, executeCommandHelp, 0, "SSB", 0, 0,
+"single step til branch", -1 };
+
+DEBUGGER_PARSER GPE = {
+0, 0, processGo, executeCommandHelp, 0, "G", 0, 0,
+"g or g til <address> match"  , -1 };
+
+DEBUGGER_PARSER GoPE = {
+0, 0, processGo, executeCommandHelp, 0, "GO", 0, 0,
+"go or go til <address> match"  , -1 };
+
+DEBUGGER_PARSER QPE = {
+0, 0, processGo, executeCommandHelp, 0, "Q", 0, 0,
+"quit debugger until <address> match"  , -1 };
+
+DEBUGGER_PARSER XPE = {
+0, 0, processGo, executeCommandHelp, 0, "X", 0, 0,
+"exit debugger until <address> match"  , -1 };
+
+DEBUGGER_PARSER BreakProcessorPE = {
+0, 0, breakProcessor, processorCommandHelp, 0, "CPU", 0, 0,
+"switch processor"  , -1 };
+
+DEBUGGER_PARSER ListProcessorsPE = {
+0, 0, listProcessors, processorCommandHelp, 0, "LCPU", 0, 0,
+"list processors"  , 0 };
+
+DEBUGGER_PARSER EAXPE = {
+0, 0, ChangeEAXRegister, displayEAXHelp, 0, "EAX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ORIGEAXPE = {
+0, 0, ChangeORIGEAXRegister, displayEAXHelp, 0, "ORGEAX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EBXPE = {
+0, 0, ChangeEBXRegister, displayEBXHelp, 0, "EBX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ECXPE = {
+0, 0, ChangeECXRegister, displayECXHelp, 0, "ECX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EDXPE = {
+0, 0, ChangeEDXRegister, displayEDXHelp, 0, "EDX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ESIPE = {
+0, 0, ChangeESIRegister, displayESIHelp, 0, "ESI", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EDIPE = {
+0, 0, ChangeEDIRegister, displayEDIHelp, 0, "EDI", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EBPPE = {
+0, 0, ChangeEBPRegister, displayEBPHelp, 0, "EBP", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ESPPE = {
+0, 0, ChangeESPRegister, displayESPHelp, 0, "ESP", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EIPPE = {
+0, 0, ChangeEIPRegister, displayEIPHelp, 0, "EIP", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER CSPE = {
+0, 0, ChangeCSRegister, displayCSHelp, 0, "XCS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER DSPE = {
+0, 0, ChangeDSRegister, displayDSHelp, 0, "XDS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ESPE = {
+0, 0, ChangeESRegister, displayESHelp, 0, "XES", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER FSPE = {
+0, 0, ChangeFSRegister, displayFSHelp, 0, "XFS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER GSPE = {
+0, 0, ChangeGSRegister, displayGSHelp, 0, "XGS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER SSPE = {
+0, 0, ChangeSSRegister, displaySSHelp, 0, "XSS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER RFPE = {
+0, 0, ChangeRFFlag, displayRFHelp, 0, "RF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER TFPE = {
+0, 0, ChangeTFFlag, displayTFHelp, 0, "TF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ZFPE = {
+0, 0, ChangeZFFlag, displayZFHelp, 0, "ZF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER SFPE = {
+0, 0, ChangeSFFlag, displaySFHelp, 0, "SF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER PFPE = {
+0, 0, ChangePFFlag, displayPFHelp, 0, "PF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER CFPE = {
+0, 0, ChangeCFFlag, displayCFHelp, 0, "CF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER OFPE = {
+0, 0, ChangeOFFlag, displayOFHelp, 0, "OF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER IFPE = {
+0, 0, ChangeIFFlag, displayIFHelp, 0, "IF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER IDPE = {
+0, 0, ChangeIDFlag, displayIDHelp, 0, "CPUID", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER DFPE = {
+0, 0, ChangeDFFlag, displayDFHelp, 0, "DF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER NTPE = {
+0, 0, ChangeNTFlag, displayNTHelp, 0, "NT", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER VMPE = {
+0, 0, ChangeVMFlag, displayVMHelp, 0, "VM", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER VIFPE = {
+0, 0, ChangeVIFFlag, displayVIFHelp, 0, "VIF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER VIPPE = {
+0, 0, ChangeVIPFlag, displayVIPHelp, 0, "VIP", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER AFPE = {
+0, 0, ChangeAFFlag, displayAFHelp, 0, "AF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ACPE = {
+0, 0, ChangeACFlag, displayACHelp, 0, "AC", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER MTRRPE = {
+0, 0, DisplayMTRRRegisters, displayMTRRHelp, 0, "MTRR", 0, 0,
+"display memory type range registers" , 0 };
+
+DEBUGGER_PARSER GDTPE = {
+0, 0, displayGDT, displayGDTHelp, 0, ".G", 0, 0,
+"display global descriptor table" , 0 };
+
+DEBUGGER_PARSER IDTPE = {
+0, 0, displayIDT, displayIDTHelp, 0, ".I", 0, 0,
+"display interrupt descriptor table"  , 0 };
+
+DEBUGGER_PARSER EvaluatePE = {
+0, 0, evaluateExpression, evaluateExpressionHelp, 0, ".E", 0, 0,
+"evaluate expression (help .e)"  , 0 };
+
+DEBUGGER_PARSER InputWordPE = {
+0, 0, inputWordPort, portCommandHelp, 0, "IW", 0, 0,
+"input word from port" , 0 };
+
+DEBUGGER_PARSER InputDoublePE = {
+0, 0, inputDoublePort, portCommandHelp, 0, "IL", 0, 0,
+"input double word from port" , 0 };
+
+DEBUGGER_PARSER InputBytePE = {
+0, 0, inputBytePort, portCommandHelp, 0, "IB", 0, 0,
+"input byte from port" , 0 };
+
+DEBUGGER_PARSER InputPE = {
+0, 0, inputPort, portCommandHelp, 0, "I", 0, 0,
+"input byte from port" , 0 };
+
+DEBUGGER_PARSER OutputWordPE = {
+0, 0, outputWordPort, portCommandHelp, 0, "OW", 0, 0,
+"output word to port" , 0 };
+
+DEBUGGER_PARSER OutputDoublePE = {
+0, 0, outputDoublePort, portCommandHelp, 0, "OL", 0, 0,
+"output double word to port" , 0 };
+
+DEBUGGER_PARSER OutputBytePE = {
+0, 0, outputBytePort, portCommandHelp, 0, "OB", 0, 0,
+"output byte to port" , 0 };
+
+DEBUGGER_PARSER OutputPE = {
+0, 0, outputPort, portCommandHelp, 0, "O", 0, 0,
+"output byte to port" , 0 };
+
+DEBUGGER_PARSER BreakClearAllPE = {
+0, 0, breakpointClearAll, breakpointCommandHelp, 0, "BCA", 0, 0,
+"clear all breakpoints" , 0 };
+
+DEBUGGER_PARSER BreakClearPE = {
+0, 0, breakpointClear, breakpointCommandHelp, 0, "BC", 0, 0,
+"clear breakpoint" , 0 };
+
+DEBUGGER_PARSER BreakMaskPE = {
+0, 0, breakpointMask, breakpointCommandHelp, 0, "BM", 0, 0,
+"mask breaks for specific processor" , 0 };
+
+DEBUGGER_PARSER BW1PE = {
+0, 0, breakpointWord1, breakpointCommandHelp, 0, "BW1", 0, -1,
+"" , 0 };
+
+DEBUGGER_PARSER BW2PE = {
+0, 0, breakpointWord2, breakpointCommandHelp, 0, "BW2", 0, -1,
+"" , 0 };
+
+DEBUGGER_PARSER BW4PE = {
+0, 0, breakpointWord4, breakpointCommandHelp, 0, "BW4", 0, -1,
+"" , 0 };
+
+DEBUGGER_PARSER BWPE = {
+0, 0, breakpointWord, breakpointCommandHelp, 0, "BW", 0, 0,
+"set write only breakpoint #=1,2 or 4 byte len" , 0 };
+
+DEBUGGER_PARSER BR1PE = {
+0, 0, breakpointRead1, breakpointCommandHelp, 0, "BR1", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BR2PE = {
+0, 0, breakpointRead2, breakpointCommandHelp, 0, "BR2", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BR4PE = {
+0, 0, breakpointRead4, breakpointCommandHelp, 0, "BR4", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BRPE = {
+0, 0, breakpointRead, breakpointCommandHelp, 0, "BR", 0, 0,
+"set read/write breakpoint #=1,2 or 4 byte len" , 0 };
+
+DEBUGGER_PARSER BI1PE = {
+0, 0, breakpointIO1, breakpointCommandHelp, 0, "BI1", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BI2PE = {
+0, 0, breakpointIO2, breakpointCommandHelp, 0, "BI2", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BI4PE = {
+0, 0, breakpointIO4, breakpointCommandHelp, 0, "BI4", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BIPE = {
+0, 0, breakpointIO, breakpointCommandHelp, 0, "BI", 0, 0,
+"set io address breakpoint #=1,2 or 4 byte len"  , 0 };
+
+DEBUGGER_PARSER breakpointExecutePE = {
+0, 0, breakpointExecute, breakpointCommandHelp, 0, "B", 0, 0,
+"display all/set execute breakpoint" , 0 };
+
+DEBUGGER_PARSER breakShowTemp = {
+0, 0, breakpointShowTemp, breakpointCommandHelp, 0, "BST", 0, 0,
+"displays temporary breakpoints (proceed/go)" , 0 };
+
+// interactive debugger accelerators
+
+ACCELERATOR traceSSBACC = {
+0, 0, processTraceSSBACC, 0, 0, K_F6, 0,
+"F6 - Trace/Single Step til Branch" };
+
+ACCELERATOR traceACC = {
+0, 0, processTraceACC, 0, 0, K_F7, 0,
+"F7 - Trace/Single Step" };
+
+ACCELERATOR proceedACC = {
+0, 0, processProceedACC, 0, 0, K_F8, 0,
+"F8 - Proceed" };
+
+ACCELERATOR goACC = {
+0, 0, processGoACC, 0, 0, K_F9, 0,
+"F9 - Go" };
+
+ACCELERATOR enterACC = { // this accelerator handles repeat command
+0, 0, enterKeyACC, 0, 0, 13, 0,   // processing
+"Enter - Execute or Repeat a Command" };
+
+volatile BYTE *lastDumpAddress = 0; 
+volatile BYTE *lastLinkAddress = 0;
+volatile ULONG lastUnasmAddress = 0;
+volatile ULONG displayLength;
+volatile ULONG lastCommand = 0;
+volatile ULONG lastCommandEntry = 0;
+volatile BYTE lastDebugCommand[100] = {""};
+volatile ULONG lastDisplayLength = 0;
+volatile BYTE debugCommand[100] = {""};
+volatile ULONG nextUnasmAddress = 0;
+volatile ULONG pic1Value;
+volatile ULONG pic2Value;
+volatile ULONG BreakReserved[4];
+volatile ULONG BreakPoints[4];
+volatile ULONG BreakType[4];
+volatile ULONG BreakLength[4];
+volatile ULONG BreakTemp[4];
+volatile ULONG BreakGo[4];
+volatile ULONG BreakProceed[4];
+volatile ULONG BreakMask[MAX_PROCESSORS];
+volatile StackFrame *CurrentFrame[MAX_PROCESSORS];
+volatile ULONG NestedInterrupts[MAX_PROCESSORS];
+volatile ULONG ConditionalBreakpoint[4];
+volatile BYTE BreakCondition[4][256];
+volatile StackFrame lastStackFrame;
+volatile ULONG lastCR0 = 0;
+volatile ULONG lastCR2 = 0;
+volatile ULONG lastCR4 = 0;
+volatile ULONG CurrentDR7 = 0;
+volatile ULONG CurrentDR6[MAX_PROCESSORS];
+volatile ULONG repeatCommand = 0;
+volatile ULONG totalLines;
+volatile ULONG debuggerInitialized = 0;
+
+void MDBInitializeDebugger(void)
+{
+   register ULONG i;
+   extern void InitializeDebuggerRegisters(void);
+   extern ULONG AddAccelRoutine(ACCELERATOR *);
+
+   lastCommand = 0;
+   lastCommandEntry = 0;
+   lastDisplayLength = 0;
+
+   for (i=0; i < MAX_PROCESSORS; i++)
+   {
+      BreakMask[i] = 0;
+      ProcessorHold[i] = 0;
+      ProcessorState[i] = 0;
+      ProcessorMode[i] = 0;
+   }
+
+   for (i=0; i < 4; i++)
+   {
+      BreakReserved[i] = 0;
+      BreakPoints[i] = 0;
+      BreakType[i] = 0;
+      BreakLength[i] = 0;
+      BreakProceed[i] = 0;
+      BreakGo[i] = 0;
+      BreakTemp[i] = 0;
+      ConditionalBreakpoint[i] = 0;
+      BreakCondition[i][0] = '\0';
+   }
+
+   InitializeDebuggerRegisters();
+
+   AddDebuggerCommandParser(&ReasonPE);
+   AddDebuggerCommandParser(&backTraceAllPidPE);
+   AddDebuggerCommandParser(&backTracePidPE);
+   AddDebuggerCommandParser(&backTraceStackPE);
+   AddDebuggerCommandParser(&eFramePE);
+   AddDebuggerCommandParser(&cpuFramePE);
+   AddDebuggerCommandParser(&ProcessorPE);
+   AddDebuggerCommandParser(&HPE);
+   AddDebuggerCommandParser(&HelpPE);
+   AddDebuggerCommandParser(&clearScreenPE);
+   AddDebuggerCommandParser(&asciiTablePE);
+   AddDebuggerCommandParser(&TUTogglePE);
+   AddDebuggerCommandParser(&TDTogglePE);
+   AddDebuggerCommandParser(&TLTogglePE);
+   AddDebuggerCommandParser(&TGTogglePE);
+   AddDebuggerCommandParser(&TCTogglePE);
+   AddDebuggerCommandParser(&TNTogglePE);
+   AddDebuggerCommandParser(&TRTogglePE);
+   AddDebuggerCommandParser(&TSTogglePE);
+   AddDebuggerCommandParser(&TATogglePE);
+   AddDebuggerCommandParser(&TTogglePE);
+   AddDebuggerCommandParser(&versionPE);
+   AddDebuggerCommandParser(&rebootPE);
+   AddDebuggerCommandParser(&KernelProcessPE1);
+   AddDebuggerCommandParser(&KernelProcessPE2);
+/*
+   // section defines
+   AddDebuggerCommandParser(&SectionPE1);
+   AddDebuggerCommandParser(&SectionPE2);
+*/
+   AddDebuggerCommandParser(&AllSymbolsPE);
+   AddDebuggerCommandParser(&SymbolsPE);
+
+#if defined(CONFIG_MODULES)
+   AddDebuggerCommandParser(&lsmodPE1);
+   AddDebuggerCommandParser(&lsmodPE2);
+   AddDebuggerCommandParser(&rmmodPE);
+#endif
+
+   AddDebuggerCommandParser(&ControlPE);
+   AddDebuggerCommandParser(&AllPE);
+   AddDebuggerCommandParser(&SegmentPE);
+   AddDebuggerCommandParser(&NumericPE);
+   AddDebuggerCommandParser(&GeneralPE);
+   AddDebuggerCommandParser(&DefaultPE);
+   AddDebuggerCommandParser(&SearchMemoryBPE);
+   AddDebuggerCommandParser(&SearchMemoryWPE);
+   AddDebuggerCommandParser(&SearchMemoryDPE);
+   AddDebuggerCommandParser(&ChangeWordPE);
+   AddDebuggerCommandParser(&ChangeDoublePE);
+   AddDebuggerCommandParser(&ChangeBytePE);
+   AddDebuggerCommandParser(&ChangeDefaultPE);
+   AddDebuggerCommandParser(&CloseSymbolsPE);
+   AddDebuggerCommandParser(&WalkPE);
+   AddDebuggerCommandParser(&DumpLinkedPE);
+   AddDebuggerCommandParser(&DumpWordPE);
+   AddDebuggerCommandParser(&DumpStackPE);
+   AddDebuggerCommandParser(&DumpDoubleStackPE);
+   AddDebuggerCommandParser(&DumpDoublePE);
+   AddDebuggerCommandParser(&DumpBytePE);
+   AddDebuggerCommandParser(&DumpDefaultPE);
+   AddDebuggerCommandParser(&Diss16PE);
+   AddDebuggerCommandParser(&Diss32PE);
+   AddDebuggerCommandParser(&Id32PE);
+   AddDebuggerCommandParser(&ProceedPE);
+   AddDebuggerCommandParser(&TracePE);
+   AddDebuggerCommandParser(&SingleStepPE);
+   AddDebuggerCommandParser(&TraceSSPE);
+   AddDebuggerCommandParser(&TraceSSBPE);
+   AddDebuggerCommandParser(&GPE);
+   AddDebuggerCommandParser(&GoPE);
+   AddDebuggerCommandParser(&QPE);
+   AddDebuggerCommandParser(&XPE);
+   AddDebuggerCommandParser(&BreakProcessorPE);
+   AddDebuggerCommandParser(&ListProcessorsPE);
+   AddDebuggerCommandParser(&EAXPE);
+   AddDebuggerCommandParser(&ORIGEAXPE);
+   AddDebuggerCommandParser(&EBXPE);
+   AddDebuggerCommandParser(&ECXPE);
+   AddDebuggerCommandParser(&EDXPE);
+   AddDebuggerCommandParser(&ESIPE);
+   AddDebuggerCommandParser(&EDIPE);
+   AddDebuggerCommandParser(&EBPPE);
+   AddDebuggerCommandParser(&ESPPE);
+   AddDebuggerCommandParser(&EIPPE);
+   AddDebuggerCommandParser(&CSPE);
+   AddDebuggerCommandParser(&DSPE);
+   AddDebuggerCommandParser(&ESPE);
+   AddDebuggerCommandParser(&FSPE);
+   AddDebuggerCommandParser(&GSPE);
+   AddDebuggerCommandParser(&SSPE);
+   AddDebuggerCommandParser(&RFPE);
+   AddDebuggerCommandParser(&TFPE);
+   AddDebuggerCommandParser(&ZFPE);
+   AddDebuggerCommandParser(&SFPE);
+   AddDebuggerCommandParser(&PFPE);
+   AddDebuggerCommandParser(&CFPE);
+   AddDebuggerCommandParser(&OFPE);
+   AddDebuggerCommandParser(&IFPE);
+   AddDebuggerCommandParser(&IDPE);
+   AddDebuggerCommandParser(&DFPE);
+   AddDebuggerCommandParser(&NTPE);
+   AddDebuggerCommandParser(&VMPE);
+   AddDebuggerCommandParser(&VIFPE);
+   AddDebuggerCommandParser(&VIPPE);
+   AddDebuggerCommandParser(&AFPE);
+   AddDebuggerCommandParser(&ACPE);
+   AddDebuggerCommandParser(&MTRRPE);
+   AddDebuggerCommandParser(&GDTPE);
+   AddDebuggerCommandParser(&IDTPE);
+   AddDebuggerCommandParser(&EvaluatePE);
+   AddDebuggerCommandParser(&InputWordPE);
+   AddDebuggerCommandParser(&InputDoublePE);
+   AddDebuggerCommandParser(&InputBytePE);
+   AddDebuggerCommandParser(&InputPE);
+   AddDebuggerCommandParser(&OutputWordPE);
+   AddDebuggerCommandParser(&OutputDoublePE);
+   AddDebuggerCommandParser(&OutputBytePE);
+   AddDebuggerCommandParser(&OutputPE);
+   AddDebuggerCommandParser(&BreakClearAllPE);
+   AddDebuggerCommandParser(&BreakClearPE);
+   AddDebuggerCommandParser(&BreakMaskPE);
+   AddDebuggerCommandParser(&BW1PE);
+   AddDebuggerCommandParser(&BW2PE);
+   AddDebuggerCommandParser(&BW4PE);
+   AddDebuggerCommandParser(&BWPE);
+   AddDebuggerCommandParser(&BR1PE);
+   AddDebuggerCommandParser(&BR2PE);
+   AddDebuggerCommandParser(&BR4PE);
+   AddDebuggerCommandParser(&BRPE);
+   AddDebuggerCommandParser(&BI1PE);
+   AddDebuggerCommandParser(&BI2PE);
+   AddDebuggerCommandParser(&BI4PE);
+   AddDebuggerCommandParser(&BIPE);
+   AddDebuggerCommandParser(&breakpointExecutePE);
+
+   AddAccelRoutine(&traceSSBACC);
+   AddAccelRoutine(&traceACC);
+   AddAccelRoutine(&proceedACC);
+   AddAccelRoutine(&goACC);
+   AddAccelRoutine(&enterACC);
+
+   debuggerInitialized = TRUE;
+
+   return;
+}
+
+void MDBClearDebuggerState(void)
+{
+   extern void ClearDebuggerRegisters(void);
+
+   ClearDebuggerRegisters();
+   return;
+}
+
+
+void ClearTempBreakpoints(void)
+{
+   register ULONG i;
+
+   for (i=0; i < 4; i++)
+   {
+      if (BreakTemp[i])
+      {
+	 BreakTemp[i] = 0;
+	 BreakReserved[i] = 0;
+	 BreakPoints[i] = 0;
+	 BreakType[i] = 0;
+	 BreakLength[i] = 0;
+	 BreakGo[i] = 0;
+	 BreakProceed[i] = 0;
+      }
+   }
+   SetDebugRegisters();
+   return;
+}
+
+ULONG ValidBreakpoint(ULONG address)
+{
+
+   register ULONG i;
+
+   for (i=0; i < 4; i++)
+   {
+      if (!BreakTemp[i])
+	 if (BreakPoints[i] == address)
+	    return 1;
+   }
+   return 0;
+
+}
+
+ULONG GetIP(StackFrame *stackFrame)
+{
+    return (ULONG)(stackFrame->tEIP);
+}
+
+ULONG GetStackAddress(StackFrame *stackFrame)
+{
+    return (ULONG)(stackFrame->tESP);
+}
+
+ULONG GetStackSegment(StackFrame *stackFrame)
+{
+    return (ULONG)(stackFrame->tSS);
+}
+
+// F6
+
+ULONG processTraceSSBACC(ULONG key, void *p, ACCELERATOR *accel)
+{
+     register StackFrame *stackFrame = p;
+     
+     if (key) {};
+     if (p) {};
+     if (accel) {};
+
+     DBGPrint("\n");
+     lastCommand = 'T';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, 
+		     sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+     ProcessorMode[get_processor_id()] = TRUE;
+
+     return -1;
+}
+
+// F8
+
+ULONG processProceedACC(ULONG key, void *p, ACCELERATOR *accel)
+{
+     register StackFrame *stackFrame = p;
+     register ULONG i;
+
+     if (key) {};
+     if (p) {};
+     if (accel) {};
+
+     DBGPrint("\n");
+     if (needs_proceed)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      BreakReserved[i] = TRUE;
+	      BreakPoints[i] = nextUnasmAddress;
+	      BreakType[i] = BREAK_EXECUTE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      BreakTemp[i] = TRUE;
+	      BreakProceed[i] = TRUE;
+	      SetDebugRegisters();
+	      lastCommand = 'P';
+	      lastCR0 = ReadCR0();
+	      lastCR2 = ReadCR2();
+	      lastCR4 = ReadCR4();
+	      memmove((void *)&lastStackFrame, stackFrame, 
+		      sizeof(StackFrame));
+
+	      stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	      stackFrame->tSystemFlags |= RESUME;
+              ProcessorMode[get_processor_id()] = TRUE;
+
+	      return -1;
+	   }
+	}
+	DBGPrint("\nNo breakpoint available for Proceed, (single step) instead");
+     }
+     lastCommand = 'P';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, 
+	       sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+     ProcessorMode[get_processor_id()] = TRUE;
+
+     return -1;
+}
+
+// F7
+
+ULONG processTraceACC(ULONG key, void *p, ACCELERATOR *accel)
+{
+     register StackFrame *stackFrame = p;
+     
+     if (key) {};
+     if (p) {};
+     if (accel) {};
+
+     DBGPrint("\n");
+     lastCommand = 'T';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, 
+		     sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+     ProcessorMode[get_processor_id()] = TRUE;
+
+     return -1;
+}
+
+// F9
+
+ULONG processGoACC(ULONG key, void *p, ACCELERATOR *accel)
+{
+     register StackFrame *stackFrame = p;
+
+     if (key) {};
+     if (p) {};
+     if (accel) {};
+
+     DBGPrint("\n");
+     ClearTempBreakpoints();
+     lastCommand = 'G';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, sizeof(StackFrame));
+
+     stackFrame->tSystemFlags &= ~SINGLE_STEP;
+     stackFrame->tSystemFlags |= RESUME;
+
+     return -1;
+    
+}
+
+ULONG executeCommandHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("t                        - trace\n");
+    DBGPrint("s                        - single step\n");
+    DBGPrint("ss                       - single step\n");
+    DBGPrint("ssb                      - single step til branch\n");
+    DBGPrint("p                        - proceed\n");
+    DBGPrint("g or g <address>         - go\n");
+    DBGPrint("go or go <address>       - go\n");
+    DBGPrint("q or q <address>         - quit\n");
+    DBGPrint("x or x <address>         - exit\n");
+    DBGPrint("F7                       - trace\n");
+    DBGPrint("F8                       - proceed\n");
+    DBGPrint("F9                       - go\n");
+    DBGPrint("\n");
+    return TRUE;
+}
+
+// P
+
+ULONG processProceed(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register ULONG i;
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     if (needs_proceed)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      BreakReserved[i] = TRUE;
+	      BreakPoints[i] = nextUnasmAddress;
+	      BreakType[i] = BREAK_EXECUTE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      BreakTemp[i] = TRUE;
+	      BreakProceed[i] = TRUE;
+	      SetDebugRegisters();
+	      lastCommand = 'P';
+	      lastCR0 = ReadCR0();
+	      lastCR2 = ReadCR2();
+	      lastCR4 = ReadCR4();
+	      memmove((void *)&lastStackFrame, stackFrame, 
+		      sizeof(StackFrame));
+
+	      stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	      stackFrame->tSystemFlags |= RESUME;
+              ProcessorMode[get_processor_id()] = TRUE;
+
+	      return -1;
+	   }
+	}
+	DBGPrint("\nNo breakpoint available for Proceed, (single step) instead");
+     }
+     lastCommand = 'P';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, 
+	       sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+     ProcessorMode[get_processor_id()] = TRUE;
+
+     return -1;
+
+}
+
+// SSB
+
+ULONG processTraceSSB(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     lastCommand = 'T';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, 
+		     sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+     ProcessorMode[get_processor_id()] = TRUE;
+
+     return -1;
+
+}
+
+
+// T
+
+ULONG processTrace(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     lastCommand = 'T';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, 
+		     sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+     ProcessorMode[get_processor_id()] = TRUE;
+
+     return -1;
+
+}
+
+// G
+
+ULONG processGo(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register ULONG address;
+     ULONG valid;
+     register ULONG i;
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      BreakReserved[i] = TRUE;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_EXECUTE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      BreakTemp[i] = TRUE;
+	      BreakGo[i] = TRUE;
+	      SetDebugRegisters();
+	      DBGPrint("\n");
+	      lastCommand = 'G';
+	      lastCR0 = ReadCR0();
+	      lastCR2 = ReadCR2();
+	      lastCR4 = ReadCR4();
+	      memmove((void *)&lastStackFrame, stackFrame, 
+			      sizeof(StackFrame));
+
+	      stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	      stackFrame->tSystemFlags |= RESUME;
+
+	      return -1;
+	   }
+	}
+     }
+     else
+     {
+	ClearTempBreakpoints();
+	DBGPrint("\n");
+	lastCommand = 'G';
+	lastCR0 = ReadCR0();
+	lastCR2 = ReadCR2();
+	lastCR4 = ReadCR4();
+	memmove((void *)&lastStackFrame, stackFrame, 
+			sizeof(StackFrame));
+
+	stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	stackFrame->tSystemFlags |= RESUME;
+
+	return -1;
+     }
+     DBGPrint("no breakpoint available for GO\n");
+     return TRUE;
+
+}
+
+ULONG processorCommandHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("lcpu                     - list processors\n");
+    DBGPrint("cpu [p#]                 - switch processor\n");
+    DBGPrint("lr  [p#]                 - display processor registers\n");
+    return TRUE;
+}
+
+// CPU
+
+ULONG breakProcessor(BYTE *cmd,
+		     StackFrame *stackFrame, ULONG Exception,
+		     DEBUGGER_PARSER *parser)
+{
+     register ULONG cpunum, cpu = get_processor_id();
+     ULONG valid, i;
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     cpunum = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)   
+     {
+        if (cpunum == cpu)
+        {
+           DBGPrint("debugger already running on processor %d\n", (int)cpunum);
+           return TRUE;
+        }
+
+	if ((cpunum > MAX_PROCESSORS) || !(cpu_online(cpunum)))  
+        {
+	   DBGPrint("invalid processor specified\n");
+           return TRUE;
+        }
+
+        for (i=0; i < MAX_PROCESSORS; i++) 
+        {
+           if (cpu_online(i)) 
+           {
+	      if (i == cpunum) 
+              {
+	         ProcessorState[i] = PROCESSOR_SWITCH;
+                 ProcessorHold[cpu] = TRUE;
+                 break;
+              }
+	   }
+        }
+	DBGPrint("\n");
+	lastCommand = 'G';
+	lastCR0 = ReadCR0();
+	lastCR2 = ReadCR2();
+	lastCR4 = ReadCR4();
+	memmove((void *)&lastStackFrame, stackFrame, 
+			   sizeof(StackFrame));
+	return -1;
+     }
+     else
+     {
+	DBGPrint("no target processor specified\n");
+        DBGPrint("Current Processor: %d\n", get_processor_id());
+        DBGPrint("Active Processors: ");
+
+        for (i=0; i < MAX_PROCESSORS; i++) 
+        {
+           if (cpu_online(i)) 
+           {
+	      if (i) 
+                 DBGPrint(", ");
+
+ 	      DBGPrint("%d", i);
+	   }
+        }
+        DBGPrint("\n");
+     }
+     return TRUE;
+
+}
+
+// LR
+
+extern volatile StackFrame CurrentStackFrame[MAX_PROCESSORS];
+
+ULONG listProcessorFrame(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser)
+{
+     ULONG valid, pnum;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     pnum = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid && (pnum < MAX_PROCESSORS) && (cpu_online(pnum)))
+     {
+	DBGPrint("Processor Frame %d -> (%08X)\n", pnum, 
+                 &CurrentStackFrame[pnum]);
+	DisplayTSS((StackFrame *)&CurrentStackFrame[pnum]);
+     }
+     else
+	DBGPrint("invalid processor frame\n");
+
+     return TRUE;
+
+}
+
+// EF
+
+ULONG dump_ef(BYTE *cmd,
+	      StackFrame *stackFrame, ULONG Exception,
+	      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     BYTE *addr;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     addr = (BYTE *)EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+        DBGPrint("invalid frame address\n");
+     }
+     else
+     {
+        addr = (BYTE *)stackFrame->tReserved[2];
+        DBGPrint("invalid frame pointer address\n");
+     }
+     return TRUE;
+
+}
+
+// UF
+
+ULONG dump_uf(BYTE *cmd,
+	      StackFrame *stackFrame, ULONG Exception,
+	      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     BYTE *addr;
+     extern int mdb_dumpregs(struct pt_regs *, const char *, const char *);
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     addr = (BYTE *)EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+        DBGPrint("invalid frame address\n");
+     }
+     else
+     {
+        addr = (BYTE *)stackFrame->tReserved[2];
+        DBGPrint("invalid frame pointer address\n");
+     }
+     return TRUE;
+
+}
+
+// .TA
+
+ULONG ProcessTAToggle(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     if (general_toggle)
+     {
+        general_toggle = 0;
+        control_toggle = 0;
+        segment_toggle = 0;
+     }
+     else
+     {
+        general_toggle = 1;
+        control_toggle = 1;
+        segment_toggle = 1;
+     }
+
+     DBGPrint("toggle general registers (%s) \n",
+					    general_toggle ? "ON" : "OFF");
+     DBGPrint("toggle control registers (%s) \n",
+					    control_toggle ? "ON" : "OFF");
+     DBGPrint("toggle segment registers (%s) \n",
+					    segment_toggle ? "ON" : "OFF");
+     return TRUE;
+
+}
+
+ULONG TSSDisplayHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint(".t <address>             - display task state regs\n");
+    return TRUE;
+}
+
+// .T
+
+ULONG TSSDisplay(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address;
+     ULONG valid;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	DisplayTSS(stackFrame);
+     else
+	DisplayTSS((StackFrame *) address);
+
+     return TRUE;
+}
+
+ULONG displayRegistersHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("r                        - display registers for a processor\n");
+    DBGPrint("rc                       - display control registers \n");
+    DBGPrint("rs                       - display segment registers \n");
+    DBGPrint("rg                       - display general registers \n");
+    DBGPrint("ra                       - display all registers\n");
+    DBGPrint("rn                       - display coprocessor/MMX registers\n");
+
+    return TRUE;
+}
+
+// RC
+
+ULONG displayControlRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     DBGPrint("Control Registers\n");
+     DisplayControlRegisters(get_processor_id(), stackFrame);
+     return TRUE;
+
+}
+
+// RA
+
+ULONG displayAllRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     register ULONG processor = get_processor_id();
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     DBGPrint("General Registers\n");
+     DisplayGeneralRegisters(stackFrame);
+
+     DBGPrint("Segment Registers\n");
+     DisplaySegmentRegisters(stackFrame);
+     
+     DBGPrint("Control Registers\n");
+     DisplayControlRegisters(processor, stackFrame);
+
+     if (fpu_present())
+     {
+	DBGPrint("Coprocessor Registers\n");
+	DisplayNPXRegisters(processor);
+     }
+     else
+     {
+	DBGPrint("Coprocessor Not Present\n");
+     }
+     return TRUE;
+
+}
+
+
+// RS
+
+ULONG displaySegmentRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     DBGPrint("Segment Registers\n");
+     DisplaySegmentRegisters(stackFrame);
+     return TRUE;
+
+}
+
+// RN
+
+ULONG displayNumericRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     if (fpu_present())
+     {
+	DBGPrint("Coprocessor Registers\n");
+	DisplayNPXRegisters(get_processor_id());
+     }
+     else
+     {
+	DBGPrint("Coprocessor Not Present\n");
+     }
+     return TRUE;
+
+}
+
+// RG
+
+ULONG displayGeneralRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     DBGPrint("General Registers\n");
+     DisplayGeneralRegisters(stackFrame);
+     return TRUE;
+
+
+}
+
+#ifdef RENDER_NPX_VALUES
+double ldexp(double v, int e)
+{
+   double two = 2.0;
+
+   if (e < 0)
+   {
+      e = -e; // This just might overflow on two-complement machines.  
+      if (e < 0) 
+         return 0.0;
+
+      while (e > 0)
+      {
+	 if (e & 1) 
+         {
+//            v = v / two;
+            do_div(&v, two);
+         }
+	 two = two * two;
+	 e >>= 1;
+      }
+   }
+   else 
+   if (e > 0)
+   {
+      while (e > 0)
+      {
+	 if (e & 1) 
+            v = v * two;
+	 two = two * two;
+	 e >>= 1;
+      }
+   }
+   return v;
+}
+#endif
+
+void DisplayNPXRegisters(ULONG processor)
+{
+     register int i;
+     int tag;
+     int tos;
+#ifdef RENDER_NPX_VALUES
+     double d;
+#endif
+
+     tos = (npx[processor].status >> 11) & 7;
+     if (tos) {};
+
+     DBGPrint("Control: 0x%04X  Status: 0x%04X  Tag: 0x%04X  TOS: %i CPU: %i\n",
+	       (unsigned)npx[processor].control & 0xFFFF, 
+               (unsigned)npx[processor].status & 0xFFFF, 
+               (unsigned)npx[processor].tag & 0xFFFF,
+               (int)tos, (int)processor);
+
+     for (i = 0; i < 8; i++)
+     {
+	tos = (npx[processor].status >> 11) & 7;
+	DBGPrint("st(%d)/MMX%d  ", i, (int)((tos + i) % 8));
+
+	if (npx[processor].reg[i].sign)
+	    DBGPrint("-");
+	else
+	    DBGPrint("+");
+
+	DBGPrint(" %04X %04X %04X %04X e %04X    ",
+		 (unsigned)npx[processor].reg[i].sig3,
+		 (unsigned)npx[processor].reg[i].sig2,
+		 (unsigned)npx[processor].reg[i].sig1,
+		 (unsigned)npx[processor].reg[i].sig0,
+		 (unsigned)npx[processor].reg[i].exponent);
+
+	 if (tos) {};
+	 tag = (npx[processor].tag >> (((i + tos) % 8) * 2)) & 3;
+	 switch (tag)
+	 {
+
+	    case 0:
+	       DBGPrint("Valid");
+#ifdef RENDER_NPX_VALUES
+	       if (((int) npx[processor].reg[i].exponent - 16382 < 1000) &&
+		  ((int) npx[processor].reg[i].exponent - 16382 > -1000))
+	       {
+		  d = 
+                  npx[processor].reg[i].sig3 / 65536.0 + 
+                  npx[processor].reg[i].sig2 / 65536.0 / 65536.0 + 
+                  npx[processor].reg[i].sig1 / 65536.0 / 65536.0 / 65536.0;
+
+		  d = ldexp(d, (int) npx[processor].reg[i].exponent - 16382);
+	
+ 	          if (npx[processor].reg[i].sign)
+		     d = -d;
+
+		  DBGPrint("  %.16g", d);
+	       }
+	       else
+		  DBGPrint("  (too big to display)");
+#endif
+	       DBGPrint("\n");
+	       break;
+
+	    case 1:
+	       DBGPrint("Zero\n");
+	       break;
+
+	    case 2:
+	       DBGPrint("Special\n");
+	       break;
+
+	    case 3:
+	       DBGPrint("Empty\n");
+	       break;
+	}
+     }
+}
+
+// R
+
+ULONG displayDefaultRegisters(BYTE *cmd,
+			     StackFrame *stackFrame, ULONG Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     register ULONG processor = get_processor_id();
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+    DisplayGeneralRegisters(stackFrame);
+
+    if (control_toggle)
+       DisplayControlRegisters(processor, stackFrame);
+
+    if (numeric_toggle)
+       DisplayNPXRegisters(processor);
+
+     disassemble(stackFrame, stackFrame->tEIP, 1, 1);
+     return TRUE;
+
+}
+
+void displayRegisters(StackFrame *stackFrame, ULONG processor)
+{
+    if (general_toggle)
+       DisplayGeneralRegisters(stackFrame);
+
+    if (control_toggle)
+       DisplayControlRegisters(processor, stackFrame);
+
+    if (numeric_toggle)
+       DisplayNPXRegisters(processor);
+
+}
+
+ULONG displayEAXHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+    return TRUE;
+}
+
+// EAX
+
+ULONG ChangeEAXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEAX = value;
+	DBGPrint("EAX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+
+// ORIGEAX
+
+ULONG ChangeORIGEAXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tReserved[1] = value;
+	DBGPrint("ORIGEAX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+
+ULONG displayEBXHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// EBX
+
+ULONG ChangeEBXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEBX = value;
+	DBGPrint("EBX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+ULONG displayECXHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// ECX
+
+ULONG ChangeECXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tECX = value;
+	DBGPrint("ECX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+
+ULONG displayEDXHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// EDX
+
+ULONG ChangeEDXRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEDX = value;
+	DBGPrint("EDX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+ULONG displayESIHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// ESI
+
+ULONG ChangeESIRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tESI = value;
+	DBGPrint("ESI changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+
+ULONG displayEDIHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// EDI
+
+ULONG ChangeEDIRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEDI = value;
+	DBGPrint("EDI changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+
+ULONG displayEBPHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// EBP
+
+ULONG ChangeEBPRegister(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEBP = value;
+	DBGPrint("EBP changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+
+ULONG displayESPHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// ESP
+
+ULONG ChangeESPRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tESP = value;
+	DBGPrint("ESP changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+
+ULONG displayEIPHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// EIP
+
+ULONG ChangeEIPRegister(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEIP = value;
+	DBGPrint("EIP changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return TRUE;
+
+}
+
+ULONG displayCSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// CS
+
+ULONG ChangeCSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+     register WORD oldW;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tCS;
+	stackFrame->tCS = (WORD) value;
+	DBGPrint("CS: = [%04X] changed to CS: = [%04X]\n",
+			(unsigned)oldW, (unsigned) value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return TRUE;
+
+}
+
+ULONG displayDSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// DS
+
+ULONG ChangeDSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+     register WORD oldW;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tDS;
+	stackFrame->tDS = (WORD) value;
+	DBGPrint("DS: = [%04X] changed to DS: = [%04X]\n",
+			(unsigned)oldW, (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return TRUE;
+
+}
+
+ULONG displayESHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// ES
+
+ULONG ChangeESRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+     register WORD oldW;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tES;
+	stackFrame->tES = (WORD) value;
+	DBGPrint("ES: = [%04X] changed to ES: = [%04X]\n",
+			(unsigned)oldW, (unsigned) value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return TRUE;
+
+}
+
+ULONG displayFSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// FS
+
+ULONG ChangeFSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+     register WORD oldW;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tFS;
+	stackFrame->tFS = (WORD) value;
+	DBGPrint("FS: = [%04X] changed to FS: = [%04X]\n",
+			(unsigned)oldW, (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return TRUE;
+
+}
+
+ULONG displayGSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// GS
+
+ULONG ChangeGSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+     register WORD oldW;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tGS;
+	stackFrame->tGS = (WORD) value;
+	DBGPrint("GS: = [%04X] changed to GS: = [%04X]\n",
+			(unsigned)oldW, (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return TRUE;
+
+}
+
+ULONG displaySSHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// SS
+
+ULONG ChangeSSRegister(BYTE *cmd,
+		      StackFrame *stackFrame, ULONG Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value;
+     register WORD oldW;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tSS;
+	stackFrame->tSS = (WORD) value;
+	DBGPrint("SS: = [%04X] changed to SS: = [%04X]\n",
+			(unsigned)oldW, (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+
+     return TRUE;
+
+}
+
+ULONG displayRFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// RF
+
+ULONG ChangeRFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & RF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= RF_FLAG) : (stackFrame->tSystemFlags &= ~RF_FLAG);
+	DBGPrint("EFlag RF[%08X] changed to (%d)\n",
+			(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayTFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// TF
+
+ULONG ChangeTFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & TF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= TF_FLAG) : (stackFrame->tSystemFlags &= ~TF_FLAG);
+	DBGPrint("EFlag TF[%08X] changed to (%d)\n",
+			(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayZFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// ZF
+
+ULONG ChangeZFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & ZF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= ZF_FLAG) : (stackFrame->tSystemFlags &= ~ZF_FLAG);
+	DBGPrint("EFlag ZF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displaySFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// SF
+
+ULONG ChangeSFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & SF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= SF_FLAG) : (stackFrame->tSystemFlags &= ~SF_FLAG);
+	DBGPrint("EFlag SF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayPFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// PF
+
+ULONG ChangePFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & PF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= PF_FLAG) : (stackFrame->tSystemFlags &= ~PF_FLAG);
+	DBGPrint("EFlag PF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayCFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// CF
+
+ULONG ChangeCFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & CF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= CF_FLAG) : (stackFrame->tSystemFlags &= ~CF_FLAG);
+	DBGPrint("EFlag CF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayOFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// OF
+
+ULONG ChangeOFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & OF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= OF_FLAG) : (stackFrame->tSystemFlags &= ~OF_FLAG);
+	DBGPrint("EFlag OF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+
+ULONG displayIFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// IF
+
+ULONG ChangeIFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & IF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= IF_FLAG) : (stackFrame->tSystemFlags &= ~IF_FLAG);
+	DBGPrint("EFlag IF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayIDHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// ID
+
+ULONG ChangeIDFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & ID_FLAGS;
+	(value) ? (stackFrame->tSystemFlags |= ID_FLAGS) : (stackFrame->tSystemFlags &= ~ID_FLAGS);
+	DBGPrint("EFlag ID[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayDFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// DF
+
+ULONG ChangeDFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & DF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= DF_FLAG) : (stackFrame->tSystemFlags &= ~DF_FLAG);
+	DBGPrint("EFlag DF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayNTHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// NT
+
+ULONG ChangeNTFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & NT_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= NT_FLAG) : (stackFrame->tSystemFlags &= ~NT_FLAG);
+	DBGPrint("EFlag NT[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayVMHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// VM
+
+ULONG ChangeVMFlag(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & VM_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= VM_FLAG) : (stackFrame->tSystemFlags &= ~VM_FLAG);
+	DBGPrint("EFlag VM[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+
+ULONG displayVIFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// VIF
+
+ULONG ChangeVIFFlag(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & VIF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= VIF_FLAG) : (stackFrame->tSystemFlags &= ~VIF_FLAG);
+	DBGPrint("EFlag VIF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayVIPHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// VIP
+
+ULONG ChangeVIPFlag(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & VIP_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= VIP_FLAG) : (stackFrame->tSystemFlags &= ~VIP_FLAG);
+	DBGPrint("EFlag VIP[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayAFHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// AF
+
+ULONG ChangeAFFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & AF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= AF_FLAG) : (stackFrame->tSystemFlags &= ~AF_FLAG);
+	DBGPrint("EFlag AF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+
+ULONG displayACHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    return TRUE;
+}
+
+// AC
+
+ULONG ChangeACFlag(BYTE *cmd,
+		  StackFrame *stackFrame, ULONG Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG value, oldD;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & AC_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= AC_FLAG) : (stackFrame->tSystemFlags &= ~AC_FLAG);
+	DBGPrint("EFlag AC[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return TRUE;
+
+}
+
+ULONG displayMTRRHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("mtrr                     - display memory type range registers\n");
+    return TRUE;
+}
+
+// MTRR
+
+ULONG DisplayMTRRRegisters(BYTE *cmd,
+			  StackFrame *stackFrame, ULONG Exception,
+			  DEBUGGER_PARSER *parser)
+{
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     displayMTRRRegisters();
+     return TRUE;
+
+}
+
+ULONG displayGDTHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint(".g or .g <address>       - display global descriptor table\n");
+    return TRUE;
+}
+
+// .G
+
+ULONG displayGDT(BYTE *cmd,
+		StackFrame *stackFrame, ULONG Exception,
+		DEBUGGER_PARSER *parser)
+{
+     register ULONG address;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+	DisplayGDT((BYTE *) address);
+     else
+	DisplayGDT((BYTE *) 0);
+     return TRUE;
+}
+
+ULONG displayIDTHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint(".i or .i <address>       - display interrupt descriptor table\n");
+    return TRUE;
+}
+
+// .I
+
+ULONG displayIDT(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+	DisplayIDT((BYTE *) address);
+     else
+	DisplayIDT((BYTE *) 0);
+     return TRUE;
+}
+
+ULONG evaluateExpressionHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    extern void displayExpressionHelp(void);
+
+    if (commandLine) {}
+    if (parser) {}
+
+    displayExpressionHelp();
+    return TRUE;
+}
+
+// .E
+
+ULONG evaluateExpression(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     extern void EvaluateCommandExpression(StackFrame *stackFrame, 
+                                           BYTE *cmd);
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     EvaluateCommandExpression(stackFrame, cmd);
+     return TRUE;
+}
+
+ULONG portCommandHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("i   <port>               - input byte from port\n");
+    DBGPrint("ib  <port>               - input byte from port\n");
+    DBGPrint("iw  <port>               - input word from port\n");
+    DBGPrint("il  <port>               - input double word from port\n");
+    DBGPrint("o   <port> <val>         - output byte to port\n");
+    DBGPrint("ob  <port> <val>         - output byte to port\n");
+    DBGPrint("ow  <port> <val>         - output word to port\n");
+    DBGPrint("ol  <port> <val>         - output double word to port\n");
+    return TRUE;
+}
+
+// IW
+
+ULONG inputWordPort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	DBGPrint("inportw (%04X) = %04X\n",
+                     (unsigned)address, (unsigned)inw(address));
+     }
+     else
+     {
+	DBGPrint("bad port command\n");
+     }
+     return TRUE;
+
+}
+
+// ID
+
+ULONG inputDoublePort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	DBGPrint("inportd (%04X) = %08X\n",
+			  (unsigned)address, (unsigned)inl(address));
+     }
+     else
+     {
+	DBGPrint("bad port command\n");
+     }
+     return TRUE;
+
+}
+
+// IB
+
+ULONG inputBytePort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	DBGPrint("inportb (%04X) = %02X\n",
+			  (unsigned)address, (unsigned)inb(address));
+     }
+     else
+     {
+	DBGPrint("bad port command\n");
+     }
+     return TRUE;
+
+}
+
+// I
+
+ULONG inputPort(BYTE *cmd,
+	       StackFrame *stackFrame, ULONG Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register ULONG address;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	DBGPrint("inportb (%04X) = %02X\n",
+			  (unsigned)address, (unsigned)inb(address));
+     }
+     else
+     {
+	DBGPrint("bad port command\n");
+     }
+     return TRUE;
+
+}
+
+// OW
+
+ULONG outputWordPort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG port, value;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     port = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	value = EvaluateExpression(stackFrame, &cmd, &valid);
+	if (valid)
+	{
+	   DBGPrint("outportw (%04X) = %04X\n",
+				    (unsigned)port, (unsigned)value);
+	   outw(port, value);
+	   return TRUE;
+	}
+     }
+     else
+	DBGPrint("bad port command\n");
+
+     return TRUE;
+
+}
+
+// OD
+
+ULONG outputDoublePort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG port, value;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     port = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	value = EvaluateExpression(stackFrame, &cmd, &valid);
+	if (valid)
+	{
+	   DBGPrint("outportd (%04X) = %08X\n",
+			    (unsigned)port, (unsigned)value);
+	   outl(port, value);
+	   return TRUE;
+	}
+     }
+     else
+	DBGPrint("bad port command\n");
+
+     return TRUE;
+
+}
+
+// OB
+
+ULONG outputBytePort(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG port, value;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     port = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	value = EvaluateExpression(stackFrame, &cmd, &valid);
+	if (valid)
+	{
+	   DBGPrint("outportb (%04X) = %02X\n",
+			    (unsigned)port, (unsigned)value);
+	   outb(port, value);
+	   return TRUE;
+	}
+     }
+     else
+	DBGPrint("bad port command\n");
+
+     return TRUE;
+
+}
+
+// O
+
+ULONG outputPort(BYTE *cmd,
+		StackFrame *stackFrame, ULONG Exception,
+		DEBUGGER_PARSER *parser)
+{
+     register ULONG port, value;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     port = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	value = EvaluateExpression(stackFrame, &cmd, &valid);
+	if (valid)
+	{
+	   DBGPrint("outportb (%04X) = %02X\n",
+			    (unsigned)port, (unsigned)value);
+	   outb(port, value);
+	   return TRUE;
+	}
+     }
+     else
+	DBGPrint("bad port command\n");
+
+     return TRUE;
+
+}
+
+ULONG breakpointCommandHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("b                        - display all breakpoints\n");
+    DBGPrint("b   <address>            - set execute breakpoint\n");
+    DBGPrint("bc  [#] (1-4)            - clear breakpoint\n");
+    DBGPrint("bca                      - clear all breakpoints\n");
+    DBGPrint("br[#] <address>          - set read/write breakpoint #=1,2 or 4 byte len\n");
+    DBGPrint("bw[#] <address>          - set write only breakpoint #=1,2 or 4 byte len\n");
+    DBGPrint("bi[#] <address>          - set io address breakpoint #=1,2 or 4 byte len\n");
+    DBGPrint("bm  [p#]                 - mask breaks for specific processor \n");
+    DBGPrint("bst                      - display temporary (go/proceed) breakpoints\n");
+    return TRUE;
+}
+
+// BCA
+
+ULONG breakpointClearAll(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG i;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     for (i=0; i < 4; i++)
+     {
+	BreakReserved[i] = 0;
+	BreakPoints[i] = 0;
+	BreakType[i] = 0;
+	BreakLength[i] = 0;
+	ConditionalBreakpoint[i] = 0;
+     }
+     SetDebugRegisters();
+     DBGPrint("all breakpoints cleared\n");
+
+     return TRUE;
+
+}
+
+// BC
+
+ULONG breakpointClear(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     ULONG valid;
+     register ULONG i, address;
+     register BYTE *symbolName;
+     register BYTE *moduleName;
+     register int c = get_processor_id();
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	i = address;
+	if (i < 4)
+	{
+	   symbolName = GetSymbolFromValue(BreakPoints[i], &symbuf[c][0], 
+                                           MAX_SYMBOL_LEN);
+	   moduleName = GetModuleInfoFromSymbolValue(BreakPoints[i], 
+                                           &modbuf[c][0], MAX_SYMBOL_LEN);
+           if (moduleName)
+	      DBGPrint("breakpoint %i at 0x%08X (%s %s) %s|%s cleared\n",
+			     (int)i,
+			     (unsigned)BreakPoints[i],
+			     BreakDescription[(BreakType[i] & 3)],
+			     BreakLengthDescription[(BreakLength[i] & 3)],
+			     ((char *)(moduleName) ? (char *)(moduleName)
+                             : (char *)("")),
+			     ((char *)(symbolName) ? (char *)(symbolName) 
+                             : (char *)("")));
+           else
+	      DBGPrint("breakpoint %i at 0x%08X (%s %s) %s cleared\n",
+			     (int)i,
+			     (unsigned)BreakPoints[i],
+			     BreakDescription[(BreakType[i] & 3)],
+			     BreakLengthDescription[(BreakLength[i] & 3)],
+			     ((char *)(symbolName) ? (char *)(symbolName) 
+                             : (char *)("")));
+	   BreakReserved[i] = 0;
+	   BreakPoints[i] = 0;
+	   BreakType[i] = 0;
+	   BreakLength[i] = 0;
+	   ConditionalBreakpoint[i] = 0;
+	   SetDebugRegisters();
+	   return TRUE;
+	}
+	else
+	   DBGPrint("breakpoint out of range\n");
+	return TRUE;
+     }
+     DBGPrint("breakpoint not found\n");
+     return TRUE;
+}
+
+// BM
+
+ULONG breakpointMask(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, pnum, i;
+     ULONG valid;
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	pnum = address;
+	if (pnum < MAX_PROCESSORS)
+	{
+	   if (BreakMask[pnum])
+	      BreakMask[pnum] = 0;
+	   else
+	      BreakMask[pnum] = 1;
+	   DBGPrint("processor %i : %s\n", (int)pnum,
+		   BreakMask[pnum] ? "BREAKS_MASKED" : "BREAKS_UNMASKED");
+	}
+	else
+	   DBGPrint("processor (%i) invalid\n", (int)pnum);
+     }
+     else
+     {
+	for (i=0; i < MAX_PROCESSORS; i++)
+	{
+	   DBGPrint("processor %i : %s\n", (int)i,
+		    BreakMask[i] ? "BREAKS_MASKED" : "BREAKS_UNMASKED");
+	}
+     }
+     return TRUE;
+
+}
+
+// BW1
+
+ULONG breakpointWord1(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_WRITE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0], 
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+		               ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+			
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+// BW2
+
+ULONG breakpointWord2(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_WRITE;
+	      BreakLength[i] = TWO_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+			
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+// BW4
+
+ULONG breakpointWord4(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_WRITE;
+	      BreakLength[i] = FOUR_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+// BW
+
+ULONG breakpointWord(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_WRITE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+
+// BR1
+
+ULONG breakpointRead1(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_READWRITE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+
+// BR2
+
+ULONG breakpointRead2(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_READWRITE;
+	      BreakLength[i] = TWO_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+
+// BR4
+
+ULONG breakpointRead4(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_READWRITE;
+	      BreakLength[i] = FOUR_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0], 
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+
+// BR
+
+ULONG breakpointRead(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_READWRITE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+// BI1
+
+ULONG breakpointIO1(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_IOPORT;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+// BI2
+
+ULONG breakpointIO2(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_IOPORT;
+	      BreakLength[i] = TWO_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+// BI4
+
+ULONG breakpointIO4(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_IOPORT;
+	      BreakLength[i] = FOUR_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+// BI
+
+ULONG breakpointIO(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_IOPORT;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+ 	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return TRUE;
+
+}
+
+// B
+
+ULONG breakpointExecute(BYTE *cmd,
+		   StackFrame *stackFrame, ULONG Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register ULONG address, i, r;
+     register BYTE *pB, *symbolName;
+     register BYTE *moduleName;
+     ULONG valid;
+     register int c = get_processor_id();
+
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ') cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+     {
+        register int found = 0;
+
+	for (i=0; i < 4; i++)
+	{
+	   if (BreakReserved[i])
+	   {
+	      symbolName = GetSymbolFromValue(BreakPoints[i], &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(BreakPoints[i], 
+                                           &modbuf[c][0], MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("Break %i is at 0x%08X (%s %s) %s|%s\n",
+				(int)i,
+				(unsigned)BreakPoints[i],
+				BreakDescription[(BreakType[i] & 3)],
+				BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                : (char *)("")),
+			        ((char *)(symbolName) ? (char *)(symbolName) 
+                                : (char *)("")));
+              else
+	         DBGPrint("Break %i is at 0x%08X (%s %s) %s\n",
+				(int)i,
+				(unsigned)BreakPoints[i],
+				BreakDescription[(BreakType[i] & 3)],
+				BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(symbolName) ? (char *)(symbolName) 
+                                : (char *)("")));
+				
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+              found = TRUE;
+	   }
+	}
+        if (!found)
+           DBGPrint("no breakpoints currently defined\n");
+
+     }
+     else
+     {
+	for (i=0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r=0; r < 255 && *pB; r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_EXECUTE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName) 
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName) 
+                                 : (char *)("")));
+				 
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return TRUE;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     return TRUE;
+
+}
+
+// BST
+
+ULONG breakpointShowTemp(BYTE *cmd,
+			StackFrame *stackFrame, ULONG Exception,
+			DEBUGGER_PARSER *parser)
+{
+     register ULONG i;
+     register BYTE *symbolName;
+     register BYTE *moduleName;
+     register int found = 0;
+     register int c = get_processor_id();
+     
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     for (i=0; i < 4; i++)
+     {
+	if (BreakReserved[i] && BreakTemp[i])
+	{
+	   symbolName = GetSymbolFromValue(BreakPoints[i], &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	   moduleName = GetModuleInfoFromSymbolValue(BreakPoints[i], 
+                                           &modbuf[c][0], MAX_SYMBOL_LEN);
+           if (moduleName)
+	      DBGPrint("Break %i is at 0x%08X (%s %s) %s|%s [%s]\n",
+				(int)i,
+				(unsigned)BreakPoints[i],
+				BreakDescription[(BreakType[i] & 3)],
+				BreakLengthDescription[(BreakLength[i] & 3)],
+			       ((char *)(moduleName) ? (char *)(moduleName) 
+                                : (char *)("")),
+			        ((char *)(symbolName) ? (char *)(symbolName) 
+                                : (char *)("")),
+				BreakGo[i] ? "GO" : BreakProceed[i] 
+                                ? "PROCEED" : "");
+           else
+	      DBGPrint("Break %i is at 0x%08X (%s %s) %s [%s]\n",
+				(int)i,
+				(unsigned)BreakPoints[i],
+				BreakDescription[(BreakType[i] & 3)],
+				BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(symbolName) ? (char *)(symbolName) 
+                                : (char *)("")),
+				BreakGo[i] ? "GO" : BreakProceed[i] 
+                                ? "PROCEED" : "");
+	   if (ConditionalBreakpoint[i])
+	      DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+           found = TRUE;
+	}
+     }
+     if (!found)
+        DBGPrint("no temporary breakpoints defined\n");
+
+     return TRUE;
+
+}
+
+ULONG displayProcessorStatusHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    mdb_printf("displays active processors and their current state\n");
+    return TRUE;
+}
+
+ULONG displayProcessorStatus(BYTE *cmd,
+		       StackFrame *stackFrame, ULONG Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     register ULONG i;
+
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     for (i=0; i < MAX_PROCESSORS; i++)
+     {
+        if (cpu_online(i)) 
+        {
+	   mdb_printf("Processor: (%i)  State:  %s\n",
+	              i, procState[ProcessorState[i] & 0xF]);
+        }
+     }
+     return TRUE;
+}
+
+void displayMTRRRegisters(void)
+{
+    register int i;
+    ULONG base1, base2;
+    ULONG mask1, mask2;
+    extern ULONG cpu_mttr_on(void);
+
+    if (cpu_mttr_on())
+    {
+       DBGPrint("memory type range registers\n");
+       for (i = 0; i < 8; i++)
+       {
+	  ReadMSR(MTRR_BASE_REGS[i], &base1, &base2);
+	  ReadMSR(MTRR_MASK_VALUES[i], &mask1, &mask2);
+	  DBGPrint("MTRR_BASE_%i  %08X:%08X   MTRR_MASK_%i  %08X:%08X\n",
+			   (int)i, 
+                           (unsigned)base1, (unsigned)base2, 
+                           (int)i, 
+                           (unsigned)mask1, (unsigned)mask2);
+       }
+    }
+    else
+       DBGPrint("memory type range registers are Pentium Pro/II/Xeon and above\n");
+    return;
+}
+
+void DisplayGDT(BYTE *GDT_ADDRESS)
+{
+
+    register int i, r;
+    ULONG count;
+    ULONG gdt_pointer;
+    WORD gdt_index;
+    BYTE *p;
+    BYTE GDTR[8];
+    GDT *gdt;
+    TSS *tss;
+    union 
+    {
+       GDT lgdt;
+       BYTE data[8];
+    } lg;
+
+    ReadGDTR((ULONG *)&GDTR[0]);
+    gdt_index = mdb_getword((ULONG)&GDTR[0], 2);
+    gdt_pointer = mdb_getword((ULONG)&GDTR[2], 4);
+
+    DBGPrint("GDTR: %04X:%08X  Processor: %i\n", 
+                  (unsigned)gdt_index, (unsigned)gdt_pointer, 
+                  (int)get_processor_id());
+
+    count = 0;
+    gdt_index = (gdt_index + 7) / 8;
+    p = (BYTE *) gdt_pointer;
+    for (i=0; i < gdt_index; i++)
+    {
+       if (DBGPrint("%08X (%04i):", (unsigned) count, (int)i)) return;
+       for (r=0; r < 8; r++)
+       {
+	  lg.data[r] = (BYTE) mdb_getword((ULONG)&p[r], 1);
+	  if (DBGPrint(" %02X", (BYTE) lg.data[r])) return;
+       }
+
+       gdt = (GDT *) &lg.lgdt;
+       if ((gdt->GDTType & 0x92) == 0x92)
+       {
+	  if (DBGPrint("  b:%08X lim:%08X t:%02X ot:%02X",
+		   ((gdt->Base3 << 24) | (gdt->Base2 << 16) | 
+                   (gdt->Base1)),
+		   (((gdt->OtherType & 0xF) << 16) | (gdt->Limit)),
+		   gdt->GDTType, gdt->OtherType)) return;
+       }
+       else if ((gdt->GDTType & 0x89) == 0x89)
+       {
+	  tss = (TSS *) gdt;
+	  if (DBGPrint("  tss:%08X lim:%04X t:%02X ot:%02X",
+		      ((tss->TSSBase3 << 24) | (tss->TSSBase2 << 16) | 
+                      (tss->TSSBase1)),
+		      tss->TSSLimit, tss->TSSType, 
+                      tss->TSSOtherType)) return;
+       }
+       if (DBGPrint("\n")) return;
+
+       p = (void *)((ULONG) p + (ULONG) 8);
+       count += 8;
+    }
+
+    return;
+
+}
+
+void DisplayIDT(BYTE *IDT_ADDRESS)
+{
+
+    register int i, r;
+    ULONG count;
+    ULONG idt_pointer;
+    WORD idt_index;
+    BYTE *p;
+    BYTE IDTR[8];
+    IDT *idt;
+    TSS_GATE *tss_gate;
+    union 
+    {
+       IDT lidt;
+       BYTE data[8];   
+    } id;
+
+    ReadIDTR((ULONG *)&IDTR[0]);
+    idt_index = mdb_getword((ULONG)&IDTR[0], 2);
+    idt_pointer = mdb_getword((ULONG)&IDTR[2], 4);
+
+    DBGPrint("IDTR: %04X:%08X  Processor: %i\n", 
+                    (unsigned)idt_index, (unsigned)idt_pointer, 
+                    (int)get_processor_id());
+
+    count = 0;
+    idt_index = (idt_index + 7) / 8;
+    p = (BYTE *) idt_pointer;
+    for (i=0; i < idt_index; i++)
+    {
+       if (DBGPrint("%08X (%04i):", (unsigned)count, (int)i)) return;
+       for (r=0; r < 8; r++)
+       {
+	   id.data[r] = mdb_getword((ULONG)&p[r], 1);
+	   if (DBGPrint(" %02X", (BYTE) id.data[r])) return;
+       }
+       idt = (IDT *) &id.lidt;
+       if ((idt->IDTFlags & 0x8E) == 0x8E)
+       {
+	  if (DBGPrint("  b:%08X s:%04X t:%02X ot:%02X",
+			     ((idt->IDTHigh << 16) | (idt->IDTLow)),
+			     idt->IDTSegment,
+			     idt->IDTFlags, idt->IDTSkip)) return;
+
+       }
+       else if ((idt->IDTFlags & 0x85) == 0x85)
+       {
+	  tss_gate = (TSS_GATE *) idt;
+	  if (DBGPrint("  task_gate: %04X t:%02X",
+		     tss_gate->TSSSelector, tss_gate->TSSFlags)) return;
+       }
+       if (DBGPrint("\n")) return;
+
+       p = (void *)((ULONG) p + (ULONG) 8);
+       count += 8;
+    }
+
+    return;
+
+}
+
+void DisplayTSS(StackFrame *stackFrame)
+{
+
+    ULONG i, f = 0;
+
+    DBGPrint("Task State Segment at 0x%08X\n", 
+        (unsigned)stackFrame);
+
+    DBGPrint("LDT: %08X  CR3: %08X  IOMAP: %08X  BLINK: %08X\n",
+	(unsigned)stackFrame->tLDT, 
+        (unsigned)stackFrame->tCR3, 
+        (unsigned)stackFrame->tIOMap, 
+        (unsigned)stackFrame->tReserved[0]);
+
+    DBGPrint("CS: %04X  DS: %04X  ES: %04X  FS: %04X  GS: %04X  SS: %04X\n",
+       (unsigned)stackFrame->tCS, 
+       (unsigned)stackFrame->tDS, 
+       (unsigned)stackFrame->tES,
+       (unsigned)stackFrame->tFS, 
+       (unsigned)stackFrame->tGS, 
+       (unsigned)stackFrame->tSS);
+
+    DBGPrint("EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X\n",
+       (unsigned)stackFrame->tEAX, 
+       (unsigned)stackFrame->tEBX, 
+       (unsigned)stackFrame->tECX, 
+       (unsigned)stackFrame->tEDX);
+
+    DBGPrint("ESI: %08X  EDI: %08X  ESP: %08X  EBP: %08X\n",
+       (unsigned)stackFrame->tESI, 
+       (unsigned)stackFrame->tEDI, 
+       (unsigned)stackFrame->tESP, 
+       (unsigned)stackFrame->tEBP);
+
+    DBGPrint("EIP: %08X  FLAGS: %08X ",
+       (unsigned)stackFrame->tEIP, 
+       (unsigned)stackFrame->tSystemFlags);
+
+    DBGPrint(" (");
+    for (i=0; i < 22; i++)
+    {
+       if (IA32Flags[i])
+       {
+	  if ((stackFrame->tSystemFlags >> i) & 0x00000001)
+	  {
+	     if (f)
+		DBGPrint(" ");
+	     f = 1;
+	     DBGPrint("%s", IA32Flags[i]);
+	  }
+       }
+    }
+    DBGPrint(")\n");
+
+
+}
+
+void DisplayGeneralRegisters(StackFrame *stackFrame)
+{
+
+    ULONG i, f = 0;
+
+    DBGPrint("EAX: %08X ", (unsigned)stackFrame->tEAX);
+    DBGPrint("EBX: %08X ", (unsigned)stackFrame->tEBX);
+    DBGPrint("ECX: %08X ", (unsigned)stackFrame->tECX);
+    DBGPrint("EDX: %08X\n", (unsigned)stackFrame->tEDX);
+    DBGPrint("ESI: %08X ", (unsigned)stackFrame->tESI);
+    DBGPrint("EDI: %08X ", (unsigned)stackFrame->tEDI);
+    DBGPrint("ESP: %08X ", (unsigned)stackFrame->tESP);
+    DBGPrint("EBP: %08X\n", (unsigned)stackFrame->tEBP);
+
+    if (segment_toggle)
+       DisplaySegmentRegisters(stackFrame);
+
+    DBGPrint("EIP: %08X ", (unsigned)stackFrame->tEIP);
+    DBGPrint("ORGEAX: %08X ", (unsigned)stackFrame->tReserved[1]);
+    DBGPrint("EFLAGS: %08X ", (unsigned)stackFrame->tSystemFlags);
+
+    DBGPrint(" (");
+    for (i=0; i < 22; i++)
+    {
+       if (IA32Flags[i])
+       {
+	  if ((stackFrame->tSystemFlags >> i) & 0x00000001)
+	  {
+	     if (f)
+		DBGPrint(" ");
+	     f = 1;
+	     DBGPrint("%s", IA32Flags[i]);
+	  }
+       }
+    }
+    DBGPrint(")\n");
+
+}
+
+void DisplaySegmentRegisters(StackFrame *stackFrame)
+{
+
+    DBGPrint("CS: %04X ", (unsigned)stackFrame->tCS);
+    DBGPrint("DS: %04X ", (unsigned)stackFrame->tDS);
+    DBGPrint("ES: %04X ", (unsigned)stackFrame->tES);
+    DBGPrint("FS: %04X ", (unsigned)stackFrame->tFS);
+    DBGPrint("GS: %04X ", (unsigned)stackFrame->tGS);
+    DBGPrint("SS: %04X\n", (unsigned)stackFrame->tSS);
+
+}
+
+void DisplayControlRegisters(ULONG processor, StackFrame *stackFrame)
+{
+
+    BYTE GDTR[8], IDTR[8];
+
+    if (stackFrame) {};
+
+    DBGPrint("CR0: %08X ", (unsigned)ReadCR0());
+    DBGPrint("CR2: %08X ", (unsigned)ReadCR2());
+    DBGPrint("CR3: %08X ", (unsigned)ReadCR3());
+    DBGPrint("CR4: %08X\n", (unsigned)ReadCR4());
+    DBGPrint("DR0: %08X ", (unsigned)ReadDR0());
+    DBGPrint("DR1: %08X ", (unsigned)ReadDR1());
+    DBGPrint("DR2: %08X ", (unsigned)ReadDR2());
+    DBGPrint("DR3: %08X\n", (unsigned)ReadDR3());
+    DBGPrint("DR6: %08X ", (unsigned)ReadDR6());
+    DBGPrint("DR7: %08X ", (unsigned)ReadDR7());
+    DBGPrint("VR6: %08X ", (unsigned)CurrentDR6[processor]);
+    DBGPrint("VR7: %08X\n", (unsigned)CurrentDR7);
+
+    ReadGDTR((ULONG *)&GDTR[0]);
+    ReadIDTR((ULONG *)&IDTR[0]);
+    DBGPrint("GDTR: %04X:%08X IDTR: %04X:%08X  LDTR: %04X  TR: %04X\n",
+			(unsigned)*(WORD *)&GDTR[0], 
+                        (unsigned)*(ULONG *)&GDTR[2],
+			(unsigned)*(WORD *)&IDTR[0], 
+                        (unsigned)*(ULONG *)&IDTR[2],
+			(unsigned)ReadLDTR(), 
+                        (unsigned)ReadTR());
+
+}
+
+ULONG ConsoleDisplayBreakReason(StackFrame *stackFrame, ULONG Exception, 
+                                ULONG processor, ULONG lastCommand)
+{
+       if (last_mdb_oops)
+          DBGPrint("\nKernel Oops reported (%s)\n", last_mdb_oops);
+
+       if ((CurrentDR6[processor] & B0_BIT) && (CurrentDR7 & G0_BIT) && 
+            Exception == 1)
+       {
+	  if (BreakGo[0])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - GO breakpoint (0)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (BreakProceed[0])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed breakpoint (0)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (BreakPoints[0] && ConditionalBreakpoint[0])
+	  {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 0 (%s)\n",
+				 (unsigned)stackFrame->tEIP, 
+                                 BreakDescription[(BreakType[0] & 3)]);
+	     DBGPrint("expr: %s was TRUE\n", BreakCondition[0]);
+             return 1;
+	  }
+	  else
+          if (BreakPoints[0])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 0 (%s)\n",
+				 (unsigned)stackFrame->tEIP, 
+                                 BreakDescription[(BreakType[0] & 3)]);
+             return 1;
+          } 
+          else
+             return 0;  // not one of ours
+       }
+       else 
+       if ((CurrentDR6[processor] & B1_BIT) && (CurrentDR7 & G1_BIT) && 
+            Exception == 1)
+       {
+	  if (BreakGo[1])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - GO breakpoint (1)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (BreakProceed[1])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed breakpoint (1)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (BreakPoints[1] && ConditionalBreakpoint[1])
+	  {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 1 (%s)\n",
+				 (unsigned)stackFrame->tEIP, 
+                                 BreakDescription[(BreakType[1] & 3)]);
+	     DBGPrint("expr: %s was TRUE\n", BreakCondition[1]);
+             return 1;
+	  }
+	  else
+          if (BreakPoints[1])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 1 (%s)\n",
+				 (unsigned)stackFrame->tEIP, 
+                                 BreakDescription[(BreakType[1] & 3)]);
+             return 1;
+          }
+          else
+             return 0;  // not one of ours
+       }
+       else 
+       if ((CurrentDR6[processor] & B2_BIT) && (CurrentDR7 & G2_BIT) && 
+            Exception == 1)
+       {
+	  if (BreakGo[2])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - GO breakpoint (2)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (BreakProceed[2])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed breakpoint (2)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (BreakPoints[2] && ConditionalBreakpoint[2])
+	  {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 2 (%s)\n",
+				 (unsigned)stackFrame->tEIP, 
+                                 BreakDescription[(BreakType[2] & 3)]);
+	     DBGPrint("expr: %s was TRUE\n", BreakCondition[2]);
+             return 1;
+	  }
+	  else
+          if (BreakPoints[2])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 2 (%s)\n",
+				 (unsigned)stackFrame->tEIP, 
+                                 BreakDescription[(BreakType[2] & 3)]);
+             return 1;
+          }  
+          else
+             return 0;  // not one of ours
+       }
+       else 
+       if ((CurrentDR6[processor] & B3_BIT) && (CurrentDR7 & G3_BIT) && 
+            Exception == 1)
+       {
+	  if (BreakGo[3])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - GO breakpoint (3)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (BreakProceed[3])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed breakpoint (3)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (BreakPoints[3] && ConditionalBreakpoint[3])
+	  {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 3 (%s)\n",
+				 (unsigned)stackFrame->tEIP, 
+                                 BreakDescription[(BreakType[3] & 3)]);
+	     DBGPrint("expr: %s was TRUE\n", BreakCondition[3]);
+             return 1;
+	  }
+	  else
+          if (BreakPoints[3])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 3 (%s)\n",
+				 (unsigned)stackFrame->tEIP, 
+                                 BreakDescription[(BreakType[3] & 3)]);
+             return 1;
+          }
+          else
+             return 0;  // not one of ours
+       }
+       else
+       {
+	  // if the last command was a Proceed that was converted into a
+	  // single step command, report proceed single step
+	  if (lastCommandEntry == 'P' && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed (single step)\n", 
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (lastCommandEntry == 'T' && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Trace (single step)\n", 
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+          else
+	  if (lastCommandEntry == K_F8 && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed (single step)\n", 
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (lastCommandEntry == K_F7 && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Trace (single step)\n", 
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else 
+          if (lastCommandEntry == K_F6 && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Step (single step)\n",
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+          else
+          if (Exception == 3)  // not our exception
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - INT3 breakpoint\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+          else
+          if (Exception == 1)  // not our exception, must be gdb
+          {
+             return 0;
+          }
+	  else
+          if ((Exception < exceptions) && 
+              ExceptionDescription[Exception % exceptions])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - %s\n", 
+                    (unsigned)stackFrame->tEIP, 
+                    ExceptionDescription[Exception % exceptions]);
+             return 1;
+          }
+          else
+          {  
+	     DBGPrint("\nBreak at 0x%08X due to - %lu\n", 
+                    (unsigned)stackFrame->tEIP, Exception);
+             return 1;
+          }
+       }
+       return 0;
+
+}
+
+ULONG ReasonHelp(BYTE *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    mdb_printf("display break reason\n");
+    return TRUE;
+}
+
+ULONG ReasonDisplay(BYTE *cmd,
+		    StackFrame *stackFrame, ULONG Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     if (cmd) {};
+     if (stackFrame) {};
+     if (Exception) {};
+     if (parser) {};
+
+     ConsoleDisplayBreakReason(stackFrame, Exception, get_processor_id(), 0);
+     return TRUE;
+}
+
+void ReadStackFrame(void *frame, StackFrame *sf, ULONG processor)
+{
+   struct pt_regs *regs = frame;
+
+   sf->tCR3 = (ULONG *)ReadCR3();
+   sf->tEIP = regs->eip;
+   sf->tSystemFlags = regs->eflags;
+   sf->tReserved[1] = regs->orig_eax;
+   sf->tReserved[2] = (ULONG)regs;
+   sf->tEAX = regs->eax;
+   sf->tECX = regs->ecx; 
+   sf->tEDX = regs->edx; 
+   sf->tEBX = regs->ebx; 
+   sf->tEBP = regs->ebp; 
+   sf->tESI = regs->esi;  
+   sf->tEDI = regs->edi; 
+   sf->tES = (WORD)regs->xes; 
+   sf->tCS = (WORD)regs->xcs; 
+   sf->tDS = (WORD)regs->xds; 
+   sf->tFS = (ReadFS() & 0xFFFF);
+   sf->tGS = (ReadGS() & 0xFFFF);
+   sf->tLDT = (ReadLDTR() & 0xFFFF);
+   if ((regs->xcs & 0xffff) == __KERNEL_CS) 
+   {
+      sf->tESP = (ULONG)((ULONG)regs + sizeof(struct pt_regs) - 2*4); 
+      asm volatile("pushl %%ss\n"
+		   "popl %0\n"
+                  :"=m" (sf->tSS));
+      sf->tSS &= 0xFFFF;
+   }
+   else
+   {
+      sf->tESP = regs->esp; 
+      sf->tSS = (WORD)regs->xss; 
+   }
+   // save state.
+   memmove((void *)&ReferenceFrame[processor], sf, sizeof(StackFrame));
+   return;
+}
+
+void WriteStackFrame(void *frame, StackFrame *sf, ULONG processor)
+{
+   struct pt_regs *regs = frame;
+
+   if (ReferenceFrame[processor].tEIP != sf->tEIP)
+      regs->eip = sf->tEIP;
+   if (ReferenceFrame[processor].tSystemFlags != sf->tSystemFlags)
+      regs->eflags = sf->tSystemFlags;
+   if (ReferenceFrame[processor].tReserved[1] != sf->tReserved[1])
+      regs->orig_eax = sf->tReserved[1];
+   if (ReferenceFrame[processor].tEAX != sf->tEAX)
+      regs->eax = sf->tEAX;
+   if (ReferenceFrame[processor].tECX != sf->tECX)
+      regs->ecx = sf->tECX; 
+   if (ReferenceFrame[processor].tEDX != sf->tEDX)
+      regs->edx = sf->tEDX; 
+   if (ReferenceFrame[processor].tEBX != sf->tEBX)
+      regs->ebx = sf->tEBX; 
+   if (ReferenceFrame[processor].tESP != sf->tESP)
+      regs->esp = sf->tESP; 
+   if (ReferenceFrame[processor].tEBP != sf->tEBP)
+      regs->ebp = sf->tEBP; 
+   if (ReferenceFrame[processor].tESI != sf->tESI)
+      regs->esi = sf->tESI; 
+   if (ReferenceFrame[processor].tEDI != sf->tEDI)
+      regs->edi = sf->tEDI; 
+   if (ReferenceFrame[processor].tES != sf->tES)
+      regs->xes = sf->tES; 
+   if (ReferenceFrame[processor].tCS != sf->tCS)
+      regs->xcs = sf->tCS; 
+   if (ReferenceFrame[processor].tSS != sf->tSS)
+      regs->xss = sf->tSS; 
+   if (ReferenceFrame[processor].tDS != sf->tDS)
+      regs->xds = sf->tDS; 
+   return;
+}
+
+void SetDebugRegisters(void)
+{
+   register int i;
+
+   for (i=0; i < 4; i++)
+   {
+      switch (i)
+      {
+	 case 0:
+	    if (BreakReserved[i])
+	    {
+	       CurrentDR7 &= 0xFFF0FFFF;
+	       CurrentDR7 |= G0_BIT;
+	       CurrentDR7 |= ((BreakType[i] << ((i * 4) + 16)) |
+			      (BreakLength[i] << ((i * 4) + 18)));
+	    }
+	    else
+	    {
+	       CurrentDR7 &= 0xFFF0FFFF;
+	       CurrentDR7 &= ~G0_BIT;
+	       CurrentDR7 &= ~L0_BIT;
+	    }
+	    WriteDR0(BreakPoints[i]);
+	    break;
+
+	 case 1:
+	    if (BreakReserved[i])
+	    {
+	       CurrentDR7 &= 0xFF0FFFFF;
+	       CurrentDR7 |= G1_BIT;
+	       CurrentDR7 |= ((BreakType[i] << ((i * 4) + 16)) |
+			      (BreakLength[i] << ((i * 4) + 18)));
+	    }
+	    else
+	    {
+	       CurrentDR7 &= 0xFF0FFFFF;
+	       CurrentDR7 &= ~G1_BIT;
+	       CurrentDR7 &= ~L1_BIT;
+	    }
+	    WriteDR1(BreakPoints[i]);
+	    break;
+
+	 case 2:
+	    if (BreakReserved[i])
+	    {
+	       CurrentDR7 &= 0xF0FFFFFF;
+	       CurrentDR7 |= G2_BIT;
+	       CurrentDR7 |= ((BreakType[i] << ((i * 4) + 16)) |
+			      (BreakLength[i] << ((i * 4) + 18)));
+	    }
+	    else
+	    {
+	       CurrentDR7 &= 0xF0FFFFFF;
+	       CurrentDR7 &= ~G2_BIT;
+	       CurrentDR7 &= ~L2_BIT;
+	    }
+	    WriteDR2(BreakPoints[i]);
+	    break;
+
+	 case 3:
+	    if (BreakReserved[i])
+	    {
+	       CurrentDR7 &= 0x0FFFFFFF;
+	       CurrentDR7 |= G3_BIT;
+	       CurrentDR7 |= ((BreakType[i] << ((i * 4) + 16)) |
+			      (BreakLength[i] << ((i * 4) + 18)));
+	    }
+	    else
+	    {
+	       CurrentDR7 &= 0x0FFFFFFF;
+	       CurrentDR7 &= ~G3_BIT;
+	       CurrentDR7 &= ~L3_BIT;
+	    }
+	    WriteDR3(BreakPoints[i]);
+	    break;
+
+      }
+   }
+   return;
+
+}
+
+void LoadDebugRegisters(void)
+{
+
+   register int i;
+
+   WriteDR6(0);  // clear last exception status
+   for (i=0; i < 4; i++)
+   {
+      switch (i)
+      {
+	 case 0:
+	    if (BreakReserved[i])
+	       WriteDR0(BreakPoints[i]);
+	    break;
+
+	 case 1:
+	    if (BreakReserved[i])
+	       WriteDR1(BreakPoints[i]);
+	    break;
+
+	 case 2:
+	    if (BreakReserved[i])
+	       WriteDR2(BreakPoints[i]);
+	    break;
+
+	 case 3:
+	    if (BreakReserved[i])
+	       WriteDR3(BreakPoints[i]);
+	    break;
+      }
+   }
+   WriteDR7(CurrentDR7);  // set breakpoint enable/disable state
+
+}
+
+//
+//   returns   0 - atomic lock occurred, processor assigned
+//             1 - recusive count increased
+//
+
+ULONG rspin_lock(volatile rlock_t *rlock)
+{
+#if defined(CONFIG_SMP)
+   register ULONG proc = get_processor_id();
+   register ULONG retCode;
+
+   if (rlock->lock.raw_lock.slock && rlock->processor == proc)
+   {
+      rlock->count++;
+      retCode = 1;
+   }
+   else
+   {
+      spin_lock_irqsave((spinlock_t *)&rlock->lock, rlock->flags);
+      rlock->processor = proc;
+      retCode = 0;
+   }
+   return retCode;
+#else
+   return 0;
+#endif
+}
+
+//
+//   returns   0 - lock released
+//             1 - recusive count decreased
+//
+
+ULONG rspin_unlock(volatile rlock_t *rlock)
+{
+#if defined(CONFIG_SMP)
+   register ULONG retCode;
+
+   if (rlock->count)
+   {
+      rlock->count--;
+      retCode = 1;
+   }
+   else
+   {
+      rlock->processor = -1;
+      spin_unlock_irqrestore((spinlock_t *)&rlock->lock, rlock->flags);
+      retCode = 0;
+   }
+   return retCode;
+#else
+   return 0;
+#endif
+}
+
+//
+//   returns   0 - atomic lock occurred, processor assigned
+//             1 - recusive count increased
+//            -1 - atomic try lock failed
+//
+
+ULONG rspin_try_lock(volatile rlock_t *rlock)
+{
+#if defined(CONFIG_SMP)
+   register ULONG proc = get_processor_id();
+   register ULONG retCode;
+
+   if (rlock->lock.raw_lock.slock && rlock->processor == proc)
+   {
+      rlock->count++;
+      retCode = 0;
+   }
+   else
+   {
+      spin_lock_irqsave((spinlock_t *)&rlock->lock, rlock->flags);
+      rlock->processor = proc;
+      retCode = 0;
+   }
+   return retCode;
+#else
+   return 0;
+#endif
+}
+
+ULONG debug_lock(volatile rlock_t *rlock, ULONG p)
+{
+    while (rspin_try_lock(rlock))
+    {
+       if (ProcessorState[p] == PROCESSOR_SHUTDOWN)
+	  return 0;
+    }
+    return 1;
+}
+
+void debug_unlock(volatile rlock_t *rlock)
+{
+    rspin_unlock(rlock);
+}
+
+int mdb_ipi_state(void)
+{
+   return ((ProcessorState[get_processor_id()] == PROCESSOR_IPI) ? 1 : 0);
+}
+
+ULONG StopProcessorsExclSelf(ULONG self)
+{
+#if defined(CONFIG_SMP)
+   register ULONG failed;
+   register ULONG count;
+   register int i;
+   extern void smp_mdb_stop(void);
+
+   for (i=0; i < MAX_PROCESSORS; i++) 
+   {
+      if (cpu_online(i)) 
+      {
+         if (i != self)
+         {
+	    ProcessorHold[i] = TRUE;
+         }
+      }
+   }
+
+   // NMI the other processors
+   send_IPI_allbutself(NMI_VECTOR);
+
+   for (i=0, count=0, failed=0; i < MAX_PROCESSORS; i++) 
+   {
+      if (cpu_online(i)) 
+      {
+         if (i != self)
+         {
+	    while (ProcessorState[i] != PROCESSOR_SUSPEND)
+	    {
+	       if (count++ > 0x1FFFFF)
+	       {
+	          failed++;
+		  mdb_printf("\nProcessor %i could not be halted\n", (int)i);
+		  break;
+	       }
+	    }
+         }
+      }
+   }
+   return (ULONG) failed;
+#else
+   return 0;
+#endif
+}
+
+ULONG FreeProcessorsExclSelf(ULONG self)
+{
+#if defined(CONFIG_SMP)
+   register int i;
+
+   for (i=0; i < MAX_PROCESSORS; i++) 
+      ProcessorState[i] = PROCESSOR_RESUME;
+   return i;
+#else
+   return MAX_PROCESSORS;
+#endif
+
+}
+
+ULONG WaitRestartExclSelf(ULONG self)
+{
+#if defined(CONFIG_SMP)
+   register ULONG failed;
+   register ULONG count;
+   register int i;
+   
+   for (i=0, count=0, failed=0; i < MAX_PROCESSORS; i++) 
+   {
+      if (cpu_online(i)) 
+      {
+         if (i != self)
+         {
+	    while (ProcessorState[i] != PROCESSOR_ACTIVE)
+	    {
+	       if (count++ > 0x1FFFFF)
+	       {
+	          failed++;
+		  mdb_printf("\nProcessor %i could did not restart\n", (int)i);
+		  break;
+	       }
+	    }
+         }
+      }
+   }
+   return (ULONG) failed;
+#else
+   return 0;
+#endif
+}
+
+ULONG debugger_entry(ULONG Exception, StackFrame *stackFrame, 
+                     ULONG processor)
+{
+    register ULONG retCode = TRUE;
+    BYTE *cmd;
+    ULONG valid;
+
+    ProcessorState[processor] = PROCESSOR_DEBUG;
+    CurrentFrame[processor] = stackFrame;
+
+    debuggerActive++;
+
+    WriteDR7(0);  // disable breakpoints while debugger is running
+    CurrentDR6[processor] = ReadDR6();
+
+    if (fpu_present())
+       save_npx(&npx[processor]);
+
+MDBLoop:;
+    switch (Exception)
+    {
+          case 1:// int 1 debug exception
+	    if (BreakMask[processor])
+	    {
+	       stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	       stackFrame->tSystemFlags |= RESUME;
+	       break;
+	    }
+	    else
+	    if ((CurrentDR6[processor] & B0_BIT) && 
+                (CurrentDR7 & G0_BIT) && 
+                (ConditionalBreakpoint[0]))
+	    {
+	       cmd = (BYTE *)&BreakCondition[0][0];
+	       if (!EvaluateExpression(stackFrame, &cmd, &valid))
+	       {
+		  stackFrame->tSystemFlags &= ~SINGLE_STEP;
+		  stackFrame->tSystemFlags |= RESUME;
+		  break;
+	       }
+	    }
+	    else
+	    if ((CurrentDR6[processor] & B1_BIT) && 
+                (CurrentDR7 & G1_BIT) && 
+                (ConditionalBreakpoint[1]))
+	    {
+	       cmd = (BYTE *)&BreakCondition[1][0];
+	       if (!EvaluateExpression(stackFrame, &cmd, &valid))
+	       {
+		  stackFrame->tSystemFlags &= ~SINGLE_STEP;
+		  stackFrame->tSystemFlags |= RESUME;
+		  break;
+	       }
+	    }
+	    else
+	    if ((CurrentDR6[processor] & B2_BIT) && 
+                (CurrentDR7 & G2_BIT) && 
+                (ConditionalBreakpoint[2]))
+	    {
+	       cmd = (BYTE *)&BreakCondition[2][0];
+	       if (!EvaluateExpression(stackFrame, &cmd, &valid))
+	       {
+		  stackFrame->tSystemFlags &= ~SINGLE_STEP;
+		  stackFrame->tSystemFlags |= RESUME;
+		  break;
+	       }
+	    }
+	    else
+	    if ((CurrentDR6[processor] & B3_BIT) && 
+                (CurrentDR7 & G3_BIT) && 
+                (ConditionalBreakpoint[3]))
+	    {
+	       cmd = (BYTE *)&BreakCondition[3][0];
+	       if (!EvaluateExpression(stackFrame, &cmd, &valid))
+	       {
+		  stackFrame->tSystemFlags &= ~SINGLE_STEP;
+		  stackFrame->tSystemFlags |= RESUME;
+		  break;
+	       }
+	    }
+
+            if (debug_lock(&debug_mutex, processor))
+            {
+               if (!ProcessorMode[processor])
+	          StopProcessorsExclSelf(processor);
+
+	       debugger_command_entry(processor, Exception, stackFrame);
+
+               if (!ProcessorMode[processor])
+	          FreeProcessorsExclSelf(processor);
+
+               debug_unlock(&debug_mutex);
+            }
+	    break;
+
+
+	 case 3:// int 3 breakpoint
+	    if (BreakMask[processor])
+	    {
+	       stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	       stackFrame->tSystemFlags |= RESUME;
+	       break;
+	    }
+
+            if (debug_lock(&debug_mutex, processor))
+            {
+               if (!ProcessorMode[processor])
+	          StopProcessorsExclSelf(processor);
+
+	       debugger_command_entry(processor, Exception, stackFrame);
+
+               if (!ProcessorMode[processor])
+	          FreeProcessorsExclSelf(processor);
+
+               debug_unlock(&debug_mutex);
+            }
+	    break;
+
+         case 2: // nmi 
+            if (ProcessorHold[processor])  // hold processor if directed nmi
+            {
+               ProcessorHold[processor] = 0;
+ 	       ProcessorState[processor] = PROCESSOR_SUSPEND;
+               // processor suspend loop
+	       while ((ProcessorState[processor] != PROCESSOR_RESUME) &&
+	              (ProcessorState[processor] != PROCESSOR_SWITCH))
+               {
+   	          if ((ProcessorState[processor] == PROCESSOR_RESUME) ||
+	              (ProcessorState[processor] == PROCESSOR_SWITCH))
+                     break;  
+               }
+
+               if (ProcessorState[processor] == PROCESSOR_SWITCH)
+               {
+   	          ProcessorState[processor] = PROCESSOR_DEBUG;
+                  if (debug_lock(&debug_mutex, processor))
+                  {
+	             debugger_command_entry(processor, 21, stackFrame);
+
+                     if (!ProcessorMode[processor])
+	                FreeProcessorsExclSelf(processor);
+
+                     debug_unlock(&debug_mutex);
+                  }
+               }
+               break;
+            }
+            else   // all other nmi exceptions fall through to here
+            if (debug_lock(&debug_mutex, processor))
+            {
+               if (!ProcessorMode[processor])
+	          StopProcessorsExclSelf(processor);
+
+	       debugger_command_entry(processor, Exception, stackFrame);
+
+               if (!ProcessorMode[processor])
+	          FreeProcessorsExclSelf(processor);
+
+               debug_unlock(&debug_mutex);
+            }
+            break;
+
+	 default:
+            if (debug_lock(&debug_mutex, processor))
+            {
+               if (!ProcessorMode[processor])
+	          StopProcessorsExclSelf(processor);
+
+	       debugger_command_entry(processor, Exception, stackFrame);
+
+               if (!ProcessorMode[processor])
+	          FreeProcessorsExclSelf(processor);
+
+               debug_unlock(&debug_mutex);
+            }
+	    break;
+    }
+
+    if (ProcessorHold[processor])
+    {
+       Exception = 2;
+       goto MDBLoop;
+    }
+
+    LoadDebugRegisters();
+
+    if (fpu_present())
+       load_npx(&npx[processor]);
+
+    if (debuggerActive)
+       debuggerActive--;
+
+    CurrentFrame[processor] = 0;
+    ProcessorState[processor] = PROCESSOR_ACTIVE;
+
+    return retCode;
+
+}
+
+void InitializeDebuggerRegisters(void)
+{
+   CurrentDR7 = (DR7DEF | GEXACT | LEXACT); // set mode to GLOBAL EXACT
+   WriteDR0(0);                      // clear out DR0-DR6
+   WriteDR1(0);
+   WriteDR2(0);
+   WriteDR3(0);
+   WriteDR6(0);
+   WriteDR7(CurrentDR7);            // set DR7 register
+}
+
+void ClearDebuggerRegisters(void)
+{
+   WriteDR0(0);   // clear out all breakpoints and breakpoint
+   WriteDR1(0);   // registers DR0-DR7
+   WriteDR2(0);
+   WriteDR3(0);
+   WriteDR6(0);
+   WriteDR7(0);
+}
+
+#endif
+
diff -Naur ./debug/mdb-ia32.h ../linux-2.6.18-mdb/./debug/mdb-ia32.h
--- ./debug/mdb-ia32.h	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-ia32.h	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,175 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-IA32.H
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#ifndef _MDB_IA32_H
+#define _MDB_IA32_H
+
+typedef struct _StackFrame {
+   ULONG tReserved[7];
+   ULONG *tCR3;
+   ULONG tEIP;
+   ULONG tSystemFlags;
+   ULONG tEAX;
+   ULONG tECX;
+   ULONG tEDX;
+   ULONG tEBX;
+   ULONG tESP;
+   ULONG tEBP;
+   ULONG tESI;
+   ULONG tEDI;
+   WORD tES;
+   WORD Res1;
+   WORD tCS;
+   WORD Res2;
+   WORD tSS;
+   WORD Res3;
+   WORD tDS;
+   WORD Res4;
+   WORD tFS;
+   WORD Res5;
+   WORD tGS;
+   WORD Res6;
+   WORD tLDT;
+   WORD Res7;
+   ULONG tIOMap;
+} StackFrame;
+
+//  128 bytes total size numeric register context
+
+typedef struct _NPXREG {
+  WORD sig0;        //  10 bytes total size this structure
+  WORD sig1;
+  WORD sig2;
+  WORD sig3;
+  WORD exponent:15;
+  WORD sign:1;
+} NUMERIC_REGISTER_CONTEXT;
+
+typedef struct _NPX {
+  ULONG control;
+  ULONG status;
+  ULONG tag;
+  ULONG eip;
+  ULONG cs;
+  ULONG dataptr;
+  ULONG datasel;
+  NUMERIC_REGISTER_CONTEXT reg[8];    // 80 bytes
+  ULONG pad[5];
+} NUMERIC_FRAME;
+
+//  128 bytes total size register context
+
+typedef struct _CONTEXT_FRAME {
+    WORD cBackLink;
+    WORD cTSSReserved;
+    ULONG cESP0;
+    WORD cSS0;
+    WORD cSS0res;
+    ULONG cESP1;
+    WORD cSS1;
+    WORD cSS1res;
+    ULONG cESP2;
+    WORD cSS2;
+    WORD cSS2res;
+    ULONG cCR3;
+    ULONG cEIP;
+    ULONG cSystemFlags;
+    ULONG cEAX;
+    ULONG cECX;
+    ULONG cEDX;
+    ULONG cEBX;
+    ULONG cESP;
+    ULONG cEBP;
+    ULONG cESI;
+    ULONG cEDI;
+    ULONG cES;
+    ULONG cCS;
+    ULONG cSS;
+    ULONG cDS;
+    ULONG cFS;
+    ULONG cGS;
+    ULONG cLDT;
+    ULONG cIOPermissMap;
+    ULONG pad[6];
+} CONTEXT_FRAME;
+
+static inline void _cli(void)
+{
+	__asm__ __volatile__("cli" : : : "memory");
+}
+
+static inline void _sti(void)
+{
+	__asm__ __volatile__("sti" : : : "memory");
+}
+
+static inline unsigned long get_flags(void)
+{
+	unsigned long flags;
+
+	__asm__ __volatile__(
+		"pushfl ; popl %0"
+		: "=g" (flags)
+		: /* no input */
+	);
+	return flags;
+}
+
+static inline unsigned long save_flags(void)
+{
+	unsigned long flags;
+
+	__asm__ __volatile__(
+		"pushfl ; popl %0"
+		: "=g" (flags)
+		: /* no input */
+	);
+	__asm__ __volatile__("cli" : : : "memory");
+	return flags;
+}
+
+static inline void restore_flags(unsigned long flags)
+{
+	__asm__ __volatile__(
+		"pushl %0 ; popfl"
+		: 
+		:"g" (flags)
+		:"memory", "cc"
+	);
+}
+
+#endif
+
diff -Naur ./debug/mdb-keyboard.h ../linux-2.6.18-mdb/./debug/mdb-keyboard.h
--- ./debug/mdb-keyboard.h	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-keyboard.h	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,140 @@
+
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-KEYBOARD.H
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#undef KBD_REPORT_ERR			/* Report keyboard errors */
+#define KBD_REPORT_UNKN			/* Report unknown scan codes */
+#define KBD_REPORT_TIMEOUTS		/* Report keyboard timeouts */
+#undef KBD_IS_FOCUS_9000		/* We have the brain-damaged FOCUS-9000 keyboard */
+#undef INITIALIZE_MOUSE			/* Define if your PS/2 mouse needs initialization. */
+
+
+#define KBD_INIT_TIMEOUT 1000		/* Timeout in ms for initializing the keyboard */
+#define KBC_TIMEOUT 250			/* Timeout in ms for sending to keyboard controller */
+#define KBD_TIMEOUT 1000		/* Timeout in ms for keyboard command acknowledge */
+
+/*
+ *	Keyboard Controller Registers on normal PCs.
+ */
+
+#define KBD_STATUS_REG		0x64	/* Status register (R) */
+#define KBD_CNTL_REG		0x64	/* Controller command register (W) */
+#define KBD_DATA_REG		0x60	/* Keyboard data register (R/W) */
+
+/*
+ *	Keyboard Controller Commands
+ */
+
+#define KBD_CCMD_READ_MODE	0x20	/* Read mode bits */
+#define KBD_CCMD_WRITE_MODE	0x60	/* Write mode bits */
+#define KBD_CCMD_GET_VERSION	0xA1	/* Get controller version */
+#define KBD_CCMD_MOUSE_DISABLE	0xA7	/* Disable mouse interface */
+#define KBD_CCMD_MOUSE_ENABLE	0xA8	/* Enable mouse interface */
+#define KBD_CCMD_TEST_MOUSE	0xA9	/* Mouse interface test */
+#define KBD_CCMD_SELF_TEST	0xAA	/* Controller self test */
+#define KBD_CCMD_KBD_TEST	0xAB	/* Keyboard interface test */
+#define KBD_CCMD_KBD_DISABLE	0xAD	/* Keyboard interface disable */
+#define KBD_CCMD_KBD_ENABLE	0xAE	/* Keyboard interface enable */
+#define KBD_CCMD_WRITE_AUX_OBUF	0xD3    /* Write to output buffer as if
+					   initiated by the auxiliary device */
+#define KBD_CCMD_WRITE_MOUSE	0xD4	/* Write the following byte to the mouse */
+
+/*
+ *	Keyboard Commands
+ */
+
+#define KBD_CMD_SET_LEDS	0xED	/* Set keyboard leds */
+#define KBD_CMD_SET_RATE	0xF3	/* Set typematic rate */
+#define KBD_CMD_ENABLE		0xF4	/* Enable scanning */
+#define KBD_CMD_DISABLE		0xF5	/* Disable scanning */
+#define KBD_CMD_RESET		0xFF	/* Reset */
+
+/*
+ *	Keyboard Replies
+ */
+
+#define KBD_REPLY_POR		0xAA	/* Power on reset */
+#define KBD_REPLY_ACK		0xFA	/* Command ACK */
+#define KBD_REPLY_RESEND	0xFE	/* Command NACK, send the cmd again */
+
+/*
+ *	Status Register Bits
+ */
+
+#define KBD_STAT_OBF 		0x01	/* Keyboard output buffer full */
+#define KBD_STAT_IBF 		0x02	/* Keyboard input buffer full */
+#define KBD_STAT_SELFTEST	0x04	/* Self test successful */
+#define KBD_STAT_CMD		0x08	/* Last write was a command write (0=data) */
+#define KBD_STAT_UNLOCKED	0x10	/* Zero if keyboard locked */
+#define KBD_STAT_MOUSE_OBF	0x20	/* Mouse output buffer full */
+#define KBD_STAT_GTO 		0x40	/* General receive/xmit timeout */
+#define KBD_STAT_PERR 		0x80	/* Parity error */
+
+#define AUX_STAT_OBF (KBD_STAT_OBF | KBD_STAT_MOUSE_OBF)
+
+/*
+ *	Controller Mode Register Bits
+ */
+
+#define KBD_MODE_KBD_INT	0x01	/* Keyboard data generate IRQ1 */
+#define KBD_MODE_MOUSE_INT	0x02	/* Mouse data generate IRQ12 */
+#define KBD_MODE_SYS 		0x04	/* The system flag (?) */
+#define KBD_MODE_NO_KEYLOCK	0x08	/* The keylock doesn't affect the keyboard if set */
+#define KBD_MODE_DISABLE_KBD	0x10	/* Disable keyboard interface */
+#define KBD_MODE_DISABLE_MOUSE	0x20	/* Disable mouse interface */
+#define KBD_MODE_KCC 		0x40	/* Scan code conversion to PC format */
+#define KBD_MODE_RFU		0x80
+
+/*
+ *	Mouse Commands
+ */
+
+#define AUX_SET_RES		0xE8	/* Set resolution */
+#define AUX_SET_SCALE11		0xE6	/* Set 1:1 scaling */
+#define AUX_SET_SCALE21		0xE7	/* Set 2:1 scaling */
+#define AUX_GET_SCALE		0xE9	/* Get scaling factor */
+#define AUX_SET_STREAM		0xEA	/* Set stream mode */
+#define AUX_SET_SAMPLE		0xF3	/* Set sample rate */
+#define AUX_ENABLE_DEV		0xF4	/* Enable aux device */
+#define AUX_DISABLE_DEV		0xF5	/* Disable aux device */
+#define AUX_RESET		0xFF	/* Reset aux device */
+#define AUX_ACK			0xFA	/* Command byte ACK. */
+
+#define AUX_BUF_SIZE		2048	/* This might be better divisible by
+					   three to make overruns stay in sync
+					   but then the read function would need
+					   a lock etc - ick */
+
diff -Naur ./debug/mdb-list.c ../linux-2.6.18-mdb/./debug/mdb-list.c
--- ./debug/mdb-list.c	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-list.c	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,585 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-LIST.C
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#include "mdb.h"
+
+#ifdef CONFIG_MDB
+
+#ifdef MDB_ATOMIC
+static spinlock_t accelLock = SPIN_LOCK_UNLOCKED;
+static long accelflags = 0;
+#endif
+
+ACCELERATOR *accelHead = 0;
+ACCELERATOR *accelTail = 0;
+
+ULONG AccelRoutine(ULONG key, void *p)
+{
+    register ACCELERATOR *accel;
+    ULONG retCode;
+
+    accel = accelHead;
+    while (accel)
+    {
+       if (accel->accelFlags && accel->accelRoutine && accel->key == key)
+       {
+	  retCode = (accel->accelRoutine)(key, p, accel);
+	  return retCode;
+       }
+       accel = accel->accelNext;
+    }
+    return 0;
+}
+
+void ShowDebuggerAccelerators(void)
+{
+   register ACCELERATOR *accel;
+
+   DBGPrint("\nDebugger Keystroke Accelerator(s)\n");
+
+   accel = accelHead;
+   while (accel)
+   {
+      if (accel->shortHelp)
+         if (DBGPrint("%s\n", accel->shortHelp)) return;
+      accel = accel->accelNext;
+   }
+   return;
+}
+
+ULONG IsAccelerator(ULONG key)
+{
+    register ACCELERATOR *accel;
+    
+    accel = accelHead;
+    while (accel)
+    {
+       if (accel->accelFlags && accel->accelRoutine && accel->key == key)
+       {
+	  return 1;
+       }
+       accel = accel->accelNext;
+    }
+    return 0;
+}
+
+ULONG AccelHelpRoutine(ULONG key)
+{
+    register ACCELERATOR *accel;
+
+    accel = accelHead;
+    if (key)  // if we were passed a command string
+    {
+       while (accel)
+       {
+	  if (accel->accelFlags && accel->key == key)
+	  {
+	     if (accel->accelRoutineHelp)
+	     {
+		DBGPrint("Accelerator %08X\n", (unsigned)accel->key);
+		(accel->accelRoutineHelp)(key, accel);
+		return 1;
+	     }
+	     DBGPrint("Accelerator %08X\n", (unsigned)accel->key);
+	     return 1;
+	  }
+	  accel = accel->accelNext;
+       }
+       DBGPrint("Help for Accelerator [%08X] not found\n", (unsigned)key);
+       return 1;
+    }
+    else
+    {
+       DBGPrint("Accelerator(s)\n");
+       while (accel)
+       {
+	  if (accel->accelFlags && accel->key && !accel->supervisorCommand)
+	     DBGPrint("%08X         - %s\n", 
+                      (unsigned)accel->key, accel->shortHelp);
+	  accel = accel->accelNext;
+       }
+    }
+    return 0;
+}
+
+ACCELERATOR *insertAccel(ACCELERATOR *i, ACCELERATOR *top)
+{
+    ACCELERATOR *old, *p;
+
+    if (!accelTail)
+    {
+       i->accelNext = i->accelPrior = NULL;
+       accelTail = i;
+       return i;
+    }
+    p = top;
+    old = NULL;
+    while (p)
+    {
+       if (p->key < i->key)
+       {
+	  old = p;
+	  p = p->accelNext;
+       }
+       else
+       {
+	  if (p->accelPrior)
+	  {
+	     p->accelPrior->accelNext = i;
+	     i->accelNext = p;
+	     i->accelPrior = p->accelPrior;
+	     p->accelPrior = i;
+	     return top;
+	  }
+	  i->accelNext = p;
+	  i->accelPrior = NULL;
+	  p->accelPrior = i;
+	  return i;
+       }
+    }
+    old->accelNext = i;
+    i->accelNext = NULL;
+    i->accelPrior = old;
+    accelTail = i;
+    return accelHead;
+
+}
+
+ULONG AddAccelRoutine(ACCELERATOR *newAccel)
+{
+    register ACCELERATOR *accel;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&accelLock, accelflags);
+#endif
+    accel = accelHead;
+    while (accel)
+    {
+       if (accel == newAccel || accel->key == newAccel->key)
+       {
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&accelLock, accelflags);  
+#endif
+	  return 1;
+       }
+       accel = accel->accelNext;
+    }
+    newAccel->accelFlags = -1;
+    accelHead = insertAccel(newAccel, accelHead);
+
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&accelLock, accelflags);
+#endif
+    return 0;
+}
+
+ULONG RemoveAccelRoutine(ACCELERATOR *newAccel)
+{
+    register ACCELERATOR *accel;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&accelLock, accelflags);
+#endif
+    accel = accelHead;
+    while (accel)
+    {
+       if (accel == newAccel)   // found, remove from list
+       {
+	  if (accelHead == newAccel)
+	  {
+	     accelHead = (void *) newAccel->accelNext;
+	     if (accelHead)
+		accelHead->accelPrior = NULL;
+	     else
+		accelTail = NULL;
+	  }
+	  else
+	  {
+	     newAccel->accelPrior->accelNext = newAccel->accelNext;
+	     if (newAccel != accelTail)
+		newAccel->accelNext->accelPrior = newAccel->accelPrior;
+	     else
+		accelTail = newAccel->accelPrior;
+	  }
+	  newAccel->accelNext = newAccel->accelPrior = 0;
+	  newAccel->accelFlags = 0;
+
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&accelLock, accelflags);
+#endif
+	  return 0;
+       }
+       accel = accel->accelNext;
+    }
+
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&accelLock, accelflags);
+#endif
+    return -1;
+}
+
+#ifdef MDB_ATOMIC
+static spinlock_t altDebugLock = SPIN_LOCK_UNLOCKED;
+static long altflags = 0;
+#endif
+
+ALT_DEBUGGER *altDebugHead = 0;
+ALT_DEBUGGER *altDebugTail = 0;
+
+int AlternateDebuggerRoutine(int reason, int error, void *frame)
+{
+    register ALT_DEBUGGER *altDebug;
+    register ULONG retCode;
+    unsigned long state;
+
+    state = save_flags();
+    altDebug = altDebugHead;
+    while (altDebug)
+    {
+       if (altDebug->AlternateDebugger)
+       {
+	  retCode = (altDebug->AlternateDebugger)(reason, error, frame);
+	  if (retCode)
+          {
+             restore_flags(state);
+	     return retCode;
+          }
+       }
+       altDebug = altDebug->altDebugNext;
+    }
+    restore_flags(state);
+    return 0;
+}
+
+ULONG AddAlternateDebugger(ALT_DEBUGGER *Debugger)
+{
+    register ALT_DEBUGGER *altDebug;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&altDebugLock, altflags);
+#endif
+    altDebug = altDebugHead;
+    while (altDebug)
+    {
+       if (altDebug == Debugger)
+       {
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&altDebugLock, altflags);  
+#endif
+	  return 1;
+       }
+       altDebug = altDebug->altDebugNext;
+    }
+    if (!altDebugHead)
+    {
+       altDebugHead = Debugger;
+       altDebugTail = Debugger;
+       Debugger->altDebugNext = 0;
+       Debugger->altDebugPrior = 0;
+    }
+    else
+    {
+       altDebugTail->altDebugNext = Debugger;
+       Debugger->altDebugNext = 0;
+       Debugger->altDebugPrior = altDebugTail;
+       altDebugTail = Debugger;
+    }
+
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&altDebugLock, altflags);
+#endif
+    return 0;
+}
+
+ULONG RemoveAlternateDebugger(ALT_DEBUGGER *Debugger)
+{
+    register ALT_DEBUGGER *altDebug;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&altDebugLock, altflags);
+#endif
+    altDebug = altDebugHead;
+    while (altDebug)
+    {
+       if (altDebug == Debugger)   // found, remove from list
+       {
+	  if (altDebugHead == Debugger)
+	  {
+	     altDebugHead = (void *) Debugger->altDebugNext;
+	     if (altDebugHead)
+		altDebugHead->altDebugPrior = NULL;
+	     else
+		altDebugTail = NULL;
+	  }
+	  else
+	  {
+	     Debugger->altDebugPrior->altDebugNext = Debugger->altDebugNext;
+	     if (Debugger != altDebugTail)
+		Debugger->altDebugNext->altDebugPrior = Debugger->altDebugPrior;
+	     else
+		altDebugTail = Debugger->altDebugPrior;
+	  }
+	  Debugger->altDebugNext = Debugger->altDebugPrior = 0;
+
+#ifdef MDB_ATOMIC
+          spin_unlock_irqrestore(&altDebugLock, altflags);
+#endif
+	  return 0;
+       }
+       altDebug = altDebug->altDebugNext;
+    }
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&altDebugLock, altflags);
+#endif
+    return -1;
+}
+
+#ifdef MDB_ATOMIC
+static spinlock_t debugParserLock = SPIN_LOCK_UNLOCKED;
+static long parserflags = 0;
+#endif
+
+DEBUGGER_PARSER *debugParserHead = 0;
+DEBUGGER_PARSER *debugParserTail = 0;
+
+ULONG DebuggerParserRoutine(BYTE *command, BYTE *commandLine,
+			    StackFrame *stackFrame, ULONG Exception)
+{
+    register DEBUGGER_PARSER *debugParser;
+    register ULONG retCode, valid = 0;
+    register BYTE *p;
+ 
+    p = commandLine;
+    if (!p)
+       return 0;
+
+    // if a passed string is just whitespace, return error
+    while (*p)
+    {
+       if ((*p != ' ') && (*p != '\n') && (*p != '\r'))
+       {
+          valid = TRUE;
+          break;
+       }
+       p++;
+    }
+    if (!valid)
+       return 0;
+
+    debugParser = debugParserHead;
+    while (debugParser)
+    {
+       if (debugParser->parserFlags && debugParser->DebugCommandParser &&
+	   strlen(debugParser->debugCommandName) == strlen(command) &&
+	   (!strcmp(debugParser->debugCommandName, UpcaseString(command))))
+       {
+	  retCode = (debugParser->DebugCommandParser)(commandLine, stackFrame,
+						      Exception, debugParser);
+	  if (retCode)
+	     return retCode;
+       }
+       debugParser = debugParser->debugNext;
+    }
+    DBGPrint("unknown mdb command -> %s\n", command);
+    return 0;
+}
+
+ULONG DebuggerParserHelpRoutine(BYTE *command, BYTE *commandLine)
+{
+    extern void ShowDebuggerAccelerators(void);
+    register DEBUGGER_PARSER *debugParser;
+
+    debugParser = debugParserHead;
+    if (*command)  // if we were passed a command string
+    {
+       while (debugParser)
+       {
+	  if (debugParser->parserFlags &&
+	      strlen(debugParser->debugCommandName) == strlen(command) &&
+	      !strcmp(debugParser->debugCommandName, UpcaseString(command)))
+	  {
+	     if (debugParser->DebugCommandParserHelp)
+	     {
+		DBGPrint("Help for Command %s\n", 
+                         debugParser->debugCommandName);
+		(debugParser->DebugCommandParserHelp)(commandLine, debugParser);
+		return 1;
+	     }
+	     DBGPrint("Help for Command %s\n", debugParser->debugCommandName);
+	     return 1;
+	  }
+	  debugParser = debugParser->debugNext;
+       }
+       DBGPrint("Help for Command [%s] not found\n", command);
+       return 1;
+    }
+    else
+    {
+       DBGPrint("Debugger Command(s)\n");
+       while (debugParser)
+       {
+	  if (debugParser->parserFlags && debugParser->debugCommandName &&
+	      !debugParser->supervisorCommand)
+	     if (DBGPrint("%15s    - %s\n", debugParser->debugCommandName, 
+                      debugParser->shortHelp)) return 0;
+	  debugParser = debugParser->debugNext;
+       }
+       ShowDebuggerAccelerators();
+    }
+    return 0;
+}
+
+DEBUGGER_PARSER *insertDebuggerParser(DEBUGGER_PARSER *i, DEBUGGER_PARSER *top)
+{
+    DEBUGGER_PARSER *old, *p;
+
+    if (!debugParserTail)
+    {
+       i->debugNext = i->debugPrior = NULL;
+       debugParserTail = i;
+       return i;
+    }
+    p = top;
+    old = NULL;
+    while (p)
+    {
+       if (strcmp(p->debugCommandName, i->debugCommandName) < 0)
+       {
+	  old = p;
+	  p = p->debugNext;
+       }
+       else
+       {
+	  if (p->debugPrior)
+	  {
+	     p->debugPrior->debugNext = i;
+	     i->debugNext = p;
+	     i->debugPrior = p->debugPrior;
+	     p->debugPrior = i;
+	     return top;
+	  }
+	  i->debugNext = p;
+	  i->debugPrior = NULL;
+	  p->debugPrior = i;
+	  return i;
+       }
+    }
+    old->debugNext = i;
+    i->debugNext = NULL;
+    i->debugPrior = old;
+    debugParserTail = i;
+    return debugParserHead;
+
+}
+
+ULONG AddDebuggerCommandParser(DEBUGGER_PARSER *parser)
+{
+    register DEBUGGER_PARSER *debugParser;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&debugParserLock, parserflags);
+#endif
+    debugParser = debugParserHead;
+    while (debugParser)
+    {
+       if (debugParser == parser ||
+	  (strlen(parser->debugCommandName) == strlen(debugParser->debugCommandName) &&
+	  (!strcmp(parser->debugCommandName, debugParser->debugCommandName))))
+       {
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&debugParserLock, parserflags);  
+#endif
+	  return 1;
+       }
+       debugParser = debugParser->debugNext;
+    }
+    parser->parserFlags = -1;
+    parser->debugCommandNameLength = strlen(parser->debugCommandName);
+
+    debugParserHead = insertDebuggerParser(parser, debugParserHead);
+
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&debugParserLock, parserflags);
+#endif
+    return 0;
+}
+
+ULONG RemoveDebuggerCommandParser(DEBUGGER_PARSER *parser)
+{
+    register DEBUGGER_PARSER *debugParser;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&debugParserLock, parserflags);
+#endif
+    debugParser = debugParserHead;
+    while (debugParser)
+    {
+       if (debugParser == parser)   // found, remove from list
+       {
+	  if (debugParserHead == parser)
+	  {
+	     debugParserHead = (void *) parser->debugNext;
+	     if (debugParserHead)
+		debugParserHead->debugPrior = NULL;
+	     else
+		debugParserTail = NULL;
+	  }
+	  else
+	  {
+	     parser->debugPrior->debugNext = parser->debugNext;
+	     if (parser != debugParserTail)
+		parser->debugNext->debugPrior = parser->debugPrior;
+	     else
+		debugParserTail = parser->debugPrior;
+	  }
+	  parser->debugNext = parser->debugPrior = 0;
+	  parser->parserFlags = 0;
+
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&debugParserLock, parserflags);
+#endif
+	  return 0;
+       }
+       debugParser = debugParser->debugNext;
+    }
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&debugParserLock, parserflags);
+#endif
+    return -1;
+}
+
+#endif
+
diff -Naur ./debug/mdb-list.h ../linux-2.6.18-mdb/./debug/mdb-list.h
--- ./debug/mdb-list.h	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-list.h	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,86 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-LIST.H
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#ifndef _MDB_LIST
+#define _MDB_LIST
+
+typedef struct _ACCELERATOR
+{
+    struct _ACCELERATOR *accelNext;
+    struct _ACCELERATOR *accelPrior;
+    ULONG (*accelRoutine)(ULONG key, void *p, struct _ACCELERATOR *parser);
+    ULONG (*accelRoutineHelp)(ULONG key, struct _ACCELERATOR *parser);
+    ULONG accelFlags;
+    ULONG key;
+    ULONG supervisorCommand;
+    BYTE *shortHelp;
+} ACCELERATOR;
+
+typedef struct _ALT_DEBUGGER 
+{
+    struct _ALT_DEBUGGER *altDebugNext;
+    struct _ALT_DEBUGGER *altDebugPrior;
+    int (*AlternateDebugger)(int reason, int error, void *frame);
+} ALT_DEBUGGER;
+
+extern int AlternateDebuggerRoutine(int reason, int error, void *frame);
+extern ULONG AddAlternateDebugger(ALT_DEBUGGER *Debugger);
+extern ULONG RemoveAlternateDebugger(ALT_DEBUGGER *Debugger);
+
+typedef struct _DEBUGGER_PARSER {
+    struct _DEBUGGER_PARSER *debugNext;
+    struct _DEBUGGER_PARSER *debugPrior;
+    ULONG (*DebugCommandParser)(BYTE *commandLine,
+			       StackFrame *stackFrame, ULONG Exception,
+			       struct _DEBUGGER_PARSER *parser);
+    ULONG (*DebugCommandParserHelp)(BYTE *commandLine,
+				   struct _DEBUGGER_PARSER *parser);
+    ULONG parserFlags;
+    BYTE *debugCommandName;
+    ULONG debugCommandNameLength;
+    ULONG supervisorCommand;
+    BYTE *shortHelp;
+    ULONG controlTransfer;
+} DEBUGGER_PARSER;
+
+extern ULONG DebuggerParserRoutine(BYTE *command, BYTE *commandLine,
+			   StackFrame *stackFrame, ULONG Exception);
+extern ULONG DebuggerParserHelpRoutine(BYTE *command, BYTE *commandLine);
+extern ULONG AddDebuggerCommandParser(DEBUGGER_PARSER *parser);
+extern ULONG RemoveDebuggerCommandParser(DEBUGGER_PARSER *parser);
+
+#endif
+
diff -Naur ./debug/mdb-logic.c ../linux-2.6.18-mdb/./debug/mdb-logic.c
--- ./debug/mdb-logic.c	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-logic.c	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,2331 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-LOGIC.C
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#include "mdb.h"
+
+#ifdef CONFIG_MDB
+
+#define PROCESSOR_32        32
+#define PROCESSOR_64        64
+
+#define DEBUG_EXPRESS        0
+#define DEBUG_BOOL           0
+#define DEBUG_LOGICAL        0
+#define DEBUG_LOGICAL_STACK  0
+#define DEBUG_BOOL_STACK     0
+
+#define INVALID_EXPRESSION  0
+#define NUMERIC_EXPRESSION  1
+#define BOOLEAN_EXPRESSION  2
+
+#define NUM_STACK_SIZE      256
+#define CONTEXT_STACK_SIZE  1024
+#define BOOL_STACK_SIZE     256
+#define LOGICAL_STACK_SIZE  256
+
+#define NULL_TOKEN            0
+#define NUMBER_TOKEN          1
+#define MINUS_TOKEN           2
+#define PLUS_TOKEN            3
+#define MULTIPLY_TOKEN        4
+#define DIVIDE_TOKEN          5
+#define GREATER_TOKEN         6
+#define LESS_TOKEN            7
+#define XOR_TOKEN             8
+#define AND_TOKEN             9
+#define OR_TOKEN             10
+#define NOT_TOKEN            11
+#define NEG_TOKEN            12
+#define EQUAL_TOKEN          13
+#define LEFT_SHIFT_TOKEN     14
+#define RIGHT_SHIFT_TOKEN    15
+#define SPACE_TOKEN          16
+#define FLAGS_TOKEN          17
+#define EAX_TOKEN            18
+#define EBX_TOKEN            19
+#define ECX_TOKEN            20
+#define EDX_TOKEN            21
+#define ESI_TOKEN            22
+#define EDI_TOKEN            23
+#define EBP_TOKEN            24
+#define ESP_TOKEN            25
+#define CS_TOKEN             26
+#define DS_TOKEN             27
+#define ES_TOKEN             28
+#define FS_TOKEN             29
+#define GS_TOKEN             30
+#define SS_TOKEN             31
+#define DREF_OPEN_TOKEN      32
+#define DREF_CLOSE_TOKEN     33
+#define MOD_TOKEN            34
+#define NUMBER_END           35
+#define GREATER_EQUAL_TOKEN  36
+#define LESS_EQUAL_TOKEN     37
+#define EIP_TOKEN            38
+#define ASSIGNMENT_TOKEN     39
+#define DWORD_TOKEN          40
+#define WORD_TOKEN           41
+#define BYTE_TOKEN           42
+#define LOGICAL_AND_TOKEN    43
+#define LOGICAL_OR_TOKEN     44
+#define CF_TOKEN             45
+#define PF_TOKEN             46
+#define AF_TOKEN             47
+#define ZF_TOKEN             48
+#define SF_TOKEN             49
+#define IF_TOKEN             50
+#define DF_TOKEN             51
+#define OF_TOKEN             52
+#define VM_TOKEN             53
+#define AC_TOKEN             54
+#define BB_TOKEN             55
+#define EB_TOKEN             56
+#define NOT_EQUAL_TOKEN      57
+#define INVALID_NUMBER_TOKEN 58
+
+#define CF_FLAG   0x00000001   
+#define PF_FLAG   0x00000004
+#define AF_FLAG   0x00000010   
+#define ZF_FLAG   0x00000040
+#define SF_FLAG   0x00000080
+#define TF_FLAG   0x00000100  // ss flag
+#define IF_FLAG   0x00000200
+#define DF_FLAG   0x00000400   
+#define OF_FLAG   0x00000800
+#define NT_FLAG   0x00004000
+#define RF_FLAG   0x00010000  // resume flag
+#define VM_FLAG   0x00020000
+#define AC_FLAG   0x00040000   
+#define VIF_FLAG  0x00080000
+#define VIP_FLAG  0x00100000
+#define ID_FLAG   0x00200000
+
+#define   ULONG_PTR         0
+#define   WORD_PTR          1
+#define   BYTE_PTR          2
+
+#define   CLASS_DATA        1
+#define   CLASS_ASSIGN      2
+#define   CLASS_PARTITION   3
+#define   CLASS_ARITHMETIC  4
+#define   CLASS_BOOLEAN     5
+
+BYTE *exprDescription[]={
+     "INVALID",
+     "NUMERIC",
+     "BOOLEAN",
+     "???????",
+};
+
+BYTE *parserDescription[]={
+     "NULL_TOKEN",
+     "NUMBER_TOKEN",
+     "MINUS_TOKEN",
+     "PLUS_TOKEN",
+     "MULTIPLY_TOKEN",
+     "DIVIDE_TOKEN",
+     "GREATER_TOKEN",
+     "LESS_TOKEN",
+     "XOR_TOKEN",
+     "AND_TOKEN",
+     "OR_TOKEN",
+     "NOT_TOKEN",
+     "NEG_TOKEN",
+     "EQUAL_TOKEN",
+     "LEFT_SHIFT_TOKEN",
+     "RIGHT_SHIFT_TOKEN",
+     "SPACE_TOKEN",
+     "FLAGS_TOKEN",
+     "EAX_TOKEN",
+     "EBX_TOKEN",
+     "ECX_TOKEN",
+     "EDX_TOKEN",
+     "ESI_TOKEN",
+     "EDI_TOKEN",
+     "EBP_TOKEN",
+     "ESP_TOKEN",
+     "CS_TOKEN",
+     "DS_TOKEN",
+     "ES_TOKEN",
+     "FS_TOKEN",
+     "GS_TOKEN",
+     "SS_TOKEN",
+     "DREF_OPEN_TOKEN",
+     "DREF_CLOSE_TOKEN",
+     "MOD_TOKEN",
+     "NUMBER_END",
+     "GREATER_EQUAL_TOKEN",
+     "LESS_EQUAL_TOKEN",
+     "EIP_TOKEN",
+     "ASSIGNMENT_TOKEN",
+     "DWORD_TOKEN",
+     "WORD_TOKEN",
+     "BYTE_TOKEN",
+     "LOGICAL_AND_TOKEN",
+     "LOGICAL_OR_TOKEN",
+     "CF_TOKEN",
+     "PF_TOKEN",
+     "AF_TOKEN",
+     "ZF_TOKEN",
+     "SF_TOKEN",
+     "IF_TOKEN",
+     "DF_TOKEN",
+     "OF_TOKEN",
+     "VM_TOKEN",
+     "AC_TOKEN",
+     "BEGIN_BRACKET",
+     "END_BRACKET",
+     "NOT_EQUAL_TOKEN"
+     "INVALID_NUMBER_TOKEN"
+};
+
+BYTE TokenIndex[256];
+BYTE TokenClass[256];
+BYTE TokenType[256];
+ULONG TokenValue[256];
+ULONG TokenCount;
+
+ULONG numStack[NUM_STACK_SIZE];
+ULONG *sp;
+ULONG *tos;
+ULONG *bos;
+
+ULONG contextStack[CONTEXT_STACK_SIZE];
+ULONG *c_sp;
+ULONG *c_tos;
+ULONG *c_bos;
+
+ULONG booleanStack[BOOL_STACK_SIZE];
+ULONG *b_sp;
+ULONG *b_tos;
+ULONG *b_bos;
+
+ULONG logicalStack[LOGICAL_STACK_SIZE];
+ULONG *l_sp;
+ULONG *l_tos;
+ULONG *l_bos;
+
+extern ULONG GetValueFromSymbol(BYTE *symbolName);
+extern BYTE delim_table[256];
+
+#ifdef LINUX_DRIVER
+spinlock_t expressLock = SPIN_LOCK_UNLOCKED;
+static long flags = 0;
+#endif
+
+ULONG GetNumber(BYTE *p, BYTE **rp, ULONG *opl, ULONG *retCode, ULONG mode)
+{
+
+    BYTE *op, *pp = NULL;
+    ULONG c = 0, decimal = 0, hex_found = 0, invalid = 0, valid = 0;
+
+    pp = op = p;
+    while (*p)
+    {
+       if (*p == 'X' || *p == 'x')  
+       {
+          hex_found = 1;
+          p++;
+          pp = p;
+       }
+
+       if (*p >= '0' && *p <= '9')
+       {
+          valid++; 
+	  p++;
+       }
+       else 
+       if (*p >= 'A' && *p <= 'F')
+       {
+	  hex_found = 1;
+          valid++; 
+	  p++;
+       }
+       else 
+       if (*p >= 'a' && *p <= 'f')
+       {
+	  hex_found = 1;
+          valid++; 
+	  p++;
+       }
+       else 
+       if ((*p == 'R') || (*p == 'r'))
+       {
+	  decimal = 1;
+	  p++;
+       }
+       else 
+       if (delim_table[((*p) & 0xFF)])
+	  break;
+       else
+       {
+          invalid = 1;
+          break;
+       }
+    }
+
+    if (rp)
+       *rp = p;
+    if (opl)
+       *opl = (ULONG)((ULONG)p - (ULONG) op);
+
+    if (invalid && !valid)
+    {
+       if (retCode)
+          *retCode = -1;   // invalid string
+       return 0;
+    }
+
+    p = pp;
+
+    if (mode)
+       decimal = 1;
+
+    if (decimal)
+    {
+       // parse as decimal number;
+       while (*p)
+       {
+	     if (*p >= '0' && *p <= '9')
+		c = (c * 10) + (*p - '0');
+	     else
+		break;
+	  p++;
+       }
+    }
+    else 
+    if (hex_found)
+    {
+       // parse as hex number;
+       while (*p)
+       {
+	  if (*p >= '0' && *p <= '9')
+	     c = (c << 4) | (*p - '0');
+	  else if (*p >= 'A' && *p <= 'F')
+	     c = (c << 4) | (*p - 'A' + 10);
+	  else if (*p >= 'a' && *p <= 'f')
+	     c = (c << 4) | (*p - 'a' + 10);
+	  else
+	     break;
+	  p++;
+       }
+    }
+    else  // default parses as hex
+    {
+       // parse as hex number;
+       while (*p)
+       {
+	  if (*p >= '0' && *p <= '9')
+	     c = (c << 4) | (*p - '0');
+	  else if (*p >= 'A' && *p <= 'F')
+	     c = (c << 4) | (*p - 'A' + 10);
+	  else if (*p >= 'a' && *p <= 'f')
+	     c = (c << 4) | (*p - 'a' + 10);
+	  else
+	     break;
+	  p++;
+       }
+    }
+
+    if (retCode)
+       *retCode = 0;   
+
+    return (c);
+
+}
+
+
+BYTE *parseTokens(StackFrame *stackFrame, BYTE *p, ULONG mode)
+{
+
+    register ULONG i, value;
+    BYTE symbol[256], *s;
+    BYTE *tmp, *op;
+    ULONG delta, retCode = 0;
+
+    op = p;
+    TokenCount = 0;
+    while (TokenCount < 200 && (ULONG)p - (ULONG)op < 200)
+    {
+       if (isalpha(*p) || *p == '_' ||  *p == '@' || *p == '$')
+       {
+	  s = p;
+	  for (i=0; i < 255; i++)
+          {
+             if (delim_table[((s[i]) & 0xFF)])
+                break;
+
+             if (!isprint(s[i]))
+                break;
+
+	     symbol[i] = s[i];
+          }
+	  symbol[i] = '\0';
+
+	  value = GetValueFromSymbol(symbol);
+	  if (value)
+	  {
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = value;
+	     TokenType[TokenCount++] = NUMBER_TOKEN;
+	     p = &s[i];   // bump the pointer past the symbol
+	  }
+       }
+
+       if (stackFrame)
+       {
+	 switch (*p)
+	 {
+
+	  case '\0':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = NULL_TOKEN;
+	     return (p);
+
+	  case ']':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = DREF_CLOSE_TOKEN;
+	     p++;
+	     break;
+
+	  case '(':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = BB_TOKEN;
+	     p++;
+	     break;
+
+	  case ')':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = EB_TOKEN;
+	     p++;
+	     break;
+
+	  case '+':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = PLUS_TOKEN;
+	     p++;
+	     break;
+
+	  case '-':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = MINUS_TOKEN;
+	     p++;
+	     break;
+
+	  case '*':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = MULTIPLY_TOKEN;
+	     p++;
+	     break;
+
+	  case '/':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = DIVIDE_TOKEN;
+	     p++;
+	     break;
+
+	  case '%':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = MOD_TOKEN;
+	     p++;
+	     break;
+
+	  case '~':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = NEG_TOKEN;
+	     p++;
+	     break;
+
+	  case '^':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = XOR_TOKEN;
+	     p++;
+	     break;
+
+	  case '!':
+	     p++;
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = NOT_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = NOT_TOKEN;
+	     break;
+
+	  case ' ':   // drop spaces on the floor
+	     p++;
+	     break;
+
+	  //
+	  //  These cases require special handling
+	  //
+
+	  case 'p':
+	  case 'P':
+	     p++;
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & PF_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = PF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'z':
+	  case 'Z':
+	     p++;
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & ZF_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = ZF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'i':
+	  case 'I':
+	     p++;
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & IF_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = IF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'o':
+	  case 'O':
+	     p++;
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & OF_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = OF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'v':
+	  case 'V':
+	     p++;
+	     if (*p == 'M' || *p == 'm')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & VM_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = VM_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'x':  
+	  case 'X':
+	  case '0':
+	  case '1':
+	  case '2':
+	  case '3':
+	  case '4':
+	  case '5':
+	  case '6':
+	  case '7':
+	  case '8':
+	  case '9':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'a':
+	  case 'A':
+	     tmp = p;
+	     tmp++;
+	     if ((*tmp == 'F' || *tmp == 'f') && (*(tmp + 1) == ' ' || *(tmp + 1) == '=' ))
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & AF_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = AF_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     if ((*tmp == 'C' || *tmp == 'c') && (*(tmp + 1) == ' ' || *(tmp + 1) == '=' ))
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & AC_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = AC_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+
+	  case 'b':
+	  case 'B':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'c':
+	  case 'C':
+	     tmp = p;
+	     tmp++;
+	     if (*tmp == 'S' || *tmp == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tCS;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = CS_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     if ((*tmp == 'F' || *tmp == 'f') && (*(tmp + 1) == ' ' || *(tmp + 1) == '=' ))
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & CF_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = CF_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'd':
+	  case 'D':
+	     tmp = p;
+	     tmp++;
+	     if (*tmp == 'S' || *tmp == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tDS;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = DS_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     if ((*tmp == 'F' || *tmp == 'f') && (*(tmp + 1) == ' ' || *(tmp + 1) == '=' ))
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & DF_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = DF_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'e':
+	  case 'E':
+	     tmp = p;
+	     tmp++;
+	     if (*tmp == 'A' || *tmp == 'a')
+	     {
+		tmp++;
+		if (*tmp == 'X' || *tmp == 'x')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEAX;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = EAX_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, 
+                                                   mode);
+	        ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                   : (TokenType[TokenCount++] = NUMBER_TOKEN));
+		break;
+	     }
+	     if (*tmp == 'B' || *tmp == 'b')
+	     {
+		tmp++;
+		if (*tmp == 'X' || *tmp == 'x')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEBX;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = EBX_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		if (*tmp == 'P' || *tmp == 'p')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEBP;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = EBP_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, 
+                                                   mode);
+	        ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                   : (TokenType[TokenCount++] = NUMBER_TOKEN));
+		break;
+	     }
+	     if (*tmp == 'C' || *tmp == 'c')
+	     {
+		tmp++;
+		if (*tmp == 'X' || *tmp == 'x')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tECX;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = ECX_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, 
+                                                   mode);
+	        ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                   : (TokenType[TokenCount++] = NUMBER_TOKEN));
+		break;
+	     }
+	     if (*tmp == 'D' || *tmp == 'd')
+	     {
+		tmp++;
+		if (*tmp == 'X' || *tmp == 'x')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEDX;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = EDX_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		if (*tmp == 'I' || *tmp == 'i')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEDI;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = EDI_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, 
+                                                   mode);
+	        ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                   : (TokenType[TokenCount++] = NUMBER_TOKEN));
+		break;
+	     }
+	     if (*tmp == 'S' || *tmp == 's')
+	     {
+		tmp++;
+		if (*tmp == 'P' || *tmp == 'p')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tESP;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = ESP_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		if (*tmp == 'I' || *tmp == 'i')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tESI;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = ESI_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tES;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = ES_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     if (*tmp == 'I' || *tmp == 'i')
+	     {
+		tmp++;
+		if (*tmp == 'P' || *tmp == 'p')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEIP;
+		   TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		   TokenType[TokenCount++] = EIP_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'f':
+	  case 'F':
+	     tmp = p;
+	     tmp++;
+	     if (*tmp == 'S' || *tmp == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tFS;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = FS_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'g':
+	  case 'G':   // GS:
+	     p++;
+	     if (*p == 'S' || *p == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tGS;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = GS_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 's':
+	  case 'S':
+	     p++;
+	     if (*p == 'S' || *p == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSS;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = SS_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & SF_FLAG;
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = SF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case '[':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = DREF_OPEN_TOKEN;
+	     p++;
+	     if (*p == 'D' || *p == 'd')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = DWORD_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'W' || *p == 'w')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = WORD_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'B' || *p == 'b')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = BYTE_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case '=':
+	     p++;
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = ASSIGNMENT_TOKEN;
+	     break;
+
+	  case '<':
+	     p++;
+	     if (*p == '<')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = LEFT_SHIFT_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = LESS_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = LESS_TOKEN;
+	     break;
+
+	  case '>':
+	     p++;
+	     if (*p == '>')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = RIGHT_SHIFT_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = GREATER_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = GREATER_TOKEN;
+	     break;
+
+	  case '|':
+	     p++;
+	     if (*p == '|')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = LOGICAL_OR_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = OR_TOKEN;
+	     break;
+
+	  case '&':
+	     p++;
+	     if (*p == '&')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = LOGICAL_AND_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = AND_TOKEN;
+	     break;
+
+	  default: // if we get a default, drop the character on the floor
+	     p++;
+	     break;
+
+	 }
+       }
+       else
+       {
+	 switch (*p)
+	 {
+	  case '\0':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = NULL_TOKEN;
+	     return (p);
+
+	  case ']':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = DREF_CLOSE_TOKEN;
+	     p++;
+	     break;
+
+	  case '(':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = BB_TOKEN;
+	     p++;
+	     break;
+
+	  case ')':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = EB_TOKEN;
+	     p++;
+	     break;
+
+	  case '+':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = PLUS_TOKEN;
+	     p++;
+	     break;
+
+	  case '-':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = MINUS_TOKEN;
+	     p++;
+	     break;
+
+	  case '*':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = MULTIPLY_TOKEN;
+	     p++;
+	     break;
+
+	  case '/':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = DIVIDE_TOKEN;
+	     p++;
+	     break;
+
+	  case '%':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = MOD_TOKEN;
+	     p++;
+	     break;
+
+	  case '~':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = NEG_TOKEN;
+	     p++;
+	     break;
+
+	  case '^':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = XOR_TOKEN;
+	     p++;
+	     break;
+
+	  case '!':
+	     p++;
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = NOT_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = NOT_TOKEN;
+	     break;
+
+	  case ' ':   // drop spaces on the floor
+	     p++;
+	     break;
+
+	  //
+	  //  These cases require special handling
+	  //
+
+	  case 'x':
+	  case 'X':
+	  case '0':
+	  case '1':
+	  case '2':
+	  case '3':
+	  case '4':
+	  case '5':
+	  case '6':
+	  case '7':
+	  case '8':
+	  case '9':
+	  case 'a':
+	  case 'A':
+	  case 'b':
+	  case 'B':
+	  case 'c':
+	  case 'C':
+	  case 'd':
+	  case 'D':
+	  case 'e':
+	  case 'E':
+	  case 'f':
+	  case 'F':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case '[':
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = DREF_OPEN_TOKEN;
+	     p++;
+	     if (*p == 'D' || *p == 'd')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = DWORD_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'W' || *p == 'w')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = WORD_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'B' || *p == 'b')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = BYTE_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case '=':
+	     p++;
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = ASSIGNMENT_TOKEN;
+	     break;
+
+	  case '<':
+	     p++;
+	     if (*p == '<')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = LEFT_SHIFT_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = LESS_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = LESS_TOKEN;
+	     break;
+
+	  case '>':
+	     p++;
+	     if (*p == '>')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = RIGHT_SHIFT_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = GREATER_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = GREATER_TOKEN;
+	     break;
+
+	  case '|':
+	     p++;
+	     if (*p == '|')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = LOGICAL_OR_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = OR_TOKEN;
+	     break;
+
+	  case '&':
+	     p++;
+	     if (*p == '&')
+	     {
+		TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+		TokenType[TokenCount++] = LOGICAL_AND_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (ULONG) ((ULONG) p - (ULONG) op);
+	     TokenType[TokenCount++] = AND_TOKEN;
+	     break;
+
+	  default: // if we get a default, drop the character on the floor
+	     p++;
+	     break;
+
+	 }
+       }
+    }
+    return p;
+
+}
+
+void displayExpressionHelp(void)
+{
+
+       if (DBGPrint("Arithmetic Operators\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("+   add\n")) return;
+       if (DBGPrint("-   subtract\n")) return;
+       if (DBGPrint("*   multiply\n")) return;
+       if (DBGPrint("/   divide\n")) return;
+       if (DBGPrint("<<  bit shift left\n")) return;
+       if (DBGPrint(">>  bit shift right\n")) return;
+       if (DBGPrint("|   OR operator\n")) return;
+       if (DBGPrint("&   AND operator\n")) return;
+       if (DBGPrint("^   XOR operator\n")) return;
+       if (DBGPrint("~   NEG operator\n")) return;
+       if (DBGPrint("%%   MODULO operator\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 1:\n")) return;
+       if (DBGPrint("(0)> .e (100 + 100)\n")) return;
+       if (DBGPrint("(0)> result = 0x200 (512)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 2:\n")) return;
+       if (DBGPrint("(0)> .e (1 << 20)\n")) return;
+       if (DBGPrint("(0)> result = 0x00100000 (1,024,000)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 3:\n")) return;
+       if (DBGPrint("(0)> .e (FEF023 & 100F)\n")) return;
+       if (DBGPrint("(0)> result = 0x1003 (4099)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Boolean Operators (Conditional Breakpoint)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("==      is equal to\n")) return;
+       if (DBGPrint("!=      is not equal to\n")) return;
+       if (DBGPrint("!<expr> is not\n")) return;
+       if (DBGPrint(">       is greater than\n")) return;
+       if (DBGPrint("<       is less than\n")) return;
+       if (DBGPrint(">=      is greater than or equal to\n")) return;
+       if (DBGPrint("<=      if less than or equal to\n")) return;
+       if (DBGPrint("||      logical OR operator\n")) return;
+       if (DBGPrint("&&      logical AND operator\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("all breakpoint conditions must be enclosed in brackets () to\n")) return;
+       if (DBGPrint("evaluate correctly\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 1 (Execute Breakpoint):\n")) return;
+       if (DBGPrint("(0)> b 37000 (EAX == 20 && EBX <= 4000)\n")) return;
+       if (DBGPrint("breakpoint will activate if condition is true (returns 1)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 2 (IO Breakpoint):\n")) return;
+       if (DBGPrint("(0)> bi 3D4 (!EBX && [d ESI+40] != 2000)\n")) return;
+       if (DBGPrint("breakpoint will activate if condition is true (returns 1)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Register Operators\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("EAX, EBX, ECX, EDX        - general registers\n")) return;
+       if (DBGPrint("ESI, EDI, EBP, ESP        - pointer registers\n")) return;
+       if (DBGPrint("EIP, <symbol>             - instruction pointer or symbol\n")) return;
+       if (DBGPrint("CS, DS, ES, FS, GS, SS    - segment registers\n")) return;
+       if (DBGPrint("CF, PF, AF, ZF, SF, IF    - flags\n")) return;
+       if (DBGPrint("DF, OF, VM, AC\n")) return;
+       if (DBGPrint("=                         - set equal to\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 1:\n")) return;
+       if (DBGPrint("(0)> EAX = 0032700 \n")) return;
+       if (DBGPrint("EAX changed to 0x0032700\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 2:\n")) return;
+       if (DBGPrint("(0)> u thread_switch\n")) return;
+       if (DBGPrint("unassembles function thread_switch\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 3 (Dump):\n")) return;
+       if (DBGPrint("(0)> d EBP+ECX\n")) return;
+       if (DBGPrint("(dumps [d EBP + ECX])\n")) return;
+       if (DBGPrint("[addr] 00 00 00 01 02 04 07 ...\n")) return;
+       if (DBGPrint("[addr] 00 34 56 00 7A 01 00 ...\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Bracket Operators\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("(       begin expression bracket\n")) return;
+       if (DBGPrint(")       end expression bracket\n")) return;
+       if (DBGPrint("[       begin pointer\n")) return;
+       if (DBGPrint("]       end pointer\n")) return;
+       if (DBGPrint("d       DWORD reference\n")) return;
+       if (DBGPrint("w       WORD reference\n")) return;
+       if (DBGPrint("b       BYTE reference\n")) return;
+       if (DBGPrint("<num>r  parse number as decimal not hex flag"
+                    " (e.g. 512r == 200)\n")) return;
+       if (DBGPrint("Note - DWORD,WORD, and BYTE dereference operators must\n"))          return;
+       if (DBGPrint("immediately follow pointer brackets (no spaces)\n"))                 return;
+       if (DBGPrint("i.e.  [d <addr/symbol>] or [w <addr/symbol>] or\n"))
+           return;
+       if (DBGPrint("[b <addr/symbol>], etc.\n")) 
+           return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 1 (dump):\n")) return;
+       if (DBGPrint("(0)> d [d EAX+100r] \n")) return;
+       if (DBGPrint("[eax + 100 (dec)] 00 00 00 01 02 04 07 00\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 2 (dump):\n")) return;
+       if (DBGPrint("(0)> d [w 003400] \n")) return;
+       if (DBGPrint("[addr (hex)] 00 22 00 01 02 04 07 ...\n")) return;
+       if (DBGPrint("[addr (hex)] 00 31 A1 00 6A 05 00 ...\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 3 (break):\n")) return;
+       if (DBGPrint("(0)> b = 7A000 (EAX + ECX == 30) && ([d B8000+50]  == 0x07)\n")) return;
+       if (DBGPrint("breakpoint will activate if condition is true (returns 1)\n")) return;
+       if (DBGPrint("\n")) return;
+
+       return;
+
+}
+
+ULONG deref(ULONG type, ULONG value)
+{
+   ULONG *pd;
+   WORD *pw;
+   BYTE *pb;
+
+   switch (type)
+   {
+      case ULONG_PTR:
+	 pd = (ULONG *) value;
+#if (DEBUG_EXPRESS)
+	 DBGPrint("dref (d): [%08X]-> %08X\n", pd, 
+                  mdb_getword((ULONG)pd, 4));
+#endif
+	 return (ULONG) mdb_getword((ULONG)pd, 4);
+
+      case WORD_PTR:
+	 pw = (WORD *) value;
+#if (DEBUG_EXPRESS)
+	 DBGPrint("dref (w): [%08X]-> %04X\n", pw, 
+                  mdb_getword((ULONG)pw, 2));
+#endif
+	 return (WORD) mdb_getword((ULONG)pw, 2);
+
+      case BYTE_PTR:
+	 pb = (BYTE *) value;
+#if (DEBUG_EXPRESS)
+	 DBGPrint("dref (b): [%08X]-> %02X\n", pb, 
+                  mdb_getword((ULONG)pb, 1));
+#endif
+	 return (BYTE) mdb_getword((ULONG)pb, 1);
+
+      default:
+#if (DEBUG_EXPRESS)
+	 DBGPrint("dref (?): [0]-> 0\n");
+#endif
+	 return 0;
+   }
+
+}
+
+ULONG ExpressPush(ULONG i)
+{
+     if (sp > bos)
+     {
+#if (DEBUG_EXPRESS)
+	DBGPrint("push : <err>\n");
+#endif
+	return 0;
+     }
+     *sp = i;
+#if (DEBUG_EXPRESS)
+     DBGPrint("push : %08X (%d)\n", *sp, *sp);
+#endif
+     sp++;
+     return 1;
+}
+
+ULONG ExpressPop(void)
+{
+    sp--;
+    if (sp < tos)
+    {
+       sp++;
+#if (DEBUG_EXPRESS)
+       DBGPrint("pop  : <err>\n");
+#endif
+       return 0;
+    }
+#if (DEBUG_EXPRESS)
+    DBGPrint("pop  : %08X (%d)\n", *sp, *sp);
+#endif
+    return *sp;
+
+}
+
+ULONG ContextPush(ULONG i)
+{
+     if (c_sp > c_bos)
+     {
+#if (DEBUG_EXPRESS)
+	DBGPrint("cpush: <err>\n");
+#endif
+	return 0;
+     }
+     *c_sp = i;
+#if (DEBUG_EXPRESS)
+     DBGPrint("cpush: %08X (%d)\n", *c_sp, *c_sp);
+#endif
+     c_sp++;
+     return 1;
+}
+
+ULONG ContextPop(void)
+{
+    c_sp--;
+    if (c_sp < c_tos)
+    {
+       c_sp++;
+#if (DEBUG_EXPRESS)
+       DBGPrint("cpop : <err>\n");
+#endif
+       return 0;
+    }
+#if (DEBUG_EXPRESS)
+    DBGPrint("cpop : %08X (%d)\n", *c_sp, *c_sp);
+#endif
+    return *c_sp;
+
+}
+
+ULONG BooleanPush(ULONG i)
+{
+     if (b_sp > b_bos)
+     {
+#if (DEBUG_BOOL_STACK)
+	DBGPrint("bpush: <err>\n");
+#endif
+	return 0;
+     }
+     *b_sp = i;
+#if (DEBUG_BOOL_STACK)
+     DBGPrint("bpush: %08X (%d)\n", *b_sp, *b_sp);
+#endif
+     b_sp++;
+     return 1;
+}
+
+ULONG BooleanPop(void)
+{
+    b_sp--;
+    if (b_sp < b_tos)
+    {
+       b_sp++;
+#if (DEBUG_BOOL_STACK)
+       DBGPrint("bpop : <err>\n");
+#endif
+       return 0;
+    }
+#if (DEBUG_BOOL_STACK)
+    DBGPrint("bpop : %08X (%d)\n", *b_sp, *b_sp);
+#endif
+    return *b_sp;
+
+}
+
+ULONG LogicalPush(ULONG i)
+{
+     if (l_sp > l_bos)
+     {
+#if (DEBUG_LOGICAL_STACK)
+	DBGPrint("lpush: <err>\n");
+#endif
+	return 0;
+     }
+     *l_sp = i;
+#if (DEBUG_LOGICAL_STACK)
+     DBGPrint("lpush: %08X (%d)\n", *l_sp, *l_sp);
+#endif
+     l_sp++;
+     return 1;
+}
+
+ULONG LogicalPop(void)
+{
+    l_sp--;
+    if (l_sp < l_tos)
+    {
+       l_sp++;
+#if (DEBUG_LOGICAL_STACK)
+       DBGPrint("lpop : <err>\n");
+#endif
+       return 0;
+    }
+#if (DEBUG_LOGICAL_STACK)
+    DBGPrint("lpop : %08X (%d)\n", *l_sp, *l_sp);
+#endif
+    return *l_sp;
+
+}
+
+void initNumericStacks(void)
+{
+
+    sp = numStack;
+    tos = sp;
+    bos = sp + NUM_STACK_SIZE - 1;
+
+    c_sp = contextStack;
+    c_tos = c_sp;
+    c_bos = c_sp + CONTEXT_STACK_SIZE - 1;
+
+    b_sp = booleanStack;
+    b_tos = b_sp;
+    b_bos = b_sp + BOOL_STACK_SIZE - 1;
+
+    l_sp = logicalStack;
+    l_tos = l_sp;
+    l_bos = l_sp + LOGICAL_STACK_SIZE - 1;
+
+}
+
+ULONG ProcessOperator(ULONG oper)
+{
+    ULONG a, b;
+
+    b = ExpressPop();
+    a = ExpressPop();
+    switch(oper)
+    {
+       case NEG_TOKEN:
+	  break;
+
+       case LEFT_SHIFT_TOKEN:
+	  ExpressPush(a << (b % PROCESSOR_32));  // mod (b) to base 32
+	  break;
+
+       case RIGHT_SHIFT_TOKEN:
+	  ExpressPush(a >> (b % PROCESSOR_32));  // mob (b) to base 32
+	  break;
+
+       case PLUS_TOKEN:
+	  ExpressPush(a + b);
+	  break;
+
+       case XOR_TOKEN:
+	  ExpressPush(a ^ b);
+	  break;
+
+       case AND_TOKEN:
+	  ExpressPush(a & b);
+	  break;
+
+       case MOD_TOKEN:
+	  if (b) // if modulo by zero, drop value on the floor
+	     ExpressPush(a % b);
+	  else
+	     ExpressPush(0);
+	  break;
+
+       case OR_TOKEN:
+	  ExpressPush(a | b);
+	  break;
+
+       case MINUS_TOKEN:
+	  ExpressPush(a - b);
+	  break;
+
+       case MULTIPLY_TOKEN:
+	  ExpressPush(a * b);
+	  break;
+
+       case DIVIDE_TOKEN:
+	  if (b) // if divide by zero, drop value on the floor
+	     ExpressPush(a / b);
+	  else
+	     ExpressPush(0);
+	  break;
+
+    }
+    return 0;
+
+}
+
+ULONG ProcessBoolean(ULONG oper)
+{
+
+    ULONG a, b;
+
+    b = ExpressPop();
+    a = ExpressPop();
+    switch(oper)
+    {
+       case NOT_TOKEN:
+	  ExpressPush(a == b); // we pushed an imaginary zero on the stack
+	  break;               // this operation returns the boolean for (!x)
+
+       case GREATER_TOKEN:
+	  ExpressPush(a > b);
+	  break;
+
+       case LESS_TOKEN:
+	  ExpressPush(a < b);
+	  break;
+
+       case GREATER_EQUAL_TOKEN:
+	  ExpressPush(a >= b);
+	  break;
+
+       case LESS_EQUAL_TOKEN:
+	  ExpressPush(a <= b);
+	  break;
+
+       case EQUAL_TOKEN:
+	  ExpressPush(a == b);
+	  break;
+
+       case NOT_EQUAL_TOKEN:
+	  ExpressPush(a != b);
+	  break;
+    }
+    return 0;
+
+}
+
+ULONG ProcessLogical(ULONG oper)
+{
+
+    ULONG a, b;
+
+    b = ExpressPop();
+    a = ExpressPop();
+    switch(oper)
+    {
+       case LOGICAL_AND_TOKEN:
+	  ExpressPush(a && b);
+	  break;
+
+       case LOGICAL_OR_TOKEN:
+	  ExpressPush(a || b);
+	  break;
+    }
+    return 0;
+
+}
+
+ULONG ParseLogical(ULONG logicalCount)
+{
+
+    register int i, r;
+    ULONG a;
+    ULONG c = 0, lastClass = 0, oper = 0;
+
+    for (i=0; i < logicalCount; i++)
+       ExpressPush(LogicalPop());
+
+    for (i=0, r=0; i < (logicalCount / 2); i++)
+    {
+       a = ExpressPop();
+       TokenType[r] = NUMBER_TOKEN;
+       TokenValue[r++] = a;
+       a = ExpressPop();
+       TokenType[r] = a;  // get the operator type
+       TokenValue[r++] = 0;
+    }
+
+    initNumericStacks();
+
+#if (DEBUG_LOGICAL)
+     DBGPrint("\n");
+#endif
+    for (i=0; i < logicalCount; i++)
+    {
+#if DEBUG_LOGICAL
+       DBGPrint("token: %02X  value: %08X  type: %s\n", TokenType[i],
+	      TokenValue[i], parserDescription[TokenType[i]]);
+#endif
+       switch (TokenType[i])
+       {
+	  case LOGICAL_AND_TOKEN:
+	  case LOGICAL_OR_TOKEN:
+	     if (lastClass != CLASS_BOOLEAN)
+	     {
+		lastClass = CLASS_BOOLEAN;
+		oper = TokenType[i];
+	     }
+	     continue;
+
+	  case NUMBER_TOKEN:
+	     if (lastClass == CLASS_DATA)
+	     {
+		c = ExpressPop();
+		return c;
+	     }
+	     lastClass = CLASS_DATA;
+	     c = TokenValue[i];
+	     ExpressPush(c);
+	     if (oper)
+		oper = ProcessLogical(oper);
+	     continue;
+
+	  case NULL_TOKEN:
+	     c = ExpressPop();
+	     return c;
+
+	  default:
+	     continue;
+       }
+    }
+    return c;
+
+}
+
+ULONG ParseBoolean(ULONG booleanCount)
+{
+
+    register int i, r;
+    ULONG a, oper = 0;
+    ULONG c = 0, lastClass = 0, logicalCount = 0;
+
+    for (i=0; i < booleanCount; i++)
+       ExpressPush(BooleanPop());
+
+    for (i=0, r=0; i < (booleanCount / 2); i++)
+    {
+       a = ExpressPop();
+       TokenType[r] = NUMBER_TOKEN;
+       TokenValue[r++] = a;
+       a = ExpressPop();
+       TokenType[r] = a;  // get the operator type
+       TokenValue[r++] = 0;
+    }
+
+    initNumericStacks();
+
+#if (DEBUG_BOOL)
+     DBGPrint("\n");
+#endif
+    for (i=0; i < booleanCount; i++)
+    {
+#if DEBUG_BOOL
+       DBGPrint("token: %02X  value: %08X  type: %s\n", TokenType[i],
+	      TokenValue[i], parserDescription[TokenType[i]]);
+#endif
+       switch (TokenType[i])
+       {
+	  // partition operators
+	  case LOGICAL_AND_TOKEN:
+	  case LOGICAL_OR_TOKEN:
+	     c = ExpressPop();
+	     LogicalPush(c);
+	     logicalCount++;
+	     LogicalPush(TokenType[i]);
+	     logicalCount++;
+	     ExpressPush(c);
+	     oper = 0;
+	     lastClass = 0;
+	     continue;
+
+	  // boolean operators
+	  case NOT_TOKEN:
+	     if (lastClass != CLASS_BOOLEAN)
+	     {
+		ExpressPush(0);
+		lastClass = CLASS_BOOLEAN;
+		oper = TokenType[i];
+	     }
+	     continue;
+
+	  case GREATER_TOKEN:
+	  case LESS_TOKEN:
+	  case GREATER_EQUAL_TOKEN:
+	  case LESS_EQUAL_TOKEN:
+	  case EQUAL_TOKEN:
+	  case NOT_EQUAL_TOKEN:
+	     if (lastClass != CLASS_BOOLEAN)
+	     {
+		lastClass = CLASS_BOOLEAN;
+		oper = TokenType[i];
+	     }
+	     continue;
+
+	  case NUMBER_TOKEN:
+	     if (lastClass == CLASS_DATA)
+	     {
+		c = ExpressPop();
+		if (logicalCount)
+		{
+		   LogicalPush(c);
+		   logicalCount++;
+		   LogicalPush(0); // push null token
+		   logicalCount++;
+		   c = ParseLogical(logicalCount);
+		   return c;
+		}
+		return c;
+	     }
+	     lastClass = CLASS_DATA;
+	     c = TokenValue[i];
+	     ExpressPush(c);
+	     if (oper)
+		oper = ProcessBoolean(oper);
+	     continue;
+
+	  case NULL_TOKEN:
+	     c = ExpressPop();
+	     if (logicalCount)
+	     {
+		LogicalPush(c);
+		logicalCount++;
+		LogicalPush(0); // push null token
+		logicalCount++;
+		c = ParseLogical(logicalCount);
+		return c;
+	     }
+	     return c;
+
+	  default:
+	     continue;
+       }
+    }
+    return c;
+
+}
+
+ULONG Evaluate(StackFrame *stackFrame, BYTE **p, ULONG *type, ULONG mode)
+{
+
+     register int i;
+     ULONG oper = 0, dref = 0, bracket = 0;
+     ULONG dref_type = 0, lastClass = 0, lastToken = 0;
+     ULONG neg_flag = 0, negative_flag = 0, c;
+     ULONG booleanCount = 0;
+
+#ifdef MDB_ATOMIC
+     spin_lock_irqsave(&expressLock, flags);
+#endif
+
+     if (type)
+	*type = INVALID_EXPRESSION;
+#if (DEBUG_BOOL)
+     DBGPrint("\n");
+#endif
+#if (DEBUG_EXPRESS)
+     DBGPrint("\np: %08X  %s\n", *p, *p);
+#endif
+     parseTokens(stackFrame, *p, mode);
+     if (TokenCount)
+     {
+	initNumericStacks();
+	for (i=0; i < TokenCount; i++)
+	{
+#if (DEBUG_EXPRESS)
+	   DBGPrint("token: %s  lastClass: %d\n", parserDescription[TokenType[i]], lastClass);
+#endif
+	   switch (TokenType[i])
+	   {
+	      case INVALID_NUMBER_TOKEN:
+                 goto evaluate_error_exit;
+
+	      case NOT_TOKEN:
+		 if (lastClass != CLASS_DATA)
+		 {
+		    if (oper)
+		       oper = ProcessOperator(oper);
+		    c = ExpressPop();
+		    BooleanPush(c);
+		    booleanCount++;
+		    BooleanPush(TokenType[i]);
+		    booleanCount++;
+		    dref_type = 0;
+		    lastClass = 0;
+		    neg_flag  = 0;
+		    negative_flag = 0;
+		 }
+		 lastToken = NOT_TOKEN;
+		 continue;
+
+	      // boolean operators
+	      case GREATER_TOKEN:
+	      case LESS_TOKEN:
+	      case GREATER_EQUAL_TOKEN:
+	      case LESS_EQUAL_TOKEN:
+	      case LOGICAL_AND_TOKEN:
+	      case LOGICAL_OR_TOKEN:
+	      case EQUAL_TOKEN:
+	      case NOT_EQUAL_TOKEN:
+		 if (oper)
+		    oper = ProcessOperator(oper);
+		 c = ExpressPop();
+		 BooleanPush(c);
+		 booleanCount++;
+		 BooleanPush(TokenType[i]);
+		 booleanCount++;
+		 dref_type = 0;
+		 lastClass = 0;
+		 neg_flag  = 0;
+		 negative_flag = 0;
+		 lastToken = 0;
+		 continue;
+
+	      // partition operators
+	      case DWORD_TOKEN:
+		 if (dref)
+		    dref_type = ULONG_PTR;
+		 lastToken = 0;
+		 continue;
+
+	      case WORD_TOKEN:
+		 if (dref)
+		    dref_type = WORD_PTR;
+		 lastToken = 0;
+		 continue;
+
+	      case BYTE_TOKEN:
+		 if (dref)
+		    dref_type = BYTE_PTR;
+		 lastToken = 0;
+		 continue;
+
+	      case DREF_OPEN_TOKEN:   // push state and nest for de-reference
+		 if (lastClass == CLASS_DATA)
+		 {
+		    *p = (BYTE *)((ULONG)*p + (ULONG)TokenIndex[i]);
+		    if (type)
+		    {
+		       if (booleanCount)
+			  *type = BOOLEAN_EXPRESSION;
+		       else
+			  *type = NUMERIC_EXPRESSION;
+		    }
+		    c = ExpressPop();
+		    if (booleanCount)
+		    {
+		       BooleanPush(c);
+		       booleanCount++;
+		       BooleanPush(0); // last operator is the null token
+		       booleanCount++;
+		       c = ParseBoolean(booleanCount);
+#if (DEBUG_BOOL)
+		       DBGPrint("be_N : (%d) = (%s)\n", c, c ? "TRUE" : "FALSE");
+#endif
+#ifdef MDB_ATOMIC
+		       spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		       return c;
+		    }
+#if (DEBUG_EXPRESS)
+		    DBGPrint("ee_N : %08X (%d)\n", c, c);
+#endif
+#ifdef MDB_ATOMIC
+		    spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		    return c;
+		 }
+		 dref++;
+		 ContextPush(dref_type);
+		 ContextPush(oper);
+		 ContextPush(lastClass);
+		 ContextPush(neg_flag);
+		 ContextPush(negative_flag);
+		 dref_type = 0;
+		 oper      = 0;
+		 lastClass = 0;
+		 neg_flag  = 0;
+		 negative_flag = 0;
+		 lastToken = 0;
+		 continue;
+
+	      case DREF_CLOSE_TOKEN:   // pop state, restore, and complete oper
+		 if (!dref)
+		    continue;
+		 c = deref(dref_type, ExpressPop());
+		 ExpressPush(c);
+		 negative_flag  = ContextPop();
+		 neg_flag  = ContextPop();
+		 ContextPop();
+		 oper      = ContextPop();
+		 dref_type = ContextPop();
+		 if (dref)
+		    dref--;
+		 lastClass = CLASS_DATA;
+
+		 c = ExpressPop();
+		 if (negative_flag)
+		    c = 0 - c;
+		 if (neg_flag)
+		    c = ~c;
+		 neg_flag = 0;
+		 negative_flag = 0;
+		 ExpressPush(c);
+
+		 if (oper)
+		    oper = ProcessOperator(oper);
+		 lastToken = 0;
+		 continue;
+
+	      case BB_TOKEN:
+		 if (lastClass == CLASS_DATA)
+		 {
+		    *p = (BYTE *)((ULONG)*p + (ULONG)TokenIndex[i]);
+		    if (type)
+		    {
+		       if (booleanCount)
+			  *type = BOOLEAN_EXPRESSION;
+		       else
+			  *type = NUMERIC_EXPRESSION;
+		    }
+		    c = ExpressPop();
+		    if (booleanCount)
+		    {
+		       BooleanPush(c);
+		       booleanCount++;
+		       BooleanPush(0); // last operator is the null token
+		       booleanCount++;
+		       c = ParseBoolean(booleanCount);
+#if (DEBUG_BOOL)
+		       DBGPrint("be_N : (%d) = (%s)\n", c, c ? "TRUE" : "FALSE");
+#endif
+#ifdef MDB_ATOMIC
+		       spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		       return c;
+		    }
+#if (DEBUG_EXPRESS)
+		    DBGPrint("ee_N : %08X (%d)\n", c, c);
+#endif
+#ifdef MDB_ATOMIC
+		    spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		    return c;
+		 }
+		 bracket++;
+		 ContextPush(oper);
+		 ContextPush(lastClass);
+		 ContextPush(neg_flag);
+		 ContextPush(negative_flag);
+		 oper      = 0;
+		 lastClass = 0;
+		 neg_flag  = 0;
+		 negative_flag = 0;
+		 lastToken = 0;
+		 continue;
+
+	      case EB_TOKEN:
+		 if (!bracket)
+		    continue;
+		 negative_flag  = ContextPop();
+		 neg_flag  = ContextPop();
+		 ContextPop();
+		 oper      = ContextPop();
+		 if (bracket)
+		    bracket--;
+		 lastClass = CLASS_DATA;
+		 c = ExpressPop();
+		 if (negative_flag)
+		    c = 0 - c;
+		 if (neg_flag)
+		    c = ~c;
+		 neg_flag = 0;
+		 negative_flag = 0;
+		 ExpressPush(c);
+		 if (oper)
+		    oper = ProcessOperator(oper);
+		 lastToken = 0;
+		 continue;
+
+	      // arithmetic operators
+	      case NEG_TOKEN:
+		 neg_flag = 1;
+		 lastToken = 0;
+		 continue;
+
+	      case MINUS_TOKEN:
+		 if (lastClass == CLASS_ARITHMETIC)
+		 {
+		    lastToken = MINUS_TOKEN;
+		    negative_flag = 1;
+		    continue;
+		 }
+		 if (lastClass != CLASS_ARITHMETIC)
+		 {
+		    lastClass = CLASS_ARITHMETIC;
+		    oper = TokenType[i];
+		 }
+		 lastToken = 0;
+		 continue;
+
+	      case PLUS_TOKEN:
+	      case LEFT_SHIFT_TOKEN:
+	      case RIGHT_SHIFT_TOKEN:
+	      case XOR_TOKEN:
+	      case AND_TOKEN:
+	      case MOD_TOKEN:
+	      case OR_TOKEN:
+	      case MULTIPLY_TOKEN:
+	      case DIVIDE_TOKEN:
+		 if (lastClass != CLASS_ARITHMETIC)
+		 {
+		    lastClass = CLASS_ARITHMETIC;
+		    oper = TokenType[i];
+		 }
+		 lastToken = 0;
+		 continue;
+
+	      // data operators
+	      case CF_TOKEN:
+	      case PF_TOKEN:
+	      case AF_TOKEN:
+	      case ZF_TOKEN:
+	      case SF_TOKEN:
+	      case IF_TOKEN:
+	      case DF_TOKEN:
+	      case OF_TOKEN:
+	      case VM_TOKEN:
+	      case AC_TOKEN:
+	      case EIP_TOKEN:
+	      case FLAGS_TOKEN:
+	      case EAX_TOKEN:
+	      case EBX_TOKEN:
+	      case ECX_TOKEN:
+	      case EDX_TOKEN:
+	      case ESI_TOKEN:
+	      case EDI_TOKEN:
+	      case EBP_TOKEN:
+	      case ESP_TOKEN:
+	      case CS_TOKEN:
+	      case DS_TOKEN:
+	      case ES_TOKEN:
+	      case FS_TOKEN:
+	      case GS_TOKEN:
+	      case SS_TOKEN:
+	      case NUMBER_TOKEN:
+		 if (lastClass == CLASS_DATA)
+		 {
+		    *p = (BYTE *)((ULONG)*p + (ULONG)TokenIndex[i]);
+		    if (type)
+		    {
+		       if (booleanCount)
+			  *type = BOOLEAN_EXPRESSION;
+		       else
+			  *type = NUMERIC_EXPRESSION;
+		    }
+		    c = ExpressPop();
+		    if (booleanCount)
+		    {
+		       BooleanPush(c);
+		       booleanCount++;
+		       BooleanPush(0); // last operator is the null token
+		       booleanCount++;
+		       c = ParseBoolean(booleanCount);
+#if (DEBUG_BOOL)
+		       DBGPrint("be_N : (%d) = (%s)\n", c, c ? "TRUE" : "FALSE");
+#endif
+#ifdef MDB_ATOMIC
+		       spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		       return c;
+		    }
+#if (DEBUG_EXPRESS)
+		    DBGPrint("ee_N : %08X (%d)\n", c, c);
+#endif
+#ifdef MDB_ATOMIC
+		    spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		    return c;
+		 }
+		 lastClass = CLASS_DATA;
+		 c = TokenValue[i];
+		 if (negative_flag)
+		    c = 0 - c;
+		 if (neg_flag)
+		    c = ~TokenValue[i];
+		 neg_flag = 0;
+		 negative_flag = 0;
+		 ExpressPush(c);
+		 if (oper)
+		    oper = ProcessOperator(oper);
+		 lastToken = 0;
+		 continue;
+
+	      case NULL_TOKEN:
+		 *p = (BYTE *)((ULONG)*p + (ULONG)TokenIndex[i]);
+		 if (TokenCount > 1 && type)
+		 {
+		    if (booleanCount)
+		       *type = BOOLEAN_EXPRESSION;
+		    else
+		       *type = NUMERIC_EXPRESSION;
+		 }
+		 c = ExpressPop();
+		 if (booleanCount)
+		 {
+		    BooleanPush(c);
+		    booleanCount++;
+		    BooleanPush(0); // last operator is the null token
+		    booleanCount++;
+		    c = ParseBoolean(booleanCount);
+#if (DEBUG_BOOL)
+		    DBGPrint("be_N : (%d) = (%s)\n", c, c ? "TRUE" : "FALSE");
+#endif
+#ifdef MDB_ATOMIC
+		    spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		    return c;
+		 }
+#if (DEBUG_EXPRESS)
+		 DBGPrint("ee_N : %08X (%d)\n", c, c);
+#endif
+#ifdef MDB_ATOMIC
+		 spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		 return c;
+
+	      // assignment operators
+	      case ASSIGNMENT_TOKEN:
+		 lastToken = 0;
+		 continue;
+
+	      default:
+		 lastToken = 0;
+		 continue;
+	   }
+	}
+     }
+
+evaluate_error_exit:
+     if (type)
+	*type = INVALID_EXPRESSION;
+
+     if (lastToken) {};
+
+#ifdef MDB_ATOMIC
+     spin_unlock_irqrestore(&expressLock, flags);
+#endif
+     return 0;
+
+}
+
+ULONG EvaluateNumericExpression(StackFrame *stackFrame, BYTE **p, ULONG *type)
+{
+     register ULONG c;
+     c = Evaluate(stackFrame, p, type, 1);
+     return c;
+}
+
+ULONG EvaluateExpression(StackFrame *stackFrame, BYTE **p, ULONG *type)
+{
+     register ULONG c;
+     c = Evaluate(stackFrame, p, type, 0);
+     return c;
+}
+
+void EvaluateCommandExpression(StackFrame *stackFrame, BYTE *p)
+{
+     BYTE *expr;
+     ULONG type;
+     ULONG c;
+
+#if DEBUG_EXPRESS
+     DBGPrint("expr: [%s]\n", p);
+#endif
+     expr = p;
+     c = EvaluateExpression(stackFrame, &p, &type);
+     if (type)
+     {
+	DBGPrint("expr: %s = 0x%08X (%dr) (%s) bool(%i) = %s\n",
+		    expr, (unsigned)c, (int)c, exprDescription[type & 3],
+		    (c) ? 1 : 0, (c) ? "TRUE" : "FALSE");
+     }
+     else
+     {
+        DBGPrint("expression parameters invalid\n");
+	DBGPrint("expr: %s = 0x%08X (%dr) (results invalid) (%s)"
+                 " bool(%i) = %s\n",
+		 expr, (unsigned)c, (int)c, exprDescription[type & 3],
+		 (c) ? 1 : 0, (c) ? "TRUE" : "FALSE");
+     }
+     return;
+
+}
+
+#endif
diff -Naur ./debug/mdb-os.c ../linux-2.6.18-mdb/./debug/mdb-os.c
--- ./debug/mdb-os.c	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-os.c	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,1022 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-OS.C
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#include "mdb.h"
+
+#ifdef CONFIG_MDB
+
+// module symbol workspace
+BYTE symbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+BYTE modbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+BYTE workbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+BYTE traceBuf[MAX_SYMBOL_LEN];
+
+extern void touch_nmi_watchdog(void);
+
+int valid_stack_ptr(struct thread_info *tinfo, void *p)
+{
+    return ((p > (void *)tinfo) && (p < (void *)(tinfo + THREAD_SIZE - 3)));
+}
+
+unsigned long print_context_stack(struct thread_info *tinfo,
+			  unsigned long *stack, unsigned long ebp,
+                          unsigned long *rebp)
+{
+    register BYTE *symbol;
+    unsigned long addr, offset;
+    BYTE *modname;
+
+#ifdef	CONFIG_FRAME_POINTER
+    while (valid_stack_ptr(tinfo, (void *)ebp)) 
+    {
+         // addr = *(unsigned long *)(ebp + 4);
+	addr = mdb_getword((ebp + 4), 4);
+
+        if (DBGPrint("[<%08lx>] ", addr))
+           return 1;
+
+        symbol = GetSymbolFromValueOffsetModule(addr, &offset, &modname, 
+                                                traceBuf, MAX_SYMBOL_LEN);
+        if (symbol)
+        {
+           if (modname)
+           {   
+              if (offset)
+              {
+                 if (DBGPrint("%s|%s+0x%X", modname, symbol, offset))
+                    return 1;
+              }
+              else
+              {
+                 if (DBGPrint("%s|%s", modname, symbol))
+                    return 1;
+              }
+           }
+           else
+           {
+              if (offset)
+              {
+                 if (DBGPrint("%s+0x%X", symbol, offset))
+                    return 1;
+              }
+              else
+              {
+                 if (DBGPrint("%s", symbol))
+                    return 1;
+              }
+           }
+        }
+        if (DBGPrint("\n"))
+           return 1;
+
+        // if (ebp == *(unsigned long *)ebp)
+	if (ebp == mdb_getword(ebp, 4))
+	   break;
+
+        // ebp = *(unsigned long *)ebp;
+	ebp = mdb_getword(ebp, 4))
+    }
+#else
+    while (valid_stack_ptr(tinfo, stack)) 
+    {
+       addr = mdb_getword((unsigned long)stack, 4);
+       stack++;
+
+       if (__kernel_text_address(addr))
+       {
+          if (DBGPrint("[<%08lx>] ", addr))
+             return 1;
+
+          symbol = GetSymbolFromValueOffsetModule(addr, &offset, &modname, 
+                                                traceBuf, MAX_SYMBOL_LEN);
+          if (symbol)
+          {
+             if (modname)
+             {    
+                if (offset)
+                {
+                   if (DBGPrint("%s|%s+0x%X", modname, symbol, offset))
+                      return 1;
+                }
+                else
+                {
+                   if (DBGPrint("%s|%s", modname, symbol))
+                      return 1;
+                }
+             }
+             else
+             {
+                if (offset)  
+                {
+                   if (DBGPrint("%s+0x%X", symbol, offset))
+                      return 1;
+                }
+                else
+                {
+                   if (DBGPrint("%s", symbol))
+                      return 1;
+                }
+             }
+          }
+          if (DBGPrint("\n"))
+             return 1;
+       }
+    }
+#endif
+    if (rebp)
+       *rebp = ebp;
+
+    return 0;
+}
+
+int bt_stack(struct task_struct *task, struct pt_regs *regs,
+             unsigned long *stack)
+{
+    unsigned long ebp = 0;
+
+    if (!task)
+       task = current;
+
+    if (!stack) 
+    {
+       unsigned long dummy;
+
+       stack = &dummy;
+       if (task && task != current)
+       {  
+          if (mdb_verify_rw(&task->thread.esp, 4))
+             return 0;
+
+          // stack = (unsigned long *)task->thread.esp;
+          stack = (unsigned long *)
+                  mdb_getword((unsigned long)&task->thread.esp, 4);
+       }
+    }
+
+#ifdef CONFIG_FRAME_POINTER
+    if (!ebp) 
+    {
+       if (task == current) 
+          asm ("movl %%ebp, %0" : "=r" (ebp) : );
+       else 
+       {
+          if (mdb_verify_rw(task->thread.esp, 4))
+             return 0;
+
+          // ebp = *(unsigned long *)task->thread.esp;
+          ebp = (unsigned long *)mdb_getword(task->thread.esp, 4);
+       } 
+    }
+#endif
+
+    while (1) 
+    {
+       struct thread_info *context;
+
+       context = (struct thread_info *)
+                 ((unsigned long)stack & (~(THREAD_SIZE - 1)));
+
+       if (mdb_verify_rw(context, 4))
+          return 0;
+
+       if (print_context_stack(context, stack, ebp, &ebp))
+          return 1;
+
+       if (mdb_verify_rw(&context->previous_esp, 4))
+          return 0;
+
+       // stack = (unsigned long *)context->previous_esp;
+       stack = (unsigned long *)
+               mdb_getword((unsigned long)&context->previous_esp, 4);
+       if (!stack)
+          break;
+
+       touch_nmi_watchdog();
+    }
+    return 0;
+}
+
+unsigned char *mdbprompt = "--- More (Q to Quit) ---";
+int nextline = 0;
+
+int mdb_printf(char *fmt, ...)
+{
+	char buffer[256];
+	char keystroke[16];
+	va_list	ap;
+	int linecount;
+	struct console *c = console_drivers;
+
+        linecount = 23;
+
+	va_start(ap, fmt);
+	vsprintf(buffer, fmt, ap);
+	va_end(ap);
+
+	while (c) 
+        {
+	   c->write(c, buffer, strlen(buffer));
+	   c = c->next;
+	}
+
+	if (strchr(buffer, '\n') != NULL) 
+	   nextline++;
+
+	if (nextline == linecount) 
+        {
+	   nextline = 0;	
+
+	   c = console_drivers;
+	   while (c) 
+           {
+	      c->write(c, mdbprompt, strlen(mdbprompt));
+	      c = c->next;
+	   }
+
+	   keystroke[0] = (char)mdb_getkey();
+	   nextline = 1;	
+
+	   if ((keystroke[0] == 'q') || (keystroke[0] == 'Q'))
+           {
+	      c = console_drivers;
+  	      while (c) 
+              { 
+	         c->write(c, "\n", 1);
+	         c = c->next;
+	      }
+              return 1;
+           }
+	}
+
+        return 0;
+}
+
+
+int mdb_serial_port = 0;
+
+int get_modem_char(void)
+{
+    unsigned char ch;
+    int status;
+
+    if (mdb_serial_port == 0)
+       return -1;
+
+    if ((status = inb(mdb_serial_port + UART_LSR)) & UART_LSR_DR) 
+    {
+       ch = inb(mdb_serial_port + UART_RX);
+       switch (ch)
+       {
+	   case 0x7f:
+  	      ch = 8;
+              break;
+
+           case '\t':
+	      ch = ' ';
+              break;
+
+           case 8:  // backspace
+              break;
+
+	   case 13: // enter
+	      mdb_printf("\n");
+              break;
+
+           default:
+	      if (!isprint(ch))
+	         return(-1);
+	      mdb_printf("%c", ch);
+              break;
+	}
+ 	return ch;
+    }
+    return -1;
+}
+
+int mdb_suppress_crlf = 0;
+static int get_kbd_char(void)
+{
+	int	scancode, scanstatus;
+	static int shift_lock;	/* CAPS LOCK state (0-off, 1-on) */
+	static int shift_key;	/* Shift next keypress */
+	static int ctrl_key;
+	u_short keychar;
+	extern u_short plain_map[], shift_map[], ctrl_map[];
+
+	if ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)
+		return -1;
+
+	/*
+	 * Fetch the scancode
+	 */
+	scancode = inb(KBD_DATA_REG);
+	scanstatus = inb(KBD_STATUS_REG);
+
+	/*
+	 * Ignore mouse events.
+	 */
+	if (scanstatus & KBD_STAT_MOUSE_OBF)
+		return -1;
+
+	/*
+	 * Ignore release, trigger on make
+	 * (except for shift keys, where we want to
+	 *  keep the shift state so long as the key is
+	 *  held down).
+	 */
+
+	if (((scancode & 0x7f) == 0x2a) || 
+            ((scancode & 0x7f) == 0x36)) 
+        {
+		/*
+		 * Next key may use shift table
+		 */
+		if ((scancode & 0x80) == 0) {
+			shift_key=1;
+		} else {
+			shift_key=0;
+		}
+		return -1;
+	}
+
+	if ((scancode & 0x7f) == 0x1d) {
+		/*
+		 * Left ctrl key
+		 */
+		if ((scancode & 0x80) == 0) {
+			ctrl_key = 1;
+		} else {
+			ctrl_key = 0;
+		}
+		return -1;
+	}
+
+	if ((scancode & 0x80) != 0)
+		return -1;
+
+	scancode &= 0x7f;
+
+	/*
+	 * Translate scancode
+	 */
+
+	if (scancode == 0x3a) {
+		/*
+		 * Toggle caps lock
+		 */
+		shift_lock ^= 1;
+		return -1;
+	}
+
+	if (scancode == 0x0e) {
+		/*
+		 * Backspace
+		 */
+		return 8;
+	}
+
+	if (scancode == 0xe0) {
+		return -1;
+	}
+
+	/*
+	 * For Japanese 86/106 keyboards
+	 * 	See comment in drivers/char/pc_keyb.c.
+	 * 	- Masahiro Adegawa
+	 */
+	if (scancode == 0x73) {
+		scancode = 0x59;
+	} else if (scancode == 0x7d) {
+		scancode = 0x7c;
+	}
+
+	if (!shift_lock && !shift_key && !ctrl_key) {
+		keychar = plain_map[scancode];
+	} else if (shift_lock || shift_key) {
+		keychar = shift_map[scancode];
+	} else if (ctrl_key) {
+		keychar = ctrl_map[scancode];
+	} else {
+		keychar = 0x0020;
+		mdb_printf("Unknown state/scancode (%d)\n", scancode);
+	}
+
+	keychar &= 0x0fff;
+	if (keychar == '\t')
+		keychar = ' ';
+	
+        switch (keychar)
+        {
+           case K_F1:
+           case K_F2:
+           case K_F3:
+           case K_F4:
+           case K_F5:
+           case K_F6:
+           case K_F7:
+           case K_F8:
+           case K_F9:
+           case K_F10:
+           case K_F11:
+           case K_F12:
+	      return keychar;
+           default:
+              break;
+        }
+
+	switch (KTYP(keychar)) 
+        {
+	   case KT_LETTER:
+	   case KT_LATIN:
+		if (isprint(keychar))
+			break;		/* printable characters */
+		/* drop through */
+	   case KT_SPEC:
+		if (keychar == K_ENTER)
+			break;
+		/* drop through */
+           case KT_PAD:
+                switch (keychar)
+                { 
+                   case K_P0:
+                   case K_P1:
+                   case K_P2:
+                   case K_P4:
+                   case K_P6:
+                   case K_P7:
+                   case K_P8:
+                   case K_PDOT:
+                      return keychar;
+                }
+                return -1;
+
+           case KT_CUR:
+                switch (keychar)
+                { 
+                   case K_DOWN:
+                   case K_LEFT:
+                   case K_RIGHT:
+                   case K_UP:
+                      return keychar;
+                }
+                return -1;
+
+	   default:
+		return(-1);	/* ignore unprintables */
+	}
+
+	if ((scancode & 0x7f) == 0x1c) {
+		/*
+		 * enter key.  All done.  Absorb the release scancode.
+		 */
+		while ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)
+			;
+
+		/*
+		 * Fetch the scancode
+		 */
+		scancode = inb(KBD_DATA_REG);
+		scanstatus = inb(KBD_STATUS_REG);
+
+		while (scanstatus & KBD_STAT_MOUSE_OBF) 
+                {
+		   scancode = inb(KBD_DATA_REG);
+		   scanstatus = inb(KBD_STATUS_REG);
+		}
+
+                // enter-release error
+		if (scancode != 0x9c) {} ;
+
+                if (!mdb_suppress_crlf)
+		   mdb_printf("\n");
+		return 13;
+	}
+
+	/*
+	 * echo the character.
+	 */
+	mdb_printf("%c", keychar & 0xff);
+	return keychar & 0xff;
+}
+
+int mdb_getkey(void)
+{
+   int key = -1;
+
+   for (;;) 
+   {
+      key = get_kbd_char();
+      if (key != -1)
+ 	 break;
+
+      touch_nmi_watchdog();
+   }
+   return key;
+}
+
+int mdb_copy(void *to, void *from, size_t size)
+{
+    return __copy_to_user_inatomic(to, from, size);
+}
+
+int mdb_verify_rw(void *addr, size_t size)
+{
+    unsigned char data[size];
+    return (mdb_copy(data, addr, size));
+}
+
+int mdb_getlword(unsigned long *word, unsigned long addr, size_t size)
+{
+	int err;
+
+	__u8  w1;
+	__u16 w2;
+	__u32 w4;
+	__u64 w8;
+
+	*word = 0;	/* Default value if addr or size is invalid */
+	switch (size) {
+	case 1:
+		if (!(err = mdb_copy(&w1, (void *)addr, size)))
+			*word = w1;
+		break;
+	case 2:
+		if (!(err = mdb_copy(&w2, (void *)addr, size)))
+			*word = w2;
+		break;
+	case 4:
+		if (!(err = mdb_copy(&w4, (void *)addr, size)))
+			*word = w4;
+		break;
+	case 8:
+		if (size <= sizeof(*word)) 
+                {
+			if (!(err = mdb_copy(&w8, (void *)addr, size)))
+				*word = w8;
+			break;
+		}
+	default:
+		err = -EFAULT;
+	}
+	return (err);
+}
+
+int mdb_putword(unsigned long addr, unsigned long word, size_t size)
+{
+	int err;
+	__u8  w1;
+	__u16 w2;
+	__u32 w4;
+	__u64 w8;
+
+	switch (size) {
+	case 1:
+		w1 = word;
+		err = mdb_copy((void *)addr, &w1, size);
+		break;
+	case 2:
+		w2 = word;
+		err = mdb_copy((void *)addr, &w2, size);
+		break;
+	case 4:
+		w4 = word;
+		err = mdb_copy((void *)addr, &w4, size);
+		break;
+	case 8:
+		if (size <= sizeof(word)) 
+                {
+		   w8 = word;
+		   err = mdb_copy((void *)addr, &w8, size);
+		   break;
+		}
+	default:
+		err = -EFAULT;
+	}
+	return (err);
+}
+
+unsigned long mdb_getword(unsigned long addr, size_t size)
+{
+   unsigned long data = 0;
+   register int ret;
+   
+   ret = mdb_getlword(&data, addr, size);
+   if (ret)
+      return 0;
+
+   return data;
+}
+
+int DisplayClosestSymbol(ULONG address)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset = 0, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(address, &size, &offset, &modname, namebuf);
+    if (!name)
+       return -1;
+
+    if (modname)
+    {
+       if (offset)
+          DBGPrint("%s|%s+0x%X\n", modname, name, offset);
+       else
+          DBGPrint("%s|%s\n", modname, name);
+    }
+    else
+    {
+       if (offset)
+          DBGPrint("%s+0x%X\n", name, offset);
+       else
+          DBGPrint("%s\n", name);
+    }
+    return 0;
+}
+
+void DumpOSSymbolTableMatch(BYTE *symbol)
+{
+    mdb_kallsyms(symbol, mdb_printf);
+    return;
+}
+
+ULONG GetValueFromSymbol(BYTE *symbol)
+{
+   return ((ULONG)kallsyms_lookup_name(symbol));
+}
+
+
+BYTE *GetModuleInfoFromSymbolValue(ULONG value, BYTE *buf, ULONG len)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(value, &size, &offset, &modname, namebuf);
+    if (modname && buf)
+    {
+       strncpy(buf, modname, len);
+       return (BYTE *)buf;
+    }
+    return NULL;
+}
+
+BYTE *GetSymbolFromValue(ULONG value, BYTE *buf, ULONG len)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(value, &size, &offset, &modname, namebuf);
+    if (!name)
+       return NULL;
+
+    if (!offset && buf)
+    {
+       strncpy(buf, namebuf, len);
+       return (BYTE *)buf;
+    }
+
+    return NULL;
+}
+
+BYTE *GetSymbolFromValueWithOffset(ULONG value, ULONG *sym_offset,
+                                   BYTE *buf, ULONG len)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(value, &size, &offset, &modname, namebuf);
+    if (!name || !buf)
+       return NULL;
+
+    if (sym_offset)
+      *sym_offset = offset;
+
+    strncpy(buf, namebuf, len);
+    return (BYTE *)buf;
+}
+
+BYTE *GetSymbolFromValueOffsetModule(ULONG value, ULONG *sym_offset,
+                                     BYTE **module, BYTE *buf, ULONG len)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(value, &size, &offset, &modname, namebuf);
+    if (!name || !buf)
+       return NULL;
+
+    if (sym_offset)
+      *sym_offset = offset;
+
+    if (module)
+       *module = modname;
+
+    strncpy(buf, namebuf, len);
+    return (BYTE *)buf;
+}
+
+ULONG get_processor_id(void)
+{
+#if defined(CONFIG_SMP)
+   return smp_processor_id();
+#else
+   return 0;
+#endif
+}
+
+ULONG get_physical_processor(void)
+{
+#if defined(CONFIG_SMP)
+   return smp_processor_id();
+#else
+   return 0;
+#endif
+}
+
+ULONG fpu_present(void)
+{
+   if (boot_cpu_has(X86_FEATURE_FPU)) 
+       return 1;
+    return 0;
+}
+
+extern ULONG cpu_mttr_on(void)
+{
+   if (boot_cpu_has(X86_FEATURE_MTRR)) 
+       return 1;
+    return 0;
+}
+
+BYTE *UpcaseString(BYTE *s)
+{
+   register int i;
+ 
+   for (i=0; i < strlen(s); i++)     
+      s[i] = toupper(s[i]);
+   return s;
+      
+}
+void ClearScreen(void)
+{
+    return;
+}
+
+WORD ReadFS(void)
+{
+    WORD contents = 0;
+
+    __asm__ ("mov %%fs,%0\n\t":"=r"(contents));
+    return contents;
+}
+
+WORD ReadGS(void)
+{
+    WORD contents = 0;
+
+    __asm__ ("mov %%gs,%0\n\t":"=r"(contents));
+    return contents;
+}
+
+ULONG ReadDR(ULONG regnum)
+{
+	ULONG contents = 0;
+
+	switch(regnum) 
+        {
+	   case 0:
+		__asm__ ("movl %%db0,%0\n\t":"=r"(contents));
+		break;
+	   case 1:
+		__asm__ ("movl %%db1,%0\n\t":"=r"(contents));
+		break;
+	   case 2:
+		__asm__ ("movl %%db2,%0\n\t":"=r"(contents));
+		break;
+	   case 3:
+		__asm__ ("movl %%db3,%0\n\t":"=r"(contents));
+		break;
+	   case 4:
+	   case 5:
+		break;
+	   case 6:
+		__asm__ ("movl %%db6,%0\n\t":"=r"(contents));
+		break;
+	   case 7:
+		__asm__ ("movl %%db7,%0\n\t":"=r"(contents));
+		break;
+	   default:
+		break;
+	}
+
+	return contents;
+}
+
+void WriteDR(int regnum, ULONG contents)
+{
+	switch(regnum) 
+        {
+	   case 0:
+		__asm__ ("movl %0,%%db0\n\t"::"r"(contents));
+		break;
+	   case 1:
+		__asm__ ("movl %0,%%db1\n\t"::"r"(contents));
+		break;
+	   case 2:
+		__asm__ ("movl %0,%%db2\n\t"::"r"(contents));
+		break;
+	   case 3:
+		__asm__ ("movl %0,%%db3\n\t"::"r"(contents));
+		break;
+	   case 4:
+	   case 5:
+		break;
+	   case 6:
+		__asm__ ("movl %0,%%db6\n\t"::"r"(contents));
+		break;
+	   case 7:
+		__asm__ ("movl %0,%%db7\n\t"::"r"(contents));
+		break;
+	   default:
+		break;
+	}
+}
+
+ULONG ReadCR(int regnum)
+{
+	ULONG contents = 0;
+
+	switch(regnum) 
+        {
+	   case 0:
+		__asm__ ("movl %%cr0,%0\n\t":"=r"(contents));
+		break;
+	   case 1:
+		break;
+	   case 2:
+		__asm__ ("movl %%cr2,%0\n\t":"=r"(contents));
+		break;
+	   case 3:
+		__asm__ ("movl %%cr3,%0\n\t":"=r"(contents));
+		break;
+	   case 4:
+		__asm__ ("movl %%cr4,%0\n\t":"=r"(contents));
+		break;
+	   default:
+		break;
+	}
+	return contents;
+}
+
+void WriteCR(int regnum, ULONG contents)
+{
+	switch(regnum) 
+        {
+	   case 0:
+		__asm__ ("movl %0,%%cr0\n\t"::"r"(contents));
+		break;
+	   case 1:
+		break;
+	   case 2:
+		__asm__ ("movl %0,%%cr2\n\t"::"r"(contents));
+		break;
+	   case 3:
+		__asm__ ("movl %0,%%cr3\n\t"::"r"(contents));
+		break;
+	   case 4:
+		__asm__ ("movl %0,%%cr4\n\t"::"r"(contents));
+		break;
+	   default:
+		break;
+	}
+	return;
+}
+
+ULONG ReadTR(void)
+{
+   unsigned short tr;
+
+   __asm__ __volatile__("str %0":"=a"(tr));
+
+   return (ULONG) tr;
+}
+
+ULONG ReadLDTR(void)
+{
+   unsigned short ldt;
+ 
+   __asm__ __volatile__("sldt %0":"=a"(ldt));
+
+   return (ULONG) ldt;
+}
+
+void ReadGDTR(ULONG *v)
+{
+   __asm__ __volatile__("sgdt %0":"=m"(*v));
+}
+
+void ReadIDTR(ULONG *v)
+{
+    __asm__ __volatile__("sidt %0":"=m"(*v));
+}
+  
+void save_npx(NUMERIC_FRAME *v)
+{
+    __asm__ __volatile__("fsave %0":"=m"(*v));
+}
+
+void load_npx(NUMERIC_FRAME *v)
+{
+    __asm__ __volatile__("frstor %0":"=m"(*v));
+}
+
+ULONG ReadDR0(void)  {  return (ReadDR(0)); }
+ULONG ReadDR1(void)  {  return (ReadDR(1)); }
+ULONG ReadDR2(void)  {  return (ReadDR(2)); }
+ULONG ReadDR3(void)  {  return (ReadDR(3)); }
+ULONG ReadDR6(void)  {  return (ReadDR(6)); }
+ULONG ReadDR7(void)  {  return (ReadDR(7)); }
+
+void WriteDR0(ULONG v) { WriteDR(0, v); }
+void WriteDR1(ULONG v) { WriteDR(1, v); }
+void WriteDR2(ULONG v) { WriteDR(2, v); }
+void WriteDR3(ULONG v) { WriteDR(3, v); }
+void WriteDR6(ULONG v) { WriteDR(6, v); }
+void WriteDR7(ULONG v) { WriteDR(7, v); }
+
+ULONG ReadCR0(void) {  return (ReadCR(0)); }
+ULONG ReadCR2(void) {  return (ReadCR(2)); }
+ULONG ReadCR3(void) {  return (ReadCR(3)); }
+ULONG ReadCR4(void) {  return (ReadCR(4)); }
+
+void WriteCR0(ULONG v) { WriteCR(0, v); }
+void WriteCR2(ULONG v) { WriteCR(2, v); }
+void WriteCR3(ULONG v) { WriteCR(3, v); }
+void WriteCR4(ULONG v) { WriteCR(4, v); }
+
+void ReadMSR(ULONG r, ULONG *v1, ULONG *v2)
+{
+    ULONG vv1, vv2;
+
+    rdmsr(r, vv1, vv2);
+
+    if (v1)
+       *v1 = vv1;
+    if (v2)
+       *v2 = vv2;
+}
+
+void WriteMSR(ULONG r, ULONG *v1, ULONG *v2)
+{
+    ULONG vv1 = 0, vv2 = 0;
+
+    if (v1)
+       vv1 = *v1;
+    if (v2)
+       vv2 = *v2;
+
+    wrmsr(r, vv1, vv2);
+}
+
+#endif
diff -Naur ./debug/mdb-os.h ../linux-2.6.18-mdb/./debug/mdb-os.h
--- ./debug/mdb-os.h	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-os.h	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,109 @@
+
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-OS.H
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#ifndef _MDB_OS_H
+#define _MDB_OS_H
+
+#define MAX_SYMBOL_LEN  KSYM_NAME_LEN+1
+
+extern atomic_t inmdb;
+extern BYTE *mdb_oops;
+extern BYTE *last_mdb_oops;
+extern BYTE symbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+extern BYTE modbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+extern BYTE workbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+
+extern int mdb_kallsyms(char *str, int (*print)(char *s, ...));
+extern int mdb_modules(char *str, int (*print)(char *s, ...));
+extern int mdb_getkey(void);
+extern int mdb_getlword(unsigned long *word, unsigned long addr, size_t size);
+extern int mdb_putword(unsigned long addr, unsigned long word, size_t size);
+extern unsigned long mdb_getword(unsigned long addr, size_t size);
+extern int mdb_verify_rw(void *addr, size_t size);
+extern ULONG ValidateAddress(ULONG addr, ULONG length);
+extern int DisplayClosestSymbol(ULONG address);
+extern void DumpOSSymbolTableMatch(BYTE *symbol);
+extern void DumpOSSymbolTable(void);
+extern ULONG GetValueFromSymbol(BYTE *symbol);
+extern BYTE *GetModuleInfoFromSymbolValue(ULONG value, BYTE *buf, ULONG len);
+extern BYTE *GetSymbolFromValue(ULONG value, BYTE *buf, ULONG len);
+extern BYTE *GetSymbolFromValueWithOffset(ULONG value, ULONG *sym_offset,
+                                          BYTE *buf, ULONG len);
+extern BYTE *GetSymbolFromValueOffsetModule(ULONG value, ULONG *sym_offset,
+                                     BYTE **module, BYTE *buf, ULONG len);
+extern ULONG get_processor_id(void);
+extern ULONG get_physical_processor(void);
+extern ULONG fpu_present(void);
+extern ULONG cpu_mttr_on(void);
+extern BYTE *UpcaseString(BYTE *s);
+extern void ClearScreen(void);
+extern WORD ReadFS(void);
+extern WORD ReadGS(void);
+extern ULONG ReadDR(ULONG regnum);
+extern void WriteDR(int regnum, ULONG contents);
+extern ULONG ReadCR(int regnum);
+extern void WriteCR(int regnum, ULONG contents);
+extern ULONG ReadTR(void);
+extern ULONG ReadLDTR(void);
+extern void ReadGDTR(ULONG *v);
+extern void ReadIDTR(ULONG *v);
+extern void save_npx(NUMERIC_FRAME *v);
+extern void load_npx(NUMERIC_FRAME *v);
+extern ULONG ReadDR0(void); 
+extern ULONG ReadDR1(void);
+extern ULONG ReadDR2(void);
+extern ULONG ReadDR3(void);
+extern ULONG ReadDR6(void);
+extern ULONG ReadDR7(void);
+extern void WriteDR0(ULONG v);
+extern void WriteDR1(ULONG v);
+extern void WriteDR2(ULONG v);
+extern void WriteDR3(ULONG v);
+extern void WriteDR6(ULONG v);
+extern void WriteDR7(ULONG v);
+extern ULONG ReadCR0(void);
+extern ULONG ReadCR2(void);
+extern ULONG ReadCR3(void);
+extern ULONG ReadCR4(void);
+extern void WriteCR0(ULONG v);
+extern void WriteCR2(ULONG v);
+extern void WriteCR3(ULONG v);
+extern void WriteCR4(ULONG v);
+extern void ReadMSR(ULONG r, ULONG *v1, ULONG *v2);
+extern void WriteMSR(ULONG r, ULONG *v1, ULONG *v2);
+#endif
+
diff -Naur ./debug/mdb-proc.h ../linux-2.6.18-mdb/./debug/mdb-proc.h
--- ./debug/mdb-proc.h	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb-proc.h	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,139 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB-PROC.H
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#ifndef _MDB_PROC_H
+#define _MDB_PROC_H
+
+#define MAX_PROCESSORS           NR_CPUS
+#define SYMBOL_DEBUG             0
+
+// mdb-base.c
+extern ULONG needs_proceed;
+extern ULONG general_toggle;
+extern ULONG line_info_toggle;
+extern ULONG control_toggle;
+extern ULONG segment_toggle;
+extern ULONG numeric_toggle;
+extern ULONG reason_toggle;
+
+extern ULONG MajorVersion;
+extern ULONG MinorVersion;
+extern ULONG BuildVersion;
+extern BYTE *IA32Flags[];
+extern BYTE *BreakDescription[];
+extern BYTE *BreakLengthDescription[];
+extern BYTE *ExceptionDescription[];
+extern NUMERIC_FRAME npx[MAX_PROCESSORS];
+extern StackFrame ReferenceFrame[MAX_PROCESSORS];
+extern volatile ULONG debuggerActive;
+extern volatile ULONG ProcessorHold[MAX_PROCESSORS]; 
+extern volatile ULONG ProcessorState[MAX_PROCESSORS]; 
+extern volatile ULONG ProcessorMode[MAX_PROCESSORS]; 
+
+// mdb-ia32.c
+extern volatile BYTE *lastDumpAddress; 
+extern volatile BYTE *lastLinkAddress;
+extern volatile ULONG lastUnasmAddress;
+extern volatile ULONG displayLength;
+extern volatile ULONG lastCommand;
+extern volatile ULONG lastCommandEntry;
+extern volatile BYTE lastDebugCommand[100];
+extern volatile ULONG lastDisplayLength;
+extern volatile BYTE debugCommand[100];
+extern volatile ULONG nextUnasmAddress;
+extern volatile ULONG pic1Value;
+extern volatile ULONG pic2Value;
+extern volatile ULONG BreakReserved[4];
+extern volatile ULONG BreakPoints[4];
+extern volatile ULONG BreakType[4];
+extern volatile ULONG BreakLength[4];
+extern volatile ULONG BreakTemp[4];
+extern volatile ULONG BreakGo[4];
+extern volatile ULONG BreakProceed[4];
+extern volatile ULONG BreakMask[MAX_PROCESSORS];
+extern volatile StackFrame *CurrentFrame[MAX_PROCESSORS];
+extern volatile ULONG NestedInterrupts[MAX_PROCESSORS];
+extern volatile ULONG ConditionalBreakpoint[4];
+extern volatile BYTE BreakCondition[4][256];
+extern volatile StackFrame lastStackFrame;
+extern volatile ULONG lastCR0;
+extern volatile ULONG lastCR2;
+extern volatile ULONG lastCR4;
+extern volatile ULONG CurrentDR7;
+extern volatile ULONG CurrentDR6[MAX_PROCESSORS];
+extern volatile ULONG repeatCommand;
+extern volatile ULONG totalLines;
+extern volatile ULONG debuggerInitialized;
+
+extern ULONG disassemble(StackFrame *stackFrame, ULONG p, ULONG count, 
+                         ULONG use);
+extern void ClearDebuggerState(void);
+extern void displayMTRRRegisters(void);
+extern void DisplayGDT(BYTE *GDT_ADDRESS);
+extern void DisplayIDT(BYTE *IDT_ADDRESS);
+extern void SetDebugRegisters(void);
+extern void LoadDebugRegisters(void);
+extern void ClearTempBreakpoints(void);
+extern ULONG ValidBreakpoint(ULONG address);
+extern BYTE *dump(BYTE *p, ULONG count);
+extern BYTE *dumpWord(BYTE *p, ULONG count);
+extern BYTE *dumpDouble(BYTE *p, ULONG count);
+extern BYTE *dumpLinkedList(BYTE *p, ULONG count, ULONG offset);
+extern BYTE *dumpDoubleStack(StackFrame *stackFrame, BYTE *p, ULONG count);
+extern BYTE *dumpStack(StackFrame *stackFrame, BYTE *p, ULONG count);
+extern ULONG debugger_setup(ULONG processor, ULONG Exception, StackFrame *stackFrame, BYTE *panicMsg);
+extern ULONG debugger_entry(ULONG Exception, StackFrame *stackFrame, ULONG processor);
+extern ULONG debugger_command_entry(ULONG processor, ULONG Exception, StackFrame *stackFrame);
+extern ULONG ConsoleDisplayBreakReason(StackFrame *stackFrame,
+			       ULONG reason, ULONG processor,
+			       ULONG lastCommand);
+extern ULONG EvaluateExpression(StackFrame *stackFrame, BYTE **p, ULONG *type);
+extern ULONG EvaluateNumericExpression(StackFrame *stackFrame, BYTE **p, 
+                                       ULONG *type);
+extern ULONG unassemble(StackFrame *stackFrame, ULONG ip, ULONG use, 
+                        ULONG *ret);
+extern void DisplayASCIITable(void);
+extern BYTE *UpcaseString(BYTE *);
+extern ULONG validate_address(ULONG addr);
+extern ULONG ScreenInputFromKeyboard(BYTE *buffer, ULONG Start, ULONG Length);
+
+extern ULONG GetIP(StackFrame *);
+extern ULONG GetStackAddress(StackFrame *);
+extern ULONG GetStackSegment(StackFrame *);
+extern WORD read_memory(void *, void *, unsigned);
+
+#endif
+
diff -Naur ./debug/mdb.c ../linux-2.6.18-mdb/./debug/mdb.c
--- ./debug/mdb.c	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb.c	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,496 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 1997, 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah  84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2, or any later version.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@utah-nac.org is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software to jmerkey@utah-nac.org
+*   or linux-kernel@vger.kernel.org.  New releases, patches, bug fixes, and
+*   technical documentation can be found at www.kernel.org.  I will
+*   periodically post new releases of this software to www.kernel.org
+*   that contain bug fixes and enhanced capabilities.
+*
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB.C
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  December 20, 2001
+*
+***************************************************************************/
+
+#include "mdb.h"
+
+#ifdef CONFIG_MDB
+
+extern void MDBInitializeDebugger(void);
+extern void MDBClearDebuggerState(void);
+
+ULONG TotalSystemMemory = 0;
+ULONG HistoryPointer = 0;
+BYTE HistoryBuffer[16][256]; // remember last 32 non-repeating commands
+BYTE delim_table[256];
+void set_delimiter(BYTE c) {  delim_table[c & 0xFF] = TRUE;  }
+
+void SaveLastCommandInfo(ULONG processor)
+{
+    register int i;
+
+    repeatCommand = 0;
+    lastCommand = toupper(debugCommand[0]);
+    lastDisplayLength = displayLength;
+    ProcessorMode[processor] = 0;
+
+    for (i=0; (i < 80) && (debugCommand[i]); i++)
+    {
+       if ((debugCommand[i] == '\n') || (debugCommand[i] == '\r'))
+          lastDebugCommand[i] = '\0';
+       else
+          lastDebugCommand[i] = debugCommand[i];
+    }
+    lastDebugCommand[i] = '\0';
+
+    return;
+}
+
+StackFrame CurrentStackFrame[MAX_PROCESSORS];
+
+atomic_t inmdb = { 0 };
+BYTE *mdb_oops = NULL;
+BYTE *last_mdb_oops = NULL;
+
+int mdb(int reason, int error, void *frame)
+{
+    register ULONG retCode = 0, processor = get_processor_id();
+    extern void ReadStackFrame(void *, StackFrame *, ULONG);
+    extern void WriteStackFrame(void *, StackFrame *, ULONG);
+    unsigned long state;
+#ifdef CONFIG_MDB_CONSOLE_REDIRECTION
+    extern int kmsg_redirect;
+    int kmsg_redirect_save;
+#endif
+
+    preempt_disable();
+#ifdef CONFIG_MDB_CONSOLE_REDIRECTION
+    kmsg_redirect_save = kmsg_redirect;
+    kmsg_redirect = 0;
+#endif
+
+    last_mdb_oops = NULL;
+    if (mdb_oops)
+    {
+       last_mdb_oops = mdb_oops;
+       mdb_oops = NULL;
+    }
+    atomic_inc(&inmdb);
+    state = save_flags();
+    memset(&CurrentStackFrame[processor], 0, sizeof(StackFrame));
+    ReadStackFrame(frame, &CurrentStackFrame[processor], processor);
+    CurrentStackFrame[processor].tReserved[2] = (ULONG)frame;
+    retCode = debugger_entry(reason, &CurrentStackFrame[processor], 
+                             processor);
+    WriteStackFrame(frame, &CurrentStackFrame[processor], processor);
+
+    restore_flags(state);
+    atomic_dec(&inmdb);
+
+#ifdef CONFIG_MDB_CONSOLE_REDIRECTION
+    kmsg_redirect = kmsg_redirect_save;
+#endif
+    preempt_enable();
+
+    return retCode; 
+}
+
+int mdb_close(void) {  MDBClearDebuggerState(); return 0; }
+
+ALT_DEBUGGER MDBDebugger = { NULL, NULL, NULL };
+
+int mdb_init(void) 
+{  
+   register int i;
+
+   MDBInitializeDebugger(); 
+   MDBDebugger.AlternateDebugger = mdb;
+   AddAlternateDebugger(&MDBDebugger);
+
+   // initialize delimiter lookup table
+   for (i=0; i < 256; i++)
+      delim_table[i] = '\0';
+
+   set_delimiter('\0');
+   set_delimiter('\n');
+   set_delimiter('\r');
+   set_delimiter('[');
+   set_delimiter(']');
+   set_delimiter('<');
+   set_delimiter('>');
+   set_delimiter('(');
+   set_delimiter(')');
+   set_delimiter('|');
+   set_delimiter('&');
+   set_delimiter('=');
+   set_delimiter('*');
+   set_delimiter('+');
+   set_delimiter('-');
+   set_delimiter('/');
+   set_delimiter('%');
+   set_delimiter('~');
+   set_delimiter('^');
+   set_delimiter('!');
+   set_delimiter(' ');
+
+   return 0;
+}
+
+ULONG ScreenInputFromKeyboard(BYTE *buf, ULONG buf_index, ULONG max_index)
+{
+    register ULONG key;
+    register BYTE *p;
+    register int i, r, temp;
+    register ULONG orig_index, HistoryIndex;
+    extern ULONG IsAccelerator(ULONG);
+
+    if (buf_index > max_index)
+       return 0;
+
+    if (!max_index)
+       return 0;
+
+    orig_index = buf_index;
+
+    p = (BYTE *)((ULONG)buf + (ULONG)buf_index);
+    for (i=0; i < (max_index - buf_index); i++)   
+       *p++ = '\0';
+
+    HistoryIndex = HistoryPointer;
+    while (1)
+    {
+       key = mdb_getkey();
+
+       if ((IsAccelerator(key)) && (key != 13))
+	  return key;
+
+       switch (key)
+       {
+	  case 8: // backspace
+	     if (buf_index)
+	     {
+                register int delta;
+
+		buf_index--;
+		DBGPrint("\b \b");
+
+//		if (!buf[buf_index + 1])
+//		   buf[buf_index] = '\0';
+//		else
+//		   buf[buf_index] = ' ';
+
+                delta = strlen(buf) - buf_index;
+
+                for (i=0; i < delta; i++)
+                  DBGPrint(" ");
+                         
+                for (i=0; i < delta; i++)
+                   DBGPrint("\b");
+
+	        p = (BYTE *) &buf[buf_index];
+	        temp = buf_index;
+	        p++;
+	        while ((*p) && (temp < max_index))
+		   buf[temp++] = *p++;
+	        buf[temp] = '\0';
+              
+                delta = strlen(buf) - buf_index;
+
+                for (i=0; (i < delta) && (buf[i]); i++)
+                  DBGPrint("%c", buf[buf_index + i]);
+                         
+                for (i=0; i < delta; i++)
+                   DBGPrint("\b");
+	     }
+	     break;
+
+	  case K_P7: // home
+             {
+                BYTE s[256];
+
+                for (i=0; (i < buf_index) && (i < 255); i++)
+                   s[i] = '\b';
+                s[i] = '\0';
+                DBGPrint("%s", s);
+
+	        buf_index = orig_index;
+             }
+	     break;
+
+	  case K_P1: // end
+             {
+                BYTE s[256];
+
+                for (i=0; (i < buf_index) && (i < 255); i++)
+                   s[i] = '\b';
+                s[i] = '\0';
+                DBGPrint("%s", s);
+
+                for (i=0; (i < strlen(buf)) && (i < 255); i++)
+                   DBGPrint("%c", buf[i]);
+
+	        buf_index = strlen(buf);
+
+             }
+	     break;
+
+	  case K_P4: // left arrow
+	     if (buf_index)
+	     {
+		buf_index--;
+		DBGPrint("\b");
+	     }
+	     break;
+
+	  case K_P6: // right arrow
+	     if (buf_index < strlen(buf))
+	     {
+                DBGPrint("%c", buf[buf_index]);
+		buf_index++;
+	     }
+	     break;
+
+	  case K_PDOT:
+             {
+                register int delta;
+
+                delta = strlen(buf) - buf_index;
+
+                for (i=0; i < delta; i++)
+                  DBGPrint(" ");
+                         
+                for (i=0; i < delta; i++)
+                   DBGPrint("\b");
+
+	        p = (BYTE *) &buf[buf_index];
+	        temp = buf_index;
+	        p++;
+	        while ((*p) && (temp < max_index))
+		   buf[temp++] = *p++;
+	        buf[temp] = '\0';
+              
+                delta = strlen(buf) - buf_index;
+
+                for (i=0; (i < delta) && (buf[i]); i++)
+                  DBGPrint("%c", buf[buf_index + i]);
+                         
+                for (i=0; i < delta; i++)
+                   DBGPrint("\b");
+             }
+	     break;
+
+	  case 13:  // enter
+	     if (strncmp(HistoryBuffer[(HistoryPointer - 1) & 0xF], buf, 
+                         strlen(buf)) || (strlen(buf) != 
+                         strlen(HistoryBuffer[(HistoryPointer - 1) & 0xF])))
+	     {
+		for (r=0; r < max_index; r++)
+		{
+		   if (buf[0])
+		      HistoryBuffer[HistoryPointer & 0xF][r] = buf[r];
+		}
+		if (buf[0])
+		   HistoryPointer++;
+	     }
+	     return 13;
+
+	  case K_P8: // up arrow
+	     if (HistoryBuffer[(HistoryIndex - 1) & 0xF][0])
+	     {
+                BYTE s[256];
+
+                for (i=0; (i < buf_index) && (i < 255); i++)
+                   s[i] = '\b';
+                s[i] = '\0';
+                DBGPrint("%s", s);
+
+                for (i=0; (i < strlen(buf)) && (i < 255); i++)
+                   s[i] = ' ';
+                s[i] = '\0';
+                DBGPrint("%s", s);
+
+                for (i=0; (i < strlen(buf)) && (i < 255); i++)
+                   s[i] = '\b';
+                s[i] = '\0';
+                DBGPrint("%s", s);
+
+		HistoryIndex--;
+
+		for (r=0; r < max_index; r++)
+		   buf[r] = HistoryBuffer[HistoryIndex & 0xF][r];
+		buf_index = strlen(buf);
+
+                DBGPrint("%s", buf);
+	     }
+	     break;
+
+	  case K_P2: // down arrow
+	     if (HistoryBuffer[HistoryIndex & 0xF][0])
+	     {
+                BYTE s[256];
+
+                for (i=0; (i < buf_index) && (i < 255); i++)
+                   s[i] = '\b';
+                s[i] = '\0';
+                DBGPrint("%s", s);
+
+                for (i=0; (i < strlen(buf)) && (i < 255); i++)
+                   s[i] = ' ';
+                s[i] = '\0';
+                DBGPrint("%s", s);
+
+                for (i=0; (i < strlen(buf)) && (i < 255); i++)
+                   s[i] = '\b';
+                s[i] = '\0';
+                DBGPrint("%s", s);
+
+		HistoryIndex++;
+
+		for (r=0; r < max_index; r++)
+		   buf[r] = HistoryBuffer[HistoryIndex & 0xF][r];
+		buf_index = strlen(buf);
+
+                DBGPrint("%s", buf);
+	     }
+	     break;
+
+	  default:
+	     if ((key > 0x7E) || (key < ' '))  // if above or below text
+		break;
+	     else
+	     {
+	        if (strlen(buf) < max_index)
+		{
+                   register int delta;
+
+		   for (i=max_index; i > buf_index; i--)
+		      buf[i] = buf[i-1];
+		   buf[buf_index] = (BYTE)key;
+		   if (buf_index < max_index)
+		      buf_index++;
+
+                   delta = strlen(buf) - buf_index;
+
+                   for (i=0; (i < delta) && (buf[i]); i++)
+                        DBGPrint("%c", buf[buf_index + i]);
+                         
+                   for (i=0; i < delta; i++)
+                        DBGPrint("\b");
+		}
+             }
+	     break;
+       }
+    }
+}
+
+ULONG debugger_command_entry(ULONG processor, ULONG Exception,
+			    StackFrame *stackFrame)
+{
+    BYTE verbBuffer[100];
+    register BYTE *verb, *pp, *vp;
+    register ULONG count, retCode, key;
+    extern ULONG reason_toggle;
+    extern void displayRegisters(StackFrame *, ULONG);
+
+    if (Exception > 22)
+       Exception = 20;
+
+    lastUnasmAddress = (ULONG) GetIP(stackFrame);
+    lastLinkAddress = lastDumpAddress = (BYTE *) GetStackAddress(stackFrame);
+    lastDisplayLength = displayLength = 20;
+    lastCommandEntry = lastCommand;
+
+    if (reason_toggle)
+    {
+       if (!ConsoleDisplayBreakReason(stackFrame, Exception, processor, 
+                                      lastCommand))
+          return 0; 
+    }
+    displayRegisters(stackFrame, processor);
+    nextUnasmAddress = disassemble(stackFrame, lastUnasmAddress, 1, 1);
+    ClearTempBreakpoints();
+
+    while (1)
+    {
+       extern int nextline;
+
+       nextline = 0;
+
+       DBGPrint("(%i)> ", (int)processor);
+
+       SaveLastCommandInfo(processor);
+
+       key = ScreenInputFromKeyboard((BYTE *)&debugCommand[0], 0, 80);
+       if (key)
+       {
+          extern ULONG AccelRoutine(ULONG key, void *p);
+
+          retCode = AccelRoutine(key, stackFrame);
+          switch (retCode)
+          {
+             case 0:
+                break;  
+
+             case -1: 
+   	        return retCode;
+
+             default:
+                DBGPrint("\n");
+                continue;
+          }
+       }
+
+       if (*debugCommand)
+       {
+          count = 0;
+          pp = (BYTE *)debugCommand;
+          vp = verb = &verbBuffer[0];
+          while (*pp && *pp == ' ' && count++ < 80)
+    	     pp++;
+
+          while (*pp && *pp != ' ' && *pp != '=' && count++ < 80)
+  	     *vp++ = *pp++;
+          *vp = '\0';
+
+          while (*pp && *pp == ' ' && count++ < 80)
+  	     pp++;
+
+          retCode = DebuggerParserRoutine(verb, (BYTE *)debugCommand, 
+                                          stackFrame, Exception);
+          switch (retCode)
+          {
+             case -1: 
+  	       return retCode;
+          }
+       }
+    }
+}
+
+#endif
diff -Naur ./debug/mdb.h ../linux-2.6.18-mdb/./debug/mdb.h
--- ./debug/mdb.h	1969-12-31 17:00:00.000000000 -0700
+++ ../linux-2.6.18-mdb/./debug/mdb.h	2008-08-02 13:27:25.000000000 -0600
@@ -0,0 +1,104 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 3.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.  
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   FILE     :  MDB.H
+*   DESCRIP  :  Merkey's NetWare Debugger
+*   DATE     :  April 8, 2008
+*
+***************************************************************************/
+
+#ifndef _MDB_H
+#define _MDB_H
+
+extern int mdb_printf(char *s, ...);
+#define DBGPrint   mdb_printf
+
+#define  TRUE               1
+#define  FALSE              0
+
+#ifndef LONGLONG
+typedef long long LONGLONG;
+#endif
+typedef unsigned long  ULONG;
+typedef unsigned short WORD;
+typedef unsigned char  BYTE;
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+//#include <linux/pc_keyb.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_SMP
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+#endif
+
diff -Naur ./drivers/char/keyboard.c ../linux-2.6.18-mdb/./drivers/char/keyboard.c
--- ./drivers/char/keyboard.c	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./drivers/char/keyboard.c	2008-08-02 12:14:12.000000000 -0600
@@ -1162,6 +1162,16 @@
 			if (keycode < BTN_MISC)
 				printk(KERN_WARNING "keyboard.c: can't emulate rawmode for keycode %d\n", keycode);
 
+#ifdef CONFIG_MDB
+	if (down && !rep && keycode == KEY_PAUSE) 
+        {
+           extern int mdb(int reason, int error, struct pt_regs *regs);
+
+	   mdb(19, 0, regs);
+	   return;
+	}
+#endif	
+
 #ifdef CONFIG_MAGIC_SYSRQ	       /* Handle the SysRq Hack */
 	if (keycode == KEY_SYSRQ && (sysrq_down || (down == 1 && sysrq_alt))) {
 		if (!sysrq_down) {
diff -Naur ./include/linux/console.h ../linux-2.6.18-mdb/./include/linux/console.h
--- ./include/linux/console.h	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./include/linux/console.h	2008-08-02 12:14:13.000000000 -0600
@@ -126,9 +126,15 @@
 
 /* Some debug stub to catch some of the obvious races in the VT code */
 #if 1
+#ifdef CONFIG_MDB
+extern atomic_t inmdb;
+#define WARN_CONSOLE_UNLOCKED()	WARN_ON(!is_console_locked() && !oops_in_progress && !atomic_read(&inmdb))
+#else
 #define WARN_CONSOLE_UNLOCKED()	WARN_ON(!is_console_locked() && !oops_in_progress)
+#endif // CONFIG_MDB
 #else
 #define WARN_CONSOLE_UNLOCKED()
+
 #endif
 
 /* VESA Blanking Levels */
diff -Naur ./init/main.c ../linux-2.6.18-mdb/./init/main.c
--- ./init/main.c	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./init/main.c	2008-08-02 12:14:13.000000000 -0600
@@ -557,6 +557,14 @@
 	pgtable_cache_init();
 	prio_tree_init();
 	anon_vma_init();
+
+#ifdef CONFIG_MDB
+        {
+           extern int mdb_init(void);
+	   mdb_init();
+        }
+#endif
+
 #ifdef CONFIG_X86
 	if (efi_enabled)
 		efi_enter_virtual_mode();
diff -Naur ./kernel/kallsyms.c ../linux-2.6.18-mdb/./kernel/kallsyms.c
--- ./kernel/kallsyms.c	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./kernel/kallsyms.c	2008-08-02 12:14:13.000000000 -0600
@@ -418,4 +418,47 @@
 }
 __initcall(kallsyms_init);
 
+#ifdef CONFIG_MDB
+struct kallsym_iter mdb_iter;
+int mdb_kallsyms(char *str, int (*print)(char *s, ...))
+{
+    register loff_t pos = 0;
+    register struct kallsym_iter *iter = &mdb_iter;
+
+    if (!print)
+       return 0;
+
+    // set to beginning of the kallsyms list 
+    reset_iter(iter, 0);
+    while (1)
+    {
+       // search the kallsyms list
+       if (!update_iter(iter, pos++))
+          break;
+
+       if (!iter->name[0])
+ 	  continue;
+
+       // if an exclusion search was specified, skip non-matching entries
+       if (str && *str && !strstr(iter->name, str))
+          continue;
+
+       if (iter->owner)
+       {
+          if (print("%0*lx %c %s [%s]\n", (int)(2*sizeof(void*)),
+	      iter->value, iter->type, iter->name,
+	      module_name(iter->owner)))
+             return 1;
+       }
+       else
+       {
+          if (print("%0*lx %c %s\n", (int)(2*sizeof(void*)),
+   	      iter->value, iter->type, iter->name))
+             return 1;
+       }
+    }
+    return 0;
+}
+#endif
+
 EXPORT_SYMBOL(__print_symbol);
diff -Naur ./kernel/module.c ../linux-2.6.18-mdb/./kernel/module.c
--- ./kernel/module.c	2006-09-19 21:42:06.000000000 -0600
+++ ../linux-2.6.18-mdb/./kernel/module.c	2008-08-02 12:14:13.000000000 -0600
@@ -2024,22 +2024,70 @@
 {
 	struct module *mod;
 
-	mutex_lock(&module_mutex);
+#ifdef CONFIG_MDB           
+        extern atomic_t inmdb; 
+        if (!atomic_read(&inmdb))
+#endif
+   	mutex_lock(&module_mutex);
 	list_for_each_entry(mod, &modules, list) {
 		if (symnum < mod->num_symtab) {
 			*value = mod->symtab[symnum].st_value;
 			*type = mod->symtab[symnum].st_info;
 			strlcpy(name, mod->strtab + mod->symtab[symnum].st_name,
 				namelen);
+#ifdef CONFIG_MDB           
+                        if (!atomic_read(&inmdb))
+#endif
 			mutex_unlock(&module_mutex);
 			return mod;
 		}
 		symnum -= mod->num_symtab;
 	}
+#ifdef CONFIG_MDB           
+        if (!atomic_read(&inmdb))
+#endif
 	mutex_unlock(&module_mutex);
 	return NULL;
 }
 
+#ifdef CONFIG_MDB           
+int mdb_modules(char *str, int (*print)(char *s, ...))
+{
+	struct module *mod;
+	struct module_use *use;
+
+        if (!print)
+           return 0;
+
+	list_for_each_entry(mod, &modules, list) 
+        {
+           if (str && *str && !strstr(mod->name, str))
+              continue;
+
+	   print(" 0x%08p ", mod->module_core);
+	   print("%s", mod->name);
+	   print(" %lu %02u ", mod->init_size + mod->core_size,
+                 module_refcount(mod));
+	   list_for_each_entry(use, &mod->modules_which_use_me, list) 
+		print("%s,", use->module_which_uses->name);
+	   if (mod->unsafe) 
+		print("[unsafe],");
+  	   if (mod->init != NULL && mod->exit == NULL) 
+	      print("[permanent],");
+	   print(" %s ", mod->state == MODULE_STATE_GOING ? "Unloading":
+	                mod->state == MODULE_STATE_COMING ? "Loading":
+		        "Live");
+#if CONFIG_MODULE_SIG		
+	   if (!mod->gpgsig_ok)
+	      print("(U)");
+#endif		
+	   if (print("\n"))
+              return 1;
+	}
+        return 0;
+}
+#endif
+
 static unsigned long mod_find_symname(struct module *mod, const char *name)
 {
 	unsigned int i;
