diff -urN linux-2.6.18.1/arch/i386/kernel/entry.S linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/entry.S
--- linux-2.6.18.1/arch/i386/kernel/entry.S	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/entry.S	2006-11-09 22:41:13.000000000 -0600
@@ -318,7 +318,56 @@
 	jnz syscall_trace_entry
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
+
+#ifdef CONFIG_KTAU_SYSCALL 
+	/*
+	* Function   :  ktau_syscall_entry
+	* Description:	KTAU Instrumentation for syscall entry
+	* Input	     :	eax (stack pointer)
+        *		edx (address of system call)
+	*		ecx (system call number)
+	*/
+	/******** START KTAU **********/
+        pushl %ecx                      # save %ecx
+        pushl %edx                      # save %edx
+        pushl %eax                      # save %eax
+        movl %eax, %ecx			
+					# save syscall address from the table
+        movl sys_call_table(,%eax,4), %edx
+        movl %esp, %eax                 # pt_regs pointer 
+        call ktau_syscall_entry 
+        addl $4,%esp                    # return stack to state before pass
+        popl %edx                       # restore %edx 
+        popl %ecx                       # restore %ecx 
+        movl ORIG_EAX(%esp),%eax        # restore %eax
+	/*********** END KTAU **********/
+#endif /* CONFIG_KTAU */
+
 	call *sys_call_table(,%eax,4)
+
+#ifdef CONFIG_KTAU_SYSCALL
+	/*
+	* Function   :  ktau_syscall_exit
+	* Description:	KTAU Instrumentation for syscall exit
+	* Input	     :	eax (stack pointer)
+        *		edx (address of system call)
+	*		ecx (system call number)
+	*/
+	/******** START KTAU **********/
+        pushl %ecx                      # save %ecx
+        pushl %edx                      # save %edx
+        pushl %eax                      # save %eax
+        movl EFLAGS(%esp),%ecx          # get the call number from (ORIG_EAX+0xC)
+                                        # save syscall address from the table
+        movl sys_call_table(,%ecx,4), %edx
+        movl %esp, %eax                 # pt_regs pointer 
+        call ktau_syscall_exit 
+        popl %eax                       # store %eax
+        popl %edx                       # store %edx
+        popl %ecx                       # store %ecx
+	/*********** END KTAU **********/
+#endif /* CONFIG_KTAU */
+
 	movl %eax,EAX(%esp)
 	cli
 	TRACE_IRQS_OFF
@@ -353,7 +402,56 @@
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
 syscall_call:
+
+#ifdef CONFIG_KTAU_SYSCALL 
+	/*
+	* Function   :  ktau_syscall_entry
+	* Description:	KTAU Instrumentation for syscall entry
+	* Input	     :	eax (stack pointer)
+        *		edx (address of system call)
+	*		ecx (system call number)
+	*/
+	/******** START KTAU **********/
+        pushl %ecx                      # save %ecx
+        pushl %edx                      # save %edx
+        pushl %eax                      # save %eax
+        movl %eax, %ecx			
+					# save syscall address from the table
+        movl sys_call_table(,%eax,4), %edx
+        movl %esp, %eax                 # pt_regs pointer 
+        call ktau_syscall_entry 
+        addl $4,%esp                    # return stack to state before pass
+        popl %edx                       # restore %edx 
+        popl %ecx                       # restore %ecx 
+        movl ORIG_EAX(%esp),%eax        # restore %eax
+	/*********** END KTAU **********/
+#endif /* CONFIG_KTAU */
+
 	call *sys_call_table(,%eax,4)
+
+#ifdef CONFIG_KTAU_SYSCALL
+	/*
+	* Function   :  ktau_syscall_exit
+	* Description:	KTAU Instrumentation for syscall exit
+	* Input	     :	eax (stack pointer)
+        *		edx (address of system call)
+	*		ecx (system call number)
+	*/
+	/******** START KTAU **********/
+        pushl %ecx                      # save %ecx
+        pushl %edx                      # save %edx
+        pushl %eax                      # save %eax
+        movl EFLAGS(%esp),%ecx          # get the call number from (ORIG_EAX+0xC)
+                                        # save syscall address from the table
+        movl sys_call_table(,%ecx,4), %edx
+        movl %esp, %eax                 # pt_regs pointer 
+        call ktau_syscall_exit 
+        popl %eax                       # store %eax
+        popl %edx                       # store %edx
+        popl %ecx                       # store %ecx
+	/*********** END KTAU **********/
+#endif /* CONFIG_KTAU */
+
 	movl %eax,EAX(%esp)		# store the return value
 syscall_exit:
 	cli				# make sure we don't miss an interrupt
diff -urN linux-2.6.18.1/arch/i386/kernel/irq.c linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/irq.c
--- linux-2.6.18.1/arch/i386/kernel/irq.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/irq.c	2006-11-09 22:41:13.000000000 -0600
@@ -22,6 +22,10 @@
 DEFINE_PER_CPU(irq_cpustat_t, irq_stat) ____cacheline_internodealigned_in_smp;
 EXPORT_PER_CPU_SYMBOL(irq_stat);
 
+#ifdef CONFIG_KTAU_IRQ
+//#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_IRQ*/
+
 #ifndef CONFIG_X86_LOCAL_APIC
 /*
  * 'what should we do if we get a hw irq event on an illegal vector'.
@@ -66,6 +70,11 @@
 		BUG();
 	}
 
+#ifdef CONFIG_KTAU_IRQ
+	//GET_KTAU_INDEX();
+	//if(current->pid) ktau_start_timer((unsigned int) &do_IRQ);
+#endif /*CONFIG_KTAU_IRQ*/
+
 	irq_enter();
 #ifdef CONFIG_DEBUG_STACKOVERFLOW
 	/* Debugging check for stack overflow: is there less than 1KB free? */
@@ -122,6 +131,9 @@
 		__do_IRQ(irq, regs);
 
 	irq_exit();
+#ifdef CONFIG_KTAU_IRQ
+	//if(current->pid) ktau_stop_timer((unsigned int) &do_IRQ);
+#endif /*CONFIG_KTAU_IRQ*/
 
 	return 1;
 }
diff -urN linux-2.6.18.1/arch/i386/kernel/setup.c linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/setup.c
--- linux-2.6.18.1/arch/i386/kernel/setup.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/setup.c	2006-11-09 22:41:13.000000000 -0600
@@ -151,6 +151,11 @@
 extern void generic_apic_probe(char *);
 extern int root_mountflags;
 
+#ifdef CONFIG_KTAU_BOOTOPT
+extern void ktau_bootopt_parse(char *);
+#endif /*CONFIG_KTAU_BOOTOPT*/
+
+
 unsigned long saved_videomode;
 
 #define RAMDISK_IMAGE_START_MASK  	0x07FF
@@ -1580,6 +1585,10 @@
 #endif
 #endif
 	tsc_init();
+
+#ifdef CONFIG_KTAU_BOOTOPT
+	ktau_bootopt_parse(*cmdline_p);
+#endif /* CONFIG_KTAU_BOOTOPT */
 }
 
 static __init int add_pcspkr(void)
diff -urN linux-2.6.18.1/arch/i386/kernel/signal.c linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/signal.c
--- linux-2.6.18.1/arch/i386/kernel/signal.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/signal.c	2006-11-09 22:41:13.000000000 -0600
@@ -27,6 +27,11 @@
 #include <asm/i387.h>
 #include "sigframe.h"
 
+#ifdef CONFIG_KTAU_SYSCALL
+#include <linux/ktau/ktau_inst.h>
+#include <linux/ktau/ktau_bootopt.h>
+#endif /*CONFIG_KTAU_SYSCALL*/
+
 #define DEBUG_SIG 0
 
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
@@ -193,7 +198,16 @@
 	current->blocked = set;
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
-	
+
+#ifdef CONFIG_KTAU_SYSCALL
+        /* 
+         * We put the stop here to intercept the control before the
+         * registers are being restored. 
+         * Note that we are hardcoding the call number for sys_sigreturn here.
+         */
+	ktau_stop_prof(119,(unsigned int)&sys_sigreturn,KTAU_SYSCALL_MSK);
+#endif /*CONFIG_KTAU_SYSCALL*/
+
 	if (restore_sigcontext(regs, &frame->sc, &eax))
 		goto badframe;
 	return eax;
@@ -220,6 +234,15 @@
 	current->blocked = set;
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
+
+#ifdef CONFIG_KTAU_SYSCALL
+        /* 
+         * We put the stop here to intercept the control before the
+         * registers are being restored. 
+         * Note that we are hardcoding the call number for sys_sigreturn here.
+         */
+	ktau_stop_prof(173,(unsigned int)&sys_rt_sigreturn,KTAU_SYSCALL_MSK);
+#endif /*CONFIG_KTAU_SYSCALL*/
 	
 	if (restore_sigcontext(regs, &frame->uc.uc_mcontext, &eax))
 		goto badframe;
diff -urN linux-2.6.18.1/arch/i386/kernel/syscall_table.S linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/syscall_table.S
--- linux-2.6.18.1/arch/i386/kernel/syscall_table.S	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/syscall_table.S	2006-11-09 22:41:13.000000000 -0600
@@ -317,3 +317,6 @@
 	.long sys_tee			/* 315 */
 	.long sys_vmsplice
 	.long sys_move_pages
+#ifdef CONFIG_KTAU_MERGE
+ 	.long sys_ktau_gettimeofday	/* 318 */
+#endif /*CONFIG_KTAU_MERGE*/
diff -urN linux-2.6.18.1/arch/i386/kernel/traps.c linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/traps.c
--- linux-2.6.18.1/arch/i386/kernel/traps.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/traps.c	2006-11-09 22:41:13.000000000 -0600
@@ -56,6 +56,30 @@
 
 #include "mach_traps.h"
 
+#ifdef CONFIG_KTAU
+#include <linux/ktau/ktau_inst.h>
+#include <linux/ktau/ktau_hash.h>
+#define TAU_NAME "traps.h"
+#include <linux/ktau/ktau_print.h>
+
+#define DELAY_LOOP_TIMES 1000000
+#define KTAU_DELAY_ME() (delay_loop(DELAY_LOOP_TIMES))
+
+void delay_loop(unsigned long long times) {
+	volatile vtimes = times;
+	volatile unsigned long long j = 59;
+	volatile unsigned long long k = 43;
+	
+	while(vtimes) {
+		j *= k;
+		k = k >> 4;
+		vtimes--;
+	}
+}
+#endif /* CONFIG_KTAU */
+
+
+
 asmlinkage int system_call(void);
 
 struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
@@ -369,6 +393,81 @@
 	printk(KERN_EMERG "Kernel BUG at [verbose debug info unavailable]\n");
 }
 
+#ifdef CONFIG_KTAU_SYSCALL 
+fastcall void ktau_syscall_entry(struct pt_regs *regs
+                                       , unsigned long addr
+                                       , unsigned long callno)
+{
+	
+		if(current->pid){
+		       /* 
+			* Call KTAU start:
+			*      We must make sure that the start of 
+			*      system call must be level 0 
+			*/
+#if 0
+		       if(current->ktau->cur_level != 0 || current->ktau->last_level !=0){
+			       printk(KERN_INFO "traps.c -- ERROR_START_SYSCALL: pid:%d\n\
+				       ------ addr:%lx cur:%u last:%u\n\
+				       ------ prev_start = %lx prev_stop = %lx\n",
+				       current->pid,
+				       addr,
+				       (unsigned int) current->ktau->cur_level,
+				       (unsigned int) current->ktau->last_level,
+				       (unsigned long)current->ktau->prev_start,
+				       (unsigned long)current->ktau->prev_stop);
+			       current->ktau->cur_level = 0; 
+			       current->ktau->last_level = 0;
+		       }
+#endif
+		       ktau_start_prof(callno,addr,KTAU_SYSCALL_MSK);
+		}
+}
+
+
+fastcall void ktau_syscall_exit(struct pt_regs *regs
+                                       , unsigned long addr
+                                       , unsigned long callno)
+{
+		if(current->pid){
+			/* 
+			* Call KTAU stop:
+			*      We must make sure that the stop of 
+			*      system call must be level 0 
+			*/
+			if(callno != 0xffffffff){
+			       ktau_stop_prof(callno,addr,KTAU_SYSCALL_MSK);
+#if 0
+			       if(current->ktau->cur_level != 0 || current->ktau->last_level !=0){
+				       printk(KERN_INFO "traps.c -- ERROR_STOP_SYSCALL: pid:%d addr:%lx callno:%lu cur:%u last:%u\n",
+					       current->pid,
+					       addr,
+					       callno,
+					       (unsigned int) current->ktau->cur_level,
+					       (unsigned int) current->ktau->last_level);
+				       
+			       }
+#endif
+			}else{
+			       /* This is the case when sys_sigreturn() is called.
+				* Syscall handler modified the ORIG_EAX to be -1
+				*/
+			       info("Warning: pid:%d has callno is -1, current->ktau->stackDepth = %u",current->pid,current->ktau->stackDepth);
+			       //current->ktau->cur_level = 0; 
+			       //current->ktau->last_level = 0;
+			       current->ktau->stackDepth = 0;
+
+			}
+			/* Check to see if the stackDepth is 0 when leaving the system call */
+			if(current->ktau->stackDepth != 0){
+				info("Warning: ktau_syscall_exit: stackDepth is not zero.\n\
+						stackDepth = %u, address = %x, callno =%lu",
+						current->ktau->stackDepth, addr, callno);
+			}
+		}
+}
+#endif /*CONFIG_KTAU_SYSCALL*/
+
 /* This is gone through when something in the kernel
  * has done something bad and is about to be terminated.
 */
@@ -507,50 +606,74 @@
 	}
 }
 
+#ifdef CONFIG_KTAU_EXCEPTION
+#define ktau_start_exception(index,fnc_addr)    ktau_start_prof(KTAU_EXCEPTION_BASE+index,(unsigned int)fnc_addr,KTAU_EXCEPTION_MSK)
+#define ktau_stop_exception(index,fnc_addr)     ktau_stop_prof(KTAU_EXCEPTION_BASE+index,(unsigned int)fnc_addr,KTAU_EXCEPTION_MSK)
+#else /*CONFIG_KTAU_EXCEPTION*/
+#define ktau_start_exception(index,fnc_addr)
+#define ktau_stop_exception(index,fnc_addr)
+#endif /*CONFIG_KTAU_EXCEPTION*/
+
 #define DO_ERROR(trapnr, signr, str, name) \
 fastcall void do_##name(struct pt_regs * regs, long error_code) \
 { \
+	ktau_start_exception(trapnr , &do_##name); \
 	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) \
-						== NOTIFY_STOP) \
+						== NOTIFY_STOP) { \
+		ktau_stop_exception(trapnr , &do_##name); \
 		return; \
+	} \
 	do_trap(trapnr, signr, str, 0, regs, error_code, NULL); \
+	ktau_stop_exception(trapnr , &do_##name); \
 }
 
 #define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) \
 fastcall void do_##name(struct pt_regs * regs, long error_code) \
 { \
 	siginfo_t info; \
+	ktau_start_exception(trapnr , &do_##name);\
 	info.si_signo = signr; \
 	info.si_errno = 0; \
 	info.si_code = sicode; \
 	info.si_addr = (void __user *)siaddr; \
 	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) \
-						== NOTIFY_STOP) \
+						== NOTIFY_STOP) { \
+		ktau_stop_exception(trapnr , &do_##name); \
 		return; \
+	} \
 	do_trap(trapnr, signr, str, 0, regs, error_code, &info); \
+	ktau_stop_exception(trapnr , &do_##name);\
 }
 
 #define DO_VM86_ERROR(trapnr, signr, str, name) \
 fastcall void do_##name(struct pt_regs * regs, long error_code) \
 { \
+	ktau_start_exception(trapnr , &do_##name);\
 	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) \
-						== NOTIFY_STOP) \
+						== NOTIFY_STOP) { \
+		ktau_stop_exception(trapnr , &do_##name); \
 		return; \
+	} \
 	do_trap(trapnr, signr, str, 1, regs, error_code, NULL); \
+	ktau_stop_exception(trapnr , &do_##name);\
 }
 
 #define DO_VM86_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) \
 fastcall void do_##name(struct pt_regs * regs, long error_code) \
 { \
 	siginfo_t info; \
+	ktau_start_exception(trapnr , &do_##name);\
 	info.si_signo = signr; \
 	info.si_errno = 0; \
 	info.si_code = sicode; \
 	info.si_addr = (void __user *)siaddr; \
 	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) \
-						== NOTIFY_STOP) \
+						== NOTIFY_STOP) { \
+		ktau_stop_exception(trapnr , &do_##name);\
 		return; \
+	} \
 	do_trap(trapnr, signr, str, 1, regs, error_code, &info); \
+	ktau_stop_exception(trapnr , &do_##name);\
 }
 
 DO_VM86_ERROR_INFO( 0, SIGFPE,  "divide error", divide_error, FPE_INTDIV, regs->eip)
@@ -761,8 +884,9 @@
 
 	++nmi_count(cpu);
 
-	if (!rcu_dereference(nmi_callback)(regs, cpu))
+	if (!rcu_dereference(nmi_callback)(regs, cpu)){
 		default_do_nmi(regs);
+	}
 
 	nmi_exit();
 }
diff -urN linux-2.6.18.1/arch/i386/kernel/vm86.c linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/vm86.c
--- linux-2.6.18.1/arch/i386/kernel/vm86.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/kernel/vm86.c	2006-11-09 22:41:13.000000000 -0600
@@ -49,6 +49,12 @@
 #include <asm/tlbflush.h>
 #include <asm/irq.h>
 
+#ifdef CONFIG_KTAU_SYSCALL
+#include <linux/ktau/ktau_inst.h>
+#include <linux/ktau/ktau_bootopt.h>
+#include <asm/unistd.h>
+#endif /*CONFIG_KTAU_SYSCALL*/
+
 /*
  * Known problems:
  *
@@ -192,6 +198,13 @@
 	memset(&info.vm86plus, 0, (int)&info.regs32 - (int)&info.vm86plus);
 	info.regs32 = &regs;
 	tsk->thread.vm86_info = v86;
+#ifdef CONFIG_KTAU_SYSCALL
+        /* 
+         * We put the stop here to intercept the control before the
+         * registers are being restored. 
+         */
+	ktau_stop_prof(__NR_vm86old,(unsigned int)&sys_vm86old,KTAU_SYSCALL_MSK);
+#endif /*CONFIG_KTAU_SYSCALL*/
 	do_sys_vm86(&info, tsk);
 	ret = 0;	/* we never return here */
 out:
@@ -242,6 +255,13 @@
 	info.regs32 = &regs;
 	info.vm86plus.is_vm86pus = 1;
 	tsk->thread.vm86_info = (struct vm86_struct __user *)v86;
+#ifdef CONFIG_KTAU_SYSCALL
+        /* 
+         * We put the stop here to intercept the control before the
+         * registers are being restored. 
+         */
+	ktau_stop_prof(__NR_vm86,(unsigned int)&sys_vm86,KTAU_SYSCALL_MSK);
+#endif /*CONFIG_KTAU_SYSCALL*/
 	do_sys_vm86(&info, tsk);
 	ret = 0;	/* we never return here */
 out:
diff -urN linux-2.6.18.1/arch/i386/mm/fault.c linux-2.6.18.1-ktau-1.7.7_all/arch/i386/mm/fault.c
--- linux-2.6.18.1/arch/i386/mm/fault.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/mm/fault.c	2006-11-09 22:41:13.000000000 -0600
@@ -28,6 +28,10 @@
 #include <asm/desc.h>
 #include <asm/kdebug.h>
 
+#ifdef CONFIG_KTAU_EXCEPTION
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_EXCEPTION*/
+
 extern void die(const char *,struct pt_regs *,long);
 
 #ifdef CONFIG_KPROBES
@@ -335,6 +339,12 @@
 	unsigned long page;
 	int write, si_code;
 
+#ifdef CONFIG_KTAU_EXCEPTION
+        //KTAU may be using vmalloc. So only instrument
+        //user-mode faults (i.e: (error_code&4) != 0)
+        if((current->pid) && (error_code&4)) ktau_start_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
+
 	/* get the address */
         address = read_cr2();
 
@@ -356,11 +366,19 @@
 	 * protection error (error_code & 9) == 0.
 	 */
 	if (unlikely(address >= TASK_SIZE)) {
-		if (!(error_code & 0x0000000d) && vmalloc_fault(address) >= 0)
+		if (!(error_code & 0x0000000d) && vmalloc_fault(address) >= 0) {
+#ifdef CONFIG_KTAU_EXCEPTION
+			if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 			return;
+		}
 		if (notify_page_fault(DIE_PAGE_FAULT, "page fault", regs, error_code, 14,
-						SIGSEGV) == NOTIFY_STOP)
+						SIGSEGV) == NOTIFY_STOP) {
+#ifdef CONFIG_KTAU_EXCEPTION
+			if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 			return;
+		}
 		/*
 		 * Don't take the mm semaphore here. If we fixup a prefetch
 		 * fault we could otherwise deadlock.
@@ -369,8 +387,12 @@
 	}
 
 	if (notify_page_fault(DIE_PAGE_FAULT, "page fault", regs, error_code, 14,
-					SIGSEGV) == NOTIFY_STOP)
+					SIGSEGV) == NOTIFY_STOP) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		return;
+	}
 
 	/* It's safe to allow irq's after cr2 has been saved and the vmalloc
 	   fault has been handled. */
@@ -483,6 +505,9 @@
 			tsk->thread.screen_bitmap |= 1 << bit;
 	}
 	up_read(&mm->mmap_sem);
+#ifdef CONFIG_KTAU_EXCEPTION
+	if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 	return;
 
 /*
@@ -499,14 +524,21 @@
 		 * Valid to do another page fault here because this one came 
 		 * from user space.
 		 */
-		if (is_prefetch(regs, address, error_code))
+		if (is_prefetch(regs, address, error_code)) {
+#ifdef CONFIG_KTAU_EXCEPTION
+			if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 			return;
+		}
 
 		tsk->thread.cr2 = address;
 		/* Kernel addresses are always protection faults */
 		tsk->thread.error_code = error_code | (address >= TASK_SIZE);
 		tsk->thread.trap_no = 14;
 		force_sig_info_fault(SIGSEGV, si_code, address, tsk);
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		return;
 	}
 
@@ -521,6 +553,9 @@
 
 		if (nr == 6) {
 			do_invalid_op(regs, 0);
+#ifdef CONFIG_KTAU_EXCEPTION
+			if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 			return;
 		}
 	}
@@ -528,16 +563,24 @@
 
 no_context:
 	/* Are we prepared to handle this kernel fault?  */
-	if (fixup_exception(regs))
+	if (fixup_exception(regs)) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		return;
+	}
 
 	/* 
 	 * Valid to do another page fault here, because if this fault
 	 * had been triggered by is_prefetch fixup_exception would have 
 	 * handled it.
 	 */
- 	if (is_prefetch(regs, address, error_code))
+ 	if (is_prefetch(regs, address, error_code)) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
  		return;
+	}
 
 /*
  * Oops. The kernel tried to access some bad page. We'll have to
@@ -590,6 +633,9 @@
 	tsk->thread.error_code = error_code;
 	die("Oops", regs, error_code);
 	bust_spinlocks(0);
+#ifdef CONFIG_KTAU_EXCEPTION
+	if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 	do_exit(SIGKILL);
 
 /*
@@ -604,8 +650,12 @@
 		goto survive;
 	}
 	printk("VM: killing process %s\n", tsk->comm);
-	if (error_code & 4)
+	if (error_code & 4) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		do_exit(SIGKILL);
+	}
 	goto no_context;
 
 do_sigbus:
@@ -616,13 +666,20 @@
 		goto no_context;
 
 	/* User space => ok to do another page fault */
-	if (is_prefetch(regs, address, error_code))
+	if (is_prefetch(regs, address, error_code)) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		return;
+	}
 
 	tsk->thread.cr2 = address;
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_no = 14;
 	force_sig_info_fault(SIGBUS, BUS_ADRERR, address, tsk);
+#ifdef CONFIG_KTAU_EXCEPTION
+	if((current->pid) && (error_code&4)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 }
 
 #ifndef CONFIG_X86_PAE
diff -urN linux-2.6.18.1/arch/i386/oprofile/Kconfig linux-2.6.18.1-ktau-1.7.7_all/arch/i386/oprofile/Kconfig
--- linux-2.6.18.1/arch/i386/oprofile/Kconfig	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/i386/oprofile/Kconfig	2006-11-09 22:41:13.000000000 -0600
@@ -15,3 +15,149 @@
 
 	  If unsure, say N.
 
+config KTAU
+	bool "KTAU Profiling/Tracing (EXPERIMENTAL)"
+	depends on PROFILING
+	help
+	  KTAU is a Kernel Tuning Analysis Utilities providing 
+	  context-based (process/thread) profiling/tracing of the system.
+	  
+	  If unsure, say N.
+
+config KTAU_DEBUG
+	bool "Extra Debug Msgs and Checks within KTAU"
+	depends on KTAU
+	help
+	  Enable debug checks and messages within KTAU.
+	  
+	  If unsure, say N.
+
+config KTAU_PROFILE
+	bool "KTAU Profiling" 
+	depends on KTAU
+	help
+	  Enable KTAU Profile collection.
+
+	  If unsure, say N.
+
+config KTAU_MERGE
+	bool "Merging KTAU Profile with TAU"
+	depends on KTAU_PROFILE
+	help
+	  Enable kernel-space and user-space profile merging using mmap.
+	  
+	  If unsure, say N.
+
+config KTAU_TRACE
+	bool "KTAU Tracing" 
+	depends on KTAU
+	help
+	  Enable KTAU tracing using circular buffer.
+
+	  If unsure, say N.
+
+config KTAU_TRACE_MAX_IN_K
+	int "Maximum number of KTAU trace entries (in K)"
+	default "5"
+	depends on KTAU_TRACE
+	help
+	  Please specify the size of the circular buffer used in KTAU tracing
+	
+	  If unsure, say N.
+
+config KTAU_BOOTOPT
+	bool "KTAU Kernel Boot Option"
+	depends on KTAU
+	help
+	  This option allows KTAU instrumentations to be enabled/disabled
+	  using the linux kernel boot options. Note that each instrumentation
+	  must be enabled in the kenel configuration phase. 
+	  
+	  Available options are:
+	  	- ktau_syscall
+		- ktau_irq
+		- ktau_bh
+		- ktau_sched
+		- ktau_exception
+		- ktau_signal
+		- ktau_tcp
+		- ktau_socket
+		- ktau_icmp
+		
+	  If unsure, say N.
+
+config KTAU_SYSCALL
+	bool "KTAU System Calls Instrumentation" 
+	depends on KTAU 
+	help
+	  Enable KTAU system calls instrumentation
+	  
+	  If unsure, say N.
+
+config KTAU_IRQ
+	bool "KTAU Interrupt Instrumentation" 
+	depends on KTAU
+	help
+	  Enable KTAU interrupt instrumentation
+	  
+	  If unsure, say N.
+
+config KTAU_BH
+	bool "KTAU Bottom Halves Instrumentation" 
+	depends on KTAU
+	help
+	  Enable KTAU bottom havles instrumentation including
+	  	- Softirq
+		- Tasklet
+		- Timer Interrupt
+		- Work Queue
+	  
+	  If unsure, say N.
+
+config KTAU_EXCEPTION
+        bool "KTAU Exception Instrumentation" 
+        depends on KTAU
+        help
+          Enable KTAU exception instrumentation
+
+          If unsure, say N.
+
+config KTAU_SIGNAL
+        bool "KTAU Signal Instrumentation" 
+        depends on KTAU
+        help
+          Enable KTAU signal instrumentation
+
+          If unsure, say N.
+
+config KTAU_SCHED
+	bool "KTAU Scheduling Instrumentation" 
+	depends on KTAU
+	help
+	  Enable KTAU scheduling instrumentation
+	  
+	  If unsure, say N.
+
+config KTAU_SOCKET
+	bool "KTAU Socket Instrumentation" 
+	depends on KTAU 
+	help
+	  Enable KTAU network socket instrumentation
+	  
+	  If unsure, say N.
+
+config KTAU_TCP
+	bool "KTAU TCP Instrumentation" 
+	depends on KTAU
+	help
+	  Enable KTAU  TCP protocol instrumentation
+	  
+	  If unsure, say N.
+
+config KTAU_ICMP
+	bool "KTAU  ICMP Instrumentation" 
+	depends on KTAU
+	help
+	  Enable KTAU ICMP protocol instrumentation
+	  
+	  If unsure, say N.
diff -urN linux-2.6.18.1/arch/x86_64/kernel/entry.S linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/kernel/entry.S
--- linux-2.6.18.1/arch/x86_64/kernel/entry.S	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/kernel/entry.S	2006-11-09 22:42:30.000000000 -0600
@@ -220,6 +220,9 @@
 	jnz tracesys
 	cmpq $__NR_syscall_max,%rax
 	ja badsys
+#ifdef CONFIG_KTAU_SYSCALL
+	jmp ktautracesys
+#endif /* CONFIG_KTAU_SYSCALL */
 	movq %r10,%rcx
 	call *sys_call_table(,%rax,8)  # XXX:	 rip relative
 	movq %rax,RAX-ARGOFFSET(%rsp)
@@ -307,6 +310,29 @@
 1:	movq %rax,RAX-ARGOFFSET(%rsp)
 	/* Use IRET because user could have changed frame */
 	jmp int_ret_from_sys_call
+
+#ifdef CONFIG_KTAU_SYSCALL
+        /* Do ktau syscall tracing */
+ktautracesys:
+        SAVE_REST
+        movq $-ENOSYS,RAX(%rsp)
+        FIXUP_TOP_OF_STACK %rdi
+        movq %rsp,%rdi
+        call ktau_syscall_enter
+        LOAD_ARGS ARGOFFSET  /* reload args from stack in case ptrace changed it */
+        RESTORE_REST
+        cmpq $__NR_syscall_max,%rax
+        ja  1f
+        movq %r10,%rcx  /* fixup for C */
+        call *sys_call_table(,%rax,8)
+        movq %rax,RAX-ARGOFFSET(%rsp)
+1:      SAVE_REST
+        movq %rsp,%rdi
+        call ktau_syscall_exit
+        RESTORE_TOP_OF_STACK %rbx
+        RESTORE_REST
+        jmp ret_from_sys_call
+#endif /* CONFIG_KTAU_SYSCALL */
 	CFI_ENDPROC
 END(system_call)
 		
@@ -449,6 +475,7 @@
 	RESTORE_TOP_OF_STACK %r11
 	movq %rax,RAX(%rsp)
 	RESTORE_REST
+        call ktau_syscall_exit
 	jmp int_ret_from_sys_call
 	CFI_ENDPROC
 END(stub_execve)
diff -urN linux-2.6.18.1/arch/x86_64/kernel/setup.c linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/kernel/setup.c
--- linux-2.6.18.1/arch/x86_64/kernel/setup.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/kernel/setup.c	2006-11-09 22:42:30.000000000 -0600
@@ -65,6 +65,10 @@
 #include <asm/sections.h>
 #include <asm/dmi.h>
 
+#ifdef CONFIG_KTAU_BOOTOPT
+extern void ktau_bootopt_parse(char *);
+#endif /*CONFIG_KTAU_BOOTOPT*/
+
 /*
  * Machine setup..
  */
@@ -708,6 +712,10 @@
 	conswitchp = &dummy_con;
 #endif
 #endif
+
+#ifdef CONFIG_KTAU_BOOTOPT
+	ktau_bootopt_parse(*cmdline_p);
+#endif /* CONFIG_KTAU_BOOTOPT */
 }
 
 static int __cpuinit get_model_name(struct cpuinfo_x86 *c)
diff -urN linux-2.6.18.1/arch/x86_64/kernel/signal.c linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/kernel/signal.c
--- linux-2.6.18.1/arch/x86_64/kernel/signal.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/kernel/signal.c	2006-11-09 22:42:30.000000000 -0600
@@ -28,6 +28,14 @@
 #include <asm/proto.h>
 #include <asm/ia32_unistd.h>
 
+#ifdef CONFIG_KTAU_SYSCALL
+#include <linux/ktau/ktau_inst.h>
+#include <linux/ktau/ktau_bootopt.h>
+void __ktau_syscall_enter(unsigned long callno);
+void __ktau_syscall_exit(unsigned long callno);
+void ktau_syscall_exit();
+#endif /*CONFIG_KTAU_SYSCALL*/
+
 /* #define DEBUG_SIG 1 */
 
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
@@ -177,11 +185,29 @@
 
 	if (do_sigaltstack(&frame->uc.uc_stack, NULL, regs->rsp) == -EFAULT)
 		goto badframe;
+#ifdef CONFIG_KTAU_SYSCALL
+        /* 
+         * We put the stop here to intercept the control before the
+         * registers are being restored. 
+         * Note that we are hardcoding the call number for sys_sigreturn here. - Not anymore.
+         */
+	//__ktau_syscall_exit(__NR_rt_sigreturn);
+	ktau_syscall_exit();
+#endif /*CONFIG_KTAU_SYSCALL*/
 
 	return eax;
 
 badframe:
 	signal_fault(regs,frame,"sigreturn");
+#ifdef CONFIG_KTAU_SYSCALL
+        /* 
+         * We put the stop here to intercept the control before the
+         * registers are being restored. 
+         * Note that we are hardcoding the call number for sys_sigreturn here.
+         */
+	//__ktau_syscall_exit(__NR_rt_sigreturn);
+	ktau_syscall_exit();
+#endif /*CONFIG_KTAU_SYSCALL*/
 	return 0;
 }	
 
diff -urN linux-2.6.18.1/arch/x86_64/kernel/traps.c linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/kernel/traps.c
--- linux-2.6.18.1/arch/x86_64/kernel/traps.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/kernel/traps.c	2006-11-09 22:42:30.000000000 -0600
@@ -46,6 +46,16 @@
 #include <asm/proto.h>
 #include <asm/nmi.h>
 
+#ifdef CONFIG_KTAU_SYSCALL
+#include <linux/ktau/ktau_hash.h>
+#include <linux/ktau/ktau_inst.h>
+#define TAU_NAME "traps.h"
+#include <linux/ktau/ktau_print.h>
+#include <asm-x86_64/unistd.h>
+typedef void (*sys_call_ptr_t)(void);
+extern sys_call_ptr_t sys_call_table[__NR_syscall_max+1];
+#endif /* CONFIG_KTAU_SYSCALL */
+
 asmlinkage void divide_error(void);
 asmlinkage void debug(void);
 asmlinkage void nmi(void);
@@ -68,6 +78,65 @@
 asmlinkage void machine_check(void);
 asmlinkage void spurious_interrupt_bug(void);
 
+#ifdef CONFIG_KTAU_SYSCALL
+void __ktau_syscall_enter(unsigned long callno) {
+	info("__ktau_syscall_enter: callno:%lu\n", callno);
+	if(callno > __NR_syscall_max) {
+		err("__ktau_syscall_enter: PID:%d  callno(%lu) > __NR_syscall_max. Ignore.\n", current->pid, callno);
+		return;
+	}
+
+	unsigned long addr = sys_call_table[callno];
+	//Check if last_sysc == Magic-Null
+	if(current->ktau->last_sysc != (-(0xAEEE))) {
+		err("__ktau_syscall_enter: PID:%d  last_sysc Not Null: callno: %lu last-sysc: %lu\n", current->pid, callno, current->ktau->last_sysc);
+	}
+
+	//set the last_sysc to hold the callno
+	//so that syscall_exit will know which
+	//timer to stop.
+	current->ktau->last_sysc = callno;
+
+	ktau_start_prof(callno,addr,KTAU_SYSCALL_MSK);
+}
+
+asmlinkage void ktau_syscall_enter(struct pt_regs *regs) {
+	if(current->pid) {
+		unsigned long callno = regs->orig_rax;
+		__ktau_syscall_enter(callno);
+	}
+}
+
+void __ktau_syscall_exit(unsigned long callno) {
+	info("__ktau_syscall_exit: PID: %d  callno:%lu\n", current->pid, callno);
+	if(callno >= 0 && callno <= __NR_syscall_max){
+		unsigned long addr = (unsigned long) sys_call_table[callno];
+		ktau_stop_prof(callno,addr,KTAU_SYSCALL_MSK);
+
+		/* Check if the stackDepth is 0 when leaving syscall */
+		if(current->ktau->stackDepth != 0){
+			info("Warning: ktau_syscall_exit: PID:%d, stackDepth not zero\n\
+			stackDepth = %u, address = %x, callno =%lu",
+			current->pid, current->ktau->stackDepth, addr, callno);
+
+			//current->ktau->stackDepth = 0;
+		}
+	} else {
+		err("__ktau_syscall_exit: PID:%d Bad callno: %lu\n", current->pid, callno);
+	}
+	//reset the last_sysc to the Magic-Null
+	current->ktau->last_sysc = (-(0xAEEE));
+}
+
+//asmlinkage void ktau_syscall_exit(struct pt_regs *regs) {
+asmlinkage void ktau_syscall_exit() {
+	if(current->pid) {
+		unsigned long callno = current->ktau->last_sysc;
+		__ktau_syscall_exit(callno);
+	}
+}
+#endif /* CONFIG_KTAU_SYSCALL */
+
 ATOMIC_NOTIFIER_HEAD(die_chain);
 EXPORT_SYMBOL(die_chain);
 
@@ -105,6 +174,15 @@
 	   on an exception stack. */
 	preempt_enable_no_resched();
 }
+//AN ADDED
+void slow_trace() {
+	volatile unsigned long long t1 =0, t2 =0;
+	rdtscll(t1);
+	t2 = t1;
+	while(t2-t1 < 2000000000) {
+		rdtscll(t2);
+	}
+}
 
 static int kstack_depth_to_print = 12;
 #ifdef CONFIG_STACK_UNWIND
@@ -240,6 +318,7 @@
 
 	while (unwind(info) == 0 && UNW_PC(info)) {
 		n++;
+		slow_trace(); 
 		printk_address(UNW_PC(info));
 		if (arch_unw_user_mode(info))
 			break;
@@ -262,6 +341,8 @@
 
 	printk("\nCall Trace:\n");
 
+	slow_trace(); 
+
 	if (!tsk)
 		tsk = current;
 
@@ -312,6 +393,7 @@
 			 * down the cause of the crash will be able to figure \
 			 * out the call path that was taken. \
 			 */ \
+			slow_trace(); \
 			printk_address(addr); \
 		} \
 	} while (0)
@@ -403,6 +485,7 @@
 			printk("\n");
 		printk(" %016lx", *stack++);
 		touch_nmi_watchdog();
+		slow_trace(); 
 	}
 	show_trace(tsk, regs, rsp);
 }
@@ -627,29 +710,45 @@
 	}
 }
 
+#ifdef CONFIG_KTAU_EXCEPTION
+#define ktau_start_exception(index,fnc_addr)    ktau_start_prof(KTAU_EXCEPTION_BASE+index,(unsigned int)fnc_addr,KTAU_EXCEPTION_MSK)
+#define ktau_stop_exception(index,fnc_addr)     ktau_stop_prof(KTAU_EXCEPTION_BASE+index,(unsigned int)fnc_addr,KTAU_EXCEPTION_MSK)
+#else /*CONFIG_KTAU_EXCEPTION*/
+#define ktau_start_exception(index,fnc_addr)
+#define ktau_stop_exception(index,fnc_addr)
+#endif /*CONFIG_KTAU_EXCEPTION*/
+
 #define DO_ERROR(trapnr, signr, str, name) \
 asmlinkage void do_##name(struct pt_regs * regs, long error_code) \
 { \
+	ktau_start_exception(trapnr , &do_##name);\
 	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) \
-							== NOTIFY_STOP) \
+							== NOTIFY_STOP) { \
+		ktau_stop_exception(trapnr , &do_##name); \
 		return; \
+	} \
 	conditional_sti(regs);						\
 	do_trap(trapnr, signr, str, regs, error_code, NULL); \
+	ktau_stop_exception(trapnr , &do_##name); \
 }
 
 #define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) \
 asmlinkage void do_##name(struct pt_regs * regs, long error_code) \
 { \
 	siginfo_t info; \
+	ktau_start_exception(trapnr , &do_##name);\
 	info.si_signo = signr; \
 	info.si_errno = 0; \
 	info.si_code = sicode; \
 	info.si_addr = (void __user *)siaddr; \
 	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) \
-							== NOTIFY_STOP) \
+							== NOTIFY_STOP) { \
+		ktau_stop_exception(trapnr , &do_##name); \
 		return; \
+	} \
 	conditional_sti(regs);						\
 	do_trap(trapnr, signr, str, regs, error_code, &info); \
+	ktau_stop_exception(trapnr , &do_##name); \
 }
 
 DO_ERROR_INFO( 0, SIGFPE,  "divide error", divide_error, FPE_INTDIV, regs->rip)
diff -urN linux-2.6.18.1/arch/x86_64/mm/fault.c linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/mm/fault.c
--- linux-2.6.18.1/arch/x86_64/mm/fault.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/mm/fault.c	2006-11-09 22:42:30.000000000 -0600
@@ -75,6 +75,10 @@
 }
 #endif
 
+#ifdef CONFIG_KTAU_EXCEPTION
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_EXCEPTION*/
+
 void bust_spinlocks(int yes)
 {
 	int loglevel_save = console_loglevel;
@@ -348,6 +352,12 @@
 	unsigned long flags;
 	siginfo_t info;
 
+#ifdef CONFIG_KTAU_EXCEPTION
+	//KTAU may be using vmalloc. So only instrument
+	//user-mode faults (i.e: (error_code&4) != 0)
+	if((current->pid) && (error_code&PF_USER)) ktau_start_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
+
 	tsk = current;
 	mm = tsk->mm;
 	prefetchw(&mm->mmap_sem);
@@ -379,12 +389,20 @@
 		 */
 		if (!(error_code & (PF_RSVD|PF_USER|PF_PROT)) &&
 		      ((address >= VMALLOC_START && address < VMALLOC_END))) {
-			if (vmalloc_fault(address) >= 0)
+			if (vmalloc_fault(address) >= 0) {
+#ifdef CONFIG_KTAU_EXCEPTION
+				if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 				return;
+			}
 		}
 		if (notify_page_fault(DIE_PAGE_FAULT, "page fault", regs, error_code, 14,
-						SIGSEGV) == NOTIFY_STOP)
+						SIGSEGV) == NOTIFY_STOP) {
+#ifdef CONFIG_KTAU_EXCEPTION
+			if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 			return;
+		}
 		/*
 		 * Don't take the mm semaphore here. If we fixup a prefetch
 		 * fault we could otherwise deadlock.
@@ -393,8 +411,12 @@
 	}
 
 	if (notify_page_fault(DIE_PAGE_FAULT, "page fault", regs, error_code, 14,
-					SIGSEGV) == NOTIFY_STOP)
+					SIGSEGV) == NOTIFY_STOP) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		return;
+	}
 
 	if (likely(regs->eflags & X86_EFLAGS_IF))
 		local_irq_enable();
@@ -493,6 +515,9 @@
 	}
 
 	up_read(&mm->mmap_sem);
+#ifdef CONFIG_KTAU_EXCEPTION
+	if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 	return;
 
 /*
@@ -505,8 +530,12 @@
 bad_area_nosemaphore:
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & PF_USER) {
-		if (is_prefetch(regs, address, error_code))
+		if (is_prefetch(regs, address, error_code)) {
+#ifdef CONFIG_KTAU_EXCEPTION
+			if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 			return;
+		}
 
 		/* Work around K8 erratum #100 K8 in compat mode
 		   occasionally jumps to illegal addresses >4GB.  We
@@ -515,8 +544,12 @@
 		   case and return.  Any code segment in LDT is
 		   compatibility mode. */
 		if ((regs->cs == __USER32_CS || (regs->cs & (1<<2))) &&
-		    (address >> 32))
+		    (address >> 32)) {
+#ifdef CONFIG_KTAU_EXCEPTION
+			if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 			return;
+		}
 
 		if (exception_trace && unhandled_signal(tsk, SIGSEGV)) {
 			printk(
@@ -535,6 +568,9 @@
 		/* info.si_code has been set above */
 		info.si_addr = (void __user *)address;
 		force_sig_info(SIGSEGV, &info, tsk);
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		return;
 	}
 
@@ -544,6 +580,9 @@
 	fixup = search_exception_tables(regs->rip);
 	if (fixup) {
 		regs->rip = fixup->fixup;
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		return;
 	}
 
@@ -551,11 +590,19 @@
 	 * Hall of shame of CPU/BIOS bugs.
 	 */
 
- 	if (is_prefetch(regs, address, error_code))
+ 	if (is_prefetch(regs, address, error_code)) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
  		return;
+	}
 
-	if (is_errata93(regs, address))
+	if (is_errata93(regs, address)) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		return; 
+	}
 
 /*
  * Oops. The kernel tried to access some bad page. We'll have to
@@ -578,6 +625,9 @@
 	/* Executive summary in case the body of the oops scrolled away */
 	printk(KERN_EMERG "CR2: %016lx\n", address);
 	oops_end(flags);
+#ifdef CONFIG_KTAU_EXCEPTION
+	if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 	do_exit(SIGKILL);
 
 /*
@@ -591,8 +641,12 @@
 		goto again;
 	}
 	printk("VM: killing process %s\n", tsk->comm);
-	if (error_code & 4)
+	if (error_code & 4) {
+#ifdef CONFIG_KTAU_EXCEPTION
+		if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 		do_exit(SIGKILL);
+	}
 	goto no_context;
 
 do_sigbus:
@@ -610,6 +664,9 @@
 	info.si_code = BUS_ADRERR;
 	info.si_addr = (void __user *)address;
 	force_sig_info(SIGBUS, &info, tsk);
+#ifdef CONFIG_KTAU_EXCEPTION
+	if((current->pid) && (error_code&PF_USER)) ktau_stop_prof(KTAU_EXCEPTION_BASE+14, (unsigned int) &do_page_fault, KTAU_EXCEPTION_MSK);
+#endif /*CONFIG_KTAU_EXCEPTION*/
 	return;
 }
 
diff -urN linux-2.6.18.1/arch/x86_64/oprofile/Kconfig linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/oprofile/Kconfig
--- linux-2.6.18.1/arch/x86_64/oprofile/Kconfig	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/arch/x86_64/oprofile/Kconfig	2006-11-09 22:42:30.000000000 -0600
@@ -15,3 +15,143 @@
 
 	  If unsure, say N.
 
+config KTAU
+        bool "KTAU Profiling (EXPERIMENTAL)"
+        depends on PROFILING
+        help
+          KTAU is a Kernel Tuning Analysis Utilities providing
+          context-based (process/thread) profiling of the system.
+
+          If unsure, say N.
+
+config KTAU_DEBUG
+        bool "Extra Debug Msgs and Checks within KTAU"
+        depends on KTAU
+        help
+          Enable debug checks and messages within KTAU.
+
+          If unsure, say N.
+
+config KTAU_MERGE
+        bool "Merging KTAU Profile with TAU"
+        depends on KTAU
+        help
+          Enable kernel-space and user-space profile merging using mmap.
+
+          If unsure, say N.
+
+config KTAU_TRACE
+        bool "KTAU Tracing"
+        depends on KTAU
+        help
+          Enable KTAU tracing using circular buffer.
+
+          If unsure, say N.
+
+config KTAU_TRACE_MAX_IN_K
+        int "Maximum number of KTAU trace entries (in K)"
+        default "5"
+        depends on KTAU_TRACE
+        help
+          Please specify the size of the circular buffer used in KTAU tracing
+
+          If unsure, say N.
+
+config KTAU_BOOTOPT
+        bool "KTAU Kernel Boot Option"
+        depends on KTAU
+        help
+          This option allows KTAU instrumentations to be enabled/disabled
+          using the linux kernel boot options. Note that each instrumentation
+          must be enabled in the kenel configuration phase.
+
+          Available options are:
+                - ktau_syscall
+                - ktau_irq
+                - ktau_bh
+                - ktau_sched
+                - ktau_exception
+                - ktau_signal
+                - ktau_tcp
+                - ktau_socket
+                - ktau_icmp
+
+          If unsure, say N.
+
+config KTAU_SYSCALL
+        bool "KTAU System Calls Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU system calls instrumentation
+
+          If unsure, say N.
+
+config KTAU_IRQ
+        bool "KTAU Interrupt Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU interrupt instrumentation
+
+          If unsure, say N.
+
+config KTAU_BH
+        bool "KTAU Bottom Halves Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU bottom havles instrumentation including
+                - Softirq
+                - Tasklet
+                - Timer Interrupt
+                - Work Queue
+
+          If unsure, say N.
+
+config KTAU_EXCEPTION
+        bool "KTAU Exception Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU exception instrumentation
+
+          If unsure, say N.
+
+config KTAU_SIGNAL
+        bool "KTAU Signal Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU signal instrumentation
+
+          If unsure, say N.
+
+config KTAU_SCHED
+        bool "KTAU Scheduling Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU scheduling instrumentation
+
+          If unsure, say N.
+
+config KTAU_SOCKET
+        bool "KTAU Socket Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU network socket instrumentation
+
+          If unsure, say N.
+
+config KTAU_TCP
+        bool "KTAU TCP Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU  TCP protocol instrumentation
+
+          If unsure, say N.
+
+config KTAU_ICMP
+        bool "KTAU  ICMP Instrumentation"
+        depends on KTAU
+        help
+          Enable KTAU ICMP protocol instrumentation
+
+          If unsure, say N.
+
+
diff -urN linux-2.6.18.1/include/asm-i386/unistd.h linux-2.6.18.1-ktau-1.7.7_all/include/asm-i386/unistd.h
--- linux-2.6.18.1/include/asm-i386/unistd.h	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/include/asm-i386/unistd.h	2006-11-09 22:40:13.000000000 -0600
@@ -1,6 +1,8 @@
 #ifndef _ASM_I386_UNISTD_H_
 #define _ASM_I386_UNISTD_H_
 
+#include <linux/config.h>
+
 /*
  * This file contains the system call numbers.
  */
@@ -323,11 +325,18 @@
 #define __NR_tee		315
 #define __NR_vmsplice		316
 #define __NR_move_pages		317
+#ifdef CONFIG_KTAU_MERGE
+#define __NR_ktau_gettimeofday  318
+#endif /*CONFIG_KTAU_MERGE*/
+
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_KTAU_MERGE
+#define NR_syscalls 319
+#else /*CONFIG_KTAU_MERGE*/
 #define NR_syscalls 318
-
+#endif /*CONFIG_KTAU_MERGE*/
 /*
  * user-visible error numbers are in the range -1 - -128: see
  * <asm-i386/errno.h>
diff -urN linux-2.6.18.1/include/asm-x86_64/unistd.h linux-2.6.18.1-ktau-1.7.7_all/include/asm-x86_64/unistd.h
--- linux-2.6.18.1/include/asm-x86_64/unistd.h	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/include/asm-x86_64/unistd.h	2006-11-09 22:42:30.000000000 -0600
@@ -619,10 +619,18 @@
 __SYSCALL(__NR_vmsplice, sys_vmsplice)
 #define __NR_move_pages		279
 __SYSCALL(__NR_move_pages, sys_move_pages)
+#ifdef CONFIG_KTAU_MERGE
+#define __NR_ktau_gettimeofday  280
+__SYSCALL(__NR_ktau_gettimeofday, sys_ktau_gettimeofday)
+#endif /*CONFIG_KTAU_MERGE*/
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_KTAU_MERGE
+#define __NR_syscall_max __NR_ktau_gettimeofday
+#else /* not CONFIG_KTAU_MERGE */
 #define __NR_syscall_max __NR_move_pages
+#endif /*CONFIG_KTAU_MERGE*/
 
 #ifndef __NO_STUBS
 
diff -urN linux-2.6.18.1/include/linux/sched.h linux-2.6.18.1-ktau-1.7.7_all/include/linux/sched.h
--- linux-2.6.18.1/include/linux/sched.h	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/include/linux/sched.h	2006-11-09 22:40:05.000000000 -0600
@@ -83,6 +83,10 @@
 
 #include <asm/processor.h>
 
+#ifdef CONFIG_KTAU
+struct _ktau_prof;
+#endif /*CONFIG_KTAU*/
+
 struct exec_domain;
 struct futex_pi_state;
 
@@ -694,6 +698,7 @@
 	unsigned long ttwu_move_affine;
 	unsigned long ttwu_move_balance;
 #endif
+
 };
 
 extern int partition_sched_domains(cpumask_t *partition1,
@@ -996,6 +1001,12 @@
 #ifdef	CONFIG_TASK_DELAY_ACCT
 	struct task_delay_info *delays;
 #endif
+
+#ifdef CONFIG_KTAU
+        struct _ktau_prof *ktau;
+	spinlock_t ktau_lock;
+#endif /*CONFIG_KTAU*/
+
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
diff -urN linux-2.6.18.1/include/net/inet_timewait_sock.h linux-2.6.18.1-ktau-1.7.7_all/include/net/inet_timewait_sock.h
--- linux-2.6.18.1/include/net/inet_timewait_sock.h	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/include/net/inet_timewait_sock.h	2006-11-09 22:40:17.000000000 -0600
@@ -39,7 +39,8 @@
  * so that we select tick to get range about 4 seconds.
  */
 #if HZ <= 16 || HZ > 4096
-# error Unsupported: HZ <= 16 or HZ > 4096
+//# error Unsupported: HZ <= 16 or HZ > 4096
+# define INET_TWDR_RECYCLE_TICK (4 + 2 - INET_TWDR_RECYCLE_SLOTS_LOG)
 #elif HZ <= 32
 # define INET_TWDR_RECYCLE_TICK (5 + 2 - INET_TWDR_RECYCLE_SLOTS_LOG)
 #elif HZ <= 64
diff -urN linux-2.6.18.1/init/main.c linux-2.6.18.1-ktau-1.7.7_all/init/main.c
--- linux-2.6.18.1/init/main.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/init/main.c	2006-11-09 22:39:57.000000000 -0600
@@ -100,6 +100,12 @@
 static inline void mark_rodata_ro(void) { }
 #endif
 
+#ifdef CONFIG_KTAU
+extern void ktau_init(void);      /* KTAU initialization */
+#endif /*CONFIG_KTAU*/
+
+
+
 #ifdef CONFIG_TC
 extern void tc_init(void);
 #endif
@@ -583,6 +589,10 @@
 
 	acpi_early_init(); /* before LAPIC and SMP init */
 
+#ifdef CONFIG_KTAU
+	ktau_init();
+#endif /*CONFIG_KTAU */
+
 	/* Do the rest non-__init'ed, we're now alive */
 	rest_init();
 }
diff -urN linux-2.6.18.1/kernel/exit.c linux-2.6.18.1-ktau-1.7.7_all/kernel/exit.c
--- linux-2.6.18.1/kernel/exit.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/kernel/exit.c	2006-11-09 23:18:20.000000000 -0600
@@ -44,6 +44,10 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#ifdef CONFIG_KTAU
+#include <linux/ktau/ktau_hash.h>
+#endif /* CONFIG_KTAU */
+
 extern void sem_exit (void);
 extern struct task_struct *child_reaper;
 
@@ -168,6 +172,21 @@
 
 	sched_exit(p);
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KTAU
+	/* 
+	 * This must be done before task_struct
+	 * is free. 
+	 */
+	//Moved from free_task
+	// AN - but lets check here if ktau is NULL
+	if(p->ktau) {
+		remove_task_profile(p);
+#ifdef CONFIG_KTAU_DEBUG
+	} else {
+		printk("KTAU: release_task: PID:%d ktau==NULL.\n", p->pid);
+#endif /*CONFIG_KTAU_DEBUG*/
+	}
+#endif /*CONFIG_KTAU*/
 	proc_flush_task(p);
 	release_thread(p);
 	call_rcu(&p->rcu, delayed_put_task_struct);
diff -urN linux-2.6.18.1/kernel/fork.c linux-2.6.18.1-ktau-1.7.7_all/kernel/fork.c
--- linux-2.6.18.1/kernel/fork.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/kernel/fork.c	2006-11-09 23:24:44.000000000 -0600
@@ -53,6 +53,10 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_KTAU
+#include <linux/ktau/ktau_hash.h>
+#endif /* CONFIG_KTAU */
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -102,6 +106,19 @@
 
 void free_task(struct task_struct *tsk)
 {
+
+#ifdef CONFIG_KTAU_DEBUG
+	/* 
+	 * This must be done before task_struct
+	 * is free. 
+	 */
+	//Moved this to release_task 
+        //remove_task_profile(tsk);
+	if(tsk->ktau) {
+		printk("KTAU: free_task: PID:%d Cmd:%s ktau!=NULL:%x.\n", tsk->pid, tsk->comm, tsk->ktau);
+	}
+#endif /*CONFIG_KTAU_DEBUG*/
+
 	free_thread_info(tsk->thread_info);
 	rt_mutex_debug_task_free(tsk);
 	free_task_struct(tsk);
@@ -1141,12 +1158,16 @@
 	   These must match for thread signalling to apply */
 	   
 	p->parent_exec_id = p->self_exec_id;
-
+ 
 	/* ok, now we should be set up.. */
 	p->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);
 	p->pdeath_signal = 0;
 	p->exit_state = 0;
 
+#ifdef CONFIG_KTAU
+        create_task_profile(p);
+#endif /*CONFIG_KTAU*/
+
 	/*
 	 * Ok, make it visible to the rest of the system.
 	 * We dont wake it up yet.
diff -urN linux-2.6.18.1/kernel/irq/handle.c linux-2.6.18.1-ktau-1.7.7_all/kernel/irq/handle.c
--- linux-2.6.18.1/kernel/irq/handle.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/kernel/irq/handle.c	2006-11-09 22:41:15.000000000 -0600
@@ -16,6 +16,10 @@
 #include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
 
+#ifdef CONFIG_KTAU_IRQ
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_IRQ*/
+
 #include "internals.h"
 
 /**
@@ -171,6 +175,10 @@
 	struct irq_desc *desc = irq_desc + irq;
 	struct irqaction *action;
 	unsigned int status;
+#ifdef CONFIG_KTAU_IRQ
+	GET_KTAU_INDEX();
+	if(current->pid) ktau_start_timer((unsigned int) &__do_IRQ, KTAU_IRQ_MSK);
+#endif /*CONFIG_KTAU_IRQ*/
 
 	kstat_this_cpu.irqs[irq]++;
 	if (CHECK_IRQ_PER_CPU(desc->status)) {
@@ -183,6 +191,9 @@
 			desc->chip->ack(irq);
 		action_ret = handle_IRQ_event(irq, regs, desc->action);
 		desc->chip->end(irq);
+#ifdef CONFIG_KTAU_IRQ
+		if(current->pid) ktau_stop_timer((unsigned int) &__do_IRQ, KTAU_IRQ_MSK);
+#endif /*CONFIG_KTAU_IRQ*/
 		return 1;
 	}
 
@@ -251,6 +262,9 @@
 	desc->chip->end(irq);
 	spin_unlock(&desc->lock);
 
+#ifdef CONFIG_KTAU_IRQ
+	if(current->pid) ktau_stop_timer((unsigned int) &__do_IRQ, KTAU_IRQ_MSK);
+#endif /*CONFIG_KTAU_IRQ*/
 	return 1;
 }
 
diff -urN linux-2.6.18.1/kernel/Makefile linux-2.6.18.1-ktau-1.7.7_all/kernel/Makefile
--- linux-2.6.18.1/kernel/Makefile	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/kernel/Makefile	2006-11-09 22:41:15.000000000 -0600
@@ -50,6 +50,7 @@
 obj-$(CONFIG_RELAY) += relay.o
 obj-$(CONFIG_TASK_DELAY_ACCT) += delayacct.o
 obj-$(CONFIG_TASKSTATS) += taskstats.o
+obj-$(CONFIG_KTAU) += ktau/
 
 ifneq ($(CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff -urN linux-2.6.18.1/kernel/sched.c linux-2.6.18.1-ktau-1.7.7_all/kernel/sched.c
--- linux-2.6.18.1/kernel/sched.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/kernel/sched.c	2006-11-09 22:41:15.000000000 -0600
@@ -56,6 +56,10 @@
 
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KTAU_SCHED
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_SCHED*/
+
 /*
  * Convert user-nice values [ -20 ... 0 ... 19 ]
  * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
@@ -2894,6 +2898,14 @@
 
 EXPORT_PER_CPU_SYMBOL(kstat);
 
+#ifdef CONFIG_KTAU_SCHED
+int schedule_vol(void)
+{
+	volatile int dummy = 10;
+	return dummy;
+}
+#endif /* CONFIG_KTAU_SCHED */
+
 /*
  * This is called on clock ticks and on context switches.
  * Bank in p->sched_time the ns elapsed since the last tick or switch.
@@ -3302,6 +3314,11 @@
 	long *switch_count;
 	struct rq *rq;
 
+#ifdef CONFIG_KTAU_SCHED
+	INCR_KTAU_INDEX(2);
+	int involuntary = 0;
+#endif /*CONFIG_KTAU_SCHED*/
+
 	/*
 	 * Test if we are atomic.  Since do_exit() needs to call into
 	 * schedule() atomically, we ignore that path for now.
@@ -3417,6 +3434,9 @@
 		schedstat_inc(rq, sched_goidle);
 	prefetch(next);
 	prefetch_stack(next);
+#ifdef CONFIG_KTAU_SCHED
+	if(current->pid) involuntary = test_thread_flag(TIF_NEED_RESCHED);
+#endif /*CONFIG_KTAU_SCHED*/
 	clear_tsk_need_resched(prev);
 	rcu_qsctr_inc(task_cpu(prev));
 
@@ -3434,9 +3454,28 @@
 		rq->curr = next;
 		++*switch_count;
 
+#ifdef CONFIG_KTAU_SCHED
+		if(current->pid) {
+			if(involuntary) {
+				ktau_start_timer((unsigned int) &schedule,KTAU_SCHED_MSK);
+			} else {
+				ktau_start_prof(ktau_index + 1, (unsigned int)&schedule_vol, KTAU_SCHED_MSK);
+			}
+		}
+#endif /*CONFIG_KTAU_SCHED*/
 		prepare_task_switch(rq, next);
 		prev = context_switch(rq, prev, next);
 		barrier();
+#ifdef CONFIG_KTAU_SCHED
+		if(current->pid) {
+			if(involuntary) {
+				ktau_stop_timer((unsigned int) &schedule,KTAU_SCHED_MSK);
+			} else {
+				ktau_stop_prof(ktau_index + 1, (unsigned int)&schedule_vol, KTAU_SCHED_MSK);
+			}
+		}
+#endif /*CONFIG_KTAU_SCHED*/
+
 		/*
 		 * this_rq must be evaluated again because prev may have moved
 		 * CPUs since it called schedule(), thus the 'rq' on its stack
diff -urN linux-2.6.18.1/kernel/softirq.c linux-2.6.18.1-ktau-1.7.7_all/kernel/softirq.c
--- linux-2.6.18.1/kernel/softirq.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/kernel/softirq.c	2006-11-09 22:41:15.000000000 -0600
@@ -19,6 +19,11 @@
 #include <linux/smp.h>
 
 #include <asm/irq.h>
+
+#ifdef CONFIG_KTAU_BH
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_BH*/
+
 /*
    - No shared variables, all the data are CPU local.
    - If a softirq needs serialization, let it serialize itself
@@ -210,6 +215,14 @@
 	int max_restart = MAX_SOFTIRQ_RESTART;
 	int cpu;
 
+#ifdef CONFIG_KTAU_BH
+	GET_KTAU_INDEX();
+#endif /*CONFIG_KTAU_BH*/
+
+#ifdef CONFIG_KTAU_BH
+	if(current->pid)ktau_start_timer(&__do_softirq, KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
+
 	pending = local_softirq_pending();
 	account_system_vtime(current);
 
@@ -228,6 +241,9 @@
 	do {
 		if (pending & 1) {
 			h->action(h);
+#ifdef CONFIG_KTAU_BH
+//			if(current->pid)ktau_event_prof(KTAU_EVENT_SOFTIRQ,(unsigned int)&__do_softirq);
+#endif /*CONFIG_KTAU_BH*/
 			rcu_bh_qsctr_inc(cpu);
 		}
 		h++;
@@ -247,6 +263,10 @@
 
 	account_system_vtime(current);
 	_local_bh_enable();
+
+#ifdef CONFIG_KTAU_BH
+	if(current->pid)ktau_stop_timer(&__do_softirq, KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
 }
 
 #ifndef __ARCH_HAS_DO_SOFTIRQ
@@ -369,12 +389,19 @@
 static void tasklet_action(struct softirq_action *a)
 {
 	struct tasklet_struct *list;
+#ifdef CONFIG_KTAU_BH
+	GET_KTAU_INDEX();
+#endif /*CONFIG_KTAU_BH*/
 
 	local_irq_disable();
 	list = __get_cpu_var(tasklet_vec).list;
 	__get_cpu_var(tasklet_vec).list = NULL;
 	local_irq_enable();
 
+#ifdef CONFIG_KTAU_BH
+	if(current->pid)ktau_start_timer(&tasklet_action, KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
+
 	while (list) {
 		struct tasklet_struct *t = list;
 
@@ -384,6 +411,9 @@
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+#ifdef CONFIG_KTAU_BH
+//				if(current->pid)ktau_event_prof(KTAU_EVENT_TASKLET,(unsigned int)&tasklet_action);
+#endif /*CONFIG_KTAU_BH*/
 				t->func(t->data);
 				tasklet_unlock(t);
 				continue;
@@ -397,17 +427,27 @@
 		__raise_softirq_irqoff(TASKLET_SOFTIRQ);
 		local_irq_enable();
 	}
+#ifdef CONFIG_KTAU_BH
+	if(current->pid)ktau_stop_timer(&tasklet_action, KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
 }
 
 static void tasklet_hi_action(struct softirq_action *a)
 {
 	struct tasklet_struct *list;
+#ifdef CONFIG_KTAU_BH
+	GET_KTAU_INDEX();
+#endif /*CONFIG_KTAU_BH*/
 
 	local_irq_disable();
 	list = __get_cpu_var(tasklet_hi_vec).list;
 	__get_cpu_var(tasklet_hi_vec).list = NULL;
 	local_irq_enable();
 
+#ifdef CONFIG_KTAU_BH
+	if(current->pid)ktau_start_timer(&tasklet_hi_action, KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
+
 	while (list) {
 		struct tasklet_struct *t = list;
 
@@ -430,6 +470,9 @@
 		__raise_softirq_irqoff(HI_SOFTIRQ);
 		local_irq_enable();
 	}
+#ifdef CONFIG_KTAU_BH
+	if(current->pid)ktau_stop_timer(&tasklet_hi_action, KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
 }
 
 
diff -urN linux-2.6.18.1/kernel/timer.c linux-2.6.18.1-ktau-1.7.7_all/kernel/timer.c
--- linux-2.6.18.1/kernel/timer.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/kernel/timer.c	2006-11-09 22:41:15.000000000 -0600
@@ -35,12 +35,18 @@
 #include <linux/syscalls.h>
 #include <linux/delay.h>
 
+#ifdef CONFIG_KTAU_BH
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_BH*/
+
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 #include <asm/div64.h>
 #include <asm/timex.h>
 #include <asm/io.h>
 
+#include <linux/ktau/ktau_hash.h>
+
 #ifdef CONFIG_TIME_INTERPOLATION
 static void time_interpolator_update(long delta_nsec);
 #else
@@ -413,6 +419,10 @@
 static inline void __run_timers(tvec_base_t *base)
 {
 	struct timer_list *timer;
+#ifdef CONFIG_KTAU_BH
+	GET_KTAU_INDEX();
+	if(current->pid) ktau_start_timer((unsigned int)&__run_timers, KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
 
 	spin_lock_irq(&base->lock);
 	while (time_after_eq(jiffies, base->timer_jiffies)) {
@@ -458,6 +468,9 @@
 	}
 	set_running_timer(base, NULL);
 	spin_unlock_irq(&base->lock);
+#ifdef CONFIG_KTAU_BH
+	if(current->pid) ktau_stop_timer((unsigned int)&__run_timers, KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
 }
 
 #ifdef CONFIG_NO_IDLE_HZ
diff -urN linux-2.6.18.1/kernel/workqueue.c linux-2.6.18.1-ktau-1.7.7_all/kernel/workqueue.c
--- linux-2.6.18.1/kernel/workqueue.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/kernel/workqueue.c	2006-11-09 22:41:15.000000000 -0600
@@ -29,6 +29,10 @@
 #include <linux/kthread.h>
 #include <linux/hardirq.h>
 
+#ifdef CONFIG_KTAU_BH
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_BH*/
+
 /*
  * The per-CPU workqueue (if single thread, we always use the first
  * possible cpu).
@@ -195,7 +199,10 @@
 static void run_workqueue(struct cpu_workqueue_struct *cwq)
 {
 	unsigned long flags;
-
+#ifdef CONFIG_KTAU_BH
+	GET_KTAU_INDEX();
+	ktau_start_timer(&run_workqueue,KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
 	/*
 	 * Keep taking off work from the queue until
 	 * done.
@@ -219,6 +226,9 @@
 
 		BUG_ON(work->wq_data != cwq);
 		clear_bit(0, &work->pending);
+#ifdef CONFIG_KTAU_BH
+	//	ktau_event_prof(KTAU_EVENT_WORKQUEUE,(unsigned int) &run_workqueue);
+#endif /*CONFIG_KTAU_BH*/
 		f(data);
 
 		spin_lock_irqsave(&cwq->lock, flags);
@@ -227,6 +237,9 @@
 	}
 	cwq->run_depth--;
 	spin_unlock_irqrestore(&cwq->lock, flags);
+#ifdef CONFIG_KTAU_BH
+	ktau_stop_timer(&run_workqueue,KTAU_BH_MSK);
+#endif /*CONFIG_KTAU_BH*/
 }
 
 static int worker_thread(void *__cwq)
diff -urN linux-2.6.18.1/Makefile linux-2.6.18.1-ktau-1.7.7_all/Makefile
--- linux-2.6.18.1/Makefile	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/Makefile	2006-11-09 22:39:56.000000000 -0600
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 18
-EXTRAVERSION = .1
+EXTRAVERSION = .1-ktau-1.7.7
 NAME=Avast! A bilge rat!
 
 # *DOCUMENTATION*
diff -urN linux-2.6.18.1/net/ipv4/icmp.c linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/icmp.c
--- linux-2.6.18.1/net/ipv4/icmp.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/icmp.c	2006-11-09 22:40:26.000000000 -0600
@@ -93,6 +93,10 @@
 #include <asm/uaccess.h>
 #include <net/checksum.h>
 
+#ifdef CONFIG_KTAU_ICMP
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_ICMP*/
+
 /*
  *	Build xmit assembly blocks
  */
@@ -383,11 +387,25 @@
 	struct rtable *rt = (struct rtable *)skb->dst;
 	u32 daddr;
 
-	if (ip_options_echo(&icmp_param->replyopts, skb))
+#ifdef CONFIG_KTAU_ICMP
+	GET_KTAU_INDEX();
+	if(current->pid)ktau_start_timer(&icmp_reply,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
+
+	if (ip_options_echo(&icmp_param->replyopts, skb)) {
+#ifdef CONFIG_KTAU_ICMP
+		if(current->pid)ktau_stop_timer(&icmp_reply,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
+
 		return;
+	}
 
-	if (icmp_xmit_lock())
+	if (icmp_xmit_lock()) {
+#ifdef CONFIG_KTAU_ICMP
+		if(current->pid)ktau_stop_timer(&icmp_reply,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
 		return;
+	}
 
 	icmp_param->data.icmph.checksum = 0;
 	icmp_out_count(icmp_param->data.icmph.type);
@@ -415,6 +433,9 @@
 	ip_rt_put(rt);
 out_unlock:
 	icmp_xmit_unlock();
+#ifdef CONFIG_KTAU_ICMP
+	if(current->pid)ktau_stop_timer(&icmp_reply,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
 }
 
 
@@ -439,6 +460,11 @@
 	u32 saddr;
 	u8  tos;
 
+#ifdef CONFIG_KTAU_ICMP
+	GET_KTAU_INDEX();
+	if(current->pid)ktau_start_timer(&icmp_send,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
+
 	if (!rt)
 		goto out;
 
@@ -503,8 +529,12 @@
 		}
 	}
 
-	if (icmp_xmit_lock())
+	if (icmp_xmit_lock()) {
+#ifdef CONFIG_KTAU_ICMP
+		if(current->pid)ktau_stop_timer(&icmp_send,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
 		return;
+	}
 
 	/*
 	 *	Construct source address and options.
@@ -586,9 +616,11 @@
 out_unlock:
 	icmp_xmit_unlock();
 out:;
+#ifdef CONFIG_KTAU_ICMP
+	if(current->pid)ktau_stop_timer(&icmp_send,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
 }
 
-
 /*
  *	Handle ICMP_DEST_UNREACH, ICMP_TIME_EXCEED, and ICMP_QUENCH.
  */
@@ -925,6 +957,11 @@
 	struct icmphdr *icmph;
 	struct rtable *rt = (struct rtable *)skb->dst;
 
+#ifdef CONFIG_KTAU_ICMP
+        GET_KTAU_INDEX();
+        if(current->pid)ktau_start_timer(&icmp_rcv,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
+
 	ICMP_INC_STATS_BH(ICMP_MIB_INMSGS);
 
 	switch (skb->ip_summed) {
@@ -982,6 +1019,9 @@
 
 drop:
 	kfree_skb(skb);
+#ifdef CONFIG_KTAU_ICMP
+        if(current->pid)ktau_stop_timer(&icmp_rcv,KTAU_ICMP_MSK);
+#endif /*CONFIG_KTAU_ICMP*/
 	return 0;
 error:
 	ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
diff -urN linux-2.6.18.1/net/ipv4/tcp.c linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/tcp.c
--- linux-2.6.18.1/net/ipv4/tcp.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/tcp.c	2006-11-09 22:40:25.000000000 -0600
@@ -268,6 +268,10 @@
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+#ifdef CONFIG_KTAU_TCP
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_TCP*/
+
 int sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;
 
 DEFINE_SNMP_STAT(struct tcp_mib, tcp_statistics) __read_mostly;
@@ -667,6 +671,11 @@
 	int err, copied;
 	long timeo;
 
+#ifdef CONFIG_KTAU_TCP
+        GET_KTAU_INDEX();
+	if(current->pid)ktau_start_timer(&tcp_sendmsg,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
+
 	lock_sock(sk);
 	TCP_CHECK_TIMER(sk);
 
@@ -854,6 +863,9 @@
 		tcp_push(sk, tp, flags, mss_now, tp->nonagle);
 	TCP_CHECK_TIMER(sk);
 	release_sock(sk);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_sendmsg,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return copied;
 
 do_fault:
@@ -871,6 +883,9 @@
 	err = sk_stream_error(sk, flags, err);
 	TCP_CHECK_TIMER(sk);
 	release_sock(sk);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_sendmsg,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return err;
 }
 
@@ -1105,6 +1120,10 @@
 	long timeo;
 	struct task_struct *user_recv = NULL;
 	int copied_early = 0;
+#ifdef CONFIG_KTAU_TCP
+	GET_KTAU_INDEX();
+	if(current->pid)ktau_start_timer(&tcp_recvmsg,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 
 	lock_sock(sk);
 
@@ -1465,11 +1484,17 @@
 
 	TCP_CHECK_TIMER(sk);
 	release_sock(sk);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_recvmsg,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return copied;
 
 out:
 	TCP_CHECK_TIMER(sk);
 	release_sock(sk);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_recvmsg,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return err;
 
 recv_urg:
diff -urN linux-2.6.18.1/net/ipv4/tcp_input.c linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/tcp_input.c
--- linux-2.6.18.1/net/ipv4/tcp_input.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/tcp_input.c	2006-11-09 22:40:25.000000000 -0600
@@ -72,6 +72,10 @@
 #include <asm/unaligned.h>
 #include <net/netdma.h>
 
+#ifdef CONFIG_KTAU_TCP
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_TCP*/
+
 int sysctl_tcp_timestamps = 1;
 int sysctl_tcp_window_scaling = 1;
 int sysctl_tcp_sack = 1;
@@ -3130,6 +3134,10 @@
 	struct tcphdr *th = skb->h.th;
 	struct tcp_sock *tp = tcp_sk(sk);
 	int eaten = -1;
+#ifdef CONFIG_KTAU_TCP
+	GET_KTAU_INDEX();
+	if(current->pid)ktau_start_timer(&tcp_data_queue,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 
 	if (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq)
 		goto drop;
@@ -3208,6 +3216,9 @@
 			__kfree_skb(skb);
 		else if (!sock_flag(sk, SOCK_DEAD))
 			sk->sk_data_ready(sk, 0);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_data_queue,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 		return;
 	}
 
@@ -3221,6 +3232,9 @@
 		inet_csk_schedule_ack(sk);
 drop:
 		__kfree_skb(skb);
+#ifdef CONFIG_KTAU_TCP
+		if(current->pid)ktau_stop_timer(&tcp_data_queue,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 		return;
 	}
 
@@ -3289,6 +3303,9 @@
 
 			/* Common case: data arrive in order after hole. */
 			tp->selective_acks[0].end_seq = end_seq;
+#ifdef CONFIG_KTAU_TCP
+			if(current->pid)ktau_stop_timer(&tcp_data_queue,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 			return;
 		}
 
@@ -3334,6 +3351,9 @@
 		if (tp->rx_opt.sack_ok)
 			tcp_sack_new_ofo_skb(sk, seq, end_seq);
 	}
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_data_queue,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 }
 
 /* Collapse contiguous sequence of skbs head..tail with
@@ -3870,6 +3890,11 @@
 int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,
 			struct tcphdr *th, unsigned len)
 {
+#ifdef CONFIG_KTAU_TCP
+	GET_KTAU_INDEX();
+        if(current->pid)ktau_start_timer(&tcp_rcv_established,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
+	
 	struct tcp_sock *tp = tcp_sk(sk);
 
 	/*
@@ -3951,6 +3976,9 @@
 				tcp_ack(sk, skb, 0);
 				__kfree_skb(skb); 
 				tcp_data_snd_check(sk, tp);
+#ifdef CONFIG_KTAU_TCP
+				if(current->pid)ktau_stop_timer(&tcp_rcv_established,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 				return 0;
 			} else { /* Header too small */
 				TCP_INC_STATS_BH(TCP_MIB_INERRS);
@@ -4042,11 +4070,18 @@
 				__kfree_skb(skb);
 			else
 				sk->sk_data_ready(sk, 0);
+#ifdef CONFIG_KTAU_TCP
+			if(current->pid)ktau_stop_timer(&tcp_rcv_established,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 			return 0;
 		}
 	}
 
 slow_path:
+#ifdef CONFIG_KTAU_TCP
+	//if(current->pid)ktau_event_prof(KTAU_EVENT_TCP_SLOWPATH,(unsigned int)&tcp_rcv_established,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
+
 	if (len < (th->doff<<2) || tcp_checksum_complete_user(sk, skb))
 		goto csum_error;
 
@@ -4094,6 +4129,9 @@
 		TCP_INC_STATS_BH(TCP_MIB_INERRS);
 		NET_INC_STATS_BH(LINUX_MIB_TCPABORTONSYN);
 		tcp_reset(sk);
+#ifdef CONFIG_KTAU_TCP
+		if(current->pid)ktau_stop_timer(&tcp_rcv_established,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 		return 1;
 	}
 
@@ -4111,6 +4149,9 @@
 
 	tcp_data_snd_check(sk, tp);
 	tcp_ack_snd_check(sk);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_rcv_established,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return 0;
 
 csum_error:
@@ -4118,6 +4159,9 @@
 
 discard:
 	__kfree_skb(skb);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_rcv_established,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return 0;
 }
 
diff -urN linux-2.6.18.1/net/ipv4/tcp_ipv4.c linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/tcp_ipv4.c
--- linux-2.6.18.1/net/ipv4/tcp_ipv4.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/tcp_ipv4.c	2006-11-09 22:40:25.000000000 -0600
@@ -78,6 +78,10 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
+#ifdef CONFIG_KTAU_TCP
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_TCP*/
+
 int sysctl_tcp_tw_reuse;
 int sysctl_tcp_low_latency;
 
@@ -998,11 +1002,19 @@
  */
 int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)
 {
+#ifdef CONFIG_KTAU_TCP
+	GET_KTAU_INDEX();
+	if(current->pid)ktau_start_timer(&tcp_v4_do_rcv,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
+
 	if (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */
 		TCP_CHECK_TIMER(sk);
 		if (tcp_rcv_established(sk, skb, skb->h.th, skb->len))
 			goto reset;
 		TCP_CHECK_TIMER(sk);
+#ifdef CONFIG_KTAU_TCP
+		if(current->pid)ktau_stop_timer(&tcp_v4_do_rcv,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 		return 0;
 	}
 
@@ -1017,6 +1029,9 @@
 		if (nsk != sk) {
 			if (tcp_child_process(sk, nsk, skb))
 				goto reset;
+#ifdef CONFIG_KTAU_TCP
+			if(current->pid)ktau_stop_timer(&tcp_v4_do_rcv,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 			return 0;
 		}
 	}
@@ -1025,6 +1040,9 @@
 	if (tcp_rcv_state_process(sk, skb, skb->h.th, skb->len))
 		goto reset;
 	TCP_CHECK_TIMER(sk);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_v4_do_rcv,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return 0;
 
 reset:
@@ -1036,6 +1054,9 @@
 	 * might be destroyed here. This current version compiles correctly,
 	 * but you have been warned.
 	 */
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_v4_do_rcv,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return 0;
 
 csum_err:
@@ -1052,6 +1073,10 @@
 	struct tcphdr *th;
 	struct sock *sk;
 	int ret;
+#ifdef CONFIG_KTAU_TCP
+	GET_KTAU_INDEX();
+	if(current->pid)ktau_start_timer(&tcp_v4_rcv,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 
 	if (skb->pkt_type != PACKET_HOST)
 		goto discard_it;
@@ -1127,6 +1152,9 @@
 
 	sock_put(sk);
 
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_v4_rcv,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return ret;
 
 no_tcp_socket:
@@ -1143,6 +1171,9 @@
 discard_it:
 	/* Discard frame. */
 	kfree_skb(skb);
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_v4_rcv,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
   	return 0;
 
 discard_and_relse:
diff -urN linux-2.6.18.1/net/ipv4/tcp_output.c linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/tcp_output.c
--- linux-2.6.18.1/net/ipv4/tcp_output.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/net/ipv4/tcp_output.c	2006-11-09 22:40:26.000000000 -0600
@@ -42,6 +42,10 @@
 #include <linux/module.h>
 #include <linux/smp_lock.h>
 
+#ifdef CONFIG_KTAU_TCP
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_TCP*/
+
 /* People can turn this off for buggy TCP's found in printers etc. */
 int sysctl_tcp_retrans_collapse = 1;
 
@@ -1670,6 +1674,11 @@
  	unsigned int cur_mss = tcp_current_mss(sk, 0);
 	int err;
 
+#ifdef CONFIG_KTAU_TCP
+	GET_KTAU_INDEX();
+	if(current->pid)ktau_start_timer(&tcp_retransmit_skb,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
+
 	/* Inconslusive MTU probe */
 	if (icsk->icsk_mtup.probe_size) {
 		icsk->icsk_mtup.probe_size = 0;
@@ -1679,14 +1688,23 @@
 	 * copying overhead: fragmentation, tunneling, mangling etc.
 	 */
 	if (atomic_read(&sk->sk_wmem_alloc) >
-	    min(sk->sk_wmem_queued + (sk->sk_wmem_queued >> 2), sk->sk_sndbuf))
+	    min(sk->sk_wmem_queued + (sk->sk_wmem_queued >> 2), sk->sk_sndbuf)) {
+#ifdef CONFIG_KTAU_TCP
+		if(current->pid)ktau_stop_timer(&tcp_retransmit_skb,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
+
 		return -EAGAIN;
+	}
 
 	if (before(TCP_SKB_CB(skb)->seq, tp->snd_una)) {
 		if (before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))
 			BUG();
-		if (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))
+		if (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq)) {
+#ifdef CONFIG_KTAU_TCP
+			if(current->pid)ktau_stop_timer(&tcp_retransmit_skb,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 			return -ENOMEM;
+		}
 	}
 
 	/* If receiver has shrunk his window, and skb is out of
@@ -1696,11 +1714,21 @@
 	 */
 	if (!before(TCP_SKB_CB(skb)->seq, tp->snd_una+tp->snd_wnd)
 	    && TCP_SKB_CB(skb)->seq != tp->snd_una)
+	{		
+#ifdef CONFIG_KTAU_TCP
+		if(current->pid)ktau_stop_timer(&tcp_retransmit_skb,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 		return -EAGAIN;
+	}
 
 	if (skb->len > cur_mss) {
 		if (tcp_fragment(sk, skb, cur_mss, cur_mss))
+		{
+#ifdef CONFIG_KTAU_TCP
+			if(current->pid)ktau_stop_timer(&tcp_retransmit_skb,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 			return -ENOMEM; /* We'll try again later. */
+		}
 	}
 
 	/* Collapse two adjacent packets if worthwhile and we can. */
@@ -1766,6 +1794,9 @@
 		 */
 		TCP_SKB_CB(skb)->ack_seq = tp->snd_nxt;
 	}
+#ifdef CONFIG_KTAU_TCP
+	if(current->pid)ktau_stop_timer(&tcp_retransmit_skb,KTAU_TCP_MSK);
+#endif /*CONFIG_KTAU_TCP*/
 	return err;
 }
 
diff -urN linux-2.6.18.1/net/socket.c linux-2.6.18.1-ktau-1.7.7_all/net/socket.c
--- linux-2.6.18.1/net/socket.c	2006-10-13 22:34:03.000000000 -0500
+++ linux-2.6.18.1-ktau-1.7.7_all/net/socket.c	2006-11-09 22:40:27.000000000 -0600
@@ -94,6 +94,10 @@
 #include <net/sock.h>
 #include <linux/netfilter.h>
 
+#ifdef CONFIG_KTAU_SOCKET
+#include <linux/ktau/ktau_inst.h>
+#endif /*CONFIG_KTAU_SOCKET*/
+
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
 			 size_t size, loff_t pos);
@@ -601,12 +605,19 @@
 	struct kiocb iocb;
 	struct sock_iocb siocb;
 	int ret;
+#ifdef CONFIG_KTAU_SOCKET
+	GET_KTAU_INDEX();
+	ktau_start_timer(&sock_sendmsg,KTAU_SOCKET_MSK);
+#endif /*CONFIG_KTAU_SOCKET*/
 
 	init_sync_kiocb(&iocb, NULL);
 	iocb.private = &siocb;
 	ret = __sock_sendmsg(&iocb, sock, msg, size);
 	if (-EIOCBQUEUED == ret)
 		ret = wait_on_sync_kiocb(&iocb);
+#ifdef CONFIG_KTAU_SOCKET
+	ktau_stop_timer(&sock_sendmsg,KTAU_SOCKET_MSK);
+#endif /*CONFIG_KTAU_SOCKET*/
 	return ret;
 }
 
@@ -653,12 +664,19 @@
 	struct kiocb iocb;
 	struct sock_iocb siocb;
 	int ret;
+#ifdef CONFIG_KTAU_SOCKET
+	GET_KTAU_INDEX();
+	ktau_start_timer(&sock_recvmsg,KTAU_SOCKET_MSK);
+#endif /*CONFIG_KTAU_SOCKET*/
 
         init_sync_kiocb(&iocb, NULL);
 	iocb.private = &siocb;
 	ret = __sock_recvmsg(&iocb, sock, msg, size, flags);
 	if (-EIOCBQUEUED == ret)
 		ret = wait_on_sync_kiocb(&iocb);
+#ifdef CONFIG_KTAU_SOCKET
+	ktau_stop_timer(&sock_recvmsg,KTAU_SOCKET_MSK);
+#endif /*CONFIG_KTAU_SOCKET*/
 	return ret;
 }
 
