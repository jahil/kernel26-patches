Index: linux-2.6.19-avr1/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/Makefile	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 19
-EXTRAVERSION =
+EXTRAVERSION = -avr1
 NAME=Avast! A bilge rat!
 
 # *DOCUMENTATION*
Index: linux-2.6.19-avr1/Documentation/serial/driver
===================================================================
--- linux-2.6.19-avr1.orig/Documentation/serial/driver	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/Documentation/serial/driver	2006-12-03 19:23:23.000000000 +0100
@@ -186,6 +186,17 @@ hardware.
 	Locking: port_sem taken.
 	Interrupts: caller dependent.
 
+  flush_buffer(port)
+	Flush any write buffers, reset any DMA state and stop any
+	ongoing DMA transfers.
+
+	This will be called whenever the port->info->xmit circular
+	buffer is cleared.
+
+	Locking: port->lock taken.
+	Interrupts: locally disabled.
+	This call must not sleep
+
   set_termios(port,termios,oldtermios)
 	Change the port parameters, including word length, parity, stop
 	bits.  Update read_status_mask and ignore_status_mask to indicate
Index: linux-2.6.19-avr1/drivers/serial/serial_core.c
===================================================================
--- linux-2.6.19-avr1.orig/drivers/serial/serial_core.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/drivers/serial/serial_core.c	2006-12-03 19:23:23.000000000 +0100
@@ -556,6 +556,8 @@ static void uart_flush_buffer(struct tty
 
 	spin_lock_irqsave(&port->lock, flags);
 	uart_circ_clear(&state->info->xmit);
+	if (port->ops->flush_buffer)
+		port->ops->flush_buffer(port);
 	spin_unlock_irqrestore(&port->lock, flags);
 	tty_wakeup(tty);
 }
Index: linux-2.6.19-avr1/include/linux/serial_core.h
===================================================================
--- linux-2.6.19-avr1.orig/include/linux/serial_core.h	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/include/linux/serial_core.h	2006-12-03 19:23:23.000000000 +0100
@@ -164,6 +164,7 @@ struct uart_ops {
 	void		(*break_ctl)(struct uart_port *, int ctl);
 	int		(*startup)(struct uart_port *);
 	void		(*shutdown)(struct uart_port *);
+	void		(*flush_buffer)(struct uart_port *);
 	void		(*set_termios)(struct uart_port *, struct termios *new,
 				       struct termios *old);
 	void		(*pm)(struct uart_port *, unsigned int state,
Index: linux-2.6.19-avr1/drivers/spi/spi.c
===================================================================
--- linux-2.6.19-avr1.orig/drivers/spi/spi.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/drivers/spi/spi.c	2006-12-03 19:23:23.000000000 +0100
@@ -366,6 +366,7 @@ spi_alloc_master(struct device *dev, uns
 
 	class_device_initialize(&master->cdev);
 	master->cdev.class = &spi_master_class;
+	kobj_set_kset_s(&master->cdev, spi_master_class.subsys);
 	master->cdev.dev = get_device(dev);
 	spi_master_set_devdata(master, &master[1]);
 
@@ -463,15 +464,13 @@ EXPORT_SYMBOL_GPL(spi_unregister_master)
  */
 struct spi_master *spi_busnum_to_master(u16 bus_num)
 {
-	if (bus_num) {
-		char			name[8];
-		struct kobject		*bus;
-
-		snprintf(name, sizeof name, "spi%u", bus_num);
-		bus = kset_find_obj(&spi_master_class.subsys.kset, name);
-		if (bus)
-			return container_of(bus, struct spi_master, cdev.kobj);
-	}
+	char			name[9];
+	struct kobject		*bus;
+
+	snprintf(name, sizeof name, "spi%u", bus_num);
+	bus = kset_find_obj(&spi_master_class.subsys.kset, name);
+	if (bus)
+		return container_of(bus, struct spi_master, cdev.kobj);
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(spi_busnum_to_master);
Index: linux-2.6.19-avr1/drivers/usb/gadget/ether.c
===================================================================
--- linux-2.6.19-avr1.orig/drivers/usb/gadget/ether.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/drivers/usb/gadget/ether.c	2006-12-03 19:23:23.000000000 +0100
@@ -266,6 +266,10 @@ MODULE_PARM_DESC(host_addr, "Host Ethern
 #define DEV_CONFIG_CDC
 #endif
 
+#ifdef CONFIG_USB_GADGET_HUSB2DEV
+#define DEV_CONFIG_CDC
+#endif
+
 
 /* For CDC-incapable hardware, choose the simple cdc subset.
  * Anything that talks bulk (without notable bugs) can do this.
@@ -428,7 +432,7 @@ static inline int BITRATE(struct usb_gad
 #define DEV_RNDIS_CONFIG_VALUE	2	/* rndis; optional */
 
 static struct usb_device_descriptor
-device_desc = {
+device_desc __attribute__((aligned(2))) = {
 	.bLength =		sizeof device_desc,
 	.bDescriptorType =	USB_DT_DEVICE,
 
@@ -454,7 +458,7 @@ otg_descriptor = {
 };
 
 static struct usb_config_descriptor
-eth_config = {
+eth_config __attribute__((aligned(2))) = {
 	.bLength =		sizeof eth_config,
 	.bDescriptorType =	USB_DT_CONFIG,
 
@@ -468,7 +472,7 @@ eth_config = {
 
 #ifdef	CONFIG_USB_ETH_RNDIS
 static struct usb_config_descriptor
-rndis_config = {
+rndis_config __attribute__((aligned(2))) = {
 	.bLength =              sizeof rndis_config,
 	.bDescriptorType =      USB_DT_CONFIG,
 
@@ -493,7 +497,7 @@ rndis_config = {
 
 #ifdef	DEV_CONFIG_CDC
 static struct usb_interface_descriptor
-control_intf = {
+control_intf __attribute__((aligned(2))) = {
 	.bLength =		sizeof control_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -509,7 +513,7 @@ control_intf = {
 
 #ifdef	CONFIG_USB_ETH_RNDIS
 static const struct usb_interface_descriptor
-rndis_control_intf = {
+rndis_control_intf __attribute__((aligned(2))) = {
 	.bLength =              sizeof rndis_control_intf,
 	.bDescriptorType =      USB_DT_INTERFACE,
 
@@ -524,7 +528,7 @@ rndis_control_intf = {
 
 #if defined(DEV_CONFIG_CDC) || defined(CONFIG_USB_ETH_RNDIS)
 
-static const struct usb_cdc_header_desc header_desc = {
+static const struct usb_cdc_header_desc __attribute__((aligned(2))) header_desc = {
 	.bLength =		sizeof header_desc,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_HEADER_TYPE,
@@ -566,7 +570,8 @@ static const struct usb_cdc_acm_descript
 
 #ifdef	DEV_CONFIG_CDC
 
-static const struct usb_cdc_ether_desc ether_desc = {
+static const struct usb_cdc_ether_desc
+ether_desc __attribute__((aligned(2))) = {
 	.bLength =		sizeof ether_desc,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_ETHERNET_TYPE,
@@ -601,7 +606,7 @@ static const struct usb_cdc_ether_desc e
 #define STATUS_BYTECOUNT		16	/* 8 byte header + data */
 
 static struct usb_endpoint_descriptor
-fs_status_desc = {
+fs_status_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -632,7 +637,7 @@ data_nop_intf = {
 /* ... but the "real" data interface has two bulk endpoints */
 
 static const struct usb_interface_descriptor
-data_intf = {
+data_intf __attribute__((aligned(2))) = {
 	.bLength =		sizeof data_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -652,7 +657,7 @@ data_intf = {
 /* RNDIS doesn't activate by changing to the "real" altsetting */
 
 static const struct usb_interface_descriptor
-rndis_data_intf = {
+rndis_data_intf __attribute__((aligned(2))) = {
 	.bLength =		sizeof rndis_data_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -675,7 +680,7 @@ rndis_data_intf = {
  */
 
 static const struct usb_interface_descriptor
-subset_data_intf = {
+subset_data_intf __attribute__((aligned(2))) = {
 	.bLength =		sizeof subset_data_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -692,7 +697,7 @@ subset_data_intf = {
 
 
 static struct usb_endpoint_descriptor
-fs_source_desc = {
+fs_source_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -701,7 +706,7 @@ fs_source_desc = {
 };
 
 static struct usb_endpoint_descriptor
-fs_sink_desc = {
+fs_sink_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -767,7 +772,7 @@ static const struct usb_descriptor_heade
 
 #if defined(DEV_CONFIG_CDC) || defined(CONFIG_USB_ETH_RNDIS)
 static struct usb_endpoint_descriptor
-hs_status_desc = {
+hs_status_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -778,7 +783,7 @@ hs_status_desc = {
 #endif /* DEV_CONFIG_CDC */
 
 static struct usb_endpoint_descriptor
-hs_source_desc = {
+hs_source_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -787,7 +792,7 @@ hs_source_desc = {
 };
 
 static struct usb_endpoint_descriptor
-hs_sink_desc = {
+hs_sink_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -796,7 +801,7 @@ hs_sink_desc = {
 };
 
 static struct usb_qualifier_descriptor
-dev_qualifier = {
+dev_qualifier __attribute__((aligned(2))) = {
 	.bLength =		sizeof dev_qualifier,
 	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
 
Index: linux-2.6.19-avr1/drivers/usb/gadget/file_storage.c
===================================================================
--- linux-2.6.19-avr1.orig/drivers/usb/gadget/file_storage.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/drivers/usb/gadget/file_storage.c	2006-12-03 19:23:23.000000000 +0100
@@ -854,7 +854,7 @@ static void inline put_be32(u8 *buf, u32
 #define	CONFIG_VALUE		1
 
 static struct usb_device_descriptor
-device_desc = {
+device_desc __attribute__((aligned(2))) = {
 	.bLength =		sizeof device_desc,
 	.bDescriptorType =	USB_DT_DEVICE,
 
@@ -873,7 +873,7 @@ device_desc = {
 };
 
 static struct usb_config_descriptor
-config_desc = {
+config_desc __attribute__((aligned(2))) = {
 	.bLength =		sizeof config_desc,
 	.bDescriptorType =	USB_DT_CONFIG,
 
@@ -896,7 +896,7 @@ otg_desc = {
 /* There is only one interface. */
 
 static struct usb_interface_descriptor
-intf_desc = {
+intf_desc __attribute__((aligned(2))) = {
 	.bLength =		sizeof intf_desc,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -911,7 +911,7 @@ intf_desc = {
  * and interrupt-in. */
 
 static struct usb_endpoint_descriptor
-fs_bulk_in_desc = {
+fs_bulk_in_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -921,7 +921,7 @@ fs_bulk_in_desc = {
 };
 
 static struct usb_endpoint_descriptor
-fs_bulk_out_desc = {
+fs_bulk_out_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -931,7 +931,7 @@ fs_bulk_out_desc = {
 };
 
 static struct usb_endpoint_descriptor
-fs_intr_in_desc = {
+fs_intr_in_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -963,7 +963,7 @@ static const struct usb_descriptor_heade
  * for the config descriptor.
  */
 static struct usb_qualifier_descriptor
-dev_qualifier = {
+dev_qualifier __attribute__((aligned(2))) = {
 	.bLength =		sizeof dev_qualifier,
 	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
 
@@ -974,7 +974,7 @@ dev_qualifier = {
 };
 
 static struct usb_endpoint_descriptor
-hs_bulk_in_desc = {
+hs_bulk_in_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -984,7 +984,7 @@ hs_bulk_in_desc = {
 };
 
 static struct usb_endpoint_descriptor
-hs_bulk_out_desc = {
+hs_bulk_out_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -995,7 +995,7 @@ hs_bulk_out_desc = {
 };
 
 static struct usb_endpoint_descriptor
-hs_intr_in_desc = {
+hs_intr_in_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
Index: linux-2.6.19-avr1/drivers/usb/gadget/serial.c
===================================================================
--- linux-2.6.19-avr1.orig/drivers/usb/gadget/serial.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/drivers/usb/gadget/serial.c	2006-12-03 19:23:23.000000000 +0100
@@ -333,7 +333,7 @@ static struct usb_gadget_strings gs_stri
 	.strings =		gs_strings,
 };
 
-static struct usb_device_descriptor gs_device_desc = {
+static struct usb_device_descriptor __attribute__((aligned(2))) gs_device_desc = {
 	.bLength =		USB_DT_DEVICE_SIZE,
 	.bDescriptorType =	USB_DT_DEVICE,
 	.bcdUSB =		__constant_cpu_to_le16(0x0200),
@@ -353,7 +353,7 @@ static struct usb_otg_descriptor gs_otg_
 	.bmAttributes =		USB_OTG_SRP,
 };
 
-static struct usb_config_descriptor gs_bulk_config_desc = {
+static struct usb_config_descriptor __attribute__((aligned(2))) gs_bulk_config_desc = {
 	.bLength =		USB_DT_CONFIG_SIZE,
 	.bDescriptorType =	USB_DT_CONFIG,
 	/* .wTotalLength computed dynamically */
@@ -364,7 +364,7 @@ static struct usb_config_descriptor gs_b
 	.bMaxPower =		1,
 };
 
-static struct usb_config_descriptor gs_acm_config_desc = {
+static struct usb_config_descriptor __attribute__((aligned(2))) gs_acm_config_desc = {
 	.bLength =		USB_DT_CONFIG_SIZE,
 	.bDescriptorType =	USB_DT_CONFIG,
 	/* .wTotalLength computed dynamically */
@@ -375,7 +375,7 @@ static struct usb_config_descriptor gs_a
 	.bMaxPower =		1,
 };
 
-static const struct usb_interface_descriptor gs_bulk_interface_desc = {
+static const struct usb_interface_descriptor __attribute__((aligned(2))) gs_bulk_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	.bInterfaceNumber =	GS_BULK_INTERFACE_ID,
@@ -386,7 +386,7 @@ static const struct usb_interface_descri
 	.iInterface =		GS_DATA_STR_ID,
 };
 
-static const struct usb_interface_descriptor gs_control_interface_desc = {
+static const struct usb_interface_descriptor __attribute__((aligned(2))) gs_control_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	.bInterfaceNumber =	GS_CONTROL_INTERFACE_ID,
@@ -397,7 +397,7 @@ static const struct usb_interface_descri
 	.iInterface =		GS_CONTROL_STR_ID,
 };
 
-static const struct usb_interface_descriptor gs_data_interface_desc = {
+static const struct usb_interface_descriptor __attribute__((aligned(2))) gs_data_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	.bInterfaceNumber =	GS_DATA_INTERFACE_ID,
@@ -408,7 +408,7 @@ static const struct usb_interface_descri
 	.iInterface =		GS_DATA_STR_ID,
 };
 
-static const struct usb_cdc_header_desc gs_header_desc = {
+static const struct usb_cdc_header_desc __attribute__((aligned(2))) gs_header_desc = {
 	.bLength =		sizeof(gs_header_desc),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_HEADER_TYPE,
@@ -438,7 +438,7 @@ static const struct usb_cdc_union_desc g
 	.bSlaveInterface0 =	1,	/* index of data interface */
 };
  
-static struct usb_endpoint_descriptor gs_fullspeed_notify_desc = {
+static struct usb_endpoint_descriptor __attribute__((aligned(2))) gs_fullspeed_notify_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
@@ -447,14 +447,14 @@ static struct usb_endpoint_descriptor gs
 	.bInterval =		1 << GS_LOG2_NOTIFY_INTERVAL,
 };
 
-static struct usb_endpoint_descriptor gs_fullspeed_in_desc = {
+static struct usb_endpoint_descriptor __attribute__((aligned(2))) gs_fullspeed_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_endpoint_descriptor gs_fullspeed_out_desc = {
+static struct usb_endpoint_descriptor __attribute__((aligned(2))) gs_fullspeed_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_OUT,
@@ -484,7 +484,7 @@ static const struct usb_descriptor_heade
 };
 
 #ifdef CONFIG_USB_GADGET_DUALSPEED
-static struct usb_endpoint_descriptor gs_highspeed_notify_desc = {
+static struct usb_endpoint_descriptor __attribute__((aligned(2))) gs_highspeed_notify_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
@@ -493,21 +493,21 @@ static struct usb_endpoint_descriptor gs
 	.bInterval =		GS_LOG2_NOTIFY_INTERVAL+4,
 };
 
-static struct usb_endpoint_descriptor gs_highspeed_in_desc = {
+static struct usb_endpoint_descriptor __attribute__((aligned(2))) gs_highspeed_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
-static struct usb_endpoint_descriptor gs_highspeed_out_desc = {
+static struct usb_endpoint_descriptor __attribute__((aligned(2))) gs_highspeed_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
-static struct usb_qualifier_descriptor gs_qualifier_desc = {
+static struct usb_qualifier_descriptor __attribute__((aligned(2))) gs_qualifier_desc = {
 	.bLength =		sizeof(struct usb_qualifier_descriptor),
 	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
 	.bcdUSB =		__constant_cpu_to_le16 (0x0200),
Index: linux-2.6.19-avr1/drivers/usb/gadget/zero.c
===================================================================
--- linux-2.6.19-avr1.orig/drivers/usb/gadget/zero.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/drivers/usb/gadget/zero.c	2006-12-03 19:23:23.000000000 +0100
@@ -221,7 +221,7 @@ module_param (loopdefault, bool, S_IRUGO
 #define	CONFIG_LOOPBACK		2
 
 static struct usb_device_descriptor
-device_desc = {
+device_desc __attribute__((aligned(2))) = {
 	.bLength =		sizeof device_desc,
 	.bDescriptorType =	USB_DT_DEVICE,
 
@@ -237,7 +237,7 @@ device_desc = {
 };
 
 static struct usb_config_descriptor
-source_sink_config = {
+source_sink_config __attribute__((aligned(2))) = {
 	.bLength =		sizeof source_sink_config,
 	.bDescriptorType =	USB_DT_CONFIG,
 
@@ -250,7 +250,7 @@ source_sink_config = {
 };
 
 static struct usb_config_descriptor
-loopback_config = {
+loopback_config __attribute__((aligned(2))) = {
 	.bLength =		sizeof loopback_config,
 	.bDescriptorType =	USB_DT_CONFIG,
 
@@ -273,7 +273,7 @@ otg_descriptor = {
 /* one interface in each configuration */
 
 static const struct usb_interface_descriptor
-source_sink_intf = {
+source_sink_intf __attribute__((aligned(2))) = {
 	.bLength =		sizeof source_sink_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -283,7 +283,7 @@ source_sink_intf = {
 };
 
 static const struct usb_interface_descriptor
-loopback_intf = {
+loopback_intf __attribute__((aligned(2))) = {
 	.bLength =		sizeof loopback_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -295,7 +295,7 @@ loopback_intf = {
 /* two full speed bulk endpoints; their use is config-dependent */
 
 static struct usb_endpoint_descriptor
-fs_source_desc = {
+fs_source_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -304,7 +304,7 @@ fs_source_desc = {
 };
 
 static struct usb_endpoint_descriptor
-fs_sink_desc = {
+fs_sink_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -340,7 +340,7 @@ static const struct usb_descriptor_heade
  */
 
 static struct usb_endpoint_descriptor
-hs_source_desc = {
+hs_source_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -349,7 +349,7 @@ hs_source_desc = {
 };
 
 static struct usb_endpoint_descriptor
-hs_sink_desc = {
+hs_sink_desc __attribute__((aligned(2))) = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -358,7 +358,7 @@ hs_sink_desc = {
 };
 
 static struct usb_qualifier_descriptor
-dev_qualifier = {
+dev_qualifier __attribute__((aligned(2))) = {
 	.bLength =		sizeof dev_qualifier,
 	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
 
Index: linux-2.6.19-avr1/include/linux/mtd/physmap.h
===================================================================
--- linux-2.6.19-avr1.orig/include/linux/mtd/physmap.h	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/include/linux/mtd/physmap.h	2006-12-03 19:23:23.000000000 +0100
@@ -18,9 +18,10 @@
 #define __LINUX_MTD_PHYSMAP__
 
 #include <linux/mtd/mtd.h>
-#include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 
+struct map_info;
+
 struct physmap_flash_data {
 	unsigned int		width;
 	void			(*set_vpp)(struct map_info *, int);
Index: linux-2.6.19-avr1/arch/avr32/boards/atstk1000/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/boards/atstk1000/Makefile	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/boards/atstk1000/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -1,2 +1,2 @@
-obj-y				+= setup.o spi.o flash.o
+obj-y				+= setup.o flash.o
 obj-$(CONFIG_BOARD_ATSTK1002)	+= atstk1002.o
Index: linux-2.6.19-avr1/arch/avr32/boards/atstk1000/atstk1002.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/boards/atstk1000/atstk1002.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/boards/atstk1000/atstk1002.c	2006-12-03 19:23:23.000000000 +0100
@@ -7,20 +7,96 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/etherdevice.h>
 #include <linux/init.h>
-
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/spi/spi.h>
+
+#include <asm/io.h>
+#include <asm/setup.h>
+#include <asm/arch/at32ap7000.h>
 #include <asm/arch/board.h>
 #include <asm/arch/init.h>
 
-struct eth_platform_data __initdata eth0_data = {
-	.valid		= 1,
-	.mii_phy_addr	= 0x10,
-	.is_rmii	= 0,
-	.hw_addr	= { 0x6a, 0x87, 0x71, 0x14, 0xcd, 0xcb },
+struct eth_addr {
+	u8 addr[6];
 };
 
+static struct eth_addr __initdata hw_addr[2];
+
+static struct eth_platform_data __initdata eth_data[2];
 extern struct lcdc_platform_data atstk1000_fb0_data;
 
+static struct spi_board_info spi_board_info[] __initdata = {
+	{
+		.modalias	= "ltv350qv",
+		.controller_data = (void *)GPIO_PIN_PA(4),
+		.max_speed_hz	= 16000000,
+		.bus_num	= 0,
+		.chip_select	= 1,
+	},
+};
+
+/*
+ * The next two functions should go away as the boot loader is
+ * supposed to initialize the macb address registers with a valid
+ * ethernet address. But we need to keep it around for a while until
+ * we can be reasonably sure the boot loader does this.
+ *
+ * The phy_id is ignored as the driver will probe for it.
+ */
+static int __init parse_tag_ethernet(struct tag *tag)
+{
+	int i;
+
+	i = tag->u.ethernet.mac_index;
+	if (i < ARRAY_SIZE(hw_addr))
+		memcpy(hw_addr[i].addr, tag->u.ethernet.hw_address,
+		       sizeof(hw_addr[i].addr));
+
+	return 0;
+}
+__tagtable(ATAG_ETHERNET, parse_tag_ethernet);
+
+static void __init set_hw_addr(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	const u8 *addr;
+	void __iomem *regs;
+	struct clk *pclk;
+
+	if (!res)
+		return;
+	if (pdev->id >= ARRAY_SIZE(hw_addr))
+		return;
+
+	addr = hw_addr[pdev->id].addr;
+	if (!is_valid_ether_addr(addr))
+		return;
+
+	/*
+	 * Since this is board-specific code, we'll cheat and use the
+	 * physical address directly as we happen to know that it's
+	 * the same as the virtual address.
+	 */
+	regs = (void __iomem __force *)res->start;
+	pclk = clk_get(&pdev->dev, "pclk");
+	if (!pclk)
+		return;
+
+	clk_enable(pclk);
+	__raw_writel((addr[3] << 24) | (addr[2] << 16)
+		     | (addr[1] << 8) | addr[0], regs + 0x98);
+	__raw_writel((addr[5] << 8) | addr[4], regs + 0x9c);
+	clk_disable(pclk);
+	clk_put(pclk);
+}
+
 void __init setup_board(void)
 {
 	at32_map_usart(1, 0);	/* /dev/ttyS0 */
@@ -38,7 +114,9 @@ static int __init atstk1002_init(void)
 	at32_add_device_usart(1);
 	at32_add_device_usart(2);
 
-	at32_add_device_eth(0, &eth0_data);
+	set_hw_addr(at32_add_device_eth(0, &eth_data[0]));
+
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
 	at32_add_device_spi(0);
 	at32_add_device_lcdc(0, &atstk1000_fb0_data);
 
Index: linux-2.6.19-avr1/arch/avr32/boards/atstk1000/spi.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/boards/atstk1000/spi.c	2006-12-03 19:23:21.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,27 +0,0 @@
-/*
- * ATSTK1000 SPI devices
- *
- * Copyright (C) 2005 Atmel Norway
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/device.h>
-#include <linux/spi/spi.h>
-
-static struct spi_board_info spi_board_info[] __initdata = {
-	{
-		.modalias	= "ltv350qv",
-		.max_speed_hz	= 16000000,
-		.bus_num	= 0,
-		.chip_select	= 1,
-	},
-};
-
-static int board_init_spi(void)
-{
-	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
-	return 0;
-}
-arch_initcall(board_init_spi);
Index: linux-2.6.19-avr1/arch/avr32/kernel/kprobes.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/kernel/kprobes.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/kernel/kprobes.c	2006-12-03 19:23:23.000000000 +0100
@@ -154,6 +154,7 @@ ss_probe:
 	return 1;
 
 no_kprobe:
+	preempt_enable_no_resched();
 	return ret;
 }
 
Index: linux-2.6.19-avr1/arch/avr32/kernel/setup.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/kernel/setup.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/kernel/setup.c	2006-12-03 19:23:23.000000000 +0100
@@ -229,30 +229,6 @@ static int __init parse_tag_rsvd_mem(str
 }
 __tagtable(ATAG_RSVD_MEM, parse_tag_rsvd_mem);
 
-static int __init parse_tag_ethernet(struct tag *tag)
-{
-#if 0
-	const struct platform_device *pdev;
-
-	/*
-	 * We really need a bus type that supports "classes"...this
-	 * will do for now (until we must handle other kinds of
-	 * ethernet controllers)
-	 */
-	pdev = platform_get_device("macb", tag->u.ethernet.mac_index);
-	if (pdev && pdev->dev.platform_data) {
-		struct eth_platform_data *data = pdev->dev.platform_data;
-
-		data->valid = 1;
-		data->mii_phy_addr = tag->u.ethernet.mii_phy_addr;
-		memcpy(data->hw_addr, tag->u.ethernet.hw_address,
-		       sizeof(data->hw_addr));
-	}
-#endif
-	return 0;
-}
-__tagtable(ATAG_ETHERNET, parse_tag_ethernet);
-
 /*
  * Scan the tag table for this tag, and call its parse function. The
  * tag table is built by the linker from all the __tagtable
Index: linux-2.6.19-avr1/arch/avr32/mach-at32ap/at32ap7000.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/mach-at32ap/at32ap7000.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/mach-at32ap/at32ap7000.c	2006-12-03 19:23:23.000000000 +0100
@@ -11,8 +11,9 @@
 
 #include <asm/io.h>
 
+#include <asm/arch/at32ap7000.h>
 #include <asm/arch/board.h>
-#include <asm/arch/portmux.h>
+#include <asm/arch/gpio.h>
 #include <asm/arch/sm.h>
 
 #include "clock.h"
@@ -67,17 +68,8 @@ static struct clk devname##_##_name = {	
 	.index		= _index,				\
 }
 
-enum {
-	PIOA,
-	PIOB,
-	PIOC,
-	PIOD,
-};
-
-enum {
-	FUNC_A,
-	FUNC_B,
-};
+#define select_peripheral(pin, periph, pullup)				\
+	at32_select_periph(GPIO_PIN_##pin, GPIO_##periph, pullup)
 
 unsigned long at32ap7000_osc_rates[3] = {
 	[0] = 32768,
@@ -569,26 +561,26 @@ DEV_CLK(usart, atmel_usart3, pba, 6);
 
 static inline void configure_usart0_pins(void)
 {
-	portmux_set_func(PIOA,  8, FUNC_B);	/* RXD	*/
-	portmux_set_func(PIOA,  9, FUNC_B);	/* TXD	*/
+	select_peripheral(PA(8), PERIPH_B, 0);	/* RXD	*/
+	select_peripheral(PA(9), PERIPH_B, 0);	/* TXD	*/
 }
 
 static inline void configure_usart1_pins(void)
 {
-	portmux_set_func(PIOA, 17, FUNC_A);	/* RXD	*/
-	portmux_set_func(PIOA, 18, FUNC_A);	/* TXD	*/
+	select_peripheral(PA(17), PERIPH_A, 0);	/* RXD	*/
+	select_peripheral(PA(18), PERIPH_A, 0);	/* TXD	*/
 }
 
 static inline void configure_usart2_pins(void)
 {
-	portmux_set_func(PIOB, 26, FUNC_B);	/* RXD	*/
-	portmux_set_func(PIOB, 27, FUNC_B);	/* TXD	*/
+	select_peripheral(PB(26), PERIPH_B, 0);	/* RXD	*/
+	select_peripheral(PB(27), PERIPH_B, 0);	/* TXD	*/
 }
 
 static inline void configure_usart3_pins(void)
 {
-	portmux_set_func(PIOB, 18, FUNC_B);	/* RXD	*/
-	portmux_set_func(PIOB, 17, FUNC_B);	/* TXD	*/
+	select_peripheral(PB(18), PERIPH_B, 0);	/* RXD	*/
+	select_peripheral(PB(17), PERIPH_B, 0);	/* TXD	*/
 }
 
 static struct platform_device *at32_usarts[4];
@@ -654,6 +646,15 @@ DEFINE_DEV_DATA(macb, 0);
 DEV_CLK(hclk, macb0, hsb, 8);
 DEV_CLK(pclk, macb0, pbb, 6);
 
+static struct eth_platform_data macb1_data;
+static struct resource macb1_resource[] = {
+	PBMEM(0xfff01c00),
+	IRQ(26),
+};
+DEFINE_DEV_DATA(macb, 1);
+DEV_CLK(hclk, macb1, hsb, 9);
+DEV_CLK(pclk, macb1, pbb, 7);
+
 struct platform_device *__init
 at32_add_device_eth(unsigned int id, struct eth_platform_data *data)
 {
@@ -663,27 +664,54 @@ at32_add_device_eth(unsigned int id, str
 	case 0:
 		pdev = &macb0_device;
 
-		portmux_set_func(PIOC,  3, FUNC_A);	/* TXD0	*/
-		portmux_set_func(PIOC,  4, FUNC_A);	/* TXD1	*/
-		portmux_set_func(PIOC,  7, FUNC_A);	/* TXEN	*/
-		portmux_set_func(PIOC,  8, FUNC_A);	/* TXCK */
-		portmux_set_func(PIOC,  9, FUNC_A);	/* RXD0	*/
-		portmux_set_func(PIOC, 10, FUNC_A);	/* RXD1	*/
-		portmux_set_func(PIOC, 13, FUNC_A);	/* RXER	*/
-		portmux_set_func(PIOC, 15, FUNC_A);	/* RXDV	*/
-		portmux_set_func(PIOC, 16, FUNC_A);	/* MDC	*/
-		portmux_set_func(PIOC, 17, FUNC_A);	/* MDIO	*/
+		select_peripheral(PC(3), PERIPH_A, 0);		/* TXD0	*/
+		select_peripheral(PC(4), PERIPH_A, 0);		/* TXD1	*/
+		select_peripheral(PC(7), PERIPH_A, 0);		/* TXEN	*/
+		select_peripheral(PC(8), PERIPH_A, 0);		/* TXCK */
+		select_peripheral(PC(9), PERIPH_A, 0);		/* RXD0	*/
+		select_peripheral(PC(10), PERIPH_A, 0);		/* RXD1	*/
+		select_peripheral(PC(13), PERIPH_A, 0);		/* RXER	*/
+		select_peripheral(PC(15), PERIPH_A, 0);		/* RXDV	*/
+		select_peripheral(PC(16), PERIPH_A, 0);		/* MDC	*/
+		select_peripheral(PC(17), PERIPH_A, 0);		/* MDIO	*/
+
+		if (!data->is_rmii) {
+			select_peripheral(PC(0), PERIPH_A, 0);	/* COL	*/
+			select_peripheral(PC(1), PERIPH_A, 0);	/* CRS	*/
+			select_peripheral(PC(2), PERIPH_A, 0);	/* TXER	*/
+			select_peripheral(PC(5), PERIPH_A, 0);	/* TXD2	*/
+			select_peripheral(PC(6), PERIPH_A, 0);	/* TXD3 */
+			select_peripheral(PC(11), PERIPH_A, 0);	/* RXD2	*/
+			select_peripheral(PC(12), PERIPH_A, 0);	/* RXD3	*/
+			select_peripheral(PC(14), PERIPH_A, 0);	/* RXCK	*/
+			select_peripheral(PC(18), PERIPH_A, 0);	/* SPD	*/
+		}
+		break;
+
+	case 1:
+		pdev = &macb1_device;
+
+		select_peripheral(PD(13), PERIPH_B, 0);		/* TXD0	*/
+		select_peripheral(PD(14), PERIPH_B, 0);		/* TXD1	*/
+		select_peripheral(PD(11), PERIPH_B, 0);		/* TXEN	*/
+		select_peripheral(PD(12), PERIPH_B, 0);		/* TXCK */
+		select_peripheral(PD(10), PERIPH_B, 0);		/* RXD0	*/
+		select_peripheral(PD(6),  PERIPH_B, 0);		/* RXD1	*/
+		select_peripheral(PD(5),  PERIPH_B, 0);		/* RXER	*/
+		select_peripheral(PD(4),  PERIPH_B, 0);		/* RXDV	*/
+		select_peripheral(PD(3),  PERIPH_B, 0);		/* MDC	*/
+		select_peripheral(PD(2),  PERIPH_B, 0);		/* MDIO	*/
 
 		if (!data->is_rmii) {
-			portmux_set_func(PIOC,  0, FUNC_A);	/* COL	*/
-			portmux_set_func(PIOC,  1, FUNC_A);	/* CRS	*/
-			portmux_set_func(PIOC,  2, FUNC_A);	/* TXER	*/
-			portmux_set_func(PIOC,  5, FUNC_A);	/* TXD2	*/
-			portmux_set_func(PIOC,  6, FUNC_A);	/* TXD3 */
-			portmux_set_func(PIOC, 11, FUNC_A);	/* RXD2	*/
-			portmux_set_func(PIOC, 12, FUNC_A);	/* RXD3	*/
-			portmux_set_func(PIOC, 14, FUNC_A);	/* RXCK	*/
-			portmux_set_func(PIOC, 18, FUNC_A);	/* SPD	*/
+			select_peripheral(PC(19), PERIPH_B, 0);	/* COL	*/
+			select_peripheral(PC(23), PERIPH_B, 0);	/* CRS	*/
+			select_peripheral(PC(26), PERIPH_B, 0);	/* TXER	*/
+			select_peripheral(PC(27), PERIPH_B, 0);	/* TXD2	*/
+			select_peripheral(PC(28), PERIPH_B, 0);	/* TXD3 */
+			select_peripheral(PC(29), PERIPH_B, 0);	/* RXD2	*/
+			select_peripheral(PC(30), PERIPH_B, 0);	/* RXD3	*/
+			select_peripheral(PC(24), PERIPH_B, 0);	/* RXCK	*/
+			select_peripheral(PD(15), PERIPH_B, 0);	/* SPD	*/
 		}
 		break;
 
@@ -700,12 +728,19 @@ at32_add_device_eth(unsigned int id, str
 /* --------------------------------------------------------------------
  *  SPI
  * -------------------------------------------------------------------- */
-static struct resource spi0_resource[] = {
+static struct resource atmel_spi0_resource[] = {
 	PBMEM(0xffe00000),
 	IRQ(3),
 };
-DEFINE_DEV(spi, 0);
-DEV_CLK(mck, spi0, pba, 0);
+DEFINE_DEV(atmel_spi, 0);
+DEV_CLK(pclk, atmel_spi0, pba, 0);
+
+static struct resource atmel_spi1_resource[] = {
+	PBMEM(0xffe00400),
+	IRQ(4),
+};
+DEFINE_DEV(atmel_spi, 1);
+DEV_CLK(pclk, atmel_spi1, pba, 1);
 
 struct platform_device *__init at32_add_device_spi(unsigned int id)
 {
@@ -713,13 +748,33 @@ struct platform_device *__init at32_add_
 
 	switch (id) {
 	case 0:
-		pdev = &spi0_device;
-		portmux_set_func(PIOA,  0, FUNC_A);	/* MISO	 */
-		portmux_set_func(PIOA,  1, FUNC_A);	/* MOSI	 */
-		portmux_set_func(PIOA,  2, FUNC_A);	/* SCK	 */
-		portmux_set_func(PIOA,  3, FUNC_A);	/* NPCS0 */
-		portmux_set_func(PIOA,  4, FUNC_A);	/* NPCS1 */
-		portmux_set_func(PIOA,  5, FUNC_A);	/* NPCS2 */
+		pdev = &atmel_spi0_device;
+		select_peripheral(PA(0), PERIPH_A, 0);	/* MISO	 */
+		select_peripheral(PA(1), PERIPH_A, 0);	/* MOSI	 */
+		select_peripheral(PA(2), PERIPH_A, 0);	/* SCK	 */
+
+		/* NPCS[2:0] */
+		at32_select_gpio(GPIO_PIN_PA(3),
+				 AT32_GPIOF_OUTPUT | AT32_GPIOF_HIGH);
+		at32_select_gpio(GPIO_PIN_PA(4),
+				 AT32_GPIOF_OUTPUT | AT32_GPIOF_HIGH);
+		at32_select_gpio(GPIO_PIN_PA(5),
+				 AT32_GPIOF_OUTPUT | AT32_GPIOF_HIGH);
+		break;
+
+	case 1:
+		pdev = &atmel_spi1_device;
+		select_peripheral(PB(0), PERIPH_B, 0);	/* MISO  */
+		select_peripheral(PB(1), PERIPH_B, 0);	/* MOSI  */
+		select_peripheral(PB(5), PERIPH_B, 0);	/* SCK   */
+
+		/* NPCS[2:0] */
+		at32_select_gpio(GPIO_PIN_PB(2),
+				 AT32_GPIOF_OUTPUT | AT32_GPIOF_HIGH);
+		at32_select_gpio(GPIO_PIN_PB(3),
+				 AT32_GPIOF_OUTPUT | AT32_GPIOF_HIGH);
+		at32_select_gpio(GPIO_PIN_PB(4),
+				 AT32_GPIOF_OUTPUT | AT32_GPIOF_HIGH);
 		break;
 
 	default:
@@ -762,37 +817,37 @@ at32_add_device_lcdc(unsigned int id, st
 	switch (id) {
 	case 0:
 		pdev = &lcdc0_device;
-		portmux_set_func(PIOC, 19, FUNC_A);	/* CC	  */
-		portmux_set_func(PIOC, 20, FUNC_A);	/* HSYNC  */
-		portmux_set_func(PIOC, 21, FUNC_A);	/* PCLK	  */
-		portmux_set_func(PIOC, 22, FUNC_A);	/* VSYNC  */
-		portmux_set_func(PIOC, 23, FUNC_A);	/* DVAL	  */
-		portmux_set_func(PIOC, 24, FUNC_A);	/* MODE	  */
-		portmux_set_func(PIOC, 25, FUNC_A);	/* PWR	  */
-		portmux_set_func(PIOC, 26, FUNC_A);	/* DATA0  */
-		portmux_set_func(PIOC, 27, FUNC_A);	/* DATA1  */
-		portmux_set_func(PIOC, 28, FUNC_A);	/* DATA2  */
-		portmux_set_func(PIOC, 29, FUNC_A);	/* DATA3  */
-		portmux_set_func(PIOC, 30, FUNC_A);	/* DATA4  */
-		portmux_set_func(PIOC, 31, FUNC_A);	/* DATA5  */
-		portmux_set_func(PIOD,  0, FUNC_A);	/* DATA6  */
-		portmux_set_func(PIOD,  1, FUNC_A);	/* DATA7  */
-		portmux_set_func(PIOD,  2, FUNC_A);	/* DATA8  */
-		portmux_set_func(PIOD,  3, FUNC_A);	/* DATA9  */
-		portmux_set_func(PIOD,  4, FUNC_A);	/* DATA10 */
-		portmux_set_func(PIOD,  5, FUNC_A);	/* DATA11 */
-		portmux_set_func(PIOD,  6, FUNC_A);	/* DATA12 */
-		portmux_set_func(PIOD,  7, FUNC_A);	/* DATA13 */
-		portmux_set_func(PIOD,  8, FUNC_A);	/* DATA14 */
-		portmux_set_func(PIOD,  9, FUNC_A);	/* DATA15 */
-		portmux_set_func(PIOD, 10, FUNC_A);	/* DATA16 */
-		portmux_set_func(PIOD, 11, FUNC_A);	/* DATA17 */
-		portmux_set_func(PIOD, 12, FUNC_A);	/* DATA18 */
-		portmux_set_func(PIOD, 13, FUNC_A);	/* DATA19 */
-		portmux_set_func(PIOD, 14, FUNC_A);	/* DATA20 */
-		portmux_set_func(PIOD, 15, FUNC_A);	/* DATA21 */
-		portmux_set_func(PIOD, 16, FUNC_A);	/* DATA22 */
-		portmux_set_func(PIOD, 17, FUNC_A);	/* DATA23 */
+		select_peripheral(PC(19), PERIPH_A, 0);	/* CC	  */
+		select_peripheral(PC(20), PERIPH_A, 0);	/* HSYNC  */
+		select_peripheral(PC(21), PERIPH_A, 0);	/* PCLK	  */
+		select_peripheral(PC(22), PERIPH_A, 0);	/* VSYNC  */
+		select_peripheral(PC(23), PERIPH_A, 0);	/* DVAL	  */
+		select_peripheral(PC(24), PERIPH_A, 0);	/* MODE	  */
+		select_peripheral(PC(25), PERIPH_A, 0);	/* PWR	  */
+		select_peripheral(PC(26), PERIPH_A, 0);	/* DATA0  */
+		select_peripheral(PC(27), PERIPH_A, 0);	/* DATA1  */
+		select_peripheral(PC(28), PERIPH_A, 0);	/* DATA2  */
+		select_peripheral(PC(29), PERIPH_A, 0);	/* DATA3  */
+		select_peripheral(PC(30), PERIPH_A, 0);	/* DATA4  */
+		select_peripheral(PC(31), PERIPH_A, 0);	/* DATA5  */
+		select_peripheral(PD(0), PERIPH_A, 0);	/* DATA6  */
+		select_peripheral(PD(1), PERIPH_A, 0);	/* DATA7  */
+		select_peripheral(PD(2), PERIPH_A, 0);	/* DATA8  */
+		select_peripheral(PD(3), PERIPH_A, 0);	/* DATA9  */
+		select_peripheral(PD(4), PERIPH_A, 0);	/* DATA10 */
+		select_peripheral(PD(5), PERIPH_A, 0);	/* DATA11 */
+		select_peripheral(PD(6), PERIPH_A, 0);	/* DATA12 */
+		select_peripheral(PD(7), PERIPH_A, 0);	/* DATA13 */
+		select_peripheral(PD(8), PERIPH_A, 0);	/* DATA14 */
+		select_peripheral(PD(9), PERIPH_A, 0);	/* DATA15 */
+		select_peripheral(PD(10), PERIPH_A, 0);	/* DATA16 */
+		select_peripheral(PD(11), PERIPH_A, 0);	/* DATA17 */
+		select_peripheral(PD(12), PERIPH_A, 0);	/* DATA18 */
+		select_peripheral(PD(13), PERIPH_A, 0);	/* DATA19 */
+		select_peripheral(PD(14), PERIPH_A, 0);	/* DATA20 */
+		select_peripheral(PD(15), PERIPH_A, 0);	/* DATA21 */
+		select_peripheral(PD(16), PERIPH_A, 0);	/* DATA22 */
+		select_peripheral(PD(17), PERIPH_A, 0);	/* DATA23 */
 
 		clk_set_parent(&lcdc0_pixclk, &pll0);
 		clk_set_rate(&lcdc0_pixclk, clk_get_rate(&pll0));
@@ -838,7 +893,10 @@ struct clk *at32_clock_list[] = {
 	&atmel_usart3_usart,
 	&macb0_hclk,
 	&macb0_pclk,
-	&spi0_mck,
+	&macb1_hclk,
+	&macb1_pclk,
+	&atmel_spi0_pclk,
+	&atmel_spi1_pclk,
 	&lcdc0_hclk,
 	&lcdc0_pixclk,
 };
Index: linux-2.6.19-avr1/arch/avr32/mach-at32ap/pio.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/mach-at32ap/pio.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/mach-at32ap/pio.c	2006-12-03 19:23:24.000000000 +0100
@@ -11,57 +11,900 @@
 #include <linux/clk.h>
 #include <linux/debugfs.h>
 #include <linux/fs.h>
+#include <linux/irq.h>
 #include <linux/platform_device.h>
 
+#include <asm/gpio.h>
 #include <asm/io.h>
 
-#include <asm/arch/portmux.h>
-
 #include "pio.h"
 
 #define MAX_NR_PIO_DEVICES		8
 
 struct pio_device {
 	void __iomem *regs;
-	const struct platform_device *pdev;
+	struct platform_device *pdev;
 	struct clk *clk;
-	u32 alloc_mask;
+	u32 pinmux_mask;
+	u32 gpio_mask;
 	char name[32];
 };
 
 static struct pio_device pio_dev[MAX_NR_PIO_DEVICES];
 
-void portmux_set_func(unsigned int portmux_id, unsigned int pin_id,
-		      unsigned int function_id)
+static struct pio_device *gpio_to_pio(unsigned int gpio)
 {
 	struct pio_device *pio;
-	u32 mask = 1 << pin_id;
+	unsigned int index;
+
+	index = gpio >> 5;
+	if (index >= MAX_NR_PIO_DEVICES)
+		return NULL;
+	pio = &pio_dev[index];
+	if (!pio->regs)
+		return NULL;
 
-	BUG_ON(portmux_id >= MAX_NR_PIO_DEVICES);
+	return pio;
+}
 
-	pio = &pio_dev[portmux_id];
+/* Pin multiplexing API */
 
-	if (function_id)
+void __init at32_select_periph(unsigned int pin, unsigned int periph,
+			       unsigned long flags)
+{
+	struct pio_device *pio;
+	unsigned int pin_index = pin & 0x1f;
+	u32 mask = 1 << pin_index;
+
+	pio = gpio_to_pio(pin);
+	if (unlikely(!pio)) {
+		printk("pio: invalid pin %u\n", pin);
+		goto fail;
+	}
+
+	if (unlikely(test_and_set_bit(pin_index, &pio->pinmux_mask))) {
+		printk("%s: pin %u is busy\n", pio->name, pin_index);
+		goto fail;
+	}
+
+	pio_writel(pio, PUER, mask);
+	if (periph)
 		pio_writel(pio, BSR, mask);
 	else
 		pio_writel(pio, ASR, mask);
+
 	pio_writel(pio, PDR, mask);
+	if (!(flags & AT32_GPIOF_PULLUP))
+		pio_writel(pio, PUDR, mask);
+
+	return;
+
+fail:
+	dump_stack();
+}
+
+void __init at32_select_gpio(unsigned int pin, unsigned long flags)
+{
+	struct pio_device *pio;
+	unsigned int pin_index = pin & 0x1f;
+	u32 mask = 1 << pin_index;
+
+	pio = gpio_to_pio(pin);
+	if (unlikely(!pio)) {
+		printk("pio: invalid pin %u\n", pin);
+		goto fail;
+	}
+
+	if (unlikely(test_and_set_bit(pin_index, &pio->pinmux_mask))) {
+		printk("%s: pin %u is busy\n", pio->name, pin_index);
+		goto fail;
+	}
+
+	pio_writel(pio, PUER, mask);
+	if (flags & AT32_GPIOF_HIGH)
+		pio_writel(pio, SODR, mask);
+	else
+		pio_writel(pio, CODR, mask);
+	if (flags & AT32_GPIOF_OUTPUT)
+		pio_writel(pio, OER, mask);
+	else
+		pio_writel(pio, ODR, mask);
+
+	pio_writel(pio, PER, mask);
+	if (!(flags & AT32_GPIOF_PULLUP))
+		pio_writel(pio, PUDR, mask);
+
+	/* It's now allowed to use request_gpio on this pin */
+	clear_bit(pin_index, &pio->gpio_mask);
+
+	return;
+
+fail:
+	dump_stack();
+}
+
+void at32_set_deglitch(unsigned int pin, int enable)
+{
+	struct pio_device *pio;
+	u32 mask = 1 << (pin & 0x1f);
+
+	pio = gpio_to_pio(pin);
+	if (enable)
+		pio_writel(pio, IFER, mask);
+	else
+		pio_writel(pio, IFDR, mask);
+}
+
+static unsigned int pio_id(struct pio_device *pio)
+{
+	return pio - pio_dev;
+}
+
+static void __disable_gpio(struct pio_device *pio, u32 mask)
+{
+	pio_writel(pio, PUER, mask);
+	pio_writel(pio, ODR, mask);
+}
+
+static void pio_dealloc_mask(struct pio_device *pio, u32 mask)
+{
+	u32 old, new;
+
+	do {
+		old = pio->pinmux_mask;
+		new = old & ~mask;
+	} while (cmpxchg(&pio->pinmux_mask, old, new) != old);
+}
+
+/* GPIO API */
+
+int gpio_request(unsigned int gpio, const char *label)
+{
+	struct pio_device *pio;
+	unsigned int pin;
+
+	pio = gpio_to_pio(gpio);
+	if (!pio)
+		return -ENODEV;
+
+	pin = gpio & 0x1f;
+	if (test_and_set_bit(pin, &pio->gpio_mask))
+		return -EBUSY;
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_request);
+
+void gpio_free(unsigned int gpio)
+{
+	struct pio_device *pio;
+	unsigned int pin;
+
+	pio = gpio_to_pio(gpio);
+	if (!pio) {
+		printk(KERN_ERR
+		       "gpio: attempted to free invalid pin %u\n", gpio);
+		return;
+	}
+
+	pin = gpio & 0x1f;
+	if (!test_and_clear_bit(pin, &pio->gpio_mask))
+		printk(KERN_ERR "gpio: freeing already-free pin %s[%u]\n",
+		       pio->name, pin);
+}
+EXPORT_SYMBOL(gpio_free);
+
+int gpio_direction_input(unsigned int gpio)
+{
+	struct pio_device *pio;
+	unsigned int pin;
+
+	pio = gpio_to_pio(gpio);
+	if (!pio)
+		return -ENODEV;
+
+	pin = gpio & 0x1f;
+	pio_writel(pio, ODR, 1 << pin);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_direction_input);
+
+int gpio_direction_output(unsigned int gpio)
+{
+	struct pio_device *pio;
+	unsigned int pin;
+
+	pio = gpio_to_pio(gpio);
+	if (!pio)
+		return -ENODEV;
+
+	pin = gpio & 0x1f;
+	pio_writel(pio, OER, 1 << pin);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_direction_output);
+
+int gpio_get_value(unsigned int gpio)
+{
+	struct pio_device *pio = &pio_dev[gpio >> 5];
+
+	return (pio_readl(pio, PDSR) >> (gpio & 0x1f)) & 1;
+}
+EXPORT_SYMBOL(gpio_get_value);
+
+void gpio_set_value(unsigned int gpio, int value)
+{
+	struct pio_device *pio = &pio_dev[gpio >> 5];
+	u32 mask;
+
+	mask = 1 << (gpio & 0x1f);
+	if (value)
+		pio_writel(pio, SODR, mask);
+	else
+		pio_writel(pio, CODR, mask);
+}
+EXPORT_SYMBOL(gpio_set_value);
+
+#ifdef CONFIG_PIO_DEV
+#include <linux/configfs.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+
+#define GPIO_DEV_MAX			8
+
+static struct class *gpio_dev_class;
+static dev_t gpio_devt;
+
+struct gpio_item {
+	spinlock_t lock;
+
+	struct pio_device *pio;
+
+	int enabled;
+	int pio_id;
+	u32 pin_mask;
+	u32 oe_mask;
+
+	/* Pin state last time we read it (for blocking reads) */
+	u32 pin_state;
+	int changed;
+
+	wait_queue_head_t change_wq;
+	struct fasync_struct *async_queue;
+
+	int id;
+	struct class_device *gpio_dev;
+	struct cdev char_dev;
+	struct config_item item;
+};
+
+struct gpio_attribute {
+	struct configfs_attribute attr;
+	ssize_t (*show)(struct gpio_item *, char *);
+	ssize_t (*store)(struct gpio_item *, const char *, size_t);
+};
+
+static irqreturn_t gpio_dev_interrupt(int irq, void *dev_id)
+{
+	struct gpio_item *gpio = dev_id;
+	u32 old_state, new_state;
+
+	old_state = gpio->pin_state;
+	new_state = pio_readl(gpio->pio, PDSR);
+	gpio->pin_state = new_state;
+
+	if (new_state != old_state) {
+		gpio->changed = 1;
+		wake_up_interruptible(&gpio->change_wq);
+
+		if (gpio->async_queue)
+			kill_fasync(&gpio->async_queue, SIGIO, POLL_IN);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int gpio_dev_open(struct inode *inode, struct file *file)
+{
+	struct gpio_item *gpio = container_of(inode->i_cdev,
+					      struct gpio_item,
+					      char_dev);
+	unsigned int irq;
+	unsigned int i;
+	int ret;
+
+	nonseekable_open(inode, file);
+	config_item_get(&gpio->item);
+	file->private_data = gpio;
+
+	gpio->pin_state = pio_readl(gpio->pio, PDSR) & gpio->pin_mask;
+	gpio->changed = 1;
+
+	for (i = 0; i < 32; i++) {
+		if (gpio->pin_mask & (1 << i)) {
+			irq = gpio_to_irq(32 * pio_id(gpio->pio) + i);
+			ret = request_irq(irq, gpio_dev_interrupt, 0,
+					  "gpio-dev", gpio);
+			if (ret)
+				goto err_irq;
+		}
+	}
+
+	return 0;
+
+err_irq:
+	while (i--) {
+		if (gpio->pin_mask & (1 << i)) {
+			irq = gpio_to_irq(32 * pio_id(gpio->pio) + i);
+			free_irq(irq, gpio);
+		}
+	}
+
+	config_item_put(&gpio->item);
+
+	return ret;
+}
+
+static int gpio_dev_fasync(int fd, struct file *file, int mode)
+{
+	struct gpio_item *gpio = file->private_data;
+
+	return fasync_helper(fd, file, mode, &gpio->async_queue);
+}
+
+static int gpio_dev_release(struct inode *inode, struct file *file)
+{
+	struct gpio_item *gpio = file->private_data;
+	unsigned int irq;
+	unsigned int i;
+
+	gpio_dev_fasync(-1, file, 0);
+
+	for (i = 0; i < 32; i++) {
+		if (gpio->pin_mask & (1 << i)) {
+			irq = gpio_to_irq(32 * pio_id(gpio->pio) + i);
+			free_irq(irq, gpio);
+		}
+	}
+
+	config_item_put(&gpio->item);
+
+	return 0;
+}
+
+static unsigned int gpio_dev_poll(struct file *file, poll_table *wait)
+{
+	struct gpio_item *gpio = file->private_data;
+	unsigned int mask = 0;
+
+	poll_wait(file, &gpio->change_wq, wait);
+	if (gpio->changed)
+		mask |= POLLIN | POLLRDNORM;
+
+	return mask;
+}
+
+static ssize_t gpio_dev_read(struct file *file, char __user *buf,
+			     size_t count, loff_t *offset)
+{
+	struct gpio_item *gpio = file->private_data;
+	u32 value;
+
+	spin_lock_irq(&gpio->lock);
+	while (!gpio->changed) {
+		spin_unlock_irq(&gpio->lock);
+
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(gpio->change_wq, gpio->changed))
+			return -ERESTARTSYS;
+
+		spin_lock_irq(&gpio->lock);
+	}
+
+	gpio->changed = 0;
+	value = pio_readl(gpio->pio, PDSR) & gpio->pin_mask;
+
+	spin_unlock_irq(&gpio->lock);
+
+	count = min(count, (size_t)4);
+	if (copy_to_user(buf, &value, count))
+		return -EFAULT;
+
+	return count;
+}
+
+static ssize_t gpio_dev_write(struct file *file, const char __user *buf,
+			      size_t count, loff_t *offset)
+{
+	struct gpio_item *gpio = file->private_data;
+	u32 value = 0;
+	u32 mask = ~0UL;
+
+	count = min(count, (size_t)4);
+	if (copy_from_user(&value, buf, count))
+		return -EFAULT;
+
+	/* Assuming big endian */
+	mask <<= (4 - count) * 8;
+	mask &= gpio->pin_mask;
+
+	pio_writel(gpio->pio, CODR, ~value & mask);
+	pio_writel(gpio->pio, SODR, value & mask);
+
+	return count;
+}
+
+static struct file_operations gpio_dev_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.open		= gpio_dev_open,
+	.release	= gpio_dev_release,
+	.fasync		= gpio_dev_fasync,
+	.poll		= gpio_dev_poll,
+	.read		= gpio_dev_read,
+	.write		= gpio_dev_write,
+};
+
+static struct gpio_item *to_gpio_item(struct config_item *item)
+{
+	return item ? container_of(item, struct gpio_item, item) : NULL;
+}
+
+static ssize_t gpio_show_gpio_id(struct gpio_item *gpio, char *page)
+{
+	return sprintf(page, "%d\n", gpio->pio_id);
+}
+
+static ssize_t gpio_store_gpio_id(struct gpio_item *gpio,
+				  const char *page, size_t count)
+{
+	unsigned long id;
+	char *p = (char *)page;
+	ssize_t ret = -EINVAL;
+
+	id = simple_strtoul(p, &p, 0);
+	if (!p || (*p && (*p != '\n')))
+		return -EINVAL;
+
+	/* Switching PIO is not allowed when live... */
+	spin_lock(&gpio->lock);
+	if (!gpio->enabled) {
+		ret = -ENXIO;
+		if ((id < MAX_NR_PIO_DEVICES) && pio_dev[id].regs) {
+			gpio->pio_id = id;
+			ret = count;
+		}
+	}
+	spin_unlock(&gpio->lock);
+
+	return ret;
+}
+
+static ssize_t gpio_show_pin_mask(struct gpio_item *gpio, char *page)
+{
+	return sprintf(page, "0x%08x\n", gpio->pin_mask);
+}
+
+static ssize_t gpio_store_pin_mask(struct gpio_item *gpio,
+				   const char *page, size_t count)
+{
+	u32 new_mask;
+	char *p = (char *)page;
+	ssize_t ret = -EINVAL;
+
+	new_mask = simple_strtoul(p, &p, 0);
+	if (!p || (*p && (*p != '\n')))
+		return -EINVAL;
+
+	/* Can't update the pin mask while live. */
+	spin_lock(&gpio->lock);
+	if (!gpio->enabled) {
+		gpio->oe_mask &= new_mask;
+		gpio->pin_mask = new_mask;
+		ret = count;
+	}
+	spin_unlock(&gpio->lock);
+
+	return ret;
+}
+
+static ssize_t gpio_show_oe_mask(struct gpio_item *gpio, char *page)
+{
+	return sprintf(page, "0x%08x\n", gpio->oe_mask);
+}
+
+static ssize_t gpio_store_oe_mask(struct gpio_item *gpio,
+				  const char *page, size_t count)
+{
+	u32 mask;
+	char *p = (char *)page;
+	ssize_t ret = -EINVAL;
+
+	mask = simple_strtoul(p, &p, 0);
+	if (!p || (*p && (*p != '\n')))
+		return -EINVAL;
+
+	spin_lock(&gpio->lock);
+	if (!gpio->enabled) {
+		gpio->oe_mask = mask & gpio->pin_mask;
+		ret = count;
+	}
+	spin_unlock(&gpio->lock);
+
+	return ret;
+}
+
+static ssize_t gpio_show_enabled(struct gpio_item *gpio, char *page)
+{
+	return sprintf(page, "%d\n", gpio->enabled);
+}
+
+static ssize_t gpio_store_enabled(struct gpio_item *gpio,
+				  const char *page, size_t count)
+{
+	struct pio_device *pio;
+	u32 old, new;
+	char *p = (char *)page;
+	int enabled;
+	int ret;
+
+	enabled = simple_strtoul(p, &p, 0);
+	if (!p || (*p && (*p != '\n')))
+		return -EINVAL;
+
+	/* make it a boolean value */
+	enabled = !!enabled;
+
+	if (gpio->enabled == enabled)
+		/* Already enabled; do nothing. */
+		return count;
+
+	BUG_ON(gpio->id >= GPIO_DEV_MAX);
+
+	if (!enabled) {
+		class_device_unregister(gpio->gpio_dev);
+		cdev_del(&gpio->char_dev);
+		__disable_gpio(gpio->pio, gpio->pin_mask);
+		pio_dealloc_mask(gpio->pio, gpio->pin_mask);
+		gpio->pio = NULL;
+	} else {
+		if (gpio->pio_id < 0 || !gpio->pin_mask)
+			return -ENODEV;
+	}
+
+	/* Disallow any updates to gpio_id or pin_mask */
+	spin_lock(&gpio->lock);
+	gpio->enabled = enabled;
+	spin_unlock(&gpio->lock);
+
+	if (!enabled)
+		return count;
+
+	/* Now, try to allocate the pins */
+	ret = -EBUSY;
+	pio = gpio->pio = &pio_dev[gpio->pio_id];
+	do {
+		old = pio->pinmux_mask;
+		if (old & gpio->pin_mask)
+			goto err_alloc_pins;
+
+		new = old | gpio->pin_mask;
+	} while (cmpxchg(&pio->pinmux_mask, old, new) != old);
+
+	pio_writel(pio, OER, gpio->oe_mask);
+	pio_writel(pio, PER, gpio->pin_mask);
+
+	cdev_init(&gpio->char_dev, &gpio_dev_fops);
+	gpio->char_dev.owner = THIS_MODULE;
+	ret = cdev_add(&gpio->char_dev, MKDEV(MAJOR(gpio_devt), gpio->id), 1);
+	if (ret < 0)
+		goto err_cdev_add;
+	gpio->gpio_dev = class_device_create(gpio_dev_class, NULL,
+					     MKDEV(MAJOR(gpio_devt), gpio->id),
+					     &gpio->pio->pdev->dev,
+					     "gpio%d", gpio->id);
+	if (IS_ERR(gpio->gpio_dev)) {
+		printk(KERN_ERR "failed to create gpio%d\n", gpio->id);
+		ret = PTR_ERR(gpio->gpio_dev);
+		goto err_class_dev;
+	}
+
+	printk(KERN_INFO "created gpio%d (pio%d/0x%08x) as (%d:%d)\n",
+	       gpio->id, pio_id(gpio->pio), gpio->pin_mask,
+	       MAJOR(gpio->gpio_dev->devt), MINOR(gpio->gpio_dev->devt));
+
+	return 0;
+
+err_class_dev:
+	cdev_del(&gpio->char_dev);
+err_cdev_add:
+	__disable_gpio(pio, gpio->pin_mask);
+	pio_dealloc_mask(pio, gpio->pin_mask);
+err_alloc_pins:
+	spin_lock(&gpio->lock);
+	gpio->enabled = 0;
+	spin_unlock(&gpio->lock);
+	gpio->pio = NULL;
+
+	return ret;
+}
+
+static struct gpio_attribute gpio_item_attr_gpio_id = {
+	.attr = {
+		.ca_owner = THIS_MODULE,
+		.ca_name = "gpio_id",
+		.ca_mode = S_IRUGO | S_IWUSR,
+	},
+	.show = gpio_show_gpio_id,
+	.store = gpio_store_gpio_id,
+};
+static struct gpio_attribute gpio_item_attr_pin_mask = {
+	.attr = {
+		.ca_owner = THIS_MODULE,
+		.ca_name = "pin_mask",
+		.ca_mode = S_IRUGO | S_IWUSR,
+	},
+	.show = gpio_show_pin_mask,
+	.store = gpio_store_pin_mask,
+};
+static struct gpio_attribute gpio_item_attr_oe_mask = {
+	.attr = {
+		.ca_owner = THIS_MODULE,
+		.ca_name = "oe_mask",
+		.ca_mode = S_IRUGO | S_IWUSR,
+	},
+	.show = gpio_show_oe_mask,
+	.store = gpio_store_oe_mask,
+};
+static struct gpio_attribute gpio_item_attr_enabled = {
+	.attr = {
+		.ca_owner = THIS_MODULE,
+		.ca_name = "enabled",
+		.ca_mode = S_IRUGO | S_IWUSR,
+	},
+	.show = gpio_show_enabled,
+	.store = gpio_store_enabled,
+};
+
+static struct configfs_attribute *gpio_item_attrs[] = {
+	&gpio_item_attr_gpio_id.attr,
+	&gpio_item_attr_pin_mask.attr,
+	&gpio_item_attr_oe_mask.attr,
+	&gpio_item_attr_enabled.attr,
+	NULL,
+};
+
+static ssize_t gpio_show_attr(struct config_item *item,
+			      struct configfs_attribute *attr,
+			      char *page)
+{
+	struct gpio_item *gpio_item = to_gpio_item(item);
+	struct gpio_attribute *gpio_attr
+		= container_of(attr, struct gpio_attribute, attr);
+	ssize_t ret = 0;
+
+	if (gpio_attr->show)
+		ret = gpio_attr->show(gpio_item, page);
+	return ret;
+}
+
+static ssize_t gpio_store_attr(struct config_item *item,
+			       struct configfs_attribute *attr,
+			       const char *page, size_t count)
+{
+	struct gpio_item *gpio_item = to_gpio_item(item);
+	struct gpio_attribute *gpio_attr
+		= container_of(attr, struct gpio_attribute, attr);
+	ssize_t ret = -EINVAL;
+
+	if (gpio_attr->store)
+		ret = gpio_attr->store(gpio_item, page, count);
+	return ret;
+}
+
+static void gpio_release(struct config_item *item)
+{
+	kfree(to_gpio_item(item));
+}
+
+static struct configfs_item_operations gpio_item_ops = {
+	.release		= gpio_release,
+	.show_attribute		= gpio_show_attr,
+	.store_attribute	= gpio_store_attr,
+};
+
+static struct config_item_type gpio_item_type = {
+	.ct_item_ops	= &gpio_item_ops,
+	.ct_attrs	= gpio_item_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_item *gpio_make_item(struct config_group *group,
+					  const char *name)
+{
+	static int next_id;
+	struct gpio_item *gpio;
+
+	if (next_id >= GPIO_DEV_MAX)
+		return NULL;
+
+	gpio = kzalloc(sizeof(struct gpio_item), GFP_KERNEL);
+	if (!gpio)
+		return NULL;
+
+	gpio->id = next_id++;
+	config_item_init_type_name(&gpio->item, name, &gpio_item_type);
+	spin_lock_init(&gpio->lock);
+	init_waitqueue_head(&gpio->change_wq);
+
+	return &gpio->item;
+}
+
+static void gpio_drop_item(struct config_group *group,
+			   struct config_item *item)
+{
+	struct gpio_item *gpio = to_gpio_item(item);
+	struct pio_device *pio;
+
+	spin_lock(&gpio->lock);
+	if (gpio->enabled) {
+		class_device_unregister(gpio->gpio_dev);
+		cdev_del(&gpio->char_dev);
+	}
+
+	pio = gpio->pio;
+	if (pio) {
+		__disable_gpio(pio, gpio->pin_mask);
+		pio_dealloc_mask(pio, gpio->pin_mask);
+		gpio->pio = NULL;
+	}
+	spin_unlock(&gpio->lock);
+}
+
+static struct configfs_group_operations gpio_group_ops = {
+	.make_item	= gpio_make_item,
+	.drop_item	= gpio_drop_item,
+};
+
+static struct config_item_type gpio_group_type = {
+	.ct_group_ops	= &gpio_group_ops,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct configfs_subsystem gpio_subsys = {
+	.su_group = {
+		.cg_item = {
+			 .ci_namebuf = "gpio",
+			 .ci_type = &gpio_group_type,
+		 },
+	},
+};
+
+static int __init pio_init_dev(void)
+{
+	int err;
+
+	gpio_dev_class = class_create(THIS_MODULE, "gpio-dev");
+	if (IS_ERR(gpio_dev_class)) {
+		err = PTR_ERR(gpio_dev_class);
+		goto err_class_create;
+	}
+
+	err = alloc_chrdev_region(&gpio_devt, 0, GPIO_DEV_MAX, "gpio");
+	if (err < 0)
+		goto err_alloc_chrdev;
+
+	/* Configfs initialization */
+	config_group_init(&gpio_subsys.su_group);
+	init_MUTEX(&gpio_subsys.su_sem);
+	err = configfs_register_subsystem(&gpio_subsys);
+	if (err)
+		goto err_register_subsys;
+
+	return 0;
+
+err_register_subsys:
+	unregister_chrdev_region(gpio_devt, GPIO_DEV_MAX);
+err_alloc_chrdev:
+	class_destroy(gpio_dev_class);
+err_class_create:
+	printk(KERN_WARNING "Failed to initialize gpio /dev interface\n");
+	return err;
+}
+late_initcall(pio_init_dev);
+#endif /* CONFIG_PIO_DEV */
+
+/* Interrupt controller implementation */
+static void pio_mask_irq(unsigned int irq)
+{
+	struct pio_device *pio = get_irq_chip_data(irq);
+
+	pio_writel(pio, IDR, 1 << (irq & 0x1f));
+}
+
+static void pio_unmask_irq(unsigned int irq)
+{
+	struct pio_device *pio = get_irq_chip_data(irq);
+
+	pio_writel(pio, IER, 1 << (irq & 0x1f));
+}
+
+static int pio_set_irq_type(unsigned int irq, unsigned int flow_type)
+{
+	if (flow_type != IRQ_TYPE_NONE && flow_type != IRQ_TYPE_EDGE_BOTH)
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct irq_chip pio_irq_chip = {
+	.name		= "pio",
+	.mask		= pio_mask_irq,
+	.unmask		= pio_unmask_irq,
+	.set_type	= pio_set_irq_type,
+};
+
+static void demux_pio_irq(unsigned int irq, struct irq_desc *desc)
+{
+	struct pio_device *pio = desc->handler_data;
+	struct irq_desc *ext_desc;
+	u32 status, pending;
+	unsigned int ext_irq;
+	unsigned int i;
+
+	status = pio_readl(pio, ISR);
+	pending = status & pio_readl(pio, IMR);
+
+	while (pending) {
+		i = fls(pending) - 1;
+		pending &= ~(1 << i);
+
+		ext_irq = gpio_to_irq(32 * pio_id(pio) + i);
+		ext_desc = irq_desc + ext_irq;
+		ext_desc->handle_irq(ext_irq, ext_desc);
+	}
 }
 
 static int __init pio_probe(struct platform_device *pdev)
 {
 	struct pio_device *pio = NULL;
+	unsigned int i;
+	int int_irq, ext_irq;
 
 	BUG_ON(pdev->id >= MAX_NR_PIO_DEVICES);
 	pio = &pio_dev[pdev->id];
 	BUG_ON(!pio->regs);
 
-	/* TODO: Interrupts */
+	/* Set up interrupts */
+	pio_writel(pio, IDR, ~0UL);
+	pio_readl(pio, ISR);
+
+	ext_irq = gpio_to_irq(32 * pdev->id);
+	for (i = 0; i < 32; i++, ext_irq++) {
+		set_irq_chip_and_handler(ext_irq, &pio_irq_chip,
+					 handle_simple_irq);
+		set_irq_chip_data(ext_irq, pio);
+	}
+
+	int_irq = platform_get_irq(pdev, 0);
+	set_irq_chained_handler(int_irq, demux_pio_irq);
+	set_irq_data(int_irq, pio);
 
 	platform_set_drvdata(pdev, pio);
 
 	printk(KERN_INFO "%s: Atmel Port Multiplexer at 0x%p (irq %d)\n",
 	       pio->name, pio->regs, platform_get_irq(pdev, 0));
+	printk(KERN_INFO
+	       "%s: Handling 32 external IRQs, starting with IRQ %d\n",
+	       pio->name, ext_irq - 32);
 
 	return 0;
 }
@@ -113,6 +956,12 @@ void __init at32_init_pio(struct platfor
 	pio->pdev = pdev;
 	pio->regs = ioremap(regs->start, regs->end - regs->start + 1);
 
+	/*
+	 * request_gpio() is only valid for pins that have been
+	 * configured as GPIO.
+	 */
+	pio->gpio_mask = ~0UL;
+
 	pio_writel(pio, ODR, ~0UL);
 	pio_writel(pio, PER, ~0UL);
 }
Index: linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/at32ap7000.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/at32ap7000.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,26 @@
+#ifndef __ASM_ARCH_AT32AP7000_H
+#define __ASM_ARCH_AT32AP7000_H
+
+#define GPIO_PERIPH_A	0
+#define GPIO_PERIPH_B	1
+
+#define NR_GPIO_CONTROLLERS	4
+
+/*
+ * Pin numbers identifying specific GPIO pins on the chip. They can
+ * also be converted to IRQ numbers by passing them through
+ * gpio_to_irq().
+ */
+#define GPIO_PIOA_BASE	(0)
+#define GPIO_PIOB_BASE	(GPIO_PIOA_BASE + 32)
+#define GPIO_PIOC_BASE	(GPIO_PIOB_BASE + 32)
+#define GPIO_PIOD_BASE	(GPIO_PIOC_BASE + 32)
+#define GPIO_PIOE_BASE	(GPIO_PIOD_BASE + 32)
+
+#define GPIO_PIN_PA(N)	(GPIO_PIOA_BASE + (N))
+#define GPIO_PIN_PB(N)	(GPIO_PIOB_BASE + (N))
+#define GPIO_PIN_PC(N)	(GPIO_PIOC_BASE + (N))
+#define GPIO_PIN_PD(N)	(GPIO_PIOD_BASE + (N))
+#define GPIO_PIN_PE(N)	(GPIO_PIOE_BASE + (N))
+
+#endif /* __ASM_ARCH_AT32AP7000_H */
Index: linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/board.h
===================================================================
--- linux-2.6.19-avr1.orig/include/asm-avr32/arch-at32ap/board.h	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/board.h	2006-12-03 19:23:23.000000000 +0100
@@ -21,10 +21,7 @@ void at32_map_usart(unsigned int hw_id, 
 struct platform_device *at32_add_device_usart(unsigned int id);
 
 struct eth_platform_data {
-	u8	valid;
-	u8	mii_phy_addr;
 	u8	is_rmii;
-	u8	hw_addr[6];
 };
 struct platform_device *
 at32_add_device_eth(unsigned int id, struct eth_platform_data *data);
Index: linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/gpio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/gpio.h	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,40 @@
+#ifndef __ASM_AVR32_ARCH_GPIO_H
+#define __ASM_AVR32_ARCH_GPIO_H
+
+#include <linux/compiler.h>
+#include <asm/irq.h>
+
+/*
+ * Set up pin multiplexing, called from board init only.
+ *
+ * The following flags determine the initial state of the pin.
+ */
+#define AT32_GPIOF_PULLUP	0x00000001	/* Enable pull-up */
+#define AT32_GPIOF_OUTPUT	0x00000002	/* Enable output driver */
+#define AT32_GPIOF_HIGH		0x00000004	/* Set output high */
+
+void at32_select_periph(unsigned int pin, unsigned int periph,
+			unsigned long flags);
+void at32_select_gpio(unsigned int pin, unsigned long flags);
+void at32_set_deglitch(unsigned int pin, int enable);
+
+/* Arch-neutral GPIO API */
+int __must_check gpio_request(unsigned int gpio, const char *label);
+void gpio_free(unsigned int gpio);
+
+int gpio_direction_input(unsigned int gpio);
+int gpio_direction_output(unsigned int gpio);
+int gpio_get_value(unsigned int gpio);
+void gpio_set_value(unsigned int gpio, int value);
+
+static inline int gpio_to_irq(unsigned int gpio)
+{
+	return gpio + GPIO_IRQ_BASE;
+}
+
+static inline int irq_to_gpio(unsigned int irq)
+{
+	return irq - GPIO_IRQ_BASE;
+}
+
+#endif /* __ASM_AVR32_ARCH_GPIO_H */
Index: linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/irq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/irq.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef __ASM_AVR32_ARCH_IRQ_H
+#define __ASM_AVR32_ARCH_IRQ_H
+
+#define EIM_IRQ_BASE	NR_INTERNAL_IRQS
+#define NR_EIM_IRQS	32
+#define GPIO_IRQ_BASE	(EIM_IRQ_BASE + NR_EIM_IRQS)
+#define NR_GPIO_IRQS	(4 * 32)
+
+#define NR_IRQS		(GPIO_IRQ_BASE + NR_GPIO_IRQS)
+
+#endif /* __ASM_AVR32_ARCH_IRQ_H */
Index: linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/portmux.h
===================================================================
--- linux-2.6.19-avr1.orig/include/asm-avr32/arch-at32ap/portmux.h	2006-12-03 19:23:21.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,16 +0,0 @@
-/*
- * AT32 portmux interface.
- *
- * Copyright (C) 2006 Atmel Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#ifndef __ASM_AVR32_AT32_PORTMUX_H__
-#define __ASM_AVR32_AT32_PORTMUX_H__
-
-void portmux_set_func(unsigned int portmux_id, unsigned int pin_id,
-		      unsigned int function_id);
-
-#endif /* __ASM_AVR32_AT32_PORTMUX_H__ */
Index: linux-2.6.19-avr1/include/asm-avr32/gpio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/include/asm-avr32/gpio.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __ASM_AVR32_GPIO_H
+#define __ASM_AVR32_GPIO_H
+
+#include <asm/arch/gpio.h>
+
+#endif /* __ASM_AVR32_GPIO_H */
Index: linux-2.6.19-avr1/include/asm-avr32/irq.h
===================================================================
--- linux-2.6.19-avr1.orig/include/asm-avr32/irq.h	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/include/asm-avr32/irq.h	2006-12-03 19:23:23.000000000 +0100
@@ -2,8 +2,12 @@
 #define __ASM_AVR32_IRQ_H
 
 #define NR_INTERNAL_IRQS	64
-#define NR_EXTERNAL_IRQS	64
-#define NR_IRQS			(NR_INTERNAL_IRQS + NR_EXTERNAL_IRQS)
+
+#include <asm/arch/irq.h>
+
+#ifndef NR_IRQS
+#define NR_IRQS			(NR_INTERNAL_IRQS)
+#endif
 
 #define irq_canonicalize(i)	(i)
 
Index: linux-2.6.19-avr1/arch/avr32/kernel/avr32_ksyms.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/kernel/avr32_ksyms.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/kernel/avr32_ksyms.c	2006-12-03 19:23:23.000000000 +0100
@@ -7,12 +7,12 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+#include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/module.h>
 
 #include <asm/checksum.h>
 #include <asm/uaccess.h>
-#include <asm/delay.h>
 
 /*
  * GCC functions
Index: linux-2.6.19-avr1/arch/avr32/lib/delay.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/lib/delay.c	2006-12-03 19:23:21.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/lib/delay.c	2006-12-03 19:23:23.000000000 +0100
@@ -14,7 +14,6 @@
 #include <linux/module.h>
 #include <linux/types.h>
 
-#include <asm/delay.h>
 #include <asm/processor.h>
 #include <asm/sysreg.h>
 
Index: linux-2.6.19-avr1/scripts/checkstack.pl
===================================================================
--- linux-2.6.19-avr1.orig/scripts/checkstack.pl	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/scripts/checkstack.pl	2006-12-03 19:23:23.000000000 +0100
@@ -12,6 +12,7 @@
 #	sh64 port by Paul Mundt
 #	Random bits by Matt Mackall <mpm@selenic.com>
 #	M68k port by Geert Uytterhoeven and Andreas Schwab
+#	AVR32 port by Haavard Skinnemoen <hskinnemoen@atmel.com>
 #
 #	Usage:
 #	objdump -d vmlinux | stackcheck.pl [arch]
@@ -37,6 +38,10 @@ my (@stack, $re, $x, $xs);
 	if ($arch eq 'arm') {
 		#c0008ffc:	e24dd064	sub	sp, sp, #100	; 0x64
 		$re = qr/.*sub.*sp, sp, #(([0-9]{2}|[3-9])[0-9]{2})/o;
+	} elsif ($arch eq 'avr32') {
+		#8000008a:       20 1d           sub sp,4
+		#80000ca8:       fa cd 05 b0     sub sp,sp,1456
+		$re = qr/^.*sub.*sp.*,([0-9]{1,8})/o;
 	} elsif ($arch =~ /^i[3456]86$/) {
 		#c0105234:       81 ec ac 05 00 00       sub    $0x5ac,%esp
 		$re = qr/^.*[as][du][db]    \$(0x$x{1,8}),\%esp$/o;
Index: linux-2.6.19-avr1/arch/avr32/oprofile/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/oprofile/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,23 @@
+
+menu "Profiling support"
+	depends on EXPERIMENTAL
+
+config PROFILING
+	bool "Profiling support (EXPERIMENTAL)"
+	help
+	  Say Y here to enable the extended profiling support mechanisms used
+	  by profilers such as OProfile.
+
+
+config OPROFILE
+	tristate "OProfile system profiling (EXPERIMENTAL)"
+	depends on PROFILING
+	help
+	  OProfile is a profiling system capable of profiling the
+	  whole system, including the kernel, kernel modules, libraries,
+	  and applications.
+
+	  If unsure, say N.
+
+endmenu
+
Index: linux-2.6.19-avr1/arch/avr32/oprofile/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/oprofile/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,10 @@
+obj-$(CONFIG_OPROFILE) += oprofile.o
+
+DRIVER_OBJS = $(addprefix ../../../drivers/oprofile/, \
+		oprof.o cpu_buffer.o buffer_sync.o \
+		event_buffer.o oprofile_files.o \
+		oprofilefs.o oprofile_stats.o \
+		timer_int.o )
+
+oprofile-y				:= $(DRIVER_OBJS) init.o common.o
+oprofile-y				+= op_model_avr32.o
Index: linux-2.6.19-avr1/arch/avr32/oprofile/common.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/oprofile/common.c	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Author: Ronny Pedersen
+ */
+
+#define DEBUG
+#include <linux/init.h>
+#include <linux/oprofile.h>
+#include <linux/errno.h>
+#include <asm/semaphore.h>
+#include <linux/sysdev.h>
+
+#include "op_avr32_model.h"
+#include "op_counter.h"
+
+static struct op_avr32_model_spec *pc_model;
+static int pc_enabled = 0;
+static struct semaphore pc_sem;
+
+
+static int pc_start(void);
+static int pc_setup(void);
+static void pc_stop(void);
+static int pc_create_files(struct super_block *, struct dentry *);
+
+
+struct op_counter_config counter_config[OP_MAX_COUNTER];
+
+static int pc_suspend(struct sys_device *dev, u32 state)
+{
+	if (pc_enabled)
+		pc_stop();
+	return 0;
+}
+
+static int pc_resume(struct sys_device *dev)
+{
+	if (pc_enabled)
+		pc_start();
+	return 0;
+}
+
+static struct sysdev_class oprofile_sysclass = {
+	set_kset_name("oprofile"),
+	.resume		= pc_resume,
+	.suspend	= pc_suspend,
+};
+
+static struct sys_device device_oprofile = {
+	.id		= 0,
+	.cls		= &oprofile_sysclass,
+};
+
+static int __init init_driverfs(void)
+{
+	int ret;
+
+	if (!(ret = sysdev_class_register(&oprofile_sysclass)))
+		ret = sysdev_register(&device_oprofile);
+
+	return ret;
+}
+
+static void  exit_driverfs(void)
+{
+	sysdev_unregister(&device_oprofile);
+	sysdev_class_unregister(&oprofile_sysclass);
+}
+
+static int pc_create_files(struct super_block *sb, struct dentry *root)
+{
+	unsigned int i;
+
+	pr_debug("AVR32 Peformance Counters: create files\n");
+	for (i = 0; i < pc_model->num_counters; i++) {
+		struct dentry *dir;
+		char buf[2];
+
+		snprintf(buf, sizeof buf, "%d", i);
+		dir = oprofilefs_mkdir(sb, root, buf);
+		oprofilefs_create_ulong(sb, dir, "enabled",
+					&counter_config[i].enabled);
+		oprofilefs_create_ulong(sb, dir, "event",
+					&counter_config[i].event);
+		oprofilefs_create_ulong(sb, dir, "count",
+					&counter_config[i].count);
+		oprofilefs_create_ulong(sb, dir, "unit_mask",
+					&counter_config[i].unit_mask);
+		oprofilefs_create_ulong(sb, dir, "kernel",
+					&counter_config[i].kernel);
+		oprofilefs_create_ulong(sb, dir, "user",
+					&counter_config[i].user);
+	}
+
+	return 0;
+}
+
+static int pc_setup(void)
+{
+	int ret;
+
+	spin_lock(&oprofilefs_lock);
+	pr_debug("AVR32 Peformance Counters: setup\n");
+	ret = pc_model->setup_ctrs();
+	spin_unlock(&oprofilefs_lock);
+	return ret;
+}
+
+static int pc_start(void)
+{
+	int ret = -EBUSY;
+
+	down(&pc_sem);
+	if (!pc_enabled) {
+		pr_debug("AVR32 Peformance Counters: start\n");
+		ret = pc_model->start();
+		pc_enabled = !ret;
+	}
+	up(&pc_sem);
+	return ret;
+}
+
+static void pc_stop(void)
+{
+	down(&pc_sem);
+	pr_debug("AVR32 Peformance Counters: stop\n");
+	if (pc_enabled)
+		pc_model->stop();
+	pc_enabled = 0;
+	up(&pc_sem);
+}
+
+int __init pc_init(struct oprofile_operations *ops,
+		   struct op_avr32_model_spec *spec)
+{
+	init_MUTEX(&pc_sem);
+
+	if ( spec->init )
+		if (spec->init() < 0)
+			return -ENODEV;
+
+	pc_model = spec;
+	init_driverfs();
+	ops->create_files = pc_create_files;
+	ops->setup = pc_setup;
+	ops->shutdown = pc_stop;
+	ops->start = pc_start;
+	ops->stop = pc_stop;
+	ops->cpu_type = pc_model->name;
+	printk(KERN_INFO "oprofile: using %s Performance Counters\n",
+	       spec->name);
+	pr_debug("AVR32 Peformance Counters: pc_init\n");
+
+	return 0;
+}
+
+void pc_exit(void)
+{
+	if (pc_model) {
+		pr_debug("AVR32 Peformance Counters: exit\n");
+		exit_driverfs();
+		pc_model = NULL;
+	}
+}
Index: linux-2.6.19-avr1/arch/avr32/oprofile/init.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/oprofile/init.c	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Author: Ronny Pedersen
+ */
+
+#include <linux/oprofile.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include "op_avr32_model.h"
+#include "op_model_avr32.h"
+
+int __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+	int ret = -ENODEV;
+
+	ret = pc_init(ops, &op_avr32_spec);
+
+	return ret;
+}
+
+void oprofile_arch_exit(void)
+{
+	pc_exit();
+}
Index: linux-2.6.19-avr1/arch/avr32/oprofile/op_avr32_model.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/oprofile/op_avr32_model.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+ * interface to AVR32 machine specific operations
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Author: Ronny Pedersen
+ */
+
+#ifndef OP_AVR32_MODEL_H
+#define OP_AVR32_MODEL_H
+
+struct op_avr32_model_spec {
+	int (*init)(void);
+	unsigned int num_counters;
+	int (*setup_ctrs)(void);
+	int (*start)(void);
+	void (*stop)(void);
+	char *name;
+};
+
+#endif /* OP_AVR32_MODEL_H */
Index: linux-2.6.19-avr1/arch/avr32/oprofile/op_counter.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/oprofile/op_counter.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Author: Ronny Pedersen
+ */
+#ifndef OP_COUNTER_H
+#define OP_COUNTER_H
+
+#define OP_MAX_COUNTER 3
+
+/* Per performance monitor configuration as set via
+ * oprofilefs.
+ */
+struct op_counter_config {
+	unsigned long count;
+	unsigned long enabled;
+	unsigned long event;
+	unsigned long unit_mask;
+	unsigned long kernel;
+	unsigned long user;
+};
+
+extern struct op_counter_config counter_config[];
+
+#endif /* OP_COUNTER_H */
Index: linux-2.6.19-avr1/arch/avr32/oprofile/op_model_avr32.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/oprofile/op_model_avr32.c	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,219 @@
+/*
+ * AVR32 Performance Counter Driver
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Author: Ronny Pedersen
+ */
+
+#define DEBUG
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/sysreg.h>
+
+#include "op_counter.h"
+#include "op_avr32_model.h"
+
+
+#define	PC_ENABLE	0x001	/* Enable counters */
+#define PCNT_RESET	0x002	/* Reset event counters */
+#define	CCNT_RESET	0x004	/* Reset clock counter */
+#define	PC_RESET	(CCNT_RESET | PCNT_RESET)
+#define PC_CNT64	0x008	/* Make CCNT count every 64th cycle */
+
+
+#define EVT_UNUSED			0xFF
+
+struct pc_counter {
+	volatile unsigned long ovf;
+	unsigned long reset_counter;
+};
+
+enum { PCCNT, PCNT0, PCNT1, MAX_COUNTERS };
+
+#define PCCNT_IE  (1 << 4)
+#define PCNT0_IE  (1 << 5)
+#define PCNT1_IE  (1 << 6)
+
+#define PCCNT_F  (1 << 8)
+#define PCNT0_F  (1 << 9)
+#define PCNT1_F  (1 << 10)
+
+#define AVR32_PC_IRQ 1
+
+static const u32 int_mask[MAX_COUNTERS] = { PCCNT_IE, PCNT0_IE, PCNT1_IE };
+static const u32 ovf_mask[MAX_COUNTERS] = { PCCNT_F, PCNT0_F, PCNT1_F };
+
+static struct pc_counter results[MAX_COUNTERS];
+
+static void write_pccr(u32 val)
+{
+	__builtin_mtsr(SYSREG_PCCR, val);
+}
+
+static u32 read_pccr(void)
+{
+	return __builtin_mfsr(SYSREG_PCCR);
+}
+
+static u32 read_counter(int counter)
+{
+	switch (counter) {
+	case PCCNT:
+		return __builtin_mfsr(SYSREG_PCCNT);
+	case PCNT0:
+		return __builtin_mfsr(SYSREG_PCNT0);
+	case PCNT1:
+		return __builtin_mfsr(SYSREG_PCNT0);
+	default:
+		return 0;
+	}
+}
+
+
+static void write_counter(int counter, u32 val)
+{
+	switch (counter) {
+	case PCCNT:
+		__builtin_mtsr(SYSREG_PCCNT, val);
+	case PCNT0:
+		__builtin_mtsr(SYSREG_PCNT0, val);
+	case PCNT1:
+		__builtin_mtsr(SYSREG_PCNT0, val);
+	default:
+		break;
+	}
+}
+
+static int avr32_setup_ctrs(void)
+{
+	u32  pccr;
+	int i;
+
+	for (i = PCCNT; i < MAX_COUNTERS; i++) {
+		if (counter_config[i].enabled)
+			continue;
+
+		counter_config[i].event = EVT_UNUSED;
+	}
+
+	pccr = ((counter_config[PCNT1].event << 18)
+		| (counter_config[PCNT0].event << 12));
+	pr_debug("avr32_setup_ctrs: pccr: %#08x\n", pccr);
+	write_pccr(pccr);
+
+	for (i = PCCNT; i < MAX_COUNTERS; i++) {
+		if (counter_config[i].event == EVT_UNUSED) {
+			counter_config[i].event = 0;
+			continue;
+		}
+
+		results[i].reset_counter = counter_config[i].count;
+		write_counter(i, -(u32)counter_config[i].count);
+		pr_debug("avr32_setup_ctrs: counter%d %#08x from %#08lx\n",
+			 i, read_counter(i), counter_config[i].count);
+	}
+
+	return 0;
+}
+
+static void inline check_ctrs(void)
+{
+	int i;
+	u32 pccr = read_pccr();
+
+	/* Writeback clears overflow flag */
+	write_pccr(pccr & ~PC_ENABLE);
+
+	for (i = PCCNT; i < MAX_COUNTERS; i++) {
+		if (!(int_mask[i] & pccr))
+			continue;
+
+		if (pccr & ovf_mask[i])
+			results[i].ovf++;
+	}
+}
+
+
+static irqreturn_t avr32_pc_interrupt(int irq, void *arg,
+				      struct pt_regs *regs)
+{
+	int i;
+
+	check_ctrs();
+
+	for (i = PCCNT; i < MAX_COUNTERS; i++) {
+		if (!results[i].ovf)
+			continue;
+
+		write_counter(i, -(u32)results[i].reset_counter);
+		oprofile_add_sample(regs, i);
+		results[i].ovf--;
+	}
+
+	/* Enable Performance Counter */
+	write_pccr(read_pccr() | PC_ENABLE);
+
+	return IRQ_HANDLED;
+}
+
+static void avr32_pc_stop(void)
+{
+	write_pccr(read_pccr() & ~PC_ENABLE);
+
+	free_irq(AVR32_PC_IRQ, results);
+}
+
+static int avr32_pc_start(void)
+{
+	int i, ret;
+	u32 pccr = read_pccr();
+
+	ret = request_irq(AVR32_PC_IRQ, avr32_pc_interrupt, SA_INTERRUPT,
+			  "AVR32 Performance Counter", (void *)results);
+
+	if (ret < 0) {
+		printk(KERN_ERR
+		       "oprofile: unable to request IRQ%d for AVR32"
+		       " Performance Counter\n",
+		       AVR32_PC_IRQ);
+		return ret;
+	}
+
+	/* Enable interrupts */
+	for (i = PCCNT; i < MAX_COUNTERS; i++) {
+		if (counter_config[i].enabled)
+			pccr |= int_mask[i];
+	}
+
+	/* Disable scaler */
+	pccr &= ~PC_CNT64;
+
+	/* Enable Performance Counter */
+	pccr |= PC_ENABLE;
+
+	write_pccr(pccr);
+	pr_debug("avr32_pc_start: pc: %#08x\n", pccr);
+	return 0;
+}
+
+
+struct op_avr32_model_spec op_avr32_spec = {
+	.init		= 0,
+	.setup_ctrs	= avr32_setup_ctrs,
+	.start		= avr32_pc_start,
+	.stop		= avr32_pc_stop,
+	.num_counters	= MAX_COUNTERS,
+	.name		= "avr32",
+};
+
Index: linux-2.6.19-avr1/arch/avr32/oprofile/op_model_avr32.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/oprofile/op_model_avr32.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,21 @@
+/**
+ * AVR32 Machine Specific Operations
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Author: Ronny Pedersen
+ */
+#ifndef OP_MODEL_AVR32_H
+#define OP_MODEL_AVR32_H
+
+extern struct op_avr32_model_spec op_avr32_spec;
+extern int pc_init(struct oprofile_operations *ops,
+		   struct op_avr32_model_spec *spec);
+extern void pc_exit(void);
+
+
+#endif
Index: linux-2.6.19-avr1/arch/avr32/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/Kconfig	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -104,6 +104,8 @@ config	LOADER_U_BOOT
 	bool "U-Boot (or similar) bootloader"
 endchoice
 
+source "arch/avr32/mach-at32ap/Kconfig"
+
 config LOAD_ADDRESS
 	hex
 	default 0x10000000 if LOADER_U_BOOT=y && CPU_AT32AP7000=y
@@ -152,6 +154,10 @@ config OWNERSHIP_TRACE
 	  enabling Nexus-compliant debuggers to keep track of the PID of the
 	  currently executing task.
 
+config DW_DMAC
+	tristate "Synopsys DesignWare DMA Controller support"
+	default y if CPU_AT32AP7000
+
 # FPU emulation goes here
 
 source "kernel/Kconfig.hz"
@@ -187,6 +193,8 @@ source "drivers/Kconfig"
 
 source "fs/Kconfig"
 
+source "arch/avr32/oprofile/Kconfig"
+
 source "arch/avr32/Kconfig.debug"
 
 source "security/Kconfig"
Index: linux-2.6.19-avr1/arch/avr32/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -30,6 +30,8 @@ core-$(CONFIG_BOARD_ATSTK1000)		+= arch/
 core-$(CONFIG_LOADER_U_BOOT)		+= arch/avr32/boot/u-boot/
 core-y					+= arch/avr32/kernel/
 core-y					+= arch/avr32/mm/
+drivers-y				+= arch/avr32/drivers/
+drivers-$(CONFIG_OPROFILE)		+= arch/avr32/oprofile/
 libs-y					+= arch/avr32/lib/
 
 archincdir-$(CONFIG_PLATFORM_AT32AP)	:= arch-at32ap
Index: linux-2.6.19-avr1/arch/avr32/mm/dma-coherent.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/mm/dma-coherent.c	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/mm/dma-coherent.c	2006-12-03 19:23:23.000000000 +0100
@@ -41,6 +41,13 @@ static struct page *__dma_alloc(struct d
 	struct page *page, *free, *end;
 	int order;
 
+	/* Following is a work-around (a.k.a. hack) to prevent pages
+	 * with __GFP_COMP being passed to split_page() which cannot
+	 * handle them.  The real problem is that this flag probably
+	 * should be 0 on AVR32 as it is not supported on this
+	 * platform--see CONFIG_HUGETLB_PAGE. */
+	gfp &= ~(__GFP_COMP);
+
 	size = PAGE_ALIGN(size);
 	order = get_order(size);
 
Index: linux-2.6.19-avr1/arch/avr32/kernel/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/kernel/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/kernel/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -9,6 +9,7 @@ obj-y				+= syscall_table.o syscall-stub
 obj-y				+= setup.o traps.o semaphore.o ptrace.o
 obj-y				+= signal.o sys_avr32.o process.o time.o
 obj-y				+= init_task.o switch_to.o cpu.o
+obj-y				+= dma-controller.o
 obj-$(CONFIG_MODULES)		+= module.o avr32_ksyms.o
 obj-$(CONFIG_KPROBES)		+= kprobes.o
 
Index: linux-2.6.19-avr1/arch/avr32/kernel/dma-controller.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/kernel/dma-controller.c	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,34 @@
+/*
+ * Preliminary DMA controller framework for AVR32
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <asm/dma-controller.h>
+
+static LIST_HEAD(controllers);
+
+int register_dma_controller(struct dma_controller *dmac)
+{
+	static int next_id;
+
+	dmac->id = next_id++;
+	list_add_tail(&dmac->list, &controllers);
+
+	return 0;
+}
+EXPORT_SYMBOL(register_dma_controller);
+
+struct dma_controller *find_dma_controller(int id)
+{
+	struct dma_controller *dmac;
+
+	list_for_each_entry(dmac, &controllers, list)
+		if (dmac->id == id)
+			return dmac;
+	return NULL;
+}
+EXPORT_SYMBOL(find_dma_controller);
Index: linux-2.6.19-avr1/include/asm-avr32/dma-controller.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/include/asm-avr32/dma-controller.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_AVR32_DMA_CONTROLLER_H
+#define __ASM_AVR32_DMA_CONTROLLER_H
+
+#include <linux/device.h>
+
+#define DMA_DIR_MEM_TO_MEM		0x0000
+#define DMA_DIR_MEM_TO_PERIPH		0x0001
+#define DMA_DIR_PERIPH_TO_MEM		0x0002
+#define DMA_DIR_PERIPH_TO_PERIPH	0x0003
+
+#define DMA_WIDTH_8BIT			0
+#define DMA_WIDTH_16BIT			1
+#define DMA_WIDTH_32BIT			2
+
+struct dma_request {
+	struct dma_controller *dmac;
+	struct list_head list;
+
+	unsigned short channel;
+
+	void (*xfer_complete)(struct dma_request *req);
+	void (*block_complete)(struct dma_request *req);
+	void (*error)(struct dma_request *req);
+};
+
+struct dma_request_sg {
+	struct dma_request req;
+
+	int nr_sg;
+	struct scatterlist *sg;
+	unsigned long block_size;
+
+	dma_addr_t data_reg;
+	unsigned short periph_id;
+
+	unsigned char direction;
+	unsigned char width;
+};
+#define to_dma_request_sg(_req)				\
+	container_of(_req, struct dma_request_sg, req)
+
+struct dma_request_cyclic {
+	struct dma_request req;
+
+        int periods;
+	unsigned long buffer_size;
+
+        dma_addr_t buffer_start;
+	dma_addr_t data_reg;
+
+	unsigned short periph_id;
+	unsigned char direction;
+	unsigned char width;
+
+        void *dev_id;
+};
+#define to_dma_request_cyclic(_req)				\
+	container_of(_req, struct dma_request_cyclic, req)
+
+struct dma_request_memcpy {
+	struct dma_request req;
+
+	dma_addr_t src_addr;
+	unsigned int src_width;
+	unsigned int src_stride;
+
+	dma_addr_t dst_addr;
+	unsigned int dst_width;
+	unsigned int dst_stride;
+
+	size_t length;
+
+	unsigned short src_reverse:1;
+	unsigned short dst_reverse:1;
+};
+#define to_dma_request_memcpy(_req)				\
+	container_of(_req, struct dma_request_memcpy, req)
+
+struct dma_controller {
+	struct list_head list;
+	int id;
+	struct device *dev;
+
+	int (*alloc_channel)(struct dma_controller *dmac);
+	void (*release_channel)(struct dma_controller *dmac,
+				int channel);
+	int (*prepare_request_sg)(struct dma_controller *dmac,
+				  struct dma_request_sg *req);
+        int (*prepare_request_cyclic)(struct dma_controller *dmac,
+				      struct dma_request_cyclic *req);
+	int (*prepare_request_memcpy)(struct dma_controller *dmac,
+				      struct dma_request_memcpy *req);
+	int (*start_request)(struct dma_controller *dmac,
+			     unsigned int channel);
+	int (*stop_request)(struct dma_controller *dmac,
+                            unsigned int channel);
+        dma_addr_t (*get_current_pos)(struct dma_controller *dmac,
+                                      unsigned int channel);
+};
+
+static inline int
+dma_alloc_channel(struct dma_controller *dmac)
+{
+	return dmac->alloc_channel(dmac);
+}
+
+static inline void
+dma_release_channel(struct dma_controller *dmac, int chan)
+{
+	dmac->release_channel(dmac, chan);
+}
+
+static inline int
+dma_prepare_request_sg(struct dma_controller *dmac,
+		       struct dma_request_sg *req)
+{
+	return dmac->prepare_request_sg(dmac, req);
+}
+
+static inline int
+dma_prepare_request_cyclic(struct dma_controller *dmac,
+			   struct dma_request_cyclic *req)
+{
+	return dmac->prepare_request_cyclic(dmac, req);
+}
+
+static inline int
+dma_prepare_request_memcpy(struct dma_controller *dmac,
+			   struct dma_request_memcpy *req)
+{
+	return dmac->prepare_request_memcpy(dmac, req);
+}
+
+static inline int
+dma_start_request(struct dma_controller *dmac,
+		  unsigned int channel)
+{
+	return dmac->start_request(dmac, channel);
+}
+
+static inline int
+dma_stop_request(struct dma_controller *dmac,
+                 unsigned int channel)
+{
+	return dmac->stop_request(dmac, channel);
+}
+
+static inline dma_addr_t
+dma_get_current_pos(struct dma_controller *dmac,
+                    unsigned int channel)
+{
+	return dmac->get_current_pos(dmac, channel);
+}
+
+extern int register_dma_controller(struct dma_controller *dmac);
+extern struct dma_controller *find_dma_controller(int id);
+
+#endif /* __ASM_AVR32_DMA_CONTROLLER_H */
Index: linux-2.6.19-avr1/arch/avr32/mach-at32ap/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/mach-at32ap/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,15 @@
+if PLATFORM_AT32AP
+
+menu "Atmel AVR32 AP options"
+
+config PIO_DEV
+	bool "PIO /dev interface"
+	select CONFIGFS_FS
+	default y
+	help
+	  Say `Y' to enable a /dev interface to the Parallel I/O
+	  Controller.
+
+endmenu
+
+endif
Index: linux-2.6.19-avr1/MAINTAINERS
===================================================================
--- linux-2.6.19-avr1.orig/MAINTAINERS	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/MAINTAINERS	2006-12-03 19:23:23.000000000 +0100
@@ -432,6 +432,13 @@ L:	linux-atm-general@lists.sourceforge.n
 W:	http://linux-atm.sourceforge.net
 S:	Maintained
 
+ATMEL MACB ETHERNET DRIVER
+P:	Atmel AVR32 Support Team
+M:	avr32@atmel.com
+P:	Haavard Skinnemoen
+M:	hskinnemoen@atmel.com
+S:	Supported
+
 ATMEL WIRELESS DRIVER
 P:	Simon Kelley
 M:	simon@thekelleys.org.uk
Index: linux-2.6.19-avr1/drivers/net/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/drivers/net/Kconfig	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/net/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -188,6 +188,17 @@ config MII
 	  or internal device.  It is safe to say Y or M here even if your
 	  ethernet card lack MII.
 
+config MACB
+	tristate "Atmel MACB support"
+	depends on NET_ETHERNET && AVR32
+	select MII
+	help
+	  The Atmel MACB ethernet interface is found on many AT32 and AT91
+	  parts. Say Y to include support for the MACB chip.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called macb.
+
 source "drivers/net/arm/Kconfig"
 
 config MACE
Index: linux-2.6.19-avr1/drivers/net/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/drivers/net/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/net/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -197,6 +197,8 @@ obj-$(CONFIG_SMC911X) += smc911x.o
 obj-$(CONFIG_DM9000) += dm9000.o
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
 
+obj-$(CONFIG_MACB) += macb.o
+
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
 obj-$(CONFIG_TR) += tokenring/
Index: linux-2.6.19-avr1/drivers/net/macb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/net/macb.c	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,1210 @@
+/*
+ * Atmel MACB Ethernet Controller driver
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+#include <linux/mutex.h>
+#include <linux/dma-mapping.h>
+#include <linux/ethtool.h>
+#include <linux/platform_device.h>
+
+#include <asm/arch/board.h>
+
+#include "macb.h"
+
+#define to_net_dev(class) container_of(class, struct net_device, class_dev)
+
+#define RX_BUFFER_SIZE		128
+#define RX_RING_SIZE		512
+#define RX_RING_BYTES		(sizeof(struct dma_desc) * RX_RING_SIZE)
+
+/* Make the IP header word-aligned (the ethernet header is 14 bytes) */
+#define RX_OFFSET		2
+
+#define TX_RING_SIZE		128
+#define DEF_TX_RING_PENDING	(TX_RING_SIZE - 1)
+#define TX_RING_BYTES		(sizeof(struct dma_desc) * TX_RING_SIZE)
+
+#define TX_RING_GAP(bp)						\
+	(TX_RING_SIZE - (bp)->tx_pending)
+#define TX_BUFFS_AVAIL(bp)					\
+	(((bp)->tx_tail <= (bp)->tx_head) ?			\
+	 (bp)->tx_tail + (bp)->tx_pending - (bp)->tx_head :	\
+	 (bp)->tx_tail - (bp)->tx_head - TX_RING_GAP(bp))
+#define NEXT_TX(n)		(((n) + 1) & (TX_RING_SIZE - 1))
+
+#define NEXT_RX(n)		(((n) + 1) & (RX_RING_SIZE - 1))
+
+/* minimum number of free TX descriptors before waking up TX process */
+#define MACB_TX_WAKEUP_THRESH	(TX_RING_SIZE / 4)
+
+#define MACB_RX_INT_FLAGS	(MACB_BIT(RCOMP) | MACB_BIT(RXUBR)	\
+				 | MACB_BIT(ISR_ROVR))
+
+static void __macb_set_hwaddr(struct macb *bp)
+{
+	u32 bottom;
+	u16 top;
+
+	bottom = cpu_to_le32(*((u32 *)bp->dev->dev_addr));
+	macb_writel(bp, SA1B, bottom);
+	top = cpu_to_le16(*((u16 *)(bp->dev->dev_addr + 4)));
+	macb_writel(bp, SA1T, top);
+}
+
+static void __init macb_get_hwaddr(struct macb *bp)
+{
+	u32 bottom;
+	u16 top;
+	u8 addr[6];
+
+	bottom = macb_readl(bp, SA1B);
+	top = macb_readl(bp, SA1T);
+
+	addr[0] = bottom & 0xff;
+	addr[1] = (bottom >> 8) & 0xff;
+	addr[2] = (bottom >> 16) & 0xff;
+	addr[3] = (bottom >> 24) & 0xff;
+	addr[4] = top & 0xff;
+	addr[5] = (top >> 8) & 0xff;
+
+	if (is_valid_ether_addr(addr))
+		memcpy(bp->dev->dev_addr, addr, sizeof(addr));
+}
+
+static void macb_enable_mdio(struct macb *bp)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&bp->lock, flags);
+	reg = macb_readl(bp, NCR);
+	reg |= MACB_BIT(MPE);
+	macb_writel(bp, NCR, reg);
+	macb_writel(bp, IER, MACB_BIT(MFD));
+	spin_unlock_irqrestore(&bp->lock, flags);
+}
+
+static void macb_disable_mdio(struct macb *bp)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&bp->lock, flags);
+	reg = macb_readl(bp, NCR);
+	reg &= ~MACB_BIT(MPE);
+	macb_writel(bp, NCR, reg);
+	macb_writel(bp, IDR, MACB_BIT(MFD));
+	spin_unlock_irqrestore(&bp->lock, flags);
+}
+
+static int macb_mdio_read(struct net_device *dev, int phy_id, int location)
+{
+	struct macb *bp = netdev_priv(dev);
+	int value;
+
+	mutex_lock(&bp->mdio_mutex);
+
+	macb_enable_mdio(bp);
+	macb_writel(bp, MAN, (MACB_BF(SOF, MACB_MAN_SOF)
+			      | MACB_BF(RW, MACB_MAN_READ)
+			      | MACB_BF(PHYA, phy_id)
+			      | MACB_BF(REGA, location)
+			      | MACB_BF(CODE, MACB_MAN_CODE)));
+
+	wait_for_completion(&bp->mdio_complete);
+
+	value = MACB_BFEXT(DATA, macb_readl(bp, MAN));
+	macb_disable_mdio(bp);
+	mutex_unlock(&bp->mdio_mutex);
+
+	return value;
+}
+
+static void macb_mdio_write(struct net_device *dev, int phy_id,
+			    int location, int val)
+{
+	struct macb *bp = netdev_priv(dev);
+
+	dev_dbg(&bp->pdev->dev, "mdio_write %02x:%02x <- %04x\n",
+		phy_id, location, val);
+
+	mutex_lock(&bp->mdio_mutex);
+	macb_enable_mdio(bp);
+
+	macb_writel(bp, MAN, (MACB_BF(SOF, MACB_MAN_SOF)
+			      | MACB_BF(RW, MACB_MAN_WRITE)
+			      | MACB_BF(PHYA, phy_id)
+			      | MACB_BF(REGA, location)
+			      | MACB_BF(CODE, MACB_MAN_CODE)
+			      | MACB_BF(DATA, val)));
+
+	wait_for_completion(&bp->mdio_complete);
+
+	macb_disable_mdio(bp);
+	mutex_unlock(&bp->mdio_mutex);
+}
+
+static int macb_phy_probe(struct macb *bp)
+{
+	int phy_address;
+	u16 phyid1, phyid2;
+
+	for (phy_address = 0; phy_address < 32; phy_address++) {
+		phyid1 = macb_mdio_read(bp->dev, phy_address, MII_PHYSID1);
+		phyid2 = macb_mdio_read(bp->dev, phy_address, MII_PHYSID2);
+
+		if (phyid1 != 0xffff && phyid1 != 0x0000
+		    && phyid2 != 0xffff && phyid2 != 0x0000)
+			break;
+	}
+
+	if (phy_address == 32)
+		return -ENODEV;
+
+	dev_info(&bp->pdev->dev,
+		 "detected PHY at address %d (ID %04x:%04x)\n",
+		 phy_address, phyid1, phyid2);
+
+	bp->mii.phy_id = phy_address;
+	return 0;
+}
+
+static void macb_set_media(struct macb *bp, int media)
+{
+	u32 reg;
+
+	spin_lock_irq(&bp->lock);
+	reg = macb_readl(bp, NCFGR);
+	reg &= ~(MACB_BIT(SPD) | MACB_BIT(FD));
+	if (media & (ADVERTISE_100HALF | ADVERTISE_100FULL))
+		reg |= MACB_BIT(SPD);
+	if (media & ADVERTISE_FULL)
+		reg |= MACB_BIT(FD);
+	macb_writel(bp, NCFGR, reg);
+	spin_unlock_irq(&bp->lock);
+}
+
+static void macb_check_media(struct macb *bp, int ok_to_print, int init_media)
+{
+	struct mii_if_info *mii = &bp->mii;
+	unsigned int old_carrier, new_carrier;
+	int advertise, lpa, media, duplex;
+
+	/* if forced media, go no further */
+	if (mii->force_media)
+		return;
+
+	/* check current and old link status */
+	old_carrier = netif_carrier_ok(mii->dev) ? 1 : 0;
+	new_carrier = (unsigned int) mii_link_ok(mii);
+
+	/* if carrier state did not change, assume nothing else did */
+	if (!init_media && old_carrier == new_carrier)
+		return;
+
+	/* no carrier, nothing much to do */
+	if (!new_carrier) {
+		netif_carrier_off(mii->dev);
+		printk(KERN_INFO "%s: link down\n", mii->dev->name);
+		return;
+	}
+
+	/*
+	 * we have carrier, see who's on the other end
+	 */
+	netif_carrier_on(mii->dev);
+
+	/* get MII advertise and LPA values */
+	if (!init_media && mii->advertising) {
+		advertise = mii->advertising;
+	} else {
+		advertise = mii->mdio_read(mii->dev, mii->phy_id, MII_ADVERTISE);
+		mii->advertising = advertise;
+	}
+	lpa = mii->mdio_read(mii->dev, mii->phy_id, MII_LPA);
+
+	/* figure out media and duplex from advertise and LPA values */
+	media = mii_nway_result(lpa & advertise);
+	duplex = (media & ADVERTISE_FULL) ? 1 : 0;
+
+	if (ok_to_print)
+		printk(KERN_INFO "%s: link up, %sMbps, %s-duplex, lpa 0x%04X\n",
+		       mii->dev->name,
+		       media & (ADVERTISE_100FULL | ADVERTISE_100HALF) ? "100" : "10",
+		       duplex ? "full" : "half", lpa);
+
+	mii->full_duplex = duplex;
+
+	/* Let the MAC know about the new link state */
+	macb_set_media(bp, media);
+}
+
+static void macb_update_stats(struct macb *bp)
+{
+	u32 __iomem *reg = bp->regs + MACB_PFR;
+	u32 *p = &bp->hw_stats.rx_pause_frames;
+	u32 *end = &bp->hw_stats.tx_pause_frames + 1;
+
+	WARN_ON((unsigned long)(end - p - 1) != (MACB_TPF - MACB_PFR) / 4);
+
+	for(; p < end; p++, reg++)
+		*p += __raw_readl(reg);
+}
+
+static void macb_periodic_task(void *arg)
+{
+	struct macb *bp = arg;
+
+	macb_update_stats(bp);
+	macb_check_media(bp, 1, 0);
+
+	schedule_delayed_work(&bp->periodic_task, HZ);
+}
+
+static void macb_tx(struct macb *bp)
+{
+	unsigned int tail;
+	unsigned int head;
+	u32 status;
+
+	status = macb_readl(bp, TSR);
+	macb_writel(bp, TSR, status);
+
+	dev_dbg(&bp->pdev->dev, "macb_tx status = %02lx\n",
+		(unsigned long)status);
+
+	if (status & MACB_BIT(UND)) {
+		printk(KERN_ERR "%s: TX underrun, resetting buffers\n",
+		       bp->dev->name);
+		bp->tx_head = bp->tx_tail = 0;
+	}
+
+	if (!(status & MACB_BIT(COMP)))
+		/*
+		 * This may happen when a buffer becomes complete
+		 * between reading the ISR and scanning the
+		 * descriptors.  Nothing to worry about.
+		 */
+		return;
+
+	head = bp->tx_head;
+	for (tail = bp->tx_tail; tail != head; tail = NEXT_TX(tail)) {
+		struct ring_info *rp = &bp->tx_skb[tail];
+		struct sk_buff *skb = rp->skb;
+		u32 bufstat;
+
+		BUG_ON(skb == NULL);
+
+		rmb();
+		bufstat = bp->tx_ring[tail].ctrl;
+
+		if (!(bufstat & MACB_BIT(TX_USED)))
+			break;
+
+		dev_dbg(&bp->pdev->dev, "skb %u (data %p) TX complete\n",
+			tail, skb->data);
+		dma_unmap_single(&bp->pdev->dev, rp->mapping, skb->len,
+				 DMA_TO_DEVICE);
+		bp->stats.tx_packets++;
+		bp->stats.tx_bytes += skb->len;
+		rp->skb = NULL;
+		dev_kfree_skb_irq(skb);
+	}
+
+	bp->tx_tail = tail;
+	if (netif_queue_stopped(bp->dev) &&
+	    TX_BUFFS_AVAIL(bp) > MACB_TX_WAKEUP_THRESH)
+		netif_wake_queue(bp->dev);
+}
+
+static int macb_rx_frame(struct macb *bp, unsigned int first_frag,
+			 unsigned int last_frag)
+{
+	unsigned int len;
+	unsigned int frag;
+	unsigned int offset = 0;
+	struct sk_buff *skb;
+
+	len = MACB_BFEXT(RX_FRMLEN, bp->rx_ring[last_frag].ctrl);
+
+	dev_dbg(&bp->pdev->dev, "macb_rx_frame frags %u - %u (len %u)\n",
+		first_frag, last_frag, len);
+
+	skb = dev_alloc_skb(len + RX_OFFSET);
+	if (!skb) {
+		bp->stats.rx_dropped++;
+		for (frag = first_frag; ; frag = NEXT_RX(frag)) {
+			bp->rx_ring[frag].addr &= ~MACB_BIT(RX_USED);
+			if (frag == last_frag)
+				break;
+		}
+		wmb();
+		return 1;
+	}
+
+	skb_reserve(skb, RX_OFFSET);
+	skb->dev = bp->dev;
+	skb->ip_summed = CHECKSUM_NONE;
+	skb_put(skb, len);
+
+	for (frag = first_frag; ; frag = NEXT_RX(frag)) {
+		unsigned int frag_len = RX_BUFFER_SIZE;
+
+		if (offset + frag_len > len) {
+			BUG_ON(frag != last_frag);
+			frag_len = len - offset;
+		}
+		memcpy(skb->data + offset,
+		       bp->rx_buffers + (RX_BUFFER_SIZE * frag),
+		       frag_len);
+		offset += RX_BUFFER_SIZE;
+		bp->rx_ring[frag].addr &= ~MACB_BIT(RX_USED);
+		wmb();
+
+		if (frag == last_frag)
+			break;
+	}
+
+	skb->protocol = eth_type_trans(skb, bp->dev);
+
+	bp->stats.rx_packets++;
+	bp->stats.rx_bytes += len;
+	bp->dev->last_rx = jiffies;
+	dev_dbg(&bp->pdev->dev, "received skb of length %u, csum: %08x\n",
+		skb->len, skb->csum);
+	netif_receive_skb(skb);
+
+	return 0;
+}
+
+/* Mark DMA descriptors from begin up to and not including end as unused */
+static void discard_partial_frame(struct macb *bp, unsigned int begin,
+				  unsigned int end)
+{
+	unsigned int frag;
+
+	for (frag = begin; frag != end; frag = NEXT_RX(frag))
+		bp->rx_ring[frag].addr &= ~MACB_BIT(RX_USED);
+	wmb();
+
+	/*
+	 * When this happens, the hardware stats registers for
+	 * whatever caused this is updated, so we don't have to record
+	 * anything.
+	 */
+}
+
+static int macb_rx(struct macb *bp, int budget)
+{
+	int received = 0;
+	unsigned int tail = bp->rx_tail;
+	int first_frag = -1;
+
+	for (; budget > 0; tail = NEXT_RX(tail)) {
+		u32 addr, ctrl;
+
+		rmb();
+		addr = bp->rx_ring[tail].addr;
+		ctrl = bp->rx_ring[tail].ctrl;
+
+		if (!(addr & MACB_BIT(RX_USED)))
+			break;
+
+		if (ctrl & MACB_BIT(RX_SOF)) {
+			if (first_frag != -1)
+				discard_partial_frame(bp, first_frag, tail);
+			first_frag = tail;
+		}
+
+		if (ctrl & MACB_BIT(RX_EOF)) {
+			int dropped;
+			BUG_ON(first_frag == -1);
+
+			dropped = macb_rx_frame(bp, first_frag, tail);
+			first_frag = -1;
+			if (!dropped) {
+				received++;
+				budget--;
+			}
+		}
+	}
+
+	if (first_frag != -1)
+		bp->rx_tail = first_frag;
+	else
+		bp->rx_tail = tail;
+
+	return received;
+}
+
+static int macb_poll(struct net_device *dev, int *budget)
+{
+	struct macb *bp = netdev_priv(dev);
+	int orig_budget, work_done, retval = 0;
+	u32 status;
+
+	status = macb_readl(bp, RSR);
+	macb_writel(bp, RSR, status);
+
+	if (!status) {
+		/*
+		 * This may happen if an interrupt was pending before
+		 * this function was called last time, and no packets
+		 * have been received since.
+		 */
+		netif_rx_complete(dev);
+		goto out;
+	}
+
+	dev_dbg(&bp->pdev->dev, "poll: status = %08lx, budget = %d\n",
+		(unsigned long)status, *budget);
+
+	if (!(status & MACB_BIT(REC))) {
+		dev_warn(&bp->pdev->dev,
+			 "No RX buffers complete, status = %02lx\n",
+			 (unsigned long)status);
+		netif_rx_complete(dev);
+		goto out;
+	}
+
+	orig_budget = *budget;
+	if (orig_budget > dev->quota)
+		orig_budget = dev->quota;
+
+	work_done = macb_rx(bp, orig_budget);
+	if (work_done < orig_budget) {
+		netif_rx_complete(dev);
+		retval = 0;
+	} else {
+		retval = 1;
+	}
+
+	/*
+	 * We've done what we can to clean the buffers. Make sure we
+	 * get notified when new packets arrive.
+	 */
+out:
+	macb_writel(bp, IER, MACB_RX_INT_FLAGS);
+
+	/* TODO: Handle errors */
+
+	return retval;
+}
+
+static irqreturn_t macb_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct macb *bp = netdev_priv(dev);
+	u32 status;
+
+	status = macb_readl(bp, ISR);
+
+	if (unlikely(!status))
+		return IRQ_NONE;
+
+	spin_lock(&bp->lock);
+
+	while (status) {
+		if (status & MACB_BIT(MFD))
+			complete(&bp->mdio_complete);
+
+		/* close possible race with dev_close */
+		if (unlikely(!netif_running(dev))) {
+			macb_writel(bp, IDR, ~0UL);
+			break;
+		}
+
+		if (status & MACB_RX_INT_FLAGS) {
+			if (netif_rx_schedule_prep(dev)) {
+				/*
+				 * There's no point taking any more interrupts
+				 * until we have processed the buffers
+				 */
+				macb_writel(bp, IDR, MACB_RX_INT_FLAGS);
+				dev_dbg(&bp->pdev->dev, "scheduling RX softirq\n");
+				__netif_rx_schedule(dev);
+			}
+		}
+
+		if (status & (MACB_BIT(TCOMP) | MACB_BIT(ISR_TUND)))
+			macb_tx(bp);
+
+		/*
+		 * Link change detection isn't possible with RMII, so we'll
+		 * add that if/when we get our hands on a full-blown MII PHY.
+		 */
+
+		if (status & MACB_BIT(HRESP)) {
+			/*
+			 * TODO: Reset the hardware, and maybe move the printk
+			 * to a lower-priority context as well (work queue?)
+			 */
+			printk(KERN_ERR "%s: DMA bus error: HRESP not OK\n",
+			       dev->name);
+		}
+
+		status = macb_readl(bp, ISR);
+	}
+
+	spin_unlock(&bp->lock);
+
+	return IRQ_HANDLED;
+}
+
+static int macb_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct macb *bp = netdev_priv(dev);
+	dma_addr_t mapping;
+	unsigned int len, entry;
+	u32 ctrl;
+
+#ifdef DEBUG
+	int i;
+	dev_dbg(&bp->pdev->dev,
+		"start_xmit: len %u head %p data %p tail %p end %p\n",
+		skb->len, skb->head, skb->data, skb->tail, skb->end);
+	dev_dbg(&bp->pdev->dev,
+		"data:");
+	for (i = 0; i < 16; i++)
+		printk(" %02x", (unsigned int)skb->data[i]);
+	printk("\n");
+#endif
+
+	len = skb->len;
+	spin_lock_irq(&bp->lock);
+
+	/* This is a hard error, log it. */
+	if (TX_BUFFS_AVAIL(bp) < 1) {
+		netif_stop_queue(dev);
+		spin_unlock_irq(&bp->lock);
+		dev_err(&bp->pdev->dev,
+			"BUG! Tx Ring full when queue awake!\n");
+		dev_dbg(&bp->pdev->dev, "tx_head = %u, tx_tail = %u\n",
+			bp->tx_head, bp->tx_tail);
+		return 1;
+	}
+
+	entry = bp->tx_head;
+	dev_dbg(&bp->pdev->dev, "Allocated ring entry %u\n", entry);
+	mapping = dma_map_single(&bp->pdev->dev, skb->data,
+				 len, DMA_TO_DEVICE);
+	bp->tx_skb[entry].skb = skb;
+	bp->tx_skb[entry].mapping = mapping;
+	dev_dbg(&bp->pdev->dev, "Mapped skb data %p to DMA addr %08lx\n",
+		skb->data, (unsigned long)mapping);
+
+	ctrl = MACB_BF(TX_FRMLEN, len);
+	ctrl |= MACB_BIT(TX_LAST);
+	if (entry == (TX_RING_SIZE - 1))
+		ctrl |= MACB_BIT(TX_WRAP);
+
+	bp->tx_ring[entry].addr = mapping;
+	bp->tx_ring[entry].ctrl = ctrl;
+	wmb();
+
+	entry = NEXT_TX(entry);
+	bp->tx_head = entry;
+
+	macb_writel(bp, NCR, macb_readl(bp, NCR) | MACB_BIT(TSTART));
+
+	if (TX_BUFFS_AVAIL(bp) < 1)
+		netif_stop_queue(dev);
+
+	spin_unlock_irq(&bp->lock);
+
+	dev->trans_start = jiffies;
+
+	return 0;
+}
+
+static void macb_free_consistent(struct macb *bp)
+{
+	if (bp->tx_skb) {
+		kfree(bp->tx_skb);
+		bp->tx_skb = NULL;
+	}
+	if (bp->rx_ring) {
+		dma_free_coherent(&bp->pdev->dev, RX_RING_BYTES,
+				  bp->rx_ring, bp->rx_ring_dma);
+		bp->rx_ring = NULL;
+	}
+	if (bp->tx_ring) {
+		dma_free_coherent(&bp->pdev->dev, TX_RING_BYTES,
+				  bp->tx_ring, bp->tx_ring_dma);
+		bp->tx_ring = NULL;
+	}
+	if (bp->rx_buffers) {
+		dma_free_coherent(&bp->pdev->dev,
+				  RX_RING_SIZE * RX_BUFFER_SIZE,
+				  bp->rx_buffers, bp->rx_buffers_dma);
+		bp->rx_buffers = NULL;
+	}
+}
+
+static int macb_alloc_consistent(struct macb *bp)
+{
+	int size;
+
+	size = TX_RING_SIZE * sizeof(struct ring_info);
+	bp->tx_skb = kmalloc(size, GFP_KERNEL);
+	if (!bp->tx_skb)
+		goto out_err;
+
+	size = RX_RING_BYTES;
+	bp->rx_ring = dma_alloc_coherent(&bp->pdev->dev, size,
+					 &bp->rx_ring_dma, GFP_KERNEL);
+	if (!bp->rx_ring)
+		goto out_err;
+	dev_dbg(&bp->pdev->dev,
+		"Allocated RX ring of %d bytes at %08lx (mapped %p)\n",
+		size, (unsigned long)bp->rx_ring_dma, bp->rx_ring);
+
+	size = TX_RING_BYTES;
+	bp->tx_ring = dma_alloc_coherent(&bp->pdev->dev, size,
+					 &bp->tx_ring_dma, GFP_KERNEL);
+	if (!bp->tx_ring)
+		goto out_err;
+	dev_dbg(&bp->pdev->dev,
+		"Allocated TX ring of %d bytes at %08lx (mapped %p)\n",
+		size, (unsigned long)bp->tx_ring_dma, bp->tx_ring);
+
+	size = RX_RING_SIZE * RX_BUFFER_SIZE;
+	bp->rx_buffers = dma_alloc_coherent(&bp->pdev->dev, size,
+					    &bp->rx_buffers_dma, GFP_KERNEL);
+	if (!bp->rx_buffers)
+		goto out_err;
+	dev_dbg(&bp->pdev->dev,
+		"Allocated RX buffers of %d bytes at %08lx (mapped %p)\n",
+		size, (unsigned long)bp->rx_buffers_dma, bp->rx_buffers);
+
+	return 0;
+
+out_err:
+	macb_free_consistent(bp);
+	return -ENOMEM;
+}
+
+static void macb_init_rings(struct macb *bp)
+{
+	int i;
+	dma_addr_t addr;
+
+	addr = bp->rx_buffers_dma;
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		bp->rx_ring[i].addr = addr;
+		bp->rx_ring[i].ctrl = 0;
+		addr += RX_BUFFER_SIZE;
+	}
+	bp->rx_ring[RX_RING_SIZE - 1].addr |= MACB_BIT(RX_WRAP);
+
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		bp->tx_ring[i].addr = 0;
+		bp->tx_ring[i].ctrl = MACB_BIT(TX_USED);
+	}
+	bp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);
+
+	bp->rx_tail = bp->tx_head = bp->tx_tail = 0;
+}
+
+static void macb_reset_hw(struct macb *bp)
+{
+	/* Make sure we have the write buffer for ourselves */
+	wmb();
+
+	/*
+	 * Disable RX and TX (XXX: Should we halt the transmission
+	 * more gracefully?)
+	 */
+	macb_writel(bp, NCR, 0);
+
+	/* Clear the stats registers (XXX: Update stats first?) */
+	macb_writel(bp, NCR, MACB_BIT(CLRSTAT));
+
+	/* Clear all status flags */
+	macb_writel(bp, TSR, ~0UL);
+	macb_writel(bp, RSR, ~0UL);
+
+	/* Disable all interrupts */
+	macb_writel(bp, IDR, ~0UL);
+	macb_readl(bp, ISR);
+}
+
+static void macb_init_hw(struct macb *bp)
+{
+	u32 config;
+
+	macb_reset_hw(bp);
+	__macb_set_hwaddr(bp);
+
+	config = macb_readl(bp, NCFGR) & MACB_BF(CLK, -1L);
+	config |= MACB_BIT(PAE);		/* PAuse Enable */
+	config |= MACB_BIT(DRFCS);		/* Discard Rx FCS */
+	if (bp->dev->flags & IFF_PROMISC)
+		config |= MACB_BIT(CAF);	/* Copy All Frames */
+	if (!(bp->dev->flags & IFF_BROADCAST))
+		config |= MACB_BIT(NBC);	/* No BroadCast */
+	macb_writel(bp, NCFGR, config);
+
+	/* Initialize TX and RX buffers */
+	macb_writel(bp, RBQP, bp->rx_ring_dma);
+	macb_writel(bp, TBQP, bp->tx_ring_dma);
+
+	/* Enable TX and RX */
+	macb_writel(bp, NCR, MACB_BIT(RE) | MACB_BIT(TE));
+
+	/* Enable interrupts */
+	macb_writel(bp, IER, (MACB_BIT(RCOMP)
+			      | MACB_BIT(RXUBR)
+			      | MACB_BIT(ISR_TUND)
+			      | MACB_BIT(ISR_RLE)
+			      | MACB_BIT(TXERR)
+			      | MACB_BIT(TCOMP)
+			      | MACB_BIT(ISR_ROVR)
+			      | MACB_BIT(HRESP)));
+}
+
+static void macb_init_phy(struct net_device *dev)
+{
+	struct macb *bp = netdev_priv(dev);
+
+	/* Set some reasonable default settings */
+	macb_mdio_write(dev, bp->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_CSMA | ADVERTISE_ALL);
+	macb_mdio_write(dev, bp->mii.phy_id, MII_BMCR,
+			(BMCR_SPEED100 | BMCR_ANENABLE
+			 | BMCR_ANRESTART | BMCR_FULLDPLX));
+}
+
+static int macb_open(struct net_device *dev)
+{
+	struct macb *bp = netdev_priv(dev);
+	int err;
+
+	dev_dbg(&bp->pdev->dev, "open\n");
+
+	if (!is_valid_ether_addr(dev->dev_addr))
+		return -EADDRNOTAVAIL;
+
+	err = macb_alloc_consistent(bp);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Unable to allocate DMA memory (error %d)\n",
+		       dev->name, err);
+		return err;
+	}
+
+	macb_init_rings(bp);
+	macb_init_hw(bp);
+	macb_init_phy(dev);
+
+	macb_check_media(bp, 1, 1);
+	netif_start_queue(dev);
+
+	schedule_delayed_work(&bp->periodic_task, HZ);
+
+	return 0;
+}
+
+static int macb_close(struct net_device *dev)
+{
+	struct macb *bp = netdev_priv(dev);
+	unsigned long flags;
+
+	cancel_rearming_delayed_work(&bp->periodic_task);
+
+	netif_stop_queue(dev);
+
+	spin_lock_irqsave(&bp->lock, flags);
+	macb_reset_hw(bp);
+	netif_carrier_off(dev);
+	spin_unlock_irqrestore(&bp->lock, flags);
+
+	macb_free_consistent(bp);
+
+	return 0;
+}
+
+static struct net_device_stats *macb_get_stats(struct net_device *dev)
+{
+	struct macb *bp = netdev_priv(dev);
+	struct net_device_stats *nstat = &bp->stats;
+	struct macb_stats *hwstat = &bp->hw_stats;
+
+	/* Convert HW stats into netdevice stats */
+	nstat->rx_errors = (hwstat->rx_fcs_errors +
+			    hwstat->rx_align_errors +
+			    hwstat->rx_resource_errors +
+			    hwstat->rx_overruns +
+			    hwstat->rx_oversize_pkts +
+			    hwstat->rx_jabbers +
+			    hwstat->rx_undersize_pkts +
+			    hwstat->sqe_test_errors +
+			    hwstat->rx_length_mismatch);
+	nstat->tx_errors = (hwstat->tx_late_cols +
+			    hwstat->tx_excessive_cols +
+			    hwstat->tx_underruns +
+			    hwstat->tx_carrier_errors);
+	nstat->collisions = (hwstat->tx_single_cols +
+			     hwstat->tx_multiple_cols +
+			     hwstat->tx_excessive_cols);
+	nstat->rx_length_errors = (hwstat->rx_oversize_pkts +
+				   hwstat->rx_jabbers +
+				   hwstat->rx_undersize_pkts +
+				   hwstat->rx_length_mismatch);
+	nstat->rx_over_errors = hwstat->rx_resource_errors;
+	nstat->rx_crc_errors = hwstat->rx_fcs_errors;
+	nstat->rx_frame_errors = hwstat->rx_align_errors;
+	nstat->rx_fifo_errors = hwstat->rx_overruns;
+	/* XXX: What does "missed" mean? */
+	nstat->tx_aborted_errors = hwstat->tx_excessive_cols;
+	nstat->tx_carrier_errors = hwstat->tx_carrier_errors;
+	nstat->tx_fifo_errors = hwstat->tx_underruns;
+	/* Don't know about heartbeat or window errors... */
+
+	return nstat;
+}
+
+static int macb_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct macb *bp = netdev_priv(dev);
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&bp->lock, flags);
+	ret = mii_ethtool_gset(&bp->mii, cmd);
+	spin_unlock_irqrestore(&bp->lock, flags);
+
+	return ret;
+}
+
+static int macb_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct macb *bp = netdev_priv(dev);
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&bp->lock, flags);
+	ret = mii_ethtool_sset(&bp->mii, cmd);
+	spin_unlock_irqrestore(&bp->lock, flags);
+
+	return ret;
+}
+
+static void macb_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	struct macb *bp = netdev_priv(dev);
+
+	strcpy(info->driver, bp->pdev->dev.driver->name);
+	strcpy(info->version, "$Revision: 1.14 $");
+	strcpy(info->bus_info, bp->pdev->dev.bus_id);
+}
+
+static int macb_nway_reset(struct net_device *dev)
+{
+	struct macb *bp = netdev_priv(dev);
+	return mii_nway_restart(&bp->mii);
+}
+
+static struct ethtool_ops macb_ethtool_ops = {
+	.get_settings		= macb_get_settings,
+	.set_settings		= macb_set_settings,
+	.get_drvinfo		= macb_get_drvinfo,
+	.nway_reset		= macb_nway_reset,
+	.get_link		= ethtool_op_get_link,
+};
+
+static int macb_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct macb *bp = netdev_priv(dev);
+	int ret;
+	unsigned long flags;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	spin_lock_irqsave(&bp->lock, flags);
+	ret = generic_mii_ioctl(&bp->mii, if_mii(rq), cmd, NULL);
+	spin_unlock_irqrestore(&bp->lock, flags);
+
+	return ret;
+}
+
+static ssize_t macb_mii_show(const struct class_device *cd, char *buf,
+			unsigned long addr)
+{
+	struct net_device *dev = to_net_dev(cd);
+	struct macb *bp = netdev_priv(dev);
+	ssize_t ret = -EINVAL;
+
+	if (netif_running(dev)) {
+		int value;
+		value = macb_mdio_read(dev, bp->mii.phy_id, addr);
+		ret = sprintf(buf, "0x%04x\n", (uint16_t)value);
+	}
+
+	return ret;
+}
+
+#define MII_ENTRY(name, addr)					\
+static ssize_t show_##name(struct class_device *cd, char *buf)	\
+{								\
+	return macb_mii_show(cd, buf, addr);			\
+}								\
+static CLASS_DEVICE_ATTR(name, S_IRUGO, show_##name, NULL)
+
+MII_ENTRY(bmcr, MII_BMCR);
+MII_ENTRY(bmsr, MII_BMSR);
+MII_ENTRY(physid1, MII_PHYSID1);
+MII_ENTRY(physid2, MII_PHYSID2);
+MII_ENTRY(advertise, MII_ADVERTISE);
+MII_ENTRY(lpa, MII_LPA);
+MII_ENTRY(expansion, MII_EXPANSION);
+
+static struct attribute *macb_mii_attrs[] = {
+	&class_device_attr_bmcr.attr,
+	&class_device_attr_bmsr.attr,
+	&class_device_attr_physid1.attr,
+	&class_device_attr_physid2.attr,
+	&class_device_attr_advertise.attr,
+	&class_device_attr_lpa.attr,
+	&class_device_attr_expansion.attr,
+	NULL,
+};
+
+static struct attribute_group macb_mii_group = {
+	.name	= "mii",
+	.attrs	= macb_mii_attrs,
+};
+
+static void macb_unregister_sysfs(struct net_device *net)
+{
+	struct class_device *class_dev = &net->class_dev;
+
+	sysfs_remove_group(&class_dev->kobj, &macb_mii_group);
+}
+
+static int macb_register_sysfs(struct net_device *net)
+{
+	struct class_device *class_dev = &net->class_dev;
+	int ret;
+
+	ret = sysfs_create_group(&class_dev->kobj, &macb_mii_group);
+	if (ret)
+		printk(KERN_WARNING
+		       "%s: sysfs mii attribute registration failed: %d\n",
+		       net->name, ret);
+	return ret;
+}
+static int __devinit macb_probe(struct platform_device *pdev)
+{
+	struct eth_platform_data *pdata;
+	struct resource *regs;
+	struct net_device *dev;
+	struct macb *bp;
+	unsigned long pclk_hz;
+	u32 config;
+	int err = -ENXIO;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs) {
+		dev_err(&pdev->dev, "no mmio resource defined\n");
+		goto err_out;
+	}
+
+	err = -ENOMEM;
+	dev = alloc_etherdev(sizeof(*bp));
+	if (!dev) {
+		dev_err(&pdev->dev, "etherdev alloc failed, aborting.\n");
+		goto err_out;
+	}
+
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	/* TODO: Actually, we have some interesting features... */
+	dev->features |= 0;
+
+	bp = netdev_priv(dev);
+	bp->pdev = pdev;
+	bp->dev = dev;
+
+	spin_lock_init(&bp->lock);
+
+	bp->pclk = clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(bp->pclk)) {
+		dev_err(&pdev->dev, "failed to get pclk\n");
+		goto err_out_free_dev;
+	}
+	bp->hclk = clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(bp->hclk)) {
+		dev_err(&pdev->dev, "failed to get hclk\n");
+		goto err_out_put_pclk;
+	}
+
+	clk_enable(bp->pclk);
+	clk_enable(bp->hclk);
+
+	bp->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!bp->regs) {
+		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
+		err = -ENOMEM;
+		goto err_out_disable_clocks;
+	}
+
+	dev->irq = platform_get_irq(pdev, 0);
+	err = request_irq(dev->irq, macb_interrupt, SA_SAMPLE_RANDOM,
+			  dev->name, dev);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Unable to request IRQ %d (error %d)\n",
+		       dev->name, dev->irq, err);
+		goto err_out_iounmap;
+	}
+
+	dev->open = macb_open;
+	dev->stop = macb_close;
+	dev->hard_start_xmit = macb_start_xmit;
+	dev->get_stats = macb_get_stats;
+	dev->do_ioctl = macb_ioctl;
+	dev->poll = macb_poll;
+	dev->weight = 64;
+	dev->ethtool_ops = &macb_ethtool_ops;
+
+	dev->base_addr = regs->start;
+
+	INIT_WORK(&bp->periodic_task, macb_periodic_task, bp);
+	mutex_init(&bp->mdio_mutex);
+	init_completion(&bp->mdio_complete);
+
+	/* Set MII management clock divider */
+	pclk_hz = clk_get_rate(bp->pclk);
+	if (pclk_hz <= 20000000)
+		config = MACB_BF(CLK, MACB_CLK_DIV8);
+	else if (pclk_hz <= 40000000)
+		config = MACB_BF(CLK, MACB_CLK_DIV16);
+	else if (pclk_hz <= 80000000)
+		config = MACB_BF(CLK, MACB_CLK_DIV32);
+	else
+		config = MACB_BF(CLK, MACB_CLK_DIV64);
+	macb_writel(bp, NCFGR, config);
+
+	bp->mii.dev = dev;
+	bp->mii.mdio_read = macb_mdio_read;
+	bp->mii.mdio_write = macb_mdio_write;
+	bp->mii.phy_id_mask = 0x1f;
+	bp->mii.reg_num_mask = 0x1f;
+
+	macb_get_hwaddr(bp);
+	err = macb_phy_probe(bp);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to detect PHY, aborting.\n");
+		goto err_out_free_irq;
+	}
+
+	pdata = pdev->dev.platform_data;
+	if (pdata && pdata->is_rmii)
+		macb_writel(bp, USRIO, 0);
+	else
+		macb_writel(bp, USRIO, MACB_BIT(MII));
+
+	bp->tx_pending = DEF_TX_RING_PENDING;
+
+	err = register_netdev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
+		goto err_out_free_irq;
+	}
+
+	platform_set_drvdata(pdev, dev);
+
+	macb_register_sysfs(dev);
+
+	printk(KERN_INFO "%s: Atmel MACB at 0x%08lx irq %d "
+	       "(%02x:%02x:%02x:%02x:%02x:%02x)\n",
+	       dev->name, dev->base_addr, dev->irq,
+	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	return 0;
+
+err_out_free_irq:
+	free_irq(dev->irq, dev);
+err_out_iounmap:
+	iounmap(bp->regs);
+err_out_disable_clocks:
+	clk_disable(bp->hclk);
+	clk_disable(bp->pclk);
+	clk_put(bp->hclk);
+err_out_put_pclk:
+	clk_put(bp->pclk);
+err_out_free_dev:
+	free_netdev(dev);
+err_out:
+	platform_set_drvdata(pdev, NULL);
+	return err;
+}
+
+static int __devexit macb_remove(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct macb *bp;
+
+	dev = platform_get_drvdata(pdev);
+
+	if (dev) {
+		bp = netdev_priv(dev);
+		macb_unregister_sysfs(dev);
+		unregister_netdev(dev);
+		free_irq(dev->irq, dev);
+		iounmap(bp->regs);
+		clk_disable(bp->hclk);
+		clk_disable(bp->pclk);
+		clk_put(bp->hclk);
+		clk_put(bp->pclk);
+		free_netdev(dev);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver macb_driver = {
+	.probe		= macb_probe,
+	.remove		= __devexit_p(macb_remove),
+	.driver		= {
+		.name		= "macb",
+	},
+};
+
+static int __init macb_init(void)
+{
+	return platform_driver_register(&macb_driver);
+}
+
+static void __exit macb_exit(void)
+{
+	platform_driver_unregister(&macb_driver);
+}
+
+module_init(macb_init);
+module_exit(macb_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Atmel MACB Ethernet driver");
+MODULE_AUTHOR("Haavard Skinnemoen <hskinnemoen@atmel.com>");
Index: linux-2.6.19-avr1/drivers/net/macb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/net/macb.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,387 @@
+/*
+ * Atmel MACB Ethernet Controller driver
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _MACB_H
+#define _MACB_H
+
+/* MACB register offsets */
+#define MACB_NCR				0x0000
+#define MACB_NCFGR				0x0004
+#define MACB_NSR				0x0008
+#define MACB_TSR				0x0014
+#define MACB_RBQP				0x0018
+#define MACB_TBQP				0x001c
+#define MACB_RSR				0x0020
+#define MACB_ISR				0x0024
+#define MACB_IER				0x0028
+#define MACB_IDR				0x002c
+#define MACB_IMR				0x0030
+#define MACB_MAN				0x0034
+#define MACB_PTR				0x0038
+#define MACB_PFR				0x003c
+#define MACB_FTO				0x0040
+#define MACB_SCF				0x0044
+#define MACB_MCF				0x0048
+#define MACB_FRO				0x004c
+#define MACB_FCSE				0x0050
+#define MACB_ALE				0x0054
+#define MACB_DTF				0x0058
+#define MACB_LCOL				0x005c
+#define MACB_EXCOL				0x0060
+#define MACB_TUND				0x0064
+#define MACB_CSE				0x0068
+#define MACB_RRE				0x006c
+#define MACB_ROVR				0x0070
+#define MACB_RSE				0x0074
+#define MACB_ELE				0x0078
+#define MACB_RJA				0x007c
+#define MACB_USF				0x0080
+#define MACB_STE				0x0084
+#define MACB_RLE				0x0088
+#define MACB_TPF				0x008c
+#define MACB_HRB				0x0090
+#define MACB_HRT				0x0094
+#define MACB_SA1B				0x0098
+#define MACB_SA1T				0x009c
+#define MACB_SA2B				0x00a0
+#define MACB_SA2T				0x00a4
+#define MACB_SA3B				0x00a8
+#define MACB_SA3T				0x00ac
+#define MACB_SA4B				0x00b0
+#define MACB_SA4T				0x00b4
+#define MACB_TID				0x00b8
+#define MACB_TPQ				0x00bc
+#define MACB_USRIO				0x00c0
+#define MACB_WOL				0x00c4
+
+/* Bitfields in NCR */
+#define MACB_LB_OFFSET				0
+#define MACB_LB_SIZE				1
+#define MACB_LLB_OFFSET				1
+#define MACB_LLB_SIZE				1
+#define MACB_RE_OFFSET				2
+#define MACB_RE_SIZE				1
+#define MACB_TE_OFFSET				3
+#define MACB_TE_SIZE				1
+#define MACB_MPE_OFFSET				4
+#define MACB_MPE_SIZE				1
+#define MACB_CLRSTAT_OFFSET			5
+#define MACB_CLRSTAT_SIZE			1
+#define MACB_INCSTAT_OFFSET			6
+#define MACB_INCSTAT_SIZE			1
+#define MACB_WESTAT_OFFSET			7
+#define MACB_WESTAT_SIZE			1
+#define MACB_BP_OFFSET				8
+#define MACB_BP_SIZE				1
+#define MACB_TSTART_OFFSET			9
+#define MACB_TSTART_SIZE			1
+#define MACB_THALT_OFFSET			10
+#define MACB_THALT_SIZE				1
+#define MACB_NCR_TPF_OFFSET			11
+#define MACB_NCR_TPF_SIZE			1
+#define MACB_TZQ_OFFSET				12
+#define MACB_TZQ_SIZE				1
+
+/* Bitfields in NCFGR */
+#define MACB_SPD_OFFSET				0
+#define MACB_SPD_SIZE				1
+#define MACB_FD_OFFSET				1
+#define MACB_FD_SIZE				1
+#define MACB_BIT_RATE_OFFSET			2
+#define MACB_BIT_RATE_SIZE			1
+#define MACB_JFRAME_OFFSET			3
+#define MACB_JFRAME_SIZE			1
+#define MACB_CAF_OFFSET				4
+#define MACB_CAF_SIZE				1
+#define MACB_NBC_OFFSET				5
+#define MACB_NBC_SIZE				1
+#define MACB_NCFGR_MTI_OFFSET			6
+#define MACB_NCFGR_MTI_SIZE			1
+#define MACB_UNI_OFFSET				7
+#define MACB_UNI_SIZE				1
+#define MACB_BIG_OFFSET				8
+#define MACB_BIG_SIZE				1
+#define MACB_EAE_OFFSET				9
+#define MACB_EAE_SIZE				1
+#define MACB_CLK_OFFSET				10
+#define MACB_CLK_SIZE				2
+#define MACB_RTY_OFFSET				12
+#define MACB_RTY_SIZE				1
+#define MACB_PAE_OFFSET				13
+#define MACB_PAE_SIZE				1
+#define MACB_RBOF_OFFSET			14
+#define MACB_RBOF_SIZE				2
+#define MACB_RLCE_OFFSET			16
+#define MACB_RLCE_SIZE				1
+#define MACB_DRFCS_OFFSET			17
+#define MACB_DRFCS_SIZE				1
+#define MACB_EFRHD_OFFSET			18
+#define MACB_EFRHD_SIZE				1
+#define MACB_IRXFCS_OFFSET			19
+#define MACB_IRXFCS_SIZE			1
+
+/* Bitfields in NSR */
+#define MACB_NSR_LINK_OFFSET			0
+#define MACB_NSR_LINK_SIZE			1
+#define MACB_MDIO_OFFSET			1
+#define MACB_MDIO_SIZE				1
+#define MACB_IDLE_OFFSET			2
+#define MACB_IDLE_SIZE				1
+
+/* Bitfields in TSR */
+#define MACB_UBR_OFFSET				0
+#define MACB_UBR_SIZE				1
+#define MACB_COL_OFFSET				1
+#define MACB_COL_SIZE				1
+#define MACB_TSR_RLE_OFFSET			2
+#define MACB_TSR_RLE_SIZE			1
+#define MACB_TGO_OFFSET				3
+#define MACB_TGO_SIZE				1
+#define MACB_BEX_OFFSET				4
+#define MACB_BEX_SIZE				1
+#define MACB_COMP_OFFSET			5
+#define MACB_COMP_SIZE				1
+#define MACB_UND_OFFSET				6
+#define MACB_UND_SIZE				1
+
+/* Bitfields in RSR */
+#define MACB_BNA_OFFSET				0
+#define MACB_BNA_SIZE				1
+#define MACB_REC_OFFSET				1
+#define MACB_REC_SIZE				1
+#define MACB_OVR_OFFSET				2
+#define MACB_OVR_SIZE				1
+
+/* Bitfields in ISR/IER/IDR/IMR */
+#define MACB_MFD_OFFSET				0
+#define MACB_MFD_SIZE				1
+#define MACB_RCOMP_OFFSET			1
+#define MACB_RCOMP_SIZE				1
+#define MACB_RXUBR_OFFSET			2
+#define MACB_RXUBR_SIZE				1
+#define MACB_TXUBR_OFFSET			3
+#define MACB_TXUBR_SIZE				1
+#define MACB_ISR_TUND_OFFSET			4
+#define MACB_ISR_TUND_SIZE			1
+#define MACB_ISR_RLE_OFFSET			5
+#define MACB_ISR_RLE_SIZE			1
+#define MACB_TXERR_OFFSET			6
+#define MACB_TXERR_SIZE				1
+#define MACB_TCOMP_OFFSET			7
+#define MACB_TCOMP_SIZE				1
+#define MACB_ISR_LINK_OFFSET			9
+#define MACB_ISR_LINK_SIZE			1
+#define MACB_ISR_ROVR_OFFSET			10
+#define MACB_ISR_ROVR_SIZE			1
+#define MACB_HRESP_OFFSET			11
+#define MACB_HRESP_SIZE				1
+#define MACB_PFR_OFFSET				12
+#define MACB_PFR_SIZE				1
+#define MACB_PTZ_OFFSET				13
+#define MACB_PTZ_SIZE				1
+
+/* Bitfields in MAN */
+#define MACB_DATA_OFFSET			0
+#define MACB_DATA_SIZE				16
+#define MACB_CODE_OFFSET			16
+#define MACB_CODE_SIZE				2
+#define MACB_REGA_OFFSET			18
+#define MACB_REGA_SIZE				5
+#define MACB_PHYA_OFFSET			23
+#define MACB_PHYA_SIZE				5
+#define MACB_RW_OFFSET				28
+#define MACB_RW_SIZE				2
+#define MACB_SOF_OFFSET				30
+#define MACB_SOF_SIZE				2
+
+/* Bitfields in USRIO */
+#define MACB_MII_OFFSET				0
+#define MACB_MII_SIZE				1
+#define MACB_EAM_OFFSET				1
+#define MACB_EAM_SIZE				1
+#define MACB_TX_PAUSE_OFFSET			2
+#define MACB_TX_PAUSE_SIZE			1
+#define MACB_TX_PAUSE_ZERO_OFFSET		3
+#define MACB_TX_PAUSE_ZERO_SIZE			1
+
+/* Bitfields in WOL */
+#define MACB_IP_OFFSET				0
+#define MACB_IP_SIZE				16
+#define MACB_MAG_OFFSET				16
+#define MACB_MAG_SIZE				1
+#define MACB_ARP_OFFSET				17
+#define MACB_ARP_SIZE				1
+#define MACB_SA1_OFFSET				18
+#define MACB_SA1_SIZE				1
+#define MACB_WOL_MTI_OFFSET			19
+#define MACB_WOL_MTI_SIZE			1
+
+/* Constants for CLK */
+#define MACB_CLK_DIV8				0
+#define MACB_CLK_DIV16				1
+#define MACB_CLK_DIV32				2
+#define MACB_CLK_DIV64				3
+
+/* Constants for MAN register */
+#define MACB_MAN_SOF				1
+#define MACB_MAN_WRITE				1
+#define MACB_MAN_READ				2
+#define MACB_MAN_CODE				2
+
+/* Bit manipulation macros */
+#define MACB_BIT(name)					\
+	(1 << MACB_##name##_OFFSET)
+#define MACB_BF(name,value)				\
+	(((value) & ((1 << MACB_##name##_SIZE) - 1))	\
+	 << MACB_##name##_OFFSET)
+#define MACB_BFEXT(name,value)\
+	(((value) >> MACB_##name##_OFFSET)		\
+	 & ((1 << MACB_##name##_SIZE) - 1))
+#define MACB_BFINS(name,value,old)			\
+	(((old) & ~(((1 << MACB_##name##_SIZE) - 1)	\
+		    << MACB_##name##_OFFSET))		\
+	 | MACB_BF(name,value))
+
+/* Register access macros */
+#define macb_readl(port,reg)				\
+	__raw_readl((port)->regs + MACB_##reg)
+#define macb_writel(port,reg,value)			\
+	__raw_writel((value), (port)->regs + MACB_##reg)
+
+struct dma_desc {
+	u32	addr;
+	u32	ctrl;
+};
+
+/* DMA descriptor bitfields */
+#define MACB_RX_USED_OFFSET			0
+#define MACB_RX_USED_SIZE			1
+#define MACB_RX_WRAP_OFFSET			1
+#define MACB_RX_WRAP_SIZE			1
+#define MACB_RX_WADDR_OFFSET			2
+#define MACB_RX_WADDR_SIZE			30
+
+#define MACB_RX_FRMLEN_OFFSET			0
+#define MACB_RX_FRMLEN_SIZE			12
+#define MACB_RX_OFFSET_OFFSET			12
+#define MACB_RX_OFFSET_SIZE			2
+#define MACB_RX_SOF_OFFSET			14
+#define MACB_RX_SOF_SIZE			1
+#define MACB_RX_EOF_OFFSET			15
+#define MACB_RX_EOF_SIZE			1
+#define MACB_RX_CFI_OFFSET			16
+#define MACB_RX_CFI_SIZE			1
+#define MACB_RX_VLAN_PRI_OFFSET			17
+#define MACB_RX_VLAN_PRI_SIZE			3
+#define MACB_RX_PRI_TAG_OFFSET			20
+#define MACB_RX_PRI_TAG_SIZE			1
+#define MACB_RX_VLAN_TAG_OFFSET			21
+#define MACB_RX_VLAN_TAG_SIZE			1
+#define MACB_RX_TYPEID_MATCH_OFFSET		22
+#define MACB_RX_TYPEID_MATCH_SIZE		1
+#define MACB_RX_SA4_MATCH_OFFSET		23
+#define MACB_RX_SA4_MATCH_SIZE			1
+#define MACB_RX_SA3_MATCH_OFFSET		24
+#define MACB_RX_SA3_MATCH_SIZE			1
+#define MACB_RX_SA2_MATCH_OFFSET		25
+#define MACB_RX_SA2_MATCH_SIZE			1
+#define MACB_RX_SA1_MATCH_OFFSET		26
+#define MACB_RX_SA1_MATCH_SIZE			1
+#define MACB_RX_EXT_MATCH_OFFSET		28
+#define MACB_RX_EXT_MATCH_SIZE			1
+#define MACB_RX_UHASH_MATCH_OFFSET		29
+#define MACB_RX_UHASH_MATCH_SIZE		1
+#define MACB_RX_MHASH_MATCH_OFFSET		30
+#define MACB_RX_MHASH_MATCH_SIZE		1
+#define MACB_RX_BROADCAST_OFFSET		31
+#define MACB_RX_BROADCAST_SIZE			1
+
+#define MACB_TX_FRMLEN_OFFSET			0
+#define MACB_TX_FRMLEN_SIZE			11
+#define MACB_TX_LAST_OFFSET			15
+#define MACB_TX_LAST_SIZE			1
+#define MACB_TX_NOCRC_OFFSET			16
+#define MACB_TX_NOCRC_SIZE			1
+#define MACB_TX_BUF_EXHAUSTED_OFFSET		27
+#define MACB_TX_BUF_EXHAUSTED_SIZE		1
+#define MACB_TX_UNDERRUN_OFFSET			28
+#define MACB_TX_UNDERRUN_SIZE			1
+#define MACB_TX_ERROR_OFFSET			29
+#define MACB_TX_ERROR_SIZE			1
+#define MACB_TX_WRAP_OFFSET			30
+#define MACB_TX_WRAP_SIZE			1
+#define MACB_TX_USED_OFFSET			31
+#define MACB_TX_USED_SIZE			1
+
+struct ring_info {
+	struct sk_buff		*skb;
+	dma_addr_t		mapping;
+};
+
+/*
+ * Hardware-collected statistics. Used when updating the network
+ * device stats by a periodic timer.
+ */
+struct macb_stats {
+	u32	rx_pause_frames;
+	u32	tx_ok;
+	u32	tx_single_cols;
+	u32	tx_multiple_cols;
+	u32	rx_ok;
+	u32	rx_fcs_errors;
+	u32	rx_align_errors;
+	u32	tx_deferred;
+	u32	tx_late_cols;
+	u32	tx_excessive_cols;
+	u32	tx_underruns;
+	u32	tx_carrier_errors;
+	u32	rx_resource_errors;
+	u32	rx_overruns;
+	u32	rx_symbol_errors;
+	u32	rx_oversize_pkts;
+	u32	rx_jabbers;
+	u32	rx_undersize_pkts;
+	u32	sqe_test_errors;
+	u32	rx_length_mismatch;
+	u32	tx_pause_frames;
+};
+
+struct macb {
+	void __iomem		*regs;
+
+	unsigned int		rx_tail;
+	struct dma_desc		*rx_ring;
+	void			*rx_buffers;
+
+	unsigned int		tx_head, tx_tail;
+	struct dma_desc		*tx_ring;
+	struct ring_info	*tx_skb;
+
+	spinlock_t		lock;
+	struct platform_device	*pdev;
+	struct clk		*pclk;
+	struct clk		*hclk;
+	struct net_device	*dev;
+	struct net_device_stats	stats;
+	struct macb_stats	hw_stats;
+
+	dma_addr_t		rx_ring_dma;
+	dma_addr_t		tx_ring_dma;
+	dma_addr_t		rx_buffers_dma;
+
+	unsigned int		rx_pending, tx_pending;
+
+	struct work_struct	periodic_task;
+
+	struct mutex		mdio_mutex;
+	struct completion	mdio_complete;
+	struct mii_if_info	mii;
+};
+
+#endif /* _MACB_H */
Index: linux-2.6.19-avr1/arch/avr32/drivers/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/drivers/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_DW_DMAC)			+= dw-dmac.o
Index: linux-2.6.19-avr1/arch/avr32/drivers/dw-dmac.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/drivers/dw-dmac.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,754 @@
+/*
+ * Driver for the Synopsys DesignWare DMA Controller
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/dma-controller.h>
+#include <asm/io.h>
+
+#include "dw-dmac.h"
+
+#define DMAC_NR_CHANNELS 3
+#define DMAC_MAX_BLOCKSIZE 4095
+
+enum {
+	CH_STATE_FREE = 0,
+	CH_STATE_ALLOCATED,
+	CH_STATE_BUSY,
+};
+
+struct dw_dma_lli {
+	dma_addr_t	sar;
+	dma_addr_t	dar;
+	dma_addr_t	llp;
+	u32		ctllo;
+	u32		ctlhi;
+	u32		sstat;
+	u32		dstat;
+};
+
+struct dw_dma_block {
+	struct dw_dma_lli *lli_vaddr;
+	dma_addr_t lli_dma_addr;
+};
+
+struct dw_dma_channel {
+	unsigned int state;
+        int is_cyclic;
+	struct dma_request_sg *req_sg;
+	struct dma_request_cyclic *req_cyclic;
+	unsigned int nr_blocks;
+	int direction;
+	struct dw_dma_block *block;
+};
+
+struct dw_dma_controller {
+	spinlock_t lock;
+	void * __iomem	regs;
+	struct dma_pool *lli_pool;
+	struct clk *hclk;
+	struct dma_controller dma;
+	struct dw_dma_channel channel[DMAC_NR_CHANNELS];
+};
+#define to_dw_dmac(dmac) container_of(dmac, struct dw_dma_controller, dma)
+
+#define dmac_writel_hi(dmac, reg, value) \
+	__raw_writel((value), (dmac)->regs + DW_DMAC_##reg + 4)
+#define dmac_readl_hi(dmac, reg) \
+	__raw_readl((dmac)->regs + DW_DMAC_##reg + 4)
+#define dmac_writel_lo(dmac, reg, value) \
+	__raw_writel((value), (dmac)->regs + DW_DMAC_##reg)
+#define dmac_readl_lo(dmac, reg) \
+	__raw_readl((dmac)->regs + DW_DMAC_##reg)
+#define dmac_chan_writel_hi(dmac, chan, reg, value) \
+	__raw_writel((value), ((dmac)->regs + 0x58 * (chan) \
+			       + DW_DMAC_CHAN_##reg + 4))
+#define dmac_chan_readl_hi(dmac, chan, reg) \
+	__raw_readl((dmac)->regs + 0x58 * (chan) + DW_DMAC_CHAN_##reg + 4)
+#define dmac_chan_writel_lo(dmac, chan, reg, value) \
+	__raw_writel((value), (dmac)->regs + 0x58 * (chan) + DW_DMAC_CHAN_##reg)
+#define dmac_chan_readl_lo(dmac, chan, reg) \
+	__raw_readl((dmac)->regs + 0x58 * (chan) + DW_DMAC_CHAN_##reg)
+#define set_channel_bit(dmac, reg, chan) \
+	dmac_writel_lo(dmac, reg, (1 << (chan)) | (1 << ((chan) + 8)))
+#define clear_channel_bit(dmac, reg, chan) \
+	dmac_writel_lo(dmac, reg, (0 << (chan)) | (1 << ((chan) + 8)))
+
+static int dmac_alloc_channel(struct dma_controller *_dmac)
+{
+	struct dw_dma_controller *dmac = to_dw_dmac(_dmac);
+	struct dw_dma_channel *chan;
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&dmac->lock, flags);
+	for (i = 0; i < DMAC_NR_CHANNELS; i++)
+		if (dmac->channel[i].state == CH_STATE_FREE)
+			break;
+
+	if (i < DMAC_NR_CHANNELS) {
+		chan = &dmac->channel[i];
+		chan->state = CH_STATE_ALLOCATED;
+	} else {
+		i = -EBUSY;
+	}
+
+	spin_unlock_irqrestore(&dmac->lock, flags);
+
+	return i;
+}
+
+static void dmac_release_channel(struct dma_controller *_dmac, int channel)
+{
+	struct dw_dma_controller *dmac = to_dw_dmac(_dmac);
+
+	BUG_ON(channel >= DMAC_NR_CHANNELS
+	       || dmac->channel[channel].state != CH_STATE_ALLOCATED);
+
+	dmac->channel[channel].state = CH_STATE_FREE;
+}
+
+static struct dw_dma_block *allocate_blocks(struct dw_dma_controller *dmac,
+					    unsigned int nr_blocks)
+{
+	struct dw_dma_block *block;
+	void *p;
+	unsigned int i;
+
+	block = kmalloc(nr_blocks * sizeof(*block),
+			GFP_KERNEL);
+	if (unlikely(!block))
+		return NULL;
+
+	for (i = 0; i < nr_blocks; i++) {
+		p = dma_pool_alloc(dmac->lli_pool, GFP_KERNEL,
+				   &block[i].lli_dma_addr);
+		block[i].lli_vaddr = p;
+		if (unlikely(!p))
+			goto fail;
+	}
+
+	return block;
+
+fail:
+	for (i = 0; i < nr_blocks; i++) {
+		if (!block[i].lli_vaddr)
+			break;
+		dma_pool_free(dmac->lli_pool, block[i].lli_vaddr,
+			      block[i].lli_dma_addr);
+	}
+	kfree(block);
+	return NULL;
+}
+
+static int dmac_prepare_request_sg(struct dma_controller *_dmac,
+				   struct dma_request_sg *req)
+{
+	struct dw_dma_controller *dmac = to_dw_dmac(_dmac);
+	struct dw_dma_channel *chan;
+	unsigned long ctlhi, ctllo, cfghi, cfglo;
+	unsigned long block_size;
+	int ret, i, nr_blocks, direction;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dmac->lock, flags);
+
+	ret = -EINVAL;
+	if (req->req.channel >= DMAC_NR_CHANNELS
+	    || dmac->channel[req->req.channel].state != CH_STATE_ALLOCATED
+	    || req->block_size > DMAC_MAX_BLOCKSIZE) {
+		spin_unlock_irqrestore(&dmac->lock, flags);
+		return -EINVAL;
+	}
+
+	chan = &dmac->channel[req->req.channel];
+	chan->state = CH_STATE_BUSY;
+	chan->req_sg = req;
+	chan->is_cyclic = 0;
+
+	/*
+	 * We have marked the channel as busy, so no need to keep the
+	 * lock as long as we only touch the channel-specific
+	 * registers
+	 */
+	spin_unlock_irqrestore(&dmac->lock, flags);
+
+	/*
+	 * There may be limitations in the driver and/or the DMA
+	 * controller that prevents us from sending a whole
+	 * scatterlist item in one go.  Taking this into account,
+	 * calculate the number of block transfers we need to set up.
+	 *
+	 * FIXME: Let the peripheral driver know about the maximum
+	 * block size we support. We really don't want to use a
+	 * different block size than what was suggested by the
+	 * peripheral.
+	 *
+	 * Each block will get its own Linked List Item (LLI) below.
+	 */
+	block_size = req->block_size;
+	pr_debug("block_size = %lu, nr_sg = %u\n", block_size, req->nr_sg);
+	for (i = 0, nr_blocks = 0; i < req->nr_sg; i++) {
+		pr_debug("sg[i].length = %u\n", req->sg[i].length);
+		BUG_ON(req->sg[i].length % block_size);
+		nr_blocks += req->sg[i].length / block_size;
+	}
+
+	BUG_ON(nr_blocks == 0);
+	chan->nr_blocks = nr_blocks;
+
+	ret = -EINVAL;
+	cfglo = cfghi = 0;
+	switch (req->direction) {
+	case DMA_DIR_MEM_TO_PERIPH:
+		direction = DMA_TO_DEVICE;
+		cfghi = req->periph_id << (43 - 32);
+		break;
+
+	case DMA_DIR_PERIPH_TO_MEM:
+		direction = DMA_FROM_DEVICE;
+		cfghi = req->periph_id << (39 - 32);
+		break;
+	default:
+		goto out_unclaim_channel;
+	}
+
+        chan->direction = direction;
+
+	dmac_chan_writel_hi(dmac, req->req.channel, CFG, cfghi);
+	dmac_chan_writel_lo(dmac, req->req.channel, CFG, cfglo);
+
+	ctlhi = block_size >> req->width;
+	ctllo = ((req->direction << 20)
+		 // | (1 << 14) | (1 << 11) // source/dest burst trans len
+		 | (req->width << 4) | (req->width << 1)
+		 | (1 << 0));		 // interrupt enable
+
+	if (nr_blocks == 1) {
+		/* Only one block: No need to use block chaining */
+		if (direction == DMA_TO_DEVICE) {
+			dmac_chan_writel_lo(dmac, req->req.channel, SAR,
+					    req->sg->dma_address);
+			dmac_chan_writel_lo(dmac, req->req.channel, DAR,
+					    req->data_reg);
+			ctllo |= 2 << 7; // no dst increment
+		} else {
+			dmac_chan_writel_lo(dmac, req->req.channel, SAR,
+					    req->data_reg);
+			dmac_chan_writel_lo(dmac, req->req.channel, DAR,
+					    req->sg->dma_address);
+			ctllo |= 2 << 9; // no src increment
+		}
+		dmac_chan_writel_lo(dmac, req->req.channel, CTL, ctllo);
+		dmac_chan_writel_hi(dmac, req->req.channel, CTL, ctlhi);
+	} else {
+		struct dw_dma_lli *lli, *lli_prev = NULL;
+		int j = 0, offset = 0;
+
+		ret = -ENOMEM;
+		chan->block = allocate_blocks(dmac, nr_blocks);
+		if (!chan->block)
+			goto out_unclaim_channel;
+
+		if (direction == DMA_TO_DEVICE)
+			ctllo |= 1 << 28 | 1 << 27 | 2 << 7;
+		else
+			ctllo |= 1 << 28 | 1 << 27 | 2 << 9;
+
+		/*
+		 * Map scatterlist items to blocks. One scatterlist
+		 * item may need more than one block for the reasons
+		 * mentioned above.
+		 */
+		for (i = 0; i < nr_blocks; i++) {
+			lli = chan->block[i].lli_vaddr;
+			if (lli_prev) {
+				lli_prev->llp = chan->block[i].lli_dma_addr;
+				pr_debug("lli[%d] (0x%p/0x%x): 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+					 i - 1, chan->block[i - 1].lli_vaddr,
+					 chan->block[i - 1].lli_dma_addr,
+					 lli_prev->sar, lli_prev->dar, lli_prev->llp,
+					 lli_prev->ctllo, lli_prev->ctlhi);
+			}
+			lli->llp = 0;
+			lli->ctllo = ctllo;
+			lli->ctlhi = ctlhi;
+			if (direction == DMA_TO_DEVICE) {
+				lli->sar = req->sg[j].dma_address + offset;
+				lli->dar = req->data_reg;
+			} else {
+				lli->sar = req->data_reg;
+				lli->dar = req->sg[j].dma_address + offset;
+			}
+			lli_prev = lli;
+
+			offset += block_size;
+			if (offset > req->sg[j].length) {
+				j++;
+				offset = 0;
+			}
+		}
+
+		pr_debug("lli[%d] (0x%p/0x%x): 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+			 i - 1, chan->block[i - 1].lli_vaddr,
+			 chan->block[i - 1].lli_dma_addr, lli_prev->sar,
+			 lli_prev->dar, lli_prev->llp,
+			 lli_prev->ctllo, lli_prev->ctlhi);
+
+		/*
+		 * SAR, DAR and CTL are initialized from the LLI. We
+		 * only have to enable the LLI bits in CTL.
+		 */
+		dmac_chan_writel_lo(dmac, req->req.channel, LLP,
+				    chan->block[0].lli_dma_addr);
+		dmac_chan_writel_lo(dmac, req->req.channel, CTL, 1 << 28 | 1 << 27);
+	}
+
+	set_channel_bit(dmac, MASK_XFER, req->req.channel);
+	set_channel_bit(dmac, MASK_ERROR, req->req.channel);
+	if (req->req.block_complete)
+		set_channel_bit(dmac, MASK_BLOCK, req->req.channel);
+	else
+		clear_channel_bit(dmac, MASK_BLOCK, req->req.channel);
+
+	return 0;
+
+out_unclaim_channel:
+	chan->state = CH_STATE_ALLOCATED;
+	return ret;
+}
+
+static int dmac_prepare_request_cyclic(struct dma_controller *_dmac,
+                                       struct dma_request_cyclic *req)
+{
+	struct dw_dma_controller *dmac = to_dw_dmac(_dmac);
+	struct dw_dma_channel *chan;
+	unsigned long ctlhi, ctllo, cfghi, cfglo;
+	unsigned long block_size;
+	int ret, i, direction;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dmac->lock, flags);
+
+        block_size = (req->buffer_size/req->periods) >> req->width;
+
+	ret = -EINVAL;
+	if (req->req.channel >= DMAC_NR_CHANNELS
+	    || dmac->channel[req->req.channel].state != CH_STATE_ALLOCATED
+            || (req->periods == 0)
+	    || block_size > DMAC_MAX_BLOCKSIZE) {
+		spin_unlock_irqrestore(&dmac->lock, flags);
+		return -EINVAL;
+	}
+
+	chan = &dmac->channel[req->req.channel];
+	chan->state = CH_STATE_BUSY;
+	chan->is_cyclic = 1;
+        chan->req_cyclic = req;
+
+	/*
+	 * We have marked the channel as busy, so no need to keep the
+	 * lock as long as we only touch the channel-specific
+	 * registers
+	 */
+	spin_unlock_irqrestore(&dmac->lock, flags);
+
+	/*
+          Setup
+	 */
+	BUG_ON(req->buffer_size % req->periods);
+	/* printk(KERN_INFO "block_size = %lu, periods = %u\n", block_size, req->periods); */
+
+	chan->nr_blocks = req->periods;
+
+	ret = -EINVAL;
+	cfglo = cfghi = 0;
+	switch (req->direction) {
+	case DMA_DIR_MEM_TO_PERIPH:
+		direction = DMA_TO_DEVICE;
+		cfghi = req->periph_id << (43 - 32);
+		break;
+
+	case DMA_DIR_PERIPH_TO_MEM:
+		direction = DMA_FROM_DEVICE;
+		cfghi = req->periph_id << (39 - 32);
+		break;
+	default:
+		goto out_unclaim_channel;
+	}
+
+        chan->direction = direction;
+
+	dmac_chan_writel_hi(dmac, req->req.channel, CFG, cfghi);
+	dmac_chan_writel_lo(dmac, req->req.channel, CFG, cfglo);
+
+	ctlhi = block_size;
+	ctllo = ((req->direction << 20)
+		 | (req->width << 4) | (req->width << 1)
+		 | (1 << 0));		 // interrupt enable
+
+        {
+		struct dw_dma_lli *lli = NULL, *lli_prev = NULL;
+
+		ret = -ENOMEM;
+		chan->block = allocate_blocks(dmac, req->periods);
+		if (!chan->block)
+			goto out_unclaim_channel;
+
+		if (direction == DMA_TO_DEVICE)
+			ctllo |= 1 << 28 | 1 << 27 | 2 << 7;
+		else
+			ctllo |= 1 << 28 | 1 << 27 | 2 << 9;
+
+		/*
+		 * Set up a linked list items where each period gets
+		 * an item. The linked list item for the last period
+		 * points back to the star of the buffer making a
+		 * cyclic buffer.
+		 */
+		for (i = 0; i < req->periods; i++) {
+			lli = chan->block[i].lli_vaddr;
+			if (lli_prev) {
+				lli_prev->llp = chan->block[i].lli_dma_addr;
+				/* printk(KERN_INFO "lli[%d] (0x%p/0x%x): 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+				   i - 1, chan->block[i - 1].lli_vaddr,
+				   chan->block[i - 1].lli_dma_addr,
+				   lli_prev->sar, lli_prev->dar, lli_prev->llp,
+				   lli_prev->ctllo, lli_prev->ctlhi);*/
+			}
+			lli->llp = 0;
+			lli->ctllo = ctllo;
+			lli->ctlhi = ctlhi;
+			if (direction == DMA_TO_DEVICE) {
+				lli->sar = req->buffer_start + i*(block_size << req->width);
+				lli->dar = req->data_reg;
+			} else {
+				lli->sar = req->data_reg;
+				lli->dar = req->buffer_start + i*(block_size << req->width);
+			}
+			lli_prev = lli;
+		}
+		lli->llp = chan->block[0].lli_dma_addr;
+
+		/*printk(KERN_INFO "lli[%d] (0x%p/0x%x): 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		  i - 1, chan->block[i - 1].lli_vaddr,
+		  chan->block[i - 1].lli_dma_addr, lli_prev->sar,
+		  lli_prev->dar, lli_prev->llp,
+		  lli_prev->ctllo, lli_prev->ctlhi); */
+
+		/*
+		 * SAR, DAR and CTL are initialized from the LLI. We
+		 * only have to enable the LLI bits in CTL.
+		 */
+		dmac_chan_writel_lo(dmac, req->req.channel, LLP,
+				    chan->block[0].lli_dma_addr);
+		dmac_chan_writel_lo(dmac, req->req.channel, CTL, 1 << 28 | 1 << 27);
+	}
+
+	clear_channel_bit(dmac, MASK_XFER, req->req.channel);
+	set_channel_bit(dmac, MASK_ERROR, req->req.channel);
+	if (req->req.block_complete)
+		set_channel_bit(dmac, MASK_BLOCK, req->req.channel);
+	else
+		clear_channel_bit(dmac, MASK_BLOCK, req->req.channel);
+
+	return 0;
+
+out_unclaim_channel:
+	chan->state = CH_STATE_ALLOCATED;
+	return ret;
+}
+
+static int dmac_start_request(struct dma_controller *_dmac,
+			      unsigned int channel)
+{
+	struct dw_dma_controller *dmac = to_dw_dmac(_dmac);
+
+	BUG_ON(channel >= DMAC_NR_CHANNELS);
+
+	set_channel_bit(dmac, CH_EN, channel);
+
+	return 0;
+}
+
+static dma_addr_t dmac_get_current_pos(struct dma_controller *_dmac,
+                                       unsigned int channel)
+{
+	struct dw_dma_controller *dmac = to_dw_dmac(_dmac);
+	struct dw_dma_channel *chan;
+        dma_addr_t current_pos;
+
+	BUG_ON(channel >= DMAC_NR_CHANNELS);
+
+        chan = &dmac->channel[channel];
+
+	switch (chan->direction) {
+	case DMA_TO_DEVICE:
+		current_pos = dmac_chan_readl_lo(dmac, channel, SAR);
+		break;
+	case DMA_FROM_DEVICE:
+		current_pos = dmac_chan_readl_lo(dmac, channel, DAR);
+		break;
+	default:
+		return 0;
+	}
+
+
+        if (!current_pos) {
+		if (chan->is_cyclic) {
+			current_pos = chan->req_cyclic->buffer_start;
+		} else {
+			current_pos = chan->req_sg->sg->dma_address;
+		}
+	}
+
+	return current_pos;
+}
+
+
+static void cleanup_channel(struct dw_dma_controller *dmac,
+			    struct dw_dma_channel *chan)
+{
+	unsigned int i;
+
+	if (chan->nr_blocks > 1) {
+		for (i = 0; i < chan->nr_blocks; i++)
+			dma_pool_free(dmac->lli_pool, chan->block[i].lli_vaddr,
+				      chan->block[i].lli_dma_addr);
+		kfree(chan->block);
+	}
+
+	chan->state = CH_STATE_ALLOCATED;
+}
+
+static int dmac_stop_request(struct dma_controller *_dmac,
+                             unsigned int channel)
+{
+	struct dw_dma_controller *dmac = to_dw_dmac(_dmac);
+
+	BUG_ON(channel >= DMAC_NR_CHANNELS);
+
+	BUG_ON(dmac->channel[channel].state != CH_STATE_BUSY);
+
+	clear_channel_bit(dmac, CH_EN, channel);
+
+        cleanup_channel(dmac, &dmac->channel[channel]);
+
+	return 0;
+}
+
+
+static void dmac_block_complete(struct dw_dma_controller *dmac)
+{
+	struct dw_dma_channel *chan;
+	unsigned long status, chanid;
+
+	status = dmac_readl_lo(dmac, STATUS_BLOCK);
+
+	while (status) {
+		struct dma_request *req;
+		chanid = __ffs(status);
+		chan = &dmac->channel[chanid];
+
+                if (chan->is_cyclic) {
+			BUG_ON(!chan->req_cyclic
+			       || !chan->req_cyclic->req.block_complete);
+			req = &chan->req_cyclic->req;
+                } else {
+			BUG_ON(!chan->req_sg || !chan->req_sg->req.block_complete);
+			req = &chan->req_sg->req;
+                }
+		dmac_writel_lo(dmac, CLEAR_BLOCK, 1 << chanid);
+		req->block_complete(req);
+		status = dmac_readl_lo(dmac, STATUS_BLOCK);
+	}
+}
+
+static void dmac_xfer_complete(struct dw_dma_controller *dmac)
+{
+	struct dw_dma_channel *chan;
+	struct dma_request *req;
+	unsigned long status, chanid;
+
+	status = dmac_readl_lo(dmac, STATUS_XFER);
+
+	while (status) {
+		chanid = __ffs(status);
+		chan = &dmac->channel[chanid];
+
+		dmac_writel_lo(dmac, CLEAR_XFER, 1 << chanid);
+
+                req = &chan->req_sg->req;
+                BUG_ON(!req);
+                cleanup_channel(dmac, chan);
+                if (req->xfer_complete)
+			req->xfer_complete(req);
+
+		status = dmac_readl_lo(dmac, STATUS_XFER);
+	}
+}
+
+static void dmac_error(struct dw_dma_controller *dmac)
+{
+	struct dw_dma_channel *chan;
+	unsigned long status, chanid;
+
+	status = dmac_readl_lo(dmac, STATUS_ERROR);
+
+	while (status) {
+		struct dma_request *req;
+
+		chanid = __ffs(status);
+		chan = &dmac->channel[chanid];
+
+		dmac_writel_lo(dmac, CLEAR_ERROR, 1 << chanid);
+		clear_channel_bit(dmac, CH_EN, chanid);
+
+                if (chan->is_cyclic) {
+			BUG_ON(!chan->req_cyclic);
+			req = &chan->req_cyclic->req;
+                } else {
+			BUG_ON(!chan->req_sg);
+			req = &chan->req_sg->req;
+                }
+
+		cleanup_channel(dmac, chan);
+		if (req->error)
+			req->error(req);
+
+		status = dmac_readl_lo(dmac, STATUS_XFER);
+	}
+}
+
+static irqreturn_t dmac_interrupt(int irq, void *dev_id)
+{
+	struct dw_dma_controller *dmac = dev_id;
+	unsigned long status;
+	int ret = IRQ_NONE;
+
+	spin_lock(&dmac->lock);
+
+	status = dmac_readl_lo(dmac, STATUS_INT);
+
+	while (status) {
+		ret = IRQ_HANDLED;
+		if (status & 0x10)
+			dmac_error(dmac);
+		if (status & 0x02)
+			dmac_block_complete(dmac);
+		if (status & 0x01)
+			dmac_xfer_complete(dmac);
+
+		status = dmac_readl_lo(dmac, STATUS_INT);
+	}
+
+	spin_unlock(&dmac->lock);
+	return ret;
+}
+
+static int __devinit dmac_probe(struct platform_device *pdev)
+{
+	struct dw_dma_controller *dmac;
+	struct resource *regs;
+	int ret;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+
+	dmac = kmalloc(sizeof(*dmac), GFP_KERNEL);
+	if (!dmac)
+		return -ENOMEM;
+	memset(dmac, 0, sizeof(*dmac));
+
+	dmac->hclk = clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(dmac->hclk)) {
+		ret = PTR_ERR(dmac->hclk);
+		goto out_free_dmac;
+	}
+	clk_enable(dmac->hclk);
+
+	ret = -ENOMEM;
+	dmac->lli_pool = dma_pool_create("dmac", &pdev->dev,
+					 sizeof(struct dw_dma_lli), 4, 0);
+	if (!dmac->lli_pool)
+		goto out_disable_clk;
+
+	spin_lock_init(&dmac->lock);
+	dmac->dma.dev = &pdev->dev;
+	dmac->dma.alloc_channel = dmac_alloc_channel;
+	dmac->dma.release_channel = dmac_release_channel;
+	dmac->dma.prepare_request_sg = dmac_prepare_request_sg;
+	dmac->dma.prepare_request_cyclic = dmac_prepare_request_cyclic;
+	dmac->dma.start_request = dmac_start_request;
+	dmac->dma.stop_request = dmac_stop_request;
+	dmac->dma.get_current_pos = dmac_get_current_pos;
+
+	dmac->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!dmac->regs)
+		goto out_free_pool;
+
+	ret = request_irq(platform_get_irq(pdev, 0), dmac_interrupt,
+			  SA_SAMPLE_RANDOM, pdev->name, dmac);
+	if (ret)
+		goto out_unmap_regs;
+
+	/* Enable the DMA controller */
+	dmac_writel_lo(dmac, CFG, 1);
+
+	register_dma_controller(&dmac->dma);
+
+	printk(KERN_INFO
+	       "dmac%d: DesignWare DMA controller at 0x%p irq %d\n",
+	       dmac->dma.id, dmac->regs, platform_get_irq(pdev, 0));
+
+	return 0;
+
+out_unmap_regs:
+	iounmap(dmac->regs);
+out_free_pool:
+	dma_pool_destroy(dmac->lli_pool);
+out_disable_clk:
+	clk_disable(dmac->hclk);
+	clk_put(dmac->hclk);
+out_free_dmac:
+	kfree(dmac);
+	return ret;
+}
+
+static struct platform_driver dmac_driver = {
+	.probe		= dmac_probe,
+	.driver		= {
+		.name		= "dmac",
+	},
+};
+
+static int __init dmac_init(void)
+{
+	return platform_driver_register(&dmac_driver);
+}
+subsys_initcall(dmac_init);
+
+static void __exit dmac_exit(void)
+{
+	platform_driver_unregister(&dmac_driver);
+}
+module_exit(dmac_exit);
+
+MODULE_DESCRIPTION("Synopsys DesignWare DMA Controller driver");
+MODULE_AUTHOR("Haavard Skinnemoen <hskinnemoen@atmel.com>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.19-avr1/arch/avr32/drivers/dw-dmac.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/arch/avr32/drivers/dw-dmac.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ * Driver for the Synopsys DesignWare DMA Controller
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __AVR32_DW_DMAC_H__
+#define __AVR32_DW_DMAC_H__
+
+#define DW_DMAC_CFG		0x398
+#define DW_DMAC_CH_EN		0x3a0
+
+#define DW_DMAC_STATUS_XFER	0x2e8
+#define DW_DMAC_STATUS_BLOCK	0x2f0
+#define DW_DMAC_STATUS_ERROR	0x308
+
+#define DW_DMAC_MASK_XFER	0x310
+#define DW_DMAC_MASK_BLOCK	0x318
+#define DW_DMAC_MASK_ERROR	0x330
+
+#define DW_DMAC_CLEAR_XFER	0x338
+#define DW_DMAC_CLEAR_BLOCK	0x340
+#define DW_DMAC_CLEAR_ERROR	0x358
+
+#define DW_DMAC_STATUS_INT	0x360
+
+#define DW_DMAC_CHAN_SAR	0x000
+#define DW_DMAC_CHAN_DAR	0x008
+#define DW_DMAC_CHAN_LLP	0x010
+#define DW_DMAC_CHAN_CTL	0x018
+#define DW_DMAC_CHAN_SSTAT	0x020
+#define DW_DMAC_CHAN_DSTAT	0x028
+#define DW_DMAC_CHAN_SSTATAR	0x030
+#define DW_DMAC_CHAN_DSTATAR	0x038
+#define DW_DMAC_CHAN_CFG	0x040
+#define DW_DMAC_CHAN_SGR	0x048
+#define DW_DMAC_CHAN_DSR	0x050
+
+#endif /* __AVR32_DW_DMAC_H__ */
Index: linux-2.6.19-avr1/drivers/mmc/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/drivers/mmc/Kconfig	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/mmc/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -71,6 +71,16 @@ config MMC_OMAP
 
 	  If unsure, say N.
 
+config MMC_ATMELMCI
+	tristate "Atmel Multimedia Card Interface support"
+	depends on AVR32 && MMC
+	help
+	  This selects the Atmel Multimedia Card Interface. If you have
+	  a AT91 (ARM) or AT32 (AVR32) platform with a Multimedia Card
+	  slot, say Y or M here.
+
+	  If unsure, say N.
+
 config MMC_WBSD
 	tristate "Winbond W83L51xD SD/MMC Card Interface support"
 	depends on MMC && ISA_DMA_API
Index: linux-2.6.19-avr1/drivers/mmc/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/drivers/mmc/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/mmc/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -24,6 +24,7 @@ obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
 obj-$(CONFIG_MMC_AT91RM9200)	+= at91_mci.o
 obj-$(CONFIG_MMC_TIFM_SD)	+= tifm_sd.o
+obj-$(CONFIG_MMC_ATMELMCI)	+= atmel-mci.o
 
 mmc_core-y := mmc.o mmc_sysfs.o
 mmc_core-$(CONFIG_BLOCK) += mmc_queue.o
Index: linux-2.6.19-avr1/drivers/mmc/atmel-mci.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/mmc/atmel-mci.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,609 @@
+/*
+ * Atmel MultiMedia Card Interface driver
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/blkdev.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+
+#include <asm/io.h>
+
+#include "atmel-mci.h"
+
+#define DRIVER_NAME "mmci"
+
+static void send_stop_cmd(struct mmc_host *mmc, struct mmc_data *data,
+			  u32 flags);
+
+/* For debugging purposes. Optimized away when TRACK_STATE is not set */
+enum {
+	STATE_IDLE = 0,
+	STATE_CMD,
+	STATE_ERR,
+	STATE_READ_SINGLE,
+	STATE_READ_MULTI,
+	STATE_READ_LAST,
+	STATE_WRITE_SINGLE,
+	STATE_WRITE_MULTI,
+	STATE_WRITE_LAST,
+};
+
+#ifdef TRACK_STATE
+static struct {
+	int state;
+	int blocknum;
+	int current_sg;
+	int num_sg;
+	int sg_len;
+	int bytes_xfered;
+} mci_state;
+#define set_state(x) do { mci_state.state = (x); } while(0)
+#define set_nextblock(x) do { mci_state.blocknum = (x); } while(0)
+#define set_current_sg(x) do { mci_state.current_sg = (x); } while(0)
+#define set_num_sg(x) do { mci_state.num_sg = (x); } while(0)
+#define set_sg_len(x) do { mci_state.sg_len = (x); } while(0)
+#define set_bytes_xfered(x) do { mci_state.bytes_xfered = (x); } while(0)
+#define check_idle() BUG_ON(mci_state.state != STATE_IDLE)
+#else
+#define set_state(x) do { } while(0)
+#define set_nextblock(x) do { } while(0)
+#define set_current_sg(x) do { } while(0)
+#define set_num_sg(x) do { } while(0)
+#define set_sg_len(x) do { } while(0)
+#define set_bytes_xfered(x) do { } while(0)
+#define check_idle() do { } while(0)
+#define trace_byteswap(f,t,l) do { } while(0)
+#define trace_cache(a) do { } while(0)
+#endif
+
+/* Those printks take an awful lot of time... */
+#ifndef DEBUG
+static unsigned int fmax = 2000000;
+#else
+static unsigned int fmax = 50000;
+#endif
+
+static inline void mci_writel(struct atmci_host *port, u32 offset, u32 value)
+{
+	__raw_writel(value, port->mmio + offset);
+}
+
+static inline u32 mci_readl(struct atmci_host *port, u32 offset)
+{
+	u32 value;
+	value = __raw_readl(port->mmio + offset);
+	return value;
+}
+
+static inline unsigned int ns_to_clocks(struct atmci_host *host,
+					unsigned int ns)
+{
+	return (ns * (host->bus_hz / 1000000) + 999) / 1000;
+}
+
+static void atmci_set_timeout(struct atmci_host *host,
+			      struct mmc_data *data)
+{
+	static unsigned dtomul_to_shift[] = {
+		0, 4, 7, 8, 10, 12, 16, 20
+	};
+	unsigned timeout;
+	unsigned dtocyc, dtomul;
+
+	timeout = ns_to_clocks(host, data->timeout_ns) + data->timeout_clks;
+
+	for (dtomul = 0; dtomul < 8; dtomul++) {
+		unsigned shift = dtomul_to_shift[dtomul];
+		dtocyc = (timeout + (1 << shift) - 1) >> shift;
+		if (dtocyc < 15)
+			break;
+	}
+
+	if (dtomul >= 8) {
+		dtomul = 7;
+		dtocyc = 15;
+	}
+
+	pr_debug("%s: setting timeout to %u cycles\n",
+		 mmc_hostname(host->mmc),
+		 dtocyc << dtomul_to_shift[dtomul]);
+	mci_writel(host, MCI_DTOR, (dtomul << 4) | dtocyc);
+}
+
+static void atmci_set_blklen(struct atmci_host *host,
+			     unsigned blksz)
+{
+	u32 value;
+
+	pr_debug("%s: setting blklen to %u\n",
+		 mmc_hostname(host->mmc), blksz);
+
+	host->dma.req.block_size = blksz;
+
+	value = mci_readl(host, MCI_MR);
+	value &= 0xffff;
+	value |= blksz << 16;
+	mci_writel(host, MCI_MR, value);
+}
+
+static void atmci_start_command(struct mmc_host *mmc,
+				struct mmc_command *cmd,
+				u32 cmdflags)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+
+	WARN_ON(host->cmd);
+
+	/* Don't mess with the opcode */
+	BUG_ON(cmdflags & 0x3f);
+	cmdflags &= ~0x3fUL;
+
+	cmdflags |= cmd->opcode;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136)
+			cmdflags |= MCI_CMDR_RSPTYP_136BIT;
+		else
+			cmdflags |= MCI_CMDR_RSPTYP_48BIT;
+	}
+
+	/*
+	 * This should really be MAXLAT_5 for CMD2 and ACMD41, but
+	 * it's too difficult to determine whether this is an ACMD or
+	 * not...
+	 */
+	cmdflags |= MCI_CMDR_MAXLAT_64;
+
+	if (mmc->ios.bus_mode == MMC_BUSMODE_OPENDRAIN)
+		cmdflags |= MCI_CMDR_OPDCMD;
+
+	pr_debug("%s: cmd: op %02x arg %08x flags %08x, cmdflags %08lx\n",
+		 mmc_hostname(mmc), cmd->opcode, cmd->arg, cmd->flags,
+		 (unsigned long)cmdflags);
+
+	host->cmd = cmd;
+
+	mci_writel(host, MCI_ARGR, cmd->arg);
+	mci_writel(host, MCI_CMDR, cmdflags);
+	mci_writel(host, MCI_IER, MCI_SR_CMDRDY);
+}
+
+static void atmci_start_read(struct mmc_host *mmc, struct mmc_data *data)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+
+	host->dma.req.nr_sg = dma_map_sg(&host->pdev->dev, data->sg,
+					 data->sg_len, DMA_FROM_DEVICE);
+	host->dma.req.sg = data->sg;
+	host->dma.req.periph_id = host->dma.rx_periph_id;
+	host->dma.req.direction = DMA_DIR_PERIPH_TO_MEM;
+	host->dma.req.data_reg = host->mapbase + MCI_RDR;
+	host->dma.blocks_left = data->blocks;
+
+	dma_prepare_request_sg(host->dma.req.req.dmac, &host->dma.req);
+	mci_writel(host, MCI_IER, MCI_SR_BLKE);
+}
+
+static void atmci_start_write(struct mmc_host *mmc, struct mmc_data *data)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+
+	host->dma.req.nr_sg = dma_map_sg(&host->pdev->dev, data->sg,
+					 data->sg_len, DMA_TO_DEVICE);
+	host->dma.req.sg = data->sg;
+	host->dma.req.periph_id = host->dma.tx_periph_id;
+	host->dma.req.direction = DMA_DIR_MEM_TO_PERIPH;
+	host->dma.req.data_reg = host->mapbase + MCI_TDR;
+	host->dma.blocks_left = data->blocks;
+
+	dma_prepare_request_sg(host->dma.req.req.dmac, &host->dma.req);
+	mci_writel(host, MCI_IER, MCI_SR_BLKE);
+}
+
+static void atmci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+	u32 cmd_flags = 0;
+
+	check_idle();
+
+	BUG_ON(host->mrq != NULL);
+
+	host->mrq = mrq;
+	host->sent_stop = 0;
+
+	if (mrq->data) {
+		struct mmc_data *data = mrq->data;
+
+		host->data = data;
+
+		atmci_set_timeout(host, data);
+		atmci_set_blklen(host, data->blksz);
+
+		cmd_flags |= MCI_CMDR_TRCMD_START;
+		if (data->flags & MMC_DATA_STREAM)
+			cmd_flags |= MCI_CMDR_TRTYP_STREAM;
+		else if (data->blocks > 1)
+			cmd_flags |= MCI_CMDR_TRTYP_MULTBLK;
+		else
+			cmd_flags |= MCI_CMDR_TRTYP_BLOCK;
+
+		if (data->flags & MMC_DATA_READ) {
+			cmd_flags |= MCI_CMDR_TRDIR_READ;
+			atmci_start_read(mmc, data);
+		} else {
+			cmd_flags |= MCI_CMDR_TRDIR_WRITE;
+			atmci_start_write(mmc, data);
+		}
+	} else {
+		set_state(STATE_CMD);
+	}
+
+	atmci_start_command(mmc, mrq->cmd, cmd_flags);
+
+	if (mrq->data)
+		dma_start_request(host->dma.req.req.dmac,
+				  host->dma.req.req.channel);
+}
+
+static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+
+	if (ios->clock) {
+		u32 clkdiv;
+
+		clkdiv = host->bus_hz / (2 * ios->clock) - 1;
+		if (clkdiv > 255)
+			clkdiv = 255;
+		mci_writel(host, MCI_MR, clkdiv);
+	}
+
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_1:
+		mci_writel(host, MCI_SDCR, 0);
+		break;
+	case MMC_BUS_WIDTH_4:
+		mci_writel(host, MCI_SDCR, MCI_SDCR_SDCBUS);
+		break;
+	}
+
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+		mci_writel(host, MCI_CR, MCI_CR_MCIDIS);
+		break;
+	case MMC_POWER_UP:
+		mci_writel(host, MCI_CR, MCI_CR_SWRST);
+		break;
+	case MMC_POWER_ON:
+		mci_writel(host, MCI_CR, MCI_CR_MCIEN);
+		break;
+	}
+}
+
+static struct mmc_host_ops atmci_ops = {
+	.request	= atmci_request,
+	.set_ios	= atmci_set_ios,
+};
+
+static void atmci_request_end(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+
+	WARN_ON(host->cmd);
+
+	if (mrq->data) {
+		if (mrq->data->error != MMC_ERR_NONE)
+			pr_debug("%s: Data transmission failed: Error %d\n",
+				 mmc_hostname(mmc), mrq->data->error);
+	}
+
+	host->mrq = NULL;
+
+	set_state(STATE_IDLE);
+
+	/*
+	 * Need to drop the host lock here; mmc_request_done may call
+	 * back into the driver...
+	 */
+	spin_unlock(&mmc->lock);
+	mmc_request_done(mmc, mrq);
+	spin_lock(&mmc->lock);
+}
+
+static void send_stop_cmd(struct mmc_host *mmc, struct mmc_data *data,
+			  u32 flags)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+	/* pr_debug("sending stop cmd\n"); */
+
+	BUG_ON(host->sent_stop);
+
+	flags |= MCI_CMDR_TRCMD_STOP;
+	if (data->flags & MMC_DATA_WRITE)
+		flags |= MCI_CMDR_TRDIR_WRITE;
+	else
+		flags |= MCI_CMDR_TRDIR_READ;
+	if (data->flags & MMC_DATA_STREAM)
+		flags |= MCI_CMDR_TRTYP_STREAM;
+	else
+		flags |= MCI_CMDR_TRTYP_MULTBLK;
+
+	atmci_start_command(mmc, data->stop, flags);
+	host->sent_stop = 1;
+}
+
+static void atmci_cmd_interrupt(struct mmc_host *mmc, u32 status)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+	struct mmc_command *cmd = host->cmd;
+
+	host->cmd = NULL;
+	cmd->resp[0] = mci_readl(host, MCI_RSPR);
+	cmd->resp[1] = mci_readl(host, MCI_RSPR);
+	cmd->resp[2] = mci_readl(host, MCI_RSPR);
+	cmd->resp[3] = mci_readl(host, MCI_RSPR);
+
+	cmd->error = MMC_ERR_NONE;
+	if (status & MCI_SR_RTOE)
+		cmd->error = MMC_ERR_TIMEOUT;
+	else if (status & MCI_SR_RCRCE && cmd->flags & MMC_RSP_CRC)
+		cmd->error = MMC_ERR_BADCRC;
+
+	mci_writel(host, MCI_IDR, MCI_SR_CMDRDY);
+
+	if (cmd->error != MMC_ERR_NONE)
+		printk(KERN_DEBUG "%s: Command %02u failed: Error %d\n",
+		       mmc_hostname(mmc), cmd->opcode, cmd->error);
+	else
+		pr_debug("%s: Command %02u completed successfully (%s)\n",
+			 mmc_hostname(mmc), cmd->opcode,
+			 cmd->data ? "data" : "no data");
+
+	host->cmd = NULL;
+
+	if (!cmd->data || cmd->error != MMC_ERR_NONE)
+		atmci_request_end(mmc, cmd->mrq);
+
+	if (cmd->data && cmd->data->blocks == 1 && cmd->data->stop)
+		send_stop_cmd(mmc, cmd->data, MCI_CMDR_SPCMD_SYNC);
+}
+
+static void atmci_xfer_complete(struct dma_request *_req)
+{
+	struct dma_request_sg *req = to_dma_request_sg(_req);
+	struct atmci_dma_info *dma;
+	struct atmci_host *host;
+
+	dma = container_of(req, struct atmci_dma_info, req);
+	host = container_of(dma, struct atmci_host, dma);
+
+	dma_unmap_sg(&host->pdev->dev, host->data->sg, dma->req.nr_sg,
+		     ((host->data->flags & MMC_DATA_WRITE)
+		      ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
+}
+
+static void atmci_dma_error(struct dma_request *req)
+{
+	BUG();
+}
+
+static void atmci_blke_interrupt(struct mmc_host *mmc, u32 status, u32 pending)
+{
+	struct atmci_host *host = mmc_priv(mmc);
+	struct mmc_data *data = host->data;
+
+	if (status & (MCI_SR_DCRCE | MCI_SR_DTOE | MCI_SR_OVRE | MCI_SR_UNRE)) {
+		set_state(STATE_ERR);
+		if (status & MCI_SR_DCRCE)
+			data->error = MMC_ERR_BADCRC;
+		else if (status & MCI_SR_DTOE)
+			data->error = MMC_ERR_TIMEOUT;
+		else if (status & MCI_SR_OVRE) {
+			pr_debug("%s: DMA overrun\n", mmc_hostname(mmc));
+			data->error = MMC_ERR_FIFO;
+		} else if (status & MCI_SR_UNRE) {
+			pr_debug("%s: DMA underrun\n", mmc_hostname(mmc));
+			data->error = MMC_ERR_FIFO;
+		}
+	}
+
+	data->bytes_xfered += data->blksz;
+	if (data->bytes_xfered == ((data->blocks - 1) * data->blksz)
+	    || data->error)
+		if (data->stop && !host->sent_stop)
+			send_stop_cmd(mmc, data, MCI_CMDR_SPCMD_SYNC);
+	pr_debug("mmci: BLKE interrupt: %d blocks left\n", host->dma.blocks_left);
+
+	if ((data->bytes_xfered == (data->blocks * data->blksz)
+	     || data->error) && !data->stop)
+		atmci_request_end(mmc, data->mrq);
+}
+
+static irqreturn_t atmci_interrupt(int irq, void *dev_id)
+{
+	struct mmc_host *mmc = dev_id;
+	struct atmci_host *host = mmc_priv(mmc);
+	u32 status, mask, pending;
+
+	spin_lock(&mmc->lock);
+
+	status = mci_readl(host, MCI_SR);
+	mask = mci_readl(host, MCI_IMR);
+	pending = status & mask;
+
+	do {
+		pr_debug("mci: interrupt, status = %08x, mask = %08x\n",
+			 status, mask);
+
+		if (pending & MCI_SR_BLKE)
+			atmci_blke_interrupt(mmc, status, pending);
+		if (pending & MCI_SR_CMDRDY)
+			atmci_cmd_interrupt(mmc, status);
+
+		status = mci_readl(host, MCI_SR);
+		mask = mci_readl(host, MCI_IMR);
+		pending = status & mask;
+	} while (pending);
+
+	spin_unlock(&mmc->lock);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit atmci_probe(struct platform_device *pdev)
+{
+	struct atmci_host *host;
+	struct mmc_host *mmc;
+	struct resource *regs;
+	int irq;
+	int ret;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	mmc = mmc_alloc_host(sizeof(struct atmci_host), &pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+	host->pdev = pdev;
+	host->mmc = mmc;
+
+	host->mck = clk_get(&pdev->dev, "mck");
+	if (IS_ERR(host->mck)) {
+		ret = PTR_ERR(host->mck);
+		goto out_free_host;
+	}
+	clk_enable(host->mck);
+
+	ret = -ENOMEM;
+	host->mmio = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!host->mmio)
+		goto out_disable_clk;
+
+	host->bus_hz = clk_get_rate(host->mck);
+	host->mapbase = regs->start;
+
+	mmc->ops = &atmci_ops;
+	mmc->f_min = (host->bus_hz + 511) / 512;
+	mmc->f_max = min((unsigned int)(host->bus_hz / 2), fmax);
+	mmc->ocr_avail	= 0x00100000;
+
+	ret = request_irq(irq, atmci_interrupt, 0, "mmci", mmc);
+	if (ret)
+		goto out_unmap;
+
+	/* TODO: Get this information from the at32 device */
+	ret = -ENOMEM;
+	host->dma.req.req.dmac = find_dma_controller(0);
+	if (!host->dma.req.req.dmac) {
+		printk(KERN_ERR
+		       "mmci: No DMA controller available, aborting\n");
+		goto out_free_irq;
+	}
+	ret = dma_alloc_channel(host->dma.req.req.dmac);
+	if (ret < 0) {
+		printk(KERN_ERR
+		       "mmci: Unable to allocate DMA channel, aborting\n");
+		goto out_free_irq;
+	}
+	host->dma.req.req.channel = ret;
+	host->dma.req.width = DMA_WIDTH_32BIT;
+	host->dma.req.req.xfer_complete = atmci_xfer_complete;
+	host->dma.req.req.block_complete = NULL; // atmci_block_complete;
+	host->dma.req.req.error = atmci_dma_error;
+	host->dma.rx_periph_id = 0;
+	host->dma.tx_periph_id = 1;
+
+	mci_writel(host, MCI_CR, MCI_CR_SWRST);
+	mci_writel(host, MCI_IDR, ~0UL);
+	mci_writel(host, MCI_CR, MCI_CR_MCIEN);
+
+	platform_set_drvdata(pdev, host);
+
+	mmc_add_host(mmc);
+
+	printk(KERN_INFO "%s: Atmel MCI controller at 0x%08lx irq %d\n",
+	       mmc_hostname(mmc), host->mapbase, irq);
+
+	return 0;
+
+out_free_irq:
+	free_irq(irq, mmc);
+out_unmap:
+	iounmap(host->mmio);
+out_disable_clk:
+	clk_disable(host->mck);
+	clk_put(host->mck);
+out_free_host:
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static int __devexit atmci_remove(struct platform_device *pdev)
+{
+	struct atmci_host *host = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (host) {
+		mmc_remove_host(host->mmc);
+
+		mci_writel(host, MCI_IDR, ~0UL);
+		mci_writel(host, MCI_CR, MCI_CR_MCIDIS);
+		mci_readl(host, MCI_SR);
+
+		free_irq(platform_get_irq(pdev, 0), host->mmc);
+		iounmap(host->mmio);
+
+		clk_disable(host->mck);
+		clk_put(host->mck);
+
+		mmc_free_host(host->mmc);
+	}
+	return 0;
+}
+
+static struct platform_driver atmci_driver = {
+	.probe		= atmci_probe,
+	.remove		= __devexit_p(atmci_remove),
+	.driver		= {
+		.name		= DRIVER_NAME,
+	},
+};
+
+static int __init atmci_init(void)
+{
+	return platform_driver_register(&atmci_driver);
+}
+
+static void __exit atmci_exit(void)
+{
+	platform_driver_unregister(&atmci_driver);
+}
+
+module_init(atmci_init);
+module_exit(atmci_exit);
+
+MODULE_DESCRIPTION("Atmel Multimedia Card Interface driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.19-avr1/drivers/mmc/atmel-mci.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/mmc/atmel-mci.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,114 @@
+/*
+ * Atmel MultiMedia Card Interface driver
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ATMEL_MCI_H
+#define __ATMEL_MCI_H
+
+#include <asm/dma-controller.h>
+
+/* Atmel MultiMedia Card Interface (MCI) registers */
+#define MCI_CR			0x00
+#define MCI_MR			0x04
+#define MCI_DTOR		0x08
+#define MCI_SDCR		0x0c
+#define MCI_ARGR		0x10
+#define MCI_CMDR		0x14
+#define MCI_RSPR		MCI_RSPR0
+#define MCI_RSPR0		0x20
+#define MCI_RSPR1		0x24
+#define MCI_RSPR2		0x28
+#define MCI_RSPR3		0x2c
+#define MCI_RDR			0x30
+#define MCI_TDR			0x34
+#define MCI_SR			0x40
+#define MCI_IER			0x44
+#define MCI_IDR			0x48
+#define MCI_IMR			0x4c
+
+/* MCI Control Register */
+#define MCI_CR_MCIEN		(1 <<  0)
+#define MCI_CR_MCIDIS		(1 <<  1)
+#define MCI_CR_PWSEN		(1 <<  2)
+#define MCI_CR_PWSDIS		(1 <<  3)
+#define MCI_CR_SWRST		(1 <<  7)
+
+/* MCI Mode Register */
+#define MCI_MR_PDCPADV		(1 << 14)
+#define MCI_MR_PDCMODE		(1 << 15)
+
+/* MCI SD Card Register */
+#define MCI_SDCR_SDCBUS		(1 <<  7)
+
+/* MCI Command Register */
+#define MCI_CMDR_RSPTYP_NONE	(0 <<  6)
+#define MCI_CMDR_RSPTYP_48BIT	(1 <<  6)
+#define MCI_CMDR_RSPTYP_136BIT	(2 <<  6)
+#define MCI_CMDR_RSPTYP_MASK	(3 <<  6)
+#define MCI_CMDR_SPCMD_NONE	(0 <<  8)
+#define MCI_CMDR_SPCMD_INIT	(1 <<  8)
+#define MCI_CMDR_SPCMD_SYNC	(2 <<  8)
+#define MCI_CMDR_SPCMD_INTCMD	(4 <<  8)
+#define MCI_CMDR_SPCMD_INTRESP	(5 <<  8)
+#define MCI_CMDR_OPDCMD		(1 << 11)
+#define MCI_CMDR_MAXLAT_5	(0 << 12)
+#define MCI_CMDR_MAXLAT_64	(1 << 12)
+#define MCI_CMDR_TRCMD_NONE	(0 << 16)
+#define MCI_CMDR_TRCMD_START	(1 << 16)
+#define MCI_CMDR_TRCMD_STOP	(2 << 16)
+#define MCI_CMDR_TRDIR_WRITE	(0 << 18)
+#define MCI_CMDR_TRDIR_READ	(1 << 18)
+#define MCI_CMDR_TRTYP_BLOCK	(0 << 19)
+#define MCI_CMDR_TRTYP_MULTBLK	(1 << 19)
+#define MCI_CMDR_TRTYP_STREAM	(2 << 19)
+
+/* MCI Status Register + Interrupt Enable/Disable/Mask */
+#define MCI_SR_CMDRDY		(1 <<  0)
+#define MCI_SR_RXRDY		(1 <<  1)
+#define MCI_SR_TXRDY		(1 <<  2)
+#define MCI_SR_BLKE		(1 <<  3)
+#define MCI_SR_DTIP		(1 <<  4)
+#define MCI_SR_NOTBUSY		(1 <<  5)
+#define MCI_SR_ENDRX		(1 <<  6)
+#define MCI_SR_ENDTX		(1 <<  7)
+#define MCI_SR_RXBUFF		(1 << 14)
+#define MCI_SR_TXBUFE		(1 << 15)
+#define MCI_SR_RINDE		(1 << 16)
+#define MCI_SR_RDIRE		(1 << 17)
+#define MCI_SR_RCRCE		(1 << 18)
+#define MCI_SR_RENDE		(1 << 19)
+#define MCI_SR_RTOE		(1 << 20)
+#define MCI_SR_DCRCE		(1 << 21)
+#define MCI_SR_DTOE		(1 << 22)
+#define MCI_SR_OVRE		(1 << 30)
+#define MCI_SR_UNRE		(1 << 31)
+
+#define MCI_SR_ERROR		0x007b0000
+
+struct atmci_dma_info {
+	struct dma_request_sg req;
+	unsigned short rx_periph_id;
+	unsigned short tx_periph_id;
+	int blocks_left;
+};
+
+struct atmci_host {
+	struct mmc_host *mmc;
+	void __iomem *mmio;
+	struct atmci_dma_info dma;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	int sent_stop;
+	unsigned long bus_hz;
+	unsigned long mapbase;
+	struct clk *mck;
+	struct platform_device *pdev;
+};
+
+#endif /* __ATMEL_MCI_H */
Index: linux-2.6.19-avr1/drivers/spi/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/drivers/spi/Kconfig	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/spi/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -51,6 +51,13 @@ config SPI_MASTER
 comment "SPI Master Controller Drivers"
 	depends on SPI_MASTER
 
+config SPI_ATMEL
+	tristate "Atmel SPI Controller"
+	depends on (ARCH_AT91 || AVR32) && SPI_MASTER
+	help
+	  This selects a driver for the Atmel SPI Controller, present on
+	  many AT32 (AVR32) and AT91 (ARM) chips.
+
 config SPI_BITBANG
 	tristate "Bitbanging SPI master"
 	depends on SPI_MASTER && EXPERIMENTAL
Index: linux-2.6.19-avr1/drivers/spi/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/drivers/spi/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/spi/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -12,6 +12,7 @@ obj-$(CONFIG_SPI_MASTER)		+= spi.o
 
 # SPI master controller drivers (bus)
 obj-$(CONFIG_SPI_BITBANG)		+= spi_bitbang.o
+obj-$(CONFIG_SPI_ATMEL)			+= atmel_spi.o
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi_butterfly.o
 obj-$(CONFIG_SPI_PXA2XX)		+= pxa2xx_spi.o
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
Index: linux-2.6.19-avr1/drivers/spi/atmel_spi.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/spi/atmel_spi.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,647 @@
+/*
+ * Driver for Atmel AT32 and AT91 SPI Controllers
+ *
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+
+#include <asm/io.h>
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+#include "atmel_spi.h"
+
+/*
+ * The core SPI transfer engine just talks to a register bank to set up
+ * DMA transfers; transfer queue progress is driven by IRQs.  The clock
+ * framework provides the base clock, subdivided for each spi_device.
+ *
+ * Newer controllers, marked with "new_1" flag, have:
+ *  - CR.LASTXFER
+ *  - SPI_MR.DIV32 may become FDIV or must-be-zero (here: always zero)
+ *  - SPI_SR.TXEMPTY, SPI_SR.NSSR (and corresponding irqs)
+ *  - SPI_CSRx.CSAAT
+ *  - SPI_CSRx.SBCR allows faster clocking
+ */
+struct atmel_spi {
+	spinlock_t		lock;
+
+	void __iomem		*regs;
+	int			irq;
+	struct clk		*clk;
+	struct platform_device	*pdev;
+	unsigned		new_1:1;
+
+	u8			stopping;
+	struct list_head	queue;
+	struct spi_transfer	*current_transfer;
+	unsigned long		remaining_bytes;
+
+	void			*buffer;
+	dma_addr_t		buffer_dma;
+};
+
+#define BUFFER_SIZE		PAGE_SIZE
+#define INVALID_DMA_ADDRESS	0xffffffff
+
+/*
+ * Earlier SPI controllers (e.g. on at91rm9200) have a design bug whereby
+ * they assume that spi slave device state will not change on deselect, so
+ * that automagic deselection is OK.  Not so!  Workaround uses nCSx pins
+ * as GPIOs; or newer controllers have CSAAT and friends.
+ *
+ * Since the CSAAT functionality is a bit weird on newer controllers
+ * as well, we use GPIO to control nCSx pins on all controllers.
+ */
+
+static inline void cs_activate(struct spi_device *spi)
+{
+	unsigned gpio = (unsigned) spi->controller_data;
+
+	dev_dbg(&spi->dev, "activate %u\n", gpio);
+	gpio_set_value(gpio, 0);
+}
+
+static inline void cs_deactivate(struct spi_device *spi)
+{
+	unsigned gpio = (unsigned) spi->controller_data;
+
+	dev_dbg(&spi->dev, "DEactivate %u\n", gpio);
+	gpio_set_value(gpio, 1);
+}
+
+/*
+ * Submit next transfer for DMA.
+ * lock is held, spi irq is blocked
+ */
+static void atmel_spi_next_xfer(struct spi_master *master,
+				struct spi_message *msg)
+{
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+	struct spi_transfer	*xfer;
+	u32			imr = 0;
+	u32			len;
+	dma_addr_t		tx_dma, rx_dma;
+
+	xfer = as->current_transfer;
+	if (!xfer || as->remaining_bytes == 0) {
+		if (xfer)
+			xfer = list_entry(xfer->transfer_list.next,
+					  struct spi_transfer, transfer_list);
+		else
+			xfer = list_entry(msg->transfers.next, struct spi_transfer,
+					  transfer_list);
+		as->remaining_bytes = xfer->len;
+		as->current_transfer = xfer;
+	}
+
+	len = as->remaining_bytes;
+
+	tx_dma = xfer->tx_dma;
+	rx_dma = xfer->rx_dma;
+
+	if (rx_dma == INVALID_DMA_ADDRESS) {
+		rx_dma = as->buffer_dma;
+		if (len > BUFFER_SIZE)
+			len = BUFFER_SIZE;
+	}
+	if (tx_dma == INVALID_DMA_ADDRESS) {
+		if (xfer->tx_buf) {
+			tx_dma = as->buffer_dma;
+			if (len > BUFFER_SIZE)
+				len = BUFFER_SIZE;
+			memcpy(as->buffer, xfer->tx_buf, len);
+			dma_sync_single_for_device(&as->pdev->dev,
+						   as->buffer_dma, len,
+						   DMA_TO_DEVICE);
+		} else {
+			/* Send undefined data; rx_dma is handy */
+			tx_dma = rx_dma;
+		}
+	}
+
+	spi_writel(as, RPR, rx_dma);
+	spi_writel(as, TPR, tx_dma);
+
+	as->remaining_bytes -= len;
+	if (msg->spi->bits_per_word > 8)
+		len >>= 1;
+
+	/* REVISIT: when xfer->delay_usecs == 0, the PDC "next transfer"
+	 * mechanism might help avoid the IRQ latency between transfers
+	 *
+	 * We're also waiting for ENDRX before we start the next
+	 * transfer because we need to handle some difficult timing
+	 * issues otherwise. If we wait for ENDTX in one transfer and
+	 * then starts waiting for ENDRX in the next, it's difficult
+	 * to tell the difference between the ENDRX interrupt we're
+	 * actually waiting for and the ENDRX interrupt of the
+	 * previous transfer.
+	 *
+	 * It should be doable, though. Just not now...
+	 */
+	spi_writel(as, TNCR, 0);
+	spi_writel(as, RNCR, 0);
+	imr = SPI_BIT(ENDRX);
+
+	dev_dbg(&msg->spi->dev,
+		"start xfer %p: len %u tx %p/%08x rx %p/%08x imr %08x\n",
+		xfer, xfer->len, xfer->tx_buf, xfer->tx_dma,
+		xfer->rx_buf, xfer->rx_dma, imr);
+
+	wmb();
+	spi_writel(as, TCR, len);
+	spi_writel(as, RCR, len);
+	spi_writel(as, PTCR, SPI_BIT(TXTEN) | SPI_BIT(RXTEN));
+	spi_writel(as, IER, imr);
+}
+
+static void atmel_spi_next_message(struct spi_master *master)
+{
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+	struct spi_message	*msg;
+	u32			mr;
+
+	BUG_ON(as->current_transfer);
+
+	msg = list_entry(as->queue.next, struct spi_message, queue);
+
+	/* Select the chip */
+	mr = spi_readl(as, MR);
+	mr = SPI_BFINS(PCS, ~(1 << msg->spi->chip_select), mr);
+	spi_writel(as, MR, mr);
+	cs_activate(msg->spi);
+
+	atmel_spi_next_xfer(master, msg);
+}
+
+static void atmel_spi_dma_map_xfer(struct atmel_spi *as,
+				   struct spi_transfer *xfer)
+{
+	xfer->tx_dma = xfer->rx_dma = INVALID_DMA_ADDRESS;
+	if (!(xfer->len & (L1_CACHE_BYTES - 1))) {
+		if (xfer->tx_buf
+		    && !((unsigned long)xfer->tx_buf & (L1_CACHE_BYTES - 1)))
+			xfer->tx_dma = dma_map_single(&as->pdev->dev,
+						      xfer->tx_buf,
+						      xfer->len,
+						      DMA_TO_DEVICE);
+		if (xfer->rx_buf
+		    && !((unsigned long)xfer->rx_buf & (L1_CACHE_BYTES - 1)))
+			xfer->rx_dma = dma_map_single(&as->pdev->dev,
+						      xfer->rx_buf,
+						      xfer->len,
+						      DMA_FROM_DEVICE);
+	}
+}
+
+static irqreturn_t atmel_spi_interrupt(int irq, void *dev_id)
+{
+	struct spi_master	*master = dev_id;
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+	struct spi_message	*msg;
+	struct spi_transfer	*xfer;
+	u32			status, pending, imr;
+	int			ret = IRQ_NONE;
+
+	imr = spi_readl(as, IMR);
+	status = spi_readl(as, SR);
+	pending = status & imr;
+pr_debug("spi irq: stat %05x imr %05x pend %05x\n", status, imr, pending);
+
+	if (pending & (SPI_BIT(ENDTX) | SPI_BIT(ENDRX))) {
+		ret = IRQ_HANDLED;
+
+		spi_writel(as, IDR, pending);
+		spin_lock(&as->lock);
+
+		xfer = as->current_transfer;
+		msg = list_entry(as->queue.next, struct spi_message, queue);
+
+		/*
+		 * If the rx buffer wasn't aligned, we used a bounce
+		 * buffer for the transfer. Copy the data back and
+		 * make the bounce buffer ready for re-use.
+		 */
+		if (xfer->rx_buf && xfer->rx_dma == INVALID_DMA_ADDRESS) {
+			unsigned int len = xfer->len;
+			if (len > BUFFER_SIZE)
+				len = BUFFER_SIZE;
+
+			dma_sync_single_for_cpu(&as->pdev->dev, as->buffer_dma,
+						len, DMA_FROM_DEVICE);
+			memcpy((xfer->rx_buf + xfer->len
+				- len - as->remaining_bytes),
+			       as->buffer, len);
+		}
+
+
+		if (as->remaining_bytes == 0) {
+			msg->actual_length += xfer->len;
+
+			if (!msg->is_dma_mapped) {
+				if (xfer->tx_dma != INVALID_DMA_ADDRESS)
+					dma_unmap_single(master->cdev.dev,
+							 xfer->tx_dma,
+							 xfer->len,
+							 DMA_TO_DEVICE);
+				if (xfer->rx_dma != INVALID_DMA_ADDRESS)
+					dma_unmap_single(master->cdev.dev,
+							 xfer->rx_dma,
+							 xfer->len,
+							 DMA_FROM_DEVICE);
+			}
+
+			/* REVISIT: udelay in irq is unfriendly */
+			if (xfer->delay_usecs)
+				udelay(xfer->delay_usecs);
+
+			if (msg->transfers.prev == &xfer->transfer_list) {
+
+				/* report completed message */
+				cs_deactivate(msg->spi);
+				list_del(&msg->queue);
+				msg->status = 0;
+
+				dev_dbg(master->cdev.dev,
+					"xfer complete: %u bytes transferred\n",
+					msg->actual_length);
+
+				spin_unlock(&as->lock);
+				msg->complete(msg->context);
+				spin_lock(&as->lock);
+
+				as->current_transfer = NULL;
+
+				/* continue; complete() may have queued requests */
+				if (list_empty(&as->queue) || as->stopping)
+					spi_writel(as, PTCR, SPI_BIT(RXTDIS)
+						   | SPI_BIT(TXTDIS));
+				else
+					atmel_spi_next_message(master);
+			} else {
+				if (xfer->cs_change) {
+					cs_deactivate(msg->spi);
+					udelay(1);
+					cs_activate(msg->spi);
+				}
+
+				/*
+				 * Not done yet. Submit the next transfer.
+				 *
+				 * FIXME handle protocol options for xfer
+				 */
+				atmel_spi_next_xfer(master, msg);
+			}
+		} else {
+			/*
+			 * Keep going, we still have data to send in
+			 * the current transfer.
+			 */
+			atmel_spi_next_xfer(master, msg);
+		}
+		spin_unlock(&as->lock);
+	}
+
+	return ret;
+}
+
+static int atmel_spi_setup(struct spi_device *spi)
+{
+	struct atmel_spi	*as;
+	u32			scbr, csr;
+	unsigned int		bits = spi->bits_per_word;
+	unsigned long		bus_hz, sck_hz;
+	unsigned int		npcs_pin;
+	int			ret;
+
+	as = spi_master_get_devdata(spi->master);
+
+	if (as->stopping)
+		return -ESHUTDOWN;
+
+	if (spi->chip_select > spi->master->num_chipselect) {
+		dev_dbg(&spi->dev,
+				"setup: invalid chipselect %u (%u defined)\n",
+				spi->chip_select, spi->master->num_chipselect);
+		return -EINVAL;
+	}
+
+	if (bits == 0)
+		bits = 8;
+	if (bits < 8 || bits > 16) {
+		dev_dbg(&spi->dev,
+				"setup: invalid bits_per_word %u (8 to 16)\n",
+				bits);
+		return -EINVAL;
+	}
+
+	if (spi->mode & (SPI_CS_HIGH | SPI_LSB_FIRST)) {
+		dev_dbg(&spi->dev, "setup: unsupported mode %u\n", spi->mode);
+		return -EINVAL;
+	}
+
+	/* speed zero convention is used by some upper layers */
+	bus_hz = clk_get_rate(as->clk);
+	if (spi->max_speed_hz) {
+		/* assume div32/fdiv/mbz == 0 */
+		if (!as->new_1)
+			bus_hz /= 2;
+		scbr = ((bus_hz + spi->max_speed_hz - 1)
+			/ spi->max_speed_hz);
+		if (scbr >= (1 << SPI_SCBR_SIZE)) {
+			dev_dbg(&spi->dev, "setup: %d Hz too slow, scbr %u\n",
+					spi->max_speed_hz, scbr);
+			return -EINVAL;
+		}
+	} else
+		scbr = 0xff;
+	sck_hz = bus_hz / scbr;
+
+	csr = SPI_BF(SCBR, scbr) | SPI_BF(BITS, bits - 8);
+	if (spi->mode & SPI_CPOL)
+		csr |= SPI_BIT(CPOL);
+	if (!(spi->mode & SPI_CPHA))
+		csr |= SPI_BIT(NCPHA);
+
+	/* TODO: DLYBS and DLYBCT */
+	csr |= SPI_BF(DLYBS, 10);
+	csr |= SPI_BF(DLYBCT, 10);
+
+	npcs_pin = (unsigned int)spi->controller_data;
+	if (!spi->controller_state) {
+		ret = gpio_request(npcs_pin, "spi_npcs");
+		if (ret)
+			return ret;
+		spi->controller_state = (void *)npcs_pin;
+	}
+
+	gpio_set_value(npcs_pin, 1);
+
+	dev_dbg(&spi->dev,
+		"setup: %lu Hz bpw %u mode 0x%x -> csr%d %08x\n",
+		sck_hz, bits, spi->mode, spi->chip_select, csr);
+
+	spi_writel(as, CSR0 + 4 * spi->chip_select, csr);
+
+	return 0;
+}
+
+static int atmel_spi_transfer(struct spi_device *spi, struct spi_message *msg)
+{
+	struct atmel_spi	*as;
+	struct spi_transfer	*xfer;
+	unsigned long		flags;
+	struct device		*controller = spi->master->cdev.dev;
+
+	as = spi_master_get_devdata(spi->master);
+
+	dev_dbg(controller, "new message %p submitted for %s\n",
+			msg, spi->dev.bus_id);
+
+	if (unlikely(list_empty(&msg->transfers)
+			|| !spi->max_speed_hz))
+		return -EINVAL;
+
+	if (as->stopping)
+		return -ESHUTDOWN;
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (!(xfer->tx_buf || xfer->rx_buf)) {
+			dev_dbg(&spi->dev, "missing rx or tx buf\n");
+			return -EINVAL;
+		}
+
+		/* FIXME implement these protocol options!! */
+		if (xfer->bits_per_word || xfer->speed_hz) {
+			dev_dbg(&spi->dev, "no protocol options yet\n");
+			return -ENOPROTOOPT;
+		}
+	}
+
+	/* scrub dcache "early" */
+	if (!msg->is_dma_mapped) {
+		list_for_each_entry(xfer, &msg->transfers, transfer_list)
+			atmel_spi_dma_map_xfer(as, xfer);
+	}
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		dev_dbg(controller,
+			"  xfer %p: len %u tx %p/%08x rx %p/%08x\n",
+			xfer, xfer->len,
+			xfer->tx_buf, xfer->tx_dma,
+			xfer->rx_buf, xfer->rx_dma);
+	}
+
+	msg->status = -EINPROGRESS;
+	msg->actual_length = 0;
+
+	spin_lock_irqsave(&as->lock, flags);
+	list_add_tail(&msg->queue, &as->queue);
+	if (!as->current_transfer)
+		atmel_spi_next_message(spi->master);
+	spin_unlock_irqrestore(&as->lock, flags);
+
+	return 0;
+}
+
+static void atmel_spi_cleanup(const struct spi_device *spi)
+{
+	if (spi->controller_state)
+		gpio_free((unsigned int)spi->controller_data);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit atmel_spi_probe(struct platform_device *pdev)
+{
+	struct resource		*regs;
+	int			irq;
+	struct clk		*clk;
+	int			ret;
+	struct spi_master	*master;
+	struct atmel_spi	*as;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	clk = clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	/* setup spi core then atmel-specific driver state */
+	ret = -ENOMEM;
+	master = spi_alloc_master(&pdev->dev, sizeof *as);
+	if (!master)
+		goto out_free;
+
+	master->bus_num = pdev->id;
+	master->num_chipselect = 4;
+	master->setup = atmel_spi_setup;
+	master->transfer = atmel_spi_transfer;
+	master->cleanup = atmel_spi_cleanup;
+	platform_set_drvdata(pdev, master);
+
+	as = spi_master_get_devdata(master);
+
+	as->buffer = dma_alloc_coherent(&pdev->dev, BUFFER_SIZE,
+					&as->buffer_dma, GFP_KERNEL);
+	if (!as->buffer)
+		goto out_free;
+
+	spin_lock_init(&as->lock);
+	INIT_LIST_HEAD(&as->queue);
+	as->pdev = pdev;
+	as->regs = ioremap(regs->start, (regs->end - regs->start) + 1);
+	if (!as->regs)
+		goto out_free_buffer;
+	as->irq = irq;
+	as->clk = clk;
+#if !defined(CONFIG_ARCH_AT91RM9200)
+	/* if (!cpu_is_at91rm9200()) */
+		as->new_1 = 1;
+#endif
+
+	ret = request_irq(irq, atmel_spi_interrupt, 0,
+			pdev->dev.bus_id, master);
+	if (ret)
+		goto out_unmap_regs;
+
+	/* Initialize the hardware */
+	clk_enable(clk);
+	spi_writel(as, CR, SPI_BIT(SWRST));
+	spi_writel(as, MR, SPI_BIT(MSTR) | SPI_BIT(MODFDIS));
+	spi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));
+	spi_writel(as, CR, SPI_BIT(SPIEN));
+
+	/* go! */
+	dev_info(&pdev->dev, "Atmel SPI Controller at 0x%08lx (irq %d)\n",
+			(unsigned long)regs->start, irq);
+
+	ret = spi_register_master(master);
+	if (ret)
+		goto out_reset_hw;
+
+	return 0;
+
+out_reset_hw:
+	spi_writel(as, CR, SPI_BIT(SWRST));
+	clk_disable(clk);
+	free_irq(irq, master);
+out_unmap_regs:
+	iounmap(as->regs);
+out_free_buffer:
+	dma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,
+			  as->buffer_dma);
+out_free:
+	clk_put(clk);
+	spi_master_put(master);
+	return ret;
+}
+
+static int __devexit atmel_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master	*master = platform_get_drvdata(pdev);
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+	struct spi_message	*msg;
+
+	/* reset the hardware and block queue progress */
+	spin_lock_irq(&as->lock);
+	as->stopping = 1;
+	spi_writel(as, CR, SPI_BIT(SWRST));
+	spi_readl(as, SR);
+	spin_unlock_irq(&as->lock);
+
+	/* Terminate remaining queued transfers */
+	list_for_each_entry(msg, &as->queue, queue) {
+		/* REVISIT unmapping the dma is sort of a NOP on ARM,
+		 * but we shouldn't depend on that...
+		 */
+		msg->status = -ESHUTDOWN;
+		msg->complete(msg->context);
+	}
+
+	dma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,
+			  as->buffer_dma);
+
+	clk_disable(as->clk);
+	clk_put(as->clk);
+	free_irq(as->irq, master);
+	iounmap(as->regs);
+
+	spi_unregister_master(master);
+
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+
+static int atmel_spi_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct spi_master	*master = platform_get_drvdata(pdev);
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+
+	clk_disable(as->clk);
+	return 0;
+}
+
+static int atmel_spi_resume(struct platform_device *pdev)
+{
+	struct spi_master	*master = platform_get_drvdata(pdev);
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+
+	clk_enable(as->clk);
+	return 0;
+}
+
+#else
+#define	atmel_spi_suspend	NULL
+#define	atmel_spi_resume	NULL
+#endif
+
+
+static struct platform_driver atmel_spi_driver = {
+	.driver		= {
+		.name	= "atmel_spi",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= atmel_spi_probe,
+	.suspend	= atmel_spi_suspend,
+	.resume		= atmel_spi_resume,
+	.remove		= __devexit_p(atmel_spi_remove),
+};
+
+static int __init atmel_spi_init(void)
+{
+	return platform_driver_register(&atmel_spi_driver);
+}
+module_init(atmel_spi_init);
+
+static void __exit atmel_spi_exit(void)
+{
+	platform_driver_unregister(&atmel_spi_driver);
+}
+module_exit(atmel_spi_exit);
+
+MODULE_DESCRIPTION("Atmel AT32/AT91 SPI Controller driver");
+MODULE_AUTHOR("Haavard Skinnemoen <hskinnemoen@atmel.com>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.19-avr1/drivers/spi/atmel_spi.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/spi/atmel_spi.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,167 @@
+/*
+ * Register definitions for Atmel Serial Peripheral Interface (SPI)
+ *
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ATMEL_SPI_H__
+#define __ATMEL_SPI_H__
+
+/* SPI register offsets */
+#define SPI_CR					0x0000
+#define SPI_MR					0x0004
+#define SPI_RDR					0x0008
+#define SPI_TDR					0x000c
+#define SPI_SR					0x0010
+#define SPI_IER					0x0014
+#define SPI_IDR					0x0018
+#define SPI_IMR					0x001c
+#define SPI_CSR0				0x0030
+#define SPI_CSR1				0x0034
+#define SPI_CSR2				0x0038
+#define SPI_CSR3				0x003c
+#define SPI_RPR					0x0100
+#define SPI_RCR					0x0104
+#define SPI_TPR					0x0108
+#define SPI_TCR					0x010c
+#define SPI_RNPR				0x0110
+#define SPI_RNCR				0x0114
+#define SPI_TNPR				0x0118
+#define SPI_TNCR				0x011c
+#define SPI_PTCR				0x0120
+#define SPI_PTSR				0x0124
+
+/* Bitfields in CR */
+#define SPI_SPIEN_OFFSET			0
+#define SPI_SPIEN_SIZE				1
+#define SPI_SPIDIS_OFFSET			1
+#define SPI_SPIDIS_SIZE				1
+#define SPI_SWRST_OFFSET			7
+#define SPI_SWRST_SIZE				1
+#define SPI_LASTXFER_OFFSET			24
+#define SPI_LASTXFER_SIZE			1
+
+/* Bitfields in MR */
+#define SPI_MSTR_OFFSET				0
+#define SPI_MSTR_SIZE				1
+#define SPI_PS_OFFSET				1
+#define SPI_PS_SIZE				1
+#define SPI_PCSDEC_OFFSET			2
+#define SPI_PCSDEC_SIZE				1
+#define SPI_FDIV_OFFSET				3
+#define SPI_FDIV_SIZE				1
+#define SPI_MODFDIS_OFFSET			4
+#define SPI_MODFDIS_SIZE			1
+#define SPI_LLB_OFFSET				7
+#define SPI_LLB_SIZE				1
+#define SPI_PCS_OFFSET				16
+#define SPI_PCS_SIZE				4
+#define SPI_DLYBCS_OFFSET			24
+#define SPI_DLYBCS_SIZE				8
+
+/* Bitfields in RDR */
+#define SPI_RD_OFFSET				0
+#define SPI_RD_SIZE				16
+
+/* Bitfields in TDR */
+#define SPI_TD_OFFSET				0
+#define SPI_TD_SIZE				16
+
+/* Bitfields in SR */
+#define SPI_RDRF_OFFSET				0
+#define SPI_RDRF_SIZE				1
+#define SPI_TDRE_OFFSET				1
+#define SPI_TDRE_SIZE				1
+#define SPI_MODF_OFFSET				2
+#define SPI_MODF_SIZE				1
+#define SPI_OVRES_OFFSET			3
+#define SPI_OVRES_SIZE				1
+#define SPI_ENDRX_OFFSET			4
+#define SPI_ENDRX_SIZE				1
+#define SPI_ENDTX_OFFSET			5
+#define SPI_ENDTX_SIZE				1
+#define SPI_RXBUFF_OFFSET			6
+#define SPI_RXBUFF_SIZE				1
+#define SPI_TXBUFE_OFFSET			7
+#define SPI_TXBUFE_SIZE				1
+#define SPI_NSSR_OFFSET				8
+#define SPI_NSSR_SIZE				1
+#define SPI_TXEMPTY_OFFSET			9
+#define SPI_TXEMPTY_SIZE			1
+#define SPI_SPIENS_OFFSET			16
+#define SPI_SPIENS_SIZE				1
+
+/* Bitfields in CSR0 */
+#define SPI_CPOL_OFFSET				0
+#define SPI_CPOL_SIZE				1
+#define SPI_NCPHA_OFFSET			1
+#define SPI_NCPHA_SIZE				1
+#define SPI_CSAAT_OFFSET			3
+#define SPI_CSAAT_SIZE				1
+#define SPI_BITS_OFFSET				4
+#define SPI_BITS_SIZE				4
+#define SPI_SCBR_OFFSET				8
+#define SPI_SCBR_SIZE				8
+#define SPI_DLYBS_OFFSET			16
+#define SPI_DLYBS_SIZE				8
+#define SPI_DLYBCT_OFFSET			24
+#define SPI_DLYBCT_SIZE				8
+
+/* Bitfields in RCR */
+#define SPI_RXCTR_OFFSET			0
+#define SPI_RXCTR_SIZE				16
+
+/* Bitfields in TCR */
+#define SPI_TXCTR_OFFSET			0
+#define SPI_TXCTR_SIZE				16
+
+/* Bitfields in RNCR */
+#define SPI_RXNCR_OFFSET			0
+#define SPI_RXNCR_SIZE				16
+
+/* Bitfields in TNCR */
+#define SPI_TXNCR_OFFSET			0
+#define SPI_TXNCR_SIZE				16
+
+/* Bitfields in PTCR */
+#define SPI_RXTEN_OFFSET			0
+#define SPI_RXTEN_SIZE				1
+#define SPI_RXTDIS_OFFSET			1
+#define SPI_RXTDIS_SIZE				1
+#define SPI_TXTEN_OFFSET			8
+#define SPI_TXTEN_SIZE				1
+#define SPI_TXTDIS_OFFSET			9
+#define SPI_TXTDIS_SIZE				1
+
+/* Constants for BITS */
+#define SPI_BITS_8_BPT				0
+#define SPI_BITS_9_BPT				1
+#define SPI_BITS_10_BPT				2
+#define SPI_BITS_11_BPT				3
+#define SPI_BITS_12_BPT				4
+#define SPI_BITS_13_BPT				5
+#define SPI_BITS_14_BPT				6
+#define SPI_BITS_15_BPT				7
+#define SPI_BITS_16_BPT				8
+
+/* Bit manipulation macros */
+#define SPI_BIT(name) \
+	(1 << SPI_##name##_OFFSET)
+#define SPI_BF(name,value) \
+	(((value) & ((1 << SPI_##name##_SIZE) - 1)) << SPI_##name##_OFFSET)
+#define SPI_BFEXT(name,value) \
+	(((value) >> SPI_##name##_OFFSET) & ((1 << SPI_##name##_SIZE) - 1))
+#define SPI_BFINS(name,value,old) \
+	( ((old) & ~(((1 << SPI_##name##_SIZE) - 1) << SPI_##name##_OFFSET)) \
+	  | SPI_BF(name,value))
+
+/* Register access macros */
+#define spi_readl(port,reg) \
+	__raw_readl((port)->regs + SPI_##reg)
+#define spi_writel(port,reg,value) \
+	__raw_writel((value), (port)->regs + SPI_##reg)
+
+#endif /* __ATMEL_SPI_H__ */
Index: linux-2.6.19-avr1/drivers/i2c/busses/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/drivers/i2c/busses/Kconfig	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/i2c/busses/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -5,6 +5,12 @@
 menu "I2C Hardware Bus support"
 	depends on I2C
 
+config I2C_TWI
+        tristate "Atmel TWI/I2C"
+        depends on I2C
+        help
+                If in doubt, say NO
+
 config I2C_ALI1535
 	tristate "ALI 1535"
 	depends on I2C && PCI
Index: linux-2.6.19-avr1/drivers/i2c/busses/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/drivers/i2c/busses/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/i2c/busses/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -44,6 +44,7 @@ obj-$(CONFIG_I2C_VIAPRO)	+= i2c-viapro.o
 obj-$(CONFIG_I2C_VOODOO3)	+= i2c-voodoo3.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
+obj-$(CONFIG_I2C_TWI)           += i2c-atmeltwi.o
 
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
Index: linux-2.6.19-avr1/drivers/i2c/busses/atmeltwi.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/i2c/busses/atmeltwi.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,118 @@
+/*
+ * Register definitions for TWI
+ *
+ * Two-wire Interface
+ */
+#ifndef __ASM_AVR32_TWI_H__
+#define __ASM_AVR32_TWI_H__
+
+/* TWI register offsets */
+#define TWI_CR					0x0000
+#define TWI_MMR					0x0004
+#define TWI_SMR					0x0008
+#define TWI_IADR				0x000c
+#define TWI_CWGR				0x0010
+#define TWI_SR					0x0020
+#define TWI_IER					0x0024
+#define TWI_IDR					0x0028
+#define TWI_IMR					0x002c
+#define TWI_RHR					0x0030
+#define TWI_THR					0x0034
+
+/* Bitfields in CR */
+#define TWI_START_OFFSET			0
+#define TWI_START_SIZE				1
+#define TWI_STOP_OFFSET				1
+#define TWI_STOP_SIZE				1
+#define TWI_MSEN_OFFSET				2
+#define TWI_MSEN_SIZE				1
+#define TWI_MSDIS_OFFSET			3
+#define TWI_MSDIS_SIZE				1
+#define TWI_SVEN_OFFSET				4
+#define TWI_SVEN_SIZE				1
+#define TWI_SVDIS_OFFSET			5
+#define TWI_SVDIS_SIZE				1
+#define TWI_SWRST_OFFSET			7
+#define TWI_SWRST_SIZE				1
+
+/* Bitfields in MMR */
+#define TWI_IADRSZ_OFFSET			8
+#define TWI_IADRSZ_SIZE				2
+#define TWI_MREAD_OFFSET			12
+#define TWI_MREAD_SIZE				1
+#define TWI_DADR_OFFSET				16
+#define TWI_DADR_SIZE				7
+
+/* Bitfields in SMR */
+#define TWI_SADR_OFFSET				16
+#define TWI_SADR_SIZE				7
+
+/* Bitfields in IADR */
+#define TWI_IADR_OFFSET				0
+#define TWI_IADR_SIZE				24
+
+/* Bitfields in CWGR */
+#define TWI_CLDIV_OFFSET			0
+#define TWI_CLDIV_SIZE				8
+#define TWI_CHDIV_OFFSET			8
+#define TWI_CHDIV_SIZE				8
+#define TWI_CKDIV_OFFSET			16
+#define TWI_CKDIV_SIZE				3
+
+/* Bitfields in SR */
+#define TWI_TXCOMP_OFFSET			0
+#define TWI_TXCOMP_SIZE				1
+#define TWI_RXRDY_OFFSET			1
+#define TWI_RXRDY_SIZE				1
+#define TWI_TXRDY_OFFSET			2
+#define TWI_TXRDY_SIZE				1
+#define TWI_SVDIR_OFFSET			3
+#define TWI_SVDIR_SIZE				1
+#define TWI_SVACC_OFFSET			4
+#define TWI_SVACC_SIZE				1
+#define TWI_GCACC_OFFSET			5
+#define TWI_GCACC_SIZE				1
+#define TWI_OVRE_OFFSET				6
+#define TWI_OVRE_SIZE				1
+#define TWI_UNRE_OFFSET				7
+#define TWI_UNRE_SIZE				1
+#define TWI_NACK_OFFSET				8
+#define TWI_NACK_SIZE				1
+#define TWI_ARBLST_OFFSET			9
+#define TWI_ARBLST_SIZE				1
+
+/* Bitfields in RHR */
+#define TWI_RXDATA_OFFSET			0
+#define TWI_RXDATA_SIZE				8
+
+/* Bitfields in THR */
+#define TWI_TXDATA_OFFSET			0
+#define TWI_TXDATA_SIZE				8
+
+/* Constants for IADRSZ */
+#define TWI_IADRSZ_NO_ADDR			0
+#define TWI_IADRSZ_ONE_BYTE			1
+#define TWI_IADRSZ_TWO_BYTES			2
+#define TWI_IADRSZ_THREE_BYTES			3
+
+/* Bit manipulation macros */
+#define TWI_BIT(name)					\
+	(1 << TWI_##name##_OFFSET)
+#define TWI_BF(name,value)				\
+	(((value) & ((1 << TWI_##name##_SIZE) - 1))	\
+	 << TWI_##name##_OFFSET)
+#define TWI_BFEXT(name,value)				\
+	(((value) >> TWI_##name##_OFFSET)		\
+	 & ((1 << TWI_##name##_SIZE) - 1))
+#define TWI_BFINS(name,value,old)			\
+	(((old) & ~(((1 << TWI_##name##_SIZE) - 1)	\
+		    << TWI_##name##_OFFSET))		\
+	 | TWI_BF(name,value))
+
+/* Register access macros */
+#define twi_readl(port,reg)				\
+	__raw_readl((port)->regs + TWI_##reg)
+#define twi_writel(port,reg,value)			\
+	__raw_writel((value), (port)->regs + TWI_##reg)
+
+#endif /* __ASM_AVR32_TWI_H__ */
Index: linux-2.6.19-avr1/drivers/i2c/busses/i2c-atmeltwi.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/i2c/busses/i2c-atmeltwi.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,412 @@
+/*
+    i2c Support for Atmel's Two-Wire Interface (TWI)
+
+    Based on the work of Copyright (C) 2004 Rick Bronson
+    Converted to 2.6 by Andrew Victor <andrew at sanpeople.com>
+    Ported to AVR32 by Espen Krangnes <ekrangnes@atmel.com>
+
+    Borrowed heavily from the original work by:
+    Copyright (C) 2000 Philip Edelbrock <phil at stimpy.netroedge.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+*/
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/completion.h>
+
+
+#include <asm/io.h>
+
+#include "atmeltwi.h"
+
+static unsigned int BAUDRATE = 100000;
+module_param(BAUDRATE, uint, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+MODULE_PARM_DESC(BAUDRATE, "The TWI baudrate. Default is 100k.");
+
+
+struct atmel_twi {
+	void __iomem *regs;
+	struct i2c_adapter adapter;
+	struct clk *pclk;
+
+	unsigned char curbyte;
+	unsigned char transfer_type;
+
+	spinlock_t *lock;
+	struct completion tx_completion;
+	struct completion rx_completion;
+
+	unsigned int irq;
+
+};
+#define to_atmel_twi(adap) container_of(adap, struct atmel_twi, adapter)
+
+/*
+ * Initialize the TWI hardware registers.
+ */
+static void __devinit twi_hwinit(struct atmel_twi *twi)
+{
+	unsigned long cdiv, ckdiv=0;
+
+	twi_writel(twi, IDR, ~0UL);		/* Disable all interrupts */
+	twi_writel(twi, CR, TWI_BIT(SWRST));	/* Reset peripheral */
+	twi_writel(twi, CR, TWI_BIT(MSEN));	/* Enable master mode */
+
+	cdiv = clk_get_rate(twi->pclk);
+	cdiv = (clk_get_rate(twi->pclk) / (2 * BAUDRATE)) - 3;
+	cdiv = cdiv + 1;	/* round up */
+
+	while (cdiv > 255) {
+		ckdiv++;
+		cdiv = cdiv >> 1;
+	}
+
+	BUG_ON(ckdiv > 5);	/* AT91RM9200 Errata #22 */
+	twi_writel(twi, CWGR, (TWI_BF(CKDIV, ckdiv)
+			       | TWI_BF(CHDIV, cdiv)
+			       | TWI_BF(CLDIV, cdiv)));
+}
+
+/*
+ * Poll the i2c status register until a bit in the specified bitmask is set.
+ * Returns 0 if timed out (100 msec).
+ */
+static short twi_wait_for_completion(struct atmel_twi *twi, unsigned short mask)
+{
+	int timeout=100;
+
+	twi->transfer_type = mask;
+
+	switch(twi->transfer_type){
+
+		case TWI_BIT(TXRDY):
+			init_completion(&twi->tx_completion);
+			break;
+		case TWI_BIT(TXCOMP):
+			init_completion(&twi->tx_completion);
+			break;
+		case TWI_BIT(RXRDY):
+			init_completion(&twi->rx_completion);
+			break;
+		default:
+			return -EIO;
+
+	}
+
+	twi_writel(twi, IER, mask);		/* Enable interrupt */
+
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	switch(twi->transfer_type){
+
+		case TWI_BIT(TXRDY):
+			if(!wait_for_completion_timeout(&twi->tx_completion, timeout))
+				goto ERR;
+			else
+				goto DONE;
+		case TWI_BIT(TXCOMP):
+			if(!wait_for_completion_timeout(&twi->tx_completion, timeout))
+				goto ERR;
+			else
+				goto DONE;
+		case TWI_BIT(RXRDY):
+			if(!wait_for_completion_timeout(&twi->rx_completion, timeout))
+				goto ERR;
+			else
+				goto DONE;
+		default:
+			return -EIO;
+	}
+
+	return 0;
+
+ERR:
+	twi_writel(twi, IDR, ~0UL);		/* Disable interrupt */
+	return -ETIMEDOUT;
+
+DONE:
+	twi_writel(twi, IER, 0 );
+	return 0;
+}
+
+/*
+ * Generic i2c master transfer entrypoint.
+ */
+static int twi_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
+{
+	struct atmel_twi *twi = to_atmel_twi(adap);
+	struct i2c_msg *pmsg;
+	int length;
+	unsigned char *buf;
+	int i;
+
+	dev_dbg(&adap->dev, "twi_xfer: processing %d messages:\n", num);
+
+	twi_hwinit(twi);
+
+	pmsg = msgs;		/* get 1st message */
+	i=twi_readl(twi, RHR);	/* dummy read */
+
+	for (i = 0; i < num; i++, pmsg++) {
+
+		dev_dbg(&adap->dev, " #%d: internal addr %d byte%s %s 0x%02x ...", i,
+			pmsg->len, pmsg->len > 1 ? "s" : "",
+			pmsg->flags & I2C_M_RD ? "from" : "to", pmsg->addr);
+
+		if((num > 1) && (i==0) && (pmsg->len >= 1) && (pmsg->len <= 3) && !(pmsg->flags & I2C_M_RD)){
+
+                        length = pmsg->len;
+                        buf = pmsg->buf;
+
+                        switch(pmsg->len){
+                        case 1:
+                                twi_writel(twi, IADR, buf[0]);
+                                break;
+                        case 2:
+                                twi_writel(twi, IADR, (buf[1]<<8) + buf[0]);
+                                break;
+                        case 3:
+                                twi_writel(twi, IADR, (buf[2]<<16) + (buf[1]<<8) + buf[0]);
+                                break;
+                        }
+
+                        i++;
+                        pmsg++;
+                        twi_writel(twi, MMR, (TWI_BF(DADR, pmsg->addr) | (pmsg->flags & I2C_M_RD ? TWI_BIT(MREAD) : 0) | ((length)<<8) ));
+                }else{
+
+			/*
+			 * Set the TWI Master Mode Register: We do _not_ use
+			 * Atmel's feature of storing the "internal device
+			 * address" in TWI_IADR. Thus the IADRSZ bits in
+			 * TWI_MMR are set to zero.  Instead the "internal
+			 * device address" has to be written using a seperate
+			 * i2c message.  See
+			 * http://lists.arm.linux.org.uk/pipermail/linux-arm-kernel/2004-September/024411.html
+			 */
+			twi_writel(twi, MMR, (TWI_BF(DADR, pmsg->addr)
+					      | (pmsg->flags & I2C_M_RD
+						 ? TWI_BIT(MREAD) : 0)));
+		}
+
+		length = pmsg->len;
+		buf = pmsg->buf;
+
+		if (!length || !buf) {	/* sanity check */
+			dev_dbg(&adap->dev, "skipped\n");
+			continue;
+		}
+
+		/* Enable Master Mode */
+		twi_writel(twi, IMR, 0);
+		twi_readl(twi, SR);
+
+		/* Send Start */
+		twi_writel(twi, CR, TWI_BIT(START));
+
+		if (pmsg->flags & I2C_M_RD) {
+			while (length--) {
+				if ( twi_wait_for_completion(twi, TWI_BIT(RXRDY)) == -ETIMEDOUT ) {
+					dev_dbg(&adap->dev, "RXRDY timeout\n");
+					printk(KERN_INFO "stopped with %d rx bytes left\n", length+1);
+					return -ETIMEDOUT;
+				}
+				*buf++ = twi->curbyte;
+			}
+		} else {
+			while (length--) {
+				twi_writel(twi, THR, *buf++);
+				if ( twi_wait_for_completion(twi, TWI_BIT(TXRDY)) == -ETIMEDOUT ) {
+					dev_dbg(&adap->dev, "TXRDY timeout\n");
+					return -ETIMEDOUT;
+				}
+			}
+		}
+
+		/* Send Stop, and Wait until transfer is finished */
+		twi_writel(twi, CR, TWI_BIT(STOP));
+
+		if ( twi_wait_for_completion(twi, TWI_BIT(TXCOMP)) == -ETIMEDOUT ) {
+			dev_dbg(&adap->dev, "TXCOMP timeout\n");
+			return -ETIMEDOUT;
+		}
+		dev_dbg(&adap->dev, "ok\n");
+	}
+
+	return i;
+}
+
+
+static irqreturn_t twi_interrupt(int irq, void *dev_id)
+{
+	struct atmel_twi *twi = dev_id;
+	int status;
+
+	spin_lock(twi->lock);
+	status = twi_readl(twi, SR);
+
+	if (status & TWI_BIT(TXCOMP) )
+		complete_all(&twi->tx_completion);
+
+	else if ( status & TWI_BIT(RXRDY) ){
+		twi->curbyte = twi_readl(twi, RHR);
+		complete_all(&twi->rx_completion);
+	}
+	else if ( status & TWI_BIT(TXRDY) ){
+		complete_all(&twi->tx_completion);
+	}
+	else if (status & TWI_BIT(TXCOMP) ){
+		complete_all(&twi->tx_completion);
+	}
+
+	twi_writel(twi, IDR, ~0UL);
+
+	spin_unlock(twi->lock);
+
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * Return list of supported functionality.
+ */
+static u32 twi_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+/* For now, we only handle combined mode (smbus) */
+static struct i2c_algorithm twi_algorithm = {
+	.master_xfer	= twi_xfer,
+	.functionality	= twi_func,
+};
+
+/*
+ * Main initialization routine.
+ */
+static int __devinit twi_probe(struct platform_device *pdev)
+{
+	struct atmel_twi *twi;
+	struct resource *regs;
+	struct clk *pclk;
+	struct i2c_adapter *adapter;
+	int rc, irq;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+
+	pclk = clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(pclk))
+		return PTR_ERR(pclk);
+	clk_enable(pclk);
+
+	rc = -ENOMEM;
+	twi = kzalloc(sizeof(struct atmel_twi), GFP_KERNEL);
+	if (!twi) {
+		dev_err(&pdev->dev, "can't allocate inteface!\n");
+		goto err_alloc_twi;
+	}
+
+	twi->pclk = pclk;
+	twi->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!twi->regs)
+		goto err_ioremap;
+
+	adapter = &twi->adapter;
+	sprintf(adapter->name, "TWI");
+	adapter->algo = &twi_algorithm;
+	adapter->class = I2C_CLASS_HWMON;
+	adapter->dev.parent = &pdev->dev;
+
+	irq = platform_get_irq(pdev,0);
+	rc = request_irq(irq, twi_interrupt, 0, "twi", twi);
+	if (rc) {
+		dev_err(&pdev->dev, "can't bind irq!\n");
+		goto err_ioremap;
+
+	}
+	twi->irq = irq;
+
+	twi_hwinit(twi);
+
+	platform_set_drvdata(pdev, twi);
+
+	rc = i2c_add_adapter(adapter);
+	if (rc) {
+		dev_err(&pdev->dev, "Adapter %s registration failed\n",
+			adapter->name);
+		goto err_register;
+	}
+
+	dev_info(&pdev->dev, "Atmel TWI i2c bus device at 0x%08lx.\n",
+		 (unsigned long)regs->start);
+
+	return 0;
+
+err_register:
+	platform_set_drvdata(pdev, NULL);
+	twi_writel(twi, CR, TWI_BIT(MSDIS));
+	iounmap(twi->regs);
+err_ioremap:
+	kfree(twi);
+err_alloc_twi:
+	clk_disable(pclk);
+	clk_put(pclk);
+	return rc;
+}
+
+static int __devexit twi_remove(struct platform_device *pdev)
+{
+	struct atmel_twi *twi = platform_get_drvdata(pdev);
+	int res;
+
+	platform_set_drvdata(pdev, NULL);
+	res = i2c_del_adapter(&twi->adapter);
+	twi_writel(twi, CR, TWI_BIT(MSDIS));
+	iounmap(twi->regs);
+	clk_disable(twi->pclk);
+	clk_put(twi->pclk);
+	kfree(twi);
+
+	return res;
+}
+
+static struct platform_driver twi_driver = {
+	.probe		= twi_probe,
+	.remove		= __devexit_p(twi_remove),
+	.driver		= {
+		.name	= "atmel_twi",
+	},
+};
+
+static int __init atmel_twi_init(void)
+{
+	return platform_driver_register(&twi_driver);
+}
+
+static void __exit atmel_twi_exit(void)
+{
+	platform_driver_unregister(&twi_driver);
+}
+
+module_init(atmel_twi_init);
+module_exit(atmel_twi_exit);
+
+MODULE_AUTHOR("Copyright (C) 2004 Rick Bronson");
+MODULE_DESCRIPTION("I2C driver for Atmel TWI");
+MODULE_LICENSE("GPL");
Index: linux-2.6.19-avr1/drivers/video/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/drivers/video/Kconfig	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/video/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -276,6 +276,28 @@ config FB_SA1100
 	  If you plan to use the LCD display with your SA-1100 system, say
 	  Y here.
 
+config FB_SIDSA
+	tristate "SIDSA LCDC support"
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	depends on FB && AVR32
+	help
+	  This enables support for the SIDSA LCD Controller.
+
+config FB_SIDSA_DEFAULT_BPP
+	int "SIDSA LCDC default color depth"
+	default 24
+	depends on FB_SIDSA
+	help
+	  Specify the maximum color depth you want to be able to
+	  support. This, together with the resolution of the LCD
+	  panel, determines the amount of framebuffer memory allocated
+	  when the driver is initialized.
+
+	  Allowable values are 1, 2, 4, 8, 16, 24 and 32. If unsure,
+	  say 24.
+
 config FB_IMX
 	tristate "Motorola i.MX LCD support"
 	depends on FB && ARM && ARCH_IMX
Index: linux-2.6.19-avr1/drivers/video/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/drivers/video/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/video/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -76,6 +76,7 @@ obj-$(CONFIG_FB_HP300)            += hpf
 obj-$(CONFIG_FB_G364)             += g364fb.o
 obj-$(CONFIG_FB_SA1100)           += sa1100fb.o
 obj-$(CONFIG_FB_SUN3)             += sun3fb.o
+obj-$(CONFIG_FB_SIDSA)		  += sidsafb.o
 obj-$(CONFIG_FB_HIT)              += hitfb.o
 obj-$(CONFIG_FB_EPSON1355)	  += epson1355fb.o
 obj-$(CONFIG_FB_PVR2)             += pvr2fb.o
Index: linux-2.6.19-avr1/drivers/video/fbmem.c
===================================================================
--- linux-2.6.19-avr1.orig/drivers/video/fbmem.c	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/video/fbmem.c	2006-12-03 19:23:23.000000000 +0100
@@ -1154,6 +1154,7 @@ fb_mmap(struct file *file, struct vm_are
 	/* frame buffer memory */
 	start = info->fix.smem_start;
 	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
+	pr_debug("fb_mmap: start = 0x%08lx, len = 0x%08lx\n", start, len);
 	if (off >= len) {
 		/* memory mapped io */
 		off -= len;
@@ -1169,6 +1170,7 @@ fb_mmap(struct file *file, struct vm_are
 	if ((vma->vm_end - vma->vm_start + off) > len)
 		return -EINVAL;
 	off += start;
+	pr_debug("fb_mmap: off = 0x%08lx\n", off);
 	vma->vm_pgoff = off >> PAGE_SHIFT;
 	/* This is an IO map - tell maydump to skip this VMA */
 	vma->vm_flags |= VM_IO | VM_RESERVED;
@@ -1199,6 +1201,10 @@ fb_mmap(struct file *file, struct vm_are
 	pgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE;
 #elif defined(__arm__) || defined(__sh__) || defined(__m32r__)
 	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+#elif defined(__avr32__)
+	vma->vm_page_prot = __pgprot((pgprot_val(vma->vm_page_prot)
+				      & ~_PAGE_CACHABLE)
+				     | (_PAGE_BUFFER | _PAGE_DIRTY));
 #elif defined(__ia64__)
 	if (efi_range_is_wc(vma->vm_start, vma->vm_end - vma->vm_start))
 		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
Index: linux-2.6.19-avr1/drivers/video/sidsafb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/video/sidsafb.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,860 @@
+/*
+ * Framebuffer Driver for Atmel/SIDSA LCD Controller
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#undef DEBUG
+
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <asm/arch/board.h>
+
+#include <asm/periph/lcdc.h>
+
+/* More or less configurable parameters */
+#define SIDSAFB_FIFO_SIZE		512
+#define SIDSAFB_DMA_BURST_LEN		8
+
+/* TODO: These should be autogenerated from part description file */
+#define LCDC_DISTYPE_STN_MONO		0
+#define LCDC_DISTYPE_STN_COLOR		1
+#define LCDC_DISTYPE_TFT		2
+#define LCDC_LUT			0xc00
+
+struct sidsafb_info {
+	spinlock_t		lock;
+	struct fb_info *	info;
+	void __iomem *		regs;
+	unsigned long		irq_base;
+	int			wait_for_vsync;
+	struct completion	vsync_complete;
+	unsigned int		guard_time;
+	struct clk		*hclk;
+	struct clk		*pixclk;
+	struct platform_device	*pdev;
+	u32			pseudo_palette[16];
+};
+
+/*
+ * How large framebuffer to allocate if none was provided by the
+ * platform. This default is the smallest we can possibly get away
+ * with.
+ */
+static unsigned long fb_size = (320 * 240);
+
+#if 0
+static struct fb_videomode sony_modes[] = {
+	{
+		.refresh	= 48,
+		.xres		= 240,		.yres		= 160,
+		.pixclock	= 520833,
+
+		.left_margin	= 7,		.right_margin	= 9,
+		.upper_margin	= 19,		.lower_margin	= 20,
+		.hsync_len	= 9,		.vsync_len	= 2,
+
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+#endif
+
+#if 0
+static struct fb_videomode vga_modes[] = {
+	{
+		.refresh	= 122,
+		.xres		= 320,		.yres		= 240,
+		.pixclock	= 80000,
+
+		.left_margin	= 10,		.right_margin	= 20,
+		.upper_margin	= 30,		.lower_margin	= 5,
+		.hsync_len	= 20,		.vsync_len	= 3,
+
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	{
+		.refresh	= 70,
+		.xres		= 640,		.yres		= 480,
+		.pixclock	= 40000,
+
+		.left_margin	= 10,		.right_margin	= 20,
+		.upper_margin	= 30,		.lower_margin	= 5,
+		.hsync_len	= 20,		.vsync_len	= 3,
+
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+#else
+static struct fb_videomode samsung_modes[] = {
+	{
+		.refresh	= 75,
+		.xres		= 320,		.yres		= 240,
+		.pixclock	= 145111,
+
+		.left_margin	= 17,		.right_margin	= 33,
+		.upper_margin	= 10,		.lower_margin	= 10,
+		.hsync_len	= 16,		.vsync_len	= 1,
+
+		.sync		= FB_SYNC_PCLK_RISING,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+#endif
+
+#if 1
+static struct fb_monspecs default_monspecs = {
+	.modedb		= samsung_modes,
+	.manufacturer	= "SNG",
+	.monitor	= "LCD panel",
+	.serial_no	= "xxxx",
+	.ascii		= "yyyy",
+	.modedb_len	= ARRAY_SIZE(samsung_modes),
+	.hfmin		= 14820,
+	.hfmax		= 22230,
+	.vfmin		= 60,
+	.vfmax		= 90,
+	.dclkmax	= 30000000,
+};
+#endif
+
+#if 0
+static struct fb_monspecs default_monspecs = {
+	.modedb		= sony_modes,
+	.manufacturer	= "SNY",	/* 4 chars?!? */
+	.monitor	= "LCD panel",
+	.serial_no	= "xxxx",
+	.ascii		= "yyyy",
+	.modedb_len	= ARRAY_SIZE(sony_modes),
+	.hfmin		= 7000,
+	.hfmax		= 8000,
+	.vfmin		= 45,
+	.vfmax		= 50,
+};
+// #else
+static struct fb_monspecs default_monspecs = {
+	.modedb		= vga_modes,
+	.manufacturer	= "VGA",
+	.monitor	= "Generic VGA",
+	.serial_no	= "xxxx",
+	.ascii		= "yyyy",
+	.modedb_len	= ARRAY_SIZE(vga_modes),
+	.hfmin		= 30000,
+	.hfmax		= 64000,
+	.vfmin		= 50,
+	.vfmax		= 150,
+};
+#endif
+
+/* Driver defaults */
+static struct fb_fix_screeninfo sidsafb_fix __devinitdata = {
+	.id		= "sidsafb",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_TRUECOLOR,
+	.xpanstep	= 1,
+	.ypanstep	= 1,
+	.ywrapstep	= 0,
+	.accel		= FB_ACCEL_NONE,
+};
+
+/*
+ * Let the user decide whether FBIOPAN_DISPLAY waits for the next
+ * vsync or not.
+ */
+static ssize_t
+vsync_pan_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct sidsafb_info *sinfo = info->par;
+
+	return sprintf(buf, "%d\n", sinfo->wait_for_vsync);
+}
+
+static ssize_t
+vsync_pan_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct sidsafb_info *sinfo = info->par;
+	unsigned long val;
+
+	val = simple_strtoul(buf, NULL, 0);
+	if (val)
+		sinfo->wait_for_vsync = 1;
+	else
+		sinfo->wait_for_vsync = 0;
+
+	return count;
+}
+
+static DEVICE_ATTR(vsync_pan, 0644, vsync_pan_show, vsync_pan_store);
+
+static void sidsafb_update_dma(struct fb_info *info,
+			       struct fb_var_screeninfo *var)
+{
+	struct sidsafb_info *sinfo = info->par;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	unsigned long dma_addr;
+	unsigned long pixeloff;
+	unsigned long dma2dcfg;
+
+	dma_addr = (fix->smem_start + var->yoffset * fix->line_length
+		    + var->xoffset * var->bits_per_pixel / 8);
+
+	dma_addr &= ~3UL;
+	pixeloff = LCDC_MKBF(DMA2DCFG_PIXELOFF, var->xoffset * var->bits_per_pixel);
+
+	/* Set framebuffer DMA base address and pixel offset */
+	lcdc_writel(sinfo, DMABADDR1, dma_addr);
+	dma2dcfg = lcdc_readl(sinfo, DMA2DCFG);
+	dma2dcfg = LCDC_INSBF(DMA2DCFG_PIXELOFF, pixeloff, dma2dcfg);
+	lcdc_writel(sinfo, DMA2DCFG, dma2dcfg);
+
+	/* Update configuration */
+	lcdc_writel(sinfo, DMACON, (lcdc_readl(sinfo, DMACON)
+				    | LCDC_BIT(DMACON_DMAUPDT)));
+}
+
+/**
+ *      sidsafb_check_var - Validates a var passed in.
+ *      @var: frame buffer variable screen structure
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *	Checks to see if the hardware supports the state requested by
+ *	var passed in. This function does not alter the hardware
+ *	state!!!  This means the data stored in struct fb_info and
+ *	struct sidsafb_info do not change. This includes the var
+ *	inside of struct fb_info.  Do NOT change these. This function
+ *	can be called on its own if we intent to only test a mode and
+ *	not actually set it. The stuff in modedb.c is a example of
+ *	this. If the var passed in is slightly off by what the
+ *	hardware can support then we alter the var PASSED in to what
+ *	we can do. If the hardware doesn't support mode change a
+ *	-EINVAL will be returned by the upper layers. You don't need
+ *	to implement this function then. If you hardware doesn't
+ *	support changing the resolution then this function is not
+ *	needed. In this case the driver would just provide a var that
+ *	represents the static state the screen is in.
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int sidsafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	unsigned long new_fb_size;
+
+	pr_debug("sidsafb_check_var:\n");
+	pr_debug("  resolution: %ux%u\n", var->xres, var->yres);
+	pr_debug("  pixclk:     %llu Hz\n", 1000000000000ULL / var->pixclock);
+	pr_debug("  bpp:        %u\n", var->bits_per_pixel);
+
+	new_fb_size = (var->xres_virtual * var->yres_virtual
+		       * ((var->bits_per_pixel + 7) / 8));
+	if (new_fb_size > info->fix.smem_len) {
+		printk(KERN_NOTICE
+		       "sidsafb: %uB framebuffer too small for %ux%ux%u\n",
+		       info->fix.smem_len, var->xres_virtual,
+		       var->yres_virtual, var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	/* Force same alignment for each line */
+	var->xres = (var->xres + 3) & ~3UL;
+	var->xres_virtual = (var->xres_virtual + 3) & ~3UL;
+
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
+	var->transp.offset = var->transp.length = 0;
+
+	switch (var->bits_per_pixel) {
+	case 2:
+	case 4:
+	case 8:
+		var->red.offset = var->green.offset = var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length
+			= var->bits_per_pixel;
+		break;
+	case 15:
+	case 16:
+		/*
+		 * Bit 16 is the "intensity" bit, I think. Not sure
+		 * what we're going to use that for...
+		 */
+		var->red.offset = 0;
+		var->green.offset = 5;
+		var->blue.offset = 10;
+		var->red.length = 5;
+		var->green.length = 5;
+		var->blue.length = 5;
+		break;
+	case 32:
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		/* fall through */
+	case 24:
+		var->red.offset = 16;
+		var->green.offset = 8;
+		var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length = 8;
+		break;
+	default:
+		printk(KERN_NOTICE "sidsafb: color depth %d not supported\n",
+		       var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	var->xoffset = var->yoffset = 0;
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right =
+		var->transp.msb_right = 0;
+
+	return 0;
+}
+
+/**
+ *      sidsafb_set_par - Alters the hardware state.
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *	Using the fb_var_screeninfo in fb_info we set the resolution
+ *	of the this particular framebuffer. This function alters the
+ *	par AND the fb_fix_screeninfo stored in fb_info. It doesn't
+ *	not alter var in fb_info since we are using that data. This
+ *	means we depend on the data in var inside fb_info to be
+ *	supported by the hardware.  sidsafb_check_var is always called
+ *	before sidsafb_set_par to ensure this.  Again if you can't
+ *	change the resolution you don't need this function.
+ *
+ */
+static int sidsafb_set_par(struct fb_info *info)
+{
+	struct sidsafb_info *sinfo = info->par;
+	unsigned long value;
+
+	pr_debug("sidsafb_set_par:\n");
+	pr_debug("  * resolution: %ux%u (%ux%u virtual)\n",
+		 info->var.xres, info->var.yres,
+		 info->var.xres_virtual, info->var.yres_virtual);
+
+	/* Turn off the LCD controller and the DMA controller */
+	pr_debug("writing 0x%08x to %p\n",
+		 LCDC_MKBF(PWRCON_GUARD_TIME, sinfo->guard_time),
+		 sinfo->regs + LCDC_PWRCON);
+	lcdc_writel(sinfo, PWRCON,
+		    LCDC_MKBF(PWRCON_GUARD_TIME, sinfo->guard_time));
+	pr_debug("writing 0 to %p\n", sinfo->regs + LCDC_DMACON);
+	lcdc_writel(sinfo, DMACON, 0);
+
+	info->fix.line_length = (info->var.xres_virtual
+				 * (info->var.bits_per_pixel / 8));
+
+	if (info->var.bits_per_pixel <= 8)
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	/* Re-initialize the DMA engine... */
+	pr_debug("  * update DMA engine\n");
+	sidsafb_update_dma(info, &info->var);
+
+	/* ...set frame size and burst length = 8 words (?) */
+	value = LCDC_MKBF(DMAFRMCFG_FRMSIZE,
+			  (info->var.yres * info->fix.line_length + 3) / 4);
+	value |= LCDC_MKBF(DMAFRMCFG_BRSTLEN, (SIDSAFB_DMA_BURST_LEN - 1));
+	lcdc_writel(sinfo, DMAFRMCFG, value);
+
+	/* ...set 2D configuration (necessary for xres_virtual != xres) */
+	value = LCDC_MKBF(DMA2DCFG_ADDRINC,
+			  info->var.xres_virtual - info->var.xres);
+	lcdc_writel(sinfo, DMA2DCFG, value);
+
+	/* ...wait for DMA engine to become idle... */
+	while (lcdc_readl(sinfo, DMACON) & LCDC_BIT(DMACON_DMABUSY))
+		msleep(10);
+
+	pr_debug("  * re-enable DMA engine\n");
+	/* ...and enable it with updated configuration */
+	lcdc_writel(sinfo, DMACON, (LCDC_BIT(DMACON_DMAEN)
+				    | LCDC_BIT(DMACON_DMAUPDT)
+				    | LCDC_BIT(DMACON_DMA2DEN)));
+
+	/* Now, the LCD core... */
+
+	/* Set pixel clock. */
+	value = (clk_get_rate(sinfo->pixclk) / 100000) * info->var.pixclock;
+	value /= 10000000;
+	value = (value + 1) / 2;
+	if (value == 0) {
+		printk("sidsafb: Bypassing lcdc_pclk divider\n");
+		lcdc_writel(sinfo, LCDCON1, LCDC_BIT(LCDCON1_BYPASS));
+	} else {
+		lcdc_writel(sinfo, LCDCON1, LCDC_MKBF(LCDCON1_CLKVAL, value - 1));
+	}
+
+	/* Initialize control register 2 */
+	value = (LCDC_BIT(LCDCON2_CLKMOD)
+		 | LCDC_MKBF(LCDCON2_DISTYPE, LCDC_DISTYPE_TFT));
+	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+		value |= LCDC_BIT(LCDCON2_INVLINE);
+	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+		value |= LCDC_BIT(LCDCON2_INVFRAME);
+	if (info->var.sync & FB_SYNC_PCLK_RISING)
+		value |= LCDC_BIT(LCDCON2_INVCLK);
+
+	switch (info->var.bits_per_pixel) {
+	case 1:	value |= LCDC_MKBF(LCDCON2_PIXELSIZE, 0); break;
+	case 2: value |= LCDC_MKBF(LCDCON2_PIXELSIZE, 1); break;
+	case 4: value |= LCDC_MKBF(LCDCON2_PIXELSIZE, 2); break;
+	case 8: value |= LCDC_MKBF(LCDCON2_PIXELSIZE, 3); break;
+	case 15: /* fall through */
+	case 16: value |= LCDC_MKBF(LCDCON2_PIXELSIZE, 4); break;
+	case 24: value |= LCDC_MKBF(LCDCON2_PIXELSIZE, 5); break;
+	case 32: value |= LCDC_MKBF(LCDCON2_PIXELSIZE, 6); break;
+	default: BUG(); break;
+	}
+	pr_debug("  * LCDCON2 = %08lx\n", value);
+	lcdc_writel(sinfo, LCDCON2, value);
+
+	/* Vertical timing */
+	value = LCDC_MKBF(LCDTIM1_VPW, info->var.vsync_len - 1);
+	value |= LCDC_MKBF(LCDTIM1_VBP, info->var.upper_margin);
+	value |= LCDC_MKBF(LCDTIM1_VFP, info->var.lower_margin);
+	pr_debug("  * LCDTIM1 = %08lx\n", value);
+	lcdc_writel(sinfo, LCDTIM1, value);
+
+	/* Horizontal timing */
+	value = LCDC_MKBF(LCDTIM2_HFP, info->var.right_margin - 1);
+	value |= LCDC_MKBF(LCDTIM2_HPW, info->var.hsync_len - 1);
+	value |= LCDC_MKBF(LCDTIM2_HBP, info->var.left_margin - 1);
+	pr_debug("  * LCDTIM2 = %08lx\n", value);
+	lcdc_writel(sinfo, LCDTIM2, value);
+
+	/* Display size */
+	value = LCDC_MKBF(LCDFRMCFG_LINESIZE, info->var.xres - 1);
+	value |= LCDC_MKBF(LCDFRMCFG_LINEVAL, info->var.yres - 1);
+	lcdc_writel(sinfo, LCDFRMCFG, value);
+
+	/* FIFO Threshold: Use formula from data sheet */
+	value = SIDSAFB_FIFO_SIZE - (2 * SIDSAFB_DMA_BURST_LEN + 3);
+	lcdc_writel(sinfo, LCDFIFO, value);
+
+	/* Toggle LCD_MODE every frame */
+	lcdc_writel(sinfo, LCDMVAL, 0);
+
+	/* Disable all interrupts */
+	lcdc_writel(sinfo, LCD_IDR, ~0UL);
+
+	/* Wait for the LCDC core to become idle and enable it */
+	while(lcdc_readl(sinfo, PWRCON) & LCDC_BIT(PWRCON_LCD_BUSY))
+		msleep(10);
+
+	pr_debug("  * re-enable LCD core\n");
+	lcdc_writel(sinfo, PWRCON,
+		    LCDC_MKBF(PWRCON_GUARD_TIME, sinfo->guard_time)
+		    | LCDC_BIT(PWRCON_LCD_PWR));
+
+	pr_debug("  * DONE\n");
+	return 0;
+}
+
+static inline u_int chan_to_field(u_int chan, const struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+/**
+ *  	sidsafb_setcolreg - Optional function. Sets a color register.
+ *      @regno: Which register in the CLUT we are programming
+ *      @red: The red value which can be up to 16 bits wide
+ *	@green: The green value which can be up to 16 bits wide
+ *	@blue:  The blue value which can be up to 16 bits wide.
+ *	@transp: If supported the alpha value which can be up to 16 bits wide.
+ *      @info: frame buffer info structure
+ *
+ *  	Set a single color register. The values supplied have a 16 bit
+ *  	magnitude which needs to be scaled in this function for the hardware.
+ *	Things to take into consideration are how many color registers, if
+ *	any, are supported with the current color visual. With truecolor mode
+ *	no color palettes are supported. Here a psuedo palette is created
+ *	which we store the value in pseudo_palette in struct fb_info. For
+ *	pseudocolor mode we have a limited color palette. To deal with this
+ *	we can program what color is displayed for a particular pixel value.
+ *	DirectColor is similar in that we can program each color field. If
+ *	we have a static colormap we don't need to implement this function.
+ *
+ *	Returns negative errno on error, or zero on success. In an
+ *	ideal world, this would have been the case, but as it turns
+ *	out, the other drivers return 1 on failure, so that's what
+ *	we're going to do.
+ */
+static int sidsafb_setcolreg(unsigned int regno, unsigned int red,
+			     unsigned int green, unsigned int blue,
+			     unsigned int transp, struct fb_info *info)
+{
+	struct sidsafb_info *sinfo = info->par;
+	unsigned int val;
+	u32 *pal;
+	int ret = 1;
+
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green
+				      + 7471 * blue) >> 16;
+
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		if (regno < 16) {
+			pal = info->pseudo_palette;
+
+			val  = chan_to_field(red, &info->var.red);
+			val |= chan_to_field(green, &info->var.green);
+			val |= chan_to_field(blue, &info->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < 256) {
+			val  = ((red   >> 11) & 0x001f);
+			val |= ((green >>  6) & 0x03e0);
+			val |= ((blue  >>  1) & 0x7c00);
+
+			/*
+			 * TODO: intensity bit. Maybe something like
+			 *   ~(red[10] ^ green[10] ^ blue[10]) & 1
+			 */
+
+			lcdc_writel(sinfo, LUT + regno * 4, val);
+			ret = 0;
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static int sidsafb_pan_display(struct fb_var_screeninfo *var,
+			       struct fb_info *info)
+{
+	struct sidsafb_info *sinfo = info->par;
+
+	pr_debug("sidsafb_pan_display\n");
+
+	sidsafb_update_dma(info, var);
+
+	if (sinfo->wait_for_vsync) {
+		spin_lock_irq(&sinfo->lock);
+		lcdc_writel(sinfo, LCD_ICR, LCDC_BIT(LCD_ICR_EOFIC));
+		lcdc_writel(sinfo, LCD_IER, LCDC_BIT(LCD_IER_EOFIE));
+		init_completion(&sinfo->vsync_complete);
+		lcdc_readl(sinfo, LCD_IMR);
+		spin_unlock_irq(&sinfo->lock);
+
+		wait_for_completion(&sinfo->vsync_complete);
+
+		lcdc_writel(sinfo, LCD_IDR, LCDC_BIT(LCD_IDR_EOFID));
+	}
+
+	return 0;
+}
+
+static struct fb_ops sidsafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= sidsafb_check_var,
+	.fb_set_par	= sidsafb_set_par,
+	.fb_setcolreg	= sidsafb_setcolreg,
+	.fb_pan_display	= sidsafb_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+};
+
+static irqreturn_t sidsafb_interrupt(int irq, void *dev_id)
+{
+	struct fb_info *info = dev_id;
+	struct sidsafb_info *sinfo = info->par;
+	u32 status;
+
+	status = lcdc_readl(sinfo, LCD_ISR);
+	while (status) {
+		if (status & LCDC_BIT(LCD_ISR_EOFIS)) {
+			pr_debug("sidsafb: DMA End Of Frame interrupt\n");
+
+			lcdc_writel(sinfo, LCD_ICR, LCDC_BIT(LCD_ICR_EOFIC));
+			status &= ~LCDC_BIT(LCD_ISR_EOFIS);
+			complete(&sinfo->vsync_complete);
+		}
+
+		if (status) {
+			printk(KERN_ERR
+			       "LCDC: Interrupts still pending: 0x%x\n",
+			       status);
+			lcdc_writel(sinfo, LCD_IDR, status);
+		}
+
+		status = lcdc_readl(sinfo, LCD_ISR);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void __devinit init_pseudo_palette(u32 *palette)
+{
+	static const u32 init_palette[16] = {
+		0x000000,
+		0xaa0000,
+		0x00aa00,
+		0xaa5500,
+		0x0000aa,
+		0xaa00aa,
+		0x00aaaa,
+		0xaaaaaa,
+		0x555555,
+		0xff5555,
+		0x55ff55,
+		0xffff55,
+		0x5555ff,
+		0xff55ff,
+		0x55ffff,
+		0xffffff
+	};
+
+	memcpy(palette, init_palette, sizeof(init_palette));
+}
+
+static int __devinit sidsafb_set_fbinfo(struct sidsafb_info *sinfo)
+{
+	struct fb_info *info = sinfo->info;
+
+	init_pseudo_palette(sinfo->pseudo_palette);
+
+	info->flags		= (FBINFO_DEFAULT
+				   | FBINFO_PARTIAL_PAN_OK
+				   | FBINFO_HWACCEL_XPAN
+				   | FBINFO_HWACCEL_YPAN);
+	memcpy(&info->fix, &sidsafb_fix, sizeof(info->fix));
+	memcpy(&info->monspecs, &default_monspecs, sizeof(info->monspecs));
+	info->fbops		= &sidsafb_ops;
+	info->pseudo_palette	= sinfo->pseudo_palette;
+
+	return 0;
+}
+
+static int __devinit sidsafb_probe(struct platform_device *pdev)
+{
+	struct lcdc_platform_data *fb_data = pdev->dev.platform_data;
+	struct fb_info *info;
+	struct sidsafb_info *sinfo;
+	const struct resource *mmio_resource;
+	int ret;
+
+	pr_debug("sidsafb_probe BEGIN\n");
+
+	mmio_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mmio_resource) {
+		dev_err(&pdev->dev, "no MMIO resource found\n");
+		return -ENXIO;
+	}
+
+	ret = -ENOMEM;
+	info = framebuffer_alloc(sizeof(struct sidsafb_info), &pdev->dev);
+	if (!info) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		goto out;
+	}
+
+	sinfo = info->par;
+	sinfo->info = info;
+	sinfo->pdev = pdev;
+	sinfo->guard_time = 1;
+
+	spin_lock_init(&sinfo->lock);
+	sidsafb_set_fbinfo(sinfo);
+	info->fix.mmio_start = mmio_resource->start;
+	info->fix.mmio_len = mmio_resource->end - mmio_resource->start + 1;
+	sinfo->irq_base = platform_get_irq(pdev, 0);
+
+	sinfo->hclk = clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(sinfo->hclk)) {
+		dev_err(&pdev->dev, "failed to get hclk\n");
+		ret = PTR_ERR(sinfo->hclk);
+		goto free_info;
+	}
+	sinfo->pixclk = clk_get(&pdev->dev, "pixclk");
+	if (IS_ERR(sinfo->pixclk)) {
+		dev_err(&pdev->dev, "failed to get pixel clock\n");
+		ret = PTR_ERR(sinfo->hclk);
+		goto put_hclk;
+	}
+
+	clk_enable(sinfo->hclk);
+	clk_enable(sinfo->pixclk);
+
+	/* Use platform-supplied framebuffer memory if available */
+	if (fb_data && fb_data->fbmem_size != 0) {
+		info->fix.smem_start = fb_data->fbmem_start;
+		info->fix.smem_len = fb_data->fbmem_size;
+		info->screen_base = ioremap(info->fix.smem_start,
+					    info->fix.smem_len);
+	} else {
+		dma_addr_t paddr;
+
+		info->fix.smem_len = fb_size;
+		info->screen_base = dma_alloc_coherent(&pdev->dev, fb_size,
+						       &paddr, GFP_KERNEL);
+		info->fix.smem_start = paddr;
+	}
+
+	if (!info->screen_base) {
+		printk(KERN_ERR "sidsafb: Could not allocate framebuffer\n");
+		goto disable_clocks;
+	}
+
+	sinfo->regs = ioremap(info->fix.mmio_start, info->fix.mmio_len);
+	if (!sinfo->regs) {
+		printk(KERN_ERR "sidsafb: Could not map LCDC registers\n");
+		goto free_fb;
+	}
+
+	ret = fb_find_mode(&info->var, info, NULL, info->monspecs.modedb,
+			   info->monspecs.modedb_len, info->monspecs.modedb,
+			   CONFIG_FB_SIDSA_DEFAULT_BPP);
+	if (!ret) {
+		printk(KERN_ERR "sidsafb: No suitable video mode found\n");
+		goto unmap_regs;
+	}
+
+	ret = request_irq(sinfo->irq_base, sidsafb_interrupt, 0,
+			  "sidsafb", info);
+	if (ret)
+		goto unmap_regs;
+
+	/* Allocate colormap */
+	if (fb_alloc_cmap(&info->cmap, 256, 0)) {
+		ret = -ENOMEM;
+		goto unregister_irqs;
+	}
+
+	platform_set_drvdata(pdev, info);
+	ret = device_create_file(&pdev->dev, &dev_attr_vsync_pan);
+	if (ret)
+		goto free_cmap;
+
+	/*
+	 * Tell the world that we're ready to go
+	 */
+	ret = register_framebuffer(info);
+	if (ret)
+		goto remove_attrs;
+
+	printk("fb%d: Atmel LCDC at 0x%08lx (mapped at %p), irq %lu\n",
+	       info->node, info->fix.mmio_start, sinfo->regs, sinfo->irq_base);
+
+	memset_io(info->screen_base, 0, info->fix.smem_len);
+	info->var.activate |= FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;
+	ret = fb_set_var(info, &info->var);
+	if (ret)
+		printk(KERN_WARNING
+		       "sidsafb: Unable to set display parameters\n");
+	info->var.activate &= ~(FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW);
+
+	pr_debug("sidsafb_probe SUCCESS\n");
+	return 0;
+
+
+remove_attrs:
+	device_remove_file(&pdev->dev, &dev_attr_vsync_pan);
+free_cmap:
+	fb_dealloc_cmap(&info->cmap);
+unregister_irqs:
+	free_irq(sinfo->irq_base, info);
+unmap_regs:
+	iounmap(sinfo->regs);
+free_fb:
+	if (!fb_data || fb_data->fbmem_size == 0)
+		dma_free_coherent(&pdev->dev, info->fix.smem_len,
+				  (void __force *)info->screen_base,
+				  info->fix.smem_start);
+disable_clocks:
+	clk_disable(sinfo->pixclk);
+	clk_disable(sinfo->hclk);
+	clk_put(sinfo->pixclk);
+put_hclk:
+	clk_put(sinfo->hclk);
+free_info:
+	framebuffer_release(info);
+out:
+	pr_debug("sidsafb_probe FAILED\n");
+	return ret;
+}
+
+static int __devexit sidsafb_remove(struct platform_device *pdev)
+{
+	struct lcdc_platform_data *fb_data = pdev->dev.platform_data;
+	struct fb_info *info = platform_get_drvdata(pdev);
+	struct sidsafb_info *sinfo;
+
+	if (!info)
+		return 0;
+	sinfo = info->par;
+
+	/* TODO: Restore original state */
+	unregister_framebuffer(info);
+
+	device_remove_file(&pdev->dev, &dev_attr_vsync_pan);
+
+	fb_dealloc_cmap(&info->cmap);
+	free_irq(sinfo->irq_base, info);
+	iounmap(sinfo->regs);
+	if (!fb_data || fb_data->fbmem_size == 0)
+		dma_free_coherent(&pdev->dev, info->fix.smem_len,
+				  (void __force *)info->screen_base,
+				  info->fix.smem_start);
+	clk_disable(sinfo->hclk);
+	clk_put(sinfo->hclk);
+	platform_set_drvdata(pdev, NULL);
+	framebuffer_release(info);
+
+	return 0;
+}
+
+static struct platform_driver sidsafb_driver = {
+	.probe		= sidsafb_probe,
+	.remove		= __devexit_p(sidsafb_remove),
+	.driver		= {
+		.name		= "lcdc",
+	},
+};
+
+int __init sidsafb_init(void)
+{
+	return platform_driver_register(&sidsafb_driver);
+}
+
+static void __exit sidsafb_exit(void)
+{
+	platform_driver_unregister(&sidsafb_driver);
+}
+
+module_init(sidsafb_init);
+module_exit(sidsafb_exit);
+
+module_param(fb_size, ulong, 0644);
+MODULE_PARM_DESC(fb_size, "Minimum framebuffer size to allocate");
+
+MODULE_AUTHOR("Haavard Skinnemoen <hskinnemoen@atmel.com>");
+MODULE_DESCRIPTION("Atmel/SIDSA LCD Controller framebuffer driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.19-avr1/include/asm-avr32/periph/lcdc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/include/asm-avr32/periph/lcdc.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,271 @@
+/*
+ * Register definitions for Atmel/SIDSA LCD Controller
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_AVR32_PERIPH_LCDC_H__
+#define __ASM_AVR32_PERIPH_LCDC_H__
+
+#define LCDC_CONTRAST_CTR                       0x00000840
+# define LCDC_CONTRAST_CTR_ENA_OFFSET           3
+# define LCDC_CONTRAST_CTR_ENA_SIZE             1
+# define LCDC_CONTRAST_CTR_POL_OFFSET           2
+# define LCDC_CONTRAST_CTR_POL_SIZE             1
+# define LCDC_CONTRAST_CTR_PS_OFFSET            0
+# define LCDC_CONTRAST_CTR_PS_SIZE              2
+#define LCDC_CONTRAST_VAL                       0x00000844
+# define LCDC_CONTRAST_VAL_CVAL_OFFSET          0
+# define LCDC_CONTRAST_VAL_CVAL_SIZE            8
+#define LCDC_DMABADDR1                          0x00000000
+# define LCDC_DMABADDR1_BADDR_U_OFFSET          0
+# define LCDC_DMABADDR1_BADDR_U_SIZE            32
+#define LCDC_DMABADDR2                          0x00000004
+# define LCDC_DMABADDR2_BADDR_L_OFFSET          0
+# define LCDC_DMABADDR2_BADDR_L_SIZE            32
+#define LCDC_DMACON                             0x0000001C
+# define LCDC_DMACON_DMABUSY_OFFSET             2
+# define LCDC_DMACON_DMABUSY_SIZE               1
+# define LCDC_DMACON_DMAEN_OFFSET               0
+# define LCDC_DMACON_DMAEN_SIZE                 1
+# define LCDC_DMACON_DMARST_OFFSET              1
+# define LCDC_DMACON_DMARST_SIZE                1
+# define LCDC_DMACON_DMAUPDT_OFFSET             3
+# define LCDC_DMACON_DMAUPDT_SIZE               1
+# define LCDC_DMACON_DMA2DEN_OFFSET             4
+# define LCDC_DMACON_DMA2DEN_SIZE               1
+#define LCDC_DMAFRMADD1                         0x00000010
+# define LCDC_DMAFRMADD1_FRMADD_U_OFFSET        0
+# define LCDC_DMAFRMADD1_FRMADD_U_SIZE          32
+#define LCDC_DMAFRMADD2                         0x00000014
+# define LCDC_DMAFRMADD2_FRMADD_L_OFFSET        0
+# define LCDC_DMAFRMADD2_FRMADD_L_SIZE          32
+#define LCDC_DMAFRMCFG                          0x00000018
+# define LCDC_DMAFRMCFG_BRSTLEN_OFFSET          24
+# define LCDC_DMAFRMCFG_BRSTLEN_SIZE            7
+# define LCDC_DMAFRMCFG_FRMSIZE_OFFSET          0
+# define LCDC_DMAFRMCFG_FRMSIZE_SIZE            23
+#define LCDC_DMAFRMPT1                          0x00000008
+# define LCDC_DMAFRMPT1_FRMPT_U_OFFSET          0
+# define LCDC_DMAFRMPT1_FRMPT_U_SIZE            23
+#define LCDC_DMAFRMPT2                          0x0000000C
+# define LCDC_DMAFRMPT2_FRMPT_L_OFFSET          0
+# define LCDC_DMAFRMPT2_FRMPT_L_SIZE            23
+#define LCDC_DMA2DCFG                           0x00000020
+# define LCDC_DMA2DCFG_ADDRINC_OFFSET           0
+# define LCDC_DMA2DCFG_ADDRINC_SIZE             16
+# define LCDC_DMA2DCFG_PIXELOFF_OFFSET          24
+# define LCDC_DMA2DCFG_PIXELOFF_SIZE            5
+#define LCDC_DP1_2                              0x0000081C
+# define LCDC_DP1_2_DP1_2_OFFSET                0
+# define LCDC_DP1_2_DP1_2_SIZE                  8
+#define LCDC_DP2_3                              0x00000828
+# define LCDC_DP2_3_DP2_3_OFFSET                0
+# define LCDC_DP2_3_DP2_3_SIZE                  12
+#define LCDC_DP3_4                              0x00000830
+# define LCDC_DP3_4_DP3_4_OFFSET                0
+# define LCDC_DP3_4_DP3_4_SIZE                  16
+#define LCDC_DP3_5                              0x00000824
+# define LCDC_DP3_5_DP3_5_OFFSET                0
+# define LCDC_DP3_5_DP3_5_SIZE                  20
+#define LCDC_DP4_5                              0x00000834
+# define LCDC_DP4_5_DP4_5_OFFSET                0
+# define LCDC_DP4_5_DP4_5_SIZE                  20
+#define LCDC_DP4_7                              0x00000820
+# define LCDC_DP4_7_DP4_7_OFFSET                0
+# define LCDC_DP4_7_DP4_7_SIZE                  28
+#define LCDC_DP5_7                              0x0000082C
+# define LCDC_DP5_7_DP5_7_OFFSET                0
+# define LCDC_DP5_7_DP5_7_SIZE                  28
+#define LCDC_DP6_7                              0x00000838
+# define LCDC_DP6_7_DP6_7_OFFSET                0
+# define LCDC_DP6_7_DP6_7_SIZE                  28
+#define LCDC_LCDCON1                            0x00000800
+# define LCDC_LCDCON1_BYPASS_OFFSET             0
+# define LCDC_LCDCON1_BYPASS_SIZE               1
+# define LCDC_LCDCON1_CLKVAL_OFFSET             12
+# define LCDC_LCDCON1_CLKVAL_SIZE               9
+# define LCDC_LCDCON1_LINECNT_OFFSET            21
+# define LCDC_LCDCON1_LINECNT_SIZE              11
+#define LCDC_LCDCON2                            0x00000804
+# define LCDC_LCDCON2_CLKMOD_OFFSET             15
+# define LCDC_LCDCON2_CLKMOD_SIZE               1
+# define LCDC_LCDCON2_DISTYPE_OFFSET            0
+# define LCDC_LCDCON2_DISTYPE_SIZE              2
+# define LCDC_LCDCON2_IFWIDTH_OFFSET            3
+# define LCDC_LCDCON2_IFWIDTH_SIZE              2
+# define LCDC_LCDCON2_INVCLK_OFFSET             11
+# define LCDC_LCDCON2_INVCLK_SIZE               1
+# define LCDC_LCDCON2_INVDVAL_OFFSET            12
+# define LCDC_LCDCON2_INVDVAL_SIZE              1
+# define LCDC_LCDCON2_INVFRAME_OFFSET           9
+# define LCDC_LCDCON2_INVFRAME_SIZE             1
+# define LCDC_LCDCON2_INVLINE_OFFSET            10
+# define LCDC_LCDCON2_INVLINE_SIZE              1
+# define LCDC_LCDCON2_INVVD_OFFSET              8
+# define LCDC_LCDCON2_INVVD_SIZE                1
+# define LCDC_LCDCON2_MEMOR_OFFSET              30
+# define LCDC_LCDCON2_MEMOR_SIZE                2
+# define LCDC_LCDCON2_PIXELSIZE_OFFSET          5
+# define LCDC_LCDCON2_PIXELSIZE_SIZE            3
+# define LCDC_LCDCON2_SCANMOD_OFFSET            2
+# define LCDC_LCDCON2_SCANMOD_SIZE              1
+#define LCDC_LCDFIFO                            0x00000814
+# define LCDC_LCDFIFO_FIFOTH_OFFSET             0
+# define LCDC_LCDFIFO_FIFOTH_SIZE               16
+#define LCDC_LCDFRMCFG                          0x00000810
+# define LCDC_LCDFRMCFG_LINESIZE_OFFSET         21
+# define LCDC_LCDFRMCFG_LINESIZE_SIZE           11
+# define LCDC_LCDFRMCFG_LINEVAL_OFFSET          0
+# define LCDC_LCDFRMCFG_LINEVAL_SIZE            11
+#define LCDC_LCDMVAL                            0x00000818
+# define LCDC_LCDMVAL_MMODE_OFFSET              31
+# define LCDC_LCDMVAL_MMODE_SIZE                1
+# define LCDC_LCDMVAL_MVAL_OFFSET               0
+# define LCDC_LCDMVAL_MVAL_SIZE                 8
+#define LCDC_LCDTIM1                            0x00000808
+# define LCDC_LCDTIM1_VBP_OFFSET                8
+# define LCDC_LCDTIM1_VBP_SIZE                  8
+# define LCDC_LCDTIM1_VFP_OFFSET                0
+# define LCDC_LCDTIM1_VFP_SIZE                  8
+# define LCDC_LCDTIM1_VHDLY_OFFSET              24
+# define LCDC_LCDTIM1_VHDLY_SIZE                4
+# define LCDC_LCDTIM1_VPW_OFFSET                16
+# define LCDC_LCDTIM1_VPW_SIZE                  6
+#define LCDC_LCDTIM2                            0x0000080C
+# define LCDC_LCDTIM2_HBP_OFFSET                0
+# define LCDC_LCDTIM2_HBP_SIZE                  8
+# define LCDC_LCDTIM2_HFP_OFFSET                21
+# define LCDC_LCDTIM2_HFP_SIZE                  11
+# define LCDC_LCDTIM2_HPW_OFFSET                8
+# define LCDC_LCDTIM2_HPW_SIZE                  6
+#define LCDC_LCD_GPR                            0x0000085C
+# define LCDC_LCD_GPR_GPRB0_OFFSET              0
+# define LCDC_LCD_GPR_GPRB0_SIZE                1
+# define LCDC_LCD_GPR_GPRB1_OFFSET              1
+# define LCDC_LCD_GPR_GPRB1_SIZE                1
+# define LCDC_LCD_GPR_GPRB2_OFFSET              2
+# define LCDC_LCD_GPR_GPRB2_SIZE                1
+# define LCDC_LCD_GPR_GPRB3_OFFSET              3
+# define LCDC_LCD_GPR_GPRB3_SIZE                1
+# define LCDC_LCD_GPR_GPRB4_OFFSET              4
+# define LCDC_LCD_GPR_GPRB4_SIZE                1
+# define LCDC_LCD_GPR_GPRB5_OFFSET              5
+# define LCDC_LCD_GPR_GPRB5_SIZE                1
+# define LCDC_LCD_GPR_GPRB6_OFFSET              6
+# define LCDC_LCD_GPR_GPRB6_SIZE                1
+# define LCDC_LCD_GPR_GPRB7_OFFSET              7
+# define LCDC_LCD_GPR_GPRB7_SIZE                1
+#define LCDC_LCD_ICR                            0x00000858
+# define LCDC_LCD_ICR_EOFIC_OFFSET              2
+# define LCDC_LCD_ICR_EOFIC_SIZE                1
+# define LCDC_LCD_ICR_LNIC_OFFSET               0
+# define LCDC_LCD_ICR_LNIC_SIZE                 1
+# define LCDC_LCD_ICR_LSTLNIC_OFFSET            1
+# define LCDC_LCD_ICR_LSTLNIC_SIZE              1
+# define LCDC_LCD_ICR_MERIC_OFFSET              6
+# define LCDC_LCD_ICR_MERIC_SIZE                1
+# define LCDC_LCD_ICR_OWRIC_OFFSET              5
+# define LCDC_LCD_ICR_OWRIC_SIZE                1
+# define LCDC_LCD_ICR_UFLWIC_OFFSET             4
+# define LCDC_LCD_ICR_UFLWIC_SIZE               1
+#define LCDC_LCD_IDR                            0x0000084C
+# define LCDC_LCD_IDR_EOFID_OFFSET              2
+# define LCDC_LCD_IDR_EOFID_SIZE                1
+# define LCDC_LCD_IDR_LNID_OFFSET               0
+# define LCDC_LCD_IDR_LNID_SIZE                 1
+# define LCDC_LCD_IDR_LSTLNID_OFFSET            1
+# define LCDC_LCD_IDR_LSTLNID_SIZE              1
+# define LCDC_LCD_IDR_MERID_OFFSET              6
+# define LCDC_LCD_IDR_MERID_SIZE                1
+# define LCDC_LCD_IDR_OWRID_OFFSET              5
+# define LCDC_LCD_IDR_OWRID_SIZE                1
+# define LCDC_LCD_IDR_UFLWID_OFFSET             4
+# define LCDC_LCD_IDR_UFLWID_SIZE               1
+#define LCDC_LCD_IER                            0x00000848
+# define LCDC_LCD_IER_EOFIE_OFFSET              2
+# define LCDC_LCD_IER_EOFIE_SIZE                1
+# define LCDC_LCD_IER_LNIE_OFFSET               0
+# define LCDC_LCD_IER_LNIE_SIZE                 1
+# define LCDC_LCD_IER_LSTLNIE_OFFSET            1
+# define LCDC_LCD_IER_LSTLNIE_SIZE              1
+# define LCDC_LCD_IER_MERIE_OFFSET              6
+# define LCDC_LCD_IER_MERIE_SIZE                1
+# define LCDC_LCD_IER_OWRIE_OFFSET              5
+# define LCDC_LCD_IER_OWRIE_SIZE                1
+# define LCDC_LCD_IER_UFLWIE_OFFSET             4
+# define LCDC_LCD_IER_UFLWIE_SIZE               1
+#define LCDC_LCD_IMR                            0x00000850
+# define LCDC_LCD_IMR_EOFIM_OFFSET              2
+# define LCDC_LCD_IMR_EOFIM_SIZE                1
+# define LCDC_LCD_IMR_LNIM_OFFSET               0
+# define LCDC_LCD_IMR_LNIM_SIZE                 1
+# define LCDC_LCD_IMR_LSTLNIM_OFFSET            1
+# define LCDC_LCD_IMR_LSTLNIM_SIZE              1
+# define LCDC_LCD_IMR_MERIM_OFFSET              6
+# define LCDC_LCD_IMR_MERIM_SIZE                1
+# define LCDC_LCD_IMR_OWRIM_OFFSET              5
+# define LCDC_LCD_IMR_OWRIM_SIZE                1
+# define LCDC_LCD_IMR_UFLWIM_OFFSET             4
+# define LCDC_LCD_IMR_UFLWIM_SIZE               1
+#define LCDC_LCD_IRR                            0x00000864
+# define LCDC_LCD_IRR_EOFIR_OFFSET              2
+# define LCDC_LCD_IRR_EOFIR_SIZE                1
+# define LCDC_LCD_IRR_LNIR_OFFSET               0
+# define LCDC_LCD_IRR_LNIR_SIZE                 1
+# define LCDC_LCD_IRR_LSTLNIR_OFFSET            1
+# define LCDC_LCD_IRR_LSTLNIR_SIZE              1
+# define LCDC_LCD_IRR_MERIR_OFFSET              6
+# define LCDC_LCD_IRR_MERIR_SIZE                1
+# define LCDC_LCD_IRR_OWRIR_OFFSET              5
+# define LCDC_LCD_IRR_OWRIR_SIZE                1
+# define LCDC_LCD_IRR_UFLWIR_OFFSET             4
+# define LCDC_LCD_IRR_UFLWIR_SIZE               1
+#define LCDC_LCD_ISR                            0x00000854
+# define LCDC_LCD_ISR_EOFIS_OFFSET              2
+# define LCDC_LCD_ISR_EOFIS_SIZE                1
+# define LCDC_LCD_ISR_LNIS_OFFSET               0
+# define LCDC_LCD_ISR_LNIS_SIZE                 1
+# define LCDC_LCD_ISR_LSTLNIS_OFFSET            1
+# define LCDC_LCD_ISR_LSTLNIS_SIZE              1
+# define LCDC_LCD_ISR_MERIS_OFFSET              6
+# define LCDC_LCD_ISR_MERIS_SIZE                1
+# define LCDC_LCD_ISR_OWRIS_OFFSET              5
+# define LCDC_LCD_ISR_OWRIS_SIZE                1
+# define LCDC_LCD_ISR_UFLWIS_OFFSET             4
+# define LCDC_LCD_ISR_UFLWIS_SIZE               1
+#define LCDC_LCD_ITR                            0x00000860
+# define LCDC_LCD_ITR_EOFIT_OFFSET              2
+# define LCDC_LCD_ITR_EOFIT_SIZE                1
+# define LCDC_LCD_ITR_LNIT_OFFSET               0
+# define LCDC_LCD_ITR_LNIT_SIZE                 1
+# define LCDC_LCD_ITR_LSTLNIT_OFFSET            1
+# define LCDC_LCD_ITR_LSTLNIT_SIZE              1
+# define LCDC_LCD_ITR_MERIT_OFFSET              6
+# define LCDC_LCD_ITR_MERIT_SIZE                1
+# define LCDC_LCD_ITR_OWRIT_OFFSET              5
+# define LCDC_LCD_ITR_OWRIT_SIZE                1
+# define LCDC_LCD_ITR_UFLWIT_OFFSET             4
+# define LCDC_LCD_ITR_UFLWIT_SIZE               1
+#define LCDC_PWRCON                             0x0000083C
+# define LCDC_PWRCON_GUARD_TIME_OFFSET          1
+# define LCDC_PWRCON_GUARD_TIME_SIZE            7
+# define LCDC_PWRCON_LCD_BUSY_OFFSET            31
+# define LCDC_PWRCON_LCD_BUSY_SIZE              1
+# define LCDC_PWRCON_LCD_PWR_OFFSET             0
+# define LCDC_PWRCON_LCD_PWR_SIZE               1
+
+#define LCDC_BIT(name)                          (1 << LCDC_##name##_OFFSET)
+#define LCDC_MKBF(name,value)                   (((value) & ((1 << LCDC_##name##_SIZE) - 1)) << LCDC_##name##_OFFSET)
+#define LCDC_GETBF(name,value)                  (((value) >> LCDC_##name##_OFFSET) & ((1 << LCDC_##name##_SIZE) - 1))
+#define LCDC_INSBF(name,value,old)              (((old) & ~(((1 << LCDC_##name##_SIZE) - 1) << LCDC_##name##_OFFSET)) | LCDC_MKBF(name, value))
+
+#define lcdc_readl(port,reg)				\
+	__raw_readl((port)->regs + LCDC_##reg)
+#define lcdc_writel(port,reg,value)			\
+	__raw_writel((value), (port)->regs + LCDC_##reg)
+
+#endif /* __ASM_AVR32_PERIPH_LCDC_H__ */
Index: linux-2.6.19-avr1/include/linux/fb.h
===================================================================
--- linux-2.6.19-avr1.orig/include/linux/fb.h	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/include/linux/fb.h	2006-12-03 19:23:23.000000000 +0100
@@ -192,6 +192,7 @@ struct fb_bitfield {
 					/* vtotal = 144d/288n/576i => PAL  */
 					/* vtotal = 121d/242n/484i => NTSC */
 #define FB_SYNC_ON_GREEN	32	/* sync on green */
+#define FB_SYNC_PCLK_RISING	64	/* pixel data sampled on rising pclk */
 
 #define FB_VMODE_NONINTERLACED  0	/* non interlaced */
 #define FB_VMODE_INTERLACED	1	/* interlaced	*/
@@ -827,7 +828,7 @@ struct fb_info {
 #define fb_writeq sbus_writeq
 #define fb_memset sbus_memset_io
 
-#elif defined(__i386__) || defined(__alpha__) || defined(__x86_64__) || defined(__hppa__) || (defined(__sh__) && !defined(__SH5__)) || defined(__powerpc__)
+#elif defined(__i386__) || defined(__alpha__) || defined(__x86_64__) || defined(__hppa__) || (defined(__sh__) && !defined(__SH5__)) || defined(__powerpc__) || defined(__avr32__)
 
 #define fb_readb __raw_readb
 #define fb_readw __raw_readw
Index: linux-2.6.19-avr1/drivers/video/backlight/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/drivers/video/backlight/Kconfig	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/video/backlight/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -42,6 +42,18 @@ config LCD_DEVICE
 	depends on LCD_CLASS_DEVICE
 	default y
 
+config LCD_LTV350QV
+	tristate "Samsung LTV350QV LCD Panel"
+	depends on LCD_DEVICE && SPI
+	default n
+	help
+	  If you have a Samsung LTV350QV LCD panel, say y to include a
+	  power control driver for it.  The panel starts up in power
+	  off state, so you need this driver in order to see any
+	  output.
+
+	  The LTV350QV panel is present on most ATSTK1000 boards.
+
 config BACKLIGHT_CORGI
 	tristate "Sharp Corgi Backlight Driver (SL Series)"
 	depends on BACKLIGHT_DEVICE && PXA_SHARPSL
Index: linux-2.6.19-avr1/drivers/video/backlight/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/drivers/video/backlight/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/video/backlight/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -5,3 +5,4 @@ obj-$(CONFIG_BACKLIGHT_CLASS_DEVICE) += 
 obj-$(CONFIG_BACKLIGHT_CORGI)	+= corgi_bl.o
 obj-$(CONFIG_BACKLIGHT_HP680)	+= hp680_bl.o
 obj-$(CONFIG_BACKLIGHT_LOCOMO)	+= locomolcd.o
+obj-$(CONFIG_LCD_LTV350QV)	+= ltv350qv.o
Index: linux-2.6.19-avr1/drivers/video/backlight/ltv350qv.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/video/backlight/ltv350qv.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,300 @@
+/*
+ * Power control for Samsung LTV350QV Quarter VGA LCD Panel
+ *
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/lcd.h>
+#include <linux/module.h>
+#include <linux/reboot.h>
+#include <linux/spi/spi.h>
+
+#define POWER_IS_ON(pwr)	((pwr) <= FB_BLANK_NORMAL)
+
+struct ltv350qv {
+	struct spi_device *spi;
+	u8 *buffer;
+	int power;
+	struct semaphore lock;
+	struct lcd_device *ld;
+	struct list_head list;
+	int halt_done;
+};
+
+static LIST_HEAD(lcd_list);
+
+static int ltv350qv_write_reg(struct ltv350qv *lcd, u8 reg, u16 val)
+{
+	struct spi_message msg;
+	struct spi_transfer index_xfer = {
+		.len		= 3,
+		.cs_change	= 1,
+	};
+	struct spi_transfer value_xfer = {
+		.len		= 3,
+		.cs_change	= 1,
+	};
+
+	spi_message_init(&msg);
+
+	/* register index */
+	lcd->buffer[0] = 0x74;
+	lcd->buffer[1] = 0x00;
+	lcd->buffer[2] = reg & 0x7f;
+	index_xfer.tx_buf = lcd->buffer;
+	spi_message_add_tail(&index_xfer, &msg);
+
+	/* register value */
+	lcd->buffer[4] = 0x76;
+	lcd->buffer[5] = val >> 8;
+	lcd->buffer[6] = val;
+	value_xfer.tx_buf = lcd->buffer + 4;
+	spi_message_add_tail(&value_xfer, &msg);
+
+	return spi_sync(lcd->spi, &msg);
+}
+
+#define write_reg(_spi, reg, val)				\
+	do {							\
+		ret = ltv350qv_write_reg(_spi, reg, val);	\
+		if (ret)					\
+			goto out;				\
+	} while (0)
+
+static int ltv350qv_power_on(struct ltv350qv *lcd)
+{
+	int ret;
+
+	write_reg(lcd,  9, 0x0000);
+	msleep(15);
+	write_reg(lcd,  9, 0x4000);
+	write_reg(lcd, 10, 0x2000);
+	write_reg(lcd,  9, 0x4055);
+	msleep(55);
+	write_reg(lcd,  1, 0x409d);
+	write_reg(lcd,  2, 0x0204);
+	write_reg(lcd,  3, 0x0100);
+	write_reg(lcd,  4, 0x3000);
+	write_reg(lcd,  5, 0x4003);
+	write_reg(lcd,  6, 0x000a);
+	write_reg(lcd,  7, 0x0021);
+	write_reg(lcd,  8, 0x0c00);
+	write_reg(lcd, 10, 0x0103);
+	write_reg(lcd, 11, 0x0301);
+	write_reg(lcd, 12, 0x1f0f);
+	write_reg(lcd, 13, 0x1f0f);
+	write_reg(lcd, 14, 0x0707);
+	write_reg(lcd, 15, 0x0307);
+	write_reg(lcd, 16, 0x0707);
+	write_reg(lcd, 17, 0x0000);
+	write_reg(lcd, 18, 0x0004);
+	write_reg(lcd, 19, 0x0000);
+
+	msleep(20);
+	write_reg(lcd,  9, 0x4a55);
+	write_reg(lcd,  5, 0x5003);
+
+out:
+	return ret;
+}
+
+static int ltv350qv_power_off(struct ltv350qv *lcd)
+{
+	int ret;
+
+	/* GON -> 0, POC -> 0 */
+	write_reg(lcd,  9, 0x4055);
+	/* DSC -> 0 */
+	write_reg(lcd,  5, 0x4003);
+	/* VCOMG -> 0 */
+	write_reg(lcd, 10, 0x2103);
+
+	msleep(1);
+
+	/* AP[2:0] -> 000 */
+	write_reg(lcd,  9, 0x4050);
+
+out:
+	return ret;
+}
+
+static int ltv350qv_power(struct ltv350qv *lcd, int power)
+{
+	int ret = 0;
+
+	down(&lcd->lock);
+
+	if (POWER_IS_ON(power) && !POWER_IS_ON(lcd->power))
+		ret = ltv350qv_power_on(lcd);
+	else if (!POWER_IS_ON(power) && POWER_IS_ON(lcd->power))
+		ret = ltv350qv_power_off(lcd);
+
+	if (!ret)
+		lcd->power = power;
+
+	up(&lcd->lock);
+
+	return ret;
+}
+
+static int ltv350qv_set_power(struct lcd_device *ld, int power)
+{
+	struct ltv350qv *lcd;
+
+	lcd = class_get_devdata(&ld->class_dev);
+	return ltv350qv_power(lcd, power);
+}
+
+static int ltv350qv_get_power(struct lcd_device *ld)
+{
+	struct ltv350qv *lcd;
+
+	lcd = class_get_devdata(&ld->class_dev);
+	return lcd->power;
+}
+
+static struct lcd_properties lcd_properties = {
+	.owner		= THIS_MODULE,
+	.get_power	= ltv350qv_get_power,
+	.set_power	= ltv350qv_set_power,
+};
+
+static int __devinit ltv350qv_probe(struct spi_device *spi)
+{
+	struct ltv350qv *lcd;
+	struct lcd_device *ld;
+	int ret;
+
+	lcd = kzalloc(sizeof(struct ltv350qv), GFP_KERNEL);
+	if (!lcd)
+		return -ENOMEM;
+
+	lcd->spi = spi;
+	lcd->power = FB_BLANK_POWERDOWN;
+	init_MUTEX(&lcd->lock);
+	lcd->buffer = kzalloc(8, GFP_KERNEL);
+
+	spi->mode = SPI_MODE_3;
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret)
+		goto out_free_lcd;
+
+	ld = lcd_device_register("ltv350qv", lcd, &lcd_properties);
+	if (IS_ERR(ld)) {
+		ret = PTR_ERR(ld);
+		goto out_free_lcd;
+	}
+	lcd->ld = ld;
+
+	list_add(&lcd->list, &lcd_list);
+
+	ret = ltv350qv_power(lcd, FB_BLANK_UNBLANK);
+	if (ret)
+		goto out_unregister;
+
+	dev_set_drvdata(&spi->dev, lcd);
+
+	return 0;
+
+out_unregister:
+	lcd_device_unregister(ld);
+out_free_lcd:
+	kfree(lcd);
+	return ret;
+}
+
+static int __devexit ltv350qv_remove(struct spi_device *spi)
+{
+	struct ltv350qv *lcd = dev_get_drvdata(&spi->dev);
+
+	ltv350qv_power(lcd, FB_BLANK_POWERDOWN);
+	list_del(&lcd->list);
+	lcd_device_unregister(lcd->ld);
+	kfree(lcd);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ltv350qv_suspend(struct spi_device *spi,
+			    pm_message_t state, u32 level)
+{
+	struct ltv350qv *lcd = dev_get_drvdata(&spi->dev);
+
+	if (level == SUSPEND_POWER_DOWN)
+		return ltv350qv_power(lcd, FB_BLANK_POWERDOWN);
+
+	return 0;
+}
+
+static int ltv350qv_resume(struct spi_device *spi, u32 level)
+{
+	struct ltv350qv *lcd = dev_get_drvdata(&spi->dev);
+
+	if (level == RESUME_POWER_ON)
+		return ltv350qv_power(lcd, FB_BLANK_UNBLANK);
+
+	return 0;
+}
+#else
+#define ltv350qv_suspend	NULL
+#define ltv350qv_resume		NULL
+#endif
+
+/* Power down all displays on reboot, poweroff or halt */
+static int ltv350qv_halt(struct notifier_block *nb, unsigned long event,
+			 void *p)
+{
+	struct ltv350qv *lcd;
+
+	list_for_each_entry(lcd, &lcd_list, list) {
+		if (!lcd->halt_done)
+			ltv350qv_power(lcd, FB_BLANK_POWERDOWN);
+		lcd->halt_done = 1;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct spi_driver ltv350qv_driver = {
+	.driver = {
+		.name		= "ltv350qv",
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+
+	.probe		= ltv350qv_probe,
+	.remove		= __devexit_p(ltv350qv_remove),
+	.suspend	= ltv350qv_suspend,
+	.resume		= ltv350qv_resume,
+};
+
+static struct notifier_block ltv350qv_notifier = {
+	.notifier_call	= ltv350qv_halt,
+};
+
+static int __init ltv350qv_init(void)
+{
+	register_reboot_notifier(&ltv350qv_notifier);
+	return spi_register_driver(&ltv350qv_driver);
+}
+
+static void __exit ltv350qv_exit(void)
+{
+	unregister_reboot_notifier(&ltv350qv_notifier);
+	spi_unregister_driver(&ltv350qv_driver);
+}
+module_init(ltv350qv_init);
+module_exit(ltv350qv_exit);
+
+MODULE_AUTHOR("Atmel Norway");
+MODULE_DESCRIPTION("Samsung LTV350QV LCD Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.19-avr1/drivers/usb/gadget/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/drivers/usb/gadget/Kconfig	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/usb/gadget/Kconfig	2006-12-03 19:23:23.000000000 +0100
@@ -154,6 +154,16 @@ config USB_LH7A40X
 	default USB_GADGET
 	select USB_GADGET_SELECTED
 
+config USB_GADGET_HUSB2DEV
+	boolean "Atmel HUSB2DEVICE"
+	select USB_GADGET_DUALSPEED
+	depends on AVR32
+
+config USB_HUSB2DEV
+	tristate
+	depends on USB_GADGET_HUSB2DEV
+	default USB_GADGET
+	select USB_GADGET_SELECTED
 
 config USB_GADGET_OMAP
 	boolean "OMAP USB Device Controller"
Index: linux-2.6.19-avr1/drivers/usb/gadget/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/drivers/usb/gadget/Makefile	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/usb/gadget/Makefile	2006-12-03 19:23:23.000000000 +0100
@@ -8,6 +8,7 @@ obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
 obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
 obj-$(CONFIG_USB_LH7A40X)	+= lh7a40x_udc.o
 obj-$(CONFIG_USB_AT91)		+= at91_udc.o
+obj-$(CONFIG_USB_HUSB2DEV)	+= husb2_udc.o
 
 #
 # USB gadget drivers
Index: linux-2.6.19-avr1/drivers/usb/gadget/gadget_chips.h
===================================================================
--- linux-2.6.19-avr1.orig/drivers/usb/gadget/gadget_chips.h	2006-12-03 19:23:20.000000000 +0100
+++ linux-2.6.19-avr1/drivers/usb/gadget/gadget_chips.h	2006-12-03 19:23:23.000000000 +0100
@@ -75,6 +75,12 @@
 #define	gadget_is_pxa27x(g)	0
 #endif
 
+#ifdef CONFIG_USB_GADGET_HUSB2DEV
+#define gadget_is_husb2dev(g)	!strcmp("husb2_udc", (g)->name)
+#else
+#define gadget_is_husb2dev(g)	0
+#endif
+
 #ifdef CONFIG_USB_GADGET_S3C2410
 #define gadget_is_s3c2410(g)    !strcmp("s3c2410_udc", (g)->name)
 #else
@@ -169,5 +175,7 @@ static inline int usb_gadget_controller_
 		return 0x16;
 	else if (gadget_is_mpc8272(gadget))
 		return 0x17;
+	else if (gadget_is_husb2dev(gadget))
+		return 0x80;
 	return -ENOENT;
 }
Index: linux-2.6.19-avr1/drivers/usb/gadget/husb2_udc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/usb/gadget/husb2_udc.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,1997 @@
+/*
+ * Driver for the Atmel HUSB2device high speed USB device controller
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#undef DEBUG
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+#include <linux/dmapool.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+
+#include "husb2_udc.h"
+
+#define DRIVER_VERSION	"0.9"
+
+#define DMA_ADDR_INVALID (~(dma_addr_t)0)
+
+#define FIFO_IOMEM_ID	0
+#define CTRL_IOMEM_ID	1
+
+#ifdef DEBUG
+#define DBG_ERR		0x0001	/* report all error returns */
+#define DBG_HW		0x0002	/* debug hardware initialization */
+#define DBG_GADGET	0x0004	/* calls to/from gadget driver */
+#define DBG_INT		0x0008	/* interrupts */
+#define DBG_BUS		0x0010	/* report changes in bus state */
+#define DBG_QUEUE	0x0020  /* debug request queue processing */
+#define DBG_FIFO	0x0040  /* debug FIFO contents */
+#define DBG_DMA		0x0080  /* debug DMA handling */
+#define DBG_REQ		0x0100	/* print out queued request length */
+#define DBG_ALL		0xffff
+#define DBG_NONE	0x0000
+
+#define DEBUG_LEVEL	(DBG_ERR|DBG_REQ)
+#define DBG(level, fmt, ...)					\
+	do {							\
+		if ((level) & DEBUG_LEVEL)			\
+			printk(KERN_DEBUG "udc: " fmt, ## __VA_ARGS__);	\
+	} while (0)
+#else
+#define DBG(level, fmt...)
+#endif
+
+static struct husb2_udc the_udc;
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#include <asm/uaccess.h>
+
+static int queue_dbg_open(struct inode *inode, struct file *file)
+{
+	struct husb2_ep *ep = inode->u.generic_ip;
+	struct husb2_request *req, *req_copy;
+	struct list_head *queue_data;
+
+	queue_data = kmalloc(sizeof(*queue_data), GFP_KERNEL);
+	if (!queue_data)
+		return -ENOMEM;
+	INIT_LIST_HEAD(queue_data);
+
+	spin_lock_irq(&ep->udc->lock);
+	list_for_each_entry(req, &ep->queue, queue) {
+		req_copy = kmalloc(sizeof(*req_copy), GFP_ATOMIC);
+		if (!req_copy)
+			goto fail;
+		memcpy(req_copy, req, sizeof(*req_copy));
+		list_add_tail(&req_copy->queue, queue_data);
+	}
+	spin_unlock_irq(&ep->udc->lock);
+
+	file->private_data = queue_data;
+	return 0;
+
+fail:
+	spin_unlock_irq(&ep->udc->lock);
+	list_for_each_entry_safe(req, req_copy, queue_data, queue) {
+		list_del(&req->queue);
+		kfree(req);
+	}
+	kfree(queue_data);
+	return -ENOMEM;
+}
+
+/*
+ * bbbbbbbb llllllll IZS sssss nnnn FDL\n\0
+ *
+ * b: buffer address
+ * l: buffer length
+ * I/i: interrupt/no interrupt
+ * Z/z: zero/no zero
+ * S/s: short ok/short not ok
+ * s: status
+ * n: nr_packets
+ * F/f: submitted/not submitted to FIFO
+ * D/d: using/not using DMA
+ * L/l: last transaction/not last transaction
+ */
+static ssize_t queue_dbg_read(struct file *file, char __user *buf,
+			      size_t nbytes, loff_t *ppos)
+{
+	struct list_head *queue = file->private_data;
+	struct husb2_request *req, *tmp_req;
+	size_t len, remaining, actual = 0;
+	char tmpbuf[38];
+
+	if (!access_ok(VERIFY_WRITE, buf, nbytes))
+		return -EFAULT;
+
+	mutex_lock(&file->f_dentry->d_inode->i_mutex);
+	list_for_each_entry_safe(req, tmp_req, queue, queue) {
+		len = snprintf(tmpbuf, sizeof(tmpbuf),
+			       "%8p %08x %c%c%c %5d %4u %c%c%c\n",
+			       req->req.buf, req->req.length,
+			       req->req.no_interrupt ? 'i' : 'I',
+			       req->req.zero ? 'Z' : 'z',
+			       req->req.short_not_ok ? 's' : 'S',
+			       req->req.status,
+			       req->nr_pkts,
+			       req->submitted ? 'F' : 'f',
+			       req->using_dma ? 'D' : 'd',
+			       req->last_transaction ? 'L' : 'l');
+		len = min(len, sizeof(tmpbuf));
+		if (len > nbytes)
+			break;
+
+		list_del(&req->queue);
+		kfree(req);
+
+		remaining = __copy_to_user(buf, tmpbuf, len);
+		actual += len - remaining;
+		if (remaining)
+			break;
+
+		nbytes -= len;
+		buf += len;
+	}
+	mutex_unlock(&file->f_dentry->d_inode->i_mutex);
+
+	return actual;
+}
+
+static int queue_dbg_release(struct inode *inode, struct file *file)
+{
+	struct list_head *queue_data = file->private_data;
+	struct husb2_request *req, *tmp_req;
+
+	list_for_each_entry_safe(req, tmp_req, queue_data, queue) {
+		list_del(&req->queue);
+		kfree(req);
+	}
+	kfree(queue_data);
+	return 0;
+}
+
+static int regs_dbg_open(struct inode *inode, struct file *file)
+{
+	struct husb2_udc *udc;
+	unsigned int i;
+	u32 *data;
+	int ret = -ENOMEM;
+
+	mutex_lock(&inode->i_mutex);
+	udc = inode->u.generic_ip;
+	data = kmalloc(inode->i_size, GFP_KERNEL);
+	if (!data)
+		goto out;
+
+	spin_lock_irq(&udc->lock);
+	for (i = 0; i < inode->i_size / 4; i++)
+		data[i] = __raw_readl(udc->regs + i * 4);
+	spin_unlock_irq(&udc->lock);
+
+	file->private_data = data;
+	ret = 0;
+
+out:
+	mutex_unlock(&inode->i_mutex);
+
+	return ret;
+}
+
+static ssize_t regs_dbg_read(struct file *file, char __user *buf,
+			     size_t nbytes, loff_t *ppos)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	int ret;
+
+	mutex_lock(&inode->i_mutex);
+	ret = simple_read_from_buffer(buf, nbytes, ppos,
+				       file->private_data,
+				       file->f_dentry->d_inode->i_size);
+	mutex_unlock(&inode->i_mutex);
+
+	return ret;
+}
+
+static int regs_dbg_release(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	return 0;
+}
+
+const struct file_operations queue_dbg_fops = {
+	.owner		= THIS_MODULE,
+	.open		= queue_dbg_open,
+	.llseek		= no_llseek,
+	.read		= queue_dbg_read,
+	.release	= queue_dbg_release,
+};
+
+const struct file_operations regs_dbg_fops = {
+	.owner		= THIS_MODULE,
+	.open		= regs_dbg_open,
+	.llseek		= generic_file_llseek,
+	.read		= regs_dbg_read,
+	.release	= regs_dbg_release,
+};
+
+static void husb2_ep_init_debugfs(struct husb2_udc *udc,
+				  struct husb2_ep *ep)
+{
+	struct dentry *ep_root;
+
+	ep_root = debugfs_create_dir(ep_name(ep), udc->debugfs_root);
+	if (!ep_root)
+		goto err_root;
+	ep->debugfs_dir = ep_root;
+
+	ep->debugfs_queue = debugfs_create_file("queue", 0400, ep_root,
+						ep, &queue_dbg_fops);
+	if (!ep->debugfs_queue)
+		goto err_queue;
+
+	if (ep_can_dma(ep)) {
+		ep->debugfs_dma_status
+			= debugfs_create_u32("dma_status", 0400, ep_root,
+					     &ep->last_dma_status);
+		if (!ep->debugfs_dma_status)
+			goto err_dma_status;
+	}
+
+	return;
+
+err_dma_status:
+	debugfs_remove(ep->debugfs_queue);
+err_queue:
+	debugfs_remove(ep_root);
+err_root:
+	dev_err(&ep->udc->pdev->dev,
+		"failed to create debugfs directory for %s\n", ep_name(ep));
+}
+
+static void husb2_ep_cleanup_debugfs(struct husb2_ep *ep)
+{
+	debugfs_remove(ep->debugfs_queue);
+	debugfs_remove(ep->debugfs_dma_status);
+	debugfs_remove(ep->debugfs_dir);
+	ep->debugfs_dma_status = NULL;
+	ep->debugfs_dir = NULL;
+}
+
+static void husb2_init_debugfs(struct husb2_udc *udc)
+{
+	struct dentry *root, *regs;
+	struct resource *regs_resource;
+
+	root = debugfs_create_dir(udc->gadget.name, NULL);
+	if (IS_ERR(root) || !root)
+		goto err_root;
+	udc->debugfs_root = root;
+
+	regs = debugfs_create_file("regs", 0400, root, udc, &regs_dbg_fops);
+	if (!regs)
+		goto err_regs;
+
+	regs_resource = platform_get_resource(udc->pdev, IORESOURCE_MEM,
+					      CTRL_IOMEM_ID);
+	regs->d_inode->i_size = regs_resource->end - regs_resource->start + 1;
+	udc->debugfs_regs = regs;
+
+	husb2_ep_init_debugfs(udc, to_husb2_ep(udc->gadget.ep0));
+
+	return;
+
+err_regs:
+	debugfs_remove(root);
+err_root:
+	udc->debugfs_root = NULL;
+	dev_err(&udc->pdev->dev, "debugfs is not available\n");
+}
+
+static void husb2_cleanup_debugfs(struct husb2_udc *udc)
+{
+	husb2_ep_cleanup_debugfs(to_husb2_ep(udc->gadget.ep0));
+	debugfs_remove(udc->debugfs_regs);
+	debugfs_remove(udc->debugfs_root);
+	udc->debugfs_regs = NULL;
+	udc->debugfs_root = NULL;
+}
+#else
+static inline void husb2_ep_init_debugfs(struct husb2_udc *udc,
+					 struct husb2_ep *ep)
+{
+
+}
+
+static inline void husb2_ep_cleanup_debugfs(struct husb2_ep *ep)
+{
+
+}
+
+static inline void husb2_init_debugfs(struct husb2_udc *udc)
+{
+
+}
+
+static inline void husb2_cleanup_debugfs(struct husb2_udc *udc)
+{
+
+}
+#endif
+
+static void copy_to_fifo(void __iomem *fifo, void *buf, int len)
+{
+	unsigned long tmp;
+
+	DBG(DBG_FIFO, "copy to FIFO (len %d):\n", len);
+	for (; len > 0; len -= 4, buf += 4, fifo += 4) {
+		tmp = *(unsigned long *)buf;
+		if (len >= 4) {
+			DBG(DBG_FIFO, "  -> %08lx\n", tmp);
+			__raw_writel(tmp, fifo);
+		} else {
+			do {
+				DBG(DBG_FIFO, "  -> %02lx\n", tmp >> 24);
+				__raw_writeb(tmp >> 24, fifo);
+				fifo++;
+				tmp <<= 8;
+			} while (--len);
+			break;
+		}
+	}
+}
+
+static void copy_from_fifo(void *buf, void __iomem *fifo, int len)
+{
+	union {
+		unsigned long *w;
+		unsigned char *b;
+	} p;
+	unsigned long tmp;
+
+	DBG(DBG_FIFO, "copy from FIFO (len %d):\n", len);
+	for (p.w = buf; len > 0; len -= 4, p.w++, fifo += 4) {
+		if (len >= 4) {
+			tmp = __raw_readl(fifo);
+			*p.w = tmp;
+			DBG(DBG_FIFO, "  -> %08lx\n", tmp);
+		} else {
+			do {
+				tmp = __raw_readb(fifo);
+				*p.b = tmp;
+				DBG(DBG_FIFO, " -> %02lx\n", tmp);
+				fifo++, p.b++;
+			} while (--len);
+		}
+	}
+}
+
+static void next_fifo_transaction(struct husb2_ep *ep,
+				  struct husb2_request *req)
+{
+	unsigned int transaction_len;
+
+	transaction_len = req->req.length - req->req.actual;
+	req->last_transaction = 1;
+	if (transaction_len > ep->ep.maxpacket) {
+		transaction_len = ep->ep.maxpacket;
+		req->last_transaction = 0;
+	} else if (transaction_len == ep->ep.maxpacket
+		   && req->req.zero) {
+		req->last_transaction = 0;
+	}
+	DBG(DBG_QUEUE, "%s: submit_transaction, req %p (length %d)%s\n",
+	    ep_name(ep), req, transaction_len,
+	    req->last_transaction ? ", done" : "");
+
+	copy_to_fifo(ep->fifo, req->req.buf + req->req.actual, transaction_len);
+	husb2_ep_writel(ep, SET_STA, HUSB2_BIT(TX_PK_RDY));
+	req->req.actual += transaction_len;
+}
+
+static void submit_request(struct husb2_ep *ep, struct husb2_request *req)
+{
+	DBG(DBG_QUEUE, "%s: submit_request: req %p (length %d)\n",
+	    ep_name(ep), req, req->req.length);
+
+	req->req.actual = 0;
+	req->submitted = 1;
+
+	if (req->using_dma) {
+		if (req->req.length == 0) {
+			husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(TX_PK_RDY));
+		} else {
+			husb2_ep_writel(ep, CTL_DIS, HUSB2_BIT(TX_PK_RDY));
+			husb2_dma_writel(ep, NXT_DSC,
+					 req->packet[0].desc_dma);
+			husb2_dma_writel(ep, CONTROL, HUSB2_BIT(DMA_LINK));
+		}
+	} else {
+		next_fifo_transaction(ep, req);
+		if (req->last_transaction)
+			husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(TX_COMPLETE));
+		else
+			husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(TX_PK_RDY));
+	}
+}
+
+static void submit_next_request(struct husb2_ep *ep)
+{
+	struct husb2_request *req;
+
+	if (list_empty(&ep->queue)) {
+		husb2_ep_writel(ep, CTL_DIS, (HUSB2_BIT(TX_PK_RDY)
+					      | HUSB2_BIT(RX_BK_RDY)));
+		return;
+	}
+
+	req = list_entry(ep->queue.next, struct husb2_request, queue);
+	if (!req->submitted)
+		submit_request(ep, req);
+}
+
+static void send_status(struct husb2_udc *udc, struct husb2_ep *ep)
+{
+	ep->state = STATUS_STAGE_IN;
+	husb2_ep_writel(ep, SET_STA, HUSB2_BIT(TX_PK_RDY));
+	husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(TX_COMPLETE));
+}
+
+static void receive_data(struct husb2_ep *ep)
+{
+	struct husb2_udc *udc = ep->udc;
+	struct husb2_request *req;
+	unsigned long status;
+	unsigned int bytecount, nr_busy;
+	int is_complete = 0;
+
+	status = husb2_ep_readl(ep, STA);
+	nr_busy = HUSB2_BFEXT(BUSY_BANKS, status);
+
+	DBG(DBG_QUEUE, "receive data: nr_busy=%u\n", nr_busy);
+
+	while (nr_busy > 0) {
+		if (list_empty(&ep->queue)) {
+			husb2_ep_writel(ep, CTL_DIS, HUSB2_BIT(RX_BK_RDY));
+			break;
+		}
+		req = list_entry(ep->queue.next,
+				 struct husb2_request, queue);
+
+		bytecount = HUSB2_BFEXT(BYTE_COUNT, status);
+
+		if (status & (1 << 31))
+			is_complete = 1;
+		if (req->req.actual + bytecount >= req->req.length) {
+			is_complete = 1;
+			bytecount = req->req.length - req->req.actual;
+		}
+
+		copy_from_fifo(req->req.buf + req->req.actual,
+			       ep->fifo, bytecount);
+		req->req.actual += bytecount;
+
+		husb2_ep_writel(ep, CLR_STA, HUSB2_BIT(RX_BK_RDY));
+
+		if (is_complete) {
+			DBG(DBG_QUEUE, "%s: request done\n", ep_name(ep));
+			req->req.status = 0;
+			list_del_init(&req->queue);
+			req->req.complete(&ep->ep, &req->req);
+		}
+
+		status = husb2_ep_readl(ep, STA);
+		nr_busy = HUSB2_BFEXT(BUSY_BANKS, status);
+
+		if (is_complete && ep_is_control(ep)) {
+			BUG_ON(nr_busy != 0);
+			send_status(udc, ep);
+			break;
+		}
+	}
+}
+
+static void request_complete(struct husb2_ep *ep,
+			     struct husb2_request *req,
+			     int status)
+{
+	struct husb2_udc *udc = ep->udc;
+	int i;
+
+	BUG_ON(!list_empty(&req->queue));
+
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+
+	if (req->packet) {
+		for (i = 0; i < req->nr_pkts; i++)
+			dma_pool_free(udc->desc_pool, req->packet[i].desc,
+				      req->packet[i].desc_dma);
+		kfree(req->packet);
+		req->packet = NULL;
+		dma_unmap_single(&udc->pdev->dev,
+				 req->req.dma, req->req.length,
+				 (ep_is_in(ep)
+				  ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
+		req->req.dma = DMA_ADDR_INVALID;
+	}
+
+	DBG(DBG_GADGET | DBG_REQ,
+	    "%s: req %p complete: status %d, actual %u\n",
+	    ep_name(ep), req, req->req.status, req->req.actual);
+	req->req.complete(&ep->ep, &req->req);
+}
+
+static void request_complete_list(struct husb2_ep *ep,
+				  struct list_head *list,
+				  int status)
+{
+	struct husb2_request *req, *tmp_req;
+
+	list_for_each_entry_safe(req, tmp_req, list, queue) {
+		list_del_init(&req->queue);
+		request_complete(ep, req, status);
+	}
+}
+
+static int husb2_ep_enable(struct usb_ep *_ep,
+			   const struct usb_endpoint_descriptor *desc)
+{
+	struct husb2_ep *ep = to_husb2_ep(_ep);
+	struct husb2_udc *udc = ep->udc;
+	unsigned long flags, ept_cfg, maxpacket;
+
+	DBG(DBG_GADGET, "%s: ep_enable: desc=%p\n", ep_name(ep), desc);
+
+	maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+
+	if (ep->index == 0
+	    || desc->bDescriptorType != USB_DT_ENDPOINT
+	    || ((desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK)
+		!= ep->index)
+	    || maxpacket == 0
+	    || maxpacket > ep->fifo_size) {
+		DBG(DBG_ERR, "ep_enable: Invalid argument");
+		return -EINVAL;
+	}
+
+	if (((desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+	     == USB_ENDPOINT_XFER_ISOC)
+	    && !(ep->capabilities & HUSB2_EP_CAP_ISOC)) {
+		DBG(DBG_ERR, "ep_enable: %s is not isoc capable\n",
+		    ep_name(ep));
+		return -EINVAL;
+	}
+
+	if (maxpacket <= 8)
+		ept_cfg = HUSB2_BF(EPT_SIZE, HUSB2_EPT_SIZE_8);
+	else
+		/* LSB is bit 1, not 0 */
+		ept_cfg = HUSB2_BF(EPT_SIZE, fls(maxpacket - 1) - 3);
+	DBG(DBG_HW, "%s: EPT_SIZE = %lu (maxpacket = %lu)\n",
+	    ep_name(ep), ept_cfg, maxpacket);
+
+	if ((desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+		ept_cfg |= HUSB2_BIT(EPT_DIR);
+
+	switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		ept_cfg |= HUSB2_BF(EPT_TYPE, HUSB2_EPT_TYPE_CONTROL);
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		ept_cfg |= HUSB2_BF(EPT_TYPE, HUSB2_EPT_TYPE_ISO);
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		ept_cfg |= HUSB2_BF(EPT_TYPE, HUSB2_EPT_TYPE_BULK);
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		ept_cfg |= HUSB2_BF(EPT_TYPE, HUSB2_EPT_TYPE_INT);
+		break;
+	}
+	ept_cfg |= HUSB2_BF(BK_NUMBER, ep->nr_banks);
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+
+	if (ep->desc) {
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		DBG(DBG_ERR, "ep%d already enabled\n", ep->index);
+		return -EBUSY;
+	}
+
+	ep->desc = desc;
+	ep->ep.maxpacket = maxpacket;
+
+	husb2_ep_writel(ep, CFG, ept_cfg);
+	husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(EPT_ENABLE));
+
+	if (ep_can_dma(ep)) {
+		husb2_writel(udc, INT_ENB,
+			     (husb2_readl(udc, INT_ENB)
+			      | HUSB2_BF(EPT_INT, 1 << ep->index)
+			      | HUSB2_BF(DMA_INT, 1 << ep->index)));
+		husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(AUTO_VALID));
+	} else {
+		husb2_writel(udc, INT_ENB,
+			     (husb2_readl(udc, INT_ENB)
+			      | HUSB2_BF(EPT_INT, 1 << ep->index)));
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	DBG(DBG_HW, "EPT_CFG%d after init: %#08lx\n", ep->index,
+	    (unsigned long)husb2_ep_readl(ep, CFG));
+	DBG(DBG_HW, "INT_ENB after init: %#08lx\n",
+	    (unsigned long)husb2_readl(udc, INT_ENB));
+
+	husb2_ep_init_debugfs(udc, ep);
+
+	return 0;
+}
+
+static int husb2_ep_disable(struct usb_ep *_ep)
+{
+	struct husb2_ep *ep = to_husb2_ep(_ep);
+	struct husb2_udc *udc = ep->udc;
+	LIST_HEAD(req_list);
+	unsigned long flags;
+
+	DBG(DBG_GADGET, "ep_disable: %s\n", ep_name(ep));
+
+	husb2_ep_cleanup_debugfs(ep);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (!ep->desc) {
+		spin_unlock_irqrestore(&udc->lock, flags);
+		DBG(DBG_ERR, "ep_disable: %s not enabled\n",
+		    ep_name(ep));
+		return -EINVAL;
+	}
+	ep->desc = NULL;
+
+	list_splice_init(&ep->queue, &req_list);
+	if (ep_can_dma(ep)) {
+		husb2_dma_writel(ep, CONTROL, 0);
+		husb2_dma_writel(ep, ADDRESS, 0);
+		husb2_dma_readl(ep, STATUS);
+	}
+	husb2_ep_writel(ep, CTL_DIS, HUSB2_BIT(EPT_ENABLE));
+	husb2_writel(udc, INT_ENB, (husb2_readl(udc, INT_ENB)
+				    & ~HUSB2_BF(EPT_INT, 1 << ep->index)));
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	request_complete_list(ep, &req_list, -ESHUTDOWN);
+
+	return 0;
+}
+
+static struct usb_request *
+husb2_ep_alloc_request(struct usb_ep *_ep, unsigned gfp_flags)
+{
+	struct husb2_request *req;
+
+	DBG(DBG_GADGET, "ep_alloc_request: %p, 0x%x\n", _ep, gfp_flags);
+
+	req = kzalloc(sizeof(*req), gfp_flags);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+	req->req.dma = DMA_ADDR_INVALID;
+
+	return &req->req;
+}
+
+static void
+husb2_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct husb2_request *req = to_husb2_req(_req);
+
+	DBG(DBG_GADGET, "ep_free_request: %p, %p\n", _ep, _req);
+
+	kfree(req);
+}
+
+static void *husb2_ep_alloc_buffer(struct usb_ep *_ep, unsigned bytes,
+				   dma_addr_t *dma, unsigned gfp_flags)
+{
+	struct husb2_ep *ep = to_husb2_ep(_ep);
+	void *buf;
+
+	/*
+	 * We depend on kmalloc() returning cache-aligned memory. This
+	 * is normally guaranteed as long as we allocate a whole
+	 * cacheline or more.
+	 *
+	 * When CONFIG_DEBUG_SLAB is enabled, however, the slab
+	 * allocator inserts red zones and ownership information,
+	 * causing the slab objects to be misaligned.
+	 *
+	 * One alternative would be to use dma_alloc_coherent, but
+	 * that would make us unable to allocate anything less than a
+	 * page at a time.
+	 */
+#ifdef CONFIG_DEBUG_SLAB
+# error The HUSB2 UDC driver breaks with SLAB debugging enabled
+#endif
+
+	if (bytes < L1_CACHE_BYTES)
+		bytes = L1_CACHE_BYTES;
+
+	buf = kmalloc(bytes, gfp_flags);
+
+	/*
+	 * Seems like we have to map the buffer any chance we get.
+	 * ether.c wants us to initialize the dma member of a
+	 * different request than the one receiving the buffer, so one
+	 * never knows...
+	 *
+	 * Ah, screw it.  The ether driver is probably wrong, and this
+	 * is not the right place to do the mapping.  The driver
+	 * shouldn't mess with our DMA mappings anyway.
+	 */
+	*dma = DMA_ADDR_INVALID;
+
+	DBG(DBG_GADGET, "ep_alloc_buffer: %s, %u, 0x%x -> %p\n",
+	    ep_name(ep), bytes, gfp_flags, buf);
+
+	return buf;
+}
+
+static void husb2_ep_free_buffer(struct usb_ep *_ep, void *buf,
+				 dma_addr_t dma, unsigned bytes)
+{
+	DBG(DBG_GADGET, "ep_free_buffer: %s, buf %p (size %u)\n",
+	    _ep->name, buf, bytes);
+	kfree(buf);
+}
+
+static int queue_dma(struct husb2_udc *udc, struct husb2_ep *ep,
+		     struct husb2_request *req, unsigned int direction,
+		     gfp_t gfp_flags)
+{
+	struct husb2_packet *pkt, *prev_pkt;
+	unsigned int pkt_size, nr_pkts, i;
+	unsigned int residue;
+	dma_addr_t addr;
+	unsigned long flags;
+	u32 ctrl;
+
+	req->using_dma = 1;
+
+	if (req->req.length == 0) {
+		if (!req->req.zero)
+			return -EINVAL;
+		req->send_zlp = 1;
+
+		spin_lock_irqsave(&udc->lock, flags);
+		husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(TX_PK_RDY));
+		list_add_tail(&req->queue, &ep->queue);
+		spin_unlock_irqrestore(&udc->lock, flags);
+
+		return 0;
+	}
+
+	if (req->req.dma == DMA_ADDR_INVALID)
+		req->req.dma = dma_map_single(&udc->pdev->dev,
+					      req->req.buf,
+					      req->req.length,
+					      direction);
+	else
+		dma_sync_single_for_device(&udc->pdev->dev,
+					   req->req.dma,
+					   req->req.length,
+					   direction);
+
+	pkt_size = ep->ep.maxpacket;
+	nr_pkts = req->req.length / pkt_size;
+	residue = req->req.length % pkt_size;
+	if (residue != 0)
+		nr_pkts++;
+	else if (req->req.zero && ep_is_in(ep))
+		/* ensure last packet is short */
+		req->send_zlp = 1;
+
+	req->nr_pkts = nr_pkts;
+
+	req->packet = kzalloc(sizeof(*req->packet) * nr_pkts, gfp_flags);
+	if (!req->packet)
+		goto out_of_memory;
+
+	addr = req->req.dma;
+	ctrl = (HUSB2_BF(DMA_BUF_LEN, pkt_size)
+		| HUSB2_BIT(DMA_CH_EN) | HUSB2_BIT(DMA_LINK)
+		| HUSB2_BIT(DMA_END_TR_EN) | HUSB2_BIT(DMA_END_TR_IE));
+	prev_pkt = NULL;
+	pkt = NULL;
+	DBG(DBG_DMA, "DMA descriptors:\n");
+	for (i = 0; i < nr_pkts; i++) {
+		pkt = &req->packet[i];
+		pkt->desc = dma_pool_alloc(udc->desc_pool, gfp_flags,
+					   &pkt->desc_dma);
+		if (!pkt->desc)
+			goto out_of_memory;
+
+		if (prev_pkt) {
+			prev_pkt->desc->next = pkt->desc_dma;
+			DBG(DBG_DMA, "[%d] n%08x a%08x c%08x\n",
+			    i - 1, prev_pkt->desc->next, prev_pkt->desc->addr,
+			    prev_pkt->desc->ctrl);
+		}
+		prev_pkt = pkt;
+
+		pkt->desc->addr = addr;
+		pkt->desc->ctrl = ctrl;
+		addr += pkt_size;
+	}
+
+	/* special care is needed for the last packet... */
+	ctrl = (HUSB2_BIT(DMA_CH_EN)
+		| HUSB2_BIT(DMA_END_TR_EN) | HUSB2_BIT(DMA_END_TR_IE)
+		| HUSB2_BIT(DMA_END_BUF_IE));
+	if (ep_is_in(ep))
+		ctrl |= HUSB2_BIT(DMA_END_BUF_EN);
+	if (req->req.zero || residue)
+		ctrl |= HUSB2_BF(DMA_BUF_LEN, residue);
+	else
+		ctrl |= HUSB2_BF(DMA_BUF_LEN, pkt_size);
+	pkt->desc->ctrl = ctrl;
+
+	DBG(DBG_DMA, "[%d] n%08x a%08x c%08x\n",
+	    i - 1, prev_pkt->desc->next, prev_pkt->desc->addr,
+	    prev_pkt->desc->ctrl);
+
+	/* Add this request to the queue and try to chain the DMA descriptors */
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* If the DMA controller is idle, start it */
+	if (list_empty(&ep->queue)) {
+		husb2_dma_writel(ep, NXT_DSC, req->packet[0].desc_dma);
+		husb2_dma_writel(ep, CONTROL, HUSB2_BIT(DMA_LINK));
+	}
+
+	list_add_tail(&req->queue, &ep->queue);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+
+out_of_memory:
+	printk(KERN_ERR "ERROR: Could not allocate DMA memory for endpoint %s\n",
+	       ep_name(ep));
+	if (req->packet) {
+		for (i = 0; i < nr_pkts; i++)
+			if (req->packet[i].desc)
+				dma_pool_free(udc->desc_pool,
+					      req->packet[i].desc,
+					      req->packet[i].desc_dma);
+		kfree(req->packet);
+	}
+
+	return -ENOMEM;
+}
+
+static int husb2_ep_queue(struct usb_ep *_ep, struct usb_request *_req,
+			  gfp_t gfp_flags)
+{
+	struct husb2_request *req = to_husb2_req(_req);
+	struct husb2_ep *ep = to_husb2_ep(_ep);
+	struct husb2_udc *udc = ep->udc;
+	unsigned long flags;
+	int direction_in = 0;
+
+	DBG(DBG_GADGET | DBG_QUEUE | DBG_REQ,
+	    "%s: queue req %p, len %u\n", ep_name(ep), req, _req->length);
+
+	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+	if (!ep->desc)
+		return -ENODEV;
+
+	req->nr_pkts = 0;
+	req->submitted = 0;
+	req->using_dma = 0;
+	req->last_transaction = 0;
+	req->send_zlp = 0;
+
+	BUG_ON(req->packet);
+
+	if (ep_is_in(ep)
+	    || (ep_is_control(ep) && (ep->state == DATA_STAGE_IN
+				      || ep->state == STATUS_STAGE_IN)))
+		direction_in = 1;
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	if (ep_can_dma(ep)) {
+		return queue_dma(udc, ep, req, (direction_in
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE),
+				 gfp_flags);
+	} else {
+		spin_lock_irqsave(&udc->lock, flags);
+		list_add_tail(&req->queue, &ep->queue);
+
+		if (direction_in)
+			husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(TX_PK_RDY));
+		else
+			husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(RX_BK_RDY));
+		spin_unlock_irqrestore(&udc->lock, flags);
+	}
+
+	return 0;
+}
+
+static void husb2_update_req(struct husb2_ep *ep, struct husb2_request *req,
+			     u32 status)
+{
+	struct husb2_dma_desc *desc;
+	dma_addr_t from;
+	dma_addr_t addr;
+	size_t size;
+	unsigned int i;
+
+	addr = husb2_dma_readl(ep, ADDRESS);
+	req->req.actual = 0;
+
+	for (i = 0; i < req->nr_pkts; i++) {
+		desc = req->packet[i].desc;
+		from = desc->addr;
+		size = HUSB2_BFEXT(DMA_BUF_LEN, desc->ctrl);
+
+		req->req.actual += size;
+
+		DBG(DBG_DMA, " from=%#08x, size=%#zx\n", from, size);
+
+		if (from <= addr && (from + size) >= addr)
+			break;
+	}
+
+	req->req.actual -= HUSB2_BFEXT(DMA_BUF_LEN, status);
+}
+
+static int stop_dma(struct husb2_ep *ep, u32 *pstatus)
+{
+	unsigned int timeout;
+	u32 status;
+
+	/*
+	 * Stop the DMA controller. When writing both CH_EN
+	 * and LINK to 0, the other bits are not affected.
+	 */
+	husb2_dma_writel(ep, CONTROL, 0);
+
+	/* Wait for the FIFO to empty */
+	for (timeout = 40; timeout; --timeout) {
+		status = husb2_dma_readl(ep, STATUS);
+		if (!(status & HUSB2_BIT(DMA_CH_EN)))
+			break;
+		udelay(1);
+	}
+
+	if (pstatus)
+		*pstatus = status;
+
+	if (timeout == 0) {
+		dev_err(&ep->udc->pdev->dev,
+			"%s: timed out waiting for DMA FIFO to empty\n",
+			ep_name(ep));
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int husb2_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct husb2_ep *ep = to_husb2_ep(_ep);
+	struct husb2_udc *udc = ep->udc;
+	struct husb2_request *req = to_husb2_req(_req);
+	unsigned long flags;
+	u32 status;
+
+	DBG(DBG_GADGET | DBG_QUEUE, "ep_dequeue: %s, req %p\n", ep_name(ep), req);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (req->using_dma) {
+		/*
+		 * If this request is currently being transferred,
+		 * stop the DMA controller and reset the FIFO.
+		 */
+		if (ep->queue.next == &req->queue) {
+			status = husb2_dma_readl(ep, STATUS);
+			if (status & HUSB2_BIT(DMA_CH_EN))
+				stop_dma(ep, &status);
+
+#ifdef CONFIG_DEBUG_FS
+			ep->last_dma_status = status;
+#endif
+
+			husb2_writel(udc, EPT_RST,
+				     1 << ep_index(ep));
+
+			husb2_update_req(ep, req, status);
+		}
+	}
+
+	/*
+	 * Errors should stop the queue from advancing until the
+	 * completion function returns.
+	 */
+	list_del_init(&req->queue);
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	request_complete(ep, req, -ECONNRESET);
+
+	/* Process the next request if any */
+	spin_lock_irqsave(&udc->lock, flags);
+	submit_next_request(ep);
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static int husb2_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct husb2_ep *ep = to_husb2_ep(_ep);
+	struct husb2_udc *udc = ep->udc;
+	unsigned long flags;
+	int ret = 0;
+
+	DBG(DBG_GADGET, "endpoint %s: %s HALT\n", ep_name(ep),
+	    value ? "set" : "clear");
+
+	if (!ep->desc) {
+		DBG(DBG_ERR, "Attempted to halt uninitialized ep %s\n",
+		    ep_name(ep));
+		return -ENODEV;
+	}
+	if (ep_is_isochronous(ep)) {
+		DBG(DBG_ERR, "Attempted to halt isochronous ep %s\n",
+		    ep_name(ep));
+		return -ENOTTY;
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/*
+	 * We can't halt IN endpoints while there are still data to be
+	 * transferred
+	 */
+	if (!list_empty(&ep->queue)
+	    || ((value && ep_is_in(ep)
+		 && (husb2_ep_readl(ep, STA)
+		     & HUSB2_BF(BUSY_BANKS, -1L))))) {
+		ret = -EAGAIN;
+	} else {
+		if (value)
+			husb2_ep_writel(ep, SET_STA, HUSB2_BIT(FORCE_STALL));
+		else
+			husb2_ep_writel(ep, CLR_STA, (HUSB2_BIT(FORCE_STALL)
+						      | HUSB2_BIT(TOGGLE_SEQ)));
+		husb2_ep_readl(ep, STA);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return ret;
+}
+
+static int husb2_ep_fifo_status(struct usb_ep *_ep)
+{
+	struct husb2_ep *ep = to_husb2_ep(_ep);
+
+	return HUSB2_BFEXT(BYTE_COUNT, husb2_ep_readl(ep, STA));
+}
+
+static void husb2_ep_fifo_flush(struct usb_ep *_ep)
+{
+	struct husb2_ep *ep = to_husb2_ep(_ep);
+	struct husb2_udc *udc = ep->udc;
+
+	husb2_writel(udc, EPT_RST, 1 << ep->index);
+}
+
+struct usb_ep_ops husb2_ep_ops = {
+	.enable		= husb2_ep_enable,
+	.disable	= husb2_ep_disable,
+	.alloc_request	= husb2_ep_alloc_request,
+	.free_request	= husb2_ep_free_request,
+	.alloc_buffer	= husb2_ep_alloc_buffer,
+	.free_buffer	= husb2_ep_free_buffer,
+	.queue		= husb2_ep_queue,
+	.dequeue	= husb2_ep_dequeue,
+	.set_halt	= husb2_ep_set_halt,
+	.fifo_status	= husb2_ep_fifo_status,
+	.fifo_flush	= husb2_ep_fifo_flush,
+};
+
+static int husb2_udc_get_frame(struct usb_gadget *gadget)
+{
+	struct husb2_udc *udc = to_husb2_udc(gadget);
+
+	return HUSB2_BFEXT(FRAME_NUMBER, husb2_readl(udc, FNUM));
+}
+
+struct usb_gadget_ops husb2_udc_ops = {
+	.get_frame	= husb2_udc_get_frame,
+};
+
+#define EP(nam, type, idx, caps) {				\
+	.ep	= {						\
+		.ops		= &husb2_ep_ops,		\
+		.name		= nam,				\
+		.maxpacket	= type##_FIFO_SIZE,		\
+	},							\
+	.udc		= &the_udc,				\
+	.queue		= LIST_HEAD_INIT(husb2_ep[idx].queue),	\
+	.fifo_size	= type##_FIFO_SIZE,			\
+	.nr_banks	= type##_NR_BANKS,			\
+	.index		= idx,					\
+	.capabilities	= caps,					\
+}
+
+static struct husb2_ep husb2_ep[] = {
+	EP("ep0", EP0, 0, 0),
+	EP("ep1in-bulk", BULK, 1, HUSB2_EP_CAP_DMA),
+	EP("ep2out-bulk", BULK, 2, HUSB2_EP_CAP_DMA),
+	EP("ep3in-iso", ISO, 3, HUSB2_EP_CAP_DMA | HUSB2_EP_CAP_ISOC),
+	EP("ep4out-iso", ISO, 4, HUSB2_EP_CAP_DMA | HUSB2_EP_CAP_ISOC),
+	EP("ep5in-int", INT, 5, HUSB2_EP_CAP_DMA),
+	EP("ep6out-int", INT, 6, HUSB2_EP_CAP_DMA),
+};
+#undef EP
+
+static struct usb_endpoint_descriptor husb2_ep0_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = 0,
+	.bmAttributes = USB_ENDPOINT_XFER_CONTROL,
+	.wMaxPacketSize = __constant_cpu_to_le16(64),
+	/* FIXME: I have no idea what to put here */
+	.bInterval = 1,
+};
+
+static void nop_release(struct device *dev)
+{
+
+}
+
+static struct husb2_udc the_udc = {
+	.gadget	= {
+		.ops		= &husb2_udc_ops,
+		.ep0		= &husb2_ep[0].ep,
+		.ep_list	= LIST_HEAD_INIT(the_udc.gadget.ep_list),
+		.is_dualspeed	= 1,
+		.name		= "husb2_udc",
+		.dev	= {
+			.bus_id		= "gadget",
+			.release	= nop_release,
+		},
+	},
+
+	.lock	= SPIN_LOCK_UNLOCKED,
+};
+
+static void udc_enable(struct husb2_udc *udc)
+{
+	struct husb2_ep *ep0 = &husb2_ep[0];
+
+	/* Enable the controller */
+	husb2_writel(udc, CTRL, HUSB2_BIT(EN_HUSB2));
+
+	/* Reset all endpoints and enable basic interrupts */
+	husb2_writel(udc, EPT_RST, ~0UL);
+	husb2_writel(udc, INT_ENB, (HUSB2_BIT(DET_SUSPEND)
+				    | HUSB2_BIT(END_OF_RESET)
+				    | HUSB2_BIT(END_OF_RESUME)));
+
+	/* Configure endpoint 0 */
+	ep0->desc = &husb2_ep0_desc;
+
+	husb2_writel(udc, EPT_RST, 1 << 0);
+	husb2_ep_writel(ep0, CTL_ENB, HUSB2_BIT(EPT_ENABLE));
+	husb2_ep_writel(ep0, CFG, (HUSB2_BF(EPT_SIZE, EP0_EPT_SIZE)
+				   | HUSB2_BF(EPT_TYPE, HUSB2_EPT_TYPE_CONTROL)
+				   | HUSB2_BF(BK_NUMBER, HUSB2_BK_NUMBER_ONE)));
+
+	husb2_ep_writel(ep0, CTL_ENB, HUSB2_BIT(RX_SETUP));
+	husb2_writel(udc, INT_ENB, (husb2_readl(udc, INT_ENB)
+				    | HUSB2_BF(EPT_INT, 1)));
+
+	if (!(husb2_ep_readl(ep0, CFG) & HUSB2_BIT(EPT_MAPPED)))
+		dev_warn(&udc->pdev->dev,
+		       "WARNING: EP0 configuration is invalid!\n");
+}
+
+static void udc_disable(struct husb2_udc *udc)
+{
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+
+	husb2_writel(udc, CTRL, 0);
+}
+
+/*
+ * Called with interrupts disabled and udc->lock held.
+ */
+static void reset_all_endpoints(struct husb2_udc *udc)
+{
+	struct husb2_ep *ep;
+	struct husb2_request *req, *tmp_req;
+
+	husb2_writel(udc, EPT_RST, ~0UL);
+
+	ep = to_husb2_ep(udc->gadget.ep0);
+	list_for_each_entry_safe(req, tmp_req, &ep->queue, queue) {
+		list_del_init(&req->queue);
+		request_complete(ep, req, -ECONNRESET);
+	}
+	BUG_ON(!list_empty(&ep->queue));
+
+	list_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {
+		if (ep->desc)
+			husb2_ep_disable(&ep->ep);
+	}
+}
+
+static struct husb2_ep *get_ep_by_addr(struct husb2_udc *udc, u16 wIndex)
+{
+	struct husb2_ep *ep;
+
+	if ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)
+		return to_husb2_ep(udc->gadget.ep0);
+
+	list_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {
+		u8 bEndpointAddress;
+
+		if (!ep->desc)
+			continue;
+		bEndpointAddress = ep->desc->bEndpointAddress;
+		if ((wIndex ^ bEndpointAddress) & USB_DIR_IN)
+			continue;
+		if ((wIndex & USB_ENDPOINT_NUMBER_MASK)
+		    == (bEndpointAddress & USB_ENDPOINT_NUMBER_MASK))
+			return ep;
+	}
+
+	return NULL;
+}
+
+/* Called with interrupts disabled and udc->lock held */
+static inline void set_protocol_stall(struct husb2_udc *udc,
+				      struct husb2_ep *ep)
+{
+	husb2_ep_writel(ep, SET_STA, HUSB2_BIT(FORCE_STALL));
+	ep->state = WAIT_FOR_SETUP;
+}
+
+static inline int is_stalled(struct husb2_udc *udc, struct husb2_ep *ep)
+{
+	if (husb2_ep_readl(ep, STA) & HUSB2_BIT(FORCE_STALL))
+		return 1;
+	return 0;
+}
+
+static inline void set_address(struct husb2_udc *udc, unsigned int addr)
+{
+	u32 regval;
+
+	DBG(DBG_BUS, "setting address %u...\n", addr);
+	regval = husb2_readl(udc, CTRL);
+	regval = HUSB2_BFINS(DEV_ADDR, addr, regval);
+	husb2_writel(udc, CTRL, regval);
+}
+
+static int handle_ep0_setup(struct husb2_udc *udc, struct husb2_ep *ep,
+			    struct usb_ctrlrequest *crq)
+{
+	switch (crq->bRequest) {
+	case USB_REQ_GET_STATUS: {
+		u16 status;
+
+		if (crq->bRequestType == (USB_DIR_IN | USB_RECIP_DEVICE)) {
+			/* Self-powered, no remote wakeup */
+			status = __constant_cpu_to_le16(1 << 0);
+		} else if (crq->bRequestType
+			   == (USB_DIR_IN | USB_RECIP_INTERFACE)) {
+			status = __constant_cpu_to_le16(0);
+		} else if (crq->bRequestType
+			   == (USB_DIR_IN | USB_RECIP_ENDPOINT)) {
+			struct husb2_ep *target;
+
+			target = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));
+			if (!target)
+				goto stall;
+
+			status = 0;
+			if (is_stalled(udc, target))
+				status |= __constant_cpu_to_le16(1);
+		} else {
+			goto delegate;
+		}
+
+		/* Write directly to the FIFO. No queueing is done. */
+		if(crq->wLength != __constant_cpu_to_le16(sizeof(status)))
+			goto stall;
+		ep->state = DATA_STAGE_IN;
+		__raw_writew(status, ep->fifo);
+		husb2_ep_writel(ep, SET_STA, HUSB2_BIT(TX_PK_RDY));
+		break;
+	}
+
+	case USB_REQ_CLEAR_FEATURE: {
+		if (crq->bRequestType == USB_RECIP_DEVICE) {
+			/* We don't support TEST_MODE */
+			goto stall;
+		} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {
+			struct husb2_ep *target;
+
+			if (crq->wValue != __constant_cpu_to_le16(USB_ENDPOINT_HALT)
+			    || crq->wLength != __constant_cpu_to_le16(0))
+				goto stall;
+			target = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));
+			if (!target)
+				goto stall;
+
+			husb2_ep_writel(target, CLR_STA, (HUSB2_BIT(FORCE_STALL)
+							  | HUSB2_BIT(TOGGLE_SEQ)));
+		} else {
+			goto delegate;
+		}
+
+		send_status(udc, ep);
+		break;
+	}
+
+	case USB_REQ_SET_FEATURE: {
+		if (crq->bRequestType == USB_RECIP_DEVICE) {
+			/* We don't support TEST_MODE */
+			goto stall;
+		} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {
+			struct husb2_ep *target;
+
+			if (crq->wValue != __constant_cpu_to_le16(USB_ENDPOINT_HALT)
+			    || crq->wLength != __constant_cpu_to_le16(0))
+				goto stall;
+
+			target = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));
+			if (!target)
+				goto stall;
+
+			husb2_ep_writel(target, SET_STA, HUSB2_BIT(FORCE_STALL));
+		} else
+			goto delegate;
+
+		send_status(udc, ep);
+		break;
+	}
+
+	case USB_REQ_SET_ADDRESS:
+		if (crq->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))
+			goto delegate;
+
+		set_address(udc, le16_to_cpu(crq->wValue));
+		send_status(udc, ep);
+		ep->state = STATUS_STAGE_ADDR;
+		break;
+
+	default:
+	delegate:
+		return udc->driver->setup(&udc->gadget, crq);
+	}
+
+	return 0;
+
+stall:
+	printk(KERN_ERR
+	       "udc: %s: Invalid setup request: %02x.%02x v%04x i%04x l%d, "
+	       "halting endpoint...\n",
+	       ep_name(ep), crq->bRequestType, crq->bRequest,
+	       le16_to_cpu(crq->wValue), le16_to_cpu(crq->wIndex),
+	       le16_to_cpu(crq->wLength));
+	set_protocol_stall(udc, ep);
+	return -1;
+}
+
+static void husb2_control_irq(struct husb2_udc *udc, struct husb2_ep *ep)
+{
+	struct husb2_request *req;
+	u32 epstatus;
+	u32 epctrl;
+
+restart:
+	epstatus = husb2_ep_readl(ep, STA);
+	epctrl = husb2_ep_readl(ep, CTL);
+
+	DBG(DBG_INT, "%s: interrupt, status: 0x%08x\n",
+	    ep_name(ep), epstatus);
+
+	req = NULL;
+	if (!list_empty(&ep->queue))
+		req = list_entry(ep->queue.next,
+				 struct husb2_request, queue);
+
+	if ((epctrl & HUSB2_BIT(TX_PK_RDY))
+	    && !(epstatus & HUSB2_BIT(TX_PK_RDY))) {
+		DBG(DBG_BUS, "tx pk rdy: %d\n", ep->state);
+
+		if (req->submitted)
+			next_fifo_transaction(ep, req);
+		else
+			submit_request(ep, req);
+
+		if (req->last_transaction) {
+			husb2_ep_writel(ep, CTL_DIS, HUSB2_BIT(TX_PK_RDY));
+			husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(TX_COMPLETE));
+		}
+		goto restart;
+	}
+	if ((epstatus & epctrl) & HUSB2_BIT(TX_COMPLETE)) {
+		husb2_ep_writel(ep, CLR_STA, HUSB2_BIT(TX_COMPLETE));
+		DBG(DBG_BUS, "txc: %d\n", ep->state);
+
+		switch (ep->state) {
+		case DATA_STAGE_IN:
+			husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(RX_BK_RDY));
+			husb2_ep_writel(ep, CTL_DIS,
+					HUSB2_BIT(TX_COMPLETE));
+			ep->state = STATUS_STAGE_OUT;
+			break;
+		case STATUS_STAGE_ADDR:
+			/* Activate our new address */
+			husb2_writel(udc, CTRL, (husb2_readl(udc, CTRL)
+						 | HUSB2_BIT(FADDR_EN)));
+			husb2_ep_writel(ep, CTL_DIS,
+					HUSB2_BIT(TX_COMPLETE));
+			ep->state = WAIT_FOR_SETUP;
+			break;
+		case STATUS_STAGE_IN:
+			if (req) {
+				list_del_init(&req->queue);
+				request_complete(ep, req, 0);
+				submit_next_request(ep);
+			}
+			BUG_ON(!list_empty(&ep->queue));
+			husb2_ep_writel(ep, CTL_DIS,
+					HUSB2_BIT(TX_COMPLETE));
+			ep->state = WAIT_FOR_SETUP;
+			break;
+		default:
+			printk(KERN_ERR
+			       "udc: %s: TXCOMP: Invalid endpoint state %d, "
+			       "halting endpoint...\n",
+			       ep_name(ep), ep->state);
+			set_protocol_stall(udc, ep);
+			break;
+		}
+
+		goto restart;
+	}
+	if ((epstatus & epctrl) & HUSB2_BIT(RX_BK_RDY)) {
+		DBG(DBG_BUS, "rxc: %d\n", ep->state);
+
+		switch (ep->state) {
+		case STATUS_STAGE_OUT:
+			husb2_ep_writel(ep, CLR_STA, HUSB2_BIT(RX_BK_RDY));
+
+			if (req) {
+				list_del_init(&req->queue);
+				request_complete(ep, req, 0);
+			}
+			husb2_ep_writel(ep, CTL_DIS, HUSB2_BIT(RX_BK_RDY));
+			ep->state = WAIT_FOR_SETUP;
+			break;
+
+		case DATA_STAGE_OUT:
+			receive_data(ep);
+			break;
+
+		default:
+			husb2_ep_writel(ep, CLR_STA, HUSB2_BIT(RX_BK_RDY));
+			set_protocol_stall(udc, ep);
+			printk(KERN_ERR
+			       "udc: %s: RXRDY: Invalid endpoint state %d, "
+			       "halting endpoint...\n",
+			       ep_name(ep), ep->state);
+			break;
+		}
+
+		goto restart;
+	}
+	if (epstatus & HUSB2_BIT(RX_SETUP)) {
+		union {
+			struct usb_ctrlrequest crq;
+			unsigned long data[2];
+		} crq;
+		unsigned int pkt_len;
+		int ret;
+
+		if (ep->state != WAIT_FOR_SETUP) {
+			/*
+			 * Didn't expect a SETUP packet at this
+			 * point. Clean up any pending requests (which
+			 * may be successful).
+			 */
+			int status = -EPROTO;
+
+			/*
+			 * RXRDY is dropped when SETUP packets arrive.
+			 * Just pretend we received the status packet.
+			 */
+			if (ep->state == STATUS_STAGE_OUT)
+				status = 0;
+
+			if (req) {
+				list_del_init(&req->queue);
+				request_complete(ep, req, status);
+			}
+			BUG_ON(!list_empty(&ep->queue));
+		}
+
+		pkt_len = HUSB2_BFEXT(BYTE_COUNT, husb2_ep_readl(ep, STA));
+		DBG(DBG_HW, "Packet length: %u\n", pkt_len);
+		BUG_ON(pkt_len != sizeof(crq));
+
+		DBG(DBG_FIFO, "Copying ctrl request from 0x%p:\n", ep->fifo);
+		copy_from_fifo(crq.data, ep->fifo, sizeof(crq));
+
+		/* Free up one bank in the FIFO so that we can
+		 * generate or receive a reply right away. */
+		husb2_ep_writel(ep, CLR_STA, HUSB2_BIT(RX_SETUP));
+
+		/* printk(KERN_DEBUG "setup: %d: %02x.%02x\n",
+		       ep->state, crq.crq.bRequestType,
+		       crq.crq.bRequest); */
+
+		if (crq.crq.bRequestType & USB_DIR_IN) {
+			/*
+			 * The USB 2.0 spec states that "if wLength is
+			 * zero, there is no data transfer phase."
+			 * However, testusb #14 seems to actually
+			 * expect a data phase even if wLength = 0...
+			 */
+			ep->state = DATA_STAGE_IN;
+		} else {
+			if (crq.crq.wLength != __constant_cpu_to_le16(0))
+				ep->state = DATA_STAGE_OUT;
+			else
+				ep->state = STATUS_STAGE_IN;
+		}
+
+		ret = -1;
+		if (ep->index == 0)
+			ret = handle_ep0_setup(udc, ep, &crq.crq);
+		else
+			ret = udc->driver->setup(&udc->gadget, &crq.crq);
+
+		DBG(DBG_BUS, "req %02x.%02x, length %d, state %d, ret %d\n",
+		    crq.crq.bRequestType, crq.crq.bRequest,
+		    le16_to_cpu(crq.crq.wLength), ep->state, ret);
+
+		if (ret < 0) {
+			/* Let the host know that we failed */
+			set_protocol_stall(udc, ep);
+		}
+	}
+}
+
+static void husb2_ep_irq(struct husb2_udc *udc, struct husb2_ep *ep)
+{
+	struct husb2_request *req;
+	u32 epstatus;
+	u32 epctrl;
+
+	epstatus = husb2_ep_readl(ep, STA);
+	epctrl = husb2_ep_readl(ep, CTL);
+
+	DBG(DBG_INT, "%s: interrupt, status: 0x%08x\n",
+	    ep_name(ep), epstatus);
+
+	while ((epctrl & HUSB2_BIT(TX_PK_RDY))
+	       && !(epstatus & HUSB2_BIT(TX_PK_RDY))) {
+		BUG_ON(!ep_is_in(ep));
+
+		DBG(DBG_BUS, "%s: TX PK ready\n", ep_name(ep));
+
+		if (list_empty(&ep->queue)) {
+			dev_warn(&udc->pdev->dev, "ep_irq: queue empty\n");
+			husb2_ep_writel(ep, CTL_DIS, HUSB2_BIT(TX_PK_RDY));
+			return;
+		}
+
+		req = list_entry(ep->queue.next, struct husb2_request, queue);
+
+		if (req->using_dma) {
+			BUG_ON(!req->send_zlp);
+
+			/* Send a zero-length packet */
+			husb2_ep_writel(ep, SET_STA,
+					HUSB2_BIT(TX_PK_RDY));
+			husb2_ep_writel(ep, CTL_DIS,
+					HUSB2_BIT(TX_PK_RDY));
+			list_del_init(&req->queue);
+			submit_next_request(ep);
+			request_complete(ep, req, 0);
+		} else {
+			if (req->submitted)
+				next_fifo_transaction(ep, req);
+			else
+				submit_request(ep, req);
+
+			if (req->last_transaction) {
+				list_del_init(&req->queue);
+				submit_next_request(ep);
+				request_complete(ep, req, 0);
+			}
+		}
+
+		epstatus = husb2_ep_readl(ep, STA);
+		epctrl = husb2_ep_readl(ep, CTL);
+	}
+	if ((epstatus & epctrl) & HUSB2_BIT(RX_BK_RDY)) {
+		BUG_ON(ep_is_in(ep));
+
+		DBG(DBG_BUS, "%s: RX data ready\n", ep_name(ep));
+		receive_data(ep);
+		husb2_ep_writel(ep, CLR_STA, HUSB2_BIT(RX_BK_RDY));
+	}
+}
+
+static void husb2_dma_irq(struct husb2_udc *udc, struct husb2_ep *ep)
+{
+	struct husb2_request *req;
+	u32 status, control, pending;
+
+	status = husb2_dma_readl(ep, STATUS);
+	control = husb2_dma_readl(ep, CONTROL);
+#ifdef CONFIG_DEBUG_FS
+	ep->last_dma_status = status;
+#endif
+	pending = status & control;
+	DBG(DBG_INT, "dma irq, status=%#08x, pending=%#08x, control=%#08x\n",
+	    status, pending, control);
+
+	BUG_ON(status & HUSB2_BIT(DMA_CH_EN));
+
+	if (list_empty(&ep->queue))
+		/* Might happen if a reset comes along at the right moment */
+		return;
+
+	if (pending & (HUSB2_BIT(DMA_END_TR_ST) | HUSB2_BIT(DMA_END_BUF_ST))) {
+		req = list_entry(ep->queue.next, struct husb2_request, queue);
+		husb2_update_req(ep, req, status);
+
+		if (req->send_zlp) {
+			husb2_ep_writel(ep, CTL_ENB, HUSB2_BIT(TX_PK_RDY));
+		} else {
+			list_del_init(&req->queue);
+			submit_next_request(ep);
+			request_complete(ep, req, 0);
+		}
+	}
+}
+
+static irqreturn_t husb2_udc_irq(int irq, void *devid, struct pt_regs *regs)
+{
+	struct husb2_udc *udc = devid;
+	u32 status;
+	u32 dma_status;
+	u32 ep_status;
+
+	spin_lock(&udc->lock);
+
+	status = husb2_readl(udc, INT_STA);
+	DBG(DBG_INT, "irq, status=%#08x\n", status);
+
+	if (status & HUSB2_BIT(DET_SUSPEND)) {
+		husb2_writel(udc, INT_CLR, HUSB2_BIT(DET_SUSPEND));
+		//DBG(DBG_BUS, "Suspend detected\n");
+		if (udc->gadget.speed != USB_SPEED_UNKNOWN
+		    && udc->driver && udc->driver->suspend)
+			udc->driver->suspend(&udc->gadget);
+	}
+
+	if (status & HUSB2_BIT(WAKE_UP)) {
+		husb2_writel(udc, INT_CLR, HUSB2_BIT(WAKE_UP));
+		//DBG(DBG_BUS, "Wake Up CPU detected\n");
+	}
+
+	if (status & HUSB2_BIT(END_OF_RESUME)) {
+		husb2_writel(udc, INT_CLR, HUSB2_BIT(END_OF_RESUME));
+		DBG(DBG_BUS, "Resume detected\n");
+		if (udc->gadget.speed != USB_SPEED_UNKNOWN
+		    && udc->driver && udc->driver->resume)
+			udc->driver->resume(&udc->gadget);
+	}
+
+	dma_status = HUSB2_BFEXT(DMA_INT, status);
+	if (dma_status) {
+		int i;
+
+		for (i = 1; i < HUSB2_NR_ENDPOINTS; i++)
+			if (dma_status & (1 << i))
+				husb2_dma_irq(udc, &husb2_ep[i]);
+	}
+
+	ep_status = HUSB2_BFEXT(EPT_INT, status);
+	if (ep_status) {
+		int i;
+
+		for (i = 0; i < HUSB2_NR_ENDPOINTS; i++)
+			if (ep_status & (1 << i)) {
+				if (ep_is_control(&husb2_ep[i]))
+					husb2_control_irq(udc, &husb2_ep[i]);
+				else
+					husb2_ep_irq(udc, &husb2_ep[i]);
+			}
+	}
+
+	if (status & HUSB2_BIT(END_OF_RESET)) {
+		husb2_writel(udc, INT_CLR, HUSB2_BIT(END_OF_RESET));
+		if (status & HUSB2_BIT(HIGH_SPEED)) {
+			DBG(DBG_BUS, "High-speed bus reset detected\n");
+			udc->gadget.speed = USB_SPEED_HIGH;
+		} else {
+			DBG(DBG_BUS, "Full-speed bus reset detected\n");
+			udc->gadget.speed = USB_SPEED_FULL;
+		}
+		/* Better start from scratch... */
+		reset_all_endpoints(udc);
+		husb2_ep[0].state = WAIT_FOR_SETUP;
+		udc_enable(udc);
+	}
+
+	spin_unlock(&udc->lock);
+
+	return IRQ_HANDLED;
+}
+
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct husb2_udc *udc = &the_udc;
+	int ret;
+
+	spin_lock(&udc->lock);
+
+	ret = -ENODEV;
+	if (!udc->pdev)
+		goto out;
+	ret = -EBUSY;
+	if (udc->driver)
+		goto out;
+
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+
+	device_add(&udc->gadget.dev);
+	ret = driver->bind(&udc->gadget);
+	if (ret) {
+		DBG(DBG_ERR, "Could not bind to driver %s: error %d\n",
+		    driver->driver.name, ret);
+		device_del(&udc->gadget.dev);
+
+		udc->driver = NULL;
+		udc->gadget.dev.driver = NULL;
+		goto out;
+	}
+
+	/* TODO: Create sysfs files */
+
+	DBG(DBG_GADGET, "registered driver `%s'\n", driver->driver.name);
+	udc_enable(udc);
+
+out:
+	spin_unlock(&udc->lock);
+	return ret;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct husb2_udc *udc = &the_udc;
+	int ret;
+
+	spin_lock(&udc->lock);
+
+	ret = -ENODEV;
+	if (!udc->pdev)
+		goto out;
+	ret = -EINVAL;
+	if (driver != udc->driver)
+		goto out;
+
+	local_irq_disable();
+	udc_disable(udc);
+	local_irq_enable();
+
+	driver->unbind(&udc->gadget);
+	udc->driver = NULL;
+
+	device_del(&udc->gadget.dev);
+
+	/* TODO: Remove sysfs files */
+
+	DBG(DBG_GADGET, "unregistered driver `%s'\n", driver->driver.name);
+
+out:
+	spin_unlock(&udc->lock);
+	return ret;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+static int __devinit husb2_udc_probe(struct platform_device *pdev)
+{
+	struct resource *regs, *fifo;
+	struct clk *pclk, *hclk;
+	struct husb2_udc *udc = &the_udc;
+	int irq, ret, i;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, CTRL_IOMEM_ID);
+	fifo = platform_get_resource(pdev, IORESOURCE_MEM, FIFO_IOMEM_ID);
+	if (!regs || !fifo)
+		return -ENXIO;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	pclk = clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(pclk))
+		return PTR_ERR(pclk);
+	hclk = clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(hclk)) {
+		ret = PTR_ERR(hclk);
+		goto out_put_pclk;
+	}
+
+	clk_enable(pclk);
+	clk_enable(hclk);
+
+	udc->pdev = pdev;
+	udc->pclk = pclk;
+	udc->hclk = hclk;
+
+	ret = -ENOMEM;
+	udc->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!udc->regs) {
+		dev_err(&pdev->dev, "Unable to map I/O memory, aborting.\n");
+		goto out_disable_clocks;
+	}
+	dev_info(&pdev->dev, "MMIO registers at 0x%08lx mapped at %p\n",
+		 (unsigned long)regs->start, udc->regs);
+	udc->fifo = ioremap(fifo->start, fifo->end - fifo->start + 1);
+	if (!udc->fifo) {
+		dev_err(&pdev->dev, "Unable to map FIFO, aborting.\n");
+		goto out_unmap_regs;
+	}
+	dev_info(&pdev->dev, "FIFO at 0x%08lx mapped at %p\n",
+		 (unsigned long)fifo->start, udc->fifo);
+
+	device_initialize(&udc->gadget.dev);
+	udc->gadget.dev.parent = &pdev->dev;
+	udc->gadget.dev.dma_mask = pdev->dev.dma_mask;
+
+	/* The 3-word descriptors must be 4-word aligned... */
+	udc->desc_pool = dma_pool_create("husb2-desc", &pdev->dev,
+					 sizeof(struct husb2_dma_desc),
+					 16, 0);
+	if (!udc->desc_pool) {
+		dev_err(&pdev->dev, "Cannot create descriptor DMA pool\n");
+		goto out_unmap_fifo;
+	}
+
+	platform_set_drvdata(pdev, udc);
+
+	udc_disable(udc);
+
+	INIT_LIST_HEAD(&husb2_ep[0].ep.ep_list);
+	husb2_ep[0].ep_regs = udc->regs + HUSB2_EPT_BASE(0);
+	husb2_ep[0].dma_regs = udc->regs + HUSB2_DMA_BASE(0);
+	husb2_ep[0].fifo = udc->fifo + HUSB2_FIFO_BASE(0);
+	for (i = 1; i < ARRAY_SIZE(husb2_ep); i++) {
+		struct husb2_ep *ep = &husb2_ep[i];
+
+		ep->ep_regs = udc->regs + HUSB2_EPT_BASE(i);
+		ep->dma_regs = udc->regs + HUSB2_DMA_BASE(i);
+		ep->fifo = udc->fifo + HUSB2_FIFO_BASE(i);
+
+		list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+	}
+
+	ret = request_irq(irq, husb2_udc_irq, SA_SAMPLE_RANDOM,
+			  "husb2_udc", udc);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot request irq %d (error %d)\n",
+			irq, ret);
+		goto out_free_pool;
+	}
+	udc->irq = irq;
+
+	husb2_init_debugfs(udc);
+
+	return 0;
+
+out_free_pool:
+	dma_pool_destroy(udc->desc_pool);
+out_unmap_fifo:
+	iounmap(udc->fifo);
+out_unmap_regs:
+	iounmap(udc->regs);
+out_disable_clocks:
+	clk_disable(hclk);
+	clk_disable(pclk);
+	clk_put(hclk);
+out_put_pclk:
+	clk_put(pclk);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return ret;
+}
+
+static int __devexit husb2_udc_remove(struct platform_device *pdev)
+{
+	struct husb2_udc *udc;
+
+	udc = platform_get_drvdata(pdev);
+	if (!udc)
+		return 0;
+
+	husb2_cleanup_debugfs(udc);
+
+	free_irq(udc->irq, udc);
+	dma_pool_destroy(udc->desc_pool);
+	iounmap(udc->fifo);
+	iounmap(udc->regs);
+	clk_disable(udc->hclk);
+	clk_disable(udc->pclk);
+	clk_put(udc->hclk);
+	clk_put(udc->pclk);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver udc_driver = {
+	.probe		= husb2_udc_probe,
+	.remove		= __devexit_p(husb2_udc_remove),
+	.driver		= {
+		.name		= "usb",
+	},
+};
+
+static int __init udc_init(void)
+{
+	printk(KERN_INFO "husb2device: Driver version %s\n", DRIVER_VERSION);
+	return platform_driver_register(&udc_driver);
+}
+module_init(udc_init);
+
+static void __exit udc_exit(void)
+{
+	platform_driver_unregister(&udc_driver);
+}
+module_exit(udc_exit);
+
+MODULE_DESCRIPTION("Atmel HUSB2 Device Controller driver");
+MODULE_AUTHOR("Haavard Skinnemoen <hskinnemoen@atmel.com>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.19-avr1/drivers/usb/gadget/husb2_udc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/drivers/usb/gadget/husb2_udc.h	2006-12-03 19:23:23.000000000 +0100
@@ -0,0 +1,406 @@
+/*
+ * Driver for the Atmel HUSB2device high speed USB device controller
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __LINUX_USB_GADGET_HUSB2_UDC_H__
+#define __LINUX_USB_GADGET_HUSB2_UDC_H__
+
+/* USB register offsets */
+#define HUSB2_CTRL				0x0000
+#define HUSB2_FNUM				0x0004
+#define HUSB2_INT_ENB				0x0010
+#define HUSB2_INT_STA				0x0014
+#define HUSB2_INT_CLR				0x0018
+#define HUSB2_EPT_RST				0x001c
+#define HUSB2_TST_SOF_CNT			0x00d0
+#define HUSB2_TST_CNT_A				0x00d4
+#define HUSB2_TST_CNT_B				0x00d8
+#define HUSB2_TST_MODE_REG			0x00dc
+#define HUSB2_TST				0x00f0
+
+/* USB endpoint register offsets */
+#define HUSB2_EPT_CFG				0x0000
+#define HUSB2_EPT_CTL_ENB			0x0004
+#define HUSB2_EPT_CTL_DIS			0x0008
+#define HUSB2_EPT_CTL				0x000c
+#define HUSB2_EPT_SET_STA			0x0014
+#define HUSB2_EPT_CLR_STA			0x0018
+#define HUSB2_EPT_STA				0x001c
+
+/* USB DMA register offsets */
+#define HUSB2_DMA_NXT_DSC			0x0000
+#define HUSB2_DMA_ADDRESS			0x0004
+#define HUSB2_DMA_CONTROL			0x0008
+#define HUSB2_DMA_STATUS			0x000c
+
+/* Bitfields in CTRL */
+#define HUSB2_DEV_ADDR_OFFSET			0
+#define HUSB2_DEV_ADDR_SIZE			7
+#define HUSB2_FADDR_EN_OFFSET			7
+#define HUSB2_FADDR_EN_SIZE			1
+#define HUSB2_EN_HUSB2_OFFSET			8
+#define HUSB2_EN_HUSB2_SIZE			1
+#define HUSB2_DETACH_OFFSET			9
+#define HUSB2_DETACH_SIZE			1
+#define HUSB2_REMOTE_WAKE_UP_OFFSET		10
+#define HUSB2_REMOTE_WAKE_UP_SIZE		1
+
+/* Bitfields in FNUM */
+#define HUSB2_MICRO_FRAME_NUM_OFFSET		0
+#define HUSB2_MICRO_FRAME_NUM_SIZE		3
+#define HUSB2_FRAME_NUMBER_OFFSET		3
+#define HUSB2_FRAME_NUMBER_SIZE			11
+#define HUSB2_FRAME_NUM_ERROR_OFFSET		31
+#define HUSB2_FRAME_NUM_ERROR_SIZE		1
+
+/* Bitfields in INT_ENB/INT_STA/INT_CLR */
+#define HUSB2_HIGH_SPEED_OFFSET			0
+#define HUSB2_HIGH_SPEED_SIZE			1
+#define HUSB2_DET_SUSPEND_OFFSET		1
+#define HUSB2_DET_SUSPEND_SIZE			1
+#define HUSB2_MICRO_SOF_OFFSET			2
+#define HUSB2_MICRO_SOF_SIZE			1
+#define HUSB2_SOF_OFFSET			3
+#define HUSB2_SOF_SIZE				1
+#define HUSB2_END_OF_RESET_OFFSET		4
+#define HUSB2_END_OF_RESET_SIZE			1
+#define HUSB2_WAKE_UP_OFFSET			5
+#define HUSB2_WAKE_UP_SIZE			1
+#define HUSB2_END_OF_RESUME_OFFSET		6
+#define HUSB2_END_OF_RESUME_SIZE		1
+#define HUSB2_UPSTREAM_RESUME_OFFSET		7
+#define HUSB2_UPSTREAM_RESUME_SIZE		1
+#define HUSB2_EPT_INT_OFFSET			8
+#define HUSB2_EPT_INT_SIZE			16
+#define HUSB2_DMA_INT_OFFSET			24
+#define HUSB2_DMA_INT_SIZE			8
+
+/* Bitfields in EPT_RST */
+#define HUSB2_RST_OFFSET			0
+#define HUSB2_RST_SIZE				16
+
+/* Bitfields in TST_SOF_CNT */
+#define HUSB2_SOF_CNT_MAX_OFFSET		0
+#define HUSB2_SOF_CNT_MAX_SIZE			7
+#define HUSB2_SOF_CNT_LOAD_OFFSET		7
+#define HUSB2_SOF_CNT_LOAD_SIZE			1
+
+/* Bitfields in TST_CNT_A */
+#define HUSB2_CNT_A_MAX_OFFSET			0
+#define HUSB2_CNT_A_MAX_SIZE			7
+#define HUSB2_CNT_A_LOAD_OFFSET			7
+#define HUSB2_CNT_A_LOAD_SIZE			1
+
+/* Bitfields in TST_CNT_B */
+#define HUSB2_CNT_B_MAX_OFFSET			0
+#define HUSB2_CNT_B_MAX_SIZE			7
+#define HUSB2_CNT_B_LOAD_OFFSET			7
+#define HUSB2_CNT_B_LOAD_SIZE			1
+
+/* Bitfields in TST_MODE_REG */
+#define HUSB2_TST_MODE_OFFSET			0
+#define HUSB2_TST_MODE_SIZE			6
+
+/* Bitfields in HUSB2_TST */
+#define HUSB2_SPEED_CFG_OFFSET			0
+#define HUSB2_SPEED_CFG_SIZE			2
+#define HUSB2_TST_J_MODE_OFFSET			2
+#define HUSB2_TST_J_MODE_SIZE			1
+#define HUSB2_TST_K_MODE_OFFSET			3
+#define HUSB2_TST_K_MODE_SIZE			1
+#define HUSB2_TST_PKT_MODE_OFFSE		4
+#define HUSB2_TST_PKT_MODE_SIZE			1
+#define HUSB2_OPMODE2_OFFSET			5
+#define HUSB2_OPMODE2_SIZE			1
+
+/* Bitfields in EPT_CFG */
+#define HUSB2_EPT_SIZE_OFFSET			0
+#define HUSB2_EPT_SIZE_SIZE			3
+#define HUSB2_EPT_DIR_OFFSET			3
+#define HUSB2_EPT_DIR_SIZE			1
+#define HUSB2_EPT_TYPE_OFFSET			4
+#define HUSB2_EPT_TYPE_SIZE			2
+#define HUSB2_BK_NUMBER_OFFSET			6
+#define HUSB2_BK_NUMBER_SIZE			2
+#define HUSB2_NB_TRANS_OFFSET			8
+#define HUSB2_NB_TRANS_SIZE			2
+#define HUSB2_EPT_MAPPED_OFFSET			31
+#define HUSB2_EPT_MAPPED_SIZE			1
+
+/* Bitfields in EPT_CTL/EPT_CTL_ENB/EPT_CTL_DIS */
+#define HUSB2_EPT_ENABLE_OFFSET			0
+#define HUSB2_EPT_ENABLE_SIZE			1
+#define HUSB2_AUTO_VALID_OFFSET			1
+#define HUSB2_AUTO_VALID_SIZE			1
+#define HUSB2_INT_DIS_DMA_OFFSET		3
+#define HUSB2_INT_DIS_DMA_SIZE			1
+#define HUSB2_NYET_DIS_OFFSET			4
+#define HUSB2_NYET_DIS_SIZE			1
+#define HUSB2_DATAX_RX_OFFSET			6
+#define HUSB2_DATAX_RX_SIZE			1
+#define HUSB2_MDATA_RX_OFFSET			7
+#define HUSB2_MDATA_RX_SIZE			1
+/* Bits 8-15 and 31 enable interrupts for respective bits in EPT_STA */
+#define HUSB2_BUSY_BANK_IE_OFFSET		18
+#define HUSB2_BUSY_BANK_IE_SIZE			1
+
+/* Bitfields in EPT_SET_STA/EPT_CLR_STA/EPT_STA */
+#define HUSB2_FORCE_STALL_OFFSET		5
+#define HUSB2_FORCE_STALL_SIZE			1
+#define HUSB2_TOGGLE_SEQ_OFFSET			6
+#define HUSB2_TOGGLE_SEQ_SIZE			2
+#define HUSB2_ERR_OVFLW_OFFSET			8
+#define HUSB2_ERR_OVFLW_SIZE			1
+#define HUSB2_RX_BK_RDY_OFFSET			9
+#define HUSB2_RX_BK_RDY_SIZE			1
+#define HUSB2_KILL_BANK_OFFSET			9
+#define HUSB2_KILL_BANK_SIZE			1
+#define HUSB2_TX_COMPLETE_OFFSET		10
+#define HUSB2_TX_COMPLETE_SIZE			1
+#define HUSB2_TX_PK_RDY_OFFSET			11
+#define HUSB2_TX_PK_RDY_SIZE			1
+#define HUSB2_ISO_ERR_TRANS_OFFSET		11
+#define HUSB2_ISO_ERR_TRANS_SIZE		1
+#define HUSB2_RX_SETUP_OFFSET			12
+#define HUSB2_RX_SETUP_SIZE			1
+#define HUSB2_ISO_ERR_FLOW_OFFSET		12
+#define HUSB2_ISO_ERR_FLOW_SIZE			1
+#define HUSB2_STALL_SENT_OFFSET			13
+#define HUSB2_STALL_SENT_SIZE			1
+#define HUSB2_ISO_ERR_CRC_OFFSET		13
+#define HUSB2_ISO_ERR_CRC_SIZE			1
+#define HUSB2_ISO_ERR_NBTRANS_OFFSET		13
+#define HUSB2_ISO_ERR_NBTRANS_SIZE		1
+#define HUSB2_NAK_IN_OFFSET			14
+#define HUSB2_NAK_IN_SIZE			1
+#define HUSB2_ISO_ERR_FLUSH_OFFSET		14
+#define HUSB2_ISO_ERR_FLUSH_SIZE		1
+#define HUSB2_NAK_OUT_OFFSET			15
+#define HUSB2_NAK_OUT_SIZE			1
+#define HUSB2_CURRENT_BANK_OFFSET		16
+#define HUSB2_CURRENT_BANK_SIZE			2
+#define HUSB2_BUSY_BANKS_OFFSET			18
+#define HUSB2_BUSY_BANKS_SIZE			2
+#define HUSB2_BYTE_COUNT_OFFSET			20
+#define HUSB2_BYTE_COUNT_SIZE			11
+#define HUSB2_SHORT_PACKET_OFFSET		31
+#define HUSB2_SHORT_PACKET_SIZE			1
+
+/* Bitfields in DMA_CONTROL */
+#define HUSB2_DMA_CH_EN_OFFSET			0
+#define HUSB2_DMA_CH_EN_SIZE			1
+#define HUSB2_DMA_LINK_OFFSET			1
+#define HUSB2_DMA_LINK_SIZE			1
+#define HUSB2_DMA_END_TR_EN_OFFSET		2
+#define HUSB2_DMA_END_TR_EN_SIZE		1
+#define HUSB2_DMA_END_BUF_EN_OFFSET		3
+#define HUSB2_DMA_END_BUF_EN_SIZE		1
+#define HUSB2_DMA_END_TR_IE_OFFSET		4
+#define HUSB2_DMA_END_TR_IE_SIZE		1
+#define HUSB2_DMA_END_BUF_IE_OFFSET		5
+#define HUSB2_DMA_END_BUF_IE_SIZE		1
+#define HUSB2_DMA_DESC_LOAD_IE_OFFSET		6
+#define HUSB2_DMA_DESC_LOAD_IE_SIZE		1
+#define HUSB2_DMA_BURST_LOCK_OFFSET		7
+#define HUSB2_DMA_BURST_LOCK_SIZE		1
+#define HUSB2_DMA_BUF_LEN_OFFSET		16
+#define HUSB2_DMA_BUF_LEN_SIZE			16
+
+/* Bitfields in DMA_STATUS */
+#define HUSB2_DMA_CH_ACTIVE_OFFSET		1
+#define HUSB2_DMA_CH_ACTIVE_SIZE		1
+#define HUSB2_DMA_END_TR_ST_OFFSET		4
+#define HUSB2_DMA_END_TR_ST_SIZE		1
+#define HUSB2_DMA_END_BUF_ST_OFFSET		5
+#define HUSB2_DMA_END_BUF_ST_SIZE		1
+#define HUSB2_DMA_DESC_LOAD_ST_OFFSET		6
+#define HUSB2_DMA_DESC_LOAD_ST_SIZE		1
+
+/* Constants for SPEED_CFG */
+#define HUSB2_SPEED_CFG_NORMAL			0
+#define HUSB2_SPEED_CFG_FORCE_HIGH		2
+#define HUSB2_SPEED_CFG_FORCE_FULL		3
+
+/* Constants for EPT_SIZE */
+#define HUSB2_EPT_SIZE_8			0
+#define HUSB2_EPT_SIZE_16			1
+#define HUSB2_EPT_SIZE_32			2
+#define HUSB2_EPT_SIZE_64			3
+#define HUSB2_EPT_SIZE_128			4
+#define HUSB2_EPT_SIZE_256			5
+#define HUSB2_EPT_SIZE_512			6
+#define HUSB2_EPT_SIZE_1024			7
+
+/* Constants for EPT_TYPE */
+#define HUSB2_EPT_TYPE_CONTROL			0
+#define HUSB2_EPT_TYPE_ISO			1
+#define HUSB2_EPT_TYPE_BULK			2
+#define HUSB2_EPT_TYPE_INT			3
+
+/* Constants for BK_NUMBER */
+#define HUSB2_BK_NUMBER_ZERO			0
+#define HUSB2_BK_NUMBER_ONE			1
+#define HUSB2_BK_NUMBER_DOUBLE			2
+#define HUSB2_BK_NUMBER_TRIPLE			3
+
+/* Bit manipulation macros */
+#define HUSB2_BIT(name)						\
+	(1 << HUSB2_##name##_OFFSET)
+#define HUSB2_BF(name,value)					\
+	(((value) & ((1 << HUSB2_##name##_SIZE) - 1))		\
+	 << HUSB2_##name##_OFFSET)
+#define HUSB2_BFEXT(name,value)					\
+	(((value) >> HUSB2_##name##_OFFSET)			\
+	 & ((1 << HUSB2_##name##_SIZE) - 1))
+#define HUSB2_BFINS(name,value,old)				\
+	(((old) & ~(((1 << HUSB2_##name##_SIZE) - 1)		\
+		    << HUSB2_##name##_OFFSET))			\
+	 | HUSB2_BF(name,value))
+
+/* Register access macros */
+#define husb2_readl(udc,reg)					\
+	__raw_readl((udc)->regs + HUSB2_##reg)
+#define husb2_writel(udc,reg,value)				\
+	__raw_writel((value), (udc)->regs + HUSB2_##reg)
+#define husb2_ep_readl(ep,reg)					\
+	__raw_readl((ep)->ep_regs + HUSB2_EPT_##reg)
+#define husb2_ep_writel(ep,reg,value)				\
+	__raw_writel((value), (ep)->ep_regs + HUSB2_EPT_##reg)
+#define husb2_dma_readl(ep,reg)					\
+	__raw_readl((ep)->dma_regs + HUSB2_DMA_##reg)
+#define husb2_dma_writel(ep,reg,value)				\
+	__raw_writel((value), (ep)->dma_regs + HUSB2_DMA_##reg)
+
+/* Calculate base address for a given endpoint or DMA controller */
+#define HUSB2_EPT_BASE(x)			(0x100 + (x) * 0x20)
+#define HUSB2_DMA_BASE(x)			(0x300 + (x) * 0x10)
+#define HUSB2_FIFO_BASE(x)			((x) << 16)
+
+/* Synth parameters */
+#define HUSB2_NR_ENDPOINTS	7
+
+#define EP0_FIFO_SIZE		64
+#define EP0_EPT_SIZE		HUSB2_EPT_SIZE_64
+#define EP0_NR_BANKS		1
+#define BULK_FIFO_SIZE		512
+#define BULK_EPT_SIZE		HUSB2_EPT_SIZE_512
+#define BULK_NR_BANKS		2
+#define ISO_FIFO_SIZE		1024
+#define ISO_EPT_SIZE		HUSB2_EPT_SIZE_1024
+#define ISO_NR_BANKS		3
+#define INT_FIFO_SIZE		64
+#define INT_EPT_SIZE		HUSB2_EPT_SIZE_64
+#define INT_NR_BANKS		3
+
+enum husb2_ctrl_state {
+	WAIT_FOR_SETUP,
+	DATA_STAGE_IN,
+	DATA_STAGE_OUT,
+	STATUS_STAGE_IN,
+	STATUS_STAGE_OUT,
+	STATUS_STAGE_ADDR,
+};
+/*
+  EP_STATE_IDLE,
+  EP_STATE_SETUP,
+  EP_STATE_IN_DATA,
+  EP_STATE_OUT_DATA,
+  EP_STATE_SET_ADDR_STATUS,
+  EP_STATE_RX_STATUS,
+  EP_STATE_TX_STATUS,
+  EP_STATE_HALT,
+*/
+
+struct husb2_dma_desc {
+	dma_addr_t next;
+	dma_addr_t addr;
+	u32 ctrl;
+};
+
+struct husb2_ep {
+	int					state;
+	void __iomem				*ep_regs;
+	void __iomem				*dma_regs;
+	void __iomem				*fifo;
+	struct usb_ep				ep;
+	struct husb2_udc			*udc;
+
+	struct list_head			queue;
+	const struct usb_endpoint_descriptor	*desc;
+
+	u16					fifo_size;
+	u8					nr_banks;
+	u8					index;
+	u8					capabilities;
+
+#ifdef CONFIG_DEBUG_FS
+	u32					last_dma_status;
+	struct dentry				*debugfs_dir;
+	struct dentry				*debugfs_queue;
+	struct dentry				*debugfs_dma_status;
+#endif
+};
+#define HUSB2_EP_CAP_ISOC	0x0001
+#define HUSB2_EP_CAP_DMA	0x0002
+
+struct husb2_packet {
+	struct husb2_dma_desc			*desc;
+	dma_addr_t				desc_dma;
+};
+
+struct husb2_request {
+	struct usb_request			req;
+	struct list_head			queue;
+
+	struct husb2_packet			*packet;
+	unsigned int				nr_pkts;
+
+	unsigned int				submitted:1;
+	unsigned int				using_dma:1;
+	unsigned int				last_transaction:1;
+	unsigned int				send_zlp:1;
+};
+
+struct husb2_udc {
+	spinlock_t lock;
+
+	void __iomem *regs;
+	void __iomem *fifo;
+
+	struct dma_pool *desc_pool;
+
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	struct platform_device *pdev;
+	int irq;
+	struct clk *pclk;
+	struct clk *hclk;
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_root;
+	struct dentry *debugfs_regs;
+#endif
+};
+
+#define to_husb2_ep(x) container_of((x), struct husb2_ep, ep)
+#define to_husb2_req(x) container_of((x), struct husb2_request, req)
+#define to_husb2_udc(x) container_of((x), struct husb2_udc, gadget)
+
+#define ep_index(ep)	((ep)->index)
+#define ep_can_dma(ep)	((ep)->capabilities & HUSB2_EP_CAP_DMA)
+#define ep_is_in(ep)	(((ep)->desc->bEndpointAddress			\
+				 & USB_ENDPOINT_DIR_MASK)		\
+			 == USB_DIR_IN)
+#define ep_is_isochronous(ep)						\
+	(((ep)->desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)	\
+	 == USB_ENDPOINT_XFER_ISOC)
+#define ep_is_control(ep) (ep_index(ep) == 0)
+#define ep_name(ep)	((ep)->ep.name)
+#define ep_is_idle(ep)	((ep)->state == EP_STATE_IDLE)
+
+#endif /* __LINUX_USB_GADGET_HUSB2_H */
Index: linux-2.6.19-avr1/sound/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/sound/Kconfig	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/sound/Kconfig	2006-12-03 19:23:24.000000000 +0100
@@ -62,6 +62,8 @@ source "sound/aoa/Kconfig"
 
 source "sound/arm/Kconfig"
 
+source "sound/avr32/Kconfig"
+
 source "sound/mips/Kconfig"
 
 # the following will depenend on the order of config.
Index: linux-2.6.19-avr1/sound/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/sound/Makefile	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/sound/Makefile	2006-12-03 19:23:24.000000000 +0100
@@ -6,6 +6,7 @@ obj-$(CONFIG_SOUND_PRIME) += sound_firmw
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
 obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/
+obj-$(CONFIG_SND) += avr32/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 ifeq ($(CONFIG_SND),y)
Index: linux-2.6.19-avr1/sound/avr32/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/sound/avr32/Kconfig	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,51 @@
+# ALSA AVR32 drivers
+
+menu "ALSA AVR32 devices"
+	depends on SND != n && AVR32
+
+config SND_ATMEL_AC97
+	tristate "Atmel AC97 Controller Driver"
+	depends on SND
+	select SND_PCM
+	select SND_AC97_CODEC
+	help
+	  ALSA sound driver for the Atmel AC97 controller.
+
+config SND_ATMEL_AC97_USE_ALSA_MALLOC_CALLS
+	bool "Use the built-in malloc calls in the alsa driver"
+	default n
+	depends on SND_ATMEL_AC97
+	help
+	  Say Y if the built-in malloc calls in the alsa driver should be
+	  used instead of the native dma_alloc_coherent and dma_free_coherent
+	  function calls. Enabling this feature may break the rmmod feature.
+
+config SND_ATMEL_AC97C_USE_PDC
+	bool "Use PDC for DMA transfers to/from the Atmel AC97 Controller"
+	default n
+	depends on SND_ATMEL_AC97
+	help
+	  Say Y if PDC (Peripheral DMA Controller) is used for DMA transfers
+	  to/from the Atmel AC97C instead of using the generic DMA framework.
+
+config SND_AT73C213
+	tristate "Atmel AT73C213 DAC driver"
+	depends on SND && SPI_ATMEL
+	select SND_PCM
+	help
+	  Say Y here if you want to use the Atmel AT73C213 external
+	  DAC on the ATSTK1000 development board.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called snd-at73c213.
+
+config SND_AT73C213_USE_ALSA_MALLOC_CALLS
+	bool "Use the built-in malloc calls in the alsa driver"
+	default n
+	depends on SND_AT73C213
+	help
+	  Say Y if the built-in malloc calls in the alsa driver should be
+	  used instead of the native dma_alloc_coherent and dma_free_coherent
+	  function calls. Enabling this feature may brake the rmmod feature.
+
+endmenu
Index: linux-2.6.19-avr1/sound/avr32/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/sound/avr32/Makefile	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,9 @@
+#
+# Makefile for ALSA
+#
+
+snd-atmel-ac97-objs		:= ac97c.o
+obj-$(CONFIG_SND_ATMEL_AC97)	+= snd-atmel-ac97.o
+
+snd-at73c213-objs		:= at73c213.o
+obj-$(CONFIG_SND_AT73C213)	+= snd-at73c213.o
Index: linux-2.6.19-avr1/sound/avr32/ac97c.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/sound/avr32/ac97c.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,1249 @@
+/*
+ * Driver for the Atmel AC97 Controller
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/ac97_codec.h>
+#ifndef SND_ATMEL_AC97_USE_ALSA_MALLOC_CALLS
+#include <sound/memalloc.h>
+#endif
+
+#include <asm/io.h>
+
+#include "ac97c.h"
+
+static DEFINE_MUTEX(opened_mutex);
+
+/* module parameters */
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for AC97 controller");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for AC97 controller");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable AC97 controller");
+
+#ifndef CONFIG_SND_ATMEL_AC97C_USE_PDC
+#include <asm/dma-controller.h>
+
+struct atmel_ac97_dma_info {
+	struct dma_request_cyclic req_tx;
+	struct dma_request_cyclic req_rx;
+	unsigned short rx_periph_id;
+	unsigned short tx_periph_id;
+};
+#endif
+
+
+typedef struct atmel_ac97 {
+	spinlock_t lock;
+	void __iomem *regs;
+	int period;
+
+	snd_pcm_substream_t *playback_substream;
+	snd_pcm_substream_t *capture_substream;
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	ac97_t *ac97;
+	ac97_bus_t *ac97_bus;
+	int irq;
+	int opened;
+	u64 cur_format;
+	unsigned int cur_rate;
+	struct clk *mck;
+	struct platform_device *pdev;
+        struct atmel_ac97_dma_info dma;
+} atmel_ac97_t;
+#define get_chip(card) ((atmel_ac97_t *)(card)->private_data)
+
+#define ac97c_writel(chip, reg, val)			\
+	__raw_writel((val), (chip)->regs + AC97C_##reg)
+#define ac97c_readl(chip, reg)				\
+	__raw_readl((chip)->regs + AC97C_##reg)
+
+/* PCM part */
+
+static snd_pcm_hardware_t snd_atmel_ac97_playback_hw = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED
+				  |SNDRV_PCM_INFO_MMAP
+				  |SNDRV_PCM_INFO_MMAP_VALID
+				  |SNDRV_PCM_INFO_BLOCK_TRANSFER
+				  |SNDRV_PCM_INFO_JOINT_DUPLEX),
+	.formats		= (SNDRV_PCM_FMTBIT_S16_BE|SNDRV_PCM_FMTBIT_S16_LE),
+	.rates			= (SNDRV_PCM_RATE_CONTINUOUS),
+	.rate_min		= 4000,
+	.rate_max		= 48000,
+	.channels_min		= 1,
+	.channels_max		= 6,
+	.buffer_bytes_max	= 64*1024,
+	.period_bytes_min	= 512,
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	.period_bytes_max	= 64*1024,
+#else
+	.period_bytes_max	= 4095,
+#endif
+	.periods_min		= 8,
+	.periods_max		= 1024,
+};
+
+static snd_pcm_hardware_t snd_atmel_ac97_capture_hw = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED
+				  |SNDRV_PCM_INFO_MMAP
+				  |SNDRV_PCM_INFO_MMAP_VALID
+				  |SNDRV_PCM_INFO_BLOCK_TRANSFER
+				  |SNDRV_PCM_INFO_JOINT_DUPLEX),
+	.formats		= (SNDRV_PCM_FMTBIT_S16_BE|SNDRV_PCM_FMTBIT_S16_LE),
+	.rates			= (SNDRV_PCM_RATE_CONTINUOUS),
+	.rate_min		= 4000,
+	.rate_max		= 48000,
+	.channels_min		= 1,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 64*1024,
+	.period_bytes_min	= 512,
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	.period_bytes_max	= 64*1024,
+#else
+	.period_bytes_max	= 4095,
+#endif
+	.periods_min		= 8,
+	.periods_max		= 1024,
+};
+
+/* Joint full duplex variables */
+unsigned int hw_rates[1];
+unsigned int hw_formats[1];
+struct snd_pcm_hw_constraint_list hw_constraint_rates;
+struct snd_pcm_hw_constraint_list hw_constraint_formats;
+
+/*
+ * PCM functions
+ */
+static int
+snd_atmel_ac97_playback_open(snd_pcm_substream_t *substream)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	mutex_lock(&opened_mutex);
+	chip->opened++;
+	runtime->hw = snd_atmel_ac97_playback_hw;
+	if (chip->cur_rate) {
+		runtime->hw.rate_min = chip->cur_rate;
+		runtime->hw.rate_max = chip->cur_rate;
+	}
+	if (chip->cur_format)
+		runtime->hw.formats = (1ULL<<chip->cur_format);
+	mutex_unlock(&opened_mutex);
+	chip->playback_substream = substream;
+	chip->period = 0;
+	return 0;
+}
+
+static int
+snd_atmel_ac97_capture_open(snd_pcm_substream_t *substream)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	mutex_lock(&opened_mutex);
+	chip->opened++;
+	runtime->hw = snd_atmel_ac97_capture_hw;
+	if (chip->cur_rate) {
+		runtime->hw.rate_min = chip->cur_rate;
+		runtime->hw.rate_max = chip->cur_rate;
+	}
+	if (chip->cur_format)
+		runtime->hw.formats = (1ULL<<chip->cur_format);
+	mutex_unlock(&opened_mutex);
+	chip->capture_substream = substream;
+	chip->period = 0;
+	return 0;
+}
+
+static int snd_atmel_ac97_playback_close(snd_pcm_substream_t *substream)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	mutex_lock(&opened_mutex);
+	chip->opened--;
+	if (!chip->opened) {
+		chip->cur_rate = 0;
+		chip->cur_format = 0;
+	}
+	mutex_unlock(&opened_mutex);
+	return 0;
+}
+
+static int snd_atmel_ac97_capture_close(snd_pcm_substream_t *substream)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	mutex_lock(&opened_mutex);
+	chip->opened--;
+	if (!chip->opened) {
+		chip->cur_rate = 0;
+		chip->cur_format = 0;
+	}
+	mutex_unlock(&opened_mutex);
+	return 0;
+}
+
+static int snd_atmel_ac97_playback_hw_params(snd_pcm_substream_t *substream,
+				    snd_pcm_hw_params_t *hw_params)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+#ifdef SND_ATMEL_AC97_USE_ALSA_MALLOC_CALLS
+	int err;
+	err = snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+
+	if (err < 0)
+		return err;
+
+	/* Set restrictions to params */
+	mutex_lock(&opened_mutex);
+	chip->cur_rate = params_rate(hw_params);
+	chip->cur_format = params_format(hw_params);
+	mutex_unlock(&opened_mutex);
+
+	return err;
+#else
+	int pg;
+	size_t size = params_buffer_bytes(hw_params);
+	struct snd_pcm_runtime *runtime;
+	struct snd_dma_buffer *dmab = NULL;
+
+	substream->dma_buffer.dev.type = SNDRV_DMA_TYPE_DEV;
+	snd_assert(substream != NULL, return -EINVAL);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -EINVAL);
+
+	/* Set restrictions to params */
+	mutex_lock(&opened_mutex);
+	chip->cur_rate = params_rate(hw_params);
+	chip->cur_format = params_format(hw_params);
+	mutex_unlock(&opened_mutex);
+
+	/* check if buffer is already allocated */
+	if (runtime->dma_buffer_p) {
+		size_t size_previouse;
+		int pg_previouse;
+
+		/* new buffer is smaler than previouse allocated buffer */
+		if (runtime->dma_buffer_p->bytes >= size) {
+			runtime->dma_bytes = size;
+			return 0; /* don't change buffer size */
+		}
+
+		size_previouse = runtime->dma_buffer_p->bytes;
+		pg_previouse = get_order(size_previouse);
+
+		dma_free_coherent(runtime->dma_buffer_p->dev.dev,
+				PAGE_SIZE << pg_previouse,
+				runtime->dma_buffer_p->area,
+				runtime->dma_buffer_p->addr);
+
+		kfree(runtime->dma_buffer_p);
+	}
+
+	dmab = kzalloc(sizeof(*dmab), GFP_KERNEL);
+	if (!dmab)
+		return -ENOMEM;
+
+	dmab->dev = substream->dma_buffer.dev;
+	dmab->bytes = 0;
+
+	pg = get_order(size);
+
+	dmab->area = dma_alloc_coherent(
+			substream->dma_buffer.dev.dev,
+			PAGE_SIZE << pg,
+			(dma_addr_t *)&dmab->addr,
+			GFP_KERNEL);
+
+	if (!dmab->area) {
+		kfree(dmab);
+		return -ENOMEM;
+	}
+
+	dmab->bytes = size;
+
+	snd_pcm_set_runtime_buffer(substream, dmab);
+	runtime->dma_bytes = size;
+	return 1;
+#endif
+}
+
+static int snd_atmel_ac97_capture_hw_params(snd_pcm_substream_t *substream,
+				    snd_pcm_hw_params_t *hw_params)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+#ifdef SND_ATMEL_AC97_USE_ALSA_MALLOC_CALLS
+	int err;
+	err = snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+
+	if (err < 0)
+		return err;
+
+	/* Set restrictions to params */
+	mutex_lock(&opened_mutex);
+	chip->cur_rate = params_rate(hw_params);
+	chip->cur_format = params_format(hw_params);
+	mutex_unlock(&opened_mutex);
+
+	return err;
+#else
+	int pg;
+	size_t size = params_buffer_bytes(hw_params);
+	struct snd_pcm_runtime *runtime;
+	struct snd_dma_buffer *dmab = NULL;
+
+	substream->dma_buffer.dev.type = SNDRV_DMA_TYPE_DEV;
+	snd_assert(substream != NULL, return -EINVAL);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -EINVAL);
+
+	/* Set restrictions to params */
+	mutex_lock(&opened_mutex);
+	chip->cur_rate = params_rate(hw_params);
+	chip->cur_format = params_format(hw_params);
+	mutex_unlock(&opened_mutex);
+
+	/* check if buffer is already allocated */
+	if (runtime->dma_buffer_p) {
+		size_t size_previouse;
+		int pg_previouse;
+
+		/* new buffer is smaler than previouse allocated buffer */
+		if (runtime->dma_buffer_p->bytes >= size) {
+			runtime->dma_bytes = size;
+			return 0; /* don't change buffer size */
+		}
+
+		size_previouse = runtime->dma_buffer_p->bytes;
+		pg_previouse = get_order(size_previouse);
+
+		dma_free_coherent(runtime->dma_buffer_p->dev.dev,
+				PAGE_SIZE << pg_previouse,
+				runtime->dma_buffer_p->area,
+				runtime->dma_buffer_p->addr);
+
+		kfree(runtime->dma_buffer_p);
+	}
+
+	dmab = kzalloc(sizeof(*dmab), GFP_KERNEL);
+	if (!dmab)
+		return -ENOMEM;
+
+	dmab->dev = substream->dma_buffer.dev;
+	dmab->bytes = 0;
+
+	pg = get_order(size);
+
+	dmab->area = dma_alloc_coherent(
+			substream->dma_buffer.dev.dev,
+			PAGE_SIZE << pg,
+			(dma_addr_t *)&dmab->addr,
+			GFP_KERNEL);
+
+	if (!dmab->area) {
+		kfree(dmab);
+		return -ENOMEM;
+	}
+
+	dmab->bytes = size;
+
+	snd_pcm_set_runtime_buffer(substream, dmab);
+	runtime->dma_bytes = size;
+	return 1;
+#endif
+}
+
+static int snd_atmel_ac97_playback_hw_free(snd_pcm_substream_t *substream)
+{
+#ifdef SND_ATMEL_AC97_USE_ALSA_MALLOC_CALLS
+	return snd_pcm_lib_free_pages(substream);
+#else
+	int pg;
+	struct snd_pcm_runtime *runtime;
+	struct snd_dma_buffer *dmab = NULL;
+
+	snd_assert(substream != NULL, return -EINVAL);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -EINVAL);
+	dmab = runtime->dma_buffer_p;
+
+	if (!dmab)
+		return 0;
+
+	if (!dmab->area)
+		return 0;
+
+	pg = get_order(dmab->bytes);
+	dma_free_coherent(dmab->dev.dev, PAGE_SIZE << pg, dmab->area, dmab->addr);
+	kfree(runtime->dma_buffer_p);
+	snd_pcm_set_runtime_buffer(substream, NULL);
+	return 0;
+#endif
+}
+
+static int snd_atmel_ac97_capture_hw_free(snd_pcm_substream_t *substream)
+{
+
+#ifdef SND_ATMEL_AC97_USE_ALSA_MALLOC_CALLS
+	return snd_pcm_lib_free_pages(substream);
+#else
+	int pg;
+	struct snd_pcm_runtime *runtime;
+	struct snd_dma_buffer *dmab = NULL;
+
+	snd_assert(substream != NULL, return -EINVAL);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -EINVAL);
+	dmab = runtime->dma_buffer_p;
+
+	if (!dmab)
+		return 0;
+
+	if (!dmab->area)
+		return 0;
+
+	pg = get_order(dmab->bytes);
+	dma_free_coherent(dmab->dev.dev, PAGE_SIZE << pg, dmab->area, dmab->addr);
+	kfree(runtime->dma_buffer_p);
+	snd_pcm_set_runtime_buffer(substream, NULL);
+	return 0;
+#endif
+}
+
+static int snd_atmel_ac97_playback_prepare(snd_pcm_substream_t *substream)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	struct platform_device *pdev = chip->pdev;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int block_size = frames_to_bytes(runtime, runtime->period_size);
+	unsigned long word = 0;
+	unsigned long buffer_size = 0;
+
+	dma_sync_single_for_device(&pdev->dev, runtime->dma_addr,
+			block_size * 2, DMA_TO_DEVICE);
+
+	/* Assign slots to channels */
+	switch (substream->runtime->channels) {
+        case 1:
+		word |= AC97C_CH_ASSIGN(PCM_LEFT, A);
+		break;
+	case 2:
+		/* Assign Left and Right slot to Channel A */
+		word |= AC97C_CH_ASSIGN(PCM_LEFT, A)
+			| AC97C_CH_ASSIGN(PCM_RIGHT, A);
+		break;
+        default:
+		/* TODO: support more than two channels */
+		return -EINVAL;
+		break;
+	}
+	ac97c_writel(chip, OCA, word);
+
+	/* Configure sample format and size */
+        word = AC97C_CMR_PDCEN | AC97C_CMR_SIZE_16;
+
+        switch (runtime->format){
+        case SNDRV_PCM_FORMAT_S16_LE:
+		word |= AC97C_CMR_CEM_LITTLE;
+		break;
+        case SNDRV_PCM_FORMAT_S16_BE:
+        default:
+		word &= ~AC97C_CMR_CEM_LITTLE;
+		break;
+        }
+
+	ac97c_writel(chip, CAMR, word);
+
+        /* Set variable rate if needed */
+        if (runtime->rate != 48000) {
+		word = ac97c_readl(chip, MR);
+		word |= AC97C_MR_VRA;
+		ac97c_writel(chip, MR, word);
+        } else {
+		/* Clear Variable Rate Bit */
+		word = ac97c_readl(chip, MR);
+		word &= ~AC97C_MR_VRA;
+		ac97c_writel(chip, MR, word);
+        }
+
+        /* Set rate */
+        snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);
+
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	/* Initialize and start the PDC */
+        ac97c_writel(chip, CATPR, runtime->dma_addr);
+	ac97c_writel(chip, CATCR, block_size / 4);
+	ac97c_writel(chip, CATNPR, runtime->dma_addr + block_size);
+	ac97c_writel(chip, CATNCR, block_size / 4);
+	ac97c_writel(chip, PTCR, PDC_PTCR_TXTEN);
+	/* Enable Channel A interrupts */
+	ac97c_writel(chip, IER, AC97C_SR_CAEVT);
+#else
+	buffer_size = frames_to_bytes(runtime, runtime->period_size) *
+		runtime->periods;
+
+	chip->dma.req_tx.buffer_size = buffer_size;
+        chip->dma.req_tx.periods = runtime->periods;
+
+	BUG_ON(chip->dma.req_tx.buffer_size !=
+			(chip->dma.req_tx.periods *
+			 frames_to_bytes(runtime, runtime->period_size)));
+
+        chip->dma.req_tx.buffer_start = runtime->dma_addr;
+        chip->dma.req_tx.data_reg = (dma_addr_t)(chip->regs + AC97C_CATHR + 2);
+        chip->dma.req_tx.periph_id = chip->dma.tx_periph_id;
+        chip->dma.req_tx.direction = DMA_DIR_MEM_TO_PERIPH;
+        chip->dma.req_tx.width = DMA_WIDTH_16BIT;
+        chip->dma.req_tx.dev_id = chip;
+#endif
+
+	return 0;
+}
+
+static int snd_atmel_ac97_capture_prepare(snd_pcm_substream_t *substream)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	struct platform_device *pdev = chip->pdev;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int block_size = frames_to_bytes(runtime, runtime->period_size);
+	unsigned long word = 0;
+	unsigned long buffer_size = 0;
+
+	dma_sync_single_for_device(&pdev->dev, runtime->dma_addr,
+			block_size * 2, DMA_FROM_DEVICE);
+
+	/* Assign slots to channels */
+	switch (substream->runtime->channels) {
+        case 1:
+		word |= AC97C_CH_ASSIGN(PCM_LEFT, A);
+		break;
+        case 2:
+		/* Assign Left and Right slot to Channel A */
+		word |= AC97C_CH_ASSIGN(PCM_LEFT, A)
+			| AC97C_CH_ASSIGN(PCM_RIGHT, A);
+		break;
+	default:
+		/* TODO: support more than two channels */
+		return -EINVAL;
+		break;
+	}
+	ac97c_writel(chip, ICA, word);
+
+	/* Configure sample format and size */
+        word = AC97C_CMR_PDCEN | AC97C_CMR_SIZE_16;
+
+	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		word |= AC97C_CMR_CEM_LITTLE;
+		break;
+	case SNDRV_PCM_FORMAT_S16_BE:
+	default:
+		word &= ~(AC97C_CMR_CEM_LITTLE);
+		break;
+	}
+
+	ac97c_writel(chip, CAMR, word);
+
+	/* Set variable rate if needed */
+	if (runtime->rate != 48000) {
+		word = ac97c_readl(chip, MR);
+		word |= AC97C_MR_VRA;
+		ac97c_writel(chip, MR, word);
+	} else {
+		/* Clear Variable Rate Bit */
+		word = ac97c_readl(chip, MR);
+		word &= ~(AC97C_MR_VRA);
+		ac97c_writel(chip, MR, word);
+	}
+
+	/* Set rate */
+	snd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);
+
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	/* Initialize and start the PDC */
+	ac97c_writel(chip, CARPR, runtime->dma_addr);
+	ac97c_writel(chip, CARCR, block_size / 4);
+	ac97c_writel(chip, CARNPR, runtime->dma_addr + block_size);
+	ac97c_writel(chip, CARNCR, block_size / 4);
+	ac97c_writel(chip, PTCR, PDC_PTCR_RXEN);
+	/* Enable Channel A interrupts */
+	ac97c_writel(chip, IER, AC97C_SR_CAEVT);
+#else
+	buffer_size = frames_to_bytes(runtime, runtime->period_size) *
+		runtime->periods;
+
+	chip->dma.req_rx.buffer_size = buffer_size;
+	chip->dma.req_rx.periods = runtime->periods;
+
+	BUG_ON(chip->dma.req_rx.buffer_size !=
+			(chip->dma.req_rx.periods *
+			 frames_to_bytes(runtime, runtime->period_size)));
+
+	chip->dma.req_rx.buffer_start = runtime->dma_addr;
+	chip->dma.req_rx.data_reg = (dma_addr_t)(chip->regs + AC97C_CARHR + 2);
+	chip->dma.req_rx.periph_id = chip->dma.rx_periph_id;
+	chip->dma.req_rx.direction = DMA_DIR_PERIPH_TO_MEM;
+	chip->dma.req_rx.width = DMA_WIDTH_16BIT;
+	chip->dma.req_rx.dev_id = chip;
+#endif
+
+	return 0;
+}
+
+static int snd_atmel_ac97_playback_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long camr;
+	int flags, err = 0;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	camr = ac97c_readl(chip, CAMR);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		err = dma_prepare_request_cyclic(chip->dma.req_tx.req.dmac,
+				&chip->dma.req_tx);
+		dma_start_request(chip->dma.req_tx.req.dmac,
+				chip->dma.req_tx.req.channel);
+		camr |= (AC97C_CMR_CENA
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+				|AC97C_CMR_TXRDY
+#endif
+			);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		err = dma_stop_request(chip->dma.req_tx.req.dmac,
+				chip->dma.req_tx.req.channel);
+		if (chip->opened <= 1) {
+			camr &= ~(AC97C_CMR_CENA
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+					|AC97C_CMR_TXRDY
+#endif
+				 );
+		}
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+		else {
+			camr &= ~(AC97C_CMR_TXRDY);
+		}
+#endif
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	ac97c_writel(chip, CAMR, camr);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return err;
+}
+
+static int snd_atmel_ac97_capture_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long camr;
+	int flags, err = 0;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	camr = ac97c_readl(chip, CAMR);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		err = dma_prepare_request_cyclic(chip->dma.req_rx.req.dmac,
+				&chip->dma.req_rx);
+		dma_start_request(chip->dma.req_rx.req.dmac,
+				chip->dma.req_rx.req.channel);
+		camr |= (AC97C_CMR_CENA
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+			 | AC97C_CMR_RXRDY
+#endif
+			);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		err = dma_stop_request(chip->dma.req_rx.req.dmac,
+				chip->dma.req_rx.req.channel);
+		mutex_lock(&opened_mutex);
+		if (chip->opened <= 1) {
+			camr &= ~(AC97C_CMR_CENA
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+					| AC97C_CMR_RXRDY
+#endif
+				 );
+		}
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+		else {
+			  camr &= ~(AC97C_CSR_RXRDY);
+		}
+#endif
+		mutex_unlock(&opened_mutex);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	ac97c_writel(chip, CAMR, camr);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return err;
+}
+
+static snd_pcm_uframes_t snd_atmel_ac97_playback_pointer(snd_pcm_substream_t *substream)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	unsigned long bytes;
+
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	bytes = ac97c_readl(chip, CATPR) - runtime->dma_addr;
+#else
+        bytes = (dma_get_current_pos
+			(chip->dma.req_tx.req.dmac,
+			 chip->dma.req_tx.req.channel) - runtime->dma_addr);
+#endif
+	pos = bytes_to_frames(runtime, bytes);
+	if (pos >= runtime->buffer_size)
+		pos -= runtime->buffer_size;
+
+	return pos;
+}
+
+static snd_pcm_uframes_t snd_atmel_ac97_capture_pointer(snd_pcm_substream_t *substream)
+{
+	atmel_ac97_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	unsigned long bytes;
+
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	bytes = ac97c_readl(chip, CARPR) - runtime->dma_addr;
+#else
+        bytes = (dma_get_current_pos
+			(chip->dma.req_rx.req.dmac,chip->dma.req_rx.req.channel) -
+			runtime->dma_addr);
+#endif
+	pos = bytes_to_frames(runtime, bytes);
+	if (pos >= runtime->buffer_size)
+		pos -= runtime->buffer_size;
+
+
+	return pos;
+}
+
+static snd_pcm_ops_t atmel_ac97_playback_ops = {
+	.open		= snd_atmel_ac97_playback_open,
+	.close		= snd_atmel_ac97_playback_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_atmel_ac97_playback_hw_params,
+	.hw_free	= snd_atmel_ac97_playback_hw_free,
+	.prepare	= snd_atmel_ac97_playback_prepare,
+	.trigger	= snd_atmel_ac97_playback_trigger,
+	.pointer	= snd_atmel_ac97_playback_pointer,
+};
+
+static snd_pcm_ops_t atmel_ac97_capture_ops = {
+	.open		= snd_atmel_ac97_capture_open,
+	.close		= snd_atmel_ac97_capture_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_atmel_ac97_capture_hw_params,
+	.hw_free	= snd_atmel_ac97_capture_hw_free,
+	.prepare	= snd_atmel_ac97_capture_prepare,
+	.trigger	= snd_atmel_ac97_capture_trigger,
+	.pointer	= snd_atmel_ac97_capture_pointer,
+};
+
+static struct ac97_pcm atmel_ac97_pcm_defs[] __devinitdata = {
+	/* Playback */
+	{
+		.exclusive = 1,
+		.r = { {
+			.slots = ((1 << AC97_SLOT_PCM_LEFT)
+					| (1 << AC97_SLOT_PCM_RIGHT)
+					| (1 << AC97_SLOT_PCM_CENTER)
+					| (1 << AC97_SLOT_PCM_SLEFT)
+					| (1 << AC97_SLOT_PCM_SRIGHT)
+					| (1 << AC97_SLOT_LFE)),
+		} }
+	},
+	/* PCM in */
+	{
+		.stream = 1,
+		.exclusive = 1,
+		.r = { {
+			.slots = ((1 << AC97_SLOT_PCM_LEFT)
+					| (1 << AC97_SLOT_PCM_RIGHT)),
+		} }
+	},
+	/* Mic in */
+	{
+		.stream = 1,
+		.exclusive = 1,
+		.r = { {
+			.slots = (1<<AC97_SLOT_MIC),
+		} }
+	},
+};
+
+static int __devinit snd_atmel_ac97_pcm_new(atmel_ac97_t *chip)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	err = snd_ac97_pcm_assign(chip->ac97_bus,
+			ARRAY_SIZE(atmel_ac97_pcm_defs),
+			atmel_ac97_pcm_defs);
+	if (err)
+		return err;
+
+	err = snd_pcm_new(chip->card, "Atmel-AC97", 0, 1, 1, &pcm);
+	if (err)
+		return err;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&atmel_ac97_playback_ops);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&atmel_ac97_capture_ops);
+
+#ifdef SND_ATMEL_AC97_USE_ALSA_MALLOC_CALLS
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      &chip->pdev->dev,
+					      128 * 1024, 128 * 1024);
+#endif
+
+	pcm->private_data = chip;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "Atmel-AC97");
+	chip->pcm = pcm;
+
+	return 0;
+}
+
+/* Mixer part */
+static int snd_atmel_ac97_mixer_new(atmel_ac97_t *chip)
+{
+	int err;
+	ac97_template_t template;
+
+	memset(&template, 0, sizeof(template));
+	template.private_data = chip;
+	err = snd_ac97_mixer(chip->ac97_bus, &template, &chip->ac97);
+
+	return err;
+}
+
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+static irqreturn_t snd_atmel_ac97_interrupt(int irq, void *dev_id)
+{
+	atmel_ac97_t *chip = dev_id;
+	unsigned long status;
+
+	status = ac97c_readl(chip, SR);
+
+	if (status & AC97C_SR_CAEVT) {
+		snd_pcm_runtime_t *runtime;
+		int offset, next_period, block_size;
+		unsigned long casr;
+
+		/* FIXME: separate playback from capture */
+		runtime = chip->playback_substream->runtime;
+		block_size = frames_to_bytes(runtime, runtime->period_size);
+
+		casr = ac97c_readl(chip, CASR);
+
+		if (casr & AC97C_CSR_ENDTX) {
+			chip->period++;
+			if (chip->period == runtime->periods)
+				chip->period = 0;
+			next_period = chip->period + 1;
+			if (next_period == runtime->periods)
+				next_period = 0;
+
+			offset = block_size * next_period;
+
+			ac97c_writel(chip, CATNPR,
+				     runtime->dma_addr + offset);
+			ac97c_writel(chip, CATNCR, block_size / 4);
+
+			snd_pcm_period_elapsed(chip->playback_substream);
+		}
+		else if (casr & AC97C_CSR_ENDRX) {
+			chip->period++;
+			if (chip->period == runtime->periods)
+				chip->period = 0;
+			next_period = chip->period + 1;
+			if (next_period == runtime->periods)
+				next_period = 0;
+
+			offset = block_size * next_period;
+
+			ac97c_writel(chip, CARNPR,
+				     runtime->dma_addr + offset);
+			ac97c_writel(chip, CARNCR, block_size / 4);
+
+			snd_pcm_period_elapsed(chip->capture_substream);
+		} else {
+			snd_printk(KERN_INFO
+			       "atmel-ac97: spurious interrupt, status = 0x%08lx\n",
+			       (unsigned long)casr);
+		}
+	} else {
+		snd_printk(KERN_INFO
+		       "atmel-ac97: spurious interrupt, status = 0x%08lx\n",
+		       status);
+	}
+
+	(volatile int)ac97c_readl(chip, SR);
+
+	return IRQ_HANDLED;
+}
+
+#else
+
+static void atmel_ac97_error(struct dma_request *_req)
+{
+	struct dma_request_cyclic *req = to_dma_request_cyclic(_req);
+
+	printk(KERN_WARNING
+	       "DMA Controller error, channel %d (AC97C)\n",
+	       req->req.channel);
+}
+
+static void atmel_ac97_block_complete(struct dma_request *_req)
+{
+	struct dma_request_cyclic *req = to_dma_request_cyclic(_req);
+	atmel_ac97_t *chip = req->dev_id;
+	if (req->periph_id == chip->dma.tx_periph_id)
+		snd_pcm_period_elapsed(chip->playback_substream);
+	else
+		snd_pcm_period_elapsed(chip->capture_substream);
+}
+
+#endif
+
+/* CODEC part */
+
+static void snd_atmel_ac97_write(ac97_t *ac97, unsigned short reg,
+				 unsigned short val)
+{
+	atmel_ac97_t *chip = ac97->private_data;
+	unsigned long word;
+	int timeout = 40;
+
+	word = (reg & 0x7f) << 16 | val;
+
+	do {
+		if (ac97c_readl(chip, COSR) & AC97C_CSR_TXRDY) {
+			ac97c_writel(chip, COTHR, word);
+			return;
+		}
+		udelay(1);
+	} while (--timeout);
+
+	snd_printk(KERN_WARNING "atmel-ac97: codec write timeout\n");
+}
+
+static unsigned short snd_atmel_ac97_read(ac97_t *ac97,
+					  unsigned short reg)
+{
+	atmel_ac97_t *chip = ac97->private_data;
+	unsigned long word;
+	int timeout = 40;
+	int write = 10;
+
+	word = (0x80 | (reg & 0x7f)) << 16;
+
+	if ((ac97c_readl(chip, COSR) & AC97C_CSR_RXRDY) != 0)
+		ac97c_readl(chip, CORHR);
+
+retry_write:
+	timeout = 40;
+
+	do {
+                if ((ac97c_readl(chip, COSR) & AC97C_CSR_TXRDY) != 0) {
+			ac97c_writel(chip, COTHR, word);
+			goto read_reg;
+                }
+		mdelay(10);
+	} while (--timeout);
+
+	if (!--write)
+		goto timed_out;
+	goto retry_write;
+
+read_reg:
+	do {
+		if ((ac97c_readl(chip, COSR) & AC97C_CSR_RXRDY) != 0){
+			unsigned short val = ac97c_readl(chip, CORHR);
+			return val;
+		}
+		mdelay(10);
+	} while (--timeout);
+
+	if (!--write)
+		goto timed_out;
+	goto retry_write;
+
+timed_out:
+	snd_printk(KERN_INFO "atmel-ac97: codec read timeout\n");
+	return 0xffff;
+}
+
+static void snd_atmel_ac97_reset(atmel_ac97_t *chip)
+{
+	/* TODO: Perform hard reset of codec as well */
+	ac97c_writel(chip, MR, AC97C_MR_WRST);
+	mdelay(1);
+	ac97c_writel(chip, MR, AC97C_MR_ENA);
+}
+
+static void snd_atmel_ac97_destroy(snd_card_t *card)
+{
+	atmel_ac97_t *chip = get_chip(card);
+
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	if (chip->irq != -1)
+		free_irq(chip->irq, chip);
+#endif
+	if (chip->regs)
+		iounmap(chip->regs);
+
+	if (chip->mck) {
+		clk_disable(chip->mck);
+		clk_put(chip->mck);
+	}
+
+#ifndef CONFIG_SND_ATMEL_AC97C_USE_PDC
+        if (chip->dma.req_tx.req.dmac){
+		dma_release_channel(chip->dma.req_tx.req.dmac,
+				    chip->dma.req_tx.req.channel);
+        }
+        if (chip->dma.req_rx.req.dmac) {
+		dma_release_channel(chip->dma.req_rx.req.dmac,
+				    chip->dma.req_rx.req.channel);
+        }
+#endif
+}
+
+static int __devinit snd_atmel_ac97_create(snd_card_t *card,
+					   struct platform_device *pdev)
+{
+	static ac97_bus_ops_t ops = {
+		.write	= snd_atmel_ac97_write,
+		.read	= snd_atmel_ac97_read,
+	};
+	atmel_ac97_t *chip = get_chip(card);
+	struct resource *regs;
+	struct clk *mck;
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	int irq;
+#endif
+        int err;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+#endif
+
+	mck = clk_get(&pdev->dev, "mck");
+	if (IS_ERR(mck))
+		return PTR_ERR(mck);
+	clk_enable(mck);
+	chip->mck = mck;
+
+	card->private_free = snd_atmel_ac97_destroy;
+
+	spin_lock_init(&chip->lock);
+	chip->card = card;
+	chip->pdev = pdev;
+	chip->irq = -1;
+
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	err = request_irq(irq, snd_atmel_ac97_interrupt, 0,
+			  "ac97", chip);
+	if (err) {
+		snd_printk("unable to request IRQ%d\n", irq);
+		return err;
+	}
+	chip->irq = irq;
+#endif
+
+	chip->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!chip->regs)
+		return -ENOMEM;
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);
+
+	return err;
+}
+
+static int __devinit snd_atmel_ac97_probe(struct platform_device *pdev)
+{
+	static int dev;
+	snd_card_t *card;
+	atmel_ac97_t *chip;
+	int err;
+        int ch;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	err = -ENOMEM;
+
+	mutex_init(&opened_mutex);
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+			    sizeof(atmel_ac97_t));
+	if (!card)
+		goto out;
+	chip = get_chip(card);
+
+	err = snd_atmel_ac97_create(card, pdev);
+	if (err)
+		goto out_free_card;
+
+	snd_atmel_ac97_reset(chip);
+
+	err = snd_atmel_ac97_mixer_new(chip);
+	if (err)
+		goto out_free_card;
+
+	err = snd_atmel_ac97_pcm_new(chip);
+	if (err)
+		goto out_free_card;
+
+#ifndef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	/* TODO: Get this information from the platform device */
+	chip->dma.req_tx.req.dmac = find_dma_controller(0);
+	if (!chip->dma.req_tx.req.dmac) {
+		printk(KERN_ERR
+		       "atmel-ac97c: No DMA controller for TX, aborting\n");
+		goto out_free_card;
+	}
+	chip->dma.req_rx.req.dmac = find_dma_controller(0);
+	if (!chip->dma.req_rx.req.dmac) {
+		snd_printk(KERN_ERR
+		       "atmel-ac97c: No DMA controller available for RX, aborting\n");
+		goto out_free_card;
+	}
+
+	chip->dma.rx_periph_id = 3;
+	chip->dma.tx_periph_id = 4;
+
+	ch = dma_alloc_channel(chip->dma.req_tx.req.dmac);
+	if (ch < 0) {
+		printk(KERN_ERR
+		       "atmel-ac97c: Unable to allocate TX DMA channel, aborting\n");
+		goto out_free_card;
+	}
+	chip->dma.req_tx.req.channel = ch;
+	chip->dma.req_tx.width = DMA_WIDTH_16BIT;
+	chip->dma.req_tx.req.block_complete = atmel_ac97_block_complete;
+	chip->dma.req_tx.req.error = atmel_ac97_error;
+
+	ch = dma_alloc_channel(chip->dma.req_rx.req.dmac);
+	if (ch < 0) {
+		snd_printk(KERN_ERR
+		       "atmel-ac97c: Unable to allocate RX DMA channel, aborting\n");
+		goto out_free_card;
+	}
+	chip->dma.req_rx.req.channel = ch;
+	chip->dma.req_rx.width = DMA_WIDTH_16BIT;
+	chip->dma.req_rx.req.block_complete = atmel_ac97_block_complete;
+	chip->dma.req_rx.req.error = atmel_ac97_error;
+#endif
+
+	strcpy(card->driver, "ac97c");
+	strcpy(card->shortname, "Atmel-AC97");
+#ifdef CONFIG_SND_ATMEL_AC97C_USE_PDC
+	sprintf(card->longname, "Atmel AVR32 AC97 Controller at 0x%p, irq %i",
+		chip->regs, chip->irq);
+#else
+	sprintf(card->longname, "Atmel AVR32 AC97 Controller at 0x%p, dma rx %i and tx %i",
+		chip->regs, chip->dma.rx_periph_id, chip->dma.tx_periph_id);
+#endif
+
+	err = snd_card_register(card);
+	if (err)
+		goto out_free_card;
+
+	platform_set_drvdata(pdev, card);
+	dev++;
+	return 0;
+
+out_free_card:
+	snd_card_free(card);
+out:
+	return err;
+}
+
+static int __devexit snd_atmel_ac97_remove(struct platform_device *pdev)
+{
+	snd_card_t *card = platform_get_drvdata(pdev);
+
+	snd_card_free(card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct platform_driver atmel_ac97_driver = {
+	.probe		= snd_atmel_ac97_probe,
+	.remove		= __devexit_p(snd_atmel_ac97_remove),
+	.driver		= {
+		.name	= "ac97c",
+	},
+};
+
+static int __init atmel_ac97_init(void)
+{
+	return platform_driver_register(&atmel_ac97_driver);
+}
+
+static void __exit atmel_ac97_exit(void)
+{
+	platform_driver_unregister(&atmel_ac97_driver);
+}
+
+module_init(atmel_ac97_init);
+module_exit(atmel_ac97_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Driver for Atmel AC97 Controller");
+MODULE_AUTHOR("Haavard Skinnemoen <hskinnemoen@atmel.com>");
Index: linux-2.6.19-avr1/sound/avr32/ac97c.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/sound/avr32/ac97c.h	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,71 @@
+/*
+ * Register definitions for the Atmel AC97 Controller.
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __SOUND_AVR32_AC97C_H
+#define __SOUND_AVR32_AC97C_H
+
+#define AC97C_MR		0x08
+#define AC97C_ICA		0x10
+#define AC97C_OCA		0x14
+#define AC97C_CARHR		0x20
+#define AC97C_CATHR		0x24
+#define AC97C_CASR		0x28
+#define AC97C_CAMR		0x2c
+#define AC97C_CBRHR		0x30
+#define AC97C_CBTHR		0x34
+#define AC97C_CBSR		0x38
+#define AC97C_CBMR		0x3c
+#define AC97C_CORHR		0x40
+#define AC97C_COTHR		0x44
+#define AC97C_COSR		0x48
+#define AC97C_COMR		0x4c
+#define AC97C_SR		0x50
+#define AC97C_IER		0x54
+#define AC97C_IDR		0x58
+#define AC97C_IMR		0x5c
+#define AC97C_VERSION		0xfc
+
+#define AC97C_CATPR		PDC_TPR
+#define AC97C_CATCR		PDC_TCR
+#define AC97C_CATNPR		PDC_TNPR
+#define AC97C_CATNCR		PDC_TNCR
+#define AC97C_CARPR		PDC_RPR
+#define AC97C_CARCR		PDC_RCR
+#define AC97C_CARNPR		PDC_RNPR
+#define AC97C_CARNCR		PDC_RNCR
+#define AC97C_PTCR		PDC_PTCR
+
+#define AC97C_MR_ENA		(1 << 0)
+#define AC97C_MR_WRST		(1 << 1)
+#define AC97C_MR_VRA		(1 << 2)
+
+#define AC97C_CSR_TXRDY		(1 << 0)
+#define AC97C_CSR_UNRUN		(1 << 2)
+#define AC97C_CSR_RXRDY		(1 << 4)
+#define AC97C_CSR_ENDTX		(1 << 10)
+#define AC97C_CSR_ENDRX		(1 << 14)
+
+#define AC97C_CMR_SIZE_20	(0 << 16)
+#define AC97C_CMR_SIZE_18	(1 << 16)
+#define AC97C_CMR_SIZE_16	(2 << 16)
+#define AC97C_CMR_SIZE_10	(3 << 16)
+#define AC97C_CMR_CEM_LITTLE	(1 << 18)
+#define AC97C_CMR_CEM_BIG	(0 << 18)
+#define AC97C_CMR_CENA		(1 << 21)
+#define AC97C_CMR_PDCEN		(1 << 22)
+
+#define AC97C_SR_CAEVT		(1 << 3)
+
+#define AC97C_CH_ASSIGN(slot, channel)					\
+	(AC97C_CHANNEL_##channel << (3 * (AC97_SLOT_##slot - 3)))
+#define AC97C_CHANNEL_NONE	0x0
+#define AC97C_CHANNEL_A		0x1
+#define AC97C_CHANNEL_B		0x2
+
+#endif /* __SOUND_AVR32_AC97C_H */
Index: linux-2.6.19-avr1/sound/avr32/at73c213.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/sound/avr32/at73c213.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,1295 @@
+/*
+ * Driver for the at73c213 16-bit stereo DAC on Atmel ATSTK1000
+ *
+ * Copyright (C) 2006 Atmel Norway
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+#undef DEBUG
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/initval.h>
+#include <sound/driver.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#ifndef SND_AT73C213_USE_ALSA_MALLOC_CALLS
+#include <sound/memalloc.h>
+#endif
+
+#include <linux/spi/spi.h>
+
+#include <asm/io.h>
+#include <asm/processor.h>
+
+#include "at73c213.h"
+
+/* module parameters */
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+/* Register defines */
+#define PIOA_BASE	0xFFE02800
+#define SSC0_BASE	0xFFE01C00
+#define PM_BASE		0xFFF00000
+
+#define PM_CKSEL	0x04
+#define PM_APBAMASK	0x10
+#define PM_GCCTRL	0x60
+
+#define PIO_PER		0x00
+#define PIO_PDR		0x04
+#define PIO_PUER	0x64
+#define PIO_ASR		0x70
+#define PIO_BSR		0x74
+
+#define SSC_CMR		0x04
+#define SSC_CR		0x00
+#define SSC_TCMR	0x18
+#define SSC_TFMR	0x1C
+
+/* SSC register definitions */
+#define SSC_CR		0x00
+#define SSC_CMR		0x04
+#define SSC_TCMR	0x18
+#define SSC_TFMR	0x1C
+#define SSC_THR		0x24
+#define SSC_SR		0x40
+#define SSC_IER		0x44
+#define SSC_IDR		0x48
+#define SSC_IMR		0x4C
+
+/* SSC fields definitions */
+#define SSC_CR_TXEN	0x00000100
+#define SSC_CR_TXDIS	0x00000200
+#define SSC_CR_SWRST	0x00008000
+
+/* SSC interrupt definitions */
+#define SSC0_IRQ	10
+#define SSC_INT_ENDTX	0x00000004
+#define SSC_INT_TXBUFE	0x00000008
+
+/* PDC register definitions */
+#define PDC_RPR		0x100
+#define PDC_RCR		0x104
+#define PDC_TPR		0x108
+#define PDC_TCR		0x10c
+#define PDC_RNPR	0x110
+#define PDC_RNCR	0x114
+#define PDC_TNPR	0x118
+#define PDC_TNCR	0x11c
+#define PDC_PTCR	0x120
+#define PDC_PTSR	0x124
+
+/* PDC fields definitions */
+#define PDC_PTCR_RXTEN	0x0001
+#define PDC_PTCR_RXTDIS	0x0002
+#define PDC_PTCR_TXTEN	0x0100
+#define PDC_PTCR_TXTDIS 0x0200
+
+static int bitrate;
+static int gclk_div;
+static int ssc_div;
+static int spi = 0;
+static int ssc = 1;
+
+module_param(spi, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+MODULE_PARM_DESC(spi, "Which SPI interface to use to communicate with the at73c213");
+module_param(ssc, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+MODULE_PARM_DESC(ssc, "Which SSC interface to use to communicate with the at73c213");
+
+/* Initial AT73C213 register values */
+static unsigned char snd_at73c213_original_image[18] =
+{
+	0x00,	/* 00 - CTRL    */
+	0x05,	/* 01 - LLIG    */
+	0x05,	/* 02 - RLIG    */
+	0x08,	/* 03 - LPMG    */
+	0x08,	/* 04 - RPMG    */
+	0x00,	/* 05 - LLOG    */
+	0x00,	/* 06 - RLOG    */
+	0x22,	/* 07 - OLC     */
+	0x09,	/* 08 - MC      */
+	0x00,	/* 09 - CSFC    */
+	0x00,	/* 0A - MISC    */
+	0x00,	/* 0B -         */
+	0x00,	/* 0C - PRECH   */
+	0x05,	/* 0D - AUXG    */
+	0x00,	/* 0E -         */
+	0x00,	/* 0F -         */
+	0x00,	/* 10 - RST     */
+	0x00,	/* 11 - PA_CTRL */
+};
+
+/* chip-specific data */
+struct snd_at73c213 {
+	snd_card_t		*card;
+	snd_pcm_t		*pcm;
+	snd_pcm_substream_t	*substream;
+	int			irq;
+	int			period;
+	void __iomem		*regs;
+	struct clk		*ssc_clk;
+	struct spi_device	*spi;
+	u8			spi_wbuffer[2];
+	u8			spi_rbuffer[2];
+	/* image of the SPI registers in AT73C213 */
+	u8			image[18];
+	spinlock_t		lock;
+	struct platform_device	*pdev;
+};
+
+#define get_chip(card) ((struct snd_at73c213 *)card->private_data)
+
+static int
+snd_at73c213_write_reg(struct snd_at73c213 *chip, u8 reg, u8 val)
+{
+	struct spi_message msg;
+	struct spi_transfer msg_xfer = {
+		.len		= 2,
+		.cs_change	= 0,
+	};
+
+	spi_message_init(&msg);
+
+	chip->spi_wbuffer[0] = reg;
+	chip->spi_wbuffer[1] = val;
+
+	msg_xfer.tx_buf = chip->spi_wbuffer;
+	msg_xfer.rx_buf = chip->spi_rbuffer;
+	spi_message_add_tail(&msg_xfer, &msg);
+
+	return spi_sync(chip->spi, &msg);
+}
+
+#define write_reg(_spi, reg, val)				\
+	do {							\
+		retval = snd_at73c213_write_reg(_spi, reg, val);	\
+		if (retval)					\
+			goto out;				\
+	} while (0)
+
+static snd_pcm_hardware_t snd_at73c213_playback_hw = {
+	.info		= SNDRV_PCM_INFO_INTERLEAVED |
+			  SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.formats	= SNDRV_PCM_FMTBIT_S16_BE,
+	.rates		= SNDRV_PCM_RATE_CONTINUOUS,
+	.rate_min	= 8000,  /* This will be overwritten with bitrate */
+	.rate_max	= 50000, /* This will be overwritten with bitrate */
+	.channels_min	= 2,
+	.channels_max	= 2,
+	.buffer_bytes_max = 64 * 1024 - 1,
+	.period_bytes_min = 512,
+	.period_bytes_max = 64 * 1024 - 1,
+	.periods_min	= 4,
+	.periods_max	= 1024,
+};
+
+/* calculate and set bitrate and divisions */
+static int snd_at73c213_set_bitrate_and_div(void)
+{
+	extern struct avr32_cpuinfo boot_cpu_data;
+	unsigned long pll0_hz, apba_hz;
+	unsigned long apba_realdiv, gclk_realdiv, ssc_realdiv, wanted_bitrate;
+	char cpusel, ahbsel, apbasel;
+	int regval;
+
+	regval = __raw_readl((void __iomem *)PM_BASE + PM_CKSEL);
+	wanted_bitrate = 48000;
+
+	cpusel = regval & 0x07;
+	ahbsel = (regval>>8) & 0x07;
+	apbasel = (regval>>16) & 0x07;
+
+	/* FIXME: Use the clk framework for this */
+	if ((regval&(1<<7)) != 0) {
+		pll0_hz = clk_get_rate(boot_cpu_data.clk)/(1<<(cpusel+1));
+	} else {
+		pll0_hz = clk_get_rate(boot_cpu_data.clk);
+	}
+
+	if ((regval&(1<<23)) != 0) {
+		apba_hz = pll0_hz/(1<<(apbasel+1));
+		apba_realdiv = (1<<(apbasel+1));
+	} else {
+		apba_hz = pll0_hz;
+		apba_realdiv = 1;
+	}
+
+calculate:
+	/* Adjust bitrate as close as possible to 48000 Hz */
+	gclk_realdiv = pll0_hz/(wanted_bitrate*256);
+	ssc_realdiv = 2 * apba_realdiv * gclk_realdiv;
+
+	if ((gclk_realdiv % 2) == 0)
+		goto setbitrates;
+
+	if(wanted_bitrate >= 22050 && wanted_bitrate <= 48000)
+		wanted_bitrate -= 50;
+	else if (wanted_bitrate < 22050)
+		wanted_bitrate = 48050;
+	else if (wanted_bitrate <= 50000)
+		wanted_bitrate += 50;
+	else {
+		printk(KERN_ERR "at73c213 could not set dividers for a valid bitrate\n");
+		return -EINVAL;
+	}
+
+	goto calculate;
+
+setbitrates:
+	bitrate = pll0_hz/(gclk_realdiv*256);
+	gclk_div = (gclk_realdiv/2)-1;
+	ssc_realdiv = 2*apba_realdiv*gclk_realdiv;
+	ssc_div = ssc_realdiv/(2*apba_realdiv);
+
+	printk(KERN_INFO "at73c213: bitrate is %d Hz\n", bitrate);
+
+	return 0;
+}
+
+/* open callback */
+static int snd_at73c213_pcm_open(snd_pcm_substream_t *substream)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_at73c213_playback_hw.rate_min = bitrate;
+	snd_at73c213_playback_hw.rate_max = bitrate;
+	runtime->hw = snd_at73c213_playback_hw;
+	chip->substream = substream;
+
+	return 0;
+}
+
+/* close callback */
+static int snd_at73c213_pcm_close(snd_pcm_substream_t *substream)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	chip->substream = NULL;
+	return 0;
+}
+
+/* hw_params callback */
+static int snd_at73c213_pcm_hw_params(snd_pcm_substream_t *substream,
+				 snd_pcm_hw_params_t *hw_params)
+{
+#ifdef SND_AT73C213_USE_ALSA_MALLOC_CALLS
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+#else
+	int pg;
+	size_t size = params_buffer_bytes(hw_params);
+	struct snd_pcm_runtime *runtime;
+	struct snd_dma_buffer *dmab = NULL;
+
+	substream->dma_buffer.dev.type = SNDRV_DMA_TYPE_DEV;
+	snd_assert(substream != NULL, return -EINVAL);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -EINVAL);
+
+	/* check if buffer is already allocated */
+	if (runtime->dma_buffer_p) {
+		size_t size_previouse;
+		int pg_previouse;
+
+		/* new buffer is smaler than previouse allocated buffer */
+		if (runtime->dma_buffer_p->bytes >= size) {
+			runtime->dma_bytes = size;
+			return 0; /* don't change buffer size */
+		}
+
+		size_previouse = runtime->dma_buffer_p->bytes;
+		pg_previouse = get_order(size_previouse);
+
+		dma_free_coherent(runtime->dma_buffer_p->dev.dev,
+				PAGE_SIZE << pg_previouse,
+				runtime->dma_buffer_p->area,
+				runtime->dma_buffer_p->addr);
+
+		kfree(runtime->dma_buffer_p);
+	}
+
+	dmab = kzalloc(sizeof(*dmab), GFP_KERNEL);
+	if (!dmab)
+		return -ENOMEM;
+
+	dmab->dev = substream->dma_buffer.dev;
+	dmab->bytes = 0;
+
+	pg = get_order(size);
+
+	dmab->area = dma_alloc_coherent(
+			substream->dma_buffer.dev.dev,
+			PAGE_SIZE << pg,
+			(dma_addr_t *)&dmab->addr,
+			GFP_KERNEL);
+
+	if (!dmab->area) {
+		kfree(dmab);
+		return -ENOMEM;
+	}
+
+	dmab->bytes = size;
+	snd_pcm_set_runtime_buffer(substream, dmab);
+	runtime->dma_bytes = size;
+	return 1;
+#endif
+}
+
+/* hw_free callback */
+static int snd_at73c213_pcm_hw_free(snd_pcm_substream_t *substream)
+{
+#ifdef SND_AT73C213_USE_ALSA_MALLOC_CALLS
+	return snd_pcm_lib_free_pages(substream);
+#else
+	int pg;
+	struct snd_pcm_runtime *runtime;
+	struct snd_dma_buffer *dmab = NULL;
+
+	snd_assert(substream != NULL, return -EINVAL);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -EINVAL);
+	dmab = runtime->dma_buffer_p;
+
+	if (!dmab)
+		return 0;
+
+	if (!dmab->area)
+		return 0;
+
+	pg = get_order(dmab->bytes);
+	dma_free_coherent(dmab->dev.dev, PAGE_SIZE << pg, dmab->area, dmab->addr);
+	kfree(runtime->dma_buffer_p);
+	snd_pcm_set_runtime_buffer(substream, NULL);
+	return 0;
+#endif
+}
+
+/* prepare callback */
+static int snd_at73c213_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	struct platform_device *pdev = chip->pdev;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int block_size;
+
+	block_size = frames_to_bytes(runtime, runtime->period_size);
+
+	chip->period = 0;
+
+	/* Make sure that our data are actually readable by the SSC */
+	dma_sync_single_for_device(&pdev->dev, runtime->dma_addr,
+			block_size, DMA_TO_DEVICE);
+	dma_sync_single_for_device(&pdev->dev, runtime->dma_addr + block_size,
+			block_size, DMA_TO_DEVICE);
+
+	__raw_writel(runtime->dma_addr, chip->regs + PDC_TPR);
+	__raw_writel(runtime->period_size * 2, chip->regs + PDC_TCR);
+	__raw_writel(runtime->dma_addr + block_size, chip->regs + PDC_TNPR);
+	__raw_writel(runtime->period_size * 2, chip->regs + PDC_TNCR);
+
+	return 0;
+}
+
+/* trigger callback */
+static int snd_at73c213_pcm_trigger(snd_pcm_substream_t *substream,
+				   int cmd)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	int retval = 0;
+	int flags = 0;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		__raw_writel(SSC_INT_ENDTX, chip->regs + SSC_IER);
+		__raw_writel(PDC_PTCR_TXTEN, chip->regs + PDC_PTCR);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		__raw_writel(PDC_PTCR_TXTDIS, chip->regs + PDC_PTCR);
+		__raw_writel(SSC_INT_ENDTX, chip->regs + SSC_IDR);
+		break;
+	default:
+		printk(KERN_WARNING "at73c213: spuriouse command %x\n", cmd);
+		retval = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return retval;
+}
+
+/* pointer callback */
+static snd_pcm_uframes_t snd_at73c213_pcm_pointer(snd_pcm_substream_t *substream)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	unsigned long bytes;
+
+	bytes = __raw_readl(chip->regs + PDC_TPR) - runtime->dma_addr;
+
+	pos = bytes_to_frames(runtime, bytes);
+	if (pos >= runtime->buffer_size)
+		pos -= runtime->buffer_size;
+
+	return pos;
+}
+
+/* operators */
+static snd_pcm_ops_t at73c213_playback_ops = {
+	.open		= snd_at73c213_pcm_open,
+	.close		= snd_at73c213_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_at73c213_pcm_hw_params,
+	.hw_free	= snd_at73c213_pcm_hw_free,
+	.prepare	= snd_at73c213_pcm_prepare,
+	.trigger	= snd_at73c213_pcm_trigger,
+	.pointer	= snd_at73c213_pcm_pointer,
+};
+
+/* free a pcm device */
+static void snd_at73c213_pcm_free(snd_pcm_t *pcm)
+{
+	struct snd_at73c213 *chip = snd_pcm_chip(pcm);
+	if (chip->pcm != 0 ) {
+#ifdef SND_AT73C213_USE_ALSA_MALLOC_CALLS
+		snd_pcm_lib_preallocate_free_for_all(chip->pcm);
+#endif
+		chip->pcm = NULL;
+	}
+}
+
+/* create a new pcm device */
+static int __devinit snd_at73c213_new_pcm(struct snd_at73c213 *chip, int device)
+{
+	snd_pcm_t *pcm;
+	int retval;
+
+	retval = snd_pcm_new(chip->card, chip->card->shortname, device, 1, 0, &pcm);
+	if (retval < 0)
+		return retval;
+
+	pcm->private_data = chip;
+	pcm->private_free = snd_at73c213_pcm_free;
+	pcm->info_flags = SNDRV_PCM_INFO_BLOCK_TRANSFER;
+	strcpy(pcm->name, "at73c213");
+	chip->pcm = pcm;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &at73c213_playback_ops);
+
+#ifdef SND_AT73C213_USE_ALSA_MALLOC_CALLS
+	snd_pcm_lib_preallocate_pages_for_all(chip->pcm, SNDRV_DMA_TYPE_DEV,
+			&chip->pdev->dev, 64 * 1024, 64 * 1024);
+#endif
+
+	return 0;
+}
+
+static irqreturn_t snd_at73c213_interrupt(int irq, void *dev_id)
+{
+	struct snd_at73c213 *chip = dev_id;
+	struct platform_device *pdev = chip->pdev;
+	snd_pcm_runtime_t *runtime = chip->substream->runtime;
+	u32 status;
+	int offset, next_period, block_size;
+
+	spin_lock(&chip->lock);
+
+	block_size = frames_to_bytes(runtime, runtime->period_size);
+
+	status = __raw_readl(chip->regs + SSC_IMR);
+
+	if (status & SSC_INT_ENDTX) {
+		chip->period++;
+		if (chip->period == runtime->periods)
+			chip->period = 0;
+		next_period = chip->period + 1;
+		if (next_period == runtime->periods)
+			next_period = 0;
+
+		offset = block_size * next_period;
+
+		/* Make sure that our data are actually readable by the SSC */
+		dma_sync_single_for_device(&pdev->dev, runtime->dma_addr + offset,
+				block_size, DMA_TO_DEVICE);
+		__raw_writel(runtime->dma_addr + offset, chip->regs + PDC_TNPR);
+		__raw_writel(runtime->period_size * 2, chip->regs + PDC_TNCR);
+
+		if (next_period == 0) {
+			(void)__raw_readl(chip->regs + PDC_TPR);
+			(void)__raw_readl(chip->regs + PDC_TCR);
+		}
+	} else {
+		printk(KERN_WARNING
+		       "Spurious SSC interrupt, status = 0x%08lx\n",
+		       (unsigned long)status);
+		__raw_writel(status, chip->regs + SSC_IDR);
+	}
+
+	(void)__raw_readl(chip->regs + SSC_IMR);
+	spin_unlock(&chip->lock);
+
+	if (status & SSC_INT_ENDTX)
+		snd_pcm_period_elapsed(chip->substream);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Mixer functions
+ */
+#if 0 /* Function not in use */
+static int snd_at73c213_mono_info(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
+{
+	unsigned long mask = (kcontrol->private_value >> 16) & 0xff;
+
+	uinfo->type = (mask == 1) ?
+		SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+
+	return 0;
+}
+#endif
+
+static int snd_at73c213_mono_get(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	ucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & mask;
+
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			(mask - ucontrol->value.integer.value[0]);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int snd_at73c213_mono_put(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+	int change, retval;
+	unsigned short val;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = mask - val;
+	val <<= shift;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	val = (chip->image[reg] & ~(mask << shift)) | val;
+	change = val != chip->image[reg];
+	write_reg(chip, reg, val);
+
+	chip->image[reg] = val;
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return change;
+
+out:
+	return retval;
+}
+
+static int snd_at73c213_stereo_info(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 24) & 0xFF;
+
+	uinfo->type = mask == 1 ?
+		SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+
+	return 0;
+}
+
+static int snd_at73c213_stereo_get(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int left_reg = kcontrol->private_value & 0xff;
+	int right_reg = (kcontrol->private_value >> 8) & 0xff;
+	int shift_left = (kcontrol->private_value >> 16) & 0x07;
+	int shift_right = (kcontrol->private_value >> 19) & 0x07;
+	int mask = (kcontrol->private_value >> 24) & 0xff;
+	int invert = (kcontrol->private_value >> 22) & 1;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	ucontrol->value.integer.value[0] =
+		(chip->image[left_reg] >> shift_left) & mask;
+	ucontrol->value.integer.value[1] =
+		(chip->image[right_reg] >> shift_right) & mask;
+
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			(mask - ucontrol->value.integer.value[0]);
+		ucontrol->value.integer.value[1] =
+			(mask - ucontrol->value.integer.value[1]);
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int snd_at73c213_stereo_put(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int left_reg = kcontrol->private_value & 0xff;
+	int right_reg = (kcontrol->private_value >> 8) & 0xff;
+	int shift_left = (kcontrol->private_value >> 16) & 0x07;
+	int shift_right = (kcontrol->private_value >> 19) & 0x07;
+	int mask = (kcontrol->private_value >> 24) & 0xff;
+	int invert = (kcontrol->private_value >> 22) & 1;
+	int change, retval;
+	unsigned short val1, val2;
+
+	val1 = ucontrol->value.integer.value[0] & mask;
+	val2 = ucontrol->value.integer.value[1] & mask;
+	if (invert) {
+		val1 = mask - val1;
+		val2 = mask - val2;
+	}
+	val1 <<= shift_left;
+	val2 <<= shift_right;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	val1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;
+	val2 = (chip->image[right_reg] & ~(mask << shift_right)) | val2;
+	change = val1 != chip->image[left_reg] || val2 != chip->image[right_reg];
+	write_reg(chip, left_reg, val1);
+	write_reg(chip, right_reg, val2);
+
+	chip->image[left_reg] = val1;
+	chip->image[right_reg] = val2;
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return change;
+
+out:
+	return retval;
+}
+
+static int snd_at73c213_mono_switch_info(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int snd_at73c213_mono_switch_get(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	ucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & 0x01;
+
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			(0x01 - ucontrol->value.integer.value[0]);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int snd_at73c213_mono_switch_put(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+	int change, retval;
+	unsigned short val;
+
+	if (ucontrol->value.integer.value[0])
+		val = mask;
+	else
+		val = 0;
+
+	if (invert)
+		val = mask - val;
+	val <<= shift;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	val |= (chip->image[reg] & ~(mask << shift));
+	change = val != chip->image[reg];
+
+	write_reg(chip, reg, val);
+
+	chip->image[reg] = val;
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return change;
+
+out:
+	return retval;
+}
+
+static int snd_at73c213_pa_volume_info(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = ((kcontrol->private_value >> 16) & 0xFF) - 1;
+
+	return 0;
+}
+
+static int snd_at73c213_line_capture_volume_info(
+		struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 14;
+	uinfo->value.integer.max = 31;
+
+	return 0;
+}
+
+static int snd_at73c213_aux_capture_volume_info(
+		struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 14;
+	uinfo->value.integer.max = 31;
+
+	return 0;
+}
+
+#define AT73C213_MONO(xname, xindex, reg, shift, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_at73c213_mono_info, \
+  .get = snd_at73c213_mono_get, .put = snd_at73c213_mono_put, \
+  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
+
+#define AT73C213_MONO_SWITCH(xname, xindex, reg, shift, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_at73c213_mono_switch_info, \
+  .get = snd_at73c213_mono_switch_get, .put = snd_at73c213_mono_switch_put, \
+  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
+
+#define AT73C213_STEREO(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_at73c213_stereo_info, \
+  .get = snd_at73c213_stereo_get, .put = snd_at73c213_stereo_put, \
+  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }
+
+static struct snd_kcontrol_new snd_at73c213_controls[] __devinitdata = {
+AT73C213_STEREO("Master Playback Volume", 0, DAC_LMPG, DAC_RMPG, 0, 0, 0x1F, 1),
+AT73C213_STEREO("Master Playback Switch", 0, DAC_LMPG, DAC_RMPG, 5, 5, 1, 1),
+AT73C213_STEREO("PCM Playback Volume", 0, DAC_LLOG, DAC_RLOG, 0, 0, 0x1F, 1),
+AT73C213_STEREO("PCM Playback Switch", 0, DAC_LLOG, DAC_RLOG, 5, 5, 1, 1),
+AT73C213_MONO_SWITCH("Mono PA Playback Switch", 0, DAC_CTRL, DAC_CTRL_ONPADRV, 0x01, 0),
+{
+	.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name	= "PA Playback Volume",
+	.index	= 0,
+	.info	= snd_at73c213_pa_volume_info,
+	.get	= snd_at73c213_mono_get,
+	.put	= snd_at73c213_mono_put,
+	.private_value	= PA_CTRL|(PA_CTRL_APAGAIN<<8)|(0x0F<<16)|(1<<24),
+},
+AT73C213_MONO_SWITCH("PA High Gain Playback Switch", 0, PA_CTRL, PA_CTRL_APALP, 0x01, 1),
+AT73C213_MONO_SWITCH("PA Playback Switch", 0, PA_CTRL, PA_CTRL_APAON, 0x01, 0),
+{
+	.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name	= "Aux Capture Volume",
+	.index	= 0,
+	.info	= snd_at73c213_aux_capture_volume_info,
+	.get	= snd_at73c213_mono_get,
+	.put	= snd_at73c213_mono_put,
+	.private_value	= DAC_AUXG|(0<<8)|(0x1F<<16)|(1<<24),
+},
+AT73C213_MONO_SWITCH("Aux Capture Switch", 0, DAC_CTRL, DAC_CTRL_ONAUXIN, 0x01, 0),
+{
+	.iface	= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name	= "Line Capture Volume",
+	.index	= 0,
+	.info	= snd_at73c213_line_capture_volume_info,
+	.get	= snd_at73c213_stereo_get,
+	.put	= snd_at73c213_stereo_put,
+	.private_value	= DAC_LLIG|(DAC_RLIG<<8)|(0<<16)|(0<<19)|(0x1F<<24)|(1<<22),
+},
+AT73C213_MONO_SWITCH("Line Capture Switch", 0, DAC_CTRL, 0, 0x03, 0),
+};
+
+static int __devinit snd_at73c213_mixer(struct snd_at73c213 *chip)
+{
+	struct snd_card *card;
+	int errval, idx;
+
+	if (chip == NULL || chip->pcm == NULL)
+		return -EINVAL;
+
+	card = chip->card;
+
+	strcpy(card->mixername, chip->pcm->name);
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_at73c213_controls); idx++) {
+		if ((errval = snd_ctl_add(card,
+				       snd_ctl_new1(&snd_at73c213_controls[idx],
+						    chip))) < 0)
+			return errval;
+	}
+
+	return 0;
+}
+
+/*
+ * Device functions
+ */
+static int snd_at73c213_chip_init(struct snd_at73c213 *chip)
+{
+	int retval;
+	unsigned char dac_ctrl = 0;
+
+	/* XXX: Unmask the APB clock for SSC0 */
+	__raw_writel(__raw_readl((void __iomem *)PM_BASE + PM_APBAMASK)|(1<<7),
+			(void __iomem *)PM_BASE + PM_APBAMASK);
+
+	/* Wait for clock to be stable */
+	msleep(10);
+
+	retval = snd_at73c213_set_bitrate_and_div();
+	if (retval)
+		goto out;
+
+	/* Reset the SSC */
+	__raw_writel(SSC_CR_SWRST, chip->regs + SSC_CR);
+
+	/* Enable GCLK0 */
+	__raw_writel((1<<30), (void __iomem *)(PIOA_BASE + PIO_PDR));
+	__raw_writel((1<<30), (void __iomem *)(PIOA_BASE + PIO_ASR));
+	__raw_writel(((gclk_div<<8)|0x10|0x04|0x02), (void __iomem *)(PM_BASE + PM_GCCTRL));
+
+	/* Enable SSC and setup for I2S */
+	__raw_writel(ssc_div, chip->regs + SSC_CMR);
+
+	/* CKO, START, STTDLY, PERIOD */
+	__raw_writel((1<<2)|(4<<8)|(1<<16)|(15<<24), chip->regs + SSC_TCMR);
+
+	/* DATLEN, MSBF, DATNB, FSLEN, FSOS */
+	__raw_writel((15<<0)|(1<<7)|(1<<8)|(15<<16)|(1<<20), chip->regs + SSC_TFMR);
+
+	/* Initialize at73c213 on SPI bus */
+	/* Reset the device */
+	write_reg(chip, DAC_RST, 0x04);
+	msleep(1);
+	write_reg(chip, DAC_RST, 0x03);
+
+	/* Turn on precharge */
+	write_reg(chip, DAC_PRECH, 0xFF);
+	write_reg(chip, PA_CTRL, (1<<PA_CTRL_APAPRECH));
+	write_reg(chip, DAC_CTRL, (1<<DAC_CTRL_ONLNOL)|(1<<DAC_CTRL_ONLNOR));
+
+	msleep(50);
+
+	/* Stop precharging PA */
+	write_reg(chip, PA_CTRL, (1<<PA_CTRL_APALP)|0x0F);
+	chip->image[PA_CTRL] = (1<<PA_CTRL_APALP)|0x0F;
+
+	msleep(450);
+
+	/* Stop precharging, turn on master power */
+	write_reg(chip, DAC_PRECH, (1<<DAC_PRECH_ONMSTR));
+	chip->image[DAC_PRECH] = (1<<DAC_PRECH_ONMSTR);
+
+	msleep(1);
+
+	/* Turn on DAC */
+	dac_ctrl = (1<<DAC_CTRL_ONDACL)|(1<<DAC_CTRL_ONDACR)|
+			(1<<DAC_CTRL_ONLNOL)|(1<<DAC_CTRL_ONLNOR);
+
+	write_reg(chip, DAC_CTRL, dac_ctrl);
+	chip->image[DAC_CTRL] = dac_ctrl;
+
+	/* Mute sound */
+	write_reg(chip, DAC_LMPG, 0x3F);
+	chip->image[DAC_LMPG] = 0x3F;
+	write_reg(chip, DAC_RMPG, 0x3F);
+	chip->image[DAC_RMPG] = 0x3F;
+	write_reg(chip, DAC_LLOG, 0x3F);
+	chip->image[DAC_LLOG] = 0x3F;
+	write_reg(chip, DAC_RLOG, 0x3F);
+	chip->image[DAC_RLOG] = 0x3F;
+	write_reg(chip, DAC_LLIG, 0x11);
+	chip->image[DAC_LLIG] = 0x11;
+	write_reg(chip, DAC_RLIG, 0x11);
+	chip->image[DAC_RLIG] = 0x11;
+	write_reg(chip, DAC_AUXG, 0x11);
+	chip->image[DAC_AUXG] = 0x11;
+
+	/* Turn on SSC transmitter */
+	__raw_writel(SSC_CR_TXEN, chip->regs + SSC_CR);
+
+out:
+	return retval;
+}
+
+static int snd_at73c213_dev_free(snd_device_t *device)
+{
+	struct snd_at73c213 *chip = device->device_data;
+
+	if (chip->regs) {
+		__raw_writel(SSC_CR_TXDIS, chip->regs + SSC_CR);
+		iounmap(chip->regs);
+	}
+
+	if (chip->irq >= 0)
+		free_irq(chip->irq, chip);
+
+	if (chip->ssc_clk) {
+		clk_disable(chip->ssc_clk);
+		clk_put(chip->ssc_clk);
+	}
+
+	return 0;
+}
+
+static int __devinit snd_at73c213_create(snd_card_t *card,
+					 struct platform_device *pdev)
+{
+	static snd_device_ops_t ops = {
+		.dev_free	= snd_at73c213_dev_free,
+	};
+	struct snd_at73c213 *chip = get_chip(card);
+	struct resource *regs;
+	struct clk *ssc_clk;
+	int irq, retval;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	ssc_clk = clk_get(&pdev->dev, "mck");
+	if (IS_ERR(ssc_clk))
+		return PTR_ERR(ssc_clk);
+	clk_enable(ssc_clk);
+	chip->ssc_clk = ssc_clk;
+
+	spin_lock_init(&chip->lock);
+	chip->card = card;
+	chip->pdev = pdev;
+	chip->irq = -1;
+
+	retval = -ENOMEM;
+
+	retval = spi_setup(chip->spi);
+	if (retval)
+		goto out;
+
+	chip->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!chip->regs)
+		goto out;
+
+	retval = request_irq(irq, snd_at73c213_interrupt, 0, "at73c213", chip);
+	if (retval) {
+		snd_printk("unable to request IRQ%d\n", irq);
+		goto out;
+	}
+	chip->irq = irq;
+
+	memcpy(&chip->image, &snd_at73c213_original_image,
+			sizeof(snd_at73c213_original_image));
+
+	retval = snd_at73c213_chip_init(chip);
+	if (retval)
+		goto out;
+
+	retval = snd_at73c213_new_pcm(chip, 0);
+	if (retval)
+		goto out;
+
+	retval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (retval)
+		goto out;
+
+	retval = snd_at73c213_mixer(chip);
+	if (retval)
+		goto out;
+
+	snd_card_set_dev(card, &pdev->dev);
+
+out:
+	return retval;
+}
+
+static int __devinit snd_at73c213_probe(struct platform_device *pdev)
+{
+	static int dev;
+	struct spi_board_info *binfo;
+	struct spi_master *smaster;
+	struct snd_at73c213 *chip;
+	snd_card_t *card;
+	int retval;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	if (spi < 0 || ssc < 0)
+		return -ENODEV;
+
+	retval = -ENOMEM;
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+			    sizeof(struct snd_at73c213));
+	if (!card)
+		goto out;
+
+	chip = card->private_data;
+
+	retval = -ENODEV;
+
+	/* Get the SPI bus */
+	binfo = pdev->dev.platform_data;
+	if (!binfo) {
+		printk(KERN_WARNING "at73c213: could not get platform data\n");
+		goto out;
+	}
+
+	smaster = spi_busnum_to_master(spi);
+	if (!smaster) {
+		request_module("spi1");
+		smaster = spi_busnum_to_master(spi);
+		if (!smaster) {
+			printk(KERN_WARNING
+					"at73c213: could not get "
+					"SPI bus %d, remembered to load "
+					"the spi_atmel module?\n", spi);
+			goto out;
+		}
+	}
+
+	chip->spi = spi_new_device(smaster, binfo);
+	if (!chip->spi) {
+		printk(KERN_WARNING "at73c213: could not get SPI device %d\n", spi);
+		goto out;
+	}
+
+	chip->spi->mode = SPI_MODE_1;
+	chip->spi->bits_per_word = 8;
+
+	retval = snd_at73c213_create(card, pdev);
+	if (retval)
+		goto out_free_card;
+
+	strcpy(card->driver, "at73c213");
+	strcpy(card->shortname, "at73c213 (AVR32 STK1000)");
+	sprintf(card->longname, "%s at %p (irq %i)", card->shortname, chip->regs, chip->irq);
+
+	retval = snd_card_register(card);
+	if (retval)
+		goto out_free_card;
+
+	platform_set_drvdata(pdev, card);
+	dev++;
+	return 0;
+
+out_free_card:
+	snd_card_free(card);
+out:
+	return retval;
+}
+
+static int __devexit snd_at73c213_remove(struct platform_device *pdev)
+{
+	struct snd_card *card = platform_get_drvdata(pdev);
+	struct snd_at73c213 *chip = card->private_data;
+	int retval;
+
+	/* Stop playback */
+	__raw_writel(SSC_CR_TXDIS, chip->regs + SSC_CR);
+
+	/* Stop GLCK0 */
+	__raw_writel(0, (void __iomem *)PM_BASE + PM_GCCTRL);
+
+	/* Mute sound */
+	write_reg(chip, DAC_LMPG, 0x3F);
+	chip->image[DAC_LMPG] = 0x3F;
+	write_reg(chip, DAC_RMPG, 0x3F);
+	chip->image[DAC_RMPG] = 0x3F;
+	write_reg(chip, DAC_LLOG, 0x3F);
+	chip->image[DAC_LLOG] = 0x3F;
+	write_reg(chip, DAC_RLOG, 0x3F);
+	chip->image[DAC_RLOG] = 0x3F;
+	write_reg(chip, DAC_LLIG, 0x11);
+	chip->image[DAC_LLIG] = 0x11;
+	write_reg(chip, DAC_RLIG, 0x11);
+	chip->image[DAC_RLIG] = 0x11;
+	write_reg(chip, DAC_AUXG, 0x11);
+	chip->image[DAC_AUXG] = 0x11;
+
+	/* Turn off PA */
+	write_reg(chip, PA_CTRL, (chip->image[PA_CTRL]|0x0F));
+	chip->image[PA_CTRL] |= 0x0F;
+	msleep(10);
+	write_reg(chip, PA_CTRL, (1<<PA_CTRL_APALP)|0x0F);
+	chip->image[PA_CTRL] = (1<<PA_CTRL_APALP)|0x0F;
+
+	/* Turn off external DAC */
+	write_reg(chip, DAC_CTRL, 0x0C);
+	chip->image[DAC_CTRL] = 0x0C;
+	msleep(2);
+	write_reg(chip, DAC_CTRL, 0x00);
+	chip->image[DAC_CTRL] = 0x00;
+
+	/* Turn off master power */
+	write_reg(chip, DAC_PRECH, 0x00);
+	chip->image[DAC_PRECH] = 0x00;
+
+	msleep(10);
+
+out:
+	if (chip->spi)
+		spi_unregister_device(chip->spi);
+
+	if (card) {
+		snd_card_free(card);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int snd_at73c213_suspend(struct platform_device *pdev, pm_message_t state, u32 level)
+{
+	struct snd_card *card = at32_get_drvdata(pdev);
+	struct snd_at73c213 *chip = card->private_data;
+
+	printk(KERN_DEBUG "at73c213: suspending\n");
+
+	/* Stop SSC and GCLK0 */
+
+	spi_suspend(chip->spi, state);
+
+	return 0;
+}
+
+static int snd_at73c213_resume(struct platform_device *pdev, u32 level)
+{
+	struct snd_card *card = at32_get_drvdata(pdev);
+	struct snd_at73c213 *chip = card->private_data;
+
+	printk(KERN_DEBUG "at73c213: resuming\n");
+
+	/* Start GLCK0 and SSC */
+
+	spi_resume(chip->spi);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+/* Driver core initialization */
+static struct platform_driver at73c213_driver = {
+	.probe		= snd_at73c213_probe,
+	.remove		= __devexit_p(snd_at73c213_remove),
+	.driver		= {
+		.name	= "at73c213",
+	}
+#ifdef CONFIG_PM
+	.resume		= snd_at73c213_resume,
+	.suspend	= snd_at73c213_suspend,
+#endif
+};
+
+static int __init at73c213_init(void)
+{
+	return platform_driver_register(&at73c213_driver);
+}
+
+static void __exit at73c213_exit(void)
+{
+	platform_driver_unregister(&at73c213_driver);
+}
+
+MODULE_AUTHOR("Hans-Christian Egtvedt <hcegtvedt@atmel.com>");
+MODULE_DESCRIPTION("Sound driver for at73c213 on STK1000");
+MODULE_LICENSE("GPL");
+
+module_init(at73c213_init);
+module_exit(at73c213_exit);
+
Index: linux-2.6.19-avr1/sound/avr32/at73c213.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/sound/avr32/at73c213.h	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,120 @@
+/*
+ * Driver for the AT73C213 16-bit stereo DAC on Atmel ATSTK1000
+ *
+ * Copyright (C) 2006 Atmel Norway
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+
+#ifndef _SND_AT73C213_MIXER_H_
+#define _SND_AT73C213_MIXER_H_
+
+/* DAC control register */
+#define DAC_CTRL		0x00
+#define DAC_CTRL_ONPADRV	7
+#define DAC_CTRL_ONAUXIN	6
+#define DAC_CTRL_ONDACR		5
+#define DAC_CTRL_ONDACL		4
+#define DAC_CTRL_ONLNOR		3
+#define DAC_CTRL_ONLNOL		2
+#define DAC_CTRL_ONLNIR		1
+#define DAC_CTRL_ONLNIL		0
+
+/* DAC left line in gain register */
+#define DAC_LLIG		0x01
+#define DAC_LLIG_LLIG		0
+
+/* DAC right line in gain register */
+#define DAC_RLIG		0x02
+#define DAC_RLIG_RLIG		0
+
+/* DAC Left Master Playback Gain Register */
+#define DAC_LMPG		0x03
+#define DAC_LMPG_LMPG		0
+
+/* DAC Right Master Playback Gain Register */
+#define DAC_RMPG		0x04
+#define DAC_RMPG_RMPG		0
+
+/* DAC Left Line Out Gain Register */
+#define DAC_LLOG		0x05
+#define DAC_LLOG_LLOG		0
+
+/* DAC Right Line Out Gain Register */
+#define DAC_RLOG		0x06
+#define DAC_RLOG_RLOG		0
+
+/* DAC Output Level Control Register */
+#define DAC_OLC			0x07
+#define DAC_OLC_RSHORT		7
+#define DAC_OLC_ROLC		4
+#define DAC_OLC_LSHORT		3
+#define DAC_OLC_LOLC		0
+
+/* DAC Mixer Control Register */
+#define DAC_MC			0x08
+#define DAC_MC_INVR		5
+#define DAC_MC_INVL		4
+#define DAC_MC_RMSMIN2		3
+#define DAC_MC_RMSMIN1		2
+#define DAC_MC_LMSMIN2		1
+#define DAC_MC_LMSMIN1		0
+
+/* DAC Clock and Sampling Frequency Control Register */
+#define DAC_CSFC		0x09
+#define DAC_CSFC_OVRSEL		4
+
+/* DAC Miscellaneous Register */
+#define DAC_MISC		0x0A
+#define DAC_MISC_VCMCAPSEL	7
+#define DAC_MISC_DINTSEL	4
+#define DAC_MISC_DITHEN		3
+#define DAC_MISC_DEEMPEN	2
+#define DAC_MISC_NBITS		0
+
+/* DAC Precharge Control Register */
+#define DAC_PRECH		0x0C
+#define DAC_PRECH_PRCHGPDRV	7
+#define DAC_PRECH_PRCHGAUX1	6
+#define DAC_PRECH_PRCHGLNOR	5
+#define DAC_PRECH_PRCHGLNOL	4
+#define DAC_PRECH_PRCHGLNIR	3
+#define DAC_PRECH_PRCHGLNIL	2
+#define DAC_PRECH_PRCHG		1
+#define DAC_PRECH_ONMSTR	0
+
+/* DAC Auxiliary Input Gain Control Register */
+#define DAC_AUXG		0x0D
+#define DAC_AUXG_AUXG		0
+
+/* DAC Reset Register */
+#define DAC_RST			0x10
+#define DAC_RST_RESMASK		2
+#define DAC_RST_RESFILZ		1
+#define DAC_RST_RSTZ		0
+
+/* Power Amplifier Control Register */
+#define PA_CTRL			0x11
+#define PA_CTRL_APAON		6
+#define PA_CTRL_APAPRECH	5
+#define PA_CTRL_APALP		4
+#define PA_CTRL_APAGAIN		0
+
+#endif
+
Index: linux-2.6.19-avr1/sound/oss/Kconfig
===================================================================
--- linux-2.6.19-avr1.orig/sound/oss/Kconfig	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/sound/oss/Kconfig	2006-12-03 19:23:24.000000000 +0100
@@ -865,3 +865,7 @@ config SOUND_SH_DAC_AUDIO_CHANNEL
 	int "DAC channel"
 	default "1"
 	depends on SOUND_SH_DAC_AUDIO
+
+config SOUND_AT32_DAC
+	tristate "Atmel AT32 On-chip DAC support"
+	depends on SOUND_PRIME && AVR32
Index: linux-2.6.19-avr1/sound/oss/Makefile
===================================================================
--- linux-2.6.19-avr1.orig/sound/oss/Makefile	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/sound/oss/Makefile	2006-12-03 19:23:24.000000000 +0100
@@ -10,6 +10,7 @@ obj-$(CONFIG_SOUND_CS4232)	+= cs4232.o a
 
 # Please leave it as is, cause the link order is significant !
 
+obj-$(CONFIG_SOUND_AT32_DAC)	+= at32dac.o
 obj-$(CONFIG_SOUND_SH_DAC_AUDIO)	+= sh_dac_audio.o
 obj-$(CONFIG_SOUND_HAL2)	+= hal2.o
 obj-$(CONFIG_SOUND_AEDSP16)	+= aedsp16.o
Index: linux-2.6.19-avr1/sound/oss/at32dac.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/sound/oss/at32dac.c	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,720 @@
+/*
+ * OSS Sound Driver for the Atmel AT32 on-chip DAC.
+ *
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+
+#include <asm/byteorder.h>
+#include <asm/dma-controller.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+/* We want to use the "bizarre" swap-bytes-in-each-halfword macro */
+#include <linux/byteorder/swabb.h>
+
+#include "at32dac.h"
+
+#define DMA_BUFFER_SIZE	32768
+#define DMA_PERIOD_SHIFT 10
+#define DMA_PERIOD_SIZE (1 << DMA_PERIOD_SHIFT)
+#define DMA_WRITE_THRESHOLD DMA_PERIOD_SIZE
+
+struct sound_settings {
+	unsigned int format;
+	unsigned int channels;
+	unsigned int sample_rate;
+	/* log2(bytes per sample) */
+	unsigned int input_order;
+};
+
+struct at32_dac {
+	spinlock_t lock;
+	void __iomem *regs;
+
+	/* head and tail refer to number of words */
+	struct {
+		u32 *buf;
+		int head;
+		int tail;
+	} dma;
+
+	struct semaphore sem;
+	wait_queue_head_t write_wait;
+
+	/*
+	 * Read at most ucount bytes from ubuf, translate to 2-channel
+	 * signed 16-bit big endian format and write to the DMA buffer
+	 * as long as there is room left.  Return the number of bytes
+	 * successfully copied from ubuf, or -EFAULT if the first
+	 * sample from ubuf couldn't be read.  This function is not
+	 * called unless there is room for at least one sample (4
+	 * bytes) in the DMA buffer.
+	 */
+	int (*trans)(struct at32_dac *dac, const char __user *ubuf,
+		     size_t ucount);
+
+	struct sound_settings dsp_settings;
+	struct dma_request_cyclic req;
+
+	struct clk *mck;
+	struct clk *sample_clk;
+	struct platform_device *pdev;
+	int busy;
+	int playing;
+	int dev_dsp;
+};
+static struct at32_dac *the_dac;
+
+static inline unsigned int at32dac_get_head(struct at32_dac *dac)
+{
+	return dac->dma.head & ((DMA_BUFFER_SIZE / 4) - 1);
+}
+
+static inline unsigned int at32dac_get_tail(struct at32_dac *dac)
+{
+	return dac->dma.tail & ((DMA_BUFFER_SIZE / 4) - 1);
+}
+
+static inline unsigned int at32dac_dma_space(struct at32_dac *dac)
+{
+	unsigned int space;
+
+	space = ((dac->dma.tail - dac->dma.head - 1)
+		 & ((DMA_BUFFER_SIZE / 4) - 1));
+	return space;
+}
+
+static void at32dac_update_dma_tail(struct at32_dac *dac)
+{
+	dma_addr_t dma_addr;
+	unsigned int new_tail;
+
+	if (dac->playing) {
+		dma_addr = dma_get_current_pos(dac->req.req.dmac,
+					       dac->req.req.channel);
+		new_tail = (dma_addr - dac->req.buffer_start) / 4;
+		if (new_tail >= dac->dma.head
+		    && (dac->dma.tail < dac->dma.head
+			|| dac->dma.tail > new_tail))
+			printk(KERN_NOTICE "at32dac: underrun\n");
+		dac->dma.tail = new_tail;
+		pr_debug("update tail: 0x%x - 0x%x = %u\n",
+			 dma_addr, dac->req.buffer_start, dac->dma.tail);
+	}
+}
+
+static int at32dac_start(struct at32_dac *dac)
+{
+	int ret;
+
+	if (dac->playing)
+		return 0;
+
+	memset(dac->dma.buf, 0, DMA_BUFFER_SIZE);
+
+	clk_enable(dac->sample_clk);
+
+	ret = dma_prepare_request_cyclic(dac->req.req.dmac, &dac->req);
+	if (ret)
+		goto out_stop_clock;
+
+	pr_debug("Starting DMA...\n");
+	ret = dma_start_request(dac->req.req.dmac, dac->req.req.channel);
+	if (ret)
+		goto out_stop_request;
+
+	dac_writel(dac, CTRL, DAC_BIT(EN));
+	dac->playing = 1;
+
+	return 0;
+
+out_stop_request:
+	dma_stop_request(dac->req.req.dmac,
+			 dac->req.req.channel);
+out_stop_clock:
+	clk_disable(dac->sample_clk);
+	return ret;
+}
+
+static int at32dac_stop(struct at32_dac *dac)
+{
+	if (dac->playing) {
+		dma_stop_request(dac->req.req.dmac, dac->req.req.channel);
+		dac_writel(dac, DATA, 0);
+		dac_writel(dac, CTRL, 0);
+		dac->playing = 0;
+		clk_disable(dac->sample_clk);
+	}
+
+	return 0;
+}
+
+static int at32dac_dma_prepare(struct at32_dac *dac)
+{
+	dac->dma.buf = dma_alloc_coherent(&dac->pdev->dev, DMA_BUFFER_SIZE,
+					  &dac->req.buffer_start, GFP_KERNEL);
+	if (!dac->dma.buf)
+		return -ENOMEM;
+
+	dac->dma.head = dac->dma.tail = 0;
+	dac->req.periods = DMA_BUFFER_SIZE / DMA_PERIOD_SIZE;
+	dac->req.buffer_size = DMA_BUFFER_SIZE;
+
+	return 0;
+}
+
+static void at32dac_dma_cleanup(struct at32_dac *dac)
+{
+	if (dac->dma.buf)
+		dma_free_coherent(&dac->pdev->dev, DMA_BUFFER_SIZE,
+				  dac->dma.buf, dac->req.buffer_start);
+	dac->dma.buf = NULL;
+}
+
+static void at32dac_dma_block_complete(struct dma_request *req)
+{
+	struct dma_request_cyclic *creq = to_dma_request_cyclic(req);
+	struct at32_dac *dac = container_of(creq, struct at32_dac, req);
+
+	wake_up(&dac->write_wait);
+}
+
+static void at32dac_dma_error(struct dma_request *req)
+{
+	printk(KERN_ERR "at32dac: DMA error\n");
+}
+
+static irqreturn_t at32dac_interrupt(int irq, void *dev_id)
+{
+	struct at32_dac *dac = dev_id;
+	u32 status;
+
+	status = dac_readl(dac, INT_STATUS);
+	if (status & DAC_BIT(UNDERRUN)) {
+		printk(KERN_ERR "at32dac: Underrun detected\n");
+		dac_writel(dac, INT_CLR, DAC_BIT(UNDERRUN));
+	} else {
+		printk(KERN_ERR "at32dac: Spurious interrupt: status=0x%x\n",
+		       status);
+		dac_writel(dac, INT_CLR, status);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static ssize_t trans_s16be(struct at32_dac *dac, const char __user *ubuf,
+			   size_t ucount)
+{
+	ssize_t ret;
+
+	if (dac->dsp_settings.channels == 2) {
+		const u32 __user *up = (const u32 __user *)ubuf;
+		u32 sample;
+
+		for (ret = 0; ret < (ssize_t)(ucount - 3); ret += 4) {
+			if (!at32dac_dma_space(dac))
+				break;
+
+			if (unlikely(__get_user(sample, up++))) {
+				if (ret == 0)
+					ret = -EFAULT;
+				break;
+			}
+			dac->dma.buf[at32dac_get_head(dac)] = sample;
+			dac->dma.head++;
+		}
+	} else {
+		const u16 __user *up = (const u16 __user *)ubuf;
+		u16 sample;
+
+		for (ret = 0; ret < (ssize_t)(ucount - 1); ret += 2) {
+			if (!at32dac_dma_space(dac))
+				break;
+
+			if (unlikely(__get_user(sample, up++))) {
+				if (ret == 0)
+					ret = -EFAULT;
+				break;
+			}
+			dac->dma.buf[at32dac_get_head(dac)]
+				= (sample << 16) | sample;
+			dac->dma.head++;
+		}
+	}
+
+	return ret;
+}
+
+static ssize_t trans_s16le(struct at32_dac *dac, const char __user *ubuf,
+			   size_t ucount)
+{
+	ssize_t ret;
+
+	if (dac->dsp_settings.channels == 2) {
+		const u32 __user *up = (const u32 __user *)ubuf;
+		u32 sample;
+
+		for (ret = 0; ret < (ssize_t)(ucount - 3); ret += 4) {
+			if (!at32dac_dma_space(dac))
+				break;
+
+			if (unlikely(__get_user(sample, up++))) {
+				if (ret == 0)
+					ret = -EFAULT;
+				break;
+			}
+			/* Swap bytes in each halfword */
+			dac->dma.buf[at32dac_get_head(dac)] = swahb32(sample);
+			dac->dma.head++;
+		}
+	} else {
+		const u16 __user *up = (const u16 __user *)ubuf;
+		u16 sample;
+
+		for (ret = 0; ret < (ssize_t)(ucount - 1); ret += 2) {
+			if (!at32dac_dma_space(dac))
+				break;
+
+			if (unlikely(__get_user(sample, up++))) {
+				if (ret == 0)
+					ret = -EFAULT;
+				break;
+			}
+			sample = swab16(sample);
+			dac->dma.buf[at32dac_get_head(dac)]
+				= (sample << 16) | sample;
+			dac->dma.head++;
+		}
+	}
+
+	return ret;
+}
+
+static ssize_t at32dac_dma_translate_from_user(struct at32_dac *dac,
+					       const char __user *buffer,
+					       size_t count)
+{
+	/* At least one buffer must be available at this point */
+	pr_debug("at32dac: Copying %zu bytes from user...\n", count);
+
+	return dac->trans(dac, buffer, count);
+}
+
+static int at32dac_set_format(struct at32_dac *dac, int format)
+{
+	unsigned int order;
+
+	switch (format) {
+	case AFMT_S16_BE:
+		order = 1;
+		dac->trans = trans_s16be;
+		break;
+	case AFMT_S16_LE:
+		order = 1;
+		dac->trans = trans_s16le;
+		break;
+	default:
+		printk("at32dac: Unsupported format: %d\n", format);
+		return -EINVAL;
+	}
+
+	if (dac->dsp_settings.channels == 2)
+		order++;
+
+	dac->dsp_settings.input_order = order;
+	dac->dsp_settings.format = format;
+	return 0;
+}
+
+static int at32dac_set_sample_rate(struct at32_dac *dac, unsigned long rate)
+{
+	unsigned long new_rate;
+	int ret;
+
+	ret = clk_set_rate(dac->sample_clk, 256 * rate);
+	if (ret < 0)
+		return ret;
+
+	/* TODO: mplayer seems to have a problem with this */
+#if 0
+	new_rate = clk_get_rate(dac->sample_clk);
+	dac->dsp_settings.sample_rate = new_rate / 256;
+#else
+	dac->dsp_settings.sample_rate = rate;
+#endif
+
+	return 0;
+}
+
+static ssize_t at32dac_dsp_write(struct file *file,
+				 const char __user *buffer,
+				 size_t count, loff_t *ppos)
+{
+	struct at32_dac *dac = file->private_data;
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned int avail;
+	ssize_t copied;
+	ssize_t ret;
+
+	/* Avoid address space checking in the translation functions */
+	if (!access_ok(buffer, count, VERIFY_READ))
+		return -EFAULT;
+
+	down(&dac->sem);
+
+	if (!dac->dma.buf) {
+		ret = at32dac_dma_prepare(dac);
+		if (ret)
+			goto out;
+	}
+
+	add_wait_queue(&dac->write_wait, &wait);
+	ret = 0;
+	while (count > 0) {
+		do {
+			at32dac_update_dma_tail(dac);
+			avail = at32dac_dma_space(dac);
+			set_current_state(TASK_INTERRUPTIBLE);
+			if (avail >= DMA_WRITE_THRESHOLD)
+				break;
+
+			if (file->f_flags & O_NONBLOCK) {
+				if (!ret)
+					ret = -EAGAIN;
+				goto out;
+			}
+
+			pr_debug("Going to wait (avail = %u, count = %zu)\n",
+				 avail, count);
+
+			up(&dac->sem);
+			schedule();
+			if (signal_pending(current)) {
+				if (!ret)
+					ret = -ERESTARTSYS;
+				goto out_nosem;
+			}
+			down(&dac->sem);
+		} while (1);
+
+		copied = at32dac_dma_translate_from_user(dac, buffer, count);
+		if (copied < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		at32dac_start(dac);
+
+		count -= copied;
+		ret += copied;
+	}
+
+out:
+	up(&dac->sem);
+out_nosem:
+	remove_wait_queue(&dac->write_wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+static int at32dac_dsp_ioctl(struct inode *inode, struct file *file,
+			     unsigned int cmd, unsigned long arg)
+{
+	struct at32_dac *dac = file->private_data;
+	int __user *up = (int __user *)arg;
+	struct audio_buf_info abinfo;
+	int val, ret;
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, up);
+
+	case SNDCTL_DSP_SPEED:
+		if (get_user(val, up))
+			return -EFAULT;
+		if (val >= 0) {
+			at32dac_stop(dac);
+			ret = at32dac_set_sample_rate(dac, val);
+			if (ret)
+				return ret;
+		}
+		return put_user(dac->dsp_settings.sample_rate, up);
+
+	case SNDCTL_DSP_STEREO:
+		if (get_user(val, up))
+			return -EFAULT;
+		at32dac_stop(dac);
+		if (val && dac->dsp_settings.channels == 1)
+			dac->dsp_settings.input_order++;
+		else if (!val && dac->dsp_settings.channels != 1)
+			dac->dsp_settings.input_order--;
+		dac->dsp_settings.channels = val ? 2 : 1;
+		return 0;
+
+	case SNDCTL_DSP_CHANNELS:
+		if (get_user(val, up))
+			return -EFAULT;
+
+		if (val) {
+			if (val < 0 || val > 2)
+				return -EINVAL;
+
+			at32dac_stop(dac);
+			dac->dsp_settings.input_order
+				+= val - dac->dsp_settings.channels;
+			dac->dsp_settings.channels = val;
+		}
+		return put_user(val, (int *)arg);
+
+	case SNDCTL_DSP_GETFMTS:
+		return put_user(AFMT_S16_BE | AFMT_S16_BE, up);
+
+	case SNDCTL_DSP_SETFMT:
+		if (get_user(val, up))
+			return -EFAULT;
+
+		if (val == AFMT_QUERY) {
+			val = dac->dsp_settings.format;
+		} else {
+			ret = at32dac_set_format(dac, val);
+			if (ret)
+				return ret;
+		}
+		return put_user(val, up);
+
+	case SNDCTL_DSP_GETOSPACE:
+		at32dac_update_dma_tail(dac);
+		abinfo.fragsize = ((1 << dac->dsp_settings.input_order)
+				   * (DMA_PERIOD_SIZE / 4));
+		abinfo.bytes = (at32dac_dma_space(dac)
+				<< dac->dsp_settings.input_order);
+		abinfo.fragstotal = ((DMA_BUFFER_SIZE * 4)
+				     >> (DMA_PERIOD_SHIFT
+					 + dac->dsp_settings.input_order));
+		abinfo.fragments = ((abinfo.bytes
+				     >> dac->dsp_settings.input_order)
+				    / (DMA_PERIOD_SIZE / 4));
+		pr_debug("fragments=%d  fragstotal=%d  fragsize=%d bytes=%d\n",
+			 abinfo.fragments, abinfo.fragstotal, abinfo.fragsize,
+			 abinfo.bytes);
+		return copy_to_user(up, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
+
+	default:
+		printk("at32dac: Unimplemented ioctl cmd: 0x%x\n", cmd);
+		return -EINVAL;
+	}
+}
+
+static int at32dac_dsp_open(struct inode *inode, struct file *file)
+{
+	struct at32_dac *dac = the_dac;
+	int ret;
+
+	if (file->f_mode & FMODE_READ)
+		return -ENXIO;
+
+	down(&dac->sem);
+	ret = -EBUSY;
+	if (dac->busy)
+		goto out;
+
+	dac->dma.head = dac->dma.tail = 0;
+
+	/* FIXME: What are the correct defaults?  */
+	dac->dsp_settings.channels = 2;
+	at32dac_set_format(dac, AFMT_S16_BE);
+	ret = at32dac_set_sample_rate(dac, 8000);
+	if (ret)
+		goto out;
+
+	file->private_data = dac;
+	dac->busy = 1;
+
+	ret = 0;
+
+out:
+	up(&dac->sem);
+	return ret;
+}
+
+static int at32dac_dsp_release(struct inode *inode, struct file *file)
+{
+	struct at32_dac *dac = file->private_data;
+
+	down(&dac->sem);
+
+	at32dac_stop(dac);
+	at32dac_dma_cleanup(dac);
+	dac->busy = 0;
+
+	up(&dac->sem);
+
+	return 0;
+}
+
+static struct file_operations at32dac_dsp_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= at32dac_dsp_write,
+	.ioctl		= at32dac_dsp_ioctl,
+	.open		= at32dac_dsp_open,
+	.release	= at32dac_dsp_release,
+};
+
+static int __devinit at32dac_probe(struct platform_device *pdev)
+{
+	struct at32_dac *dac;
+	struct resource *regs;
+	struct clk *mck;
+	struct clk *sample_clk;
+	int irq;
+	int ret;
+
+	if (the_dac)
+		return -EBUSY;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	mck = clk_get(&pdev->dev, "mck");
+	if (IS_ERR(mck))
+		return PTR_ERR(mck);
+	sample_clk = clk_get(&pdev->dev, "sample_clk");
+	if (IS_ERR(sample_clk)) {
+		ret = PTR_ERR(sample_clk);
+		goto out_put_mck;
+	}
+	clk_enable(mck);
+
+	ret = -ENOMEM;
+	dac = kzalloc(sizeof(struct at32_dac), GFP_KERNEL);
+	if (!dac)
+		goto out_disable_clk;
+
+	spin_lock_init(&dac->lock);
+	init_MUTEX(&dac->sem);
+	init_waitqueue_head(&dac->write_wait);
+	dac->pdev = pdev;
+	dac->mck = mck;
+	dac->sample_clk = sample_clk;
+
+	dac->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!dac->regs)
+		goto out_free_dac;
+
+	ret = request_irq(irq, at32dac_interrupt, 0, "dac", dac);
+	if (ret)
+		goto out_unmap_regs;
+
+	/* FIXME */
+	dac->req.req.dmac = find_dma_controller(0);
+	if (!dac->req.req.dmac)
+		goto out_free_irq;
+
+	ret = dma_alloc_channel(dac->req.req.dmac);
+	if (ret < 0)
+		goto out_free_irq;
+
+	dac->req.req.channel = ret;
+	dac->req.req.block_complete = at32dac_dma_block_complete;
+	dac->req.req.error = at32dac_dma_error;
+	dac->req.data_reg = regs->start + DAC_DATA;
+	dac->req.periph_id = 2; /* FIXME */
+	dac->req.direction = DMA_DIR_MEM_TO_PERIPH;
+	dac->req.width = DMA_WIDTH_32BIT;
+
+	/* Make sure the DAC is silent and disabled */
+	dac_writel(dac, DATA, 0);
+	dac_writel(dac, CTRL, 0);
+
+	ret = register_sound_dsp(&at32dac_dsp_fops, -1);
+	if (ret < 0)
+		goto out_free_dma;
+	dac->dev_dsp = ret;
+
+	/* TODO: Register mixer */
+
+	the_dac = dac;
+	platform_set_drvdata(pdev, dac);
+
+	return 0;
+
+out_free_dma:
+	dma_release_channel(dac->req.req.dmac, dac->req.req.channel);
+out_free_irq:
+	free_irq(irq, dac);
+out_unmap_regs:
+	iounmap(dac->regs);
+out_free_dac:
+	kfree(dac);
+out_disable_clk:
+	clk_disable(mck);
+	clk_put(sample_clk);
+out_put_mck:
+	clk_put(mck);
+	return ret;
+}
+
+static int __devexit at32dac_remove(struct platform_device *pdev)
+{
+	struct at32_dac *dac;
+
+	dac = platform_get_drvdata(pdev);
+	if (dac) {
+		unregister_sound_dsp(dac->dev_dsp);
+		dma_release_channel(dac->req.req.dmac, dac->req.req.channel);
+		free_irq(platform_get_irq(pdev, 0), dac);
+		iounmap(dac->regs);
+		clk_disable(dac->mck);
+		clk_put(dac->sample_clk);
+		clk_put(dac->mck);
+		kfree(dac);
+		platform_set_drvdata(pdev, NULL);
+		the_dac = NULL;
+	}
+
+	return 0;
+}
+
+static struct platform_driver at32dac_driver = {
+	.probe		= at32dac_probe,
+	.remove		= __devexit_p(at32dac_remove),
+	.driver		= {
+		.name	= "dac",
+	},
+};
+
+static int __init at32dac_init(void)
+{
+	return platform_driver_register(&at32dac_driver);
+}
+module_init(at32dac_init);
+
+static void __exit at32dac_exit(void)
+{
+	platform_driver_unregister(&at32dac_driver);
+}
+module_exit(at32dac_exit);
+
+MODULE_AUTHOR("Haavard Skinnemoen <hskinnemoen@atmel.com>");
+MODULE_DESCRIPTION("DMA Sound Driver for the Atmel AT32 on-chip DAC");
+MODULE_LICENSE("GPL");
Index: linux-2.6.19-avr1/sound/oss/at32dac.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/sound/oss/at32dac.h	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,65 @@
+/*
+ * Register definitions for the Atmel AT32 on-chip DAC.
+ *
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_AVR32_DAC_H__
+#define __ASM_AVR32_DAC_H__
+
+/* DAC register offsets */
+#define DAC_DATA                                0x0000
+#define DAC_CTRL                                0x0008
+#define DAC_INT_MASK                            0x000c
+#define DAC_INT_EN                              0x0010
+#define DAC_INT_DIS                             0x0014
+#define DAC_INT_CLR                             0x0018
+#define DAC_INT_STATUS                          0x001c
+#define DAC_PDC_DATA                            0x0020
+
+/* Bitfields in DATA */
+#define DAC_DATA_OFFSET                         0
+#define DAC_DATA_SIZE                           32
+
+/* Bitfields in CTRL */
+#define DAC_SWAP_OFFSET                         30
+#define DAC_SWAP_SIZE                           1
+#define DAC_EN_OFFSET                           31
+#define DAC_EN_SIZE                             1
+
+/* Bitfields in INT_MASK */
+
+/* Bitfields in INT_EN */
+
+/* Bitfields in INT_DIS */
+#define DAC_TX_READY_OFFSET                     29
+#define DAC_TX_READY_SIZE                       1
+#define DAC_TX_BUFFER_EMPTY_OFFSET              30
+#define DAC_TX_BUFFER_EMPTY_SIZE                1
+#define DAC_CHANNEL_TX_END_OFFSET               31
+#define DAC_CHANNEL_TX_END_SIZE                 1
+
+/* Bitfields in INT_CLR */
+#define DAC_UNDERRUN_OFFSET                     28
+#define DAC_UNDERRUN_SIZE                       1
+
+/* Bitfields in INT_STATUS */
+
+/* Bitfields in PDC_DATA */
+
+/* Bit manipulation macros */
+#define DAC_BIT(name)                           (1 << DAC_##name##_OFFSET)
+#define DAC_BF(name,value)                      (((value) & ((1 << DAC_##name##_SIZE) - 1)) << DAC_##name##_OFFSET)
+#define DAC_BFEXT(name,value)                   (((value) >> DAC_##name##_OFFSET) & ((1 << DAC_##name##_SIZE) - 1))
+#define DAC_BFINS(name,value,old)               (((old) & ~(((1 << DAC_##name##_SIZE) - 1) << DAC_##name##_OFFSET)) | DAC_BF(name,value))
+
+/* Register access macros */
+#define dac_readl(port,reg)				\
+	__raw_readl((port)->regs + DAC_##reg)
+#define dac_writel(port,reg,value)			\
+	__raw_writel((value), (port)->regs + DAC_##reg)
+
+#endif /* __ASM_AVR32_DAC_H__ */
Index: linux-2.6.19-avr1/arch/avr32/mach-at32ap/hsmc.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/mach-at32ap/hsmc.c	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/mach-at32ap/hsmc.c	2006-12-03 19:23:24.000000000 +0100
@@ -75,12 +75,35 @@ int smc_set_configuration(int cs, const 
 		return -EINVAL;
 	}
 
+	switch (config->nwait_mode) {
+	case 0:
+		mode |= HSMC_BF(EXNW_MODE, HSMC_EXNW_MODE_DISABLED);
+		break;
+	case 1:
+		mode |= HSMC_BF(EXNW_MODE, HSMC_EXNW_MODE_RESERVED);
+		break;
+	case 2:
+		mode |= HSMC_BF(EXNW_MODE, HSMC_EXNW_MODE_FROZEN);
+		break;
+	case 3:
+		mode |= HSMC_BF(EXNW_MODE, HSMC_EXNW_MODE_READY);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (config->tdf_cycles) {
+		mode |= HSMC_BF(TDF_CYCLES, config->tdf_cycles);
+	}
+
 	if (config->nrd_controlled)
 		mode |= HSMC_BIT(READ_MODE);
 	if (config->nwe_controlled)
 		mode |= HSMC_BIT(WRITE_MODE);
 	if (config->byte_write)
 		mode |= HSMC_BIT(BAT);
+	if (config->tdf_mode)
+		mode |= HSMC_BIT(TDF_MODE);
 
 	pr_debug("smc cs%d: setup/%08x pulse/%08x cycle/%08x mode/%08x\n",
 		 cs, setup, pulse, cycle, mode);
Index: linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/smc.h
===================================================================
--- linux-2.6.19-avr1.orig/include/asm-avr32/arch-at32ap/smc.h	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/include/asm-avr32/arch-at32ap/smc.h	2006-12-03 19:23:24.000000000 +0100
@@ -48,10 +48,32 @@ struct smc_config {
 	unsigned int	nwe_controlled:1;
 
 	/*
+	 * 0: NWAIT is disabled
+	 * 1: Reserved
+	 * 2: NWAIT is frozen mode
+	 * 3: NWAIT in ready mode
+	 */
+	unsigned int	nwait_mode:2;
+
+	/*
 	 * 0: Byte select access type
 	 * 1: Byte write access type
 	 */
 	unsigned int	byte_write:1;
+
+	/*
+	 * Number of clock cycles before data is released after
+	 * the rising edge of the read controlling signal
+	 *
+	 * Total cycles from SMC is tdf_cycles + 1
+	 */
+	unsigned int	tdf_cycles:4;
+
+	/*
+	 * 0: TDF optimization disabled
+	 * 1: TDF optimization enabled
+	 */
+	unsigned int	tdf_mode:1;
 };
 
 extern int smc_set_configuration(int cs, const struct smc_config *config);
Index: linux-2.6.19-avr1/include/asm-avr32/ide.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-avr1/include/asm-avr32/ide.h	2006-12-03 19:23:24.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ *  linux/include/asm-arm/ide.h
+ *
+ *  Copyright (C) 1994-1996  Linus Torvalds & authors
+ */
+
+/*
+ *  This file contains the ARM architecture specific IDE code.
+ */
+
+#ifndef __ASMAVR32_IDE_H
+#define __ASMAVR32_IDE_H
+
+#ifdef __KERNEL__
+
+#ifndef MAX_HWIFS
+#define MAX_HWIFS	4
+#endif
+
+#if !defined(CONFIG_ARCH_L7200)
+# define IDE_ARCH_OBSOLETE_INIT
+# ifdef CONFIG_ARCH_CLPS7500
+#  define ide_default_io_ctl(base)	((base) + 0x206) /* obsolete */
+# else
+#  define ide_default_io_ctl(base)	(0)
+# endif
+#endif /* !ARCH_L7200 */
+
+#define __ide_mm_insw(port,addr,len)	readsw(port,addr,len)
+#define __ide_mm_insl(port,addr,len)	readsl(port,addr,len)
+#define __ide_mm_outsw(port,addr,len)	writesw(port,addr,len)
+#define __ide_mm_outsl(port,addr,len)	writesl(port,addr,len)
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASMAVR32_IDE_H */
Index: linux-2.6.19-avr1/include/asm-avr32/io.h
===================================================================
--- linux-2.6.19-avr1.orig/include/asm-avr32/io.h	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/include/asm-avr32/io.h	2006-12-03 19:23:24.000000000 +0100
@@ -5,6 +5,8 @@
 
 #ifdef __KERNEL__
 
+#include <linux/types.h>
+
 #include <asm/addrspace.h>
 #include <asm/byteorder.h>
 
@@ -36,37 +38,64 @@ extern void __raw_readsb(unsigned int ad
 extern void __raw_readsw(unsigned int addr, void *data, int wordlen);
 extern void __raw_readsl(unsigned int addr, void *data, int longlen);
 
-static inline void writeb(unsigned char b, volatile void __iomem *addr)
+static inline void __raw_writeb(u8 v, volatile void __iomem *addr)
+{
+	*(volatile u8 __force *)addr = v;
+}
+static inline void __raw_writew(u16 v, volatile void __iomem *addr)
+{
+	*(volatile u16 __force *)addr = v;
+}
+static inline void __raw_writel(u32 v, volatile void __iomem *addr)
+{
+	*(volatile u32 __force *)addr = v;
+}
+
+static inline u8 __raw_readb(const volatile void __iomem *addr)
 {
-	*(volatile unsigned char __force *)addr = b;
+	return *(const volatile u8 __force *)addr;
 }
-static inline void writew(unsigned short b, volatile void __iomem *addr)
+static inline u16 __raw_readw(const volatile void __iomem *addr)
 {
-	*(volatile unsigned short __force *)addr = b;
+	return *(const volatile u16 __force *)addr;
 }
-static inline void writel(unsigned int b, volatile void __iomem *addr)
+static inline u32 __raw_readl(const volatile void __iomem *addr)
 {
-	*(volatile unsigned int __force *)addr = b;
+	return *(const volatile u32 __force *)addr;
 }
-#define __raw_writeb writeb
-#define __raw_writew writew
-#define __raw_writel writel
 
-static inline unsigned char readb(const volatile void __iomem *addr)
+#define __swizzle_addr_b(addr)					\
+	((typeof(addr))((unsigned long)(addr) ^ 3UL))
+#define __swizzle_addr_w(addr)					\
+	((typeof(addr))((unsigned long)(addr) ^ 2UL))
+#define __swizzle_addr_l(addr)					\
+	(addr)
+
+static inline void writeb(u8 v, volatile void __iomem *addr)
 {
-	return *(const volatile unsigned char __force *)addr;
+	__raw_writeb(v, __swizzle_addr_b(addr));
 }
-static inline unsigned short readw(const volatile void __iomem *addr)
+static inline void writew(u16 v, volatile void __iomem *addr)
 {
-	return *(const volatile unsigned short __force *)addr;
+	__raw_writew(v, __swizzle_addr_w(addr));
 }
-static inline unsigned int readl(const volatile void __iomem *addr)
+static inline void writel(u32 v, volatile void __iomem *addr)
 {
-	return *(const volatile unsigned int __force *)addr;
+	__raw_writel(v, __swizzle_addr_l(addr));
+}
+
+static inline u8 readb(const volatile void __iomem *addr)
+{
+	return __raw_readb(__swizzle_addr_b(addr));
+}
+static inline u16 readw(const volatile void __iomem *addr)
+{
+	return __raw_readw(__swizzle_addr_w(addr));
+}
+static inline u32 readl(const volatile void __iomem *addr)
+{
+	return __raw_readl(__swizzle_addr_l(addr));
 }
-#define __raw_readb readb
-#define __raw_readw readw
-#define __raw_readl readl
 
 #define writesb(p, d, l)	__raw_writesb((unsigned int)p, d, l)
 #define writesw(p, d, l)	__raw_writesw((unsigned int)p, d, l)
@@ -108,17 +137,13 @@ static inline unsigned int readl(const v
 
 #endif
 
-
-/*
- * These two are only here because ALSA _thinks_ it needs them...
- */
 static inline void memcpy_fromio(void * to, const volatile void __iomem *from,
 				 unsigned long count)
 {
 	char *p = to;
 	while (count) {
 		count--;
-		*p = readb(from);
+		*p = __raw_readb(from);
 		p++;
 		from++;
 	}
@@ -130,7 +155,7 @@ static inline void  memcpy_toio(volatile
 	const char *p = from;
 	while (count) {
 		count--;
-		writeb(*p, to);
+		__raw_writeb(*p, to);
 		p++;
 		to++;
 	}
Index: linux-2.6.19-avr1/arch/avr32/mach-at32ap/intc.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/mach-at32ap/intc.c	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/mach-at32ap/intc.c	2006-12-03 19:23:24.000000000 +0100
@@ -136,3 +136,7 @@ fail:
 	panic("Interrupt controller initialization failed!\n");
 }
 
+unsigned long intc_get_pending(int group)
+{
+	return intc_readl(&intc0, INTREQ0 + 4 * group);
+}
Index: linux-2.6.19-avr1/arch/avr32/mach-at32ap/extint.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/mach-at32ap/extint.c	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/mach-at32ap/extint.c	2006-12-03 19:23:24.000000000 +0100
@@ -49,12 +49,25 @@ static void eim_unmask_irq(unsigned int 
 static int eim_set_irq_type(unsigned int irq, unsigned int flow_type)
 {
 	struct at32_sm *sm = get_irq_chip_data(irq);
+	struct irq_desc *desc;
 	unsigned int i = irq - sm->eim_first_irq;
 	u32 mode, edge, level;
 	unsigned long flags;
 	int ret = 0;
 
-	flow_type &= IRQ_TYPE_SENSE_MASK;
+	if (flow_type == IRQ_TYPE_NONE)
+		flow_type = IRQ_TYPE_LEVEL_LOW;
+
+	desc = &irq_desc[irq];
+	desc->status &= ~(IRQ_TYPE_SENSE_MASK | IRQ_LEVEL);
+	desc->status |= flow_type & IRQ_TYPE_SENSE_MASK;
+
+	if (flow_type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH)) {
+		desc->status |= IRQ_LEVEL;
+		set_irq_handler(irq, handle_level_irq);
+	} else {
+		set_irq_handler(irq, handle_edge_irq);
+	}
 
 	spin_lock_irqsave(&sm->lock, flags);
 
@@ -148,10 +161,15 @@ static int __init eim_init(void)
 	pattern = sm_readl(sm, EIM_MODE);
 	nr_irqs = fls(pattern);
 
+	/* Trigger on falling edge unless overridden by driver */
+	sm_writel(sm, EIM_MODE, 0UL);
+	sm_writel(sm, EIM_EDGE, 0UL);
+
 	sm->eim_chip = &eim_chip;
 
 	for (i = 0; i < nr_irqs; i++) {
-		set_irq_chip(sm->eim_first_irq + i, &eim_chip);
+		set_irq_chip_and_handler(sm->eim_first_irq + i, &eim_chip,
+					 handle_edge_irq);
 		set_irq_chip_data(sm->eim_first_irq + i, sm);
 	}
 
Index: linux-2.6.19-avr1/arch/avr32/mach-at32ap/sm.c
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/mach-at32ap/sm.c	2006-12-03 19:23:19.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,289 +0,0 @@
-/*
- * System Manager driver for AT32AP CPUs
- *
- * Copyright (C) 2006 Atmel Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/random.h>
-#include <linux/spinlock.h>
-
-#include <asm/intc.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-
-#include <asm/arch/sm.h>
-
-#include "sm.h"
-
-#define SM_EIM_IRQ_RESOURCE	1
-#define SM_PM_IRQ_RESOURCE	2
-#define SM_RTC_IRQ_RESOURCE	3
-
-#define to_eim(irqc) container_of(irqc, struct at32_sm, irqc)
-
-struct at32_sm system_manager;
-
-int __init at32_sm_init(void)
-{
-	struct resource *regs;
-	struct at32_sm *sm = &system_manager;
-	int ret = -ENXIO;
-
-	regs = platform_get_resource(&at32_sm_device, IORESOURCE_MEM, 0);
-	if (!regs)
-		goto fail;
-
-	spin_lock_init(&sm->lock);
-	sm->pdev = &at32_sm_device;
-
-	ret = -ENOMEM;
-	sm->regs = ioremap(regs->start, regs->end - regs->start + 1);
-	if (!sm->regs)
-		goto fail;
-
-	return 0;
-
-fail:
-	printk(KERN_ERR "Failed to initialize System Manager: %d\n", ret);
-	return ret;
-}
-
-/*
- * External Interrupt Module (EIM).
- *
- * EIM gets level- or edge-triggered interrupts of either polarity
- * from the outside and converts it to active-high level-triggered
- * interrupts that the internal interrupt controller can handle. EIM
- * also provides masking/unmasking of interrupts, as well as
- * acknowledging of edge-triggered interrupts.
- */
-
-static irqreturn_t spurious_eim_interrupt(int irq, void *dev_id,
-					  struct pt_regs *regs)
-{
-	printk(KERN_WARNING "Spurious EIM interrupt %d\n", irq);
-	disable_irq(irq);
-	return IRQ_NONE;
-}
-
-static struct irqaction eim_spurious_action = {
-	.handler = spurious_eim_interrupt,
-};
-
-static irqreturn_t eim_handle_irq(int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct irq_controller * irqc = dev_id;
-	struct at32_sm *sm = to_eim(irqc);
-	unsigned long pending;
-
-	/*
-	 * No need to disable interrupts globally.  The interrupt
-	 * level relevant to this group must be masked all the time,
-	 * so we know that this particular EIM instance will not be
-	 * re-entered.
-	 */
-	spin_lock(&sm->lock);
-
-	pending = intc_get_pending(sm->irqc.irq_group);
-	if (unlikely(!pending)) {
-		printk(KERN_ERR "EIM (group %u): No interrupts pending!\n",
-		       sm->irqc.irq_group);
-		goto unlock;
-	}
-
-	do {
-		struct irqaction *action;
-		unsigned int i;
-
-		i = fls(pending) - 1;
-		pending &= ~(1 << i);
-		action = sm->action[i];
-
-		/* Acknowledge the interrupt */
-		sm_writel(sm, EIM_ICR, 1 << i);
-
-		spin_unlock(&sm->lock);
-
-		if (action->flags & SA_INTERRUPT)
-			local_irq_disable();
-		action->handler(sm->irqc.first_irq + i, action->dev_id, regs);
-		local_irq_enable();
-		spin_lock(&sm->lock);
-		if (action->flags & SA_SAMPLE_RANDOM)
-			add_interrupt_randomness(sm->irqc.first_irq + i);
-	} while (pending);
-
-unlock:
-	spin_unlock(&sm->lock);
-	return IRQ_HANDLED;
-}
-
-static void eim_mask(struct irq_controller *irqc, unsigned int irq)
-{
-	struct at32_sm *sm = to_eim(irqc);
-	unsigned int i;
-
-	i = irq - sm->irqc.first_irq;
-	sm_writel(sm, EIM_IDR, 1 << i);
-}
-
-static void eim_unmask(struct irq_controller *irqc, unsigned int irq)
-{
-	struct at32_sm *sm = to_eim(irqc);
-	unsigned int i;
-
-	i = irq - sm->irqc.first_irq;
-	sm_writel(sm, EIM_IER, 1 << i);
-}
-
-static int eim_setup(struct irq_controller *irqc, unsigned int irq,
-		struct irqaction *action)
-{
-	struct at32_sm *sm = to_eim(irqc);
-	sm->action[irq - sm->irqc.first_irq] = action;
-	/* Acknowledge earlier interrupts */
-	sm_writel(sm, EIM_ICR, (1<<(irq - sm->irqc.first_irq)));
-	eim_unmask(irqc, irq);
-	return 0;
-}
-
-static void eim_free(struct irq_controller *irqc, unsigned int irq,
-		void *dev)
-{
-	struct at32_sm *sm = to_eim(irqc);
-	eim_mask(irqc, irq);
-	sm->action[irq - sm->irqc.first_irq] = &eim_spurious_action;
-}
-
-static int eim_set_type(struct irq_controller *irqc, unsigned int irq,
-			unsigned int type)
-{
-	struct at32_sm *sm = to_eim(irqc);
-	unsigned long flags;
-	u32 value, pattern;
-
-	spin_lock_irqsave(&sm->lock, flags);
-
-	pattern = 1 << (irq - sm->irqc.first_irq);
-
-	value = sm_readl(sm, EIM_MODE);
-	if (type & IRQ_TYPE_LEVEL)
-		value |= pattern;
-	else
-		value &= ~pattern;
-	sm_writel(sm, EIM_MODE, value);
-	value = sm_readl(sm, EIM_EDGE);
-	if (type & IRQ_EDGE_RISING)
-		value |= pattern;
-	else
-		value &= ~pattern;
-	sm_writel(sm, EIM_EDGE, value);
-	value = sm_readl(sm, EIM_LEVEL);
-	if (type & IRQ_LEVEL_HIGH)
-		value |= pattern;
-	else
-		value &= ~pattern;
-	sm_writel(sm, EIM_LEVEL, value);
-
-	spin_unlock_irqrestore(&sm->lock, flags);
-
-	return 0;
-}
-
-static unsigned int eim_get_type(struct irq_controller *irqc,
-				 unsigned int irq)
-{
-	struct at32_sm *sm = to_eim(irqc);
-	unsigned long flags;
-	unsigned int type = 0;
-	u32 mode, edge, level, pattern;
-
-	pattern = 1 << (irq - sm->irqc.first_irq);
-
-	spin_lock_irqsave(&sm->lock, flags);
-	mode = sm_readl(sm, EIM_MODE);
-	edge = sm_readl(sm, EIM_EDGE);
-	level = sm_readl(sm, EIM_LEVEL);
-	spin_unlock_irqrestore(&sm->lock, flags);
-
-	if (mode & pattern)
-		type |= IRQ_TYPE_LEVEL;
-	if (edge & pattern)
-		type |= IRQ_EDGE_RISING;
-	if (level & pattern)
-		type |= IRQ_LEVEL_HIGH;
-
-	return type;
-}
-
-static struct irq_controller_class eim_irq_class = {
-	.typename	= "EIM",
-	.handle		= eim_handle_irq,
-	.setup		= eim_setup,
-	.free		= eim_free,
-	.mask		= eim_mask,
-	.unmask		= eim_unmask,
-	.set_type	= eim_set_type,
-	.get_type	= eim_get_type,
-};
-
-static int __init eim_init(void)
-{
-	struct at32_sm *sm = &system_manager;
-	unsigned int i;
-	u32 pattern;
-	int ret;
-
-	/*
-	 * The EIM is really the same module as SM, so register
-	 * mapping, etc. has been taken care of already.
-	 */
-
-	/*
-	 * Find out how many interrupt lines that are actually
-	 * implemented in hardware.
-	 */
-	sm_writel(sm, EIM_IDR, ~0UL);
-	sm_writel(sm, EIM_MODE, ~0UL);
-	pattern = sm_readl(sm, EIM_MODE);
-	sm->irqc.nr_irqs = fls(pattern);
-
-	ret = -ENOMEM;
-	sm->action = kmalloc(sizeof(*sm->action) * sm->irqc.nr_irqs,
-			     GFP_KERNEL);
-	if (!sm->action)
-		goto out;
-
-	for (i = 0; i < sm->irqc.nr_irqs; i++)
-		sm->action[i] = &eim_spurious_action;
-
-	spin_lock_init(&sm->lock);
-	sm->irqc.irq_group = sm->pdev->resource[SM_EIM_IRQ_RESOURCE].start;
-	sm->irqc.class = &eim_irq_class;
-
-	ret = intc_register_controller(&sm->irqc);
-	if (ret < 0)
-		goto out_free_actions;
-
-	printk("EIM: External Interrupt Module at 0x%p, IRQ group %u\n",
-	       sm->regs, sm->irqc.irq_group);
-	printk("EIM: Handling %u external IRQs, starting with IRQ%u\n",
-	       sm->irqc.nr_irqs, sm->irqc.first_irq);
-
-	return 0;
-
-out_free_actions:
-	kfree(sm->action);
-out:
-	return ret;
-}
-arch_initcall(eim_init);
Index: linux-2.6.19-avr1/fs/jffs2/os-linux.h
===================================================================
--- linux-2.6.19-avr1.orig/fs/jffs2/os-linux.h	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/fs/jffs2/os-linux.h	2006-12-03 19:23:24.000000000 +0100
@@ -106,7 +106,8 @@ static inline void jffs2_init_inode_info
 #ifdef CONFIG_JFFS2_SUMMARY
 #define jffs2_can_mark_obsolete(c) (0)
 #else
-#define jffs2_can_mark_obsolete(c) (c->mtd->flags & (MTD_BIT_WRITEABLE))
+#define jffs2_can_mark_obsolete(c) (c->mtd->flags & (MTD_BIT_WRITEABLE)	\
+				    && !jffs2_dataflash(c))
 #endif
 
 #define jffs2_cleanmarker_oob(c) (c->mtd->type == MTD_NANDFLASH)
Index: linux-2.6.19-avr1/drivers/mtd/chips/cfi_cmdset_0001.c
===================================================================
--- linux-2.6.19-avr1.orig/drivers/mtd/chips/cfi_cmdset_0001.c	2006-12-03 19:23:19.000000000 +0100
+++ linux-2.6.19-avr1/drivers/mtd/chips/cfi_cmdset_0001.c	2006-12-03 19:23:24.000000000 +0100
@@ -47,6 +47,7 @@
 #define I82802AC	0x00ac
 #define MANUFACTURER_ST         0x0020
 #define M50LPW080       0x002F
+#define AT49BV640D	0x02de
 
 static int cfi_intelext_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_intelext_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
@@ -153,6 +154,48 @@ static void cfi_tell_features(struct cfi
 }
 #endif
 
+/* Atmel chips don't use the same PRI format as Intel chips */
+static void fixup_convert_atmel_pri(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	struct cfi_pri_intelext *extp = cfi->cmdset_priv;
+	struct cfi_pri_atmel atmel_pri;
+	uint32_t features = 0;
+
+	/* Reverse byteswapping */
+	extp->FeatureSupport = cpu_to_le32(extp->FeatureSupport);
+	extp->BlkStatusRegMask = cpu_to_le16(extp->BlkStatusRegMask);
+	extp->ProtRegAddr = cpu_to_le16(extp->ProtRegAddr);
+
+	memcpy(&atmel_pri, extp, sizeof(atmel_pri));
+	memset((char *)extp + 5, 0, sizeof(*extp) - 5);
+
+	printk(KERN_ERR "atmel Features: %02x\n", atmel_pri.Features);
+
+	if (atmel_pri.Features & 0x01) /* chip erase supported */
+		features |= (1<<0);
+	if (atmel_pri.Features & 0x02) /* erase suspend supported */
+		features |= (1<<1);
+	if (atmel_pri.Features & 0x04) /* program suspend supported */
+		features |= (1<<2);
+	if (atmel_pri.Features & 0x08) /* simultaneous operations supported */
+		features |= (1<<9);
+	if (atmel_pri.Features & 0x20) /* page mode read supported */
+		features |= (1<<7);
+	if (atmel_pri.Features & 0x40) /* queued erase supported */
+		features |= (1<<4);
+	if (atmel_pri.Features & 0x80) /* Protection bits supported */
+		features |= (1<<6);
+
+	extp->FeatureSupport = features;
+
+	if (!(atmel_pri.Features & 0x10)) { /* burst read mode not supported */
+		cfi->cfiq->BufWriteTimeoutTyp = 0;
+		cfi->cfiq->BufWriteTimeoutMax = 0;
+	}
+}
+
 #ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE
 /* Some Intel Strata Flash prior to FPO revision C has bugs in this area */
 static void fixup_intel_strataflash(struct mtd_info *mtd, void* param)
@@ -221,6 +264,7 @@ static void fixup_use_write_buffers(stru
 }
 
 static struct cfi_fixup cfi_fixup_table[] = {
+	{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri, NULL },
 #ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_intel_strataflash, NULL },
 #endif
Index: linux-2.6.19-avr1/arch/avr32/configs/atstk1002_defconfig
===================================================================
--- linux-2.6.19-avr1.orig/arch/avr32/configs/atstk1002_defconfig	2006-12-03 19:23:18.000000000 +0100
+++ linux-2.6.19-avr1/arch/avr32/configs/atstk1002_defconfig	2006-12-03 19:23:24.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.19-rc2
-# Fri Oct 20 11:52:37 2006
+# Linux kernel version: 2.6.19-avr1
+# Sun Dec  3 19:11:27 2006
 #
 CONFIG_AVR32=y
 CONFIG_GENERIC_HARDIRQS=y
@@ -101,6 +101,11 @@ CONFIG_CPU_AT32AP7000=y
 CONFIG_BOARD_ATSTK1002=y
 CONFIG_BOARD_ATSTK1000=y
 CONFIG_LOADER_U_BOOT=y
+
+#
+# Atmel AVR32 AP options
+#
+CONFIG_PIO_DEV=y
 CONFIG_LOAD_ADDRESS=0x10000000
 CONFIG_ENTRY_ADDRESS=0x90000000
 CONFIG_PHYS_OFFSET=0x10000000
@@ -123,6 +128,7 @@ CONFIG_FLAT_NODE_MEM_MAP=y
 CONFIG_SPLIT_PTLOCK_CPUS=4
 # CONFIG_RESOURCES_64BIT is not set
 # CONFIG_OWNERSHIP_TRACE is not set
+CONFIG_DW_DMAC=y
 # CONFIG_HZ_100 is not set
 CONFIG_HZ_250=y
 # CONFIG_HZ_1000 is not set
@@ -306,6 +312,8 @@ CONFIG_MTD_PHYSMAP_BANKWIDTH=2
 #
 # Self-contained MTD device drivers
 #
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_M25P80 is not set
 # CONFIG_MTD_SLRAM is not set
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
@@ -355,7 +363,6 @@ CONFIG_BLK_DEV_INITRD=y
 #
 # Misc devices
 #
-# CONFIG_SGI_IOC4 is not set
 # CONFIG_TIFM_CORE is not set
 
 #
@@ -405,11 +412,14 @@ CONFIG_TUN=m
 #
 # PHY device support
 #
+# CONFIG_PHYLIB is not set
 
 #
 # Ethernet (10 or 100Mbit)
 #
-# CONFIG_NET_ETHERNET is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_MACB=y
 
 #
 # Ethernet (1000 Mbit)
@@ -519,13 +529,56 @@ CONFIG_UNIX98_PTYS=y
 #
 # I2C support
 #
-# CONFIG_I2C is not set
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_TWI=m
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
 
 #
 # SPI support
 #
-# CONFIG_SPI is not set
-# CONFIG_SPI_MASTER is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_ATMEL=y
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
 
 #
 # Dallas's 1-wire bus
@@ -552,13 +605,76 @@ CONFIG_UNIX98_PTYS=y
 # Graphics support
 #
 # CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_SIDSA=y
+CONFIG_FB_SIDSA_DEFAULT_BPP=24
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_BACKLIGHT_CLASS_DEVICE is not set
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_DEVICE=y
+CONFIG_LCD_LTV350QV=y
 
 #
 # Sound
 #
-# CONFIG_SOUND is not set
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+CONFIG_SND_AC97_CODEC=m
+CONFIG_SND_AC97_BUS=m
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA AVR32 devices
+#
+CONFIG_SND_ATMEL_AC97=m
+# CONFIG_SND_ATMEL_AC97_USE_ALSA_MALLOC_CALLS is not set
+# CONFIG_SND_ATMEL_AC97C_USE_PDC is not set
+CONFIG_SND_AT73C213=m
+# CONFIG_SND_AT73C213_USE_ALSA_MALLOC_CALLS is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=m
+# CONFIG_OSS_OBSOLETE_DRIVER is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+CONFIG_SOUND_AT32_DAC=m
 
 #
 # USB support
@@ -579,7 +695,11 @@ CONFIG_UNIX98_PTYS=y
 #
 # MMC/SD Card support
 #
-# CONFIG_MMC is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_ATMELMCI=y
+# CONFIG_MMC_TIFM_SD is not set
 
 #
 # LED devices
@@ -623,7 +743,7 @@ CONFIG_UNIX98_PTYS=y
 #
 # File systems
 #
-CONFIG_EXT2_FS=m
+CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
 # CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
@@ -671,7 +791,7 @@ CONFIG_TMPFS=y
 # CONFIG_TMPFS_POSIX_ACL is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
-CONFIG_CONFIGFS_FS=m
+CONFIG_CONFIGFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -703,8 +823,19 @@ CONFIG_JFFS2_RTIME=y
 #
 # Network File Systems
 #
-# CONFIG_NFS_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
@@ -763,6 +894,11 @@ CONFIG_NLS_ISO8859_1=m
 CONFIG_NLS_UTF8=m
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
@@ -790,7 +926,7 @@ CONFIG_DEBUG_FS=y
 # CONFIG_DEBUG_LIST is not set
 CONFIG_FRAME_POINTER=y
 # CONFIG_UNWIND_INFO is not set
-CONFIG_FORCED_INLINING=y
+# CONFIG_FORCED_INLINING is not set
 # CONFIG_HEADERS_CHECK is not set
 # CONFIG_RCU_TORTURE_TEST is not set
 # CONFIG_KPROBES is not set
