diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/alpha/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/alpha/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/alpha/Kconfig	2007-03-15 13:38:13.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/alpha/Kconfig	2007-03-15 14:33:53.000000000 +0100
@@ -622,6 +622,8 @@
 
 endmenu
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/alpha/kernel/asm-offsets.c ./linux-2.6.19.3-rsbac-1.3.2/arch/alpha/kernel/asm-offsets.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/alpha/kernel/asm-offsets.c	2007-03-15 13:38:11.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/alpha/kernel/asm-offsets.c	2007-03-15 14:33:53.000000000 +0100
@@ -36,6 +36,9 @@
 	DEFINE(PT_PTRACED, PT_PTRACED);
 	DEFINE(CLONE_VM, CLONE_VM);
 	DEFINE(CLONE_UNTRACED, CLONE_UNTRACED);
+#ifdef CONFIG_RSBAC
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
+#endif
 	DEFINE(SIGCHLD, SIGCHLD);
 	BLANK();
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/alpha/kernel/entry.S ./linux-2.6.19.3-rsbac-1.3.2/arch/alpha/kernel/entry.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/alpha/kernel/entry.S	2007-03-15 13:38:12.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/alpha/kernel/entry.S	2007-03-15 14:33:53.000000000 +0100
@@ -644,7 +644,11 @@
 	stq	$2, 152($sp)		/* HAE */
 
 	/* Shuffle FLAGS to the front; add CLONE_VM.  */
+#ifdef CONFIG_RSBAC
+	ldi$1, CLONE_VM|CLONE_UNTRACED | CLONE_KTHREAD;
+#else
 	ldi	$1, CLONE_VM|CLONE_UNTRACED
+#endif
 	or	$18, $1, $16
 	bsr	$26, sys_clone
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/alpha/kernel/ptrace.c ./linux-2.6.19.3-rsbac-1.3.2/arch/alpha/kernel/ptrace.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/alpha/kernel/ptrace.c	2007-03-15 13:38:12.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/alpha/kernel/ptrace.c	2007-03-15 14:33:53.000000000 +0100
@@ -23,6 +23,8 @@
 
 #include "proto.h"
 
+#include <rsbac/hooks.h>
+
 #define DEBUG	DBG_MEM
 #undef DEBUG
 
@@ -269,6 +271,11 @@
 	size_t copied;
 	long ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	lock_kernel();
 	DBG(DBG_MEM, ("request=%ld pid=%ld addr=0x%lx data=0x%lx\n",
 		      request, pid, addr, data));
@@ -277,6 +284,22 @@
 		goto out_notsk;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = pid;
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		goto out_notsk;
+	}
+#endif
+
 	child = ptrace_get_task_struct(pid);
 	if (IS_ERR(child)) {
 		ret = PTR_ERR(child);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/arm/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm/Kconfig	2007-03-15 13:37:54.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/arm/Kconfig	2007-03-15 14:33:25.000000000 +0100
@@ -850,6 +850,8 @@
 
 endmenu
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 menu "Device Drivers"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm/kernel/calls.S ./linux-2.6.19.3-rsbac-1.3.2/arch/arm/kernel/calls.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm/kernel/calls.S	2007-03-15 13:37:46.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/arm/kernel/calls.S	2007-03-15 14:33:25.000000000 +0100
@@ -232,7 +232,11 @@
 /* 220 */	CALL(sys_madvise)
 		CALL(ABI(sys_fcntl64, sys_oabi_fcntl64))
 		CALL(sys_ni_syscall) /* TUX */
+#ifdef CONFIG_RSBAC
+		CALL(sys_rsbac)
+#else
 		CALL(sys_ni_syscall)
+#endif
 		CALL(sys_gettid)
 /* 225 */	CALL(ABI(sys_readahead, sys_oabi_readahead))
 		CALL(sys_setxattr)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/arm/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm/kernel/process.c	2007-03-15 13:37:46.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/arm/kernel/process.c	2007-03-15 14:33:25.000000000 +0100
@@ -36,6 +36,11 @@
 #include <asm/uaccess.h>
 #include <asm/mach/time.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 extern const char *processor_modes[];
 extern void setup_mm_for_reboot(char mode);
 
@@ -461,6 +466,11 @@
 {
 	struct pt_regs regs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        int rsbac_retval;
+        #endif
+
 	memset(&regs, 0, sizeof(regs));
 
 	regs.ARM_r1 = (unsigned long)arg;
@@ -469,7 +479,14 @@
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
 	regs.ARM_cpsr = SVC_MODE;
 
+        #ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if(rsbac_retval > 0)
+	  rsbac_kthread_notify(rsbac_retval);
+	return rsbac_retval;
+        #else
 	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm26/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/arm26/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm26/Kconfig	2007-03-15 13:38:14.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/arm26/Kconfig	2007-03-15 14:33:55.000000000 +0100
@@ -189,6 +189,8 @@
 
 endmenu
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 source "drivers/base/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm26/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/arm26/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/arm26/kernel/process.c	2007-03-15 13:38:13.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/arm26/kernel/process.c	2007-03-15 14:33:55.000000000 +0100
@@ -32,6 +32,11 @@
 #include <asm/processor.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 extern const char *processor_modes[];
 extern void setup_mm_for_reboot(char mode);
 
@@ -358,6 +363,11 @@
 {
         struct pt_regs regs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        int rsbac_retval;
+        #endif
+
         memset(&regs, 0, sizeof(regs));
 
         regs.ARM_r1 = (unsigned long)arg;
@@ -365,7 +375,15 @@
         regs.ARM_r3 = (unsigned long)do_exit;
         regs.ARM_pc = (unsigned long)kernel_thread_helper | MODE_SVC26;
 
+	/* Ok, create the new process.. */
+        #ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if(rsbac_retval > 0)
+	  rsbac_kthread_notify(rsbac_retval);
+	return rsbac_retval;
+        #else
         return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+        #endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/cris/arch-v10/kernel/entry.S ./linux-2.6.19.3-rsbac-1.3.2/arch/cris/arch-v10/kernel/entry.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/cris/arch-v10/kernel/entry.S	2007-03-15 13:38:22.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/cris/arch-v10/kernel/entry.S	2007-03-15 14:34:03.000000000 +0100
@@ -1069,7 +1069,11 @@
 	.long sys_getdents64	/* 220 */
 	.long sys_fcntl64
 	.long sys_ni_syscall	/* reserved for TUX */
-	.long sys_ni_syscall
+#ifdef CONFIG_RSBAC
+	.long sys_rsbac 	/*	reserved for sys_security */
+#else
+ 	.long sys_ni_syscall 	/*	reserved for sys_security */
+#endif
 	.long sys_gettid
 	.long sys_readahead	/* 225 */
 	.long sys_setxattr
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/cris/arch-v10/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/cris/arch-v10/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/cris/arch-v10/kernel/process.c	2007-03-15 13:38:22.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/cris/arch-v10/kernel/process.c	2007-03-15 14:34:03.000000000 +0100
@@ -18,6 +18,11 @@
 #include <asm/arch/svinto.h>
 #include <linux/init.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #ifdef CONFIG_ETRAX_GPIO
 void etrax_gpio_wake_up_check(void); /* drivers/gpio.c */
 #endif
@@ -94,6 +99,11 @@
 {
 	struct pt_regs regs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        int rsbac_retval;
+        #endif
+
 	memset(&regs, 0, sizeof(regs));
 
         /* Don't use r10 since that is set to 0 in copy_thread */
@@ -103,7 +113,14 @@
 	regs.dccr = 1 << I_DCCR_BITNR;
 
 	/* Ok, create the new process.. */
+        #ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if(rsbac_retval > 0)
+	  rsbac_kthread_notify(rsbac_retval);
+	return rsbac_retval;
+        #else
         return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+        #endif
 }
 
 /* setup the child's kernel stack with a pt_regs and switch_stack on it.
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/cris/arch-v32/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/cris/arch-v32/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/cris/arch-v32/kernel/process.c	2007-03-15 13:38:23.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/cris/arch-v32/kernel/process.c	2007-03-15 14:34:04.000000000 +0100
@@ -120,7 +120,11 @@
 	regs.ccs = 1 << (I_CCS_BITNR + CCS_SHIFT);
 
 	/* Create the new process. */
-        return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#ifdef CONFIG_RSBAC
+        return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+#else
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#endif
 }
 
 /*
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/cris/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/cris/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/cris/Kconfig	2007-03-15 13:38:23.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/cris/Kconfig	2007-03-15 14:34:03.000000000 +0100
@@ -130,6 +130,8 @@
 
 endmenu
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 # bring in ETRAX built-in drivers
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/frv/kernel/kernel_thread.S ./linux-2.6.19.3-rsbac-1.3.2/arch/frv/kernel/kernel_thread.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/frv/kernel/kernel_thread.S	2007-03-15 13:38:17.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/frv/kernel/kernel_thread.S	2007-03-15 14:33:59.000000000 +0100
@@ -13,6 +13,10 @@
 #include <asm/unistd.h>
 
 #define CLONE_VM	0x00000100	/* set if VM shared between processes */
+#ifdef CONFIG_RSBAC
+#define CLONE_KTHREAD   0x10000000      /* kernel thread */
+#define CLONE_KT        (CLONE_VM | CLONE_KTHREAD) /* kernel thread flags */
+#endif
 #define	KERN_ERR	"<3>"
 
 	.section .rodata
@@ -37,7 +41,11 @@
 
 	# start by forking the current process, but with shared VM
 	setlos.p	#__NR_clone,gr7		; syscall number
+#ifdef CONFIG_RSBAC
+	ori 		gr10,#CLONE_KT,gr8 	; first syscall arg[clone_flags]
+#else
 	ori		gr10,#CLONE_VM,gr8	; first syscall arg	[clone_flags]
+#endif
 	sethi.p		#0xe4e4,gr9		; second syscall arg	[newsp]
 	setlo		#0xe4e4,gr9
 	setlos.p	#0,gr10			; third syscall arg	[parent_tidptr]
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/h8300/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/h8300/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/h8300/kernel/process.c	2007-03-15 13:38:25.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/h8300/kernel/process.c	2007-03-15 14:34:06.000000000 +0100
@@ -44,6 +44,10 @@
 #include <asm/setup.h>
 #include <asm/pgtable.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 void (*pm_power_off)(void) = NULL;
 EXPORT_SYMBOL(pm_power_off);
 
@@ -134,7 +138,11 @@
 
 	fs = get_fs();
 	set_fs (KERNEL_DS);
+#ifdef CONFIG_RSBAC
+	clone_arg = flags | CLONE_VM | CLONE_KTHREAD;
+#else
 	clone_arg = flags | CLONE_VM;
+#endif
 	__asm__("mov.l sp,er3\n\t"
 		"sub.l er2,er2\n\t"
 		"mov.l %2,er1\n\t"
@@ -153,6 +161,12 @@
 		:"i"(__NR_clone),"g"(clone_arg),"g"(fn),"g"(arg),"i"(__NR_exit)
 		:"er0","er1","er2","er3");
 	set_fs (fs);
+
+        #ifdef CONFIG_RSBAC
+	if(retval > 0)
+	  rsbac_kthread_notify(retval);
+        #endif
+
 	return retval;
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/i386/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/i386/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/i386/Kconfig	2007-03-15 13:38:17.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/i386/Kconfig	2007-03-15 14:33:57.000000000 +0100
@@ -816,6 +816,8 @@
 
 endmenu
 
+source "rsbac/Kconfig"
+
 config ARCH_ENABLE_MEMORY_HOTPLUG
 	def_bool y
 	depends on HIGHMEM
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/i386/kernel/ioport.c ./linux-2.6.19.3-rsbac-1.3.2/arch/i386/kernel/ioport.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/i386/kernel/ioport.c	2007-03-15 13:38:15.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/i386/kernel/ioport.c	2007-03-15 14:33:57.000000000 +0100
@@ -11,12 +11,15 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/ioport.h>
+#include <linux/security.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
 #include <linux/slab.h>
 #include <linux/thread_info.h>
 
+#include <rsbac/hooks.h>
+
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base, unsigned int extent, int new_value)
 {
@@ -62,11 +65,33 @@
 	struct tss_struct * tss;
 	unsigned long *bitmap;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+ 
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
+         /* RSBAC */
+         #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_ioports;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -139,12 +164,34 @@
 	unsigned int old = (regs->eflags >> 12) & 3;
 	struct thread_struct *t = &current->thread;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (level > 3)
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
+
+	        /* RSBAC */
+	        #ifdef CONFIG_RSBAC
+	        rsbac_pr_debug(aef, "calling ADF\n");
+	        rsbac_target_id.scd = ST_ioports;
+	        rsbac_attribute_value.dummy = 0;
+	        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+	                               current->pid,
+	                               T_SCD,
+	                               rsbac_target_id,
+	                               A_none,
+	                               rsbac_attribute_value))
+	          {
+	            return -EPERM;
+	          }
+	        #endif
 	}
 	t->iopl = level << 12;
 	regs->eflags = (regs->eflags & ~X86_EFLAGS_IOPL) | t->iopl;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/i386/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/i386/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/i386/kernel/process.c	2007-03-15 13:38:15.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/i386/kernel/process.c	2007-03-15 14:33:56.000000000 +0100
@@ -57,6 +57,11 @@
 #include <asm/tlbflush.h>
 #include <asm/cpu.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
 static int hlt_counter;
@@ -344,6 +349,11 @@
 {
 	struct pt_regs regs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        int rsbac_retval;
+        #endif
+
 	memset(&regs, 0, sizeof(regs));
 
 	regs.ebx = (unsigned long) fn;
@@ -357,7 +367,14 @@
 	regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2;
 
 	/* Ok, create the new process.. */
+        #ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if(rsbac_retval > 0)
+	  rsbac_kthread_notify(rsbac_retval);
+	return rsbac_retval;
+        #else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+        #endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/i386/kernel/syscall_table.S ./linux-2.6.19.3-rsbac-1.3.2/arch/i386/kernel/syscall_table.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/i386/kernel/syscall_table.S	2007-03-15 13:38:15.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/i386/kernel/syscall_table.S	2007-03-15 14:33:57.000000000 +0100
@@ -222,7 +222,11 @@
 	.long sys_getdents64	/* 220 */
 	.long sys_fcntl64
 	.long sys_ni_syscall	/* reserved for TUX */
-	.long sys_ni_syscall
+#ifdef CONFIG_RSBAC
+	.long sys_rsbac		/* Reserved for security */
+#else
+	.long sys_ni_syscall	/* Reserved for security */
+#endif
 	.long sys_gettid
 	.long sys_readahead	/* 225 */
 	.long sys_setxattr
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/Kconfig	2007-03-15 13:38:30.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/Kconfig	2007-03-15 14:34:09.000000000 +0100
@@ -493,6 +493,8 @@
 	  operations support (formerly known as fetchop), say Y here,
 	  otherwise say N.
 
+source "rsbac/Kconfig"
+
 source "fs/Kconfig"
 
 source "lib/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/kernel/asm-offsets.c ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/kernel/asm-offsets.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/kernel/asm-offsets.c	2007-03-15 13:38:28.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/kernel/asm-offsets.c	2007-03-15 14:34:08.000000000 +0100
@@ -191,6 +191,9 @@
     /* for assembly files which can't include sched.h: */
 	DEFINE(IA64_CLONE_VFORK, CLONE_VFORK);
 	DEFINE(IA64_CLONE_VM, CLONE_VM);
+#ifdef CONFIG_RSBAC
+	DEFINE(IA64_CLONE_KTHREAD, CLONE_KTHREAD);
+#endif
 
 	BLANK();
 	DEFINE(IA64_CPUINFO_NSEC_PER_CYC_OFFSET,
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/kernel/entry.S ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/kernel/entry.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/kernel/entry.S	2007-03-15 13:38:28.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/kernel/entry.S	2007-03-15 14:34:09.000000000 +0100
@@ -1610,5 +1610,8 @@
 	data8 sys_sync_file_range		// 1300
 	data8 sys_tee
 	data8 sys_vmsplice
+#ifdef CONFIG_RSBAC
+	data8 sys_rsbac				// 1297
+#endif
 
 	.org sys_call_table + 8*NR_syscalls	// guard against failures to increase NR_syscalls
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/kernel/process.c	2007-03-15 13:38:28.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/kernel/process.c	2007-03-15 14:34:08.000000000 +0100
@@ -48,6 +48,11 @@
 # include <asm/perfmon.h>
 #endif
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #include "sigframe.h"
 
 void (*ia64_mark_idle)(int);
@@ -683,6 +688,11 @@
 		struct pt_regs pt;
 	} regs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        int rsbac_retval;
+        #endif
+
 	memset(&regs, 0, sizeof(regs));
 	regs.pt.cr_iip = helper_fptr[0];	/* set entry point (IP) */
 	regs.pt.r1 = helper_fptr[1];		/* set GP */
@@ -694,7 +704,14 @@
 	regs.sw.ar_fpsr = regs.pt.ar_fpsr = ia64_getreg(_IA64_REG_AR_FPSR);
 	regs.sw.ar_bspstore = (unsigned long) current + IA64_RBS_OFFSET;
 	regs.sw.pr = (1 << PRED_KERNEL_STACK);
+        #ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs.pt, 0, NULL, NULL);
+	if(rsbac_retval > 0)
+	  rsbac_kthread_notify(rsbac_retval);
+	return rsbac_retval;
+        #else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
+	#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/kernel/ptrace.c ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/kernel/ptrace.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/ia64/kernel/ptrace.c	2007-03-15 13:38:28.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/ia64/kernel/ptrace.c	2007-03-15 14:34:09.000000000 +0100
@@ -31,6 +31,8 @@
 
 #include "entry.h"
 
+#include <rsbac/hooks.h>
+
 /*
  * Bits in the PSR that we allow ptrace() to change:
  *	be, up, ac, mfl, mfh (the user mask; five bits total)
@@ -1418,6 +1420,11 @@
 	struct switch_stack *sw;
 	long ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
@@ -1446,6 +1453,22 @@
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = pid;
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		goto out_tsk;
+	}
+#endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/m32r/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/m32r/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/m32r/kernel/process.c	2007-03-15 13:38:07.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/m32r/kernel/process.c	2007-03-15 14:33:46.000000000 +0100
@@ -211,7 +211,11 @@
 	regs.psw = M32R_PSW_BIE;
 
 	/* Ok, create the new process. */
+#ifdef CONFIG_RSBAC
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL,
+#else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL,
+#endif
 		NULL);
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/m32r/kernel/ptrace.c ./linux-2.6.19.3-rsbac-1.3.2/arch/m32r/kernel/ptrace.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/m32r/kernel/ptrace.c	2007-03-15 13:38:07.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/m32r/kernel/ptrace.c	2007-03-15 14:33:46.000000000 +0100
@@ -33,6 +33,8 @@
 #include <asm/processor.h>
 #include <asm/mmu_context.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * This routine will get a word off of the process kernel stack.
  */
@@ -743,8 +745,28 @@
 	struct task_struct *child;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = current->pid;
+		rsbac_attribute_value.trace_request = request;
+		if (!rsbac_adf_request(R_TRACE,
+					current->pid,
+					T_PROCESS,
+					rsbac_target_id,
+					A_trace_request,
+					rsbac_attribute_value))
+		{
+			ret = -EPERM;
+			goto out;
+		}
+#endif
 		ret = ptrace_traceme();
 		goto out;
 	}
@@ -755,6 +777,22 @@
 		goto out;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = pid;
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		goto out_tsk;
+	}
+#endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		if (ret == 0)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/m68k/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/m68k/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/m68k/Kconfig	2007-03-15 13:38:11.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/m68k/Kconfig	2007-03-15 14:33:49.000000000 +0100
@@ -437,6 +437,8 @@
 
 endmenu
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/m68k/kernel/entry.S ./linux-2.6.19.3-rsbac-1.3.2/arch/m68k/kernel/entry.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/m68k/kernel/entry.S	2007-03-15 13:38:08.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/m68k/kernel/entry.S	2007-03-15 14:33:49.000000000 +0100
@@ -736,3 +736,10 @@
 	.long sys_vmsplice
 	.long sys_move_pages		/* 310 */
 
+#ifdef CONFIG_RSBAC
+	/* we use 300, until sys_security gets defined here */
+	.rept 299-281
+		.long sys_ni_syscall
+	.endr
+	.long sys_rsbac
+#endif
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/m68k/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/m68k/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/m68k/kernel/process.c	2007-03-15 13:38:08.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/m68k/kernel/process.c	2007-03-15 14:33:49.000000000 +0100
@@ -34,6 +34,11 @@
 #include <asm/setup.h>
 #include <asm/pgtable.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * Initial task/thread structure. Make this a per-architecture thing,
  * because different architectures tend to have different
@@ -159,7 +164,11 @@
 
 	{
 	register long retval __asm__ ("d0");
+#ifdef CONFIG_RSBAC
+	register long clone_arg __asm__ ("d1") = flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD;
+#else
 	register long clone_arg __asm__ ("d1") = flags | CLONE_VM | CLONE_UNTRACED;
+#endif
 
 	retval = __NR_clone;
 	__asm__ __volatile__
@@ -185,6 +194,12 @@
 	}
 
 	set_fs (fs);
+
+        #ifdef CONFIG_RSBAC
+	if(pid > 0)
+	  rsbac_kthread_notify(pid);
+        #endif
+
 	return pid;
 }
 EXPORT_SYMBOL(kernel_thread);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/m68knommu/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/m68knommu/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/m68knommu/kernel/process.c	2007-03-15 13:38:24.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/m68knommu/kernel/process.c	2007-03-15 14:34:05.000000000 +0100
@@ -36,6 +36,11 @@
 #include <asm/setup.h>
 #include <asm/pgtable.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 asmlinkage void ret_from_fork(void);
 
 /*
@@ -122,7 +127,11 @@
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
 	int retval;
+#ifdef CONFIG_RSBAC
+	long clone_arg = flags | CLONE_VM | CLONE_KTHREAD;
+#else
 	long clone_arg = flags | CLONE_VM;
+#endif
 	mm_segment_t fs;
 
 	fs = get_fs();
@@ -150,6 +159,12 @@
 		: "cc", "%d0", "%d1", "%d2");
 
 	set_fs(fs);
+
+        #ifdef CONFIG_RSBAC
+	if(retval > 0)
+	  rsbac_kthread_notify(retval);
+        #endif
+
 	return retval;
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/mips/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/mips/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/mips/kernel/process.c	2007-03-15 13:38:31.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/mips/kernel/process.c	2007-03-15 14:34:12.000000000 +0100
@@ -46,6 +46,11 @@
 extern void smtc_idle_loop_hook(void);
 #endif /* CONFIG_MIPS_MT_SMTC */
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * The idle thread. There's no useful work to be done, so just try to conserve
  * power and have a low exit latency (ie sit in a loop waiting for somebody to
@@ -256,6 +261,7 @@
 long kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
 	struct pt_regs regs;
+	int retval;
 
 	memset(&regs, 0, sizeof(regs));
 
@@ -271,7 +277,14 @@
 #endif
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#ifdef CONFIG_RSBAC
+	retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if(retval > 0)
+	  rsbac_kthread_notify(retval);
+#else
+	retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#endif
+        return retval;
 }
 
 /*
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/mips/kernel/scall32-o32.S ./linux-2.6.19.3-rsbac-1.3.2/arch/mips/kernel/scall32-o32.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/mips/kernel/scall32-o32.S	2007-03-15 13:38:31.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/mips/kernel/scall32-o32.S	2007-03-15 14:34:12.000000000 +0100
@@ -552,7 +552,11 @@
 	sys	sys_madvise		3
 	sys	sys_getdents64		3
 	sys	sys_fcntl64		3	/* 4220 */
+#ifdef CONFIG_RSBAC
+	sys	sys_rsbac		2	/* Security */
+#else
 	sys	sys_ni_syscall		0
+#endif
 	sys	sys_gettid		0
 	sys	sys_readahead		5
 	sys	sys_setxattr		5
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/mips/kernel/scall64-64.S ./linux-2.6.19.3-rsbac-1.3.2/arch/mips/kernel/scall64-64.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/mips/kernel/scall64-64.S	2007-03-15 13:38:31.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/mips/kernel/scall64-64.S	2007-03-15 14:34:12.000000000 +0100
@@ -375,7 +375,11 @@
 	PTR	sys_ni_syscall			/* res. for getpmsg */
 	PTR	sys_ni_syscall			/* 5175  for putpmsg */
 	PTR	sys_ni_syscall			/* res. for afs_syscall */
+#ifdef CONFIG_RSBAC
+	PTR	sys_rsbac			/* Security */
+#else
 	PTR	sys_ni_syscall			/* res. for security */
+#endif
 	PTR	sys_gettid
 	PTR	sys_readahead
 	PTR	sys_setxattr			/* 5180 */
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/mips/kernel/scall64-o32.S ./linux-2.6.19.3-rsbac-1.3.2/arch/mips/kernel/scall64-o32.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/mips/kernel/scall64-o32.S	2007-03-15 13:38:31.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/mips/kernel/scall64-o32.S	2007-03-15 14:34:12.000000000 +0100
@@ -426,7 +426,11 @@
 	PTR	sys_madvise
 	PTR	sys_getdents64
 	PTR	compat_sys_fcntl64		/* 4220 */
+#ifdef CONFIG_RSBAC
+	PTR	sys_rsbac			/* Security */
+#else
 	PTR	sys_ni_syscall
+#endif
 	PTR	sys_gettid
 	PTR	sys32_readahead
 	PTR	sys_setxattr
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/parisc/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/parisc/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/parisc/Kconfig	2007-03-15 13:37:56.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/parisc/Kconfig	2007-03-15 14:33:35.000000000 +0100
@@ -238,6 +238,8 @@
 endmenu
 
 
+source "rsbac/Kconfig"
+
 source "drivers/parisc/Kconfig"
 
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/parisc/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/parisc/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/parisc/kernel/process.c	2007-03-15 13:37:55.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/parisc/kernel/process.c	2007-03-15 14:33:35.000000000 +0100
@@ -54,6 +54,10 @@
 #include <asm/uaccess.h>
 #include <asm/unwind.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * The idle thread. There's no useful work to be
  * done, so just try to conserve power and have a
@@ -167,13 +171,25 @@
 extern pid_t __kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
 pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        pid_t rsbac_retval;
+        #endif
 
 	/*
 	 * FIXME: Once we are sure we don't need any debug here,
 	 *	  kernel_thread can become a #define.
 	 */
 
+	/* Ok, create the new process.. */
+        #ifdef CONFIG_RSBAC
+	rsbac_retval = __kernel_thread(fn, arg, flags | CLONE_KTHREAD);
+	if(rsbac_retval > 0)
+	  rsbac_kthread_notify(rsbac_retval);
+	return rsbac_retval;
+        #else
 	return __kernel_thread(fn, arg, flags);
+	#endif
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/parisc/kernel/syscall_table.S ./linux-2.6.19.3-rsbac-1.3.2/arch/parisc/kernel/syscall_table.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/parisc/kernel/syscall_table.S	2007-03-15 13:37:55.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/parisc/kernel/syscall_table.S	2007-03-15 14:33:35.000000000 +0100
@@ -399,5 +399,14 @@
 	ENTRY_SAME(splice)
 	ENTRY_OURS(sync_file_range)
 	ENTRY_SAME(tee)
+#ifdef CONFIG_RSBAC
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)         /* 295 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(rsbac)              /* 300 */
+#endif
 	/* Nothing yet */
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/Kconfig	2007-03-15 13:37:45.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/Kconfig	2007-03-15 14:33:19.000000000 +0100
@@ -1068,6 +1068,8 @@
 	default "0xc000000000000000"
 endif
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/kernel/asm-offsets.c ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/kernel/asm-offsets.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/kernel/asm-offsets.c	2007-03-15 13:37:38.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/kernel/asm-offsets.c	2007-03-15 14:33:20.000000000 +0100
@@ -243,6 +243,9 @@
 
 	DEFINE(CLONE_VM, CLONE_VM);
 	DEFINE(CLONE_UNTRACED, CLONE_UNTRACED);
+#ifdef CONFIG_RSBAC
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
+#endif
 
 #ifndef CONFIG_PPC64
 	DEFINE(MM_PGD, offsetof(struct mm_struct, pgd));
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/kernel/misc_32.S ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/kernel/misc_32.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/kernel/misc_32.S	2007-03-15 13:37:39.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/kernel/misc_32.S	2007-03-15 14:33:21.000000000 +0100
@@ -30,6 +30,9 @@
 #include <asm/processor.h>
 #include <asm/kexec.h>
 
+#ifdef CONFIG_RSBAC
+#define CLONE_KTHREAD           0x10000000      /* clone a kernel thread */
+#endif
 	.text
 
 /*
@@ -749,7 +752,11 @@
 	mr	r30,r3		/* function */
 	mr	r31,r4		/* argument */
 	ori	r3,r5,CLONE_VM	/* flags */
+#ifdef CONFIG_RSBAC
+	oris	r3,r3,(CLONE_UNTRACED|CLONE_KTHREAD)>>16
+#else
 	oris	r3,r3,CLONE_UNTRACED>>16
+#endif
 	li	r4,0		/* new sp (unused) */
 	li	r0,__NR_clone
 	sc
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/kernel/misc_64.S ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/kernel/misc_64.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/kernel/misc_64.S	2007-03-15 13:37:39.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/kernel/misc_64.S	2007-03-15 14:33:21.000000000 +0100
@@ -25,6 +25,10 @@
 #include <asm/cputable.h>
 #include <asm/thread_info.h>
 
+#ifdef CONFIG_RSBAC
+#define CLONE_KTHREAD           0x10000000      /* clone a kernel thread */
+#endif
+
 	.text
 
 _GLOBAL(get_msr)
@@ -394,7 +398,11 @@
 	mr	r29,r3
 	mr	r30,r4
 	ori	r3,r5,CLONE_VM	/* flags */
+#ifdef CONFIG_RSBAC
+	oris    r3,r3,(CLONE_UNTRACED|CLONE_KTHREAD)>>16
+#else
 	oris	r3,r3,(CLONE_UNTRACED>>16)
+#endif
 	li	r4,0		/* new sp (unused) */
 	li	r0,__NR_clone
 	sc
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/kernel/sys_ppc32.c ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/kernel/sys_ppc32.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/powerpc/kernel/sys_ppc32.c	2007-03-15 13:37:39.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/powerpc/kernel/sys_ppc32.c	2007-03-15 14:33:21.000000000 +0100
@@ -65,6 +65,9 @@
 
 struct readdir_callback32 {
 	struct old_linux_dirent32 __user * dirent;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	struct file * file;
+#endif
 	int count;
 };
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/ppc/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/ppc/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/ppc/Kconfig	2007-03-15 13:38:04.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/ppc/Kconfig	2007-03-15 14:33:39.000000000 +0100
@@ -1385,6 +1385,8 @@
 	depends on ADVANCED_OPTIONS && 8xx
 endmenu
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/ppc/kernel/asm-offsets.c ./linux-2.6.19.3-rsbac-1.3.2/arch/ppc/kernel/asm-offsets.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/ppc/kernel/asm-offsets.c	2007-03-15 13:38:00.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/ppc/kernel/asm-offsets.c	2007-03-15 14:33:39.000000000 +0100
@@ -121,6 +121,9 @@
 	DEFINE(TRAP, STACK_FRAME_OVERHEAD+offsetof(struct pt_regs, trap));
 	DEFINE(CLONE_VM, CLONE_VM);
 	DEFINE(CLONE_UNTRACED, CLONE_UNTRACED);
+#ifdef CONFIG_RSBAC
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
+#endif
 	DEFINE(MM_PGD, offsetof(struct mm_struct, pgd));
 
 	/* About the CPU features table */
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/ppc/kernel/misc.S ./linux-2.6.19.3-rsbac-1.3.2/arch/ppc/kernel/misc.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/ppc/kernel/misc.S	2007-03-15 13:38:00.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/ppc/kernel/misc.S	2007-03-15 14:33:39.000000000 +0100
@@ -848,7 +848,11 @@
 	mr	r30,r3		/* function */
 	mr	r31,r4		/* argument */
 	ori	r3,r5,CLONE_VM	/* flags */
+#ifdef CONFIG_RSBAC
+	oris	r3,r3,(CLONE_UNTRACED|CLONE_KTHREAD)>>16
+#else
 	oris	r3,r3,CLONE_UNTRACED>>16
+#endif
 	li	r4,0		/* new sp (unused) */
 	li	r0,__NR_clone
 	sc
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/s390/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/s390/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/s390/Kconfig	2007-03-15 13:38:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/s390/Kconfig	2007-03-15 14:34:00.000000000 +0100
@@ -483,6 +483,8 @@
 
 endmenu
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 config PCMCIA
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/s390/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/s390/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/s390/kernel/process.c	2007-03-15 13:38:19.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/s390/kernel/process.c	2007-03-15 14:34:01.000000000 +0100
@@ -45,6 +45,11 @@
 #include <asm/irq.h>
 #include <asm/timer.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 asmlinkage void ret_from_fork(void) asm ("ret_from_fork");
 
 /*
@@ -189,6 +194,11 @@
 {
 	struct pt_regs regs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        int rsbac_retval;
+        #endif
+
 	memset(&regs, 0, sizeof(regs));
 	regs.psw.mask = PSW_KERNEL_BITS | PSW_MASK_IO | PSW_MASK_EXT;
 	regs.psw.addr = (unsigned long) kernel_thread_starter | PSW_ADDR_AMODE;
@@ -198,8 +208,15 @@
 	regs.orig_gpr2 = -1;
 
 	/* Ok, create the new process.. */
+        #ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if(rsbac_retval > 0)
+	  rsbac_kthread_notify(rsbac_retval);
+	return rsbac_retval;
+        #else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED,
 		       0, &regs, 0, NULL, NULL);
+	#endif
 }
 
 /*
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/s390/kernel/ptrace.c ./linux-2.6.19.3-rsbac-1.3.2/arch/s390/kernel/ptrace.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/s390/kernel/ptrace.c	2007-03-15 13:38:19.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/s390/kernel/ptrace.c	2007-03-15 14:34:01.000000000 +0100
@@ -46,6 +46,8 @@
 #include "compat_ptrace.h"
 #endif
 
+#include <rsbac/hooks.h>
+
 static void
 FixPerRegisters(struct task_struct *task)
 {
@@ -711,6 +713,11 @@
 	struct task_struct *child;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
 		 ret = ptrace_traceme();
@@ -723,6 +730,23 @@
 		goto out;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = pid;
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		put_task_struct(child);
+		goto out;
+	}
+#endif
+
 	ret = do_ptrace(child, request, addr, data);
 	put_task_struct(child);
 out:
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sh/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/sh/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sh/Kconfig	2007-03-15 13:38:43.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sh/Kconfig	2007-03-15 14:34:21.000000000 +0100
@@ -621,6 +621,8 @@
 
 source "drivers/Kconfig"
 
+source "rsbac/Kconfig"
+
 source "fs/Kconfig"
 
 source "arch/sh/oprofile/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sh/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/sh/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sh/kernel/process.c	2007-03-15 13:38:39.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sh/kernel/process.c	2007-03-15 14:34:22.000000000 +0100
@@ -29,6 +29,11 @@
 #include <asm/elf.h>
 #include <asm/ubc.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 static int hlt_counter=0;
 
 int ubc_usercnt = 0;
@@ -156,6 +161,11 @@
 {	/* Don't use this in BL=1(cli).  Or else, CPU resets! */
 	struct pt_regs regs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        int rsbac_retval;
+        #endif
+
 	memset(&regs, 0, sizeof(regs));
 	regs.regs[4] = (unsigned long) arg;
 	regs.regs[5] = (unsigned long) fn;
@@ -164,7 +174,14 @@
 	regs.sr = (1 << 30);
 
 	/* Ok, create the new process.. */
+        #ifdef CONFIG_RSBAC
+	rsbac_retval = do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD, 0, &regs, 0, NULL, NULL);
+	if(rsbac_retval > 0)
+	  rsbac_kthread_notify(rsbac_retval);
+	return rsbac_retval;
+        #else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	#endif
 }
 
 /*
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sh/kernel/syscalls.S ./linux-2.6.19.3-rsbac-1.3.2/arch/sh/kernel/syscalls.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sh/kernel/syscalls.S	2007-03-15 13:38:39.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sh/kernel/syscalls.S	2007-03-15 14:34:22.000000000 +0100
@@ -257,7 +257,11 @@
 	.long sys_getdents64	/* 220 */
 	.long sys_fcntl64
 	.long sys_ni_syscall	/* reserved for TUX */
+#ifdef CONFIG_RSBAC
+	.long sys_rsbac
+#else
 	.long sys_ni_syscall	/* Reserved for Security */
+#endif
 	.long sys_gettid
 	.long sys_readahead	/* 225 */
 	.long sys_setxattr
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sh64/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/sh64/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sh64/kernel/process.c	2007-03-15 13:38:08.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sh64/kernel/process.c	2007-03-15 14:33:48.000000000 +0100
@@ -400,7 +400,11 @@
 	regs.pc = (unsigned long)kernel_thread_helper;
 	regs.sr = (1 << 30);
 
+#ifdef CONFIG_RSBAC
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | KERNEL_THREAD, 0,
+#else
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0,
+#endif
 		       &regs, 0, NULL, NULL);
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc/Kconfig	2007-03-15 13:38:38.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc/Kconfig	2007-03-15 14:34:19.000000000 +0100
@@ -231,6 +231,8 @@
 
 endmenu
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc/kernel/process.c	2007-03-15 13:38:37.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc/kernel/process.c	2007-03-15 14:34:20.000000000 +0100
@@ -42,6 +42,11 @@
 #include <asm/elf.h>
 #include <asm/unistd.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /* 
  * Power management idle function 
  * Set in pm platform drivers (apc.c and pmc.c)
@@ -705,9 +710,19 @@
 			     /* Notreached by child. */
 			     "1: mov %%o0, %0\n\t" :
 			     "=r" (retval) :
+#ifdef CONFIG_RSBAC
+			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD),
+#else
 			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED),
+#endif
 			     "i" (__NR_exit),  "r" (fn), "r" (arg) :
 			     "g1", "g2", "g3", "o0", "o1", "memory", "cc");
+
+        #ifdef CONFIG_RSBAC
+	if(retval > 0)
+	  rsbac_kthread_notify(retval);
+        #endif
+
 	return retval;
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc/kernel/ptrace.c ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc/kernel/ptrace.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc/kernel/ptrace.c	2007-03-15 13:38:38.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc/kernel/ptrace.c	2007-03-15 14:34:20.000000000 +0100
@@ -24,6 +24,8 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 #define MAGIC_CONSTANT 0x80000000
 
 
@@ -268,6 +270,11 @@
 	struct task_struct *child;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	lock_kernel();
 #ifdef DEBUG_PTRACE
 	{
@@ -300,6 +307,23 @@
 		goto out;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = pid;
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		pt_error_return(regs, EPERM);
+		ret = -EPERM;
+		goto out_tsk;
+	}
+#endif
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc/kernel/systbls.S ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc/kernel/systbls.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc/kernel/systbls.S	2007-03-15 13:38:38.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc/kernel/systbls.S	2007-03-15 14:34:20.000000000 +0100
@@ -49,7 +49,13 @@
 /*145*/	.long sys_setrlimit, sys_pivot_root, sys_prctl, sys_pciconfig_read, sys_pciconfig_write
 /*150*/	.long sys_nis_syscall, sys_inotify_init, sys_inotify_add_watch, sys_poll, sys_getdents64
 /*155*/	.long sys_fcntl64, sys_inotify_rm_watch, sys_statfs, sys_fstatfs, sys_oldumount
+
+#ifdef CONFIG_RSBAC /* we use 164, which seems to be unused */
+/*160*/	.long sys_sched_setaffinity, sys_sched_getaffinity, sys_getdomainname, sys_setdomainname, sys_rsbac
+#else
 /*160*/	.long sys_sched_setaffinity, sys_sched_getaffinity, sys_getdomainname, sys_setdomainname, sys_nis_syscall
+#endif
+
 /*165*/	.long sys_quotactl, sys_set_tid_address, sys_mount, sys_ustat, sys_setxattr
 /*170*/	.long sys_lsetxattr, sys_fsetxattr, sys_getxattr, sys_lgetxattr, sys_getdents
 /*175*/	.long sys_setsid, sys_fchdir, sys_fgetxattr, sys_listxattr, sys_llistxattr
@@ -142,7 +148,11 @@
 	.long sunos_getdirentries, sys_statfs, sys_fstatfs
 	.long sys_oldumount, sunos_nosys, sunos_nosys
 	.long sys_getdomainname, sys_setdomainname
+#ifdef CONFIG_RSBAC
+	.long sys_rsbac, sys_quotactl, sunos_nosys
+#else
 	.long sunos_nosys, sys_quotactl, sunos_nosys
+#endif
 	.long sunos_mount, sys_ustat, sunos_semsys
 	.long sunos_msgsys, sunos_shmsys, sunos_audit
 	.long sunos_nosys, sunos_getdents, sys_setsid
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc64/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc64/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc64/Kconfig	2007-03-15 13:38:06.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc64/Kconfig	2007-03-15 14:33:44.000000000 +0100
@@ -403,6 +403,8 @@
 
 	  NOTE: This option WILL override the PROM bootargs setting!
 
+source "rsbac/Kconfig"
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc64/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc64/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc64/kernel/process.c	2007-03-15 13:38:05.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc64/kernel/process.c	2007-03-15 14:33:44.000000000 +0100
@@ -46,6 +46,11 @@
 #include <asm/unistd.h>
 #include <asm/hypervisor.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /* #define VERBOSE_SHOWREGS */
 
 static void sparc64_yield(void)
@@ -696,9 +701,19 @@
 			     /* Notreached by child. */
 			     "1:" :
 			     "=r" (retval) :
+#ifdef CONFIG_RSBAC
+			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD),
+#else
 			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED),
+#endif
 			     "i" (__NR_exit),  "r" (fn), "r" (arg) :
 			     "g1", "g2", "g3", "o0", "o1", "memory", "cc");
+
+        #ifdef CONFIG_RSBAC
+	if(retval > 0)
+	  rsbac_kthread_notify(retval);
+        #endif
+
 	return retval;
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc64/kernel/ptrace.c ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc64/kernel/ptrace.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc64/kernel/ptrace.c	2007-03-15 13:38:05.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc64/kernel/ptrace.c	2007-03-15 14:33:44.000000000 +0100
@@ -33,6 +33,8 @@
 #include <asm/page.h>
 #include <asm/cpudata.h>
 
+#include <rsbac/hooks.h>
+
 /* Returning from ptrace is a bit tricky because the syscall return
  * low level code assumes any value returned which is negative and
  * is a valid errno will mean setting the condition codes to indicate
@@ -177,6 +179,11 @@
 	struct task_struct *child;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (test_thread_flag(TIF_32BIT)) {
 		addr &= 0xffffffffUL;
 		data &= 0xffffffffUL;
@@ -213,6 +220,22 @@
 		goto out;
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = pid;
+	rsbac_attribute_value.trace_request = request;
+	if (!rsbac_adf_request(R_TRACE,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_trace_request,
+				rsbac_attribute_value))
+	{
+		pt_error_return(regs, EPERM);
+		goto out_tsk;
+	}
+#endif
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc64/kernel/systbls.S ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc64/kernel/systbls.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/sparc64/kernel/systbls.S	2007-03-15 13:38:05.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/sparc64/kernel/systbls.S	2007-03-15 14:33:44.000000000 +0100
@@ -63,7 +63,11 @@
 	.word sys32_readahead, sys32_socketcall, sys32_syslog, sys32_lookup_dcookie, sys32_fadvise64
 /*210*/	.word sys32_fadvise64_64, sys32_tgkill, sys32_waitpid, sys_swapoff, sys32_sysinfo
 	.word sys32_ipc, sys32_sigreturn, sys_clone, sys32_ioprio_get, compat_sys_adjtimex
+#ifdef CONFIG_RSBAC
+/*220*/	.word sys32_sigprocmask, sys_rsbac, sys32_delete_module, sys_ni_syscall, sys32_getpgid
+#else
 /*220*/	.word sys32_sigprocmask, sys_ni_syscall, sys32_delete_module, sys_ni_syscall, sys32_getpgid
+#endif
 	.word sys32_bdflush, sys32_sysfs, sys_nis_syscall, sys32_setfsuid16, sys32_setfsgid16
 /*230*/	.word sys32_select, compat_sys_time, sys32_splice, compat_sys_stime, compat_sys_statfs64
 	.word compat_sys_fstatfs64, sys_llseek, sys_mlock, sys_munlock, sys32_mlockall
@@ -133,7 +137,11 @@
 	.word sys_readahead, sys_socketcall, sys_syslog, sys_lookup_dcookie, sys_fadvise64
 /*210*/	.word sys_fadvise64_64, sys_tgkill, sys_waitpid, sys_swapoff, sys_sysinfo
 	.word sys_ipc, sys_nis_syscall, sys_clone, sys_ioprio_get, sys_adjtimex
+#ifdef CONFIG_RSBAC
+/*220*/	.word sys_nis_syscall, sys_rsbac, sys_delete_module, sys_ni_syscall, sys_getpgid
+#else
 /*220*/	.word sys_nis_syscall, sys_ni_syscall, sys_delete_module, sys_ni_syscall, sys_getpgid
+#endif
 	.word sys_bdflush, sys_sysfs, sys_nis_syscall, sys_setfsuid, sys_setfsgid
 /*230*/	.word sys_select, sys_nis_syscall, sys_splice, sys_stime, sys_statfs64
 	.word sys_fstatfs64, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
@@ -230,7 +238,11 @@
 	.word sunos_nosys, sunos_nosys, sunos_nosys
 	.word sunos_nosys, sunos_nosys, sunos_nosys
 	.word sunos_nosys, sunos_nosys, sunos_nosys
+#ifdef CONFIG_RSBAC
+	.word sys_rsbac, sunos_nosys, sunos_nosys
+#else
 	.word sunos_nosys, sunos_nosys, sunos_nosys
+#endif
 	.word sunos_nosys, sunos_nosys, sunos_nosys
 	.word sunos_nosys, sunos_nosys, sunos_nosys
 	.word sunos_nosys, sunos_nosys, sunos_nosys
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/um/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/um/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/um/Kconfig	2007-03-15 13:37:59.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/um/Kconfig	2007-03-15 14:33:36.000000000 +0100
@@ -290,6 +290,8 @@
 
 source "init/Kconfig"
 
+source "rsbac/Kconfig"
+
 source "drivers/block/Kconfig"
 
 source "arch/um/Kconfig.char"
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/um/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/um/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/um/kernel/process.c	2007-03-15 13:37:57.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/um/kernel/process.c	2007-03-15 14:33:36.000000000 +0100
@@ -96,7 +96,11 @@
 
 	current->thread.request.u.thread.proc = fn;
 	current->thread.request.u.thread.arg = arg;
+#ifdef CONFIG_RSBAC
+	pid = do_fork(CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD | flags, 0,
+#else
 	pid = do_fork(CLONE_VM | CLONE_UNTRACED | flags, 0,
+#endif
 		      &current->thread.regs, 0, NULL, NULL);
 	if(pid < 0)
 		panic("do_fork failed in kernel_thread, errno = %d", pid);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/v850/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/v850/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/v850/Kconfig	2007-03-15 13:38:27.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/v850/Kconfig	2007-03-15 14:34:07.000000000 +0100
@@ -269,6 +269,10 @@
 
 #############################################################################
 
+source "rsbac/Kconfig"
+
+#############################################################################
+
 source "drivers/base/Kconfig"
 
 source drivers/mtd/Kconfig
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/v850/kernel/entry.S ./linux-2.6.19.3-rsbac-1.3.2/arch/v850/kernel/entry.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/v850/kernel/entry.S	2007-03-15 13:38:26.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/v850/kernel/entry.S	2007-03-15 14:34:07.000000000 +0100
@@ -1117,5 +1117,12 @@
 	.long CSYM(sys_pivot_root)	// 200
 	.long CSYM(sys_gettid)
 	.long CSYM(sys_tkill)
+#ifdef CONFIG_RSBAC
+	/* we use 230, until sys_security gets defined here */
+	.rept 229-202
+		.long CSYM(sys_ni_syscall)
+	.endr
+	.long CSYM(sys_rsbac)
+#endif
 sys_call_table_end:
 C_END(sys_call_table)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/v850/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/v850/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/v850/kernel/process.c	2007-03-15 13:38:26.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/v850/kernel/process.c	2007-03-15 14:34:07.000000000 +0100
@@ -29,6 +29,10 @@
 #include <asm/system.h>
 #include <asm/pgtable.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 void (*pm_power_off)(void) = NULL;
 EXPORT_SYMBOL(pm_power_off);
 
@@ -83,7 +87,11 @@
 	/* Clone this thread.  Note that we don't pass the clone syscall's
 	   second argument -- it's ignored for calls from kernel mode (the
 	   child's SP is always set to the top of the kernel stack).  */
+#ifdef CONFIG_RSBAC
+	arg0 = flags | CLONE_VM | CLONE_KTHREAD;
+#else
 	arg0 = flags | CLONE_VM;
+#endif
 	syscall = __NR_clone;
 	asm volatile ("trap " SYSCALL_SHORT_TRAP
 		      : "=r" (ret), "=r" (syscall)
@@ -103,6 +111,11 @@
 	/* In parent.  */
 	set_fs (fs);
 
+        #ifdef CONFIG_RSBAC
+	if(ret > 0)
+	  rsbac_kthread_notify(ret);
+        #endif
+
 	return ret;
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/x86_64/ia32/ia32entry.S ./linux-2.6.19.3-rsbac-1.3.2/arch/x86_64/ia32/ia32entry.S
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/x86_64/ia32/ia32entry.S	2007-03-15 13:38:21.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/x86_64/ia32/ia32entry.S	2007-03-15 14:34:03.000000000 +0100
@@ -622,7 +622,11 @@
 	.quad compat_sys_getdents64	/* 220 getdents64 */
 	.quad compat_sys_fcntl64	
 	.quad quiet_ni_syscall		/* tux */
+#ifdef CONFIG_RSBAC
+	.quad sys_rsbac		/* security */
+#else
 	.quad quiet_ni_syscall    	/* security */
+#endif
 	.quad sys_gettid	
 	.quad sys_readahead	/* 225 */
 	.quad sys_setxattr
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/x86_64/Kconfig ./linux-2.6.19.3-rsbac-1.3.2/arch/x86_64/Kconfig
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/x86_64/Kconfig	2007-03-15 13:38:21.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/x86_64/Kconfig	2007-03-15 14:34:01.000000000 +0100
@@ -645,6 +645,7 @@
 
 endmenu
 
+source "rsbac/Kconfig"
 
 menu "Executable file formats / Emulations"
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/x86_64/kernel/ioport.c ./linux-2.6.19.3-rsbac-1.3.2/arch/x86_64/kernel/ioport.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/x86_64/kernel/ioport.c	2007-03-15 13:38:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/x86_64/kernel/ioport.c	2007-03-15 14:34:02.000000000 +0100
@@ -11,12 +11,15 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/ioport.h>
+#include <linux/security.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
 #include <linux/slab.h>
 #include <linux/thread_info.h>
 
+#include <rsbac/hooks.h>
+
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base, unsigned int extent, int new_value)
 {
@@ -39,11 +42,33 @@
 	struct tss_struct * tss;
 	unsigned long *bitmap;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
+         /* RSBAC */
+         #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_ioports;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -107,12 +132,34 @@
 {
 	unsigned int old = (regs->eflags >> 12) & 3;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (level > 3)
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
+
+	        /* RSBAC */
+	        #ifdef CONFIG_RSBAC
+	        rsbac_pr_debug(aef, "calling ADF\n");
+	        rsbac_target_id.scd = ST_ioports;
+	        rsbac_attribute_value.dummy = 0;
+	        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+	                               current->pid,
+	                               T_SCD,
+	                               rsbac_target_id,
+	                               A_none,
+	                               rsbac_attribute_value))
+	          {
+	            return -EPERM;
+	          }
+	        #endif
 	}
 	regs->eflags = (regs->eflags &~ 0x3000UL) | (level << 12);
 	return 0;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/x86_64/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/x86_64/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/x86_64/kernel/process.c	2007-03-15 13:38:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/x86_64/kernel/process.c	2007-03-15 14:34:02.000000000 +0100
@@ -54,7 +54,11 @@
 
 asmlinkage extern void ret_from_fork(void);
 
+#ifdef CONFIG_RSBAC
+unsigned long kernel_thread_flags = CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD;
+#else
 unsigned long kernel_thread_flags = CLONE_VM | CLONE_UNTRACED;
+#endif
 
 unsigned long boot_option_idle_override = 0;
 EXPORT_SYMBOL(boot_option_idle_override);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/arch/xtensa/kernel/process.c ./linux-2.6.19.3-rsbac-1.3.2/arch/xtensa/kernel/process.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/arch/xtensa/kernel/process.c	2007-03-15 13:38:27.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/arch/xtensa/kernel/process.c	2007-03-15 14:34:08.000000000 +0100
@@ -206,7 +206,11 @@
 		 :"=r" (retval)
 		 :"i" (__NR_clone), "i" (__NR_exit),
 		 "r" (arg), "r" (fn),
+#ifdef CONFIG_RSBAC
+		 "r" (flags | CLONE_VM | CLONE_KTHREAD)
+#else
 		 "r" (flags | CLONE_VM)
+#endif
 		 : "a2", "a3", "a4", "a5", "a6" );
 	return retval;
 }
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/block/ioctl.c ./linux-2.6.19.3-rsbac-1.3.2/block/ioctl.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/block/ioctl.c	2007-03-15 13:36:47.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/block/ioctl.c	2007-03-15 14:32:45.000000000 +0100
@@ -8,6 +8,13 @@
 #include <linux/blktrace_api.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#include <linux/hdreg.h>
+#endif
+
+
 static int blkpg_ioctl(struct block_device *bdev, struct blkpg_ioctl_arg __user *arg)
 {
 	struct block_device *bdevp;
@@ -141,6 +148,73 @@
 	struct backing_dev_info *bdi;
 	int ret, n;
 
+	/* RSBAC */
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t     rsbac_request;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+	/* RSBAC */
+#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "blkdev_ioctl(): calling ADF\n");
+#endif
+	/* values taken from include/linux/fs.h and hdreg.h */
+	switch (cmd) {
+		case BLKGETSIZE:   /* Return device size */
+		case BLKGETSIZE64:
+		case BLKROGET:
+		case BLKRAGET:
+		case BLKFRAGET:
+		case BLKSECTGET:
+		case BLKSSZGET:
+		case BLKBSZGET:
+		case HDIO_GETGEO:
+		case HDIO_OBSOLETE_IDENTITY:
+		case HDIO_GET_UNMASKINTR:
+		case HDIO_GET_IDENTITY:
+		case HDIO_GET_NICE:
+		case HDIO_GET_BUSSTATE:
+		case HDIO_GET_QDMA:
+		case HDIO_GET_MULTCOUNT:
+		case HDIO_GET_KEEPSETTINGS:
+		case HDIO_GET_32BIT:
+		case HDIO_GET_NOWERR:
+		case HDIO_GET_DMA:
+		case HDIO_GET_WCACHE:
+		case HDIO_GET_ACOUSTIC:
+		case HDIO_GET_ADDRESS:
+			rsbac_request = R_GET_STATUS_DATA;
+			break;
+
+		default:
+			rsbac_request = R_MODIFY_SYSTEM_DATA;
+	}
+	rsbac_target_id.dev.type = D_block;
+	if(file && file->f_dentry && file->f_dentry->d_inode)
+	{
+		rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+	}
+	else
+	{
+		return -EINVAL;
+	}
+
+	rsbac_attribute_value.ioctl_cmd = cmd;
+	if (!rsbac_adf_request(rsbac_request,
+				current->pid,
+				T_DEV,
+				rsbac_target_id,
+				A_ioctl_cmd,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	switch (cmd) {
 	case BLKRAGET:
 	case BLKFRAGET:
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/Documentation/ftape.txt ./linux-2.6.19.3-rsbac-1.3.2/Documentation/ftape.txt
--- rsbac_tmp_15032007/kernel-2.6/trunk/Documentation/ftape.txt	2007-03-15 13:37:35.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/Documentation/ftape.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,307 +0,0 @@
-Intro
-=====
-
-This file describes some issues involved when using the "ftape"
-floppy tape device driver that comes with the Linux kernel.
-
-ftape has a home page at
-
-http://ftape.dot-heine.de/
-
-which contains further information about ftape. Please cross check
-this WWW address against the address given (if any) in the MAINTAINERS
-file located in the top level directory of the Linux kernel source
-tree.
-
-NOTE: This is an unmaintained set of drivers, and it is not guaranteed to work.
-If you are interested in taking over maintenance, contact Claus-Justus Heine
-<ch@dot-heine.de>, the former maintainer.
-
-Contents
-========
-
-A minus 1: Ftape documentation
-
-A. Changes
-   1. Goal
-   2. I/O Block Size
-   3. Write Access when not at EOD (End Of Data) or BOT (Begin Of Tape)
-   4. Formatting
-   5. Interchanging cartridges with other operating systems
-
-B. Debugging Output
-   1. Introduction
-   2. Tuning the debugging output
-
-C. Boot and load time configuration
-   1. Setting boot time parameters
-   2. Module load time parameters
-   3. Ftape boot- and load time options
-   4. Example kernel parameter setting
-   5. Example module parameter setting
-
-D. Support and contacts
-
-*******************************************************************************
-
-A minus 1. Ftape documentation
-==============================
-
-Unluckily, the ftape-HOWTO is out of date. This really needs to be
-changed. Up to date documentation as well as recent development
-versions of ftape and useful links to related topics can be found at
-the ftape home page at
-
-http://ftape.dot-heine.de/
-
-*******************************************************************************
-
-A. Changes
-==========
-
-1. Goal
-   ~~~~
-   The goal of all that incompatibilities was to give ftape an interface
-   that resembles the interface provided by SCSI tape drives as close
-   as possible. Thus any Unix backup program that is known to work
-   with SCSI tape drives should also work.
-
-   The concept of a fixed block size for read/write transfers is
-   rather unrelated to this SCSI tape compatibility at the file system
-   interface level. It developed out of a feature of zftape, a
-   block wise user transparent on-the-fly compression. That compression
-   support will not be dropped in future releases for compatibility
-   reasons with previous releases of zftape.
-
-2. I/O Block Size
-   ~~~~~~~~~~~~~~
-   The block size defaults to 10k which is the default block size of
-   GNU tar.
-
-   The block size can be tuned either during kernel configuration or
-   at runtime with the MTIOCTOP ioctl using the MTSETBLK operation
-   (i.e. do "mt -f /dev/qft0" setblk #BLKSZ). A block size of 0
-   switches to variable block size mode i.e. "mt setblk 0" switches
-   off the block size restriction. However, this disables zftape's
-   built in on-the-fly compression which doesn't work with variable
-   block size mode.
-
-   The BLKSZ parameter must be given as a byte count and must be a
-   multiple of 32k or 0, i.e. use "mt setblk 32768" to switch to a
-   block size of 32k.
-
-   The typical symptom of a block size mismatch is an "invalid
-   argument" error message.
-
-3. Write Access when not at EOD (End Of Data) or BOT (Begin Of Tape)
-   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-   zftape (the file system interface of ftape-3.x) denies write access
-   to the tape cartridge when it isn't positioned either at BOT or
-   EOD.
-
-4. Formatting
-   ~~~~~~~~~~
-   ftape DOES support formatting of floppy tape cartridges. You need the
-   `ftformat' program that is shipped with the modules version of ftape.
-   Please get the latest version of ftape from
-
-   ftp://sunsite.unc.edu/pub/Linux/kernel/tapes
-
-   or from the ftape home page at
-
-   http://ftape.dot-heine.de/
-
-   `ftformat' is contained in the `./contrib/' subdirectory of that
-   separate ftape package.
-
-5. Interchanging cartridges with other operating systems
-   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-   The internal emulation of Unix tape device file marks has changed
-   completely. ftape now uses the volume table segment as specified
-   by the QIC-40/80/3010/3020/113 standards to emulate file marks. As
-   a consequence there is limited support to interchange cartridges
-   with other operating systems.
-
-   To be more precise: ftape will detect volumes written by other OS's
-   programs and other OS's programs will detect volumes written by
-   ftape.
-
-   However, it isn't possible to extract the data dumped to the tape
-   by some MSDOS program with ftape. This exceeds the scope of a
-   kernel device driver. If you need such functionality, then go ahead
-   and write a user space utility that is able to do that. ftape already
-   provides all kernel level support necessary to do that.
-
-*******************************************************************************
-
-B. Debugging Output
-   ================
-
-1. Introduction
-   ~~~~~~~~~~~~
-   The ftape driver can be very noisy in that is can print lots of
-   debugging messages to the kernel log files and the system console.
-   While this is useful for debugging it might be annoying during
-   normal use and enlarges the size of the driver by several kilobytes.
-
-   To reduce the size of the driver you can trim the maximal amount of
-   debugging information available during kernel configuration. Please
-   refer to the kernel configuration script and its on-line help
-   functionality.
-
-   The amount of debugging output maps to the "tracing" boot time
-   option and the "ft_tracing" modules option as follows:
-
-   0              bugs
-   1              + errors (with call-stack dump)
-   2              + warnings
-   3              + information
-   4              + more information
-   5              + program flow
-   6              + fdc/dma info
-   7              + data flow
-   8              + everything else
-
-2. Tuning the debugging output
-   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-   To reduce the amount of debugging output printed to the system
-   console you can
-
-   i)  trim the debugging output at run-time with
-
-       mt -f /dev/nqft0 setdensity #DBGLVL
-
-       where "#DBGLVL" is a number between 0 and 9
-
-   ii) trim the debugging output at module load time with
-
-       modprobe ftape ft_tracing=#DBGLVL
-
-       Of course, this applies only if you have configured ftape to be
-       compiled as a module.
-
-   iii) trim the debugging output during system boot time. Add the
-       following to the kernel command line:
-
-       ftape=#DBGLVL,tracing
-
-       Please refer also to the next section if you don't know how to
-       set boot time parameters.
-
-*******************************************************************************
-
-C. Boot and load time configuration
-   ================================
-
-1. Setting boot time parameters
-   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
-   Assuming that you use lilo, the LI)nux LO)ader, boot time kernel
-   parameters can be set by adding a line
-
-   append some_kernel_boot_time_parameter
-
-   to `/etc/lilo.conf' or at real boot time by typing in the options
-   at the prompt provided by LILO. I can't give you advice on how to
-   specify those parameters with other loaders as I don't use them.
-
-   For ftape, each "some_kernel_boot_time_parameter" looks like
-   "ftape=value,option". As an example, the debugging output can be
-   increased with
-
-   ftape=4,tracing
-
-   NOTE: the value precedes the option name.
-
-2. Module load time parameters
-   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-   Module parameters can be specified either directly when invoking
-   the program 'modprobe' at the shell prompt:
-
-   modprobe ftape ft_tracing=4
-
-   or by editing the file `/etc/modprobe.conf' in which case they take
-   effect each time when the module is loaded with `modprobe' (please
-   refer to the respective manual pages). Thus, you should add a line
-
-   options ftape ft_tracing=4
-
-   to `/etc/modprobe.conf` if you intend to increase the debugging
-   output of the driver.
-
-
-3. Ftape boot- and load time options
-   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-   i.   Controlling the amount of debugging output
-        DBGLVL has to be replaced by a number between 0 and 8.
-
-        module                 |  kernel command line
-        -----------------------|----------------------
-        ft_tracing=DBGLVL      |  ftape=DBGLVL,tracing
-
-   ii.  Hardware setup
-	BASE is the base address of your floppy disk controller,
-        IRQ and DMA give its interrupt and DMA channel, respectively.
-        BOOL is an integer, "0" means "no"; any other value means
-	"yes". You don't need to specify anything if connecting your tape
-        drive to the standard floppy disk controller. All of these
-	values have reasonable defaults. The defaults can be modified
-	during kernel configuration, i.e. while running "make config",
-	"make menuconfig" or "make xconfig" in the top level directory
-	of the Linux kernel source tree. Please refer also to the on
-	line documentation provided during that kernel configuration
-	process.
-
-	ft_probe_fc10 is set to a non-zero value if you wish for ftape to
-	probe for a Colorado FC-10 or FC-20 controller.
-
-	ft_mach2 is set to a non-zero value if you wish for ftape to probe
-	for a Mountain MACH-2 controller.
-
-        module                 |  kernel command line
-        -----------------------|----------------------
-        ft_fdc_base=BASE       |  ftape=BASE,ioport
-        ft_fdc_irq=IRQ         |  ftape=IRQ,irq
-        ft_fdc_dma=DMA         |  ftape=DMA,dma
-        ft_probe_fc10=BOOL     |  ftape=BOOL,fc10
-        ft_mach2=BOOL          |  ftape=BOOL,mach2
-        ft_fdc_threshold=THR   |  ftape=THR,threshold
-        ft_fdc_rate_limit=RATE |  ftape=RATE,datarate
-
-4. Example kernel parameter setting
-   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
-   To configure ftape to probe for a Colorado FC-10/FC-20 controller
-   and to increase the amount of debugging output a little bit, add
-   the following line to `/etc/lilo.conf':
-
-   append ftape=1,fc10 ftape=4,tracing
-
-5. Example module parameter setting
-   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-   To do the same, but with ftape compiled as a loadable kernel
-   module, add the following line to `/etc/modprobe.conf':
-
-   options ftape ft_probe_fc10=1 ft_tracing=4
-
-*******************************************************************************
-
-D. Support and contacts
-   ====================
-
-   Ftape is distributed under the GNU General Public License. There is
-   absolutely no warranty for this software. However, you can reach
-   the current maintainer of the ftape package under the email address
-   given in the MAINTAINERS file which is located in the top level
-   directory of the Linux kernel source tree. There you'll find also
-   the relevant mailing list to use as a discussion forum and the web
-   page to query for the most recent documentation, related work and
-   development versions of ftape.
-
-   Changelog:
-   ==========
-
-~1996:		Original Document
-
-10-24-2004:	General cleanup and updating, noting additional module options.
-		James Nelson <james4765@gmail.com>
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/drivers/block/loop.c ./linux-2.6.19.3-rsbac-1.3.2/drivers/block/loop.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/drivers/block/loop.c	2007-03-15 13:39:57.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/drivers/block/loop.c	2007-03-15 14:35:18.000000000 +0100
@@ -77,6 +77,8 @@
 
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 static int max_loop = 8;
 static struct loop_device *loop_dev;
 static struct gendisk **disks;
@@ -724,6 +726,13 @@
 	int		error;
 	loff_t		size;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* This is safe, since we have a reference from open(). */
 	__module_get(THIS_MODULE);
 
@@ -790,6 +799,51 @@
 	if (!(lo_file->f_mode & FMODE_WRITE))
 		lo_flags |= LO_FLAGS_READ_ONLY;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[lo_ioctl()]: calling ADF for FILE/DEV\n");
+        if(S_ISREG(inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.dir.device = lo_file->f_dentry->d_sb->s_dev;
+            rsbac_target_id.dir.inode  = inode->i_ino;
+            rsbac_target_id.dir.dentry_p = file->f_dentry;
+          }
+        else
+          { /* must be block */
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out_putf;
+          }
+        rsbac_pr_debug(aef, "[lo_ioctl()]: calling ADF for DEV\n");
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(bdev->bd_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(bdev->bd_dev);
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out_putf;
+          }
+        #endif
+
 	set_device_ro(bdev, (lo_flags & LO_FLAGS_READ_ONLY) != 0);
 
 	lo->lo_blocksize = lo_blocksize;
@@ -887,6 +941,13 @@
 	struct file *filp = lo->lo_backing_file;
 	gfp_t gfp = lo->old_gfp_mask;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (lo->lo_state != Lo_bound)
 		return -ENXIO;
 
@@ -896,6 +957,49 @@
 	if (filp == NULL)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[lo_ioctl()]: calling ADF for FILE/DEV\n");
+        if(S_ISREG(filp->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.dir.device = filp->f_dentry->d_sb->s_dev;
+            rsbac_target_id.dir.inode  = filp->f_dentry->d_inode->i_ino;
+            rsbac_target_id.dir.dentry_p = filp->f_dentry;
+          }
+        else
+          { /* must be block dev */
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        rsbac_pr_debug(aef, "[lo_ioctl()]: calling ADF for DEV\n");
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = LOOP_MAJOR;
+        rsbac_target_id.dev.minor = lo->lo_number;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	spin_lock_irq(&lo->lo_lock);
 	lo->lo_state = Lo_rundown;
 	spin_unlock_irq(&lo->lo_lock);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/drivers/char/mem.c ./linux-2.6.19.3-rsbac-1.3.2/drivers/char/mem.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/drivers/char/mem.c	2007-03-15 13:39:21.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/drivers/char/mem.c	2007-03-15 14:34:53.000000000 +0100
@@ -35,6 +35,8 @@
 # include <linux/efi.h>
 #endif
 
+#include <rsbac/hooks.h>
+
 /*
  * Architectures vary in how they handle caching for addresses
  * outside of main memory.
@@ -799,7 +801,28 @@
 
 static int open_port(struct inode * inode, struct file * filp)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	if(!capable(CAP_SYS_RAWIO))
+		return	-EPERM;
+
+	rsbac_target_id.scd = ST_kmem;
+	rsbac_attribute_value.dummy = 0;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+	else
+		return 0;
+#else
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+#endif
 }
 
 #define zero_lseek	null_lseek
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/drivers/char/sysrq.c ./linux-2.6.19.3-rsbac-1.3.2/drivers/char/sysrq.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/drivers/char/sysrq.c	2007-03-15 13:39:21.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/drivers/char/sysrq.c	2007-03-15 14:34:58.000000000 +0100
@@ -40,6 +40,11 @@
 #include <asm/ptrace.h>
 #include <asm/irq_regs.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/types.h>
+#include <rsbac/debug.h>
+#endif
+
 /* Whether we react on sysrq keys or just ignore them */
 int sysrq_enabled = 1;
 
@@ -143,6 +148,42 @@
 	.enable_mask	= SYSRQ_ENABLE_REMOUNT,
 };
 
+#if  (defined(CONFIG_RSBAC_AUTO_WRITE) && (CONFIG_RSBAC_AUTO_WRITE > 0)) \
+   || defined(CONFIG_RSBAC_INIT_THREAD)
+static void sysrq_handle_rsbac_wakeup(int key,
+		                      struct tty_struct *tty) {
+#ifdef CONFIG_RSBAC_RMSG
+	rsbac_printk(KERN_WARNING "SysRq: Emergency rsbacd/init wake-up!\n");
+#endif
+	wakeup_rsbacd(0);
+}
+static struct sysrq_key_op sysrq_rsbac_wakeup_op = {
+	handler:	sysrq_handle_rsbac_wakeup,
+	help_msg:	"rsbac_emergency_Wakeup",
+	action_msg:	"Emergency rsbacd/init wake-up!\n",
+};
+#endif
+#ifdef CONFIG_RSBAC_SOFTMODE_SYSRQ
+static void sysrq_handle_rsbac_softmode(int key,
+		                        struct tty_struct *tty) {
+	if(rsbac_softmode)
+	  {
+	    rsbac_printk(KERN_WARNING "Soft mode disabled via SysRq!\n");
+	    rsbac_softmode = 0;
+	  }
+	else
+	  {
+	    rsbac_printk(KERN_WARNING "Soft mode enabled via SysRq!\n");
+	    rsbac_softmode = 1;
+	  }
+}
+static struct sysrq_key_op sysrq_rsbac_softmode_op = {
+	handler:	sysrq_handle_rsbac_softmode,
+	help_msg:	"rsbac_toggle_softmode_X",
+	action_msg:	"RSBAC toggle softmode\n",
+};
+#endif
+
 #ifdef CONFIG_LOCKDEP
 static void sysrq_handle_showlocks(int key, struct tty_struct *tty)
 {
@@ -303,8 +344,17 @@
 	&sysrq_mountro_op,		/* u */
 	/* May be assigned at init time by SMP VOYAGER */
 	NULL,				/* v */
+#if  (defined(CONFIG_RSBAC_AUTO_WRITE) && (CONFIG_RSBAC_AUTO_WRITE > 0)) \
+   || defined(CONFIG_RSBAC_INIT_THREAD)
+	&sysrq_rsbac_wakeup_op,		/* w */
+#else
 	NULL,				/* w */
+#endif
+#ifdef CONFIG_RSBAC_SOFTMODE_SYSRQ
+	&sysrq_rsbac_softmode_op,	/* x */
+#else
 	NULL,				/* x */
+#endif
 	NULL,				/* y */
 	NULL				/* z */
 };
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/drivers/char/tty_io.c ./linux-2.6.19.3-rsbac-1.3.2/drivers/char/tty_io.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/drivers/char/tty_io.c	2007-03-15 13:39:21.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/drivers/char/tty_io.c	2007-03-15 14:34:55.000000000 +0100
@@ -100,10 +100,13 @@
 
 #include <linux/kbd_kern.h>
 #include <linux/vt_kern.h>
+#include <linux/security.h>
 #include <linux/selection.h>
 
 #include <linux/kmod.h>
 
+#include <rsbac/hooks.h>
+
 #undef TTY_DEBUG_HANGUP
 
 #define TTY_PARANOIA_CHECK 1
@@ -2729,10 +2732,35 @@
 	char ch, mbz = 0;
 	struct tty_ldisc *ld;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+ 
 	if ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (get_user(ch, p))
 		return -EFAULT;
+ 
+ 	/* RSBAC */
+ 	#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.dev.type = D_char;
+        rsbac_target_id.dev.major = tty->driver->major;
+        rsbac_target_id.dev.minor = tty->driver->minor_start + tty->index;
+ 	rsbac_attribute_value.dummy = 0;
+ 	if (!rsbac_adf_request(R_SEND,
+ 			       current->pid,
+ 			       T_DEV,
+ 			       rsbac_target_id,
+ 			       A_none,
+ 			       rsbac_attribute_value))
+ 	  {
+ 	    return -EPERM;
+ 	  }
+ 	#endif
+ 
 	ld = tty_ldisc_ref_wait(tty);
 	ld->receive_buf(tty, &ch, &mbz, 1);
 	tty_ldisc_deref(ld);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/drivers/char/tty_ioctl.c ./linux-2.6.19.3-rsbac-1.3.2/drivers/char/tty_ioctl.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/drivers/char/tty_ioctl.c	2007-03-15 13:39:21.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/drivers/char/tty_ioctl.c	2007-03-15 14:34:58.000000000 +0100
@@ -26,6 +26,8 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#include <rsbac/hooks.h>
+
 #undef TTY_DEBUG_WAIT_UNTIL_SENT
 
 #undef	DEBUG
@@ -455,12 +457,58 @@
 	int retval;
 	struct tty_ldisc *ld;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (tty->driver->type == TTY_DRIVER_TYPE_PTY &&
 	    tty->driver->subtype == PTY_TYPE_MASTER)
 		real_tty = tty->link;
 	else
 		real_tty = tty;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	switch (cmd) {
+#ifdef TIOCGETP
+		case TIOCGETP:
+#endif
+#ifdef TIOCGETC
+		case TIOCGETC:
+#endif
+#ifdef TIOCGLTC
+		case TIOCGLTC:
+#endif
+		case TCGETS:
+		case TCGETA:
+		case TIOCOUTQ:
+		case TIOCINQ:
+		case TIOCGLCKTRMIOS:
+		case TIOCGSOFTCAR:
+		  rsbac_request = R_GET_PERMISSIONS_DATA;
+		  break;
+		default:
+		  rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+	}
+        rsbac_target_id.dev.type = D_char;
+        rsbac_target_id.dev.major = tty->driver->major;
+        rsbac_target_id.dev.minor = tty->driver->minor_start + tty->index;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+			       current->pid,
+			       T_DEV,
+			       rsbac_target_id,
+			       A_none,
+			       rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	switch (cmd) {
 #ifdef TIOCGETP
 		case TIOCGETP:
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/drivers/ide/ide.c ./linux-2.6.19.3-rsbac-1.3.2/drivers/ide/ide.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/drivers/ide/ide.c	2007-03-15 13:40:08.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/drivers/ide/ide.c	2007-03-15 14:35:22.000000000 +0100
@@ -152,12 +152,14 @@
 #include <linux/seq_file.h>
 #include <linux/device.h>
 #include <linux/bitops.h>
+#include <linux/security.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
+#include <rsbac/hooks.h>
 
 /* default maximum number of failures */
 #define IDE_DEFAULT_MAX_FAILURES 	1
@@ -1259,6 +1261,62 @@
 	int err = 0;
 	void __user *p = (void __user *)arg;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+        /* values taken from include/linux/fs.h and hdreg.h */
+	switch (cmd) {
+	 	case BLKGETSIZE:   /* Return device size */
+	 	case BLKGETSIZE64:
+		case BLKROGET:
+		case BLKRAGET:
+		case BLKFRAGET:
+		case BLKSECTGET:
+		case BLKSSZGET:
+		case BLKBSZGET:
+		case HDIO_GETGEO:
+		case HDIO_OBSOLETE_IDENTITY:
+                case HDIO_GET_UNMASKINTR:
+		case HDIO_GET_IDENTITY:
+		case HDIO_GET_NICE:
+		case HDIO_GET_BUSSTATE:
+		case HDIO_GET_QDMA:
+		case HDIO_GET_MULTCOUNT:
+		case HDIO_GET_KEEPSETTINGS:
+		case HDIO_GET_32BIT:
+		case HDIO_GET_NOWERR:
+		case HDIO_GET_DMA:
+		case HDIO_GET_WCACHE:
+		case HDIO_GET_ACOUSTIC:
+		case HDIO_GET_ADDRESS:
+		  rsbac_request = R_GET_STATUS_DATA;
+		  break;
+
+		default:
+		  rsbac_request = R_MODIFY_SYSTEM_DATA;
+	}
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(bdev->bd_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(bdev->bd_dev);
+        rsbac_attribute_value.ioctl_cmd = cmd;
+        if (!rsbac_adf_request(rsbac_request,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_ioctl_cmd,
+                               rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	down(&ide_setting_sem);
 	if ((setting = ide_find_setting_by_ioctl(drive, cmd)) != NULL) {
 		if (cmd == setting->read_ioctl) {
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/exec.c ./linux-2.6.19.3-rsbac-1.3.2/fs/exec.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/exec.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/exec.c	2007-03-15 14:33:01.000000000 +0100
@@ -57,6 +57,8 @@
 #include <linux/kmod.h>
 #endif
 
+#include <rsbac/hooks.h>
+
 int core_uses_pid;
 char core_pattern[128] = "core";
 int suid_dumpable = 0;
@@ -127,6 +129,11 @@
 	struct nameidata nd;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = __user_path_lookup_open(library, LOOKUP_FOLLOW, &nd, FMODE_READ|FMODE_EXEC);
 	if (error)
 		goto out;
@@ -135,10 +142,35 @@
 	if (!S_ISREG(nd.dentry->d_inode->i_mode))
 		goto exit;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(nd.dentry))
+		error = 0;
+	else
+#endif
 	error = vfs_permission(&nd, MAY_READ | MAY_EXEC);
 	if (error)
 		goto exit;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.file.device = nd.dentry->d_inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = nd.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MAP_EXEC,
+				current->pid,
+				T_FILE,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_pr_debug(aef, "request not granted, my PID: %i\n",
+			       current->pid);
+		error = -EPERM;
+		goto exit;
+	}
+#endif
+
 	file = nameidata_to_filp(&nd, O_RDONLY);
 	error = PTR_ERR(file);
 	if (IS_ERR(file))
@@ -164,6 +196,30 @@
 		read_unlock(&binfmt_lock);
 	}
 	fput(file);
+
+        /* RSBAC: notify ADF of mapped segment */
+        #ifdef CONFIG_RSBAC
+        if(!error)
+          {
+            union rsbac_target_id_t rsbac_new_target_id;
+
+            rsbac_pr_debug(aef, "calling ADF_set_attr\n");
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_MAP_EXEC,
+                                   current->pid,
+                                   T_FILE,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_uselib(): rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 out:
   	return error;
 exit:
@@ -485,7 +541,14 @@
 		file = ERR_PTR(-EACCES);
 		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
 		    S_ISREG(inode->i_mode)) {
-			int err = vfs_permission(&nd, MAY_EXEC);
+			int err;
+
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+			if(rsbac_dac_part_disabled(nd.dentry))
+				err = 0;
+			else
+#endif
+			err = vfs_permission(&nd, MAY_EXEC);
 			file = ERR_PTR(err);
 			if (!err) {
 				file = nameidata_to_filp(&nd, O_RDONLY);
@@ -1129,6 +1192,14 @@
 	int retval;
 	int i;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        int rsbac_has_file_ref = 0;
+        #endif
+
 	retval = -ENOMEM;
 	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
 	if (!bprm)
@@ -1167,6 +1238,30 @@
 	if (retval)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_execve()]: calling ADF\n");
+        rsbac_target_id.file.device = file->f_dentry->d_sb->s_dev;
+        rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = file->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_EXECUTE,
+                               current->pid,
+                               T_FILE,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_pr_debug(aef, "[sys_execve()]: request not granted, my PID: %i\n",
+			   current->pid);
+            retval = -EPERM;
+            goto out;
+          }
+
+        get_file(file);
+        rsbac_has_file_ref = 1;
+        #endif
+
 	retval = prepare_binprm(bprm);
 	if (retval < 0)
 		goto out;
@@ -1184,6 +1279,12 @@
 	if (retval < 0)
 		goto out;
 
+/*#ifdef CONFIG_RSBAC_CAP
+	retval = rsbac_cap_check_envp(bprm);
+	if (retval < 0)
+		goto out;
+#endif*/
+
 	retval = search_binary_handler(bprm,regs);
 	if (retval >= 0) {
 		free_arg_pages(bprm);
@@ -1191,6 +1292,29 @@
 		/* execve success */
 		security_bprm_free(bprm);
 		acct_update_integrals(current);
+
+                /* RSBAC: notify ADF of changed program in this process */
+                /*        Most structures are already filled            */
+                #ifdef CONFIG_RSBAC
+                rsbac_pr_debug(aef, "[sys_execve()]: calling ADF_set_attr\n");
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_EXECUTE,
+                                       current->pid,
+                                       T_FILE,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "do_execve() [sys_execve]: rsbac_adf_set_attr() returned error\n");
+                  }
+
+                if (rsbac_has_file_ref)
+                        fput(file);
+                #endif
+
 		kfree(bprm);
 		return retval;
 	}
@@ -1220,6 +1344,11 @@
 	kfree(bprm);
 
 out_ret:
+        #ifdef CONFIG_RSBAC
+        if (rsbac_has_file_ref)
+                fput(file);
+        #endif
+
 	return retval;
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/ext2/ioctl.c ./linux-2.6.19.3-rsbac-1.3.2/fs/ext2/ioctl.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/ext2/ioctl.c	2007-03-15 13:37:14.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/ext2/ioctl.c	2007-03-15 14:33:04.000000000 +0100
@@ -10,12 +10,17 @@
 #include "ext2.h"
 #include <linux/capability.h>
 #include <linux/time.h>
+#include <linux/security.h>
 #include <linux/sched.h>
 #include <linux/compat.h>
 #include <linux/smp_lock.h>
 #include <asm/current.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
 
 int ext2_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 		unsigned long arg)
@@ -23,6 +28,78 @@
 	struct ext2_inode_info *ei = EXT2_I(inode);
 	unsigned int flags;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        switch (cmd)
+          {
+            case EXT2_IOC_GETFLAGS:
+            case EXT2_IOC_GETVERSION:
+              rsbac_request = R_GET_PERMISSIONS_DATA;
+              break;
+            case EXT2_IOC_SETFLAGS:
+            case EXT2_IOC_SETVERSION:
+              rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+              break;
+            default:
+              rsbac_request = R_NONE;
+	  }
+        if(S_ISSOCK(inode->i_mode))
+          {
+            if(SOCKET_I(inode)->ops
+		    && (SOCKET_I(inode)->ops->family == AF_UNIX)) {
+		rsbac_target = T_UNIXSOCK;
+		rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+		rsbac_target_id.unixsock.inode  = inode->i_ino;
+		rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+	    }
+#ifdef CONFIG_RSBAC_NET_OBJ
+	    else {
+		    rsbac_target = T_NETOBJ;
+		    rsbac_target_id.netobj.sock_p
+			    = SOCKET_I(inode);
+		    rsbac_target_id.netobj.local_addr = NULL;
+		    rsbac_target_id.netobj.local_len = 0;
+		    rsbac_target_id.netobj.remote_addr = NULL;
+		    rsbac_target_id.netobj.remote_len = 0;
+	    }
+#endif
+          }
+        else
+          {
+            if (S_ISDIR(inode->i_mode))
+              rsbac_target = T_DIR;
+            else if (S_ISFIFO(inode->i_mode))
+              rsbac_target = T_FIFO;
+            else if (S_ISLNK(inode->i_mode))
+              rsbac_target = T_SYMLINK;
+            else
+              rsbac_target = T_FILE;
+            rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+            rsbac_target_id.file.inode  = inode->i_ino;
+            rsbac_target_id.file.dentry_p = filp->f_dentry;
+	  }
+        rsbac_attribute_value.ioctl_cmd = cmd;
+        if(   (rsbac_request != R_NONE)
+           && !rsbac_adf_request(rsbac_request,
+                                 current->pid,
+                                 rsbac_target,
+                                 rsbac_target_id,
+                                 A_ioctl_cmd,
+                                 rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	ext2_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/ext2/namei.c ./linux-2.6.19.3-rsbac-1.3.2/fs/ext2/namei.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/ext2/namei.c	2007-03-15 13:37:14.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/ext2/namei.c	2007-03-15 14:33:04.000000000 +0100
@@ -31,11 +31,14 @@
  */
 
 #include <linux/pagemap.h>
+#include <linux/security.h>
 #include "ext2.h"
 #include "xattr.h"
 #include "acl.h"
 #include "xip.h"
 
+#include <rsbac/hooks.h>
+
 static inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)
 {
 	int err = ext2_add_link(dentry, inode);
@@ -265,6 +268,12 @@
 	if (err)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        if(inode->i_nlink == 1)
+          rsbac_sec_del(dentry);
+        #endif
+
 	inode->i_ctime = dir->i_ctime;
 	inode_dec_link_count(inode);
 	err = 0;
@@ -322,6 +331,12 @@
 		new_de = ext2_find_entry (new_dir, new_dentry, &new_page);
 		if (!new_de)
 			goto out_dir;
+                
+#ifdef CONFIG_RSBAC_SECDEL
+		if(new_inode->i_nlink == 1)
+			rsbac_sec_del(new_dentry);
+#endif
+
 		inode_inc_link_count(old_inode);
 		ext2_set_link(new_dir, new_de, new_page, old_inode);
 		new_inode->i_ctime = CURRENT_TIME_SEC;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/ext3/ioctl.c ./linux-2.6.19.3-rsbac-1.3.2/fs/ext3/ioctl.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/ext3/ioctl.c	2007-03-15 13:37:14.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/ext3/ioctl.c	2007-03-15 14:33:04.000000000 +0100
@@ -12,11 +12,17 @@
 #include <linux/capability.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/security.h>
 #include <linux/time.h>
 #include <linux/compat.h>
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
+
 int ext3_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 		unsigned long arg)
 {
@@ -24,6 +30,87 @@
 	unsigned int flags;
 	unsigned short rsv_window_size;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        switch (cmd)
+          {
+#ifdef CONFIG_JBD_DEBUG
+            case EXT3_IOC_WAIT_FOR_READONLY:
+#endif
+            case EXT3_IOC_GETFLAGS:
+            case EXT3_IOC_GETVERSION:
+            case EXT3_IOC_GETVERSION_OLD:
+            case EXT3_IOC_GETRSVSZ:
+              rsbac_request = R_GET_PERMISSIONS_DATA;
+              break;
+            case EXT3_IOC_SETFLAGS:
+            case EXT3_IOC_SETVERSION:
+            case EXT3_IOC_SETVERSION_OLD:
+            case EXT3_IOC_SETRSVSZ:
+            case EXT3_IOC_GROUP_EXTEND:
+            case EXT3_IOC_GROUP_ADD:
+              rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+              break;
+            default:
+              rsbac_request = R_NONE;
+	  }
+        if(S_ISSOCK(inode->i_mode)) {
+		  if(SOCKET_I(inode)->ops
+			&& (SOCKET_I(inode)->ops->family == AF_UNIX)) {
+			  rsbac_target = T_UNIXSOCK;
+			  rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+			  rsbac_target_id.unixsock.inode  = inode->i_ino;
+			  rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+
+		  }
+#ifdef CONFIG_RSBAC_NET_OBJ
+		  else {
+			  rsbac_target = T_NETOBJ;
+			  rsbac_target_id.netobj.sock_p
+				  = SOCKET_I(inode);
+			  rsbac_target_id.netobj.local_addr = NULL;
+			  rsbac_target_id.netobj.local_len = 0;
+			  rsbac_target_id.netobj.remote_addr = NULL;
+			  rsbac_target_id.netobj.remote_len = 0;
+		  }
+#endif
+          }
+        else
+          {
+            if (S_ISDIR(inode->i_mode))
+              rsbac_target = T_DIR;
+            else if (S_ISFIFO(inode->i_mode))
+              rsbac_target = T_FIFO;
+            else if (S_ISLNK(inode->i_mode))
+              rsbac_target = T_SYMLINK;
+            else
+              rsbac_target = T_FILE;
+            rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+            rsbac_target_id.file.inode  = inode->i_ino;
+            rsbac_target_id.file.dentry_p = filp->f_dentry;
+	  }
+        rsbac_attribute_value.ioctl_cmd = cmd;
+        if(   (rsbac_request != R_NONE)
+           && !rsbac_adf_request(rsbac_request,
+                                 current->pid,
+                                 rsbac_target,
+                                 rsbac_target_id,
+                                 A_ioctl_cmd,
+                                 rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	ext3_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/ext3/namei.c ./linux-2.6.19.3-rsbac-1.3.2/fs/ext3/namei.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/ext3/namei.c	2007-03-15 13:37:14.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/ext3/namei.c	2007-03-15 14:33:05.000000000 +0100
@@ -31,6 +31,7 @@
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
 #include <linux/fcntl.h>
+#include <linux/security.h>
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/quotaops.h>
@@ -42,6 +43,8 @@
 #include "xattr.h"
 #include "acl.h"
 
+#include <rsbac/hooks.h>
+
 /*
  * define how far ahead to read directories while searching them.
  */
@@ -2110,6 +2113,13 @@
 	retval = ext3_delete_entry(handle, dir, de, bh);
 	if (retval)
 		goto end_unlink;
+
+        /* RSBAC ext3_unlink */
+        #ifdef CONFIG_RSBAC_SECDEL
+        if(inode->i_nlink == 1)
+          rsbac_sec_del(dentry);
+        #endif
+
 	dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;
 	ext3_update_dx_flag(dir);
 	ext3_mark_inode_dirty(handle, dir);
@@ -2263,6 +2273,13 @@
 			brelse (new_bh);
 			new_bh = NULL;
 		}
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_SECDEL
+                else
+                  if(new_inode->i_nlink == 1)
+                    rsbac_sec_del(new_dentry);
+                #endif
 	}
 	if (S_ISDIR(old_inode->i_mode)) {
 		if (new_inode) {
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/fcntl.c ./linux-2.6.19.3-rsbac-1.3.2/fs/fcntl.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/fcntl.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/fcntl.c	2007-03-15 14:32:56.000000000 +0100
@@ -22,6 +22,7 @@
 #include <asm/poll.h>
 #include <asm/siginfo.h>
 #include <asm/uaccess.h>
+#include <rsbac/hooks.h>
 
 void fastcall set_close_on_exec(unsigned int fd, int flag)
 {
@@ -318,6 +319,12 @@
 {
 	long err = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	switch (cmd) {
 	case F_DUPFD:
 		get_file(filp);
@@ -355,6 +362,21 @@
 		force_successful_syscall_return();
 		break;
 	case F_SETOWN:
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_pr_debug(aef, "calling ADF\n");
+                rsbac_target_id.process = arg;
+                rsbac_attribute_value.dummy = 0;
+                if(!rsbac_adf_request(R_SEND_SIGNAL,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_none,
+                                      rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
 		err = f_setown(filp, arg, 1);
 		break;
 	case F_GETSIG:
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/ioctl.c ./linux-2.6.19.3-rsbac-1.3.2/fs/ioctl.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/ioctl.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/ioctl.c	2007-03-15 14:33:00.000000000 +0100
@@ -16,14 +16,94 @@
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+#ifdef CONFIG_RSBAC_IOCTL
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
+
 static long do_ioctl(struct file *filp, unsigned int cmd,
 		unsigned long arg)
 {
 	int error = -ENOTTY;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IOCTL
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!filp->f_op)
 		goto out;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_IOCTL
+	if(S_ISBLK(filp->f_dentry->d_inode->i_mode))
+	  {
+	    rsbac_target = T_DEV;
+	    rsbac_target_id.dev.type = D_block;
+	    rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+	    rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+	  }
+	else
+	if(S_ISCHR(filp->f_dentry->d_inode->i_mode))
+	  {
+	    rsbac_target = T_DEV;
+	    rsbac_target_id.dev.type = D_char;
+	    rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+	    rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+	  }
+	else
+	if(S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+	  {
+            if(   SOCKET_I(filp->f_dentry->d_inode)->ops
+               && (SOCKET_I(filp->f_dentry->d_inode)->ops->family == AF_UNIX)
+              )
+              {
+		if(filp->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = filp->f_dentry->d_inode->i_ino;
+		} else {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = filp->f_dentry->d_inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+		}
+              }
+            else {
+            #ifdef CONFIG_RSBAC_NET_OBJ
+		rsbac_target = T_NETOBJ;
+		rsbac_target_id.netobj.sock_p
+		  = SOCKET_I(filp->f_dentry->d_inode);
+		rsbac_target_id.netobj.local_addr = NULL;
+		rsbac_target_id.netobj.local_len = 0;
+		rsbac_target_id.netobj.remote_addr = NULL;
+		rsbac_target_id.netobj.remote_len = 0;
+            #else
+                rsbac_target = T_NONE;
+	    #endif
+	    }
+	  }
+	else
+	  rsbac_target = T_NONE;
+	if(rsbac_target != T_NONE)
+	  {
+	    rsbac_pr_debug(aef, "[sys_ioctl()]: calling ADF\n");
+	    rsbac_attribute_value.ioctl_cmd = cmd;
+	    if (!rsbac_adf_request(R_IOCTL,
+	                           current->pid,
+	                           rsbac_target,
+	                           rsbac_target_id,
+	                           A_ioctl_cmd,
+	                           rsbac_attribute_value))
+	      {
+	        error = -EPERM;
+	        goto out;
+	      }
+	  }
+	#endif
+
 	if (filp->f_op->unlocked_ioctl) {
 		error = filp->f_op->unlocked_ioctl(filp, cmd, arg);
 		if (error == -ENOIOCTLCMD)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/ioprio.c ./linux-2.6.19.3-rsbac-1.3.2/fs/ioprio.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/ioprio.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/ioprio.c	2007-03-15 14:32:55.000000000 +0100
@@ -25,6 +25,7 @@
 #include <linux/capability.h>
 #include <linux/syscalls.h>
 #include <linux/security.h>
+#include <rsbac/hooks.h>
 
 static int set_task_ioprio(struct task_struct *task, int ioprio)
 {
@@ -62,6 +63,27 @@
 	struct user_struct *user;
 	int ret;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_SCD;
+	rsbac_target_id.scd = ST_priority;
+	rsbac_attribute_value.priority = ioprio;
+
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_priority,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	switch (class) {
 		case IOPRIO_CLASS_RT:
 			if (!capable(CAP_SYS_ADMIN))
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/locks.c ./linux-2.6.19.3-rsbac-1.3.2/fs/locks.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/locks.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/locks.c	2007-03-15 14:32:55.000000000 +0100
@@ -129,6 +129,8 @@
 #include <asm/semaphore.h>
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 #define IS_POSIX(fl)	(fl->fl_flags & FL_POSIX)
 #define IS_FLOCK(fl)	(fl->fl_flags & FL_FLOCK)
 #define IS_LEASE(fl)	(fl->fl_flags & FL_LEASE)
@@ -1573,6 +1575,13 @@
 	int can_sleep, unlock;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EBADF;
 	filp = fget(fd);
 	if (!filp)
@@ -1585,6 +1594,34 @@
 	if (!unlock && !(cmd & LOCK_MAND) && !(filp->f_mode & 3))
 		goto out_putf;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target = T_FILE;
+        if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        else if (S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_UNIXSOCK;
+        rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+        rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_LOCK,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out_putf;
+          }
+        #endif
+
 	error = flock_make_lock(filp, &lock, cmd);
 	if (error)
 		goto out_putf;
@@ -1620,6 +1657,13 @@
 	struct flock flock;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EFAULT;
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
@@ -1631,6 +1675,34 @@
 	if (error)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_fcntl()]: calling ADF\n");
+        rsbac_target = T_FILE;
+        if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        else if (S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_UNIXSOCK;
+        rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+        rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out;
+          }
+        #endif
+
 	if (filp->f_op && filp->f_op->lock) {
 		error = filp->f_op->lock(filp, F_GETLK, &file_lock);
 		if (file_lock.fl_ops && file_lock.fl_ops->fl_release_private)
@@ -1682,6 +1754,13 @@
 	struct inode *inode;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (file_lock == NULL)
 		return -ENOLCK;
 
@@ -1712,6 +1791,34 @@
 		file_lock->fl_flags |= FL_SLEEP;
 	}
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_fcntl()]: calling ADF\n");
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        else if (S_ISSOCK(inode->i_mode))
+          rsbac_target = T_UNIXSOCK;
+        rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_LOCK,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out;
+          }
+        #endif
+
 	error = -EBADF;
 	switch (flock.l_type) {
 	case F_RDLCK:
@@ -1774,6 +1881,13 @@
 	struct flock64 flock;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EFAULT;
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
@@ -1785,6 +1899,34 @@
 	if (error)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_fcntl()]: calling ADF\n");
+        rsbac_target = T_FILE;
+        if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        else if (S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_UNIXSOCK;
+        rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+        rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out;
+          }
+        #endif
+
 	if (filp->f_op && filp->f_op->lock) {
 		error = filp->f_op->lock(filp, F_GETLK, &file_lock);
 		if (file_lock.fl_ops && file_lock.fl_ops->fl_release_private)
@@ -1825,6 +1967,13 @@
 	struct inode *inode;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (file_lock == NULL)
 		return -ENOLCK;
 
@@ -1872,6 +2021,34 @@
 		goto out;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_fcntl()]: calling ADF\n");
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        else if (S_ISSOCK(inode->i_mode))
+          rsbac_target = T_UNIXSOCK;
+        rsbac_target_id.file.device = filp->f_dentry->d_sb->s_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_LOCK,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out;
+          }
+        #endif
+
 	error = security_file_lock(filp, file_lock->fl_type);
 	if (error)
 		goto out;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/minix/namei.c ./linux-2.6.19.3-rsbac-1.3.2/fs/minix/namei.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/minix/namei.c	2007-03-15 13:37:10.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/minix/namei.c	2007-03-15 14:33:01.000000000 +0100
@@ -6,6 +6,8 @@
 
 #include "minix.h"
 
+#include <rsbac/hooks.h>
+
 static int add_nondir(struct dentry *dentry, struct inode *inode)
 {
 	int err = minix_add_link(dentry, inode);
@@ -189,6 +191,12 @@
 	if (err)
 		goto end_unlink;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        if(inode->i_nlink == 1)
+          rsbac_sec_del(dentry);
+        #endif
+
 	inode->i_ctime = dir->i_ctime;
 	inode_dec_link_count(inode);
 end_unlink:
@@ -245,6 +253,12 @@
 		new_de = minix_find_entry(new_dentry, &new_page);
 		if (!new_de)
 			goto out_dir;
+                
+#ifdef CONFIG_RSBAC_SECDEL
+		if(new_inode->i_nlink == 1)
+			rsbac_sec_del(new_dentry);
+#endif
+
 		inode_inc_link_count(old_inode);
 		minix_set_link(new_de, new_page, old_inode);
 		new_inode->i_ctime = CURRENT_TIME_SEC;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/msdos/namei.c ./linux-2.6.19.3-rsbac-1.3.2/fs/msdos/namei.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/msdos/namei.c	2007-03-15 13:37:10.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/msdos/namei.c	2007-03-15 14:33:01.000000000 +0100
@@ -10,8 +10,11 @@
 #include <linux/time.h>
 #include <linux/buffer_head.h>
 #include <linux/msdos_fs.h>
+#include <linux/security.h>
 #include <linux/smp_lock.h>
 
+#include <rsbac/hooks.h>
+
 /* Characters that are undesirable in an MS-DOS file name */
 static unsigned char bad_chars[] = "*?<>|\"";
 static unsigned char bad_if_strict_pc[] = "+=,; ";
@@ -433,6 +436,12 @@
 	clear_nlink(inode);
 	inode->i_ctime = CURRENT_TIME_SEC;
 	fat_detach(inode);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        rsbac_sec_del(dentry);
+        #endif
+
 out:
 	unlock_kernel();
 	if (!err)
@@ -526,6 +535,15 @@
 	}
 	new_dir->i_version++;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+	if (new_inode)
+	      {
+                if(new_inode->i_nlink == 1)
+                  rsbac_sec_del(new_dentry);
+	      }
+        #endif
+
 	fat_detach(old_inode);
 	fat_attach(old_inode, new_i_pos);
 	if (is_hid)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/namei.c ./linux-2.6.19.3-rsbac-1.3.2/fs/namei.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/namei.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/namei.c	2007-03-15 14:32:53.000000000 +0100
@@ -34,6 +34,7 @@
 #include <linux/namei.h>
 #include <asm/namei.h>
 #include <asm/uaccess.h>
+#include <rsbac/hooks.h>
 
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 
@@ -247,6 +248,11 @@
 	}
 
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_FULL
+	if(rsbac_dac_disable)
+	  return 0;
+#endif
+
 	/*
 	 * MAY_EXEC on regular files requires special handling: We override
 	 * filesystem execute permissions if the mode bits aren't set.
@@ -610,8 +616,20 @@
 	if (!IS_ERR(cookie)) {
 		char *s = nd_get_link(nd);
 		error = 0;
-		if (s)
+		if (s) {
+#ifdef CONFIG_RSBAC_SYM_REDIR
+			char * rsbac_name;
+
+			rsbac_name = rsbac_symlink_redirect(dentry, s, PAGE_SIZE);
+			if(rsbac_name)
+			{
+				error = __vfs_follow_link(nd, rsbac_name);
+				kfree(rsbac_name);
+			}
+			else
+#endif
 			error = __vfs_follow_link(nd, s);
+                }
 		if (dentry->d_inode->i_op->put_link)
 			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
 	}
@@ -631,6 +649,12 @@
 static inline int do_follow_link(struct path *path, struct nameidata *nd)
 {
 	int err = -ELOOP;
+
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (current->link_count >= MAX_NESTED_LINKS)
 		goto loop;
 	if (current->total_link_count >= 40)
@@ -640,6 +664,28 @@
 	err = security_inode_follow_link(path->dentry, nd);
 	if (err)
 		goto loop;
+
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.dir.device = path->dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = path->dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path->dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEARCH,
+				current->pid,
+				T_SYMLINK,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+		err = -ENOENT;
+#else
+		err = -EPERM;
+#endif
+		goto loop;
+	}
+#endif
+
 	current->link_count++;
 	current->total_link_count++;
 	nd->depth++;
@@ -817,6 +863,11 @@
 	int err;
 	unsigned int lookup_flags = nd->flags;
 	
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	while (*name=='/')
 		name++;
 	if (!*name)
@@ -833,12 +884,38 @@
 		unsigned int c;
 
 		nd->flags |= LOOKUP_CONTINUE;
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+		if(rsbac_dac_part_disabled(nd->dentry))
+			err = 0;
+		else
+#endif
 		err = exec_permission_lite(inode, nd);
 		if (err == -EAGAIN)
 			err = vfs_permission(nd, MAY_EXEC);
  		if (err)
 			break;
 
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.dir.device = inode->i_sb->s_dev;
+		rsbac_target_id.dir.inode  = inode->i_ino;
+		rsbac_target_id.dir.dentry_p = nd->dentry;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_SEARCH,
+					current->pid,
+					T_DIR,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+			err = -ENOENT;
+#else
+			err = -EPERM;
+#endif
+			break;
+		}
+#endif
+
 		this.name = name;
 		c = *(const unsigned char *)name;
 
@@ -985,6 +1062,23 @@
 				break;
 		}
 return_base:
+
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+		rsbac_target_id.dir.device = nd->dentry->d_inode->i_sb->s_dev;
+		rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+		rsbac_target_id.dir.dentry_p = nd->dentry;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_SEARCH,
+					current->pid,
+					T_DIR,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			path_release(nd);
+			return -ENOENT;
+		}
+#endif
 		return 0;
 out_dput:
 		dput_path(&next, nd);
@@ -1257,12 +1351,41 @@
 	struct inode *inode;
 	int err;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	inode = base->d_inode;
+
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(base))
+		err = 0;
+	else
+#endif
 	err = permission(inode, MAY_EXEC, nd);
 	dentry = ERR_PTR(err);
 	if (err)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.dir.device = inode->i_sb->s_dev;
+	rsbac_target_id.dir.inode  = inode->i_ino;
+	rsbac_target_id.dir.dentry_p = base;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEARCH,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		dentry = ERR_PTR(err);
+		goto out;
+	}
+#endif
+
 	/*
 	 * See if the low-level filesystem might want
 	 * to use its own hash..
@@ -1321,6 +1444,82 @@
 	return ERR_PTR(-EACCES);
 }
 
+/* RSBAC
+ * I hate to put new functions into this file, but even more I hate removing
+ * all statics from all the lookup helpers in here...
+ * Still, I need some form of RSBAC bypass for internal file access.
+ * Amon Ott <ao@rsbac.org>
+ */
+#ifdef CONFIG_RSBAC
+static struct dentry * __rsbac_lookup_hash(struct qstr *name, struct dentry * base, struct nameidata *nd)
+{
+	struct dentry * dentry;
+	struct inode *inode;
+	int err;
+
+	inode = base->d_inode;
+
+	/*
+	 * See if the low-level filesystem might want
+	 * to use its own hash..
+	 */
+	if (base->d_op && base->d_op->d_hash) {
+		err = base->d_op->d_hash(base, name);
+		dentry = ERR_PTR(err);
+		if (err < 0)
+			goto out;
+	}
+
+	dentry = cached_lookup(base, name, nd);
+	if (!dentry) {
+		struct dentry *new = d_alloc(base, name);
+		dentry = ERR_PTR(-ENOMEM);
+		if (!new)
+			goto out;
+		dentry = inode->i_op->lookup(inode, new, nd);
+		if (!dentry)
+			dentry = new;
+		else
+			dput(new);
+	}
+out:
+	return dentry;
+}
+
+struct dentry * rsbac_lookup_hash(struct qstr *name, struct dentry * base)
+{
+	return __rsbac_lookup_hash(name, base, NULL);
+}
+
+/* SMP-safe */
+struct dentry * rsbac_lookup_one_len(const char * name, struct dentry * base, int len)
+{
+	unsigned long hash;
+	struct qstr this;
+	unsigned int c;
+
+	this.name = name;
+	this.len = len;
+	if (!len)
+		goto access;
+
+	hash = init_name_hash();
+	while (len--) {
+		c = *(const unsigned char *)name++;
+		if (c == '/' || c == '\0')
+			goto access;
+		hash = partial_name_hash(c, hash);
+	}
+	this.hash = end_name_hash(hash);
+
+	return rsbac_lookup_hash(&this, base);
+access:
+	return ERR_PTR(-EACCES);
+}
+
+EXPORT_SYMBOL(rsbac_lookup_one_len);
+#endif
+
 /*
  *	namei()
  *
@@ -1394,6 +1593,11 @@
 	BUG_ON(victim->d_parent->d_inode != dir);
 	audit_inode_child(victim->d_name.name, victim->d_inode, dir);
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(victim))
+		error = 0;
+	else
+#endif
 	error = permission(dir,MAY_WRITE | MAY_EXEC, NULL);
 	if (error)
 		return error;
@@ -1431,6 +1635,12 @@
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
+
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(child->d_parent))
+		return 0;
+	else
+#endif
 	return permission(dir,MAY_WRITE | MAY_EXEC, nd);
 }
 
@@ -1499,6 +1709,14 @@
 {
 	int error = may_create(dir, dentry, nd);
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	enum  rsbac_target_t          rsbac_new_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -1509,10 +1727,53 @@
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[open_namei() [filp_open() [do_open() [sys_open()]]]]: calling ADF\n");
+	rsbac_target = T_DIR;
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dir->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry->d_parent;
+	rsbac_attribute_value.create_data.target = T_FILE;
+	rsbac_attribute_value.create_data.dentry_p = dentry;
+	rsbac_attribute_value.create_data.mode = mode;
+	rsbac_attribute_value.create_data.device = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_create_data,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
-	if (!error)
+	if (!error) {
 		fsnotify_create(dir, dentry);
+
+		/* RSBAC: notify ADF of new file */
+#ifdef CONFIG_RSBAC
+		{
+			rsbac_new_target = T_FILE;
+			rsbac_new_target_id.file.device = dentry->d_sb->s_dev;
+			rsbac_new_target_id.file.inode  = dentry->d_inode->i_ino;
+			rsbac_new_target_id.file.dentry_p = dentry;
+			if (rsbac_adf_set_attr(R_CREATE,
+						current->pid,
+						rsbac_target,
+						rsbac_target_id,
+						rsbac_new_target,
+						rsbac_new_target_id,
+						A_create_data,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"vfs_create() [open_namei() [filp_open() [do_open() [sys_open()]]]]: rsbac_adf_set_attr() returned error");
+			}
+		}
+#endif
+	}
 	return error;
 }
 
@@ -1522,6 +1783,14 @@
 	struct inode *inode = dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_adf_request_t     rsbac_adf_req;
+	enum  rsbac_target_t          rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!inode)
 		return -ENOENT;
 
@@ -1531,6 +1800,11 @@
 	if (S_ISDIR(inode->i_mode) && (flag & FMODE_WRITE))
 		return -EISDIR;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(dentry))
+		error = 0;
+	else
+#endif
 	error = vfs_permission(nd, acc_mode);
 	if (error)
 		return error;
@@ -1564,6 +1838,79 @@
 		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
 			return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[open_namei() [filp_open() [do_open() [sys_open()]]]]: calling ADF\n");
+	/* get target type and id clear */
+	if(   S_ISBLK(inode->i_mode)
+			|| S_ISCHR(inode->i_mode))
+	{
+		rsbac_target = T_DEV;
+		if(S_ISBLK(inode->i_mode))
+		{
+			rsbac_target_id.dev.type = D_block;
+		}
+		else
+		{
+			rsbac_target_id.dev.type = D_char;
+		}
+		rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+	}
+		else /* must be file, dir or fifo */
+		{
+			if(S_ISDIR(inode->i_mode))
+				rsbac_target = T_DIR;
+			else if(S_ISSOCK(inode->i_mode))
+				rsbac_target = T_UNIXSOCK;
+			else if(S_ISFIFO(inode->i_mode))
+			{
+				if(inode->i_sb->s_magic != PIPEFS_MAGIC)
+					rsbac_target = T_FIFO;
+				else
+					rsbac_target = T_NONE;
+			}
+			else
+				rsbac_target = T_FILE;
+
+			rsbac_target_id.file.device = inode->i_sb->s_dev;
+			rsbac_target_id.file.inode  = inode->i_ino;
+			rsbac_target_id.file.dentry_p = dentry;
+		}
+	/* determine request type */
+	rsbac_adf_req = R_NONE;
+	if (flag & O_APPEND)
+		rsbac_adf_req = R_APPEND_OPEN;
+	else
+		if ((flag & FMODE_WRITE) && (flag & FMODE_READ))
+			rsbac_adf_req = R_READ_WRITE_OPEN;
+		else
+			if (flag & FMODE_WRITE)
+				rsbac_adf_req = R_WRITE_OPEN;
+			else
+				if (flag & FMODE_READ)
+				{
+					if(rsbac_target == T_DIR)
+						rsbac_adf_req = R_READ;
+					else
+						rsbac_adf_req = R_READ_OPEN;
+				}
+	if (   (rsbac_adf_req != R_NONE)
+			&& (rsbac_target != T_NONE)
+	   )
+	{
+		rsbac_attribute_value.open_flag = flag;
+		if (!rsbac_adf_request(rsbac_adf_req,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					A_open_flag,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+	}
+#endif /* CONFIG_RSBAC */
+
 	/*
 	 * Ensure there are no outstanding leases on the file.
 	 */
@@ -1592,6 +1939,27 @@
 		if (flag & FMODE_WRITE)
 			DQUOT_INIT(inode);
 
+#ifdef CONFIG_RSBAC
+	if (   (rsbac_adf_req != R_NONE)
+			&& (rsbac_target != T_NONE)
+	   )
+	{
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(rsbac_adf_req,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_open_flag,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"open_namei() [filp_open() [do_open() [sys_open()]]]: rsbac_adf_set_attr() returned error\n");
+		}
+	}
+#endif
+
 	return 0;
 }
 
@@ -1635,6 +2003,11 @@
 	struct dentry *dir;
 	int count = 0;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	acc_mode = ACC_MODE(flag);
 
 	/* O_TRUNC implies we need access checks for write permissions */
@@ -1758,6 +2131,24 @@
 	error = security_inode_follow_link(path.dentry, nd);
 	if (error)
 		goto exit_dput;
+
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.dir.device = path.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = path.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = path.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEARCH,
+				current->pid,
+				T_SYMLINK,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto exit_dput;
+	}
+#endif
+
 	error = __do_follow_link(&path, nd);
 	if (error) {
 		/* Does someone understand code flow here? Or it is only
@@ -1843,6 +2234,13 @@
 {
 	int error = may_create(dir, dentry, NULL);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	enum  rsbac_target_t          rsbac_new_target;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -1856,10 +2254,58 @@
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_mknod()]: calling ADF\n");
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dir->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry->d_parent;
+	rsbac_attribute_value.create_data.target = T_FILE;
+	rsbac_attribute_value.create_data.dentry_p = dentry;
+	rsbac_attribute_value.create_data.mode = mode;
+	rsbac_attribute_value.create_data.device = dev;
+	if (!rsbac_adf_request(R_CREATE,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_create_data,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	DQUOT_INIT(dir);
 	error = dir->i_op->mknod(dir, dentry, mode, dev);
-	if (!error)
+	if (!error) {
 		fsnotify_create(dir, dentry);
+
+#ifdef CONFIG_RSBAC
+		if(S_ISFIFO(dentry->d_inode->i_mode))
+			rsbac_new_target = T_FIFO;
+		else
+			if(S_ISLNK(dentry->d_inode->i_mode))
+				rsbac_new_target = T_SYMLINK;
+			else
+				if(S_ISSOCK(dentry->d_inode->i_mode))
+					rsbac_new_target = T_UNIXSOCK;
+				else
+					rsbac_new_target = T_FILE;
+		rsbac_new_target_id.dir.device = dentry->d_sb->s_dev;
+		rsbac_new_target_id.dir.inode  = dentry->d_inode->i_ino;
+		rsbac_new_target_id.dir.dentry_p = dentry;
+		if (rsbac_adf_set_attr(R_CREATE,
+					current->pid,
+					T_DIR,
+					rsbac_target_id,
+					rsbac_new_target,
+					rsbac_new_target_id,
+					A_create_data,
+					rsbac_attribute_value))
+		{
+			rsbac_pr_debug(aef, "[do_mknod(), sys_mknod()]: rsbac_adf_set_attr() returned error");
+		}
+#endif
+	}
 	return error;
 }
 
@@ -1922,6 +2368,12 @@
 {
 	int error = may_create(dir, dentry, NULL);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -1933,10 +2385,50 @@
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_mkdir()]: calling ADF\n");
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dir->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry->d_parent;
+	rsbac_attribute_value.create_data.target = T_DIR;
+	rsbac_attribute_value.create_data.dentry_p = dentry;
+	rsbac_attribute_value.create_data.mode = mode;
+	rsbac_attribute_value.create_data.device = 0;
+	rsbac_attribute_value.mode = mode;
+	if (!rsbac_adf_request(R_CREATE,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_create_data,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	DQUOT_INIT(dir);
 	error = dir->i_op->mkdir(dir, dentry, mode);
-	if (!error)
+	if (!error) {
 		fsnotify_mkdir(dir, dentry);
+
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.dir.device = dentry->d_sb->s_dev;
+		rsbac_new_target_id.dir.inode  = dentry->d_inode->i_ino;
+		rsbac_new_target_id.dir.dentry_p = dentry;
+		if (rsbac_adf_set_attr(R_CREATE,
+					current->pid,
+					T_DIR,
+					rsbac_target_id,
+					T_DIR,
+					rsbac_new_target_id,
+					A_create_data,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"vfs_mkdir() [sys_mkdir()]: rsbac_adf_set_attr() returned error");
+		}
+#endif
+	}
 	return error;
 }
 
@@ -2010,12 +2502,35 @@
 {
 	int error = may_delete(dir, dentry, 1);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
 	if (!dir->i_op || !dir->i_op->rmdir)
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_rmdir() [sys_rmdir()]]: calling ADF\n");
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_DELETE,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	DQUOT_INIT(dir);
 
 	mutex_lock(&dentry->d_inode->i_mutex);
@@ -2033,6 +2548,24 @@
 	mutex_unlock(&dentry->d_inode->i_mutex);
 	if (!error) {
 		d_delete(dentry);
+
+#ifdef CONFIG_RSBAC
+		{
+			rsbac_new_target_id.dummy = 0;
+			if (rsbac_adf_set_attr(R_DELETE,
+						current->pid,
+						T_DIR,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"vfs_rmdir() [do_rmdir() [sys_rmdir()]]: rsbac_adf_set_attr() returned error");
+			}
+		}
+#endif
 	}
 	dput(dentry);
 
@@ -2090,6 +2623,13 @@
 {
 	int error = may_delete(dir, dentry, 0);
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -2103,8 +2643,59 @@
 		error = -EBUSY;
 	else {
 		error = security_inode_unlink(dir, dentry);
-		if (!error)
+		if (!error) {
+#ifdef CONFIG_RSBAC
+			rsbac_pr_debug(aef, "[do_unlink() [sys_unlink()]]: calling ADF\n");
+			if(S_ISDIR(dentry->d_inode->i_mode))
+				rsbac_target = T_DIR;
+			else
+				if(S_ISFIFO(dentry->d_inode->i_mode))
+					rsbac_target = T_FIFO;
+				else
+					if(S_ISLNK(dentry->d_inode->i_mode))
+						rsbac_target = T_SYMLINK;
+					else
+					if(S_ISSOCK(dentry->d_inode->i_mode))
+						rsbac_target = T_UNIXSOCK;
+					else
+						rsbac_target = T_FILE;
+			rsbac_target_id.file.device = dentry->d_sb->s_dev;
+			rsbac_target_id.file.inode  = dentry->d_inode->i_ino;
+			rsbac_target_id.file.dentry_p = dentry;
+			rsbac_attribute_value.nlink = dentry->d_inode->i_nlink;
+			if (!rsbac_adf_request(R_DELETE,
+						current->pid,
+						rsbac_target,
+						rsbac_target_id,
+						A_nlink,
+						rsbac_attribute_value))
+			{
+				mutex_unlock(&dentry->d_inode->i_mutex);
+				return(-EPERM);
+			}
+#endif
+
 			error = dir->i_op->unlink(dir, dentry);
+
+#ifdef CONFIG_RSBAC
+			if (!error)
+			{
+				rsbac_new_target_id.dummy = 0;
+				if (rsbac_adf_set_attr(R_DELETE,
+							current->pid,
+							rsbac_target,
+							rsbac_target_id,
+							T_NONE,
+							rsbac_new_target_id,
+							A_nlink,
+							rsbac_attribute_value))
+				{
+					rsbac_printk(KERN_WARNING
+							"vfs_unlink() [do_unlink() [sys_unlink()]]: rsbac_adf_set_attr() returned error\n");
+				}
+			}
+#endif
+		}
 	}
 	mutex_unlock(&dentry->d_inode->i_mutex);
 
@@ -2189,6 +2780,12 @@
 {
 	int error = may_create(dir, dentry, NULL);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (error)
 		return error;
 
@@ -2199,10 +2796,49 @@
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_symlink(), sys_symlink()]: calling ADF\n");
+	rsbac_target_id.dir.device = dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = dir->i_ino;
+	rsbac_target_id.dir.dentry_p = dentry->d_parent;
+	rsbac_attribute_value.create_data.target = T_SYMLINK;
+	rsbac_attribute_value.create_data.dentry_p = dentry;
+	rsbac_attribute_value.create_data.mode = 0;
+	rsbac_attribute_value.create_data.device = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_create_data,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	DQUOT_INIT(dir);
 	error = dir->i_op->symlink(dir, dentry, oldname);
-	if (!error)
+	if (!error) {
 		fsnotify_create(dir, dentry);
+
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.file.device = dentry->d_sb->s_dev;
+		rsbac_new_target_id.file.inode  = dentry->d_inode->i_ino;
+		rsbac_new_target_id.file.dentry_p = dentry;
+		if (rsbac_adf_set_attr(R_CREATE,
+					current->pid,
+					T_DIR,
+					rsbac_target_id,
+					T_SYMLINK,
+					rsbac_new_target_id,
+					A_create_data,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"vfs_symlink() [do_symlink(), sys_symlink()]: rsbac_adf_set_attr() returned error");
+		}
+#endif
+	}
 	return error;
 }
 
@@ -2253,6 +2889,12 @@
 	struct inode *inode = old_dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!inode)
 		return -ENOENT;
 
@@ -2277,6 +2919,32 @@
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_link() [sys_link()]]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR (old_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO (old_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.dir.device = old_dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = old_dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = old_dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_LINK_HARD,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	mutex_lock(&old_dentry->d_inode->i_mutex);
 	DQUOT_INIT(dir);
 	error = dir->i_op->link(old_dentry, dir, new_dentry);
@@ -2383,12 +3051,28 @@
 	int error = 0;
 	struct inode *target;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	enum  rsbac_target_t          rsbac_target2 = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_target_id2;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	union rsbac_attribute_value_t rsbac_attribute_value2;
+	rsbac_boolean_t target_exists = FALSE;
+#endif
+
 	/*
 	 * If we are going to change the parent - check write permissions,
 	 * we'll need to flip '..'.
 	 */
 	if (new_dir != old_dir) {
-		error = permission(old_dentry->d_inode, MAY_WRITE, NULL);
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+		if(rsbac_dac_part_disabled(old_dentry))
+			error = 0;
+		else
+#endif
+			error = permission(old_dentry->d_inode, MAY_WRITE, NULL);
 		if (error)
 			return error;
 	}
@@ -2397,6 +3081,73 @@
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[vfs_rename_dir()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO (old_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = old_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = old_dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = old_dentry;
+	rsbac_attribute_value.new_dir_dentry_p = new_dentry->d_parent;
+	if (!rsbac_adf_request(R_RENAME,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_new_dir_dentry_p,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[vfs_rename_dir()]: calling ADF for WRITE on new_dir\n");
+	rsbac_target_id2.dir.device = new_dentry->d_sb->s_dev;
+	rsbac_target_id2.dir.inode  = new_dir->i_ino;
+	rsbac_target_id2.dir.dentry_p = new_dentry->d_parent;
+	rsbac_attribute_value2.dummy = 0;
+	if (!rsbac_adf_request(R_WRITE,
+				current->pid,
+				T_DIR,
+				rsbac_target_id2,
+				A_none,
+				rsbac_attribute_value2))
+	{
+		return -EPERM;
+	}
+	if(new_dentry->d_inode)
+	{
+		target_exists = TRUE;
+		rsbac_pr_debug(aef, "[vfs_rename_dir()]: calling ADF for DELETE on existing target\n");
+		rsbac_target2 = T_FILE;
+		if (S_ISDIR(new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_DIR;
+		else if (S_ISFIFO (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_FIFO;
+		else if (S_ISLNK (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_SYMLINK;
+		else if (S_ISSOCK (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_UNIXSOCK;
+		rsbac_target_id2.file.device = new_dentry->d_sb->s_dev;
+		rsbac_target_id2.file.inode  = new_dentry->d_inode->i_ino;
+		rsbac_target_id2.file.dentry_p = new_dentry;
+		rsbac_attribute_value2.nlink = new_dentry->d_inode->i_nlink;
+		if (!rsbac_adf_request(R_DELETE,
+					current->pid,
+					rsbac_target2,
+					rsbac_target_id2,
+					A_nlink,
+					rsbac_attribute_value2))
+		{
+			return -EPERM;
+		}
+	}
+#endif /* CONFIG_RSBAC */
+
 	target = new_dentry->d_inode;
 	if (target) {
 		mutex_lock(&target->i_mutex);
@@ -2414,9 +3165,41 @@
 			d_rehash(new_dentry);
 		dput(new_dentry);
 	}
-	if (!error)
+	if (!error) {
 		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
 			d_move(old_dentry,new_dentry);
+
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_RENAME,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_new_dir_dentry_p,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+				"do_rename() [sys_rename()]: rsbac_adf_set_attr() for RENAME returned error\n");
+		}
+		if (target_exists)
+		{
+			if (rsbac_adf_set_attr(R_DELETE,
+						current->pid,
+						rsbac_target2,
+						rsbac_target_id2,
+						T_NONE,
+						rsbac_new_target_id,
+						A_nlink,
+						rsbac_attribute_value2))
+			{
+				rsbac_printk(KERN_WARNING
+						"do_rename() [sys_rename()]: rsbac_adf_set_attr() for DELETE returned error\n");
+			}
+		}
+#endif
+	}
 	return error;
 }
 
@@ -2426,10 +3209,88 @@
 	struct inode *target;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	enum  rsbac_target_t          rsbac_target2 = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_target_id2;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	union rsbac_attribute_value_t rsbac_attribute_value2;
+	rsbac_boolean_t target_exists = FALSE;
+#endif
+
 	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_rename()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO (old_dentry->d_inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK (old_dentry->d_inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = old_dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = old_dentry->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = old_dentry;
+	rsbac_attribute_value.new_dir_dentry_p = new_dentry->d_parent;
+	if (!rsbac_adf_request(R_RENAME,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_new_dir_dentry_p,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[sys_rename()]: calling ADF for WRITE on new_dir\n");
+	rsbac_target_id2.dir.device = new_dentry->d_sb->s_dev;
+	rsbac_target_id2.dir.inode  = new_dir->i_ino;
+	rsbac_target_id2.dir.dentry_p = new_dentry->d_parent;
+	rsbac_attribute_value2.dummy = 0;
+	if (!rsbac_adf_request(R_WRITE,
+				current->pid,
+				T_DIR,
+				rsbac_target_id2,
+				A_none,
+				rsbac_attribute_value2))
+	{
+		return -EPERM;
+	}
+	if(new_dentry->d_inode)
+	{
+		target_exists = TRUE;
+		rsbac_pr_debug(aef, "[sys_rename()]: calling ADF for DELETE on existing target\n");
+		rsbac_target2 = T_FILE;
+		if (S_ISDIR(new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_DIR;
+		else if (S_ISFIFO (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_FIFO;
+		else if (S_ISLNK (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_SYMLINK;
+		else if (S_ISSOCK (new_dentry->d_inode->i_mode))
+			rsbac_target2 = T_UNIXSOCK;
+		rsbac_target_id2.file.device = new_dentry->d_sb->s_dev;
+		rsbac_target_id2.file.inode  = new_dentry->d_inode->i_ino;
+		rsbac_target_id2.file.dentry_p = new_dentry;
+		rsbac_attribute_value2.nlink = new_dentry->d_inode->i_nlink;
+		if (!rsbac_adf_request(R_DELETE,
+					current->pid,
+					rsbac_target2,
+					rsbac_target_id2,
+					A_nlink,
+					rsbac_attribute_value2))
+		{
+			return -EPERM;
+		}
+	}
+#endif /* CONFIG_RSBAC */
+
 	dget(new_dentry);
 	target = new_dentry->d_inode;
 	if (target)
@@ -2441,6 +3302,37 @@
 	if (!error) {
 		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
 			d_move(old_dentry, new_dentry);
+
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_RENAME,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_new_dir_dentry_p,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"do_rename() [sys_rename()]: rsbac_adf_set_attr() returned error");
+		}
+		if (target_exists)
+		{
+			if (rsbac_adf_set_attr(R_DELETE,
+						current->pid,
+						rsbac_target2,
+						rsbac_target_id2,
+						T_NONE,
+						rsbac_new_target_id,
+						A_nlink,
+						rsbac_attribute_value2))
+			{
+				rsbac_printk(KERN_WARNING
+						"do_rename() [sys_rename()]: rsbac_adf_set_attr() returned error");
+			}
+		}
+#endif
 	}
 	if (target)
 		mutex_unlock(&target->i_mutex);
@@ -2596,6 +3488,9 @@
 int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
 {
 	int len;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+	char * rsbac_name;
+#endif
 
 	len = PTR_ERR(link);
 	if (IS_ERR(link))
@@ -2604,8 +3499,21 @@
 	len = strlen(link);
 	if (len > (unsigned) buflen)
 		len = buflen;
+
+#ifdef CONFIG_RSBAC_SYM_REDIR
+	rsbac_name = rsbac_symlink_redirect(dentry, link, buflen);
+	if(rsbac_name)
+	{
+		len = strlen(rsbac_name);
+		if (copy_to_user(buffer, rsbac_name, len))
+			len = -EFAULT;
+		kfree(rsbac_name);
+	}
+	else
+#endif
 	if (copy_to_user(buffer, link, len))
 		len = -EFAULT;
+
 out:
 	return len;
 }
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/namespace.c ./linux-2.6.19.3-rsbac-1.3.2/fs/namespace.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/namespace.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/namespace.c	2007-03-15 14:32:53.000000000 +0100
@@ -28,6 +28,7 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 #include "pnode.h"
+#include <rsbac/hooks.h>
 
 /* spinlock for vfsmount related operations, inplace of dcache_lock */
 __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
@@ -541,6 +542,12 @@
 	int retval;
 	LIST_HEAD(umount_list);
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = security_sb_umount(mnt, flags);
 	if (retval)
 		return retval;
@@ -563,6 +570,47 @@
 			return -EAGAIN;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF for DIR\n");
+        rsbac_target_id.dir.device = sb->s_root->d_sb->s_dev;
+        rsbac_target_id.dir.inode  = sb->s_root->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = sb->s_root;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        rsbac_pr_debug(aef, "calling ADF for dev\n");
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(sb->s_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(sb->s_dev);
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
+        /* RSBAC: removing data structures for this fs from memory (not /) */
+        #ifdef CONFIG_RSBAC
+	if ((mnt != current->fs->rootmnt) || (flags & MNT_DETACH)) {
+	        rsbac_pr_debug(ds, "[sys_umount()]: calling rsbac_umount for Device %02u:%02u\n",
+                   MAJOR(sb->s_dev), MINOR(sb->s_dev));
+                   rsbac_umount(sb, mnt->mnt_mountpoint);
+	}
+        #endif
+
 	/*
 	 * If we may have to abort operations to get out of this
 	 * mount, and they will themselves hold resources we must
@@ -592,6 +640,7 @@
 		 * Special case for "unmounting" root ...
 		 * we just try to remount it readonly.
 		 */
+
 		down_write(&sb->s_umount);
 		if (!(sb->s_flags & MS_RDONLY)) {
 			lock_kernel();
@@ -604,6 +653,7 @@
 	}
 
 	down_write(&namespace_sem);
+
 	spin_lock(&vfsmount_lock);
 	event++;
 
@@ -616,6 +666,18 @@
 	spin_unlock(&vfsmount_lock);
 	if (retval)
 		security_sb_umount_busy(mnt);
+
+#ifdef CONFIG_RSBAC
+	/* RSBAC: umount failed, so reread data structures for this fs from disk */
+	if(retval)
+	{
+		rsbac_printk(KERN_WARNING
+				"do_umount() [sys_umount()]: umount failed -> calling rsbac_mount for Device %02u:%02u\n",
+				MAJOR(mnt->mnt_sb->s_dev),MINOR(mnt->mnt_sb->s_dev));
+		rsbac_mount(mnt->mnt_sb, mnt->mnt_mountpoint);
+	}
+#endif
+
 	up_write(&namespace_sem);
 	release_mounts(&umount_list);
 	return retval;
@@ -870,6 +932,17 @@
 	mutex_unlock(&nd->dentry->d_inode->i_mutex);
 	if (!err)
 		security_sb_post_addmount(mnt, nd);
+
+        /* RSBAC: initialising data structures for this fs (not root fs) */
+#ifdef CONFIG_RSBAC
+        if (!err) {
+		rsbac_pr_debug(ds, "[do_loopback(), do_add_mount() [sys_mount()]]: calling rsbac_mount for Device %02u:%02u\n",
+			       MAJOR(mnt->mnt_sb->s_dev),
+			       MINOR(mnt->mnt_sb->s_dev));
+		rsbac_mount(mnt->mnt_sb, mnt->mnt_mountpoint);
+	}
+#endif
+
 	return err;
 }
 
@@ -902,6 +975,14 @@
 	struct nameidata old_nd;
 	struct vfsmount *mnt = NULL;
 	int err = mount_is_safe(nd);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (err)
 		return err;
 	if (!old_name || !*old_name)
@@ -910,6 +991,57 @@
 	if (err)
 		return err;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DIR\n");
+	rsbac_target_id.dir.device = nd->dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = nd->dentry;
+	rsbac_attribute_value.mode = recurse;
+	if (!rsbac_adf_request(R_MOUNT,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		path_release(&old_nd);
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DEV\n");
+	if(S_ISBLK(old_nd.dentry->d_inode->i_mode))
+	{
+		rsbac_target = T_DEV;
+		rsbac_target_id.dev.type = D_block;
+		rsbac_target_id.dev.major = RSBAC_MAJOR(old_nd.dentry->d_sb->s_dev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(old_nd.dentry->d_sb->s_dev);
+	}
+	else
+		if(S_ISDIR(old_nd.dentry->d_inode->i_mode))
+		{
+			rsbac_target = T_DIR;
+			rsbac_target_id.dir.device = old_nd.dentry->d_sb->s_dev;
+			rsbac_target_id.dir.inode  = old_nd.dentry->d_inode->i_ino;
+			rsbac_target_id.dir.dentry_p = old_nd.dentry;
+		}
+		else
+		{
+			rsbac_target = T_FILE;
+			rsbac_target_id.file.device = old_nd.dentry->d_sb->s_dev;
+			rsbac_target_id.file.inode  = old_nd.dentry->d_inode->i_ino;
+			rsbac_target_id.file.dentry_p = old_nd.dentry;
+		}
+	if (!rsbac_adf_request(R_MOUNT,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		path_release(&old_nd);
+		return -EPERM;
+	}
+#endif
+
 	down_write(&namespace_sem);
 	err = -EINVAL;
 	if (IS_MNT_UNBINDABLE(old_nd.mnt))
@@ -953,6 +1085,12 @@
 	int err;
 	struct super_block *sb = nd->mnt->mnt_sb;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -962,6 +1100,37 @@
 	if (nd->dentry != nd->mnt->mnt_root)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DIR\n");
+        rsbac_target_id.dir.device = nd->dentry->d_sb->s_dev;
+        rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd->dentry;
+        rsbac_attribute_value.mode = flags;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DEV\n");
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(sb->s_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(sb->s_dev);
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&sb->s_umount);
 	err = do_remount_sb(sb, flags, data, 0);
 	if (!err)
@@ -987,6 +1156,13 @@
 	struct nameidata old_nd, parent_nd;
 	struct vfsmount *p;
 	int err = 0;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (!old_name || !*old_name)
@@ -995,6 +1171,64 @@
 	if (err)
 		return err;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for UMOUNT on old DIR\n");
+	rsbac_target_id.dir.device = old_nd.dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = old_nd.dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = old_nd.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_UMOUNT,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		path_release(&old_nd);
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for MOUNT on new DIR\n");
+	rsbac_target_id.dir.device = nd->dentry->d_sb->s_dev;
+	rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+	rsbac_target_id.dir.dentry_p = nd->dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MOUNT,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		path_release(&old_nd);
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for UMOUNT on DEV\n");
+	rsbac_target_id.dev.type = D_block;
+	rsbac_target_id.dev.major = RSBAC_MAJOR(old_nd.dentry->d_sb->s_dev);
+	rsbac_target_id.dev.minor = RSBAC_MINOR(old_nd.dentry->d_sb->s_dev);
+	if (!rsbac_adf_request(R_UMOUNT,
+				current->pid,
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		path_release(&old_nd);
+		return -EPERM;
+	}
+	rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for MOUNT on DEV\n");
+	if (!rsbac_adf_request(R_MOUNT,
+				current->pid,
+				T_DEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		path_release(&old_nd);
+		return -EPERM;
+	}
+#endif
+
 	down_write(&namespace_sem);
 	while (d_mountpoint(nd->dentry) && follow_down(&nd->mnt, &nd->dentry))
 		;
@@ -1086,6 +1320,11 @@
 {
 	int err;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	down_write(&namespace_sem);
 	/* Something was mounted here while we slept */
 	while (d_mountpoint(nd->dentry) && follow_down(&nd->mnt, &nd->dentry))
@@ -1104,6 +1343,40 @@
 	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
 		goto unlock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DIR\n");
+        rsbac_target_id.dir.device = nd->dentry->d_sb->s_dev;
+        rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd->dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            err = -EPERM;
+            goto unlock;
+          }
+        rsbac_pr_debug(aef, "[do_mount() [sys_mount()]]: calling ADF for DEV\n");
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(newmnt->mnt_sb->s_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(newmnt->mnt_sb->s_dev);
+        rsbac_attribute_value.mode = mnt_flags;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            err = -EPERM;
+            goto unlock;
+          }
+        #endif
+
 	newmnt->mnt_flags = mnt_flags;
 	if ((err = graft_tree(newmnt, nd)))
 		goto unlock;
@@ -1681,6 +1954,12 @@
 	struct nameidata new_nd, old_nd, parent_nd, root_parent, user_nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -1704,6 +1983,45 @@
 		goto out1;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF for MOUNT on put_old\n");
+        rsbac_target_id.dir.device = old_nd.dentry->d_sb->s_dev;
+        rsbac_target_id.dir.inode  = old_nd.dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = old_nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            path_release(&old_nd);
+            error = -EPERM;
+            goto out1;
+          }
+        rsbac_pr_debug(aef, "calling ADF for MOUNT on root DIR\n");
+        rsbac_target_id.dir.device = current->fs->rootmnt->mnt_sb->s_dev;
+        rsbac_target_id.dir.inode  = current->fs->root->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = current->fs->root;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            path_release(&old_nd);
+            error = -EPERM;
+            goto out1;
+          }
+
+        /* Make the new root's cached rsbac.dat dentry be put to free the old root's dcache */
+        rsbac_free_dat_dentries();
+        #endif
+
 	read_lock(&current->fs->lock);
 	user_nd.mnt = mntget(current->fs->rootmnt);
 	user_nd.dentry = dget(current->fs->root);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/open.c ./linux-2.6.19.3-rsbac-1.3.2/fs/open.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/open.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/open.c	2007-03-15 14:33:03.000000000 +0100
@@ -28,11 +28,38 @@
 #include <linux/rcupdate.h>
 #include <linux/audit.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#endif
+#include <rsbac/hooks.h>
+
 int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	int retval = -ENODEV;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (dentry) {
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.dev.type = D_block;
+		rsbac_target_id.dev.major = RSBAC_MAJOR(dentry->d_sb->s_dev);
+		rsbac_target_id.dev.minor = RSBAC_MINOR(dentry->d_sb->s_dev);
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					T_DEV,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+#endif
+
 		retval = -ENOSYS;
 		if (dentry->d_sb->s_op->statfs) {
 			memset(buf, 0, sizeof(*buf));
@@ -200,10 +227,43 @@
 	int err;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #ifdef CONFIG_RSBAC_SECDEL
+        loff_t old_len = dentry->d_inode->i_size;
+        #endif
+        #endif
+
 	/* Not pretty: "inode->i_size" shouldn't really be signed. But it is. */
 	if (length < 0)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[open_namei(), do_sys_truncate() [sys_truncate()]]: calling ADF\n");
+        rsbac_target_id.file.device = dentry->d_inode->i_sb->s_dev;
+        rsbac_target_id.file.inode  = dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_TRUNCATE,
+                               current->pid,
+                               T_FILE,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
+        /* RSBAC: Overwrite truncated part, if asked by flag */
+        #ifdef CONFIG_RSBAC_SECDEL
+        rsbac_sec_trunc(dentry, length, old_len);
+        #endif
+
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | time_attrs;
 	if (filp) {
@@ -214,6 +274,27 @@
 	mutex_lock(&dentry->d_inode->i_mutex);
 	err = notify_change(dentry, &newattrs);
 	mutex_unlock(&dentry->d_inode->i_mutex);
+
+        #ifdef CONFIG_RSBAC
+        if (!err)
+          {
+	    rsbac_pr_debug(aef, "[open_namei(), do_sys_truncate() [sys_truncate()]]: notifying ADF\n");
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_TRUNCATE,
+                                   current->pid,
+                                   T_FILE,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "do_truncate() [open_namei(), do_sys_truncate() [sys_truncate()]]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 	return err;
 }
 
@@ -241,6 +322,11 @@
 	if (!S_ISREG(inode->i_mode))
 		goto dput_and_out;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(nd.dentry))
+		error = 0;
+	else
+#endif
 	error = vfs_permission(&nd, MAY_WRITE);
 	if (error)
 		goto dput_and_out;
@@ -362,6 +448,13 @@
 	kernel_cap_t old_cap;
 	int res;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
 
@@ -380,12 +473,43 @@
 	 * value below.  We should hold task_capabilities_lock,
 	 * but we cannot because user_path_walk can sleep.
 	 */
-	if (current->uid)
+	if (current->uid) {
+                #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+                if(!rsbac_uid_faked())
+                #endif
 		cap_clear(current->cap_effective);
+	}
 	else
 		current->cap_effective = current->cap_permitted;
 
 	res = __user_walk_fd(dfd, filename, LOOKUP_FOLLOW|LOOKUP_ACCESS, &nd);
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!res)
+                  {
+		    rsbac_pr_debug(aef, "calling ADF\n");
+                    rsbac_target = T_FILE;
+                    if (S_ISDIR(nd.dentry->d_inode->i_mode))
+                      rsbac_target = T_DIR;
+                    else if (S_ISFIFO(nd.dentry->d_inode->i_mode))
+                      rsbac_target = T_FIFO;
+                    else if (S_ISLNK(nd.dentry->d_inode->i_mode))
+                      rsbac_target = T_SYMLINK;
+			else if (S_ISSOCK(nd.dentry->d_inode->i_mode))
+			rsbac_target = T_UNIXSOCK;
+                    rsbac_target_id.file.device = nd.dentry->d_inode->i_sb->s_dev;
+                    rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+                    rsbac_target_id.file.dentry_p = nd.dentry;
+                    rsbac_attribute_value.dummy = 0;
+                    if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+                                           current->pid,
+                                           rsbac_target,
+                                           rsbac_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      res = -EPERM;
+                  }
+                #endif
 	if (res)
 		goto out;
 
@@ -418,15 +542,45 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = __user_walk(filename,
 			    LOOKUP_FOLLOW|LOOKUP_DIRECTORY|LOOKUP_CHDIR, &nd);
 	if (error)
 		goto out;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(nd.dentry))
+		error = 0;
+	else
+#endif
 	error = vfs_permission(&nd, MAY_EXEC);
 	if (error)
 		goto dput_and_out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.dir.device = nd.dentry->d_inode->i_sb->s_dev;
+        rsbac_target_id.dir.inode  = nd.dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CHDIR,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto dput_and_out;
+          }
+        #endif
+
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
@@ -443,6 +597,12 @@
 	struct vfsmount *mnt;
 	int error;
 
+	/* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -456,7 +616,33 @@
 	if (!S_ISDIR(inode->i_mode))
 		goto out_putf;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(dentry))
+		error = 0;
+	else
+#endif
 	error = file_permission(file, MAY_EXEC);
+
+#ifdef CONFIG_RSBAC
+	if(!error)
+	{
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.dir.device = inode->i_sb->s_dev;
+		rsbac_target_id.dir.inode  = inode->i_ino;
+		rsbac_target_id.dir.dentry_p = dentry;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_CHDIR,
+					current->pid,
+					T_DIR,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			error = -EPERM;
+		}
+	}
+#endif
+
 	if (!error)
 		set_fs_pwd(current->fs, mnt, dentry);
 out_putf:
@@ -470,10 +656,21 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = __user_walk(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
 	if (error)
 		goto out;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(nd.dentry))
+		error = 0;
+	else
+#endif
 	error = vfs_permission(&nd, MAY_EXEC);
 	if (error)
 		goto dput_and_out;
@@ -482,6 +679,25 @@
 	if (!capable(CAP_SYS_CHROOT))
 		goto dput_and_out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.dir.device = nd.dentry->d_inode->i_sb->s_dev;
+        rsbac_target_id.dir.inode  = nd.dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CHDIR,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto dput_and_out;
+          }
+        #endif
+
 	set_fs_root(current->fs, nd.mnt, nd.dentry);
 	set_fs_altroot();
 	error = 0;
@@ -499,6 +715,13 @@
 	int err = -EBADF;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	file = fget(fd);
 	if (!file)
 		goto out;
@@ -514,6 +737,41 @@
 	err = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out_putf;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode)) {
+		if(inode->i_sb->s_magic == SOCKFS_MAGIC) {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+		} else {
+			rsbac_target = T_UNIXSOCK;
+		}
+	}
+	rsbac_attribute_value.mode = mode;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		err = -EPERM;
+		goto out_putf;
+	}
+#endif
+        
 	mutex_lock(&inode->i_mutex);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
@@ -536,6 +794,12 @@
 	int error;
 	struct iattr newattrs;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = __user_walk_fd(dfd, filename, LOOKUP_FOLLOW, &nd);
 	if (error)
 		goto out;
@@ -549,6 +813,40 @@
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = nd.dentry;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode)) {
+		if(inode->i_sb->s_magic == SOCKFS_MAGIC) {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+		} else {
+			rsbac_target = T_UNIXSOCK;
+		}
+	}
+	rsbac_attribute_value.mode = mode;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_mode,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto dput_and_out;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
@@ -574,6 +872,13 @@
 	int error;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -ENOENT;
 	if (!(inode = dentry->d_inode)) {
 		printk(KERN_ERR "chown_common: NULL inode\n");
@@ -596,6 +901,34 @@
 	}
 	if (!S_ISDIR(inode->i_mode))
 		newattrs.ia_valid |= ATTR_KILL_SUID|ATTR_KILL_SGID;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_*chown]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CHANGE_OWNER,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto out;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	error = notify_change(dentry, &newattrs);
 	mutex_unlock(&inode->i_mutex);
@@ -1023,16 +1356,126 @@
 {
 	int retval = 0;
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!file_count(filp)) {
 		printk(KERN_ERR "VFS: Close: file count is 0\n");
 		return 0;
 	}
 
+        /* RSBAC: calling adf */
+        #ifdef CONFIG_RSBAC
+        if (   filp
+            && filp->f_dentry
+            && filp->f_dentry->d_inode
+	   )
+          {
+            rsbac_pr_debug(aef, "[sys_close]: calling ADF\n");
+            rsbac_target = T_NONE;
+            if(   S_ISBLK(filp->f_dentry->d_inode->i_mode)
+               || S_ISCHR(filp->f_dentry->d_inode->i_mode))
+              {
+                rsbac_target = T_DEV;
+                if(S_ISBLK(filp->f_dentry->d_inode->i_mode))
+                  {
+                    rsbac_target_id.dev.type = D_block;
+                  }
+                else
+                  {
+                    rsbac_target_id.dev.type = D_char;
+                  }
+                rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_sb->s_dev);
+                rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_sb->s_dev);
+              }
+	    else
+            if(S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+              {
+                if(   SOCKET_I(filp->f_dentry->d_inode)->ops
+                   && (SOCKET_I(filp->f_dentry->d_inode)->ops->family == AF_UNIX)
+                  )
+                  {
+                    if(filp->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+                      rsbac_target = T_IPC;
+                      rsbac_target_id.ipc.type = I_anonunix;
+                      rsbac_target_id.ipc.id.id_nr = filp->f_dentry->d_inode->i_ino;
+                    } else {
+			rsbac_target = T_UNIXSOCK;
+                        rsbac_target_id.unixsock.device = filp->f_dentry->d_sb->s_dev;
+                        rsbac_target_id.unixsock.inode  = filp->f_dentry->d_inode->i_ino;
+                        rsbac_target_id.unixsock.dentry_p = filp->f_dentry;
+                    }
+                  }
+                else
+                  {
+                    rsbac_target = T_NETOBJ;
+                    rsbac_target_id.netobj.sock_p
+                      = SOCKET_I(filp->f_dentry->d_inode);
+                    rsbac_target_id.netobj.local_addr = NULL;
+                    rsbac_target_id.netobj.local_len = 0;
+                    rsbac_target_id.netobj.remote_addr = NULL;
+                    rsbac_target_id.netobj.remote_len = 0;
+                  }
+              }
+            else /* must be file, fifo or dir */
+              {
+                if(S_ISDIR(filp->f_dentry->d_inode->i_mode))
+                  rsbac_target = T_DIR;
+                else if(S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+                  rsbac_target = T_FIFO;
+                else
+                  rsbac_target = T_FILE;
+                rsbac_target_id.file.device = filp->f_dentry->d_inode->i_sb->s_dev;
+                rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+                rsbac_target_id.file.dentry_p = filp->f_dentry;
+              }
+            rsbac_attribute_value.f_mode = filp->f_mode;
+            if ((rsbac_target != T_NONE) && !rsbac_adf_request(R_CLOSE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   A_f_mode,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "filp_close() [sys_close]: ADF-call returned NOT_GRANTED\n");
+                /*return -EPERM;*/
+              }
+          }
+        #endif /* RSBAC */
+
 	if (filp->f_op && filp->f_op->flush)
 		retval = filp->f_op->flush(filp, id);
 
 	dnotify_flush(filp, id);
 	locks_remove_posix(filp, id);
+
+        /* RSBAC: notifying adf */
+        #ifdef CONFIG_RSBAC
+        if (rsbac_target != T_NONE)
+          {
+            rsbac_pr_debug(aef, "[sys_close]: notifying ADF\n");
+            rsbac_new_target_id.dummy = 0;
+            rsbac_attribute_value.f_mode = filp->f_mode;
+            if (rsbac_adf_set_attr(R_CLOSE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_f_mode,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "filp_close() [sys_close]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif /* RSBAC */
+
 	fput(filp);
 	return retval;
 }
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/pipe.c ./linux-2.6.19.3-rsbac-1.3.2/fs/pipe.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/pipe.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/pipe.c	2007-03-15 14:33:03.000000000 +0100
@@ -20,6 +20,8 @@
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * We use a start+len construction, which provides full use of the 
  * allocated memory.
@@ -229,11 +231,36 @@
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	#endif /* CONFIG_RSBAC_RW */
+
 	do_wakeup = 0;
 	ret = 0;
 	mutex_lock(&inode->i_mutex);
@@ -325,8 +352,28 @@
 		wake_up_interruptible(&pipe->wait);
 		kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
 	}
-	if (ret > 0)
+	if (ret > 0) {
 		file_accessed(filp);
+		
+		/* RSBAC: notify adf of read from pipe */
+                #ifdef CONFIG_RSBAC_RW
+		rsbac_new_target_id.dummy = 0;
+		
+		if (rsbac_adf_set_attr(R_READ,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "pipe_readv(): rsbac_adf_set_attr() returned error\n");
+                      }
+                #endif
+
+	}
 	return ret;
 }
 
@@ -343,11 +390,36 @@
 	size_t total_len;
 	ssize_t chars;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	total_len = iov_length(iov, nr_segs);
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
 		return 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	#endif /* CONFIG_RSBAC_RW */
+
 	do_wakeup = 0;
 	ret = 0;
 	mutex_lock(&inode->i_mutex);
@@ -498,8 +570,28 @@
 		wake_up_interruptible(&pipe->wait);
 		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
 	}
-	if (ret > 0)
+	if (ret > 0) {
 		file_update_time(filp);
+		
+		/* RSBAC: notify adf of write to pipe */
+                #ifdef CONFIG_RSBAC_RW
+		rsbac_new_target_id.dummy = 0;
+		
+		if (rsbac_adf_set_attr(R_WRITE,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "pipe_writev(): rsbac_adf_set_attr() returned error\n");
+                      }
+                #endif
+	}
+
 	return ret;
 }
 
@@ -587,7 +679,22 @@
 	pipe->writers -= decw;
 
 	if (!pipe->readers && !pipe->writers) {
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                union rsbac_target_id_t rsbac_target_id;
+                #endif
+
 		free_pipe_info(inode);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ACI remove_target()\n");
+                rsbac_target_id.ipc.type   = I_anonpipe;
+                rsbac_target_id.ipc.id.id_nr  = inode->i_ino;
+                rsbac_remove_target(T_IPC, rsbac_target_id);
+                #endif
+
 	} else {
 		wake_up_interruptible(&pipe->wait);
 		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
@@ -604,6 +711,29 @@
 	struct inode *inode = filp->f_dentry->d_inode;
 	int retval;
 
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	retval = fasync_helper(fd, filp, on, &inode->i_pipe->fasync_readers);
 	mutex_unlock(&inode->i_mutex);
@@ -611,6 +741,23 @@
 	if (retval < 0)
 		return retval;
 
+	/* RSBAC: notify adf of read from pipe */
+        #ifdef CONFIG_RSBAC_RW
+	rsbac_new_target_id.dummy = 0;
+		
+	if (rsbac_adf_set_attr(R_READ,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "pipe_read_fasync(): rsbac_adf_set_attr() returned error\n");
+              }
+        #endif
+
 	return 0;
 }
 
@@ -621,6 +768,29 @@
 	struct inode *inode = filp->f_dentry->d_inode;
 	int retval;
 
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	retval = fasync_helper(fd, filp, on, &inode->i_pipe->fasync_writers);
 	mutex_unlock(&inode->i_mutex);
@@ -628,6 +798,23 @@
 	if (retval < 0)
 		return retval;
 
+	/* RSBAC: notify adf of write to pipe */
+        #ifdef CONFIG_RSBAC_RW
+	rsbac_new_target_id.dummy = 0;
+		
+	if (rsbac_adf_set_attr(R_WRITE,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "pipe_write_fasync(): rsbac_adf_set_attr() returned error\n");
+              }
+        #endif
+
 	return 0;
 }
 
@@ -639,6 +826,45 @@
 	struct pipe_inode_info *pipe = inode->i_pipe;
 	int retval;
 
+#ifdef CONFIG_RSBAC_RW
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_RW
+	rsbac_pr_debug(aef, "calling ADF for READ\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+
+	rsbac_pr_debug(aef, "calling ADF for WRITE\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
+
 	mutex_lock(&inode->i_mutex);
 
 	retval = fasync_helper(fd, filp, on, &pipe->fasync_readers);
@@ -651,6 +877,40 @@
 	if (retval < 0)
 		return retval;
 
+	/* RSBAC: notify adf of read from pipe */
+        #ifdef CONFIG_RSBAC_RW
+	rsbac_new_target_id.dummy = 0;
+		
+	if (rsbac_adf_set_attr(R_READ,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "pipe_rwdr_fasync(): rsbac_adf_set_attr() returned error\n");
+              }
+	
+	/* RSBAC: notify adf of write to pipe */
+	rsbac_new_target_id.dummy = 0;
+		
+	if (rsbac_adf_set_attr(R_WRITE,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "pipe_rwdr_fasync(): rsbac_adf_set_attr() returned error\n");
+              }
+        #endif
+
 	return 0;
 }
 
@@ -683,28 +943,132 @@
 static int
 pipe_read_open(struct inode *inode, struct file *filp)
 {
+	
+	#ifdef CONFIG_RSBAC
+	/* RSBAC */
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ_OPEN,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+	#endif
+
 	/* We could have perhaps used atomic_t, but this and friends
 	   below are the only places.  So it doesn't seem worthwhile.  */
 	mutex_lock(&inode->i_mutex);
 	inode->i_pipe->readers++;
 	mutex_unlock(&inode->i_mutex);
 
+        #ifdef CONFIG_RSBAC
+	/* RSBAC: notify adf of read_open on pipe */
+	rsbac_new_target_id.dummy = 0;
+		
+	if (rsbac_adf_set_attr(R_READ_OPEN,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "pipe_read_open(): rsbac_adf_set_attr() returned error\n");
+              }
+        #endif
+
 	return 0;
 }
 
 static int
 pipe_write_open(struct inode *inode, struct file *filp)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE_OPEN,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	inode->i_pipe->writers++;
 	mutex_unlock(&inode->i_mutex);
 
+#ifdef CONFIG_RSBAC
+	/* RSBAC: notify adf of write_open on pipe */
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_WRITE_OPEN,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING "pipe_write_open(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return 0;
 }
 
 static int
 pipe_rdwr_open(struct inode *inode, struct file *filp)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ_WRITE_OPEN,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	if (filp->f_mode & FMODE_READ)
 		inode->i_pipe->readers++;
@@ -712,6 +1076,23 @@
 		inode->i_pipe->writers++;
 	mutex_unlock(&inode->i_mutex);
 
+#ifdef CONFIG_RSBAC
+	/* RSBAC: notify adf of read_write_open on pipe */
+	rsbac_new_target_id.dummy = 0;
+
+	if (rsbac_adf_set_attr(R_READ_WRITE_OPEN,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING "pipe_rdwr_open(): rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 	return 0;
 }
 
@@ -883,6 +1264,13 @@
 	char name[32];
 	struct qstr this;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	f = get_empty_filp();
 	if (!f)
 		return ERR_PTR(-ENFILE);
@@ -911,6 +1299,24 @@
 	f->f_mode = FMODE_WRITE;
 	f->f_version = 0;
 
+	/* RSBAC: notify ADF of new anonpipe */
+#ifdef CONFIG_RSBAC
+        rsbac_target_id.ipc.type = I_anonpipe;
+	rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_CREATE,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"do_pipe() [sys_pipe()]: rsbac_adf_set_attr() returned error");
+	}
+#endif
 	return f;
 
  err_inode:
@@ -954,6 +1360,29 @@
 	int error;
 	int fdw, fdr;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_pipe()]: calling ADF\n");
+        rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = 0;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	fw = create_write_pipe();
 	if (IS_ERR(fw))
 		return PTR_ERR(fw);
@@ -1017,12 +1446,28 @@
 			err = PTR_ERR(pipe_mnt);
 			unregister_filesystem(&pipe_fs_type);
 		}
+		#ifdef CONFIG_RSBAC
+		else {
+			/* RSBAC: initialising data structures for this fs (not root fs) */
+			rsbac_pr_debug(ds, "calling rsbac_mount for Device %02u:%02u\n",
+				 MAJOR(pipe_mnt->mnt_sb->s_dev), MINOR(pipe_mnt->mnt_sb->s_dev));
+			rsbac_mount(pipe_mnt->mnt_sb, NULL);
+		}
+		#endif
 	}
 	return err;
 }
 
 static void __exit exit_pipe_fs(void)
 {
+        /* RSBAC: removing data structures for this fs from memory */
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(ds, "calling rsbac_umount for "
+		       "Device %02u:%02u\n", MAJOR(pipe_mnt->mnt_sb->s_dev),
+		       MINOR(pipe_mnt->mnt_sb->s_dev));
+        rsbac_umount(pipe_mnt->mnt_sb, NULL);
+#endif
+
 	unregister_filesystem(&pipe_fs_type);
 	mntput(pipe_mnt);
 }
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/array.c ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/array.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/array.c	2007-03-15 13:36:54.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/array.c	2007-03-15 14:32:53.000000000 +0100
@@ -81,6 +81,7 @@
 #include <asm/io.h>
 #include <asm/processor.h>
 #include "internal.h"
+#include <rsbac/hooks.h>
 
 /* Gcc optimizes away "strlen(x)" for constant x */
 #define ADDBUF(buffer, string) \
@@ -296,6 +297,26 @@
 	char * orig = buffer;
 	struct mm_struct *mm = get_task_mm(task);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	buffer = task_name(task, buffer);
 	buffer = task_state(task, buffer);
  
@@ -322,7 +343,7 @@
 	int res;
  	pid_t ppid = 0, pgid = -1, sid = -1;
 	int num_threads = 0;
-	struct mm_struct *mm;
+	struct mm_struct *mm = get_task_mm(task);
 	unsigned long long start_time;
 	unsigned long cmin_flt = 0, cmaj_flt = 0;
 	unsigned long  min_flt = 0,  maj_flt = 0;
@@ -331,9 +352,28 @@
 	char tcomm[sizeof(task->comm)];
 	unsigned long flags;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
-	mm = get_task_mm(task);
 	if (mm) {
 		vsize = task_vsize(mm);
 		eip = KSTK_EIP(task);
@@ -484,8 +524,29 @@
 int proc_pid_statm(struct task_struct *task, char *buffer)
 {
 	int size = 0, resident = 0, shared = 0, text = 0, lib = 0, data = 0;
-	struct mm_struct *mm = get_task_mm(task);
+	struct mm_struct *mm;
+	
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
 	
+	mm = get_task_mm(task);
 	if (mm) {
 		size = task_statm(mm, &shared, &text, &data, &resident);
 		mmput(mm);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/base.c ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/base.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/base.c	2007-03-15 13:36:54.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/base.c	2007-03-15 14:32:53.000000000 +0100
@@ -74,6 +74,7 @@
 #include <linux/nsproxy.h>
 #include <linux/oom.h>
 #include "internal.h"
+#include <rsbac/hooks.h>
 
 /* NOTE:
  *	Implementing inode permission operations in /proc is almost
@@ -153,6 +154,23 @@
 	struct fs_struct *fs = NULL;
 	int result = -ENOENT;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = PROC_I(inode)->pid->nr;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
+
 	if (task) {
 		fs = get_fs_struct(task);
 		put_task_struct(task);
@@ -173,6 +191,23 @@
 	struct task_struct *task = get_proc_task(inode);
 	struct fs_struct *fs = NULL;
 	int result = -ENOENT;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = PROC_I(inode)->pid->nr;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
 
 	if (task) {
 		fs = get_fs_struct(task);
@@ -200,6 +235,25 @@
 {
 	int res = 0;
 	struct mm_struct *mm = get_task_mm(task);
+        
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	if (mm) {
 		unsigned int len = mm->env_end - mm->env_start;
 		if (len > PAGE_SIZE)
@@ -217,6 +271,25 @@
 	int res = 0;
 	unsigned int len;
 	struct mm_struct *mm = get_task_mm(task);
+
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	if (!mm)
 		goto out;
 	if (!mm->arg_end)
@@ -253,6 +326,25 @@
 {
 	int res = 0;
 	struct mm_struct *mm = get_task_mm(task);
+
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	if (mm) {
 		unsigned int nwords = 0;
 		do
@@ -280,6 +372,24 @@
 	unsigned long wchan, size, offset;
 	char namebuf[KSYM_NAME_LEN+1];
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	wchan = get_wchan(task);
 
 	sym_name = kallsyms_lookup(wchan, &size, &offset, &modname, namebuf);
@@ -295,6 +405,28 @@
  */
 static int proc_pid_schedstat(struct task_struct *task, char *buffer)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	return sprintf(buffer, "%lu %lu %lu\n",
 			task->sched_info.cpu_time,
 			task->sched_info.run_delay,
@@ -309,6 +441,28 @@
 	unsigned long points;
 	struct timespec uptime;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	do_posix_clock_monotonic_gettime(&uptime);
 	points = badness(task, uptime.tv_sec);
 	return sprintf(buffer, "%lu\n", points);
@@ -369,6 +523,26 @@
 	struct proc_mounts *p;
 	int ret = -EINVAL;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (task) {
 		task_lock(task);
 		namespace = task->nsproxy->namespace;
@@ -518,12 +692,32 @@
 	int ret = -ESRCH;
 	struct mm_struct *mm;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!task)
 		goto out_no_task;
 
 	if (!MAY_PTRACE(task) || !ptrace_may_attach(task))
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	ret = -ENOMEM;
 	page = (char *)__get_free_page(GFP_USER);
 	if (!page)
@@ -587,6 +781,11 @@
 	struct task_struct *task = get_proc_task(file->f_dentry->d_inode);
 	unsigned long dst = *ppos;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	copied = -ESRCH;
 	if (!task)
 		goto out_no_task;
@@ -594,6 +793,21 @@
 	if (!MAY_PTRACE(task) || !ptrace_may_attach(task))
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	copied = -ENOMEM;
 	page = (char *)__get_free_page(GFP_USER);
 	if (!page)
@@ -660,6 +874,26 @@
 	int oom_adjust;
 	loff_t __ppos = *ppos;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (!task)
 		return -ESRCH;
 	oom_adjust = task->oomkilladj;
@@ -679,12 +913,34 @@
 static ssize_t oom_adjust_write(struct file *file, const char __user *buf,
 				size_t count, loff_t *ppos)
 {
-	struct task_struct *task;
+	struct task_struct *task = get_proc_task(file->f_dentry->d_inode);
 	char buffer[PROC_NUMBUF], *end;
 	int oom_adjust;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_RESOURCE))
 		return -EPERM;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
@@ -696,7 +952,6 @@
 		return -EINVAL;
 	if (*end == '\n')
 		end++;
-	task = get_proc_task(file->f_dentry->d_inode);
 	if (!task)
 		return -ESRCH;
 	task->oomkilladj = oom_adjust;
@@ -721,6 +976,26 @@
 	ssize_t length;
 	char tmpbuf[TMPBUFLEN];
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (!task)
 		return -ESRCH;
 	length = scnprintf(tmpbuf, TMPBUFLEN, "%u",
@@ -737,6 +1012,12 @@
 	ssize_t length;
 	uid_t loginuid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_AUDIT_CONTROL))
 		return -EPERM;
 
@@ -750,6 +1031,23 @@
 		/* No partial writes. */
 		return -EINVAL;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process =  pid_task(proc_pid(inode), PIDTYPE_PID)->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	page = (char*)__get_free_page(GFP_USER);
 	if (!page)
 		return -ENOMEM;
@@ -1143,6 +1441,24 @@
 	struct file *file;
 	int fd = proc_fd(inode);
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = PROC_I(inode)->pid->nr;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	if (task) {
 		files = get_files_struct(task);
 		put_task_struct(task);
@@ -1918,6 +2234,11 @@
 	struct task_struct *task;
 	unsigned tgid;
 
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif			
+
 	result = proc_base_lookup(dir, dentry);
 	if (!IS_ERR(result) || PTR_ERR(result) != -ENOENT)
 		goto out;
@@ -1934,6 +2255,25 @@
 	if (!task)
 		goto out;
 
+	/* RSBAC */
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		result = ERR_PTR(-ENOENT);
+		rcu_read_lock();
+		put_task_struct(task);
+		rcu_read_unlock();
+		goto out;
+	}
+#endif						
+
 	result = proc_pid_instantiate(dir, dentry, task, NULL);
 	put_task_struct(task);
 out:
@@ -1994,6 +2334,10 @@
 	struct task_struct *reaper = get_proc_task(filp->f_dentry->d_inode);
 	struct task_struct *task;
 	int tgid;
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (!reaper)
 		goto out_no_task;
@@ -2009,6 +2353,21 @@
 	     task;
 	     put_task_struct(task), task = next_tgid(tgid + 1)) {
 		tgid = task->pid;
+
+#ifdef CONFIG_RSBAC_PROC_HIDE
+		rsbac_target_id.process = task->pid;
+		rsbac_attribute_value.dummy = 0;
+		if(!rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					T_PROCESS,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			continue;
+		}
+#endif
+
 		filp->f_pos = tgid + TGID_OFFSET;
 		if (proc_pid_fill_cache(filp, dirent, filldir, task, tgid) < 0) {
 			put_task_struct(task);
@@ -2124,6 +2483,10 @@
 	struct task_struct *task;
 	struct task_struct *leader = get_proc_task(dir);
 	unsigned tid;
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif			
 
 	if (!leader)
 		goto out_no_task;
@@ -2142,6 +2505,22 @@
 	if (leader->tgid != task->tgid)
 		goto out_drop_task;
 
+	/* RSBAC */
+#ifdef CONFIG_RSBAC_PROC_HIDE
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		goto out_drop_task;
+	}
+#endif						
+
+
 	result = proc_task_instantiate(dir, dentry, task, NULL);
 out_drop_task:
 	put_task_struct(task);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/kcore.c ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/kcore.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/kcore.c	2007-03-15 13:36:54.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/kcore.c	2007-03-15 14:32:53.000000000 +0100
@@ -19,13 +19,37 @@
 #include <linux/vmalloc.h>
 #include <linux/highmem.h>
 #include <linux/init.h>
+#include <linux/security.h>
+
 #include <asm/uaccess.h>
 #include <asm/io.h>
-
+#include <rsbac/hooks.h>
 
 static int open_kcore(struct inode * inode, struct file * filp)
 {
+        /* RSBAC */
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+
+	if(!capable(CAP_SYS_RAWIO))
+	  return -EPERM;
+
+        rsbac_target_id.scd = ST_kmem;
+        rsbac_attribute_value.dummy = 0;
+        rsbac_pr_debug(aef, "calling ADF\n");
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          return -EPERM;
+        else
+          return 0;
+#else
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+#endif
 }
 
 static ssize_t read_kcore(struct file *, char __user *, size_t, loff_t *);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/task_mmu.c ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/task_mmu.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/task_mmu.c	2007-03-15 13:36:54.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/task_mmu.c	2007-03-15 14:32:53.000000000 +0100
@@ -5,11 +5,13 @@
 #include <linux/highmem.h>
 #include <linux/pagemap.h>
 #include <linux/mempolicy.h>
+#include <linux/security.h>
 
 #include <asm/elf.h>
 #include <asm/uaccess.h>
 #include <asm/tlbflush.h>
 #include "internal.h"
+#include <rsbac/hooks.h>
 
 char *task_mem(struct mm_struct *mm, char *buffer)
 {
@@ -78,12 +80,34 @@
 	struct task_struct *task = get_proc_task(inode);
 	struct mm_struct * mm = NULL;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (task) {
 		mm = get_task_mm(task);
 		put_task_struct(task);
 	}
 	if (!mm)
 		goto out;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		mmput(mm);
+		return -EPERM;
+	}
+#endif
+
 	down_read(&mm->mmap_sem);
 
 	vma = mm->mmap;
@@ -415,10 +439,29 @@
 {
 	struct proc_maps_private *priv;
 	int ret = -ENOMEM;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (priv) {
 		priv->pid = proc_pid(inode);
 		ret = seq_open(file, ops);
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.process = pid_task(proc_pid(inode), PIDTYPE_PID)->pid;
+		rsbac_attribute_value.dummy = 0;
+		if(!rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					T_PROCESS,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			kfree(priv);
+			return -EPERM;
+		}
+#endif
 		if (!ret) {
 			struct seq_file *m = file->private_data;
 			m->private = priv;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/task_nommu.c ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/task_nommu.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/proc/task_nommu.c	2007-03-15 13:36:54.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/proc/task_nommu.c	2007-03-15 14:32:53.000000000 +0100
@@ -2,8 +2,10 @@
 #include <linux/mm.h>
 #include <linux/file.h>
 #include <linux/mount.h>
+#include <linux/security.h>
 #include <linux/seq_file.h>
 #include "internal.h"
+#include <rsbac/hooks.h>
 
 /*
  * Logic: we've got two memory sums for each process, "shared", and
@@ -111,8 +113,32 @@
 	struct mm_struct *mm = get_task_mm(task);
 	int result = -ENOENT;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!mm)
 		goto out;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            mmput(mm);
+            return -EPERM;
+          }
+        #endif
+
 	down_read(&mm->mmap_sem);
 
 	vml = mm->context.vmlist;
@@ -202,10 +228,32 @@
 };
 
 static int maps_open(struct inode *inode, struct file *file)
-{
+{	
 	struct proc_maps_private *priv;
 	int ret = -ENOMEM;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	struct task_struct *task = get_proc_task(inode);
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.process = pid_task(proc_pid(inode), PIDTYPE_PID)->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
+
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (priv) {
 		priv->pid = proc_pid(inode);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/quota.c ./linux-2.6.19.3-rsbac-1.3.2/fs/quota.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/quota.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/quota.c	2007-03-15 14:33:01.000000000 +0100
@@ -17,6 +17,7 @@
 #include <linux/buffer_head.h>
 #include <linux/capability.h>
 #include <linux/quotaops.h>
+#include <rsbac/hooks.h>
 
 /* Check validity of generic quotactl commands */
 static int generic_quotactl_valid(struct super_block *sb, int type, int cmd, qid_t id)
@@ -84,10 +85,32 @@
 		    !capable(CAP_SYS_ADMIN))
 			return -EPERM;
 	}
-	else if (cmd != Q_GETFMT && cmd != Q_SYNC && cmd != Q_GETINFO)
+	else if (cmd != Q_GETFMT && cmd != Q_SYNC && cmd != Q_GETINFO) {
+	        /* RSBAC */
+	        #ifdef CONFIG_RSBAC
+	        union rsbac_target_id_t       rsbac_target_id;
+	        union rsbac_attribute_value_t rsbac_attribute_value;
+	        #endif
+
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.scd = ST_quota;
+                rsbac_attribute_value.dummy = 0;
+                rsbac_pr_debug(aef, "[sys_quotactl()]: calling ADF\n");
+                if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                      current->pid,
+                                      T_SCD,
+                                      rsbac_target_id,
+                                      A_none,
+                                      rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+	}
 	return 0;
 }
 
@@ -135,10 +158,31 @@
 		     !capable(CAP_SYS_ADMIN))
 			return -EPERM;
 	} else if (cmd != Q_XGETQSTAT && cmd != Q_XQUOTASYNC) {
+	        /* RSBAC */
+	        #ifdef CONFIG_RSBAC
+	        union rsbac_target_id_t       rsbac_target_id;
+	        union rsbac_attribute_value_t rsbac_attribute_value;
+	        #endif
+
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
-	}
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.scd = ST_quota;
+                rsbac_attribute_value.dummy = 0;
+		rsbac_pr_debug(aef, "[sys_quotactl()]: calling ADF\n");
+                if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                      current->pid,
+                                      T_SCD,
+                                      rsbac_target_id,
+                                      A_none,
+                                      rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+	}
 	return 0;
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/readdir.c ./linux-2.6.19.3-rsbac-1.3.2/fs/readdir.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/readdir.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/readdir.c	2007-03-15 14:33:01.000000000 +0100
@@ -19,10 +19,27 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+#include "hfsplus/hfsplus_fs.h"
+#include "hfsplus/hfsplus_raw.h"
+#endif
+#endif
+
+#include <rsbac/hooks.h>
+#include <linux/namei.h>
+
 int vfs_readdir(struct file *file, filldir_t filler, void *buf)
 {
 	struct inode *inode = file->f_dentry->d_inode;
 	int res = -ENOTDIR;
+
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
 
@@ -30,6 +47,23 @@
 	if (res)
 		goto out;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[old_readdir(), sys_getdents()]: calling ADF\n");
+	rsbac_target_id.dir.device = inode->i_sb->s_dev;
+	rsbac_target_id.dir.inode = inode->i_ino;
+	rsbac_target_id.dir.dentry_p = file->f_dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_READ,
+				current->pid,
+				T_DIR,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))	{
+		res = -EPERM;
+		goto out;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	res = -ENOENT;
 	if (!IS_DEADDIR(inode)) {
@@ -65,6 +99,9 @@
 
 struct readdir_callback {
 	struct old_linux_dirent __user * dirent;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	struct file * file;
+#endif
 	int result;
 };
 
@@ -77,6 +114,11 @@
 
 	if (buf->result)
 		return -EINVAL;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	if (!rsbac_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+#endif
+
 	d_ino = ino;
 	if (sizeof(d_ino) < sizeof(ino) && d_ino != ino)
 		return -EOVERFLOW;
@@ -93,6 +135,7 @@
 		__put_user(0, dirent->d_name + namlen))
 		goto efault;
 	return 0;
+
 efault:
 	buf->result = -EFAULT;
 	return -EFAULT;
@@ -111,6 +154,9 @@
 
 	buf.result = 0;
 	buf.dirent = dirent;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	buf.file = file;
+#endif
 
 	error = vfs_readdir(file, fillonedir, &buf);
 	if (error >= 0)
@@ -137,6 +183,9 @@
 struct getdents_callback {
 	struct linux_dirent __user * current_dir;
 	struct linux_dirent __user * previous;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	struct file * file;
+#endif
 	int count;
 	int error;
 };
@@ -152,6 +201,10 @@
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	if (!rsbac_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+#endif
 	d_ino = ino;
 	if (sizeof(d_ino) < sizeof(ino) && d_ino != ino)
 		return -EOVERFLOW;
@@ -176,6 +229,7 @@
 	buf->current_dir = dirent;
 	buf->count -= reclen;
 	return 0;
+
 efault:
 	buf->error = -EFAULT;
 	return -EFAULT;
@@ -199,6 +253,9 @@
 
 	buf.current_dir = dirent;
 	buf.previous = NULL;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	buf.file = file;
+#endif
 	buf.count = count;
 	buf.error = 0;
 
@@ -227,6 +284,9 @@
 	struct linux_dirent64 __user * previous;
 	int count;
 	int error;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	struct file * file;
+#endif
 };
 
 static int filldir64(void * __buf, const char * name, int namlen, loff_t offset,
@@ -239,6 +299,12 @@
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	if (!rsbac_handle_filldir(buf->file, name, namlen, ino))
+		return 0;
+#endif
+
 	dirent = buf->previous;
 	if (dirent) {
 		if (__put_user(offset, &dirent->d_off))
@@ -262,6 +328,7 @@
 	buf->current_dir = dirent;
 	buf->count -= reclen;
 	return 0;
+
 efault:
 	buf->error = -EFAULT;
 	return -EFAULT;
@@ -285,6 +352,9 @@
 
 	buf.current_dir = dirent;
 	buf.previous = NULL;
+#ifdef CONFIG_RSBAC_FSOBJ_HIDE
+	buf.file = file;
+#endif
 	buf.count = count;
 	buf.error = 0;
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/read_write.c ./linux-2.6.19.3-rsbac-1.3.2/fs/read_write.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/read_write.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/read_write.c	2007-03-15 14:32:59.000000000 +0100
@@ -17,6 +17,12 @@
 #include <linux/pagemap.h>
 #include "read_write.h"
 
+#ifdef CONFIG_RSBAC_RW
+#include <net/sock.h>
+#include <net/af_unix.h>
+#endif
+#include <rsbac/hooks.h>
+
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
@@ -256,6 +262,15 @@
 {
 	ssize_t ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute = A_none;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!file->f_op || (!file->f_op->read && !file->f_op->aio_read))
@@ -268,6 +283,110 @@
 		count = ret;
 		ret = security_file_permission (file, MAY_READ);
 		if (!ret) {
+                        /* RSBAC */
+                        #ifdef CONFIG_RSBAC_RW
+                        rsbac_pr_debug(aef, "[sys_read()]: calling ADF\n");
+                        rsbac_attribute_value.dummy = 0;
+                        /* get target type and id clear */
+                        if(S_ISSOCK(file->f_dentry->d_inode->i_mode))
+                          {
+			    struct socket * sock = SOCKET_I(file->f_dentry->d_inode);
+
+                            if(   sock->ops
+                               && (sock->ops->family == AF_UNIX)
+                              )
+                              {
+#if 0
+                                if(file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+                                  rsbac_target = T_IPC;
+                                  rsbac_target_id.ipc.type = I_anonunix;
+		                  if(unix_sk(sock->sk)->peer
+		                     && unix_sk(unix_sk(sock->sk)->peer)->dentry
+                		     && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+		                    )
+					rsbac_target_id.ipc.id.id_nr = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+				  else
+	                                rsbac_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+                                } else {
+				  rsbac_target = T_UNIXSOCK;
+                                  rsbac_target_id.unixsock.device = file->f_dentry->d_sb->s_dev;
+                                  rsbac_target_id.unixsock.inode  = file->f_dentry->d_inode->i_ino;
+                                  rsbac_target_id.unixsock.dentry_p = file->f_dentry;
+                                }
+                                if (sock->sk
+				    && sock->sk->sk_peercred.pid) {
+					rsbac_attribute = A_process;
+					rsbac_attribute_value.process = sock->sk->sk_peercred.pid;
+				} else {
+					rsbac_attribute = A_sock_type;
+					rsbac_attribute_value.sock_type = sock->type;
+				}
+#endif
+                              }
+                            #ifdef CONFIG_RSBAC_NET_OBJ_RW
+                            else
+                              {
+                                rsbac_target = T_NETOBJ;
+                                rsbac_target_id.netobj.sock_p
+                                 = SOCKET_I(file->f_dentry->d_inode);
+                                rsbac_target_id.netobj.local_addr = NULL;
+                                rsbac_target_id.netobj.local_len = 0;
+                                rsbac_target_id.netobj.remote_addr = NULL;
+                                rsbac_target_id.netobj.remote_len = 0;
+				rsbac_attribute = A_sock_type;
+				rsbac_attribute_value.sock_type = sock->type;
+                              }
+                            #endif
+                          }
+                        else
+                        if(   S_ISFIFO(file->f_dentry->d_inode->i_mode)
+                              /* named FIFO only */
+                           && (file->f_dentry->d_sb->s_magic != PIPEFS_MAGIC)
+                          )
+                          {
+                            rsbac_target = T_FIFO;
+                            rsbac_target_id.fifo.device = file->f_dentry->d_sb->s_dev;
+                            rsbac_target_id.fifo.inode  = file->f_dentry->d_inode->i_ino;
+                            rsbac_target_id.fifo.dentry_p = file->f_dentry;
+                          }
+                        else
+                        if(S_ISREG(file->f_dentry->d_inode->i_mode))
+                          {
+                            rsbac_target = T_FILE;
+                            rsbac_target_id.file.device = file->f_dentry->d_sb->s_dev;
+                            rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+                            rsbac_target_id.file.dentry_p = file->f_dentry;
+                          }
+                        else
+                        if(S_ISBLK(file->f_dentry->d_inode->i_mode))
+                          {
+                            rsbac_target = T_DEV;
+                            rsbac_target_id.dev.type = D_block;
+                            rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                            rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                          }
+                        else
+                        if(S_ISCHR(file->f_dentry->d_inode->i_mode))
+                          {
+                            rsbac_target = T_DEV;
+                            rsbac_target_id.dev.type = D_char;
+                            rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                            rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                          }
+                        if (   (rsbac_target != T_NONE)
+                            && !rsbac_adf_request(R_READ,
+                                                  current->pid,
+                                                  rsbac_target,
+                                                  rsbac_target_id,
+                                                  rsbac_attribute,
+                                                  rsbac_attribute_value)
+                           )
+                          {
+                            ret = -EPERM;
+                          }
+                        else
+                        #endif /* CONFIG_RSBAC_RW */
+
 			if (file->f_op->read)
 				ret = file->f_op->read(file, buf, count, pos);
 			else
@@ -275,6 +394,26 @@
 			if (ret > 0) {
 				fsnotify_access(file->f_dentry);
 				current->rchar += ret;
+
+	                        /* RSBAC: notify adf of read file etc. */
+	                        #ifdef CONFIG_RSBAC_RW
+	                        if (rsbac_target != T_NONE)
+	                          {
+	                            rsbac_new_target_id.dummy = 0;
+	                            if (rsbac_adf_set_attr(R_READ,
+	                                                   current->pid,
+	                                                   rsbac_target,
+	                                                   rsbac_target_id,
+	                                                   T_NONE,
+	                                                   rsbac_new_target_id,
+	                                                   rsbac_attribute,
+	                                                   rsbac_attribute_value))
+	                              {
+	                                rsbac_printk(KERN_WARNING
+	                                       "vfs_read() [sys_read()]: rsbac_adf_set_attr() returned error\n");
+	                              }
+	                          }
+	                        #endif
 			}
 			current->syscr++;
 		}
@@ -314,6 +453,15 @@
 {
 	ssize_t ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute = A_none;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!(file->f_mode & FMODE_WRITE))
 		return -EBADF;
 	if (!file->f_op || (!file->f_op->write && !file->f_op->aio_write))
@@ -326,6 +474,110 @@
 		count = ret;
 		ret = security_file_permission (file, MAY_WRITE);
 		if (!ret) {
+                        /* RSBAC */
+                        #ifdef CONFIG_RSBAC_RW
+                        rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.dummy = 0;
+                        /* get target type and id clear */
+                        if(S_ISSOCK(file->f_dentry->d_inode->i_mode))
+                          {
+			    struct socket * sock = SOCKET_I(file->f_dentry->d_inode);
+
+                            if(   sock->ops
+                               && (sock->ops->family == AF_UNIX)
+                              )
+                              {
+#if 0
+                                if(file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+                                  rsbac_target = T_IPC;
+                                  rsbac_target_id.ipc.type = I_anonunix;
+		                  if(unix_sk(sock->sk)->peer
+		                     && unix_sk(unix_sk(sock->sk)->peer)->dentry
+                		     && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+		                    )
+					rsbac_target_id.ipc.id.id_nr = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+				  else
+	                                rsbac_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+                                } else {
+				  rsbac_target = T_UNIXSOCK;
+                                  rsbac_target_id.unixsock.device = file->f_dentry->d_sb->s_dev;
+                                  rsbac_target_id.unixsock.inode  = file->f_dentry->d_inode->i_ino;
+                                  rsbac_target_id.unixsock.dentry_p = file->f_dentry;
+                                }
+                                if (sock->sk
+				    && sock->sk->sk_peercred.pid) {
+					rsbac_attribute = A_process;
+					rsbac_attribute_value.process = sock->sk->sk_peercred.pid;
+				} else {
+					rsbac_attribute = A_sock_type;
+					rsbac_attribute_value.sock_type = sock->type;
+				}
+#endif
+                              }
+                            #ifdef CONFIG_RSBAC_NET_OBJ_RW
+                            else
+                              {
+                                rsbac_target = T_NETOBJ;
+                                rsbac_target_id.netobj.sock_p
+                                 = SOCKET_I(file->f_dentry->d_inode);
+                                rsbac_target_id.netobj.local_addr = NULL;
+                                rsbac_target_id.netobj.local_len = 0;
+                                rsbac_target_id.netobj.remote_addr = NULL;
+                                rsbac_target_id.netobj.remote_len = 0;
+				rsbac_attribute = A_sock_type;
+				rsbac_attribute_value.sock_type = sock->type;
+                              }
+                            #endif
+                          }
+                        else
+                        if(   S_ISFIFO(file->f_dentry->d_inode->i_mode)
+                              /* named FIFO only */
+                           && (file->f_dentry->d_sb->s_magic != PIPEFS_MAGIC)
+                          )
+                          {
+                            rsbac_target = T_FIFO;
+                            rsbac_target_id.fifo.device = file->f_dentry->d_sb->s_dev;
+                            rsbac_target_id.fifo.inode  = file->f_dentry->d_inode->i_ino;
+                            rsbac_target_id.fifo.dentry_p = file->f_dentry;
+                          }
+                        else
+                        if(S_ISREG(file->f_dentry->d_inode->i_mode))
+                          {
+                            rsbac_target = T_FILE;
+                            rsbac_target_id.file.device = file->f_dentry->d_sb->s_dev;
+                            rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+                            rsbac_target_id.file.dentry_p = file->f_dentry;
+                          }
+                        else
+                        if(S_ISBLK(file->f_dentry->d_inode->i_mode))
+                          {
+                            rsbac_target = T_DEV;
+                            rsbac_target_id.dev.type = D_block;
+                            rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                            rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                          }
+                        else
+                        if(S_ISCHR(file->f_dentry->d_inode->i_mode))
+                          {
+                            rsbac_target = T_DEV;
+                            rsbac_target_id.dev.type = D_char;
+                            rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                            rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                          }
+                        if (   (rsbac_target != T_NONE)
+                            && !rsbac_adf_request(R_WRITE,
+                                                  current->pid,
+                                                  rsbac_target,
+                                                  rsbac_target_id,
+                                                  rsbac_attribute,
+                                                  rsbac_attribute_value)
+                           )
+                          {
+                            ret = -EPERM;
+                          }
+                        else
+                        #endif /* CONFIG_RSBAC_RW */
+
 			if (file->f_op->write)
 				ret = file->f_op->write(file, buf, count, pos);
 			else
@@ -333,6 +585,26 @@
 			if (ret > 0) {
 				fsnotify_modify(file->f_dentry);
 				current->wchar += ret;
+
+	                        /* RSBAC: notify adf of written file etc. */
+	                        #ifdef CONFIG_RSBAC_RW
+	                        if (rsbac_target != T_NONE)
+	                          {
+	                            rsbac_new_target_id.dummy = 0;
+	                            if (rsbac_adf_set_attr(R_WRITE,
+	                                                   current->pid,
+	                                                   rsbac_target,
+	                                                   rsbac_target_id,
+	                                                   T_NONE,
+	                                                   rsbac_new_target_id,
+	                                                   rsbac_attribute,
+	                                                   rsbac_attribute_value))
+	                              {
+	                                rsbac_printk(KERN_WARNING
+	                                       "vfs_write()[sys_write()]: rsbac_adf_set_attr() returned error\n");
+	                              }
+	                          }
+	                        #endif
 			}
 			current->syscw++;
 		}
@@ -590,6 +862,17 @@
 	io_fn_t fn;
 	iov_fn_t fnv;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_adf_request_t     rsbac_request = R_NONE;
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute = A_none;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        struct inode * rsbac_inode;
+        #endif
+
 	if (!file->f_op) {
 		ret = -EINVAL;
 		goto out;
@@ -608,6 +891,115 @@
 	if (ret)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        rsbac_pr_debug(aef, "[sys_vread(), sys_vwrite()]: calling ADF\n");
+        rsbac_inode = file->f_dentry->d_inode;
+        rsbac_attribute_value.dummy = 0;
+        /* get target type and id clear */
+        if(S_ISSOCK(rsbac_inode->i_mode))
+          {
+	    struct socket * sock = SOCKET_I(rsbac_inode);
+
+            if(   sock->ops
+               && (sock->ops->family == AF_UNIX)
+              )
+              {
+#if 0
+                if(file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+                  if(unix_sk(sock->sk)->peer
+                     && unix_sk(unix_sk(sock->sk)->peer)->dentry
+		     && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+		    )
+			rsbac_target_id.ipc.id.id_nr = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+		  else
+	                rsbac_target_id.ipc.id.id_nr = rsbac_inode->i_ino;
+                } else {
+		  rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = file->f_dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = rsbac_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = file->f_dentry;
+                }
+                if (sock->sk
+		    && sock->sk->sk_peercred.pid) {
+			rsbac_attribute = A_process;
+			rsbac_attribute_value.process = sock->sk->sk_peercred.pid;
+		} else {
+			rsbac_attribute = A_sock_type;
+			rsbac_attribute_value.sock_type = sock->type;
+		}
+#endif
+              }
+            #ifdef CONFIG_RSBAC_NET_OBJ_RW
+            else
+              {
+                rsbac_target = T_NETOBJ;
+                rsbac_target_id.netobj.sock_p
+                  = sock;
+                rsbac_target_id.netobj.local_addr = NULL;
+                rsbac_target_id.netobj.local_len = 0;
+                rsbac_target_id.netobj.remote_addr = NULL;
+                rsbac_target_id.netobj.remote_len = 0;
+		rsbac_attribute = A_sock_type;
+		rsbac_attribute_value.sock_type = sock->type;
+              }
+            #endif
+          }
+        else
+        if(   S_ISFIFO(rsbac_inode->i_mode)
+           /* named FIFO only */
+           && (rsbac_inode->i_sb->s_magic != PIPEFS_MAGIC)
+          )
+          {
+            rsbac_target = T_FIFO;
+            rsbac_target_id.fifo.device = rsbac_inode->i_sb->s_dev;
+            rsbac_target_id.fifo.inode  = rsbac_inode->i_ino;
+            rsbac_target_id.fifo.dentry_p = file->f_dentry;
+          }
+        else
+        if(S_ISREG(rsbac_inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.file.device = rsbac_inode->i_sb->s_dev;
+            rsbac_target_id.file.inode  = rsbac_inode->i_ino;
+            rsbac_target_id.file.dentry_p = file->f_dentry;
+          }
+        else
+        if(S_ISBLK(rsbac_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(rsbac_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(rsbac_inode->i_rdev);
+          }
+        else
+        if(S_ISCHR(rsbac_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_char;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(rsbac_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(rsbac_inode->i_rdev);
+          }
+        if(type == READ)
+          rsbac_request = R_READ;
+        else
+          rsbac_request = R_WRITE;
+        if (   (rsbac_target != T_NONE)
+            && !rsbac_adf_request(rsbac_request,
+                                  current->pid,
+                                  rsbac_target,
+                                  rsbac_target_id,
+                                  rsbac_attribute,
+                                  rsbac_attribute_value)
+           )
+          {
+            ret = -EPERM;
+            goto out;
+          }
+        #endif /* CONFIG_RSBAC_RW */
+
 	fnv = NULL;
 	if (type == READ) {
 		fn = file->f_op->read;
@@ -632,6 +1024,29 @@
 		else
 			fsnotify_modify(file->f_dentry);
 	}
+
+        /* RSBAC: notify adf of read or written file etc. */
+        #ifdef CONFIG_RSBAC_RW
+        if (   (ret > 0)
+            && (rsbac_target != T_NONE)
+           )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(rsbac_request,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   rsbac_attribute,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "do_readv_writev() [sys_vread(), sys_vwrite()]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 	return ret;
 }
 
@@ -712,6 +1127,19 @@
 	ssize_t retval;
 	int fput_needed_in, fput_needed_out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        enum  rsbac_target_t          rsbac_target2 = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_target2_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute = A_none;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        enum  rsbac_attribute_t       rsbac_attribute2 = A_none;
+        union rsbac_attribute_value_t rsbac_attribute_value2;
+        #endif
+
 	/*
 	 * Get input file, and verify that it is ok..
 	 */
@@ -742,6 +1170,108 @@
 	if (retval)
 		goto fput_in;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        rsbac_pr_debug(aef, "[sys_sendfile()]: calling ADF\n");
+        rsbac_attribute_value.dummy = 0;
+        /* get target type and id clear */
+        if(S_ISSOCK(in_file->f_dentry->d_inode->i_mode))
+          {
+	    struct socket * sock = SOCKET_I(in_file->f_dentry->d_inode);
+
+	    if(   sock->ops
+               && (sock->ops->family == AF_UNIX)
+              )
+              {
+#if 0
+                if(in_file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+                  if(unix_sk(sock->sk)->peer
+                     && unix_sk(unix_sk(sock->sk)->peer)->dentry
+		     && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+		    )
+			rsbac_target_id.ipc.id.id_nr = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+		  else
+	                rsbac_target_id.ipc.id.id_nr = in_file->f_dentry->d_inode->i_ino;
+                } else {
+		  rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = in_file->f_dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = in_file->f_dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = in_file->f_dentry;
+                }
+                if (sock->sk
+		    && sock->sk->sk_peercred.pid) {
+			rsbac_attribute = A_process;
+			rsbac_attribute_value.process = sock->sk->sk_peercred.pid;
+		} else {
+			rsbac_attribute = A_sock_type;
+			rsbac_attribute_value.sock_type = sock->type;
+		}
+#endif
+              }
+            #ifdef CONFIG_RSBAC_NET_OBJ_RW
+            else
+              {
+                rsbac_target = T_NETOBJ;
+                rsbac_target_id.netobj.sock_p = sock;
+                rsbac_target_id.netobj.local_addr = NULL;
+                rsbac_target_id.netobj.local_len = 0;
+                rsbac_target_id.netobj.remote_addr = NULL;
+                rsbac_target_id.netobj.remote_len = 0;
+		rsbac_attribute = A_sock_type;
+		rsbac_attribute_value.sock_type = sock->type;
+              }
+            #endif
+          }
+        else
+        if(   S_ISFIFO(in_file->f_dentry->d_inode->i_mode)
+              /* named FIFO only */
+           && (in_file->f_dentry->d_sb->s_magic != PIPEFS_MAGIC)
+          )
+          {
+            rsbac_target = T_FIFO;
+            rsbac_target_id.fifo.device = in_file->f_dentry->d_sb->s_dev;
+            rsbac_target_id.fifo.inode  = in_file->f_dentry->d_inode->i_ino;
+            rsbac_target_id.fifo.dentry_p = in_file->f_dentry;
+          }
+        else
+        if(S_ISREG(in_file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.file.device = in_file->f_dentry->d_sb->s_dev;
+            rsbac_target_id.file.inode  = in_file->f_dentry->d_inode->i_ino;
+            rsbac_target_id.file.dentry_p = in_file->f_dentry;
+          }
+        else
+        if(S_ISBLK(in_file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(in_file->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(in_file->f_dentry->d_inode->i_rdev);
+          }
+        else
+        if(S_ISCHR(in_file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_char;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(in_file->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(in_file->f_dentry->d_inode->i_rdev);
+          }
+        if (   (rsbac_target != T_NONE)
+            && !rsbac_adf_request(R_READ,
+                                  current->pid,
+                                  rsbac_target,
+                                  rsbac_target_id,
+                                  rsbac_attribute,
+                                  rsbac_attribute_value)
+           ) {
+           	retval = -EPERM;
+		goto fput_in;
+        }
+        #endif /* CONFIG_RSBAC_RW */
+
 	/*
 	 * Get output file, and verify that it is ok..
 	 */
@@ -764,6 +1294,107 @@
 	if (retval)
 		goto fput_out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        rsbac_pr_debug(aef, "[sys_sendfile()]: calling ADF for outfile\n");
+	rsbac_attribute_value2.dummy = 0;
+        /* get target type and id clear */
+        if(S_ISSOCK(out_file->f_dentry->d_inode->i_mode))
+          {
+	    struct socket * sock = SOCKET_I(out_file->f_dentry->d_inode);
+
+	    if(   sock->ops
+               && (sock->ops->family == AF_UNIX)
+              )
+              {
+                if(out_file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+                  if(unix_sk(sock->sk)->peer
+                     && unix_sk(unix_sk(sock->sk)->peer)->dentry
+		     && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+		    )
+			rsbac_target_id.ipc.id.id_nr = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+		  else
+	                  rsbac_target_id.ipc.id.id_nr = out_file->f_dentry->d_inode->i_ino;
+                } else {
+		  rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = out_file->f_dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = out_file->f_dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = out_file->f_dentry;
+                }
+                if (sock->sk
+		    && sock->sk->sk_peercred.pid) {
+			rsbac_attribute2 = A_process;
+			rsbac_attribute_value2.process = sock->sk->sk_peercred.pid;
+		} else {
+			rsbac_attribute2 = A_sock_type;
+			rsbac_attribute_value2.sock_type = sock->type;
+		}
+              }
+            #ifdef CONFIG_RSBAC_NET_OBJ_RW
+            else
+              {
+                rsbac_target = T_NETOBJ;
+                rsbac_target_id.netobj.sock_p = sock;
+                rsbac_target_id.netobj.local_addr = NULL;
+                rsbac_target_id.netobj.local_len = 0;
+                rsbac_target_id.netobj.remote_addr = NULL;
+                rsbac_target_id.netobj.remote_len = 0;
+		rsbac_attribute2 = A_sock_type;
+		rsbac_attribute_value2.sock_type = sock->type;
+              }
+            #endif
+          }
+        else
+        if(   S_ISFIFO(out_file->f_dentry->d_inode->i_mode)
+              /* named FIFO only */
+           && (out_file->f_dentry->d_sb->s_magic != PIPEFS_MAGIC)
+          )
+          {
+            rsbac_target2 = T_FIFO;
+            rsbac_target2_id.fifo.device = out_file->f_dentry->d_sb->s_dev;
+            rsbac_target2_id.fifo.inode  = out_file->f_dentry->d_inode->i_ino;
+            rsbac_target2_id.fifo.dentry_p = out_file->f_dentry;
+          }
+        else
+        if(S_ISREG(out_file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target2 = T_FILE;
+            rsbac_target2_id.file.device = out_file->f_dentry->d_sb->s_dev;
+            rsbac_target2_id.file.inode  = out_file->f_dentry->d_inode->i_ino;
+            rsbac_target2_id.file.dentry_p = out_file->f_dentry;
+          }
+        else
+        if(S_ISBLK(out_file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target2 = T_DEV;
+            rsbac_target2_id.dev.type = D_block;
+            rsbac_target2_id.dev.major = RSBAC_MAJOR(out_file->f_dentry->d_inode->i_rdev);
+            rsbac_target2_id.dev.minor = RSBAC_MINOR(out_file->f_dentry->d_inode->i_rdev);
+          }
+        else
+        if(S_ISCHR(out_file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target2 = T_DEV;
+            rsbac_target2_id.dev.type = D_char;
+            rsbac_target2_id.dev.major = RSBAC_MAJOR(out_file->f_dentry->d_inode->i_rdev);
+            rsbac_target2_id.dev.minor = RSBAC_MINOR(out_file->f_dentry->d_inode->i_rdev);
+          }
+        if (   (rsbac_target2 != T_NONE)
+            && !rsbac_adf_request(R_WRITE,
+                                  current->pid,
+                                  rsbac_target2,
+                                  rsbac_target2_id,
+                                  rsbac_attribute2,
+                                  rsbac_attribute_value2)
+           )
+          {
+            retval = -EPERM;
+            goto fput_out;
+          }
+        #endif /* CONFIG_RSBAC_RW */
+
 	if (!max)
 		max = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);
 
@@ -790,6 +1421,45 @@
 	if (*ppos > max)
 		retval = -EOVERFLOW;
 
+        /* RSBAC: notify adf of read and written files etc. */
+        #ifdef CONFIG_RSBAC_RW
+        if (retval > 0)
+          {
+            if(rsbac_target != T_NONE)
+              {
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_READ,
+                                       current->pid,
+                                       rsbac_target,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       rsbac_attribute,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "do_sendfile() [sys_sendfile()]: rsbac_adf_set_attr() for in_file returned error\n");
+                  }
+              }
+            if(rsbac_target2 != T_NONE)
+              {
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_WRITE,
+                                       current->pid,
+                                       rsbac_target2,
+                                       rsbac_target2_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       rsbac_attribute2,
+                                       rsbac_attribute_value2))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "do_sendfile() [sys_sendfile()]: rsbac_adf_set_attr() for out_file returned error\n");
+                  }
+              }
+          }
+        #endif
+
 fput_out:
 	fput_light(out_file, fput_needed_out);
 fput_in:
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/reiserfs/namei.c ./linux-2.6.19.3-rsbac-1.3.2/fs/reiserfs/namei.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/reiserfs/namei.c	2007-03-15 13:36:57.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/reiserfs/namei.c	2007-03-15 14:32:55.000000000 +0100
@@ -16,8 +16,10 @@
 #include <linux/reiserfs_fs.h>
 #include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
+#include <linux/security.h>
 #include <linux/smp_lock.h>
 #include <linux/quotaops.h>
+#include <rsbac/hooks.h>
 
 #define INC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) { inc_nlink(i); if (i->i_nlink >= REISERFS_LINK_MAX) i->i_nlink=1; }
 #define DEC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) drop_nlink(i);
@@ -998,6 +1000,11 @@
 	 * count so we don't race
 	 */
 	savelink = inode->i_nlink;
+	
+#ifdef CONFIG_RSBAC_SECDEL
+	if(inode->i_nlink == 1)
+		rsbac_sec_del(dentry);
+#endif
 
 	retval =
 	    reiserfs_cut_from_item(&th, &path, &(de.de_entry_key), dir, NULL,
@@ -1370,6 +1377,11 @@
 			journal_end(&th, old_dir->i_sb, jbegin_count);
 			reiserfs_write_unlock(old_dir->i_sb);
 			return -EIO;
+#ifdef CONFIG_RSBAC_SECDEL
+		} else {
+			if(new_dentry_inode && (new_dentry_inode->i_nlink == 1))
+				rsbac_sec_del(new_dentry);
+#endif
 		}
 
 		copy_item_head(&new_entry_ih, get_ih(&new_entry_path));
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/reiserfs/xattr.c ./linux-2.6.19.3-rsbac-1.3.2/fs/reiserfs/xattr.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/reiserfs/xattr.c	2007-03-15 13:36:57.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/reiserfs/xattr.c	2007-03-15 14:32:54.000000000 +0100
@@ -1233,6 +1233,10 @@
 	.d_compare = xattr_lookup_poison,
 };
 
+#ifdef CONFIG_RSBAC
+struct dentry * rsbac_lookup_one_len(const char * name, struct dentry * base, int len);
+#endif
+
 /* We need to take a copy of the mount flags since things like
  * MS_RDONLY don't get set until *after* we're called.
  * mount_flags != mount_options */
@@ -1260,8 +1264,13 @@
 	/* If we don't have the privroot located yet - go find it */
 	if (reiserfs_xattrs(s) && !REISERFS_SB(s)->priv_root) {
 		struct dentry *dentry;
+#ifdef CONFIG_RSBAC
+		dentry = rsbac_lookup_one_len(PRIVROOT_NAME, s->s_root,
+						strlen(PRIVROOT_NAME));
+#else
 		dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 					strlen(PRIVROOT_NAME));
+#endif
 		if (!IS_ERR(dentry)) {
 			if (!(mount_flags & MS_RDONLY) && !dentry->d_inode) {
 				struct inode *inode = dentry->d_parent->d_inode;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/stat.c ./linux-2.6.19.3-rsbac-1.3.2/fs/stat.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/stat.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/stat.c	2007-03-15 14:32:56.000000000 +0100
@@ -19,6 +19,11 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/sock.h>
+#include <rsbac/hooks.h>
+#endif
+
 void generic_fillattr(struct inode *inode, struct kstat *stat)
 {
 	stat->dev = inode->i_sb->s_dev;
@@ -43,10 +48,53 @@
 	struct inode *inode = dentry->d_inode;
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = security_inode_getattr(mnt, dentry);
 	if (retval)
 		return retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_stat() etc.]: calling ADF\n");
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = dentry;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(inode->i_mode))
+          rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+	  rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode)) {
+		if(inode->i_sb->s_magic == SOCKFS_MAGIC) {
+		  rsbac_target = T_IPC;
+		  rsbac_target_id.ipc.type = I_anonunix;
+		  rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	        } else {
+		  rsbac_target = T_UNIXSOCK;
+		  rsbac_target_id.unixsock.device = inode->i_sb->s_dev;
+		  rsbac_target_id.unixsock.inode  = inode->i_ino;
+		  rsbac_target_id.unixsock.dentry_p = dentry;
+		}
+	} else
+		rsbac_target = T_FILE;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              rsbac_target,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value)) {
+		return -EPERM;
+	}
+	#endif
+
 	if (inode->i_op->getattr)
 		return inode->i_op->getattr(mnt, dentry, stat);
 
@@ -305,6 +353,12 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (bufsiz <= 0)
 		return -EINVAL;
 
@@ -316,6 +370,25 @@
 		if (inode->i_op && inode->i_op->readlink) {
 			error = security_inode_readlink(nd.dentry);
 			if (!error) {
+                                /* RSBAC */
+                                #ifdef CONFIG_RSBAC
+                                rsbac_pr_debug(aef, "calling ADF\n");
+                                rsbac_target_id.file.device = nd.dentry->d_sb->s_dev;
+                                rsbac_target_id.file.inode  = inode->i_ino;
+                                rsbac_target_id.file.dentry_p = nd.dentry;
+                                rsbac_attribute_value.dummy = 0;
+                                if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                                       current->pid,
+                                                       T_SYMLINK,
+                                                       rsbac_target_id,
+                                                       A_none,
+                                                       rsbac_attribute_value))
+                                  {
+                                    path_release(&nd);
+                                    return -EPERM;
+                                  }
+                                #endif /* CONFIG_RSBAC */
+
 				touch_atime(nd.mnt, nd.dentry);
 				error = inode->i_op->readlink(nd.dentry, buf, bufsiz);
 			}
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/sysfs/file.c ./linux-2.6.19.3-rsbac-1.3.2/fs/sysfs/file.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/sysfs/file.c	2007-03-15 13:37:09.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/sysfs/file.c	2007-03-15 14:33:01.000000000 +0100
@@ -12,6 +12,8 @@
 
 #include "sysfs.h"
 
+#include <rsbac/hooks.h>
+
 #define to_subsys(k) container_of(k,struct subsystem,kset.kobj)
 #define to_sattr(a) container_of(a,struct subsys_attribute,attr)
 
@@ -257,6 +259,12 @@
 	struct sysfs_ops * ops = NULL;
 	int error = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!kobj || !attr)
 		goto Einval;
 
@@ -291,6 +299,22 @@
 		if (!(inode->i_mode & S_IWUGO) || !ops->store)
 			goto Eaccess;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_pr_debug(aef, "[sysfs_open_file()]: calling ADF\n");
+                rsbac_target_id.scd = ST_sysfs;
+                rsbac_attribute_value.dummy = 0;
+                if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                      current->pid,
+                                      T_SCD,
+                                      rsbac_target_id,
+                                      A_owner,
+                                      rsbac_attribute_value))
+                  {
+                    module_put(attr->owner);
+                    return -EPERM;
+                  }
+                #endif
 	}
 
 	/* File needs read support.
@@ -300,6 +324,25 @@
 	if (file->f_mode & FMODE_READ) {
 		if (!(inode->i_mode & S_IRUGO) || !ops->show)
 			goto Eaccess;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_pr_debug(aef, "[sysfs_open_file()]: calling ADF\n");
+                rsbac_target_id.scd = ST_sysfs;
+                rsbac_attribute_value.dummy = 0;
+                if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                                      current->pid,
+                                      T_SCD,
+                                      rsbac_target_id,
+                                      A_owner,
+                                      rsbac_attribute_value))
+                  {
+                    module_put(attr->owner);
+	            if (kobj)
+                      kobject_put(kobj);
+                    return -EPERM;
+                  }
+                #endif
 	}
 
 	/* No error? Great, allocate a buffer for the file, and store it
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/utimes.c ./linux-2.6.19.3-rsbac-1.3.2/fs/utimes.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/utimes.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/utimes.c	2007-03-15 14:32:50.000000000 +0100
@@ -5,6 +5,7 @@
 #include <linux/utime.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
+#include <rsbac/hooks.h>
 
 #ifdef __ARCH_WANT_SYS_UTIME
 
@@ -26,6 +27,12 @@
 	struct inode * inode;
 	struct iattr newattrs;
 
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(filename, &nd);
 	if (error)
 		goto out;
@@ -57,9 +64,39 @@
                         goto dput_and_out;
 
 		if (current->fsuid != inode->i_uid &&
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+		    !rsbac_dac_part_disabled(nd.dentry) &&
+#endif
 		    (error = vfs_permission(&nd, MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = nd.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_ACCESS_DATA,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto dput_and_out;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	error = notify_change(nd.dentry, &newattrs);
 	mutex_unlock(&inode->i_mutex);
@@ -82,6 +119,12 @@
 	struct inode * inode;
 	struct iattr newattrs;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = __user_walk_fd(dfd, filename, LOOKUP_FOLLOW, &nd);
 
 	if (error)
@@ -108,11 +151,41 @@
 		error = -EACCES;
                 if (IS_IMMUTABLE(inode))
                         goto dput_and_out;
-
+               #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+                if(!rsbac_dac_part_disabled(nd.dentry))
+                #endif
 		if (current->fsuid != inode->i_uid &&
 		    (error = vfs_permission(&nd, MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = inode->i_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = nd.dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_ACCESS_DATA,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		goto dput_and_out;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	error = notify_change(nd.dentry, &newattrs);
 	mutex_unlock(&inode->i_mutex);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/vfat/namei.c ./linux-2.6.19.3-rsbac-1.3.2/fs/vfat/namei.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/vfat/namei.c	2007-03-15 13:37:09.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/vfat/namei.c	2007-03-15 14:33:01.000000000 +0100
@@ -24,6 +24,8 @@
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 #include <linux/namei.h>
+#include <linux/security.h>
+#include <rsbac/hooks.h>
 
 static int vfat_revalidate(struct dentry *dentry, struct nameidata *nd)
 {
@@ -805,6 +807,11 @@
 	if (err)
 		goto out;
 
+        /* RSBAC vfat_unlink */
+        #ifdef CONFIG_RSBAC_SECDEL
+        rsbac_sec_del(dentry);
+        #endif
+
 	err = fat_remove_entries(dir, &sinfo);	/* and releases bh */
 	if (err)
 		goto out;
@@ -900,7 +907,13 @@
 			if (err)
 				goto out;
 		}
+#ifdef CONFIG_RSBAC_SECDEL
+		else
+			if(new_inode->i_nlink == 1)
+				rsbac_sec_del(new_dentry);
+#endif
 		new_i_pos = MSDOS_I(new_inode)->i_pos;
+
 		fat_detach(new_inode);
 	} else {
 		err = vfat_add_entry(new_dir, &new_dentry->d_name, is_dir, 0,
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/fs/xattr.c ./linux-2.6.19.3-rsbac-1.3.2/fs/xattr.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/fs/xattr.c	2007-03-15 13:37:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/fs/xattr.c	2007-03-15 14:32:55.000000000 +0100
@@ -20,6 +20,7 @@
 #include <linux/audit.h>
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
 
 /*
  * Check permissions for extended attribute access.  This is a bit complicated
@@ -76,6 +77,13 @@
 	struct inode *inode = dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+
 	error = xattr_permission(inode, name, MAY_WRITE);
 	if (error)
 		return error;
@@ -84,6 +92,31 @@
 	error = security_inode_setxattr(dentry, name, value, size, flags);
 	if (error)
 		goto out;
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_*setxattr()]: calling ADF\n");
+		rsbac_target = T_FILE;
+		if (S_ISDIR(inode->i_mode))
+			rsbac_target = T_DIR;
+		else if (S_ISFIFO(inode->i_mode))
+			rsbac_target = T_FIFO;
+		else if (S_ISLNK(inode->i_mode))
+			rsbac_target = T_SYMLINK;
+		else if (S_ISSOCK(inode->i_mode))
+			rsbac_target = T_UNIXSOCK;
+		rsbac_target_id.file.device = dentry->d_sb->s_dev;
+		rsbac_target_id.file.inode  = inode->i_ino;
+		rsbac_target_id.file.dentry_p = dentry;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value)) {
+			error = -EPERM;
+			goto out;
+		}
+#endif
 	error = -EOPNOTSUPP;
 	if (inode->i_op->setxattr) {
 		error = inode->i_op->setxattr(dentry, name, value, size, flags);
@@ -112,6 +145,12 @@
 	struct inode *inode = dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	error = xattr_permission(inode, name, MAY_READ);
 	if (error)
 		return error;
@@ -120,6 +159,33 @@
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_*getxattr()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		return error;
+	}
+#endif
+
 	if (inode->i_op->getxattr)
 		error = inode->i_op->getxattr(dentry, name, value, size);
 	else
@@ -146,7 +212,37 @@
 vfs_listxattr(struct dentry *d, char *list, size_t size)
 {
 	ssize_t error;
-
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_*listxattr()]: calling ADF\n");
+		rsbac_target = T_FILE;
+		if (S_ISDIR(d->d_inode->i_mode))
+			rsbac_target = T_DIR;
+		else if (S_ISFIFO(d->d_inode->i_mode))
+			rsbac_target = T_FIFO;
+		else if (S_ISLNK(d->d_inode->i_mode))
+			rsbac_target = T_SYMLINK;
+		else if (S_ISSOCK(d->d_inode->i_mode))
+			rsbac_target = T_UNIXSOCK;
+		rsbac_target_id.file.device = d->d_sb->s_dev;
+		rsbac_target_id.file.inode  = d->d_inode->i_ino;
+		rsbac_target_id.file.dentry_p = d;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+#endif
 	error = security_inode_listxattr(d);
 	if (error)
 		return error;
@@ -168,6 +264,12 @@
 	struct inode *inode = dentry->d_inode;
 	int error;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!inode->i_op->removexattr)
 		return -EOPNOTSUPP;
 
@@ -179,6 +281,33 @@
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_*removexattr()]: calling ADF\n");
+	rsbac_target = T_FILE;
+	if (S_ISDIR(inode->i_mode))
+		rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+		rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+		rsbac_target = T_SYMLINK;
+	else if (S_ISSOCK(inode->i_mode))
+		rsbac_target = T_UNIXSOCK;
+	rsbac_target_id.file.device = dentry->d_sb->s_dev;
+	rsbac_target_id.file.inode  = inode->i_ino;
+	rsbac_target_id.file.dentry_p = dentry;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		error = -EPERM;
+		return error;
+	}
+#endif
+
 	mutex_lock(&inode->i_mutex);
 	error = inode->i_op->removexattr(dentry, name);
 	mutex_unlock(&inode->i_mutex);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/.gitignore ./linux-2.6.19.3-rsbac-1.3.2/.gitignore
--- rsbac_tmp_15032007/kernel-2.6/trunk/.gitignore	2007-03-15 13:40:33.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# Normal rules
-#
-.*
-*.o
-*.a
-*.s
-*.ko
-*.so
-*.mod.c
-*.i
-*.lst
-*.symtypes
-
-#
-# Top-level generic files
-#
-tags
-TAGS
-vmlinux*
-System.map
-Module.symvers
-
-#
-# Generated include files
-#
-include/asm
-include/asm-*/asm-offsets.h
-include/config
-include/linux/autoconf.h
-include/linux/compile.h
-include/linux/version.h
-include/linux/utsrelease.h
-
-# stgit generated dirs
-patches-*
-
-# quilt's files
-patches
-series
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-alpha/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-alpha/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-alpha/unistd.h	2007-03-15 13:36:13.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-alpha/unistd.h	2007-03-15 14:32:17.000000000 +0100
@@ -317,7 +317,12 @@
 #define __NR_getdents64			377
 #define __NR_gettid			378
 #define __NR_readahead			379
+/* RSBAC - use old sys_security */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac			380
+#else
 /* 380 is unused */
+#endif
 #define __NR_tkill			381
 #define __NR_setxattr			382
 #define __NR_lsetxattr			383
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-arm/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-arm/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-arm/unistd.h	2007-03-15 13:35:53.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-arm/unistd.h	2007-03-15 14:31:53.000000000 +0100
@@ -248,7 +248,13 @@
 #define __NR_madvise			(__NR_SYSCALL_BASE+220)
 #define __NR_fcntl64			(__NR_SYSCALL_BASE+221)
 					/* 222 for tux */
+/* RSBAC - we use 223, the old sys_security */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac			(__NR_SYSCALL_BASE+223)
+#else
 					/* 223 is unused */
+#endif
+
 #define __NR_gettid			(__NR_SYSCALL_BASE+224)
 #define __NR_readahead			(__NR_SYSCALL_BASE+225)
 #define __NR_setxattr			(__NR_SYSCALL_BASE+226)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-cris/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-cris/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-cris/unistd.h	2007-03-15 13:35:39.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-cris/unistd.h	2007-03-15 14:31:44.000000000 +0100
@@ -227,7 +227,12 @@
 #define __NR_madvise		219
 #define __NR_getdents64		220
 #define __NR_fcntl64		221
+/* RSBAC - we use 223, the old sys_security */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		223
+#else
 /* 223 is unused */
+#endif
 #define __NR_gettid             224
 #define __NR_readahead          225
 #define __NR_setxattr		226
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-i386/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-i386/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-i386/unistd.h	2007-03-15 13:35:36.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-i386/unistd.h	2007-03-15 14:31:41.000000000 +0100
@@ -326,6 +326,10 @@
 #define __NR_getcpu		318
 #define __NR_epoll_pwait	319
 
+#ifdef CONFIG_RSBAC /* we use old sys_security */
+#define __NR_rsbac		223
+#endif
+
 #ifdef __KERNEL__
 
 #define NR_syscalls 320
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-ia64/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-ia64/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-ia64/unistd.h	2007-03-15 13:35:22.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-ia64/unistd.h	2007-03-15 14:31:29.000000000 +0100
@@ -292,6 +292,11 @@
 #define __NR_tee			1301
 #define __NR_vmsplice			1302
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac			1280
+#endif
+
 #ifdef __KERNEL__
 
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-m68k/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-m68k/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-m68k/unistd.h	2007-03-15 13:35:33.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-m68k/unistd.h	2007-03-15 14:31:39.000000000 +0100
@@ -314,10 +314,18 @@
 #define __NR_vmsplice		309
 #define __NR_move_pages		310
 
-#ifdef __KERNEL__
+/* RSBAC - we use 300 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		300
+#endif
 
+#ifdef __KERNEL__
+#ifdef CONFIG_RSBAC
+#define NR_syscalls		301
+#else
 #define NR_syscalls		311
 #include <linux/err.h>
+#endif
 
 /* user-visible error numbers are in the range -1 - -MAX_ERRNO: see
    <asm-m68k/errno.h> */
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-m68knommu/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-m68knommu/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-m68knommu/unistd.h	2007-03-15 13:35:18.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-m68knommu/unistd.h	2007-03-15 14:31:27.000000000 +0100
@@ -315,10 +315,18 @@
 #define __NR_vmsplice		309
 #define __NR_move_pages		310
 
-#ifdef __KERNEL__
+/* RSBAC - we use 300 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		300
+#endif
 
+#ifdef __KERNEL__
+#ifdef CONFIG_RSBAC
+#define NR_syscalls		301
+#else
 #define NR_syscalls		311
 #include <linux/err.h>
+#endif
 
 /* user-visible error numbers are in the range -1 - -MAX_ERRNO: see
    <asm-m68k/errno.h> */
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-mips/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-mips/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-mips/unistd.h	2007-03-15 13:35:29.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-mips/unistd.h	2007-03-15 14:31:33.000000000 +0100
@@ -241,7 +241,12 @@
 #define __NR_madvise			(__NR_Linux + 218)
 #define __NR_getdents64			(__NR_Linux + 219)
 #define __NR_fcntl64			(__NR_Linux + 220)
+/* RSBAC - we use 221, the old sys_security */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac			(__NR_Linux + 221)
+#else
 #define __NR_reserved221		(__NR_Linux + 221)
+#endif
 #define __NR_gettid			(__NR_Linux + 222)
 #define __NR_readahead			(__NR_Linux + 223)
 #define __NR_setxattr			(__NR_Linux + 224)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-parisc/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-parisc/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-parisc/unistd.h	2007-03-15 13:35:31.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-parisc/unistd.h	2007-03-15 14:31:37.000000000 +0100
@@ -787,7 +787,12 @@
 #define __NR_sync_file_range	(__NR_Linux + 292)
 #define __NR_tee		(__NR_Linux + 293)
 
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		(__NR_Linux + 300)
+#define __NR_Linux_syscalls     301
+#else
 #define __NR_Linux_syscalls     294
+#endif
 
 #define HPUX_GATEWAY_ADDR       0xC0000004
 #define LINUX_GATEWAY_ADDR      0x100
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-powerpc/systbl.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-powerpc/systbl.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-powerpc/systbl.h	2007-03-15 13:35:47.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-powerpc/systbl.h	2007-03-15 14:31:51.000000000 +0100
@@ -227,7 +227,11 @@
 COMPAT_SYS_SPU(futex)
 COMPAT_SYS_SPU(sched_setaffinity)
 COMPAT_SYS_SPU(sched_getaffinity)
+#ifdef CONFIG_RSBAC
+SYSCALL(rsbac)
+#else
 SYSCALL(ni_syscall)
+#endif
 SYSCALL(ni_syscall)
 SYS32ONLY(sendfile64)
 COMPAT_SYS_SPU(io_setup)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-powerpc/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-powerpc/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-powerpc/unistd.h	2007-03-15 13:35:47.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-powerpc/unistd.h	2007-03-15 14:31:50.000000000 +0100
@@ -238,6 +238,10 @@
 #define __NR_futex		221
 #define __NR_sched_setaffinity	222
 #define __NR_sched_getaffinity	223
+/* RSBAC - we use 224, the old sys_security */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		224
+#endif
 /* 224 currently unused */
 #define __NR_tuxcall		225
 #ifndef __powerpc64__
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-s390/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-s390/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-s390/unistd.h	2007-03-15 13:36:17.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-s390/unistd.h	2007-03-15 14:32:20.000000000 +0100
@@ -251,7 +251,12 @@
 #define __NR_getcpu		311
 #define __NR_epoll_pwait	312
 
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		350
+#define NR_syscalls 351
+#else
 #define NR_syscalls 313
+#endif
 
 /* 
  * There are some system calls that are not present on 64 bit, some
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-sh/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-sh/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-sh/unistd.h	2007-03-15 13:35:44.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-sh/unistd.h	2007-03-15 14:31:48.000000000 +0100
@@ -231,7 +231,12 @@
 #define __NR_madvise		219
 #define __NR_getdents64		220
 #define __NR_fcntl64		221
+/* RSBAC - we use 250 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		223
+#else
 /* 223 is unused */
+#endif
 #define __NR_gettid		224
 #define __NR_setxattr		226
 #define __NR_lsetxattr		227
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-sparc/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-sparc/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-sparc/unistd.h	2007-03-15 13:35:23.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-sparc/unistd.h	2007-03-15 14:31:30.000000000 +0100
@@ -180,7 +180,14 @@
 #define __NR_sched_get_affinity 161 /* Linux specific, getfh under SunOS           */
 #define __NR_getdomainname      162 /* SunOS Specific                              */
 #define __NR_setdomainname      163 /* Common                                      */
+
+/* RSBAC - we use 164, which seems to be unused */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		164
+#else
 /* #define __NR_utrap_install   164    Linux sparc64 specific			   */
+#endif
+
 #define __NR_quotactl           165 /* Common                                      */
 #define __NR_set_tid_address    166 /* Linux specific, exportfs under SunOS        */
 #define __NR_mount              167 /* Common                                      */
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-v850/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-v850/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-v850/unistd.h	2007-03-15 13:35:40.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-v850/unistd.h	2007-03-15 14:31:45.000000000 +0100
@@ -204,6 +204,11 @@
 #define __NR_gettid		201
 #define __NR_tkill		202
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		230
+#endif
+
 
 /* Syscall protocol:
    Syscall number in r12, args in r6-r9, r13-r14
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-x86_64/ia32_unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-x86_64/ia32_unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-x86_64/ia32_unistd.h	2007-03-15 13:35:38.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-x86_64/ia32_unistd.h	2007-03-15 14:31:42.000000000 +0100
@@ -15,4 +15,8 @@
 #define __NR_ia32_sigreturn	119
 #define __NR_ia32_rt_sigreturn	173
 
+#ifdef CONFIG_RSBAC
+#define __NR_ia32_rsbac __NR_ia32_security
+#endif
+
 #endif /* _ASM_X86_64_IA32_UNISTD_H_ */
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-x86_64/unistd.h ./linux-2.6.19.3-rsbac-1.3.2/include/asm-x86_64/unistd.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/asm-x86_64/unistd.h	2007-03-15 13:35:38.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/asm-x86_64/unistd.h	2007-03-15 14:31:42.000000000 +0100
@@ -428,7 +428,13 @@
 __SYSCALL(__NR_tuxcall, sys_ni_syscall)
 
 #define __NR_security			185
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac			185 /* reserved for security */
+__SYSCALL(__NR_rsbac, sys_rsbac)
+#else
 __SYSCALL(__NR_security, sys_ni_syscall)
+#endif
 
 #define __NR_gettid		186
 __SYSCALL(__NR_gettid, sys_gettid)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/include/linux/sched.h ./linux-2.6.19.3-rsbac-1.3.2/include/linux/sched.h
--- rsbac_tmp_15032007/kernel-2.6/trunk/include/linux/sched.h	2007-03-15 13:36:08.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/include/linux/sched.h	2007-03-15 14:32:10.000000000 +0100
@@ -24,6 +24,9 @@
 #define CLONE_UNTRACED		0x00800000	/* set if the tracing process can't force CLONE_PTRACE on this clone */
 #define CLONE_CHILD_SETTID	0x01000000	/* set the TID in the child */
 #define CLONE_STOPPED		0x02000000	/* Start in stopped state */
+#ifdef CONFIG_RSBAC
+#define CLONE_KTHREAD 		0x10000000 	/* clone a kernel thread */
+#endif
 #define CLONE_NEWUTS		0x04000000	/* New utsname group? */
 #define CLONE_NEWIPC		0x08000000	/* New ipcs */
 
@@ -85,6 +88,10 @@
 
 #include <asm/processor.h>
 
+#if defined(CONFIG_RSBAC_CAP_LOG_MISSING) || defined(CONFIG_RSBAC_JAIL_LOG_MISSING)
+#include <rsbac/log_cap.h>
+#endif
+
 struct exec_domain;
 struct futex_pi_state;
 
@@ -92,7 +99,11 @@
  * List of flags we want to share for kernel threads,
  * if only because they are not used by them anyway.
  */
+#ifdef CONFIG_RSBAC
+#define CLONE_KERNEL	(CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_KTHREAD)
+#else
 #define CLONE_KERNEL	(CLONE_FS | CLONE_FILES | CLONE_SIGHAND)
+#endif
 
 /*
  * These are the constant used to fake the fixed-point load-average
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/init/do_mounts.c ./linux-2.6.19.3-rsbac-1.3.2/init/do_mounts.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/init/do_mounts.c	2007-03-15 13:36:48.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/init/do_mounts.c	2007-03-15 14:32:47.000000000 +0100
@@ -16,6 +16,15 @@
 
 #include "do_mounts.h"
 
+/* RSBAC: including rsbac_init declaration */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#include <rsbac/debug.h>
+#ifdef CONFIG_BLK_DEV_INITRD
+#include <linux/initrd.h>
+#endif
+#endif
+
 extern int get_filesystem_list(char * buf);
 
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
@@ -444,6 +453,14 @@
 out:
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
+
+        /* RSBAC: OK, most stuff initialized and root mounted: Init RSBAC. */
+#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_INIT_DELAY
+        if(rsbac_no_delay_init)
+#endif
+        rsbac_init(ROOT_DEV);
+#endif
 	security_sb_post_mountroot();
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/init/main.c ./linux-2.6.19.3-rsbac-1.3.2/init/main.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/init/main.c	2007-03-15 13:36:48.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/init/main.c	2007-03-15 14:32:47.000000000 +0100
@@ -56,6 +56,10 @@
 #include <asm/sections.h>
 #include <asm/cacheflush.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 #ifdef CONFIG_X86_LOCAL_APIC
 #include <asm/smp.h>
 #endif
@@ -595,6 +599,9 @@
 	unnamed_dev_init();
 	key_init();
 	security_init();
+#ifdef CONFIG_RSBAC
+	rsbac_kthreads_init();
+#endif
 	vfs_caches_init(num_physpages);
 	radix_tree_init();
 	signals_init();
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/ipc/msg.c ./linux-2.6.19.3-rsbac-1.3.2/ipc/msg.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/ipc/msg.c	2007-03-15 13:37:36.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/ipc/msg.c	2007-03-15 14:33:19.000000000 +0100
@@ -40,6 +40,7 @@
 #include <asm/current.h>
 #include <asm/uaccess.h>
 #include "util.h"
+#include <rsbac/hooks.h>
 
 /*
  * one msg_receiver structure for each sleeping receiver:
@@ -143,6 +144,12 @@
 	struct msg_queue *msq;
 	int id, retval;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	msq = ipc_rcu_alloc(sizeof(*msq));
 	if (!msq)
 		return -ENOMEM;
@@ -150,6 +157,23 @@
 	msq->q_perm.mode = msgflg & S_IRWXUGO;
 	msq->q_perm.key = key;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_msgget()]: calling ADF\n");
+	rsbac_target_id.ipc.type = I_msg;
+	rsbac_target_id.ipc.id.id_nr = 0;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CREATE,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ipc_rcu_putref(msq);
+		return -EPERM;
+	}
+#endif
+
 	msq->q_perm.security = NULL;
 	retval = security_msg_queue_alloc(msq);
 	if (retval) {
@@ -173,6 +197,26 @@
 	INIT_LIST_HEAD(&msq->q_messages);
 	INIT_LIST_HEAD(&msq->q_receivers);
 	INIT_LIST_HEAD(&msq->q_senders);
+
+        /* RSBAC: notify ADF of new message queue */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.ipc.type = I_msg;
+        rsbac_target_id.ipc.id.id_nr = id;
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "newque() [sys_msgget()]: rsbac_adf_set_attr() returned error");
+          }
+        #endif
+
 	msg_unlock(msq);
 
 	return msq->q_id;
@@ -392,6 +436,13 @@
 	int err, version;
 	struct ipc_namespace *ns;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (msqid < 0 || cmd < 0)
 		return -EINVAL;
 
@@ -535,6 +586,58 @@
 		if (setbuf.qbytes > ns->msg_ctlmnb && !capable(CAP_SYS_RESOURCE))
 			goto out_unlock_up;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.ipc.type = I_msg;
+                rsbac_target_id.ipc.id.id_nr = msqid;
+                if (ipcp->uid != setbuf.uid)
+                  {
+                    rsbac_pr_debug(aef, "calling ADF\n");
+                    rsbac_attribute_value.owner = setbuf.uid;
+                    if (!rsbac_adf_request(R_CHANGE_OWNER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_owner,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                if (ipcp->gid != setbuf.gid)
+                  {
+                    rsbac_pr_debug(aef, "calling ADF\n");
+                    rsbac_attribute_value.group = setbuf.gid;
+                    if (!rsbac_adf_request(R_CHANGE_GROUP,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_group,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                if (ipcp->mode != ((ipcp->mode & ~S_IRWXUGO) | 
+                                  (S_IRWXUGO & setbuf.mode)) )
+                  {
+                    rsbac_pr_debug(aef, "calling ADF\n");
+                    rsbac_attribute_value.mode = (S_IRWXUGO & setbuf.mode);
+                    if (!rsbac_adf_request(R_ALTER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_mode,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                #endif
+
 		msq->q_qbytes = setbuf.qbytes;
 
 		ipcp->uid = setbuf.uid;
@@ -554,7 +657,42 @@
 		break;
 	}
 	case IPC_RMID:
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.ipc.type = I_msg;
+		rsbac_target_id.ipc.id.id_nr = msqid;
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_DELETE,
+					current->pid,
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out_unlock_up;
+		}
+#endif
+
 		freeque(ns, msq, msqid);
+
+		/* RSBAC: notify ADF of deleted message queue */
+#ifdef CONFIG_RSBAC
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_DELETE,
+					current->pid,
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING
+					"sys_msgctl(): rsbac_adf_set_attr() returned error");
+		}
+#endif
+
 		break;
 	}
 	err = 0;
@@ -635,6 +773,13 @@
 	int err;
 	struct ipc_namespace *ns;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	ns = current->nsproxy->ipc_ns;
 
 	if (msgsz > ns->msg_ctlmax || (long) msgsz < 0 || msqid < 0)
@@ -644,6 +789,23 @@
 	if (mtype < 1)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.ipc.type   = I_msg;
+        rsbac_target_id.ipc.id.id_nr  = msqid;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_SEND,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	msg = load_msg(msgp->mtext, msgsz);
 	if (IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -712,6 +874,22 @@
 		atomic_inc(&msg_hdrs);
 	}
 
+        #ifdef CONFIG_RSBAC
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_SEND,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_msgsnd(): rsbac_adf_set_attr() returned error");
+          }
+        #endif
+
 	err = 0;
 	msg = NULL;
 
@@ -750,11 +928,35 @@
 	int mode;
 	struct ipc_namespace *ns;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (msqid < 0 || (long) msgsz < 0)
 		return -EINVAL;
 	mode = convert_mode(&msgtyp, msgflg);
 	ns = current->nsproxy->ipc_ns;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.ipc.type   = I_msg;
+        rsbac_target_id.ipc.id.id_nr  = msqid;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_RECEIVE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	msq = msg_lock(ns, msqid);
 	if (msq == NULL)
 		return -EINVAL;
@@ -802,6 +1004,23 @@
 				msg = ERR_PTR(-E2BIG);
 				goto out_unlock;
 			}
+	                /* RSBAC: notify ADF of opened ipc */
+	                #ifdef CONFIG_RSBAC
+	                rsbac_new_target_id.dummy = 0;
+	                if (rsbac_adf_set_attr(R_RECEIVE,
+	                                       current->pid,
+	                                       T_IPC,
+	                                       rsbac_target_id,
+	                                       T_NONE,
+	                                       rsbac_new_target_id,
+	                                       A_none,
+	                                       rsbac_attribute_value))
+	                  {
+	                    rsbac_printk(KERN_WARNING
+	                           "sys_msgrcv(): rsbac_adf_set_attr() returned error");
+	                  }
+	                #endif
+
 			list_del(&msg->m_list);
 			msq->q_qnum--;
 			msq->q_rtime = get_seconds();
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/ipc/sem.c ./linux-2.6.19.3-rsbac-1.3.2/ipc/sem.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/ipc/sem.c	2007-03-15 13:37:36.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/ipc/sem.c	2007-03-15 14:33:19.000000000 +0100
@@ -86,6 +86,7 @@
 
 #include <asm/uaccess.h>
 #include "util.h"
+#include <rsbac/hooks.h>
 
 #define sem_ids(ns)	(*((ns)->ids[IPC_SEM_IDS]))
 
@@ -216,6 +217,13 @@
 	struct sem_array *sma;
 	int size;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!nsems)
 		return -EINVAL;
 	if (ns->used_sems + nsems > ns->sc_semmns)
@@ -231,6 +239,24 @@
 	sma->sem_perm.mode = (semflg & S_IRWXUGO);
 	sma->sem_perm.key = key;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+        rsbac_pr_debug(aef, "[sys_semget()]: calling ADF\n");
+        rsbac_target_id.ipc.type = I_sem;
+        rsbac_target_id.ipc.id.id_nr = 0;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            ipc_rcu_putref(sma);
+            return -EPERM;
+          }
+        #endif
+
 	sma->sem_perm.security = NULL;
 	retval = security_sem_alloc(sma);
 	if (retval) {
@@ -255,6 +281,21 @@
 	sma->sem_ctime = get_seconds();
 	sem_unlock(sma);
 
+/* RSBAC: notify ADF of new shm */
+#ifdef CONFIG_RSBAC_IPC_SEM
+	rsbac_target_id.ipc.id.id_nr = sma->sem_id;
+	rsbac_new_target_id.dummy = 0;
+	if (rsbac_adf_set_attr(R_CREATE,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				T_NONE,
+				rsbac_new_target_id,
+				A_none,
+				rsbac_attribute_value))
+		rsbac_printk(KERN_WARNING
+		"newary() [sys_semget()]: rsbac_adf_set_attr() returned error");
+#endif
 	return sma->sem_id;
 }
 
@@ -645,6 +686,13 @@
 	ushort* sem_io = fast_sem_io;
 	int nsems;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	sma = sem_lock(ns, semid);
 	if(sma==NULL)
 		return -EINVAL;
@@ -691,12 +739,52 @@
 			}
 		}
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+                rsbac_pr_debug(aef, "[sys_semctl()]: calling ADF\n");
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_READ,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    sem_unlock(sma);
+                    goto out_free;
+                  }
+                #endif
+
 		for (i = 0; i < sma->sem_nsems; i++)
 			sem_io[i] = sma->sem_base[i].semval;
 		sem_unlock(sma);
 		err = 0;
 		if(copy_to_user(array, sem_io, nsems*sizeof(ushort)))
 			err = -EFAULT;
+
+                /* RSBAC: notify ADF of read sem */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                if(!err)
+                  {
+                    rsbac_new_target_id.dummy = 0;
+                    if (rsbac_adf_set_attr(R_READ,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "semctl_main() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+                      }
+                  }
+                #endif
+
 		goto out_free;
 	}
 	case SETALL:
@@ -725,6 +813,26 @@
 			goto out_free;
 		}
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+                rsbac_pr_debug(aef, "[sys_semctl()]: calling ADF\n");
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_WRITE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value)) {
+			err = -EPERM;
+			ipc_lock_by_ptr(&sma->sem_perm);
+			ipc_rcu_putref(sma);
+			sem_unlock(sma);
+			goto out_free;
+                  }
+                #endif
+
 		for (i = 0; i < nsems; i++) {
 			if (sem_io[i] > SEMVMX) {
 				ipc_lock_by_ptr(&sma->sem_perm);
@@ -748,6 +856,24 @@
 			for (i = 0; i < nsems; i++)
 				un->semadj[i] = 0;
 		sma->sem_ctime = get_seconds();
+
+                /* RSBAC: notify ADF of written sem */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_WRITE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "semctl_main() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+                  }
+                #endif
+
 		/* maybe some queued-up processes were waiting for this */
 		update_queue(sma);
 		err = 0;
@@ -795,6 +921,24 @@
 		if (val > SEMVMX || val < 0)
 			goto out_unlock;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+                rsbac_pr_debug(aef, "[sys_semctl()]: calling ADF\n");
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_WRITE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    goto out_unlock;
+                  }
+                #endif
+
 		for (un = sma->undo; un; un = un->id_next)
 			un->semadj[semnum] = 0;
 		curr->semval = val;
@@ -862,6 +1006,13 @@
 	struct sem_setbuf setbuf;
 	struct kern_ipc_perm *ipcp;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if(cmd == IPC_SET) {
 		if(copy_semid_from_user (&setbuf, arg.buf, version))
 			return -EFAULT;
@@ -897,10 +1048,96 @@
 
 	switch(cmd){
 	case IPC_RMID:
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+                rsbac_pr_debug(aef, "[sys_semctl()]: calling ADF\n");
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_DELETE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    goto out_unlock;
+                  }
+                #endif
+
 		freeary(ns, sma, semid);
+
+                /* RSBAC: notify ADF of deleted sem */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_DELETE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "semctl_down() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+                  }
+                #endif
+
 		err = 0;
 		break;
 	case IPC_SET:
+#ifdef CONFIG_RSBAC_IPC_SEM
+		rsbac_target_id.ipc.type = I_sem;
+		rsbac_target_id.ipc.id.id_nr = semid;
+		if (ipcp->uid != setbuf.uid)
+		{
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.owner = setbuf.uid;
+			if (!rsbac_adf_request(R_CHANGE_OWNER,
+						current->pid,
+						T_IPC,
+						rsbac_target_id,
+						A_owner,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+		if (ipcp->gid != setbuf.gid)
+		{
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.group = setbuf.gid;
+			if (!rsbac_adf_request(R_CHANGE_GROUP,
+						current->pid,
+						T_IPC,
+						rsbac_target_id,
+						A_group,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+		if (ipcp->mode != ((ipcp->mode & ~S_IRWXUGO) | 
+					(S_IRWXUGO & setbuf.mode)) )
+		{
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.mode = (S_IRWXUGO & setbuf.mode);
+			if (!rsbac_adf_request(R_ALTER,
+						current->pid,
+						T_IPC,
+						rsbac_target_id,
+						A_mode,
+						rsbac_attribute_value))
+			{
+				err = -EPERM;
+				goto out_unlock;
+			}
+		}
+#endif
 		ipcp->uid = setbuf.uid;
 		ipcp->gid = setbuf.gid;
 		ipcp->mode = (ipcp->mode & ~S_IRWXUGO)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/ipc/shm.c ./linux-2.6.19.3-rsbac-1.3.2/ipc/shm.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/ipc/shm.c	2007-03-15 13:37:36.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/ipc/shm.c	2007-03-15 14:33:19.000000000 +0100
@@ -42,6 +42,8 @@
 
 #include "util.h"
 
+#include <rsbac/hooks.h>
+
 static struct file_operations shm_file_operations;
 static struct vm_operations_struct shm_vm_ops;
 
@@ -79,13 +81,35 @@
 
 static void do_shm_rmid(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 	if (shp->shm_nattch){
 		shp->shm_perm.mode |= SHM_DEST;
 		/* Do not find it any more */
 		shp->shm_perm.key = IPC_PRIVATE;
 		shm_unlock(shp);
-	} else
+	} else {
 		shm_destroy(ns, shp);
+			/* RSBAC: notify ADF of deleted shm */
+#ifdef CONFIG_RSBAC
+			rsbac_new_target_id.dummy = 0;
+			if (rsbac_adf_set_attr(R_DELETE,
+						current->pid,
+						T_IPC,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_none,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING
+						"sys_shmctl(): rsbac_adf_set_attr() returned error");
+			}
+#endif
+	}
 }
 
 #ifdef CONFIG_IPC_NS
@@ -181,6 +205,11 @@
  */
 static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        #endif
+
 	ns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid(ns, shp->id);
 	shm_unlock(shp);
@@ -191,6 +220,15 @@
 						shp->mlock_user);
 	fput (shp->shm_file);
 	security_shm_free(shp);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ACI remove_target()\n");
+        rsbac_target_id.ipc.type   = I_shm;
+        rsbac_target_id.ipc.id.id_nr  = shp->id;
+        rsbac_remove_target(T_IPC, rsbac_target_id);
+        #endif
+
 	ipc_rcu_putref(shp);
 }
 
@@ -207,6 +245,28 @@
 	struct shmid_kernel *shp;
 	struct ipc_namespace *ns;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_shmdt() et al.]: calling ADF\n");
+	rsbac_target_id.ipc.type   = I_shm;
+	rsbac_target_id.ipc.id.id_nr  = id;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_CLOSE,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		rsbac_printk(KERN_WARNING
+				"shm_close() [sys_shmdt() et al.]: rsbac_adf_request() for CLOSE returned NOT_GRANTED\n");
+	}
+#endif
+
 	ns = shm_file_ns(file);
 
 	mutex_lock(&shm_ids(ns).mutex);
@@ -276,6 +336,13 @@
 	char name[13];
 	int id;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (size < SHMMIN || size > ns->shm_ctlmax)
 		return -EINVAL;
 
@@ -286,6 +353,24 @@
 	if (!shp)
 		return -ENOMEM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_shmget()]: calling ADF\n");
+        rsbac_target_id.ipc.type = I_shm;
+        rsbac_target_id.ipc.id.id_nr = 0;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            ipc_rcu_putref(shp);
+            return -EPERM;
+          }
+        #endif
+
 	shp->shm_perm.key = key;
 	shp->shm_perm.mode = (shmflg & S_IRWXUGO);
 	shp->mlock_user = NULL;
@@ -340,6 +425,23 @@
 
 	ns->shm_tot += numpages;
 	shm_unlock(shp);
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+        rsbac_new_target_id.ipc.type = I_shm;
+        rsbac_new_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+        if (rsbac_adf_set_attr(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               T_IPC,
+                               rsbac_new_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "newseg() [sys_shmget()]: rsbac_adf_set_attr() returned error");
+          }
+        #endif
 	return shp->id;
 
 no_id:
@@ -517,6 +619,12 @@
 	int err, version;
 	struct ipc_namespace *ns;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (cmd < 0 || shmid < 0) {
 		err = -EINVAL;
 		goto out;
@@ -701,6 +809,23 @@
 		if (err)
 			goto out_unlock_up;
 
+#ifdef CONFIG_RSBAC
+		rsbac_target_id.ipc.type = I_shm;
+		rsbac_target_id.ipc.id.id_nr = shmid;
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_DELETE,
+					current->pid,
+					T_IPC,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			err = -EPERM;
+			goto out_unlock_up;
+		}
+#endif
+
 		do_shm_rmid(ns, shp);
 		mutex_unlock(&shm_ids(ns).mutex);
 		goto out;
@@ -737,6 +862,58 @@
 		if (err)
 			goto out_unlock_up;
 		
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.ipc.type = I_shm;
+                rsbac_target_id.ipc.id.id_nr = shmid;
+                if (shp->shm_perm.uid != setbuf.uid)
+                  {
+                    rsbac_pr_debug(aef, "calling ADF\n");
+                    rsbac_attribute_value.owner = setbuf.uid;
+                    if (!rsbac_adf_request(R_CHANGE_OWNER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_owner,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                if (shp->shm_perm.gid != setbuf.gid)
+                  {
+                    rsbac_pr_debug(aef, "calling ADF\n");
+                    rsbac_attribute_value.group = setbuf.gid;
+                    if (!rsbac_adf_request(R_CHANGE_GROUP,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_group,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                if (shp->shm_perm.mode != ((shp->shm_perm.mode & ~S_IRWXUGO) | 
+                                           (S_IRWXUGO & setbuf.mode)) )
+                  {
+                    rsbac_pr_debug(aef, "calling ADF\n");
+                    rsbac_attribute_value.mode = (S_IRWXUGO & setbuf.mode);
+                    if (!rsbac_adf_request(R_ALTER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_mode,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                #endif
+
 		shp->shm_perm.uid = setbuf.uid;
 		shp->shm_perm.gid = setbuf.gid;
 		shp->shm_perm.mode = (shp->shm_perm.mode & ~S_IRWXUGO)
@@ -782,6 +959,14 @@
 	void *user_addr;
 	struct ipc_namespace *ns;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request = R_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (shmid < 0) {
 		err = -EINVAL;
 		goto out;
@@ -842,6 +1027,28 @@
 		return err;
 	}
 		
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef,  "calling ADF\n");
+        if ((shmflg & SHM_RDONLY))
+          rsbac_request = R_READ_OPEN;
+        else
+          rsbac_request = R_READ_WRITE_OPEN;
+        rsbac_target_id.ipc.type   = I_shm;
+        rsbac_target_id.ipc.id.id_nr  = shp->id;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(rsbac_request,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            shm_unlock(shp);
+            return -EPERM;
+          }
+        #endif
+
 	file = shp->shm_file;
 	size = i_size_read(file->f_dentry->d_inode);
 	shp->shm_nattch++;
@@ -882,6 +1089,26 @@
 	if (IS_ERR(user_addr))
 		err = PTR_ERR(user_addr);
 out:
+        /* RSBAC: notify ADF of attached shm */
+        #ifdef CONFIG_RSBAC
+        if(!err)
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(rsbac_request,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_shmat(): rsbac_adf_set_attr() returned error");
+              }
+          }
+        #endif
+
 	return err;
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/capability.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/capability.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/capability.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/capability.c	2007-03-15 14:31:19.000000000 +0100
@@ -14,6 +14,8 @@
 #include <linux/syscalls.h>
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 unsigned securebits = SECUREBITS_DEFAULT; /* systemwide security settings */
 kernel_cap_t cap_bset = CAP_INIT_EFF_SET;
 
@@ -24,7 +26,13 @@
  * This lock protects task->cap_* for all tasks including current.
  * Locking rule: acquire this prior to tasklist_lock.
  */
+
+/* RSBAC: Setting caps from outside, need the lock */
+#if defined(CONFIG_RSBAC_CAP) || defined(CONFIG_RSBAC_JAIL)
+DEFINE_SPINLOCK(task_capability_lock);
+#else
 static DEFINE_SPINLOCK(task_capability_lock);
+#endif
 
 /*
  * For sys_getproccap() and sys_setproccap(), any of the three
@@ -49,6 +57,12 @@
      struct task_struct *target;
      struct __user_cap_data_struct data;
 
+     /* RSBAC */
+     #ifdef CONFIG_RSBAC
+     union rsbac_target_id_t       rsbac_target_id;
+     union rsbac_attribute_value_t rsbac_attribute_value;
+     #endif
+
      if (get_user(version, &header->version))
 	     return -EFAULT;
 
@@ -82,6 +96,25 @@
      read_unlock(&tasklist_lock); 
      spin_unlock(&task_capability_lock);
 
+     /* RSBAC */
+     #ifdef CONFIG_RSBAC
+     if(!ret)
+       {
+         rsbac_pr_debug(aef, "calling ADF\n");
+         rsbac_target_id.process = pid;
+	 rsbac_attribute_value.dummy = 0;
+         if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+           {
+             ret = -EPERM;
+           }
+       }
+     #endif
+
      if (!ret && copy_to_user(dataptr, &data, sizeof data))
           return -EFAULT; 
 
@@ -176,6 +209,12 @@
      int ret;
      pid_t pid;
 
+     /* RSBAC */
+     #ifdef CONFIG_RSBAC
+     union rsbac_target_id_t       rsbac_target_id;
+     union rsbac_attribute_value_t rsbac_attribute_value;
+     #endif
+
      if (get_user(version, &header->version))
 	     return -EFAULT; 
 
@@ -196,6 +235,22 @@
 	 copy_from_user(&permitted, &data->permitted, sizeof(permitted)))
 	     return -EFAULT; 
 
+     /* RSBAC */
+     #ifdef CONFIG_RSBAC
+     rsbac_pr_debug(aef, "calling ADF\n");
+     rsbac_target_id.scd = ST_capability;
+     rsbac_attribute_value.dummy = 0;
+     if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                           current->pid,
+                           T_SCD,
+                           rsbac_target_id,
+                           A_none,
+                           rsbac_attribute_value))
+       {
+         return -EPERM;
+       }
+     #endif
+
      spin_lock(&task_capability_lock);
      read_lock(&tasklist_lock);
 
@@ -240,6 +295,10 @@
 		t->flags |= PF_SUPERPRIV;
 		return 1;
 	}
+#if defined(CONFIG_RSBAC_CAP_LOG_MISSING) || defined(CONFIG_RSBAC_JAIL_LOG_MISSING)
+	else
+		rsbac_log_missing_cap(cap);
+#endif
 	return 0;
 }
 EXPORT_SYMBOL(__capable);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/exit.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/exit.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/exit.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/exit.c	2007-03-15 14:31:19.000000000 +0100
@@ -47,6 +47,8 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#include <rsbac/hooks.h>
+
 extern void sem_exit (void);
 extern struct task_struct *child_reaper;
 
@@ -861,6 +863,12 @@
 	int group_dead;
 	unsigned int mycpu;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	profile_task_exit(tsk);
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
@@ -942,6 +950,27 @@
 	tsk->exit_code = code;
 	proc_exit_connector(tsk);
 	exit_notify(tsk);
+
+        /* RSBAC: notifying ADF */
+        #ifdef CONFIG_RSBAC
+        if (tsk->pid)
+          {
+            rsbac_pr_debug(aef, "[sys_exit()]: calling ADF\n");
+            rsbac_target_id.process = tsk->pid;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_TERMINATE,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                  "do_exit() [sys_exit()]: ADF request for TERMINATE returned NOT_GRANTED!\n");
+              }
+          }
+        #endif
+
 	exit_task_namespaces(tsk);
 #ifdef CONFIG_NUMA
 	mpol_free(tsk->mempolicy);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/fork.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/fork.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/fork.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/fork.c	2007-03-15 14:31:22.000000000 +0100
@@ -56,6 +56,8 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -1355,8 +1357,35 @@
 	struct pid *pid = alloc_pid();
 	long nr;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+union rsbac_target_id_t       rsbac_new_target_id;
+enum  rsbac_attribute_t       rsbac_attribute;
+union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!pid)
 		return -EAGAIN;
+	
+#ifdef CONFIG_RSBAC
+	rsbac_attribute = A_none;
+	rsbac_attribute_value.dummy = 0;
+	if(current->pid)
+	{
+		rsbac_pr_debug(aef, "[sys_fork(),sys_clone(),sys_vfork]: calling ADF\n");
+		rsbac_target_id.process = current->pid;
+		if (!rsbac_adf_request(R_CLONE,
+					current->pid,
+					T_PROCESS,
+					rsbac_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+	}
+#endif
+
 	nr = pid->nr;
 	if (unlikely(current->ptrace)) {
 		trace = fork_traceflag (clone_flags);
@@ -1385,6 +1414,34 @@
 			set_tsk_thread_flag(p, TIF_SIGPENDING);
 		}
 
+                /* RSBAC: notify ADF of forked process */
+                #ifdef CONFIG_RSBAC
+		if (clone_flags & CLONE_KTHREAD) {
+			rsbac_attribute = A_kernel_thread;
+			rsbac_attribute_value.kernel_thread = 1;
+			rsbac_mark_kthread(p->pid);
+			rsbac_kthread_notify(p->pid);
+		}
+
+                if(current->pid)
+                  {
+                    rsbac_pr_debug(aef, "[sys_fork(),sys_clone(),sys_vfork()]: calling ADF_set_attr\n");
+                    rsbac_new_target_id.process = p->pid;
+                    if (rsbac_adf_set_attr(R_CLONE,
+                                           current->pid,
+                                           T_PROCESS,
+                                           rsbac_target_id,
+                                           T_PROCESS,
+                                           rsbac_new_target_id,
+                                           rsbac_attribute,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "do_fork() [sys_fork(), sys_clone()]: rsbac_adf_set_attr() returned error!\n");
+                      }
+                  }
+                #endif
+
 		if (!(clone_flags & CLONE_STOPPED))
 			wake_up_new_task(p, clone_flags);
 		else
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/kallsyms.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/kallsyms.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/kallsyms.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/kallsyms.c	2007-03-15 14:31:19.000000000 +0100
@@ -20,9 +20,12 @@
 #include <linux/proc_fs.h>
 #include <linux/sched.h>	/* for cond_resched */
 #include <linux/mm.h>
+#include <linux/security.h>
 
 #include <asm/sections.h>
 
+#include <rsbac/hooks.h>
+
 #ifdef CONFIG_KALLSYMS_ALL
 #define all_var 1
 #else
@@ -416,6 +419,28 @@
 	struct kallsym_iter *iter;
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.scd = ST_ksyms;
+        rsbac_attribute_value.dummy = 0;
+        rsbac_pr_debug(aef, "calling ADF\n");
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	iter = kmalloc(sizeof(*iter), GFP_KERNEL);
 	if (!iter)
 		return -ENOMEM;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/kexec.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/kexec.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/kexec.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/kexec.c	2007-03-15 14:31:26.000000000 +0100
@@ -27,6 +27,8 @@
 #include <asm/system.h>
 #include <asm/semaphore.h>
 
+#include <rsbac/hooks.h>
+
 /* Per cpu memory for storing cpu states in case of system crash. */
 note_buf_t* crash_notes;
 
@@ -919,10 +921,30 @@
 	int locked;
 	int result;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t		rsbac_target_id;
+	union rsbac_attribute_value_t	rsbac_attribute_value;
+#endif
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!capable(CAP_SYS_BOOT))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	rsbac_target_id.scd = ST_kexec;
+	rsbac_attribute_value.dummy = 0;
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+	
 	/*
 	 * Verify we have a legal set of flags
 	 * This leaves us room for future extensions.
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/kmod.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/kmod.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/kmod.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/kmod.c	2007-03-15 14:31:26.000000000 +0100
@@ -36,6 +36,10 @@
 #include <linux/resource.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 extern int max_threads;
 
 static struct workqueue_struct *khelper_wq;
@@ -191,6 +195,11 @@
 	allow_signal(SIGCHLD);
 
 	pid = kernel_thread(____call_usermodehelper, sub_info, SIGCHLD);
+	
+#ifdef CONFIG_RSBAC
+	rsbac_kthread_notify(pid);
+#endif
+
 	if (pid < 0) {
 		sub_info->retval = pid;
 	} else {
@@ -232,10 +241,19 @@
 	 * until that is done.  */
 	if (wait)
 		pid = kernel_thread(wait_for_helper, sub_info,
+#ifdef CONFIG_RSBAC
+				    CLONE_FS | CLONE_FILES | CLONE_KTHREAD | SIGCHLD);
+#else
 				    CLONE_FS | CLONE_FILES | SIGCHLD);
+#endif
 	else
 		pid = kernel_thread(____call_usermodehelper, sub_info,
+#ifdef CONFIG_RSBAC
+				    CLONE_VFORK | CLONE_KTHREAD | SIGCHLD);
+	rsbac_kthread_notify(pid);
+#else
 				    CLONE_VFORK | SIGCHLD);
+#endif
 
 	if (pid < 0) {
 		sub_info->retval = pid;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/kthread.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/kthread.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/kthread.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/kthread.c	2007-03-15 14:31:25.000000000 +0100
@@ -15,6 +15,10 @@
 #include <linux/mutex.h>
 #include <asm/semaphore.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 /*
  * We dont want to execute off keventd since it might
  * hold a semaphore our callers hold too:
@@ -118,9 +122,14 @@
 
 	/* We want our own signal handler (we take no signals by default). */
 	pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);
+
 	if (pid < 0) {
 		create->result = ERR_PTR(pid);
 	} else {
+#ifdef CONFIG_RSBAC
+		rsbac_kthread_notify(pid);
+#endif
+
 		wait_for_completion(&create->started);
 		read_lock(&tasklist_lock);
 		create->result = find_task_by_pid(pid);
@@ -178,6 +187,10 @@
 		va_end(args);
 	}
 
+#ifdef CONFIG_RSBAC
+	rsbac_kthread_notify(create.result->pid);
+#endif
+
 	return create.result;
 }
 EXPORT_SYMBOL(kthread_create);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/module.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/module.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/module.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/module.c	2007-03-15 14:31:21.000000000 +0100
@@ -45,6 +45,8 @@
 #include <asm/cacheflush.h>
 #include <linux/license.h>
 
+#include <rsbac/hooks.h>
+
 #if 0
 #define DEBUGP printk
 #else
@@ -656,6 +658,12 @@
 	char name[MODULE_NAME_LEN];
 	int ret, forced = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_MODULE))
 		return -EPERM;
 
@@ -663,6 +671,21 @@
 		return -EFAULT;
 	name[MODULE_NAME_LEN-1] = '\0';
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.dummy = 0;
+	rsbac_attribute_value.mod_name = name;
+	if (!rsbac_adf_request(R_REMOVE_FROM_KERNEL,
+				current->pid,
+				T_NONE,
+				rsbac_target_id,
+				A_mod_name,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (mutex_lock_interruptible(&module_mutex) != 0)
 		return -EINTR;
 
@@ -1907,10 +1930,32 @@
 	struct module *mod;
 	int ret = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* Must have permission */
 	if (!capable(CAP_SYS_MODULE))
 		return -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.dummy = 0;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_ADD_TO_KERNEL,
+                               current->pid,
+                               T_NONE,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	/* Only one module load at a time, please */
 	if (mutex_lock_interruptible(&module_mutex) != 0)
 		return -EINTR;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/printk.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/printk.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/printk.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/printk.c	2007-03-15 14:31:23.000000000 +0100
@@ -35,6 +35,8 @@
 
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
 /* printk's without a loglevel use this.. */
@@ -187,10 +189,58 @@
 	char c;
 	int error = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SYSLOG
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = security_syslog(type);
 	if (error)
 		return error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SYSLOG
+        rsbac_pr_debug(aef, "[sys_syslog()]: calling ADF\n");
+        rsbac_target_id.scd = ST_syslog;
+        rsbac_attribute_value.dummy = 0;
+        switch(type)
+          {
+            case 2:
+            case 3:
+              if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                                    current->pid,
+                                    T_SCD,
+                                    rsbac_target_id,
+                                    A_none,
+                                    rsbac_attribute_value))
+                {
+                  error = -EPERM;
+                  goto out;
+                }
+              break;
+            case 4:
+            case 5:
+            case 6:
+            case 7:
+            case 8:
+              if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                    current->pid,
+                                    T_SCD,
+                                    rsbac_target_id,
+                                    A_none,
+                                    rsbac_attribute_value))
+                {
+                  error = -EPERM;
+                  goto out;
+                }
+              break;
+
+            default:
+              break;
+          }
+        #endif
+
 	switch (type) {
 	case 0:		/* Close log */
 		break;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/ptrace.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/ptrace.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/ptrace.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/ptrace.c	2007-03-15 14:31:26.000000000 +0100
@@ -22,6 +22,8 @@
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * ptrace a task: make the debugger its new parent and
  * move it to the ptrace list.
@@ -400,12 +402,31 @@
 {
 	int ret = -EPERM;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/*
 	 * Are we already being traced?
 	 */
 	task_lock(current);
 	if (!(current->ptrace & PT_PTRACED)) {
 		ret = security_ptrace(current->parent, current);
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_ptrace] calling ADF\n");
+		rsbac_target_id.process = current->pid;
+		rsbac_attribute_value.trace_request = PTRACE_TRACEME;
+		if (!rsbac_adf_request(R_TRACE,
+					current->pid,
+					T_PROCESS,
+					rsbac_target_id,
+					A_trace_request,
+					rsbac_attribute_value))
+		{
+			ret = -EPERM;
+		}
+#endif
 		/*
 		 * Set the ptrace bit in the process ptrace flags.
 		 */
@@ -453,6 +474,11 @@
 	struct task_struct *child;
 	long ret;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	/*
 	 * This lock_kernel fixes a subtle race with suid exec
 	 */
@@ -462,6 +488,24 @@
 		goto out;
 	}
 
+#ifdef CONFIG_RSBAC
+	if (request != PTRACE_DETACH) {
+		rsbac_pr_debug(aef, "[sys_ptrace] calling ADF\n");
+		rsbac_target_id.process = pid;
+		rsbac_attribute_value.trace_request = request;
+		if (!rsbac_adf_request(R_TRACE,
+					current->pid,
+					T_PROCESS,
+					rsbac_target_id,
+					A_trace_request,
+					rsbac_attribute_value))
+		{
+			ret = -EPERM;
+			goto out;
+		}
+	}
+#endif
+
 	child = ptrace_get_task_struct(pid);
 	if (IS_ERR(child)) {
 		ret = PTR_ERR(child);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/sched.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/sched.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/sched.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/sched.c	2007-03-15 14:31:26.000000000 +0100
@@ -56,6 +56,8 @@
 
 #include <asm/unistd.h>
 
+#include <rsbac/hooks.h>
+
 /*
  * Convert user-nice values [ -20 ... 0 ... 19 ]
  * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
@@ -1403,7 +1405,6 @@
 #ifdef CONFIG_SMP
 	if (unlikely(task_running(rq, p)))
 		goto out_activate;
-
 	new_cpu = cpu;
 
 	schedstat_inc(rq, ttwu_cnt);
@@ -1419,7 +1420,6 @@
 			break;
 		}
 	}
-
 	if (unlikely(!cpu_isset(this_cpu, p->cpus_allowed)))
 		goto out_set_cpu;
 
@@ -4001,6 +4001,10 @@
 asmlinkage long sys_nice(int increment)
 {
 	long nice, retval;
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	/*
 	 * Setpriority might change our priority at the same moment.
@@ -4021,6 +4025,23 @@
 	if (increment < 0 && !can_nice(current, nice))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC
+	if (increment < 0) {
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.scd = ST_priority;
+		rsbac_attribute_value.priority = nice;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					current->pid,
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			return -EPERM;
+		}
+	}
+#endif
+
 	retval = security_task_setnice(current, nice);
 	if (retval)
 		return retval;
@@ -4169,6 +4190,7 @@
 	retval = security_task_setscheduler(p, policy, param);
 	if (retval)
 		return retval;
+
 	/*
 	 * make sure no PI-waiters arrive (or leave) while we are
 	 * changing the priority of the task:
@@ -4220,11 +4242,43 @@
 	struct task_struct *p;
 	int retval;
 
+	/* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!param || pid < 0)
 		return -EINVAL;
 	if (copy_from_user(&lparam, param, sizeof(struct sched_param)))
 		return -EFAULT;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_sched_setscheduler, sys_sched_setparam]: calling ADF\n");
+        if(!pid || (pid == current->pid))
+          {
+            rsbac_target = T_SCD;
+            rsbac_target_id.scd = ST_priority;
+          }
+        else
+          {
+            rsbac_target = T_PROCESS;
+            rsbac_target_id.process = pid;
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	rcu_read_lock();
 	retval = -ESRCH;
 	p = find_process_by_pid(pid);
@@ -4329,6 +4383,12 @@
 
 long sched_setaffinity(pid_t pid, cpumask_t new_mask)
 {
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	cpumask_t cpus_allowed;
 	struct task_struct *p;
 	int retval;
@@ -4343,6 +4403,33 @@
 		return -ESRCH;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_sched_setaffinity]: calling ADF\n");
+        if(p == current)
+          {
+            rsbac_target = T_SCD;
+            rsbac_target_id.scd = ST_priority;
+          }
+        else
+          {
+            rsbac_target = T_PROCESS;
+            rsbac_target_id.process = p->pid;
+          }
+          rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+	    read_unlock(&tasklist_lock);
+	    unlock_cpu_hotplug();
+            return -EPERM;
+          }
+        #endif
+
 	/*
 	 * It is not safe to call set_cpus_allowed with the
 	 * tasklist_lock held.  We will bump the task_struct's
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/signal.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/signal.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/signal.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/signal.c	2007-03-15 14:31:26.000000000 +0100
@@ -29,6 +29,8 @@
 #include <asm/siginfo.h>
 #include "audit.h"	/* audit_signal_info() */
 
+#include <rsbac/hooks.h>
+
 /*
  * SLAB caches for signal bits.
  */
@@ -577,6 +579,13 @@
 				 struct task_struct *t)
 {
 	int error = -EINVAL;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!valid_signal(sig))
 		return error;
 	error = -EPERM;
@@ -588,6 +597,25 @@
 	    && !capable(CAP_KILL))
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[group_send_sig_info(), sys_tgkill(),sys_tkill()]: calling ADF\n");
+	rsbac_target_id.process = t->pid;
+	rsbac_attribute_value.dummy = 0;
+	if(   (!info || ((unsigned long)info != 1 &&
+					(unsigned long)info != 2 && SI_FROMUSER(info)))
+			&& (   (sig != SIGCONT)
+				|| (current->signal->session != t->signal->session)
+			   )
+			&& !rsbac_adf_request(R_SEND_SIGNAL,
+				current->pid,
+				T_PROCESS,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)
+	  )
+		return -EPERM;
+#endif
+
 	error = security_task_kill(t, info, sig, 0);
 	if (!error)
 		audit_signal_info(sig, t); /* Let audit system see the signal */
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/sys.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/sys.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/sys.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/sys.c	2007-03-15 14:31:25.000000000 +0100
@@ -38,6 +38,8 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#include <rsbac/hooks.h>
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
 #endif
@@ -577,6 +579,7 @@
 		error = no_nice;
 		goto out;
 	}
+
 	if (error == -ESRCH)
 		error = 0;
 	set_user_nice(p, niceval);
@@ -590,6 +593,13 @@
 	struct user_struct *user;
 	int error = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (which > 2 || which < 0)
 		goto out;
 
@@ -600,6 +610,43 @@
 	if (niceval > 19)
 		niceval = 19;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(   (niceval < (current->static_prio - MAX_RT_PRIO - 20))
+           || (   (which == PRIO_PROCESS)
+               && (who != 0)
+               && (who != current->pid)
+              )
+           || (   (which == PRIO_PGRP)
+               && (who != 0)
+               && (who != process_group(current))
+              )
+          )
+          {
+            rsbac_pr_debug(aef, "calling ADF\n");
+            if(niceval < (current->static_prio - MAX_RT_PRIO - 20))
+              {
+                rsbac_target = T_SCD;
+                rsbac_target_id.scd = ST_priority;
+              }
+            else
+              {
+                rsbac_target = T_PROCESS;
+                rsbac_target_id.process = who;
+              }
+            rsbac_attribute_value.priority = niceval;
+            if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   A_priority,
+                                   rsbac_attribute_value))
+              {
+                return -EPERM;
+              }
+          }
+        #endif
+
 	read_lock(&tasklist_lock);
 	switch (which) {
 		case PRIO_PROCESS:
@@ -804,6 +851,12 @@
 {
 	char buffer[256];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!capable(CAP_SYS_BOOT))
 		return -EPERM;
@@ -822,6 +875,21 @@
 	if ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !pm_power_off)
 		cmd = LINUX_REBOOT_CMD_HALT;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.dummy = 0;
+	rsbac_attribute_value.reboot_cmd = cmd;
+	if (!rsbac_adf_request(R_SHUTDOWN,
+				current->pid,
+				T_NONE,
+				rsbac_target_id,
+				A_reboot_cmd,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	lock_kernel();
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
@@ -931,18 +999,65 @@
 		return retval;
 
 	if (rgid != (gid_t) -1) {
-		if ((old_rgid == rgid) ||
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+
+                rsbac_pr_debug(aef, "calling ADF\n");
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.long_dummy = 0;
+                rsbac_attribute_value.group = rgid;
+                #endif
+
+		if (((old_rgid == rgid) ||
 		    (current->egid==rgid) ||
 		    capable(CAP_SETGID))
+                    /* RSBAC */
+                    #ifdef CONFIG_RSBAC
+                    && rsbac_adf_request(R_CHANGE_GROUP,
+                                         current->pid,
+                                         T_PROCESS,
+                                         rsbac_target_id,
+                                         A_group,
+                                         rsbac_attribute_value)
+                    #endif
+                   )
 			new_rgid = rgid;
 		else
 			return -EPERM;
 	}
 	if (egid != (gid_t) -1) {
-		if ((old_rgid == egid) ||
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_DAC_GROUP
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+
+                rsbac_pr_debug(aef, "calling ADF\n");
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.long_dummy = 0;
+                rsbac_attribute_value.group = egid;
+                #endif
+
+		if (((old_rgid == egid) ||
 		    (current->egid == egid) ||
 		    (current->sgid == egid) ||
 		    capable(CAP_SETGID))
+                    #ifdef CONFIG_RSBAC_DAC_GROUP
+                    && rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+                                         current->pid,
+                                         T_PROCESS,
+                                         rsbac_target_id,
+                                         A_group,
+                                         rsbac_attribute_value)
+                    && rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                         current->pid,
+                                         T_PROCESS,
+                                         rsbac_target_id,
+                                         A_group,
+                                         rsbac_attribute_value)
+                    #endif
+                   )
 			new_egid = egid;
 		else
 			return -EPERM;
@@ -972,17 +1087,72 @@
 	int old_egid = current->egid;
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = security_task_setgid(gid, (gid_t)-1, (gid_t)-1, LSM_SETID_ID);
 	if (retval)
 		return retval;
 
-	if (capable(CAP_SETGID)) {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = current->pid;
+        rsbac_attribute_value.group = gid;
+        #endif
+
+	if ((capable(CAP_SETGID))
+            /* RSBAC */
+            #ifdef CONFIG_RSBAC
+            && rsbac_adf_request(R_CHANGE_GROUP,
+                                 current->pid,
+                                 T_PROCESS,
+                                 rsbac_target_id,
+                                 A_group,
+                                 rsbac_attribute_value)
+            #ifdef CONFIG_RSBAC_DAC_GROUP
+            && rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+                                 current->pid,
+                                 T_PROCESS,
+                                 rsbac_target_id,
+                                 A_group,
+                                 rsbac_attribute_value)
+            && rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                 current->pid,
+                                 T_PROCESS,
+                                 rsbac_target_id,
+                                 A_group,
+                                 rsbac_attribute_value)
+            #endif
+            #endif
+           )
+	{
 		if (old_egid != gid) {
 			current->mm->dumpable = suid_dumpable;
 			smp_wmb();
 		}
 		current->gid = current->egid = current->sgid = current->fsgid = gid;
-	} else if ((gid == current->gid) || (gid == current->sgid)) {
+	} else if (((gid == current->gid) || (gid == current->sgid))
+                 /* RSBAC */
+                 #ifdef CONFIG_RSBAC_DAC_GROUP
+                 && rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value)
+                 && rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value)
+                 #endif
+                )
+	{
 		if (old_egid != gid) {
 			current->mm->dumpable = suid_dumpable;
 			smp_wmb();
@@ -1042,10 +1212,58 @@
 	int old_ruid, old_euid, old_suid, new_ruid, new_euid;
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = security_task_setuid(ruid, euid, (uid_t)-1, LSM_SETID_RE);
 	if (retval)
 		return retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(ruid != (uid_t) -1)
+          {
+            rsbac_pr_debug(aef, "calling ADF\n");
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.long_dummy = 0;
+            rsbac_attribute_value.owner = ruid;
+            if(!rsbac_adf_request(R_CHANGE_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        if(euid != (uid_t) -1)
+          {
+            rsbac_pr_debug(aef, "calling ADF for euid\n");
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.long_dummy = 0;
+            rsbac_attribute_value.owner = euid;
+            if(!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+            if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+          }
+        #endif
+        #endif
+
 	new_ruid = old_ruid = current->uid;
 	new_euid = old_euid = current->euid;
 	old_suid = current->suid;
@@ -1083,6 +1301,59 @@
 	key_fsuid_changed(current);
 	proc_id_connector(current, PROC_EVENT_UID);
 
+        /* RSBAC: notify ADF of changed process owner */
+        #ifdef CONFIG_RSBAC
+        if(ruid != (uid_t) -1)
+	  {
+            rsbac_set_audit_uid(old_ruid);
+            rsbac_attribute_value.owner = current->uid;
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() returned error");
+              }
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        if(euid != (uid_t) -1)
+	  {
+            rsbac_attribute_value.owner = current->euid;
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() for euid returned error");
+              }
+            if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() for fsuid returned error");
+              }
+          }
+        #endif
+        #endif
+
 	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RE);
 }
 
@@ -1105,10 +1376,57 @@
 	int old_ruid, old_suid, new_ruid, new_suid;
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        if(!uid && rsbac_uid_faked())
+          return 0;
+        #endif
+
 	retval = security_task_setuid(uid, (uid_t)-1, (uid_t)-1, LSM_SETID_ID);
 	if (retval)
 		return retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = current->pid;
+        rsbac_attribute_value.long_dummy = 0;
+        rsbac_attribute_value.owner = uid;
+        if(!rsbac_adf_request(R_CHANGE_OWNER,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_owner,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        rsbac_pr_debug(aef, "calling ADF for euid\n");
+        if(!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_owner,
+                              rsbac_attribute_value))
+           return -EPERM;
+        rsbac_pr_debug(aef, "calling ADF for fsuid\n");
+        if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_owner,
+                              rsbac_attribute_value))
+           return -EPERM;
+        #endif
+        #endif
+
 	old_ruid = new_ruid = current->uid;
 	old_suid = current->suid;
 	new_suid = old_suid;
@@ -1130,6 +1448,52 @@
 	key_fsuid_changed(current);
 	proc_id_connector(current, PROC_EVENT_UID);
 
+        /* RSBAC: notify ADF of changed process owner */
+        #ifdef CONFIG_RSBAC
+        rsbac_set_audit_uid(old_ruid);
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_owner,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_setuid(): rsbac_adf_set_attr() returned error");
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_owner,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_setuid(): rsbac_adf_set_attr() for euid returned error");
+          }
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_owner,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_setuid(): rsbac_adf_set_attr() for fsuid returned error");
+          }
+        #endif
+        #endif
+
 	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_ID);
 }
 
@@ -1145,6 +1509,13 @@
 	int old_suid = current->suid;
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = security_task_setuid(ruid, euid, suid, LSM_SETID_RES);
 	if (retval)
 		return retval;
@@ -1160,6 +1531,49 @@
 		    (suid != current->euid) && (suid != current->suid))
 			return -EPERM;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(ruid != (uid_t) -1)
+          {
+            rsbac_pr_debug(aef, "calling ADF\n");
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.long_dummy = 0;
+            rsbac_attribute_value.owner = ruid;
+            if(!rsbac_adf_request(R_CHANGE_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        if(euid != (uid_t) -1)
+          {
+            rsbac_pr_debug(aef, "calling ADF for euid\n");
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.long_dummy = 0;
+            rsbac_attribute_value.owner = euid;
+            if(!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+            rsbac_pr_debug(aef, "calling ADF for fsuid\n");
+            if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+          }
+        #endif
+        #endif
+
 	if (ruid != (uid_t) -1) {
 		if (ruid != current->uid && set_user(ruid, euid != current->euid) < 0)
 			return -EAGAIN;
@@ -1178,6 +1592,59 @@
 	key_fsuid_changed(current);
 	proc_id_connector(current, PROC_EVENT_UID);
 
+        /* RSBAC: notify ADF of changed process owner */
+        #ifdef CONFIG_RSBAC
+        if(ruid != (uid_t) -1)
+	  {
+            rsbac_set_audit_uid(old_ruid);
+            rsbac_new_target_id.dummy = 0;
+            rsbac_attribute_value.owner = current->uid;
+            if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setresuid(): rsbac_adf_set_attr() returned error");
+              }
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        if(euid != (uid_t) -1)
+	  {
+            rsbac_new_target_id.dummy = 0;
+            rsbac_attribute_value.owner = current->euid;
+            if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() for euid returned error\n");
+              }
+            if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() for fsuid returned error\n");
+              }
+          }
+        #endif
+        #endif
+
 	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RES);
 }
 
@@ -1199,6 +1666,12 @@
 {
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = security_task_setgid(rgid, egid, sgid, LSM_SETID_RES);
 	if (retval)
 		return retval;
@@ -1214,7 +1687,46 @@
 		    (sgid != current->egid) && (sgid != current->sgid))
 			return -EPERM;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(rgid != (gid_t) -1)
+          {
+            rsbac_pr_debug(aef, "calling ADF\n");
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.group = rgid;
+            if(!rsbac_adf_request(R_CHANGE_GROUP,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_group,
+                                  rsbac_attribute_value))
+               return -EPERM;
+          }
+        #endif
+
 	if (egid != (gid_t) -1) {
+	        /* RSBAC */
+                #ifdef CONFIG_RSBAC_DAC_GROUP
+                rsbac_pr_debug(aef, "calling ADF\n");
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.group = egid;
+                if(!rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value))
+                  return -EPERM;
+                if(!rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value))
+                  return -EPERM;
+                #endif
+
 		if (egid != current->egid) {
 			current->mm->dumpable = suid_dumpable;
 			smp_wmb();
@@ -1254,10 +1766,31 @@
 {
 	int old_fsuid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	old_fsuid = current->fsuid;
 	if (security_task_setuid(uid, (uid_t)-1, (uid_t)-1, LSM_SETID_FS))
 		return old_fsuid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = current->pid;
+        rsbac_attribute_value.owner = uid;
+        if (!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_owner,
+                               rsbac_attribute_value))
+          return old_fsuid;
+        #endif
+
 	if (uid == current->uid || uid == current->euid ||
 	    uid == current->suid || uid == current->fsuid || 
 	    capable(CAP_SETUID)) {
@@ -1271,6 +1804,24 @@
 	key_fsuid_changed(current);
 	proc_id_connector(current, PROC_EVENT_UID);
 
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        rsbac_target_id.process = current->pid;
+        rsbac_new_target_id.dummy = 0;
+        rsbac_attribute_value.owner = uid;
+        if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_owner,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_setfsuid(): rsbac_adf_set_attr() returned error\n");
+          }
+        #endif
+
 	security_task_post_setuid(old_fsuid, (uid_t)-1, (uid_t)-1, LSM_SETID_FS);
 
 	return old_fsuid;
@@ -1283,10 +1834,30 @@
 {
 	int old_fsgid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_DAC_GROUP
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	old_fsgid = current->fsgid;
 	if (security_task_setgid(gid, (gid_t)-1, (gid_t)-1, LSM_SETID_FS))
 		return old_fsgid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_DAC_GROUP
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = current->pid;
+        rsbac_attribute_value.group = gid;
+        if (!rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_group,
+                               rsbac_attribute_value))
+          return old_fsgid;
+        #endif
+
 	if (gid == current->gid || gid == current->egid ||
 	    gid == current->sgid || gid == current->fsgid || 
 	    capable(CAP_SETGID)) {
@@ -1358,6 +1929,12 @@
 	struct task_struct *group_leader = current->group_leader;
 	int err = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!pid)
 		pid = group_leader->pid;
 	if (!pgid)
@@ -1365,6 +1942,22 @@
 	if (pgid < 0)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	/* From this point forward we keep holding onto the tasklist lock
 	 * so that our parent does not change from under us. -DaveM
 	 */
@@ -1432,12 +2025,35 @@
 		int retval;
 		struct task_struct *p;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+                #endif
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_pr_debug(aef, "calling ADF\n");
+                rsbac_target_id.process = pid;
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+
 		read_lock(&tasklist_lock);
 		p = find_task_by_pid(pid);
 
 		retval = -ESRCH;
 		if (p) {
 			retval = security_task_getpgid(p);
+
 			if (!retval)
 				retval = process_group(p);
 		}
@@ -1464,12 +2080,35 @@
 		int retval;
 		struct task_struct *p;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+                #endif
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_pr_debug(aef, "calling ADF\n");
+                rsbac_target_id.process = pid;
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+
 		read_lock(&tasklist_lock);
 		p = find_task_by_pid(pid);
 
 		retval = -ESRCH;
 		if (p) {
 			retval = security_task_getsid(p);
+
 			if (!retval)
 				retval = p->signal->session;
 		}
@@ -1726,6 +2365,13 @@
 	struct group_info *group_info;
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        int i;
+        #endif
+
 	if (!capable(CAP_SETGID))
 		return -EPERM;
 	if ((unsigned)gidsetsize > NGROUPS_MAX)
@@ -1740,6 +2386,29 @@
 		return retval;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(gidsetsize > 0)
+          {
+            rsbac_pr_debug(aef, "calling ADF\n");
+            rsbac_target_id.process = current->pid;
+            for(i=0; i < gidsetsize; i++)
+              {
+                rsbac_attribute_value.group = group_info->blocks[i / NGROUPS_PER_BLOCK][i];
+                if(!rsbac_adf_request(R_CHANGE_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value))
+                  {
+                    put_group_info(group_info);
+                    return -EPERM;
+                  }
+	      }
+          }
+        #endif
+
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
@@ -1789,10 +2458,33 @@
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+	
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_host_id;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&uts_sem);
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
@@ -1834,11 +2526,33 @@
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+	
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_net_id;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&uts_sem);
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
@@ -1893,6 +2607,12 @@
 	unsigned long it_prof_secs;
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
 	if (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
@@ -1910,6 +2630,22 @@
 	if (retval)
 		return retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_rlimit;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	task_lock(current->group_leader);
 	*old_rlim = new_rlim;
 	task_unlock(current->group_leader);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/sysctl.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/sysctl.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/sysctl.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/sysctl.c	2007-03-15 14:31:20.000000000 +0100
@@ -49,6 +49,8 @@
 #include <asm/uaccess.h>
 #include <asm/processor.h>
 
+#include <rsbac/hooks.h>
+
 extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                      void __user *buffer, size_t *lenp, loff_t *ppos);
 
@@ -1297,9 +1299,46 @@
 static inline int ctl_perm(ctl_table *table, int op)
 {
 	int error;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = security_sysctl(table, op);
 	if (error)
 		return error;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(op & 002) /* write access */
+          {
+            switch(table->ctl_name)
+              {
+                case KERN_NODENAME:
+                  rsbac_target_id.scd = ST_host_id;
+                  break;
+                case KERN_DOMAINNAME:
+                  rsbac_target_id.scd = ST_net_id;
+                  break;
+                default:
+                  rsbac_target_id.scd = ST_sysctl;
+              }
+            rsbac_attribute_value.dummy = 0;
+            rsbac_pr_debug(aef, "[sysctl() etc.]: calling ADF\n");
+            if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                  current->pid,
+                                  T_SCD,
+                                  rsbac_target_id,
+                                  A_none,
+                                  rsbac_attribute_value))
+              {
+                return -EPERM;
+              }
+          }
+        #endif
+
 	return test_perm(table->mode, op);
 }
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/time/ntp.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/time/ntp.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/time/ntp.c	2007-03-15 13:35:14.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/time/ntp.c	2007-03-15 14:31:19.000000000 +0100
@@ -14,6 +14,7 @@
 
 #include <asm/div64.h>
 #include <asm/timex.h>
+#include <rsbac/hooks.h>
 
 /*
  * Timekeeping variables
@@ -196,10 +197,29 @@
 	s64 freq_adj, temp64;
 	int result;
 
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* In order to modify anything, you gotta be super-user! */
 	if (txc->modes && !capable(CAP_SYS_TIME))
 		return -EPERM;
 
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_time_strucs;
+        rsbac_attribute_value.dummy = 0;
+        if (   txc->modes
+            && !rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                  current->pid,
+                                  T_SCD,
+                                  rsbac_target_id,
+                                  A_none,
+                                  rsbac_attribute_value))
+	  return -EPERM;
+        #endif
+
 	/* Now we validate the data before disabling interrupts */
 
 	if ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/time.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/time.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/time.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/time.c	2007-03-15 14:31:19.000000000 +0100
@@ -40,6 +40,8 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#include <rsbac/hooks.h>
+
 /* 
  * The timezone where the local system is located.  Used as a default by some
  * programs who obtain this value by using gettimeofday.
@@ -83,9 +85,31 @@
 	struct timespec tv;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (get_user(tv.tv_sec, tptr))
 		return -EFAULT;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_clock;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	tv.tv_nsec = 0;
 
 	err = security_settime(&tv, NULL);
@@ -155,6 +179,11 @@
 	static int firsttime = 1;
 	int error = 0;
 
+#ifdef CONFIG_RSBAC
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (tv && !timespec_valid(tv))
 		return -EINVAL;
 
@@ -162,6 +191,21 @@
 	if (error)
 		return error;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_settimeofday()]: calling ADF\n");
+	rsbac_target_id.scd = ST_clock;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (tz) {
 		/* SMP safe, global irq locking makes it work. */
 		sys_tz = *tz;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/timer.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/timer.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/timer.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/timer.c	2007-03-15 14:31:26.000000000 +0100
@@ -41,6 +41,8 @@
 #include <asm/timex.h>
 #include <asm/io.h>
 
+#include <rsbac/hooks.h>
+
 u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;
 
 EXPORT_SYMBOL(jiffies_64);
@@ -1122,14 +1124,22 @@
 
 asmlinkage long sys_getuid(void)
 {
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        return rsbac_fake_uid();
+        #else
 	/* Only we change this so SMP safe */
 	return current->uid;
+	#endif
 }
 
 asmlinkage long sys_geteuid(void)
 {
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        return rsbac_fake_euid();
+        #else
 	/* Only we change this so SMP safe */
 	return current->euid;
+	#endif
 }
 
 asmlinkage long sys_getgid(void)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/kernel/uid16.c ./linux-2.6.19.3-rsbac-1.3.2/kernel/uid16.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/kernel/uid16.c	2007-03-15 13:35:16.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/kernel/uid16.c	2007-03-15 14:31:21.000000000 +0100
@@ -18,6 +18,8 @@
 
 #include <asm/uaccess.h>
 
+#include <rsbac/hooks.h>
+
 asmlinkage long sys_chown16(const char __user * filename, old_uid_t user, old_gid_t group)
 {
 	long ret = sys_chown(filename, low2highuid(user), low2highgid(group));
@@ -211,12 +213,20 @@
 
 asmlinkage long sys_getuid16(void)
 {
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        return high2lowuid(rsbac_fake_uid());
+        #else
 	return high2lowuid(current->uid);
+	#endif
 }
 
 asmlinkage long sys_geteuid16(void)
 {
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        return high2lowuid(rsbac_fake_euid());
+        #else
 	return high2lowuid(current->euid);
+	#endif
 }
 
 asmlinkage long sys_getgid16(void)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/MAINTAINERS ./linux-2.6.19.3-rsbac-1.3.2/MAINTAINERS
--- rsbac_tmp_15032007/kernel-2.6/trunk/MAINTAINERS	2007-03-15 13:40:33.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/MAINTAINERS	2007-03-15 14:33:19.000000000 +0100
@@ -2538,6 +2538,13 @@
 RISCOM8 DRIVER
 S:	Orphan
 
+RSBAC
+P:	Amon Ott
+M:	ao@rsbac.org
+L:	rsbac@rsbac.org
+W:	http://www.rsbac.org
+S:	Maintained
+
 S3 SAVAGE FRAMEBUFFER DRIVER
 P:      Antonino Daplas
 M:      adaplas@pol.net
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/Makefile ./linux-2.6.19.3-rsbac-1.3.2/Makefile
--- rsbac_tmp_15032007/kernel-2.6/trunk/Makefile	2007-03-15 13:40:33.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/Makefile	2007-03-15 14:34:26.000000000 +0100
@@ -532,6 +532,13 @@
 export	INSTALL_PATH ?= /boot
 
 #
+
+# Add RSBAC version
+ifeq ($(CONFIG_RSBAC),y)
+EXTRAVERSION:=$(EXTRAVERSION)-rsbac
+core-y		+= rsbac/
+endif
+
 # INSTALL_MOD_PATH specifies a prefix to MODLIB for module directory
 # relocations required by build roots.  This is not defined in the
 # makefile but the argument can be passed to make if needed.
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/mm/mlock.c ./linux-2.6.19.3-rsbac-1.3.2/mm/mlock.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/mm/mlock.c	2007-03-15 13:37:36.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/mm/mlock.c	2007-03-15 14:33:19.000000000 +0100
@@ -9,8 +9,9 @@
 #include <linux/mman.h>
 #include <linux/mm.h>
 #include <linux/mempolicy.h>
+#include <linux/security.h>
 #include <linux/syscalls.h>
-
+#include <rsbac/hooks.h>
 
 static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
 	unsigned long start, unsigned long end, unsigned int newflags)
@@ -127,9 +128,31 @@
 	unsigned long lock_limit;
 	int error = -ENOMEM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!can_do_mlock())
 		return -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.scd = ST_mlock;
+        rsbac_attribute_value.dummy = 0;
+        rsbac_pr_debug(aef, "calling ADF\n");
+        if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&current->mm->mmap_sem);
 	len = PAGE_ALIGN(len + (start & ~PAGE_MASK));
 	start &= PAGE_MASK;
@@ -189,6 +212,28 @@
 	unsigned long lock_limit;
 	int ret = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.scd = ST_mlock;
+        rsbac_attribute_value.dummy = 0;
+        rsbac_pr_debug(aef, "calling ADF\n");
+        if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	if (!flags || (flags & ~(MCL_CURRENT | MCL_FUTURE)))
 		goto out;
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/mm/mmap.c ./linux-2.6.19.3-rsbac-1.3.2/mm/mmap.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/mm/mmap.c	2007-03-15 13:37:36.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/mm/mmap.c	2007-03-15 14:33:19.000000000 +0100
@@ -29,6 +29,7 @@
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
 #include <asm/tlb.h>
+#include <rsbac/hooks.h>
 
 #ifndef arch_mmap_check
 #define arch_mmap_check(addr, len, flags)	(0)
@@ -900,6 +901,13 @@
 	int accountable = 1;
 	unsigned long charged = 0, reqprot = prot;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/*
 	 * Does the application expect PROT_READ to imply PROT_EXEC?
 	 *
@@ -1024,6 +1032,38 @@
 	if (error)
 		return error;
 		
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(prot & PROT_EXEC)
+          {
+            rsbac_pr_debug(aef, "[do_mmap() [sys_mmap()]]: calling ADF\n");
+            if(file)
+              {
+                rsbac_target = T_FILE;
+                rsbac_target_id.file.device = file->f_dentry->d_inode->i_sb->s_dev;
+                rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+                rsbac_target_id.file.dentry_p = file->f_dentry;
+              }
+            else
+              {
+                rsbac_target = T_NONE;
+                rsbac_target_id.dummy = 0;
+              }
+            rsbac_attribute_value.prot_bits = prot;
+            if (!rsbac_adf_request(R_MAP_EXEC,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   A_prot_bits,
+                                   rsbac_attribute_value))
+              {
+                rsbac_pr_debug(aef, "[do_mmap() [sys_mmap()]]: request not granted, my PID: %i\n",
+			       current->pid);
+                return -EPERM;
+              }
+          }
+        #endif
+
 	/* Clear old maps */
 	error = -ENOMEM;
 munmap_back:
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/mm/mprotect.c ./linux-2.6.19.3-rsbac-1.3.2/mm/mprotect.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/mm/mprotect.c	2007-03-15 13:37:36.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/mm/mprotect.c	2007-03-15 14:33:19.000000000 +0100
@@ -25,6 +25,7 @@
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
+#include <rsbac/hooks.h>
 
 static void change_pte_range(struct mm_struct *mm, pmd_t *pmd,
 		unsigned long addr, unsigned long end, pgprot_t newprot,
@@ -221,6 +222,15 @@
 	struct vm_area_struct *vma, *prev;
 	int error = -EINVAL;
 	const int grows = prot & (PROT_GROWSDOWN|PROT_GROWSUP);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        int need_notify = FALSE;
+        #endif
+
 	prot &= ~(PROT_GROWSDOWN|PROT_GROWSUP);
 	if (grows == (PROT_GROWSDOWN|PROT_GROWSUP)) /* can't be both */
 		return -EINVAL;
@@ -289,6 +299,39 @@
 		if (error)
 			goto out;
 
+#ifdef CONFIG_RSBAC
+		if(   (prot & PROT_EXEC)
+		   && !(vma->vm_flags & PROT_EXEC)
+		  )
+		{
+			rsbac_pr_debug(aef, "calling ADF\n");
+			if(vma->vm_file) {
+		                rsbac_target = T_FILE;
+				rsbac_target_id.file.device = vma->vm_file->f_dentry->d_inode->i_sb->s_dev;
+				rsbac_target_id.file.inode = vma->vm_file->f_dentry->d_inode->i_ino;
+				rsbac_target_id.file.dentry_p = vma->vm_file->f_dentry;
+			}
+			else {
+				rsbac_target = T_NONE;
+				rsbac_target_id.dummy = 0;
+			}
+			rsbac_attribute_value.prot_bits = prot;
+			if(!rsbac_adf_request(R_MAP_EXEC,
+						  current->pid,
+						  rsbac_target,
+						  rsbac_target_id,
+						  A_prot_bits,
+						  rsbac_attribute_value)) 
+			{
+				rsbac_pr_debug(aef, "request NOT_GRANTED\n");
+				error = -EPERM;
+				goto out;
+			}
+			else
+			  need_notify = TRUE;
+		}
+#endif
+
 		tmp = vma->vm_end;
 		if (tmp > end)
 			tmp = end;
@@ -310,5 +353,29 @@
 	}
 out:
 	up_write(&current->mm->mmap_sem);
+
+        /* RSBAC: notify ADF of mapped segment */
+        #ifdef CONFIG_RSBAC
+        if(need_notify && !error)
+          {
+            union rsbac_target_id_t rsbac_new_target_id;
+
+            rsbac_pr_debug(aef, "calling ADF_set_attr\n");
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_MAP_EXEC,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_mprotect: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 	return error;
 }
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/mm/swapfile.c ./linux-2.6.19.3-rsbac-1.3.2/mm/swapfile.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/mm/swapfile.c	2007-03-15 13:37:36.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/mm/swapfile.c	2007-03-15 14:33:19.000000000 +0100
@@ -31,6 +31,7 @@
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 #include <linux/swapops.h>
+#include <rsbac/hooks.h>
 
 DEFINE_SPINLOCK(swap_lock);
 unsigned int nr_swapfiles;
@@ -1146,9 +1147,32 @@
 	int i, type, prev;
 	int err;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF\n");
+        rsbac_target_id.scd = ST_swap;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	pathname = getname(specialfile);
 	err = PTR_ERR(pathname);
 	if (IS_ERR(pathname))
@@ -1160,6 +1184,44 @@
 	if (IS_ERR(victim))
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF for DEV / FILE\n");
+        if(S_ISBLK(victim->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(victim->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(victim->f_dentry->d_inode->i_rdev);
+          }
+        else
+        if(S_ISREG(victim->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.file.device = victim->f_dentry->d_sb->s_dev;
+            rsbac_target_id.file.inode  = victim->f_dentry->d_inode->i_ino;
+            rsbac_target_id.file.dentry_p = victim->f_dentry;
+          }
+        else
+          {
+            rsbac_target = T_NONE;
+            rsbac_target_id.dummy = 0;
+          }
+        rsbac_attribute_value.dummy = 0;
+        if(   (rsbac_target != T_NONE)
+           && !rsbac_adf_request(R_REMOVE_FROM_KERNEL,
+                                 current->pid,
+                                 rsbac_target,
+                                 rsbac_target_id,
+                                 A_none,
+                                 rsbac_attribute_value)
+	  )
+          {
+            err = -EPERM;
+            goto out_dput;
+          }
+        #endif
+
 	mapping = victim->f_mapping;
 	prev = -1;
 	spin_lock(&swap_lock);
@@ -1384,8 +1446,28 @@
 	struct inode *inode = NULL;
 	int did_down = 0;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
+
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_swap;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+		return -EPERM;
+#endif
+
 	spin_lock(&swap_lock);
 	p = swap_info;
 	for (type = 0 ; type < nr_swapfiles ; type++,p++)
@@ -1442,6 +1524,44 @@
 			goto bad_swap;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "calling ADF for DEV / FILE\n");
+        if(S_ISBLK(inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+          }
+        else
+        if(S_ISREG(inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.file.device = swap_file->f_dentry->d_sb->s_dev;
+            rsbac_target_id.file.inode  = inode->i_ino;
+            rsbac_target_id.file.dentry_p = swap_file->f_dentry;
+          }
+        else
+          {
+            rsbac_target = T_NONE;
+            rsbac_target_id.dummy = 0;
+          }
+        rsbac_attribute_value.dummy = 0;
+        if(   (rsbac_target != T_NONE)
+           && !rsbac_adf_request(R_ADD_TO_KERNEL,
+                                 current->pid,
+                                 rsbac_target,
+                                 rsbac_target_id,
+                                 A_none,
+                                 rsbac_attribute_value)
+	  )
+          {
+            error = -EPERM;
+            goto bad_swap;
+          }
+        #endif
+
 	error = -EINVAL;
 	if (S_ISBLK(inode->i_mode)) {
 		bdev = I_BDEV(inode);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/bridge/br_if.c ./linux-2.6.19.3-rsbac-1.3.2/net/bridge/br_if.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/bridge/br_if.c	2007-03-15 13:36:27.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/bridge/br_if.c	2007-03-15 14:32:31.000000000 +0100
@@ -23,6 +23,10 @@
 #include <linux/if_ether.h>
 #include <net/sock.h>
 
+#include <linux/security.h>
+
+#include <rsbac/hooks.h>
+
 #include "br_private.h"
 
 /*
@@ -407,6 +411,12 @@
 	struct net_bridge_port *p;
 	int err = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (dev->flags & IFF_LOOPBACK || dev->type != ARPHRD_ETHER)
 		return -EINVAL;
 
@@ -416,6 +426,34 @@
 	if (dev->br_port != NULL)
 		return -EBUSY;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+		char * p = rsbac_target_id.netdev;
+		while(*p) {
+			if(*p == ':') {
+				*p=' ';
+				break;
+			}
+			p++;
+		}
+	}
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+			current->pid,
+			T_NETDEV,
+			rsbac_target_id,
+			A_none,
+			rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	p = new_nbp(br, dev);
 	if (IS_ERR(p))
 		return PTR_ERR(p);
@@ -461,9 +499,45 @@
 {
 	struct net_bridge_port *p = dev->br_port;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!p || p->br != br) 
 		return -EINVAL;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+		char * p = rsbac_target_id.netdev;
+		while(*p)
+		{
+			if(*p == ':')
+			{
+				*p=' ';
+				break;
+			}
+			p++;
+		}
+	}
+#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	del_nbp(p);
 
 	spin_lock_bh(&br->lock);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/core/dev.c ./linux-2.6.19.3-rsbac-1.3.2/net/core/dev.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/core/dev.c	2007-03-15 13:36:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/core/dev.c	2007-03-15 14:32:24.000000000 +0100
@@ -118,6 +118,8 @@
 #include <linux/err.h>
 #include <linux/ctype.h>
 
+#include <rsbac/hooks.h>
+
 /*
  *	The list of packet types we will receive (as opposed to discard)
  *	and the routines to invoke.
@@ -2649,6 +2651,12 @@
 	int ret;
 	char *colon;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* One special case: SIOCGIFCONF takes ifconf argument
 	   and requires shared lock, because it sleeps writing
 	   to user space.
@@ -2668,10 +2676,20 @@
 
 	ifr.ifr_name[IFNAMSIZ-1] = 0;
 
+	#ifdef CONFIG_RSBAC_NET_DEV_VIRT
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#endif
+
 	colon = strchr(ifr.ifr_name, ':');
 	if (colon)
 		*colon = 0;
 
+	#if defined(CONFIG_RSBAC_NET_DEV) && !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#endif
+
 	/*
 	 *	See which interface the caller is talking about.
 	 */
@@ -2691,6 +2709,21 @@
 		case SIOCGIFMAP:
 		case SIOCGIFINDEX:
 		case SIOCGIFTXQLEN:
+			/* RSBAC */
+			#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_GET_STATUS_DATA,
+						current->pid,
+						T_NETDEV,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			  {
+			    return -EPERM;
+			  }
+			#endif
+
 			dev_load(ifr.ifr_name);
 			read_lock(&dev_base_lock);
 			ret = dev_ifsioc(&ifr, cmd);
@@ -2729,6 +2762,22 @@
 		case SIOCSIFNAME:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+
+			/* RSBAC */
+			#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+						current->pid,
+						T_NETDEV,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			  {
+			    return -EPERM;
+			  }
+			#endif
+
 			dev_load(ifr.ifr_name);
 			rtnl_lock();
 			ret = dev_ifsioc(&ifr, cmd);
@@ -2767,6 +2816,20 @@
 		case SIOCBRDELIF:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+
+#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_pr_debug(aef, "calling ADF\n");
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+			{
+				return -EPERM;
+			}
+#endif
 			/* fall through */
 		case SIOCBONDSLAVEINFOQUERY:
 		case SIOCBONDINFOQUERY:
@@ -2811,6 +2874,21 @@
 				    || cmd == SIOCGIWENCODEEXT) {
 					if (!capable(CAP_NET_ADMIN))
 						return -EPERM;
+
+					/* RSBAC */
+					#ifdef CONFIG_RSBAC_NET_DEV
+					rsbac_pr_debug(aef, "calling ADF\n");
+					rsbac_attribute_value.dummy = 0;
+					if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					    current->pid,
+					    T_NETDEV,
+					    rsbac_target_id,
+					    A_none,
+					    rsbac_attribute_value))
+					  {
+					    return -EPERM;
+					  }
+					#endif
 				}
 				dev_load(ifr.ifr_name);
 				rtnl_lock();
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/core/fib_rules.c ./linux-2.6.19.3-rsbac-1.3.2/net/core/fib_rules.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/core/fib_rules.c	2007-03-15 13:36:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/core/fib_rules.c	2007-03-15 14:32:24.000000000 +0100
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <net/fib_rules.h>
+#include <rsbac/hooks.h>
 
 static LIST_HEAD(rules_ops);
 static DEFINE_SPINLOCK(rules_mod_lock);
@@ -146,6 +147,10 @@
 	struct fib_rule *rule, *r, *last = NULL;
 	struct nlattr *tb[FRA_MAX+1];
 	int err = -EINVAL;
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh)))
 		goto errout;
@@ -166,6 +171,24 @@
 		goto errout;
 	}
 
+#ifdef CONFIG_RSBAC_NET
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "fib_nl_newrule(): calling ADF\n");
+#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (tb[FRA_PRIORITY])
 		rule->pref = nla_get_u32(tb[FRA_PRIORITY]);
 
@@ -221,6 +244,10 @@
 	struct fib_rule *rule;
 	struct nlattr *tb[FRA_MAX+1];
 	int err = -EINVAL;
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
 
 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh)))
 		goto errout;
@@ -235,6 +262,24 @@
 	if (err < 0)
 		goto errout;
 
+#ifdef CONFIG_RSBAC_NET
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "fib_nl_delrule(): calling ADF\n");
+#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	list_for_each_entry(rule, ops->rules_list, list) {
 		if (frh->action && (frh->action != rule->action))
 			continue;
@@ -279,6 +324,28 @@
 {
 	struct nlmsghdr *nlh;
 	struct fib_rule_hdr *frh;
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_NET
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "fib_nl_fill_rule(): calling ADF\n");
+#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+	#endif
 
 	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*frh), flags);
 	if (nlh == NULL)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/arp.c ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/arp.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/arp.c	2007-03-15 13:36:26.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/arp.c	2007-03-15 14:32:29.000000000 +0100
@@ -100,6 +100,7 @@
 #include <linux/net.h>
 #include <linux/rcupdate.h>
 #include <linux/jhash.h>
+#include <linux/security.h>
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
@@ -127,6 +128,8 @@
 
 #include <linux/netfilter_arp.h>
 
+#include <rsbac/hooks.h>
+
 /*
  *	Interface to generic neighbour cache.
  */
@@ -1139,15 +1142,29 @@
 	struct arpreq r;
 	struct net_device *dev = NULL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        enum  rsbac_adf_request_t     rsbac_request = R_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	switch (cmd) {
 		case SIOCDARP:
 		case SIOCSARP:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+			#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_request = R_MODIFY_SYSTEM_DATA;
+			#endif
 		case SIOCGARP:
 			err = copy_from_user(&r, arg, sizeof(struct arpreq));
 			if (err)
 				return -EFAULT;
+			#ifdef CONFIG_RSBAC_NET_DEV
+			if(rsbac_request == R_NONE)
+				rsbac_request = R_GET_STATUS_DATA;
+			#endif
 			break;
 		default:
 			return -EINVAL;
@@ -1174,6 +1191,24 @@
 		err = -EINVAL;
 		if ((r.arp_flags & ATF_COM) && r.arp_ha.sa_family != dev->type)
 			goto out;
+
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_pr_debug(aef, "calling ADF\n");
+		strncpy(rsbac_target_id.netdev, r.arp_dev, RSBAC_IFNAMSIZ);
+		rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(rsbac_request,
+				    current->pid,
+				    T_NETDEV,
+				    rsbac_target_id,
+				    A_none,
+				    rsbac_attribute_value))
+		  {
+		    err = -EPERM;
+		    goto out;
+		  }
+		#endif
 	} else if (cmd == SIOCGARP) {
 		err = -ENODEV;
 		goto out;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/devinet.c ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/devinet.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/devinet.c	2007-03-15 13:36:25.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/devinet.c	2007-03-15 14:32:28.000000000 +0100
@@ -54,6 +54,7 @@
 #include <linux/notifier.h>
 #include <linux/inetdevice.h>
 #include <linux/igmp.h>
+#include <linux/security.h>
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
@@ -65,6 +66,8 @@
 #include <net/ip_fib.h>
 #include <net/netlink.h>
 
+#include <rsbac/hooks.h>
+
 struct ipv4_devconf ipv4_devconf = {
 	.accept_redirects = 1,
 	.send_redirects =  1,
@@ -450,6 +453,12 @@
 	struct in_ifaddr *ifa, **ifap;
 	int err = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	ASSERT_RTNL();
 
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);
@@ -463,6 +472,39 @@
 		goto errout;
 	}
 
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, in_dev->dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+	  char * p = rsbac_target_id.netdev;
+
+	  while(*p)
+	    {
+	      if(*p == ':')
+	        {
+	          *p=' ';
+	          break;
+	        }
+	      p++;
+	    }
+	}
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_BIND,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value)) {
+		__in_dev_put(in_dev);
+		return -EPERM;
+	}
+	#endif
+
 	__in_dev_put(in_dev);
 
 	for (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;
@@ -497,6 +539,12 @@
 	struct in_device *in_dev;
 	int err = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);
 	if (err < 0)
 		goto errout;
@@ -520,6 +568,38 @@
 		}
 	}
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, in_dev->dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+	  char * p = rsbac_target_id.netdev;
+		  while(*p)
+	    {
+	      if(*p == ':')
+	        {
+	          *p=' ';
+	          break;
+	        }
+	      p++;
+	    }
+	}
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_BIND,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    err = -EPERM;
+	    goto errout;
+	  }
+	#endif
+
 	ifa = inet_alloc_ifa();
 	if (ifa == NULL) {
 		/*
@@ -612,6 +692,13 @@
 	int ret = -EFAULT;
 	int tryaddrmatch = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        enum  rsbac_adf_request_t     rsbac_request = R_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/*
 	 *	Fetch the caller's info block into kernel space
 	 */
@@ -620,6 +707,11 @@
 		goto out;
 	ifr.ifr_name[IFNAMSIZ - 1] = 0;
 
+	#ifdef CONFIG_RSBAC_NET_DEV_VIRT
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#endif
+
 	/* save original address for comparison */
 	memcpy(&sin_orig, sin, sizeof(*sin));
 
@@ -627,6 +719,11 @@
 	if (colon)
 		*colon = 0;
 
+	#if defined(CONFIG_RSBAC_NET_DEV) && !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#endif
+
 #ifdef CONFIG_KMOD
 	dev_load(ifr.ifr_name);
 #endif
@@ -643,12 +740,19 @@
 		tryaddrmatch = (sin_orig.sin_family == AF_INET);
 		memset(sin, 0, sizeof(*sin));
 		sin->sin_family = AF_INET;
+
+		#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_GET_STATUS_DATA;
+		#endif
 		break;
 
 	case SIOCSIFFLAGS:
 		ret = -EACCES;
 		if (!capable(CAP_NET_ADMIN))
 			goto out;
+		#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_MODIFY_SYSTEM_DATA;
+		#endif
 		break;
 	case SIOCSIFADDR:	/* Set interface address (and family) */
 	case SIOCSIFBRDADDR:	/* Set the broadcast address */
@@ -660,6 +764,9 @@
 		ret = -EINVAL;
 		if (sin->sin_family != AF_INET)
 			goto out;
+		#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_BIND;
+		#endif
 		break;
 	default:
 		ret = -EINVAL;
@@ -672,6 +779,22 @@
 	if ((dev = __dev_get_by_name(ifr.ifr_name)) == NULL)
 		goto done;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    ret = -EPERM;
+	    goto done;
+	  }
+	#endif
+
 	if (colon)
 		*colon = ':';
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/fib_frontend.c ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/fib_frontend.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/fib_frontend.c	2007-03-15 13:36:25.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/fib_frontend.c	2007-03-15 14:32:28.000000000 +0100
@@ -48,6 +48,8 @@
 #include <net/arp.h>
 #include <net/ip_fib.h>
 
+#include <rsbac/hooks.h>
+
 #define FFprint(a...) printk(KERN_DEBUG a)
 
 #ifndef CONFIG_IP_MULTIPLE_TABLES
@@ -407,6 +409,12 @@
 	struct rtentry rt;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	switch (cmd) {
 	case SIOCADDRT:		/* Add a route */
 	case SIOCDELRT:		/* Delete a route */
@@ -416,6 +424,22 @@
 		if (copy_from_user(&rt, arg, sizeof(rt)))
 			return -EFAULT;
 
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.scd = ST_network;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					current->pid,
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		  {
+		    return -EPERM;
+		  }
+		#endif
+
 		rtnl_lock();
 		err = rtentry_to_fib_config(cmd, &rt, &cfg);
 		if (err == 0) {
@@ -542,10 +566,32 @@
 	struct fib_table *tb;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	err = rtm_to_fib_config(skb, nlh, &cfg);
 	if (err < 0)
 		goto errout;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	tb = fib_get_table(cfg.fc_table);
 	if (tb == NULL) {
 		err = -ESRCH;
@@ -563,10 +609,32 @@
 	struct fib_table *tb;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	err = rtm_to_fib_config(skb, nlh, &cfg);
 	if (err < 0)
 		goto errout;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	tb = fib_new_table(cfg.fc_table);
 	if (tb == NULL) {
 		err = -ENOBUFS;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/inet_diag.c ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/inet_diag.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/inet_diag.c	2007-03-15 13:36:26.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/inet_diag.c	2007-03-15 14:32:29.000000000 +0100
@@ -17,6 +17,7 @@
 #include <linux/random.h>
 #include <linux/cache.h>
 #include <linux/init.h>
+#include <linux/security.h>
 #include <linux/time.h>
 
 #include <net/icmp.h>
@@ -33,6 +34,8 @@
 
 #include <linux/inet_diag.h>
 
+#include <rsbac/hooks.h>
+
 static const struct inet_diag_handler **inet_diag_table;
 
 struct inet_diag_entry {
@@ -804,6 +807,12 @@
 
 static inline int inet_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+
 	if (!(nlh->nlmsg_flags&NLM_F_REQUEST))
 		return 0;
 
@@ -816,6 +825,19 @@
 	if (NLMSG_LENGTH(sizeof(struct inet_diag_req)) > skb->len)
 		goto err_inval;
 
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	    return -EPERM;
+#endif
+
 	if (nlh->nlmsg_flags&NLM_F_DUMP) {
 		if (nlh->nlmsg_len >
 		    (4 + NLMSG_SPACE(sizeof(struct inet_diag_req)))) {
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/ipmr.c ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/ipmr.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/ipmr.c	2007-03-15 13:36:25.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/ipmr.c	2007-03-15 14:32:28.000000000 +0100
@@ -49,6 +49,7 @@
 #include <linux/seq_file.h>
 #include <linux/mroute.h>
 #include <linux/init.h>
+#include <linux/security.h>
 #include <linux/if_ether.h>
 #include <net/ip.h>
 #include <net/protocol.h>
@@ -64,6 +65,8 @@
 #include <net/ipip.h>
 #include <net/checksum.h>
 
+#include <rsbac/hooks.h>
+
 #if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
 #define CONFIG_IP_PIMSM	1
 #endif
@@ -863,8 +866,30 @@
 	
 	if(optname!=MRT_INIT)
 	{
+	        /* RSBAC */
+        	#ifdef CONFIG_RSBAC_NET_DEV
+	        union rsbac_target_id_t       rsbac_target_id;
+        	union rsbac_attribute_value_t rsbac_attribute_value;
+	        #endif
+
 		if(sk!=mroute_socket && !capable(CAP_NET_ADMIN))
 			return -EACCES;
+
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_pr_debug(aef, "calling ADF\n");
+		rsbac_target_id.scd = ST_network;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		  {
+		    return -EPERM;
+		  }
+		#endif
 	}
 
 	switch(optname)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/netfilter/ip_tables.c ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/netfilter/ip_tables.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/netfilter/ip_tables.c	2007-03-15 13:36:24.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/netfilter/ip_tables.c	2007-03-15 14:32:28.000000000 +0100
@@ -29,10 +29,13 @@
 #include <linux/proc_fs.h>
 #include <linux/err.h>
 #include <linux/cpumask.h>
+#include <linux/security.h>
 
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 
+#include <rsbac/hooks.h>
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("IPv4 packet filter");
@@ -1077,6 +1080,24 @@
 	struct ipt_get_entries get;
 	struct ipt_table *t;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
+
 	if (*len < sizeof(get)) {
 		duprintf("get_entries: %u < %d\n", *len,
 				(unsigned int)sizeof(get));
@@ -1784,9 +1805,30 @@
 {
 	int ret;
 
+#ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
+	/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+#endif
+
 	switch (cmd) {
 	case IPT_SO_SET_REPLACE:
 		ret = compat_do_replace(user, len);
@@ -1888,6 +1930,25 @@
 	struct compat_ipt_get_entries get;
 	struct ipt_table *t;
 
+#ifdef CONFIG_RSBAC_NET
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		return -EPERM;
+	}
+#endif
 
 	if (*len < sizeof(get)) {
 		duprintf("compat_get_entries: %u < %u\n",
@@ -1961,9 +2022,29 @@
 {
 	int ret;
 
+#ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
+#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+#endif
+
 	switch (cmd) {
 	case IPT_SO_SET_REPLACE:
 		ret = do_replace(user, len);
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/route.c ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/route.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/ipv4/route.c	2007-03-15 13:36:25.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/ipv4/route.c	2007-03-15 14:32:28.000000000 +0100
@@ -93,6 +93,7 @@
 #include <linux/jhash.h>
 #include <linux/rcupdate.h>
 #include <linux/times.h>
+#include <linux/security.h>
 #include <net/protocol.h>
 #include <net/ip.h>
 #include <net/route.h>
@@ -109,6 +110,8 @@
 #include <linux/sysctl.h>
 #endif
 
+#include <rsbac/hooks.h>
+
 #define RT_FL_TOS(oldflp) \
     ((u32)(oldflp->fl4_tos & (IPTOS_RT_MASK | RTO_ONLINK)))
 
@@ -2753,6 +2756,28 @@
 	int err;
 	struct sk_buff *skb;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy);
 	if (err < 0)
 		goto errout;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/sched/cls_api.c ./linux-2.6.19.3-rsbac-1.3.2/net/sched/cls_api.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/sched/cls_api.c	2007-03-15 13:36:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/sched/cls_api.c	2007-03-15 14:32:23.000000000 +0100
@@ -33,10 +33,13 @@
 #include <linux/rtnetlink.h>
 #include <linux/init.h>
 #include <linux/kmod.h>
+#include <linux/security.h>
 #include <net/sock.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
 
+#include <rsbac/hooks.h>
+
 #if 0 /* control */
 #define DPRINTK(format,args...) printk(KERN_DEBUG format,##args)
 #else
@@ -145,6 +148,33 @@
 	unsigned long fh;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if(n->nlmsg_type == RTM_GETTFILTER)
+	  rsbac_request = R_GET_STATUS_DATA;
+	else
+	  rsbac_request = R_MODIFY_SYSTEM_DATA;
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 replay:
 	tca = arg;
 	t = NLMSG_DATA(n);
@@ -396,6 +426,28 @@
 	struct Qdisc_class_ops *cops;
 	struct tcf_dump_args arg;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	rsbac_pr_debug(aef, "calling ADF\n");
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if (cb->nlh->nlmsg_len < NLMSG_LENGTH(sizeof(*tcm)))
 		return skb->len;
 	if ((dev = dev_get_by_index(tcm->tcm_ifindex)) == NULL)
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/sched/sch_api.c ./linux-2.6.19.3-rsbac-1.3.2/net/sched/sch_api.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/sched/sch_api.c	2007-03-15 13:36:20.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/sched/sch_api.c	2007-03-15 14:32:23.000000000 +0100
@@ -35,6 +35,7 @@
 #include <linux/kmod.h>
 #include <linux/list.h>
 #include <linux/bitops.h>
+#include <linux/security.h>
 
 #include <net/sock.h>
 #include <net/pkt_sched.h>
@@ -43,6 +44,8 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#include <rsbac/hooks.h>
+
 static int qdisc_notify(struct sk_buff *oskb, struct nlmsghdr *n, u32 clid,
 			struct Qdisc *old, struct Qdisc *new);
 static int tclass_notify(struct sk_buff *oskb, struct nlmsghdr *n,
@@ -559,9 +562,45 @@
 	struct Qdisc *p = NULL;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	if(n->nlmsg_type == RTM_DELQDISC)
+	  rsbac_request = R_MODIFY_SYSTEM_DATA;
+	else
+	  rsbac_request = R_GET_STATUS_DATA;
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if(rsbac_colon)
+	  *rsbac_colon = 0;
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if (clid) {
 		if (clid != TC_H_ROOT) {
 			if (TC_H_MAJ(clid) != TC_H_MAJ(TC_H_INGRESS)) {
@@ -619,6 +658,15 @@
 	struct Qdisc *q, *p;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 replay:
 	/* Reinit, just in case something touches this. */
 	tcm = NLMSG_DATA(n);
@@ -629,6 +677,28 @@
 	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "tc_modify_qdisc(): calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if(rsbac_colon)
+	  *rsbac_colon = 0;
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if (clid) {
 		if (clid != TC_H_ROOT) {
 			if (clid != TC_H_INGRESS) {
@@ -829,6 +899,14 @@
 	struct net_device *dev;
 	struct Qdisc *q;
 
+#ifdef CONFIG_RSBAC_NET_DEV
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+#endif
+#endif
+
 	s_idx = cb->args[0];
 	s_q_idx = q_idx = cb->args[1];
 	read_lock(&dev_base_lock);
@@ -837,6 +915,28 @@
 			continue;
 		if (idx > s_idx)
 			s_q_idx = 0;
+
+#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_pr_debug(aef, "tc_dump_qdisc(): calling ADF\n");
+		strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+		rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+		rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+		if(rsbac_colon)
+			*rsbac_colon = 0;
+#endif
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					T_NETDEV,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			continue;
+		}
+#endif
+
 		read_lock(&qdisc_tree_lock);
 		q_idx = 0;
 		list_for_each_entry(q, &dev->qdisc_list, list) {
@@ -885,9 +985,40 @@
 	u32 qid = TC_H_MAJ(clid);
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "tc_ctl_tclass(): calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if(rsbac_colon)
+	  *rsbac_colon = 0;
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	/*
 	   parent == TC_H_UNSPEC - unspecified parent.
 	   parent == TC_H_ROOT   - class is root, which has no parent.
@@ -1066,11 +1197,42 @@
 	struct tcmsg *tcm = (struct tcmsg*)NLMSG_DATA(cb->nlh);
 	struct qdisc_dump_args arg;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 	if (cb->nlh->nlmsg_len < NLMSG_LENGTH(sizeof(*tcm)))
 		return 0;
 	if ((dev = dev_get_by_index(tcm->tcm_ifindex)) == NULL)
 		return 0;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	rsbac_pr_debug(aef, "calling ADF\n");
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if(rsbac_colon)
+	  *rsbac_colon = 0;
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	s_t = cb->args[0];
 	t = 0;
 
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/socket.c ./linux-2.6.19.3-rsbac-1.3.2/net/socket.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/socket.c	2007-03-15 13:36:30.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/socket.c	2007-03-15 14:32:33.000000000 +0100
@@ -86,6 +86,12 @@
 #include <linux/audit.h>
 #include <linux/wireless.h>
 
+#ifdef CONFIG_RSBAC
+#include <net/af_unix.h>
+#include <net/scm.h>
+#include <rsbac/hooks.h>
+#endif
+
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
@@ -542,6 +548,114 @@
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
 	int err;
 
+        /* RSBAC  */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute = A_none;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #if defined(CONFIG_RSBAC)
+        rsbac_pr_debug(aef, "[sys_send(), sys_sendto(), sys_sendmsg()]: calling ADF\n");
+        if(   sock->ops
+           && (sock->ops->family == AF_UNIX)
+          )
+          {
+            if(sock->sk) {
+              if(unix_sk(unix_sk(sock->sk)->peer)) {
+                if(   unix_sk(unix_sk(sock->sk)->peer)->dentry
+                   && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+                  ) {
+	          rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = unix_sk(unix_sk(sock->sk)->peer)->dentry;
+                } else {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+                  if(   unix_sk(unix_sk(sock->sk)->peer)->dentry
+                     && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry->d_inode
+                    )
+			rsbac_target_id.ipc.id.id_nr = SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry->d_inode->i_ino;
+		  else
+		    if(sock->file
+		       && sock->file->f_dentry
+		       && sock->file->f_dentry->d_inode
+		      )
+	              rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+	            else
+	              rsbac_target_id.ipc.id.id_nr = 0;
+                }
+	      } else {
+                if(   unix_sk(sock->sk)->dentry
+                   && unix_sk(sock->sk)->dentry->d_inode
+                  ) {
+	          rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = unix_sk(sock->sk)->dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = unix_sk(sock->sk)->dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = unix_sk(sock->sk)->dentry;
+                } else {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+		  if(sock->file
+		     && sock->file->f_dentry
+		     && sock->file->f_dentry->d_inode
+		    )
+	            rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+	          else
+	            rsbac_target_id.ipc.id.id_nr = 0;
+                }
+	      }
+              if (sock->sk->sk_peercred.pid) {
+	            rsbac_attribute = A_process;
+	            rsbac_attribute_value.process = sock->sk->sk_peercred.pid;
+              } else if(unix_sk(sock->sk)->peer
+                        && unix_sk(sock->sk)->peer->sk_peercred.pid) {
+	            rsbac_attribute = A_process;
+	            rsbac_attribute_value.process = unix_sk(sock->sk)->peer->sk_peercred.pid;
+	      } else {
+	            rsbac_attribute = A_sock_type;
+		    rsbac_attribute_value.sock_type = sock->type;
+	      }
+	    }
+          }
+        #if defined(CONFIG_RSBAC_NET_OBJ)
+        else
+          {
+            #if !defined(CONFIG_RSBAC_NET_OBJ_RW)
+            if(sock->type != SOCK_STREAM)
+            #endif
+            {
+              rsbac_target = T_NETOBJ;
+              rsbac_target_id.netobj.sock_p = sock;
+              rsbac_target_id.netobj.local_addr = NULL;
+              rsbac_target_id.netobj.local_len = 0;
+              rsbac_target_id.netobj.remote_addr = msg->msg_name;
+              rsbac_target_id.netobj.remote_len = msg->msg_namelen;
+              rsbac_attribute = A_sock_type;
+              rsbac_attribute_value.sock_type = sock->type;
+            }
+          }
+        #endif
+        if (   (rsbac_target != T_NONE)
+            && !rsbac_adf_request(R_SEND,
+                                  current->pid,
+                                  rsbac_target,
+                                  rsbac_target_id,
+                                  rsbac_attribute,
+                                  rsbac_attribute_value)
+           )
+              {
+                return -EPERM;
+              }
+        #endif
+
 	si->sock = sock;
 	si->scm = NULL;
 	si->msg = msg;
@@ -551,7 +665,31 @@
 	if (err)
 		return err;
 
-	return sock->ops->sendmsg(iocb, sock, msg, size);
+	err = sock->ops->sendmsg(iocb, sock, msg, size);
+
+        /* RSBAC: notify ADF of sent msg */
+        #ifdef CONFIG_RSBAC
+        if(   !err
+           && (rsbac_target != T_NONE)
+          )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_SEND,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   rsbac_attribute,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sock_sendmsg() [sys_send(), sys_sendto(), sys_sendmsg()]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
+	return err;
 }
 
 int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
@@ -592,6 +730,15 @@
 	int err;
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute = A_none;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	si->sock = sock;
 	si->scm = NULL;
 	si->msg = msg;
@@ -602,7 +749,131 @@
 	if (err)
 		return err;
 
-	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	err = sock->ops->recvmsg(iocb, sock, msg, size, flags);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_recv(), sys_recvfrom(), sys_recvmsg()]: calling ADF\n");
+        if(   sock->ops
+           && (sock->ops->family == AF_UNIX)
+          )
+          {
+            if(sock->sk) {
+              if(unix_sk(unix_sk(sock->sk)->peer)) {
+                if(   unix_sk(unix_sk(sock->sk)->peer)->dentry
+                   && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+                  ) {
+	          rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = unix_sk(unix_sk(sock->sk)->peer)->dentry;
+                } else {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+                  if(   unix_sk(unix_sk(sock->sk)->peer)->dentry
+                     && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry->d_inode
+                    )
+			rsbac_target_id.ipc.id.id_nr = SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry->d_inode->i_ino;
+		  else
+		    if(sock->file
+		       && sock->file->f_dentry
+		       && sock->file->f_dentry->d_inode
+		      )
+	              rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+	            else
+	              rsbac_target_id.ipc.id.id_nr = 0;
+                }
+	      } else {
+                if(   unix_sk(sock->sk)->dentry
+                   && unix_sk(sock->sk)->dentry->d_inode
+                  ) {
+	          rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = unix_sk(sock->sk)->dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = unix_sk(sock->sk)->dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = unix_sk(sock->sk)->dentry;
+                } else {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+		  if(sock->file
+		     && sock->file->f_dentry
+		     && sock->file->f_dentry->d_inode
+		    )
+	            rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+	          else
+	            rsbac_target_id.ipc.id.id_nr = 0;
+                }
+	      }
+              if (sock->sk->sk_peercred.pid) {
+	            rsbac_attribute = A_process;
+	            rsbac_attribute_value.process = sock->sk->sk_peercred.pid;
+	      } else if (si->scm && si->scm->creds.pid) {
+	            rsbac_attribute = A_process;
+	            rsbac_attribute_value.process = si->scm->creds.pid;
+	      } else {
+	            rsbac_attribute = A_sock_type;
+		    rsbac_attribute_value.sock_type = sock->type;
+	      }
+	    }
+          }
+        #if defined(CONFIG_RSBAC_NET_OBJ)
+        else
+          {
+            #if !defined(CONFIG_RSBAC_NET_OBJ_RW)
+            if(sock->type != SOCK_STREAM)
+            #endif
+            {
+              rsbac_target = T_NETOBJ;
+              rsbac_target_id.netobj.sock_p = sock;
+              rsbac_target_id.netobj.local_addr = NULL;
+              rsbac_target_id.netobj.local_len = 0;
+              rsbac_target_id.netobj.remote_addr = msg->msg_name;
+              rsbac_target_id.netobj.remote_len = msg->msg_namelen;
+              rsbac_attribute = A_sock_type;
+              rsbac_attribute_value.sock_type = sock->type;
+            }
+          }
+        #endif
+        if (   (rsbac_target != T_NONE)
+            && !rsbac_adf_request(R_RECEIVE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   rsbac_attribute,
+                                   rsbac_attribute_value))
+              {
+                /* clear buffer */
+                if(err > 0)
+                  memset(msg->msg_iov->iov_base - err, 0, err);
+                return -EPERM;
+              }
+        #endif
+
+        /* RSBAC: notify ADF of received message */
+        #ifdef CONFIG_RSBAC
+        if(   !err
+           && (rsbac_target != T_NONE)
+          )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_RECEIVE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   rsbac_attribute,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sock_recvmsg() [sys_recv(), sys_recvfrom(), sys_recvmsg()]: rsbac_adf_set_attr() for RECEIVE returned error\n");
+              }
+          }
+        #endif
+
+	return err;
 }
 
 int sock_recvmsg(struct socket *sock, struct msghdr *msg,
@@ -1174,14 +1445,78 @@
 	int retval;
 	struct socket *sock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union  rsbac_target_id_t       rsbac_target_id;
+        union  rsbac_target_id_t       rsbac_new_target_id;
+        union  rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = sock_create(family, type, protocol, &sock);
 	if (retval < 0)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(family == AF_UNIX)
+          {
+            rsbac_target = T_IPC;
+            rsbac_target_id.ipc.type = I_anonunix;
+            rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock)->i_ino;
+          }
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        else
+          {
+            rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+            rsbac_target = T_NETOBJ;
+            rsbac_target_id.netobj.sock_p = sock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+          }
+        #endif
+        rsbac_attribute_value.sock_type = type;
+        if (   (rsbac_target != T_NONE)
+            && !rsbac_adf_request(R_CREATE,
+                                  current->pid,
+                                  rsbac_target,
+                                  rsbac_target_id,
+                                  A_sock_type,
+                                  rsbac_attribute_value)
+           )
+              {
+                rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+                retval = -EPERM;
+                goto out_release;
+              }
+        #endif
+
 	retval = sock_map_fd(sock);
 	if (retval < 0)
 		goto out_release;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(rsbac_target != T_NONE)
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_CREATE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_sock_type,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_socket() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 out:
 	/* It may be already another descriptor 8) Not kernel problem. */
 	return retval;
@@ -1201,6 +1536,13 @@
 	struct socket *sock1, *sock2;
 	int fd1, fd2, err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/*
 	 * Obtain the first socket and check if the underlying protocol
 	 * supports the socketpair call.
@@ -1210,10 +1552,47 @@
 	if (err < 0)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+        rsbac_target_id.ipc.type = I_anonunix;
+        rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock1)->i_ino;
+        rsbac_attribute_value.sock_type = type;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_sock_type,
+                               rsbac_attribute_value))
+          {
+                rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+                err = -EPERM;
+                goto out_release_1;
+          }
+        #endif
+
 	err = sock_create(family, type, protocol, &sock2);
 	if (err < 0)
 		goto out_release_1;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+        rsbac_target_id.ipc.type = I_anonunix;
+        rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock2)->i_ino;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_sock_type,
+                               rsbac_attribute_value))
+          {
+                rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+                err = -EPERM;
+                goto out_release_both;
+          }
+        #endif
+
 	err = sock1->ops->socketpair(sock1, sock2);
 	if (err < 0)
 		goto out_release_both;
@@ -1237,8 +1616,42 @@
 	err = put_user(fd1, &usockvec[0]);
 	if (!err)
 		err = put_user(fd2, &usockvec[1]);
-	if (!err)
+
+	if (!err) {
+	        /* RSBAC: notify ADF of new anonunix */
+	        #ifdef CONFIG_RSBAC
+	        rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock1)->i_ino;
+	        rsbac_new_target_id.dummy = 0;
+	        if (rsbac_adf_set_attr(R_CREATE,
+	                               current->pid,
+	                               T_IPC,
+	                               rsbac_target_id,
+	                               T_NONE,
+	                               rsbac_new_target_id,
+	                               A_sock_type,
+	                               rsbac_attribute_value))
+	          {
+	            rsbac_printk(KERN_WARNING
+	                   "sys_socketpair() [sys_socketcall()]: rsbac_adf_set_attr() for sock1 returned error\n");
+	          }
+	        rsbac_target_id.ipc.id.id_nr = SOCK_INODE(sock2)->i_ino;
+	        rsbac_new_target_id.dummy = 0;
+	        if (rsbac_adf_set_attr(R_CREATE,
+	                               current->pid,
+	                               T_IPC,
+	                               rsbac_target_id,
+	                               T_NONE,
+	                               rsbac_new_target_id,
+	                               A_sock_type,
+	                               rsbac_attribute_value))
+	          {
+	            rsbac_printk(KERN_WARNING
+	                   "sys_socketpair() [sys_socketcall()]: rsbac_adf_set_attr() for sock2 returned error\n");
+	          }
+	        #endif
+
 		return 0;
+        }
 
 	sys_close(fd2);
 	sys_close(fd1);
@@ -1271,10 +1684,39 @@
 	char address[MAX_SOCK_ADDR];
 	int err, fput_needed;
 
+#ifdef CONFIG_RSBAC_NET_OBJ
+	union rsbac_target_id_t rsbac_target_id;
+	union rsbac_target_id_t	rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if(sock) {
 		err = move_addr_to_kernel(umyaddr, addrlen, address);
-		if (err >= 0) {
+		if(err >= 0) {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+		        if(   sock->ops
+		           && (sock->ops->family != AF_UNIX)) {
+				rsbac_target_id.netobj.sock_p = sock;
+				rsbac_target_id.netobj.local_addr = address;
+				rsbac_target_id.netobj.local_len = addrlen;
+				rsbac_target_id.netobj.remote_addr = NULL;
+				rsbac_target_id.netobj.remote_len = 0;
+				rsbac_attribute_value.sock_type = sock->type;
+				rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF");
+				if(!rsbac_adf_request(R_BIND,
+							current->pid,
+							T_NETOBJ,
+							rsbac_target_id,
+							A_sock_type,
+							rsbac_attribute_value)) {
+					rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+					fput_light(sock->file, fput_needed);
+					return -EPERM;
+				}
+			}
+                        #endif
+
 			err = security_socket_bind(sock,
 						   (struct sockaddr *)address,
 						   addrlen);
@@ -1282,6 +1724,27 @@
 				err = sock->ops->bind(sock,
 						      (struct sockaddr *)
 						      address, addrlen);
+
+                        /* RSBAC: notify ADF of binding */
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        if(   !err
+			   && sock->ops
+		           && (sock->ops->family != AF_UNIX)) {
+                            rsbac_new_target_id.dummy = 0;
+                            if (rsbac_adf_set_attr(R_BIND,
+                                                   current->pid,
+                                                   T_NETOBJ,
+                                                   rsbac_target_id,
+                                                   T_NONE,
+                                                   rsbac_new_target_id,
+                                                   A_sock_type,
+                                                   rsbac_attribute_value))
+                              {
+                                rsbac_printk(KERN_WARNING
+                                       "sys_bind() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+                              }
+                          }
+                        #endif
 		}
 		fput_light(sock->file, fput_needed);
 	}
@@ -1300,9 +1763,60 @@
 {
 	struct socket *sock;
 	int err, fput_needed;
-
+	
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+	
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock) {
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+		if(   sock->ops
+				&& (sock->ops->family == AF_UNIX)
+				&& sock->file
+				&& sock->file->f_dentry
+				&& sock->file->f_dentry->d_inode
+		  )
+		{
+			if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+				rsbac_target = T_IPC;
+				rsbac_target_id.ipc.type = I_anonunix;
+				rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+			} else {
+				rsbac_target = T_UNIXSOCK;
+				rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+				rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+				rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+			}
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+		rsbac_attribute_value.sock_type = sock->type;
+		if (   (rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_LISTEN,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value)) {
+			rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+			fput_light(sock->file, fput_needed);
+			return -EPERM;
+		}
+#endif
+
 		if ((unsigned)backlog > sysctl_somaxconn)
 			backlog = sysctl_somaxconn;
 
@@ -1310,6 +1824,24 @@
 		if (!err)
 			err = sock->ops->listen(sock, backlog);
 
+
+		/* RSBAC: notify ADF of listened socket */
+#ifdef CONFIG_RSBAC
+		if(!err && (rsbac_target != T_NONE)) {
+			rsbac_new_target_id.dummy = 0;
+			if (rsbac_adf_set_attr(R_LISTEN,
+						current->pid,
+						rsbac_target,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_sock_type,
+						rsbac_attribute_value))
+				rsbac_printk(KERN_WARNING
+						"sys_listen() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+		}
+#endif
+
 		fput_light(sock->file, fput_needed);
 	}
 	return err;
@@ -1335,6 +1867,14 @@
 	int err, len, newfd, fput_needed;
 	char address[MAX_SOCK_ADDR];
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	enum  rsbac_attribute_t       rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
@@ -1371,6 +1911,105 @@
 	if (err < 0)
 		goto out_fd;
 
+#ifdef CONFIG_RSBAC
+	rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+	if(   sock->ops
+		&& (sock->ops->family == AF_UNIX)
+	  )
+	  {
+            if(sock->sk) {
+              if(unix_sk(unix_sk(sock->sk)->peer)) {
+                if(   unix_sk(unix_sk(sock->sk)->peer)->dentry
+                   && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+                  ) {
+	          rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = unix_sk(unix_sk(sock->sk)->peer)->dentry;
+                } else {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+                  if(   unix_sk(unix_sk(sock->sk)->peer)->dentry
+                     && unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry
+                     && SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry->d_inode
+                    )
+			rsbac_target_id.ipc.id.id_nr = SOCKET_I(unix_sk(unix_sk(sock->sk)->peer)->dentry->d_inode)->file->f_dentry->d_inode->i_ino;
+		  else
+		    if(sock->file
+		       && sock->file->f_dentry
+		       && sock->file->f_dentry->d_inode
+		      )
+	              rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+	            else
+	              rsbac_target_id.ipc.id.id_nr = 0;
+                }
+	      } else {
+                if(   unix_sk(sock->sk)->dentry
+                   && unix_sk(sock->sk)->dentry->d_inode
+                  ) {
+	          rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = unix_sk(sock->sk)->dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = unix_sk(sock->sk)->dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = unix_sk(sock->sk)->dentry;
+                } else {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+		  if(sock->file
+		     && sock->file->f_dentry
+		     && sock->file->f_dentry->d_inode
+		    )
+	            rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+	          else
+	            rsbac_target_id.ipc.id.id_nr = 0;
+                }
+	      }
+	    }
+            if (sock->sk
+		    && sock->sk->sk_peercred.pid
+		) {
+	            rsbac_attribute = A_process;
+	            rsbac_attribute_value.process = sock->sk->sk_peercred.pid;
+	    } else {
+	            rsbac_attribute = A_sock_type;
+		    rsbac_attribute_value.sock_type = sock->type;
+	    }
+	  }
+#ifdef CONFIG_RSBAC_NET_OBJ
+	else
+	  {
+		rsbac_target = T_NETOBJ;
+		rsbac_target_id.netobj.sock_p = newsock;
+		rsbac_target_id.netobj.local_addr = NULL;
+		rsbac_target_id.netobj.local_len = 0;
+		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0)
+		{
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+		else
+		{
+			rsbac_target_id.netobj.remote_addr = address;
+			rsbac_target_id.netobj.remote_len = len;
+		}
+		rsbac_attribute = A_sock_type;
+		rsbac_attribute_value.sock_type = sock->type;
+	}
+#endif
+	if (   (rsbac_target != T_NONE)
+			&& !rsbac_adf_request(R_ACCEPT,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				rsbac_attribute,
+				rsbac_attribute_value)) {
+		rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+		err = -EPERM;
+		goto out_fd;
+	}
+#endif
+
 	if (upeer_sockaddr) {
 		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
 					  &len, 2) < 0) {
@@ -1390,6 +2029,23 @@
 
 	security_socket_post_accept(sock, newsock);
 
+        /* RSBAC: notify ADF of accepted connection */
+#ifdef CONFIG_RSBAC
+	if(rsbac_target != T_NONE) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_ACCEPT,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+			rsbac_printk(KERN_WARNING
+					"sys_accept() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+	}
+#endif
+
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
@@ -1419,6 +2075,12 @@
 	char address[MAX_SOCK_ADDR];
 	int err, fput_needed;
 
+#ifdef CONFIG_RSBAC_NET_OBJ
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
@@ -1431,8 +2093,58 @@
 	if (err)
 		goto out_put;
 
+        /* RSBAC */
+        /* UNIX socket connects get intercepted in unix/af_unix.c */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        if(   sock->ops
+           && (sock->ops->family != AF_UNIX)
+          )
+          {
+            rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+            rsbac_target_id.netobj.sock_p = sock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = address;
+            rsbac_target_id.netobj.remote_len = addrlen;
+            rsbac_attribute_value.sock_type = sock->type;
+            if (!rsbac_adf_request(R_CONNECT,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_sock_type,
+                                   rsbac_attribute_value))
+              {
+                rsbac_pr_debug(aef, "[sys_socketcall()]: ADF returned NOT_GRANTED\n");
+                err = -EPERM;
+                goto out_put;
+              }
+          }
+        #endif
+
 	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
 				 sock->file->f_flags);
+
+        /* RSBAC: notify ADF of opened socket connection */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        if(!err
+	   && sock->ops
+           && (sock->ops->family != AF_UNIX)
+	  )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_CONNECT,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_sock_type,
+                                   rsbac_attribute_value))
+		rsbac_printk(KERN_WARNING
+                       "sys_connect() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+          }
+        #endif
+
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
@@ -1451,6 +2163,12 @@
 	char address[MAX_SOCK_ADDR];
 	int len, err, fput_needed;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
@@ -1459,6 +2177,51 @@
 	if (err)
 		goto out_put;
 
+        /* RSBAC */
+        #if defined(CONFIG_RSBAC)
+	rsbac_pr_debug(aef, "calling ADF\n");
+        if(   sock->ops
+           && (sock->ops->family == AF_UNIX)
+           && sock->file
+           && sock->file->f_dentry
+           && sock->file->f_dentry->d_inode
+          )
+          {
+            if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+                  rsbac_target = T_IPC;
+                  rsbac_target_id.ipc.type = I_anonunix;
+                  rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+            } else {
+	          rsbac_target = T_UNIXSOCK;
+                  rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+                  rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+                  rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+            }
+          }
+	#ifdef CONFIG_RSBAC_NET_OBJ
+	else
+          {
+	    rsbac_target = T_NETOBJ;
+            rsbac_target_id.netobj.sock_p = sock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+	  }
+	#endif
+	rsbac_attribute_value.sock_type = sock->type;
+	if (   (rsbac_target != T_NONE)
+	    && !rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				rsbac_target,
+				rsbac_target_id,
+				A_sock_type,
+				rsbac_attribute_value)) {
+		err = -EPERM;
+		goto out_put;
+	}
+	#endif
+
 	err = sock->ops->getname(sock, (struct sockaddr *)address, &len, 0);
 	if (err)
 		goto out_put;
@@ -1482,6 +2245,12 @@
 	char address[MAX_SOCK_ADDR];
 	int len, err, fput_needed;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock != NULL) {
 		err = security_socket_getpeername(sock);
@@ -1490,6 +2259,50 @@
 			return err;
 		}
 
+	        /* RSBAC */
+	        #if defined(CONFIG_RSBAC)
+		rsbac_pr_debug(aef, "calling ADF\n");
+	        if(   sock->ops
+	           && (sock->ops->family == AF_UNIX)
+	           && sock->file
+	           && sock->file->f_dentry
+	           && sock->file->f_dentry->d_inode
+	          )
+	          {
+	            if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+	                  rsbac_target = T_IPC;
+	                  rsbac_target_id.ipc.type = I_anonunix;
+	                  rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+	            } else {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+	            }
+	          }
+                #ifdef CONFIG_RSBAC_NET_OBJ
+                else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+		#endif
+		rsbac_attribute_value.sock_type = sock->type;
+		if (   (rsbac_target != T_NONE)
+		    && !rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value)) {
+			fput_light(sock->file, fput_needed);
+			return -EPERM;
+		}
+	        #endif
+
 		err =
 		    sock->ops->getname(sock, (struct sockaddr *)address, &len,
 				       1);
@@ -1629,6 +2442,13 @@
 	int err, fput_needed;
 	struct socket *sock;
 
+        /* RSBAC  */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (optlen < 0)
 		return -EINVAL;
 
@@ -1638,6 +2458,50 @@
 		if (err)
 			goto out_put;
 
+	        /* RSBAC */
+	        #if defined(CONFIG_RSBAC)
+		rsbac_pr_debug(aef, "calling ADF\n");
+	        if(   sock->ops
+	           && (sock->ops->family == AF_UNIX)
+	           && sock->file
+	           && sock->file->f_dentry
+	           && sock->file->f_dentry->d_inode
+	          )
+	          {
+	            if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+	                  rsbac_target = T_IPC;
+	                  rsbac_target_id.ipc.type = I_anonunix;
+	                  rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+	            } else {
+		          rsbac_target = T_UNIXSOCK;
+	                  rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+	                  rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+	                  rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+	            }
+	          }
+                #ifdef CONFIG_RSBAC_NET_OBJ
+                else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+		#endif
+		rsbac_attribute_value.setsockopt_level = level;
+		if (   (rsbac_target != T_NONE)
+		    && !rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					A_setsockopt_level,
+					rsbac_attribute_value)) {
+			err = -EPERM;
+			goto out_put;
+		}
+	        #endif
+
 		if (level == SOL_SOCKET)
 			err =
 			    sock_setsockopt(sock, level, optname, optval,
@@ -1663,12 +2527,64 @@
 	int err, fput_needed;
 	struct socket *sock;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock != NULL) {
 		err = security_socket_getsockopt(sock, level, optname);
 		if (err)
 			goto out_put;
 
+#if defined(CONFIG_RSBAC)
+		rsbac_pr_debug(aef, "calling ADF\n");
+		if(   sock->ops
+				&& (sock->ops->family == AF_UNIX)
+				&& sock->file
+				&& sock->file->f_dentry
+				&& sock->file->f_dentry->d_inode
+				&& sock->file->f_dentry->d_inode->i_ino
+				&& sock->file->f_dentry->d_sb
+				&& sock->file->f_dentry->d_sb->s_dev
+		  )
+		{
+			if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+				rsbac_target = T_IPC;
+				rsbac_target_id.ipc.type = I_anonunix;
+				rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+			} else {
+				rsbac_target = T_UNIXSOCK;
+				rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+				rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+				rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+			}
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+		rsbac_attribute_value.sock_type = sock->type;
+		if ((rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value)) {
+			err = -EPERM;
+			goto out_put;
+		}
+#endif
+
 		if (level == SOL_SOCKET)
 			err =
 			    sock_getsockopt(sock, level, optname, optval,
@@ -1692,11 +2608,86 @@
 	int err, fput_needed;
 	struct socket *sock;
 
+#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+#ifdef CONFIG_RSBAC_NET_OBJ
+	union rsbac_target_id_t       rsbac_new_target_id;
+#endif
+	union rsbac_attribute_value_t rsbac_attribute_value;
+#endif
+
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock != NULL) {
 		err = security_socket_shutdown(sock, how);
+
+#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_socketcall()]: calling ADF\n");
+		if(   sock->ops
+				&& (sock->ops->family == AF_UNIX)
+				&& sock->file
+				&& sock->file->f_dentry
+				&& sock->file->f_dentry->d_inode
+		  )
+		{
+			if (sock->file->f_dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+				rsbac_target = T_IPC;
+				rsbac_target_id.ipc.type = I_anonunix;
+				rsbac_target_id.ipc.id.id_nr = sock->file->f_dentry->d_inode->i_ino;
+			} else {
+				rsbac_target = T_UNIXSOCK;
+				rsbac_target_id.unixsock.device = sock->file->f_dentry->d_sb->s_dev;
+				rsbac_target_id.unixsock.inode  = sock->file->f_dentry->d_inode->i_ino;
+				rsbac_target_id.unixsock.dentry_p = sock->file->f_dentry;
+			}
+		}
+#ifdef CONFIG_RSBAC_NET_OBJ
+		else {
+			rsbac_target = T_NETOBJ;
+			rsbac_target_id.netobj.sock_p = sock;
+			rsbac_target_id.netobj.local_addr = NULL;
+			rsbac_target_id.netobj.local_len = 0;
+			rsbac_target_id.netobj.remote_addr = NULL;
+			rsbac_target_id.netobj.remote_len = 0;
+		}
+#endif
+		rsbac_attribute_value.sock_type = sock->type;
+		if (   (rsbac_target != T_NONE)
+				&& !rsbac_adf_request(R_NET_SHUTDOWN,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					A_sock_type,
+					rsbac_attribute_value)) {
+			err = -EPERM;
+		}
+#endif
+
 		if (!err)
 			err = sock->ops->shutdown(sock, how);
+
+		/* RSBAC: notifying adf / socket */
+#ifdef CONFIG_RSBAC_NET_OBJ
+		if(!err && (rsbac_target != T_NONE))
+		{
+			rsbac_pr_debug(aef, "calling rsbac_adf_set_attr() for NET_SHUTDOWN on netobj\n");
+			rsbac_new_target_id.dummy = 0;
+			rsbac_attribute_value.dummy = 0;
+			if (rsbac_adf_set_attr(R_NET_SHUTDOWN,
+						current->pid,
+						rsbac_target,
+						rsbac_target_id,
+						T_NONE,
+						rsbac_new_target_id,
+						A_sock_type,
+						rsbac_attribute_value))
+			{
+				rsbac_printk(KERN_WARNING 
+						"sys_shutdown(): rsbac_adf_set_attr() for NET_SHUTDOWN on socket returned error\n");
+			}
+		}
+#endif
+
 		fput_light(sock->file, fput_needed);
 	}
 	return err;
diff -urN rsbac_tmp_15032007/kernel-2.6/trunk/net/unix/af_unix.c ./linux-2.6.19.3-rsbac-1.3.2/net/unix/af_unix.c
--- rsbac_tmp_15032007/kernel-2.6/trunk/net/unix/af_unix.c	2007-03-15 13:36:19.000000000 +0100
+++ ./linux-2.6.19.3-rsbac-1.3.2/net/unix/af_unix.c	2007-03-15 14:32:22.000000000 +0100
@@ -117,6 +117,8 @@
 #include <net/checksum.h>
 #include <linux/security.h>
 
+#include <rsbac/hooks.h>
+
 int sysctl_unix_max_dgram_qlen __read_mostly = 10;
 
 struct hlist_head unix_socket_table[UNIX_HASH_SIZE + 1];
@@ -802,6 +804,13 @@
 		if (IS_ERR(dentry))
 			goto out_mknod_unlock;
 
+#ifdef CONFIG_RSBAC
+		/* RSBAC add: set credentials so connect and send can copy them */
+		sk->sk_peercred.pid	= current->tgid;
+		sk->sk_peercred.uid	= current->euid;
+		sk->sk_peercred.gid	= current->egid;
+#endif
+
 		/*
 		 * All right, let's create it.
 		 */
@@ -867,6 +876,15 @@
 	unsigned hash;
 	int err;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+	enum rsbac_target_t           rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	#endif
+
 	if (addr->sa_family != AF_UNSPEC) {
 		err = unix_mkname(sunaddr, alen, &hash);
 		if (err < 0)
@@ -881,6 +899,42 @@
 		if (!other)
 			goto out;
 
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC
+		rsbac_pr_debug(aef, "[sys_connect() [sys_socketcall()]]: calling ADF\n");
+		/* Named socket? */
+		if(sunaddr->sun_path[0]) {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = unix_sk(other)->dentry->d_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = unix_sk(other)->dentry->d_inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = unix_sk(other)->dentry;
+		} else {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = unix_sk(other)->dentry->d_inode->i_ino;
+		}
+		if (other->sk_peercred.pid) {
+		   	rsbac_attribute = A_process;
+		   	rsbac_attribute_value.process = other->sk_peercred.pid;
+		} else if (sk->sk_peercred.pid) {
+		   	rsbac_attribute = A_process;
+		   	rsbac_attribute_value.process = sk->sk_peercred.pid;
+		} else {
+			rsbac_attribute = A_sock_type;
+			rsbac_attribute_value.sock_type = sock->type;
+		}
+		if (!rsbac_adf_request(R_CONNECT,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value)) {
+			rsbac_pr_debug(aef, "[sys_connect() [sys_socketcall()]]: ADF returned NOT_GRANTED\n");
+			err = -EPERM;
+			goto out;
+		}
+		#endif
+
 		unix_state_wlock(sk);
 
 		err = -EPERM;
@@ -914,6 +968,24 @@
 		unix_peer(sk)=other;
 		unix_state_wunlock(sk);
 	}
+
+	/* RSBAC: notify adf */
+	#ifdef CONFIG_RSBAC
+	if(rsbac_target != T_NONE) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CONNECT,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+			rsbac_printk(KERN_WARNING
+				"unix_dgram_connect() [sys_connect() [sys_socketcall()]]: rsbac_adf_set_attr() returned error\n");
+	}
+        #endif
+
  	return 0;
 
 out_unlock:
@@ -959,6 +1031,15 @@
 	int err;
 	long timeo;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+	enum rsbac_target_t           rsbac_target = T_NONE;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_target_id_t       rsbac_new_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute = A_none;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	#endif
+
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
 		goto out;
@@ -993,6 +1074,45 @@
 	if (!other)
 		goto out;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+	if(unix_sk(other)->dentry && unix_sk(other)->dentry->d_inode) {
+		rsbac_pr_debug(aef, "[sys_connect() [sys_socketcall()]]: calling ADF\n");
+		/* Named socket? */
+		if(sunaddr->sun_path[0]) {
+			rsbac_target = T_UNIXSOCK;
+			rsbac_target_id.unixsock.device = unix_sk(other)->dentry->d_sb->s_dev;
+			rsbac_target_id.unixsock.inode  = unix_sk(other)->dentry->d_inode->i_ino;
+			rsbac_target_id.unixsock.dentry_p = unix_sk(other)->dentry;
+		} else {
+			rsbac_target = T_IPC;
+			rsbac_target_id.ipc.type = I_anonunix;
+			rsbac_target_id.ipc.id.id_nr = unix_sk(other)->dentry->d_inode->i_ino;
+		}
+		if (other->sk_peercred.pid) {
+		   	rsbac_attribute = A_process;
+		   	rsbac_attribute_value.process = other->sk_peercred.pid;
+		} else if (sk->sk_peercred.pid) {
+		   	rsbac_attribute = A_process;
+		   	rsbac_attribute_value.process = sk->sk_peercred.pid;
+		} else {
+			rsbac_attribute = A_sock_type;
+			rsbac_attribute_value.sock_type = sock->type;
+		}
+		if (!rsbac_adf_request(R_CONNECT,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value)) {
+			rsbac_pr_debug(aef, "[sys_connect() [sys_socketcall()]]:"
+					    " ADF returned NOT_GRANTED\n");
+			err = -EPERM;
+			goto out;
+		}
+	}
+	#endif
+
 	/* Latch state of peer */
 	unix_state_rlock(other);
 
@@ -1107,6 +1227,24 @@
 	spin_unlock(&other->sk_receive_queue.lock);
 	unix_state_runlock(other);
 	other->sk_data_ready(other, 0);
+
+	/* RSBAC: notify adf */
+	#ifdef CONFIG_RSBAC
+	if(rsbac_target != T_NONE) {
+		rsbac_new_target_id.dummy = 0;
+		if (rsbac_adf_set_attr(R_CONNECT,
+					current->pid,
+					rsbac_target,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					rsbac_attribute,
+					rsbac_attribute_value))
+			rsbac_printk(KERN_WARNING
+				"unix_stream_connect() [sys_connect() [sys_socketcall()]]: rsbac_adf_set_attr() returned error\n");
+	}
+        #endif
+
 	sock_put(other);
 	return 0;
 
