diff -Naur linux-2.6.27/arch/x86/kernel/io_apic_32.c linux-2.6.27-mdb/arch/x86/kernel/io_apic_32.c
--- linux-2.6.27/arch/x86/kernel/io_apic_32.c	2008-10-06 23:53:48.000000000 -0600
+++ linux-2.6.27-mdb/arch/x86/kernel/io_apic_32.c	2008-10-06 23:55:42.000000000 -0600
@@ -75,6 +75,7 @@
 /* I/O APIC entries */
 struct mp_config_ioapic mp_ioapics[MAX_IO_APICS];
 int nr_ioapics;
+EXPORT_SYMBOL(nr_ioapics);
 
 /* MP IRQ source entries */
 struct mp_config_intsrc mp_irqs[MAX_IRQ_SOURCES];
@@ -120,12 +121,13 @@
 		+ (mp_ioapics[idx].mp_apicaddr & ~PAGE_MASK);
 }
 
-static inline unsigned int io_apic_read(unsigned int apic, unsigned int reg)
+unsigned int io_apic_read(unsigned int apic, unsigned int reg)
 {
 	struct io_apic __iomem *io_apic = io_apic_base(apic);
 	writel(reg, &io_apic->index);
 	return readl(&io_apic->data);
 }
+EXPORT_SYMBOL(io_apic_read);
 
 static inline void io_apic_write(unsigned int apic, unsigned int reg, unsigned int value)
 {
diff -Naur linux-2.6.27/arch/x86/kernel/reboot.c linux-2.6.27-mdb/arch/x86/kernel/reboot.c
--- linux-2.6.27/arch/x86/kernel/reboot.c	2008-10-06 23:53:48.000000000 -0600
+++ linux-2.6.27-mdb/arch/x86/kernel/reboot.c	2008-10-06 23:55:42.000000000 -0600
@@ -497,6 +497,10 @@
 {
 	machine_ops.emergency_restart();
 }
+EXPORT_SYMBOL_GPL(machine_emergency_restart);
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+EXPORT_SYMBOL(genapic);
+#endif
 
 void machine_restart(char *cmd)
 {
diff -Naur linux-2.6.27/debug/Makefile linux-2.6.27-mdb/debug/Makefile
--- linux-2.6.27/debug/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/Makefile	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,5 @@
+#
+# Makefile for kernel debugger modules
+#
+
+obj-$(CONFIG_MDB)		+= mdb/
diff -Naur linux-2.6.27/debug/mdb/Makefile linux-2.6.27-mdb/debug/mdb/Makefile
--- linux-2.6.27/debug/mdb/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/Makefile	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,5 @@
+#
+
+obj-$(CONFIG_MDB) += mdb.o
+
+mdb-y := mdb-main.o mdb-base.o mdb-list.o mdb-logic.o mdb-os.o mdb-ia32.o mdb-ia32-support.o mdb-ia32-apic.o
diff -Naur linux-2.6.27/debug/mdb/mdb-base.c linux-2.6.27-mdb/debug/mdb/mdb-base.c
--- linux-2.6.27/debug/mdb/mdb-base.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-base.c	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,2329 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/uaccess.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <linux/io.h>
+
+#ifdef CONFIG_SMP
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb.h"
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+unsigned long debug_deref;
+unsigned long full_deref_toggle;
+unsigned long control_toggle;
+unsigned long numeric_toggle;
+unsigned long general_toggle = 1;
+unsigned long line_info_toggle = 1;
+unsigned long segment_toggle = 1;
+unsigned long reason_toggle = 1;
+
+unsigned long enterKeyACC(unsigned long key, void *stackFrame,
+	          ACCELERATOR *accel)
+{
+    unsigned char *verbBuffer = &workbuf[0][0];
+    register unsigned char *verb, *pp, *vp;
+    register unsigned long count;
+
+    if (!debugCommand[0])
+    {
+       count = 0;
+       pp = (unsigned char *)lastDebugCommand;
+       vp = verb = &verbBuffer[0];
+       while (*pp && *pp == ' ' && count++ < 80)
+	  pp++;
+
+       while (*pp && *pp != ' ' && count++ < 80)
+	  *vp++ = *pp++;
+       *vp = '\0';
+
+       while (*pp && *pp == ' ' && count++ < 80)
+	  pp++;
+
+       UpcaseString(verb);
+       if (!strcmp(verb, "P") || (lastCommand == K_F8))
+	  strcpy((char *)debugCommand, "P");
+       else
+       if (!strcmp(verb, "T") || (lastCommand == K_F7))
+	  strcpy((char *)debugCommand, "T");
+       else
+       if (!strcmp(verb, "W")   || !strcmp(verb, "D")   ||
+	   !strcmp(verb, "DB")  || !strcmp(verb, "DW")  ||
+	   !strcmp(verb, "DD")  || !strcmp(verb, "DDS") ||
+	   !strcmp(verb, "DS")  || !strcmp(verb, "DL")  ||
+	   !strcmp(verb, "U")   || !strcmp(verb, "UU")  ||
+	   !strcmp(verb, "S")   || !strcmp(verb, "SS")  ||
+	   !strcmp(verb, "SSB") || !strcmp(verb, "ID")) {
+	  strcpy((char *)debugCommand, verb);
+	  repeatCommand = 1;
+       }
+    }
+    return 0;
+
+}
+
+
+unsigned long displayDebuggerHelpHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("displays general help for all commands, or help for a specific command\n");
+    DBGPrint("HELP         <enter>  - list all commands\n");
+    DBGPrint("HELP command <enter>  - help for a specific command\n");
+
+    return 1;
+}
+
+unsigned long displayDebuggerHelp(unsigned char *commandLine,
+			 StackFrame *stackFrame, unsigned long Exception,
+			 DEBUGGER_PARSER *parser)
+{
+
+    register unsigned long count;
+    unsigned char *verbBuffer = &workbuf[0][0];
+    register unsigned char *verb, *pp, *vp;
+
+    commandLine = &commandLine[parser->debugCommandNameLength];
+    while (*commandLine && *commandLine == ' ')
+       commandLine++;
+
+    count = 0;
+    pp = commandLine;
+    vp = verb = &verbBuffer[0];
+    while (*pp && *pp == ' ' && count++ < 80)
+       pp++;
+
+    while (*pp && *pp != ' ' && count++ < 80)
+       *vp++ = *pp++;
+    *vp = '\0';
+
+    while (*pp && *pp == ' ' && count++ < 80)
+       pp++;
+
+    DebuggerParserHelpRoutine(verb, commandLine);
+    return 1;
+
+}
+
+/* TIMER */
+
+struct timer_list debug_timer;
+
+void debug_timer_callback(void)
+{
+    debug_timer.expires = jiffies + (HZ * debug_timer.data);
+    debug_timer.function = (void (*)(unsigned long))debug_timer_callback;
+    add_timer(&debug_timer);
+    mdb_breakpoint();
+    return;
+}
+
+unsigned long timedBreakpointHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("addtimer <seconds>      - add int3 timer (lockup detection)\n");
+    DBGPrint("deltimer                - del int3 timer\n");
+    return 1;
+}
+
+unsigned long timerBreakpoint(unsigned char *cmd, StackFrame *stackFrame,
+                            unsigned long Exception, DEBUGGER_PARSER *parser)
+{
+    register int seconds;
+    unsigned long valid = 0;
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ')
+       cmd++;
+
+    if (debug_timer.data)
+    {
+       DBGPrint("debug timer is already active.  seconds = %i\n",
+                (int)debug_timer.data);
+       return 1;
+    }
+
+    seconds = EvaluateNumericExpression(stackFrame, &cmd, &valid);
+    if (valid)
+    {
+       init_timer(&debug_timer);
+       debug_timer.data = seconds;
+       debug_timer.expires = jiffies + (HZ * seconds);
+       debug_timer.function = (void (*)(unsigned long))debug_timer_callback;
+       add_timer(&debug_timer);
+
+       DBGPrint("debug timer created.  seconds = %i\n", seconds);
+    }
+    return 1;
+}
+
+unsigned long timerBreakpointClear(unsigned char *cmd, StackFrame *stackFrame,
+                                   unsigned long Exception,
+                                   DEBUGGER_PARSER *parser)
+{
+    del_timer(&debug_timer);
+    debug_timer.data = 0;
+    DBGPrint("debug timer deleted\n");
+    return 1;
+}
+
+/* BT, BTA, BTP */
+
+extern int bt_stack(struct task_struct *task, struct pt_regs *regs,
+	            unsigned long *stack);
+
+unsigned long backTraceHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+
+    DBGPrint("bt <addr>                - display stack backtrace\n");
+    DBGPrint("bta                      - display stack backtrace all pids\n");
+    DBGPrint("btp <pid>                - display stack backtrace by pid\n");
+    return 1;
+}
+
+unsigned long backTraceAllPID(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	          DEBUGGER_PARSER *parser)
+{
+    struct task_struct *p, *g;
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ')
+       cmd++;
+
+    do_each_thread(g, p)
+    {
+       if (p)
+       {
+          DBGPrint("Stack backtrace for pid %d\n", p->pid);
+          if (bt_stack(p, NULL, NULL))
+             return 1;
+       }
+    } while_each_thread(g, p);
+    return 1;
+}
+
+unsigned long backTracePID(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	          DEBUGGER_PARSER *parser)
+{
+    int pid;
+    unsigned long valid = 0;
+    struct task_struct *p, *g;
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ')
+       cmd++;
+
+    pid = EvaluateNumericExpression(stackFrame, &cmd, &valid);
+    if (valid)
+    {
+       do_each_thread(g, p)
+       {
+          if (p && (p->pid == pid))
+          {
+             DBGPrint("Stack backtrace for pid %d\n", p->pid);
+             bt_stack(p, NULL, NULL);
+             return 1;
+          }
+       } while_each_thread(g, p);
+       DBGPrint("No process with pid %d found\n", pid);
+    }
+    else
+       DBGPrint("invalid pid entered for backtrace\n");
+
+    return 1;
+
+}
+
+unsigned long backTraceStack(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	             DEBUGGER_PARSER *parser)
+{
+    unsigned long valid = 0, address;
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ')
+       cmd++;
+
+    address = EvaluateExpression(stackFrame, &cmd, &valid);
+    if (valid)
+    {
+       DBGPrint("Stack backtrace for address 0x%08X\n", (unsigned)address);
+       bt_stack(NULL, NULL, (unsigned long *)address);
+       return 1;
+    }
+    else
+    {
+       DBGPrint("Stack backtrace for address 0x%08X\n",
+                (unsigned)GetStackAddress(stackFrame));
+       bt_stack(NULL, NULL, (unsigned long *)GetStackAddress(stackFrame));
+       return 1;
+    }
+    return 1;
+}
+
+void DisplayASCIITable(void)
+{
+
+    register unsigned long i;
+    union bhex
+    {
+       unsigned int i;
+       struct btemp {
+	     unsigned one : 1;
+	     unsigned two : 1;
+	     unsigned three : 1;
+	     unsigned four : 1;
+	     unsigned five : 1;
+	     unsigned six : 1;
+	     unsigned seven : 1;
+	     unsigned eight : 1;
+       } b;
+    } val;
+
+    DBGPrint("ASCII Table\n");
+    for (i = 0; i < 256; i++)
+    {
+       val.i = i;
+       switch (i)
+       {
+
+	  case 0:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | NULL  |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six,
+                (int)val.b.five,  (int)val.b.four, (int)val.b.three,
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 8:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | BKSP  |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six,
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three,
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 9:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | TAB   |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six,
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three,
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 10:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | <CR>  |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six,
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three,
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 13:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | <LF>  |", (int)i, (unsigned)i,
+		(int)val.b.eight, (int)val.b.seven, (int)val.b.six,
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three,
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  case 32:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  | SPACE |", (int)i, (unsigned)i,
+	        (int)val.b.eight, (int)val.b.seven, (int)val.b.six,
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three,
+                (int)val.b.two, (int)val.b.one)) return;
+	     break;
+
+	  default:
+	     if (DBGPrint("|  %3i  |  (0x%02X)  |  (%1i%1i%1i%1i%1i%1i%1i%1ib)  |  %c    |", (int)i, (unsigned)i,
+	        (int)val.b.eight, (int)val.b.seven, (int)val.b.six,
+                (int)val.b.five,  (int)val.b.four,  (int)val.b.three,
+                (int)val.b.two, (int)val.b.one, (unsigned char) i)) return;
+	     break;
+
+       }
+       if (DBGPrint("\n")) return;
+    }
+
+}
+
+#if defined(CONFIG_MODULES)
+
+/* LSMOD, .M */
+
+unsigned long listModulesHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint(".M                       - list loaded modules\n");
+    DBGPrint("lsmod                    - list loaded modules\n");
+    DBGPrint("rmmod <name>             - unload module\n");
+    return 1;
+}
+
+unsigned long listModules(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	          DEBUGGER_PARSER *parser)
+{
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ')
+       cmd++;
+
+    if (*cmd)
+       mdb_modules(cmd, DBGPrint);
+    else
+       mdb_modules(NULL, DBGPrint);
+    return 1;
+}
+
+unsigned long unloadModule(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	           DEBUGGER_PARSER *parser)
+{
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ')
+       cmd++;
+
+    DBGPrint("Module unload unsupported in this version\n");
+    return 0;
+}
+
+#endif
+
+/* REBOOT */
+
+unsigned long rebootSystemHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("reboot                   - reboot host system\n");
+    DBGPrint("reboot force             - reboot from current processor\n");
+    return 1;
+}
+
+
+unsigned long rebootSystem(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	     DEBUGGER_PARSER *parser)
+{
+    extern void machine_emergency_restart(void);
+
+    cmd = &cmd[parser->debugCommandNameLength];
+    while (*cmd && *cmd == ' ')
+       cmd++;
+
+    if (!strnicmp(cmd, "force", 5))
+    {
+       machine_emergency_restart();
+       return 1;
+    }
+
+    if (!get_processor_id())
+       machine_emergency_restart();
+    else
+       DBGPrint("not on processor 0.  try 'reboot force' or switch to \n"
+                "processor 0 with 'cpu 0' or 'nmi 0' commands and issue\n"
+                "the reboot command again\n");
+    return 1;
+}
+
+/* SECTIONS, .S */
+
+unsigned long displaySectionsHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("sections                 - display kernel/module sections\n");
+    DBGPrint(".s                       - display kernel/module sections\n");
+    return 1;
+}
+
+unsigned long displaySections(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     DBGPrint("\n");
+     return 1;
+}
+
+/* PS, .P */
+
+unsigned long displayKernelProcessHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    if (commandLine) {}
+    if (parser) {}
+
+    DBGPrint("ps <addr>                - display kernel processes\n");
+    DBGPrint(".p <addr>                - display kernel processes\n");
+    return 1;
+}
+
+unsigned long displayKernelProcess(unsigned char *cmd,
+		           StackFrame *stackFrame, unsigned long Exception,
+		           DEBUGGER_PARSER *parser)
+{
+     struct task_struct *p, *g;
+     unsigned long valid = 0;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (*cmd)
+     {
+        p = (struct task_struct *)EvaluateExpression(stackFrame, &cmd, &valid);
+        if (valid && p)
+        {
+	   DBGPrint("%-*s      Pid   Parent [*] State %-*s Command\n",
+		     (int)(2*sizeof(void *))+2, "Task Addr",
+		     (int)(2*sizeof(void *))+2, "Thread");
+
+	   if (DBGPrint("0x%p %8d %8d  %d    %c  0x%p %s\n",
+	       (void *)p, p->pid, p->real_parent->pid,
+               p == current,
+               (p->state == 0) ? 'R' :
+	       (p->state < 0) ? 'U' :
+	       (p->state & TASK_UNINTERRUPTIBLE) ? 'D' :
+	       (p->state & TASK_STOPPED) ? 'T' :
+	       (p->state & TASK_TRACED) ? 'C' :
+	       (p->exit_state & EXIT_ZOMBIE) ? 'Z' :
+	       (p->exit_state & EXIT_DEAD) ? 'E' :
+	       (p->state & TASK_INTERRUPTIBLE) ? 'S' : '?',
+	       (void *)(&p->thread),
+	        p->comm))
+                  return 1;
+            return 1;
+        }
+        DBGPrint("invalid task address\n");
+        return 1;
+     }
+     else
+     {
+	DBGPrint("%-*s      Pid   Parent [*] State %-*s Command\n",
+		(int)(2*sizeof(void *))+2, "Task Addr",
+		(int)(2*sizeof(void *))+2, "Thread");
+
+        do_each_thread(g, p)
+        {
+           if (p)
+           {
+	      if (DBGPrint("0x%p %8d %8d  %d    %c  0x%p %s\n",
+		   (void *)p, p->pid, p->real_parent->pid,
+                   p == current,
+                   (p->state == 0) ? 'R' :
+		   (p->state < 0) ? 'U' :
+		   (p->state & TASK_UNINTERRUPTIBLE) ? 'D' :
+		   (p->state & TASK_STOPPED) ? 'T' :
+		   (p->state & TASK_TRACED) ? 'C' :
+		   (p->exit_state & EXIT_ZOMBIE) ? 'Z' :
+		   (p->exit_state & EXIT_DEAD) ? 'E' :
+		   (p->state & TASK_INTERRUPTIBLE) ? 'S' : '?',
+		   (void *)(&p->thread),
+		   p->comm))
+                 return 1;
+           }
+        } while_each_thread(g, p);
+     }
+     return 1;
+
+}
+
+unsigned long ascTableHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("a                        - display ASCII Table\n");
+    return 1;
+}
+
+/* A */
+
+unsigned long displayASCTable(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser)
+{
+     DisplayASCIITable();
+     return 1;
+}
+
+typedef struct _LINE_INFO
+{
+   unsigned long SourcePresent;
+   unsigned char *SourceLine;
+   unsigned char *ModuleName;
+   unsigned long LineNumber;
+} LINE_INFO;
+
+void GetLineInfoFromValue(unsigned long value, LINE_INFO *lineInfo, unsigned long *exact)
+{
+    if (exact)
+       *exact = 0;
+
+    if (lineInfo)
+    {
+        lineInfo->SourcePresent = 0;
+        lineInfo->SourceLine = "";
+        lineInfo->ModuleName = "";
+        lineInfo->LineNumber = 0;
+    }
+    return;
+}
+
+unsigned long disassemble(StackFrame *stackFrame, unsigned long p, unsigned long count, unsigned long use)
+{
+    register unsigned long i;
+    unsigned char *symbolName;
+    unsigned char *moduleName;
+    unsigned long exact = 0;
+    extern unsigned long line_info_toggle;
+    LINE_INFO lineInfo;
+    register int c = get_processor_id();
+
+    for (i = 0; i < count; i++)
+    {
+       GetLineInfoFromValue(p, &lineInfo, &exact);
+
+       if (line_info_toggle && exact)
+       {
+	  if (lineInfo.SourcePresent && lineInfo.SourceLine)
+	  {
+	     register unsigned long length = strlen(lineInfo.SourceLine);
+
+	     i = length > 80
+             ? i + 1 + (length / 80)
+             : i + 1;
+
+	     DBGPrint("%s (%s : line %d)\n",
+				 lineInfo.SourceLine, lineInfo.ModuleName,
+				 lineInfo.LineNumber);
+
+	  }
+	  else if (line_info_toggle && lineInfo.LineNumber)
+	  {
+	     i++;
+	     DBGPrint("file %s  line %d\n",
+				 lineInfo.ModuleName, lineInfo.LineNumber);
+	  }
+       }
+
+       if (i >= count && count != 1)
+	  break;
+
+       symbolName = GetSymbolFromValue(p, &symbuf[c][0], MAX_SYMBOL_LEN);
+       if (symbolName)
+       {
+	  i++;
+          moduleName = GetModuleInfoFromSymbolValue(p, &modbuf[c][0],
+                                                    MAX_SYMBOL_LEN);
+          if (moduleName)
+          {
+	     if (DBGPrint("%s|%s:\n", moduleName, symbolName)) return p;
+          }
+          else
+          {
+	     if (DBGPrint("%s:\n", symbolName)) return p;
+          }
+       }
+       if (i >= count && count != 1)
+	  break;
+
+       if (unassemble(stackFrame, p, use, &p)) return p;
+    }
+
+    return p;
+
+}
+
+unsigned long dumpSearchResults(unsigned char *p, unsigned long count)
+{
+
+   unsigned char *symbolName;
+   unsigned char *moduleName;
+   register unsigned long i, r, total;
+   unsigned char ch;
+   register int c = get_processor_id();
+
+   if (DBGPrint("           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n"))
+      return 1;
+
+   for (r = 0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((unsigned long) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((unsigned long) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+         {
+	    if (DBGPrint("%s|%s:\n", moduleName, symbolName)) return 1;
+         }
+         else
+         {
+	    if (DBGPrint("%s:\n", symbolName)) return 1;
+         }
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (total = 0, i = 0; i < 16; i++, total++)
+      {
+	 DBGPrint(" %02X", (unsigned) mdb_getword((unsigned long)&p[i], 1));
+      }
+      DBGPrint("  ");
+      for (i = 0; i < total; i++)
+      {
+         ch = mdb_getword((unsigned long)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      if (DBGPrint("\n")) return 1;
+
+      p = (void *)((unsigned long) p + (unsigned long) total);
+   }
+   return 0;
+
+}
+
+unsigned char *dump(unsigned char *p, unsigned long count)
+{
+
+   unsigned char *symbolName;
+   unsigned char *moduleName;
+   register unsigned long i, r, total;
+   unsigned char ch;
+   register int c = get_processor_id();
+
+   DBGPrint("           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n");
+
+   for (r = 0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((unsigned long) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((unsigned long) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+	    DBGPrint("%s|%s:\n", moduleName, symbolName);
+         else
+	    DBGPrint("%s:\n", symbolName);
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (total = 0, i = 0; i < 16; i++, total++)
+      {
+	 DBGPrint(" %02X", (unsigned) mdb_getword((unsigned long)&p[i], 1));
+      }
+      DBGPrint("  ");
+      for (i = 0; i < total; i++)
+      {
+         ch = mdb_getword((unsigned long)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((unsigned long) p + (unsigned long) total);
+   }
+
+   return p;
+
+}
+
+unsigned long dumpWordSearchResults(unsigned char *p, unsigned long count)
+{
+
+   register int i, r;
+   unsigned short *wp;
+   unsigned char *symbolName;
+   unsigned char *moduleName;
+   unsigned char ch;
+   register int c = get_processor_id();
+
+   wp = (unsigned short *) p;
+   for (r = 0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((unsigned long) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((unsigned long) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+         {
+	    if (DBGPrint("%s|%s:\n", moduleName, symbolName)) return 1;
+         }
+         else
+         {
+	    if (DBGPrint("%s:\n", symbolName)) return 1;
+         }
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (i = 0; i < (16 / 2); i++)
+      {
+	 DBGPrint(" %04X", (unsigned) mdb_getword((unsigned long)&wp[i], 2));
+      }
+      DBGPrint("  ");
+      for (i = 0; i < 16; i++)
+      {
+         ch = mdb_getword((unsigned long)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      if (DBGPrint("\n")) return 1;
+
+      p = (void *)((unsigned long) p + (unsigned long) 16);
+      wp = (unsigned short *) p;
+   }
+
+   return 0;
+
+}
+
+unsigned char *dumpWord(unsigned char *p, unsigned long count)
+{
+
+   register int i, r;
+   unsigned short *wp;
+   unsigned char *symbolName;
+   unsigned char *moduleName;
+   unsigned char ch;
+   register int c = get_processor_id();
+
+   wp = (unsigned short *) p;
+   for (r = 0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((unsigned long) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((unsigned long) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+	    DBGPrint("%s|%s:\n", moduleName, symbolName);
+         else
+	    DBGPrint("%s:\n", symbolName);
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (i = 0; i < (16 / 2); i++)
+      {
+	 DBGPrint(" %04X", (unsigned) mdb_getword((unsigned long)&wp[i], 2));
+      }
+      DBGPrint("  ");
+      for (i = 0; i < 16; i++)
+      {
+         ch = mdb_getword((unsigned long)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((unsigned long) p + (unsigned long) 16);
+      wp = (unsigned short *) p;
+   }
+
+   return p;
+
+}
+
+unsigned long dumpDoubleSearchResults(unsigned char *p, unsigned long count)
+{
+
+   register int i, r;
+   unsigned long *lp;
+   unsigned char *symbolName;
+   unsigned char *moduleName;
+   unsigned char ch;
+   register int c = get_processor_id();
+
+   lp = (unsigned long *) p;
+
+   for (r = 0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((unsigned long) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((unsigned long) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+         {
+	    if (DBGPrint("%s|%s:\n", moduleName, symbolName)) return 1;
+         }
+         else
+         {
+	    if (DBGPrint("%s:\n", symbolName)) return 1;
+         }
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (i = 0; i < (16 / 4); i++)
+      {
+	 DBGPrint(" %08X", (unsigned) mdb_getword((unsigned long)&lp[i], 4));
+      }
+      DBGPrint("  ");
+      for (i = 0; i < 16; i++)
+      {
+         ch = mdb_getword((unsigned long)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      if (DBGPrint("\n")) return 1;
+
+      p = (void *)((unsigned long) p + (unsigned long) 16);
+      lp = (unsigned long *) p;
+   }
+
+   return 0;
+
+}
+
+unsigned char *dumpDouble(unsigned char *p, unsigned long count)
+{
+
+   register int i, r;
+   unsigned long *lp;
+   unsigned char *symbolName;
+   unsigned char *moduleName;
+   unsigned char ch;
+   register int c = get_processor_id();
+
+   lp = (unsigned long *) p;
+
+   for (r = 0; r < count; r++)
+   {
+      symbolName = GetSymbolFromValue((unsigned long) p, &symbuf[c][0], MAX_SYMBOL_LEN);
+      if (symbolName)
+      {
+         moduleName = GetModuleInfoFromSymbolValue((unsigned long) p, &modbuf[c][0],
+                                                   MAX_SYMBOL_LEN);
+         if (moduleName)
+	    DBGPrint("%s|%s:\n", moduleName, symbolName);
+         else
+	    DBGPrint("%s:\n", symbolName);
+	 if (r++ >= count && count != 1)
+	    break;
+      }
+      DBGPrint("%08X ", (unsigned) p);
+      for (i = 0; i < (16 / 4); i++)
+      {
+	 DBGPrint(" %08X", (unsigned) mdb_getword((unsigned long)&lp[i], 4));
+      }
+      DBGPrint("  ");
+      for (i = 0; i < 16; i++)
+      {
+         ch = mdb_getword((unsigned long)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((unsigned long) p + (unsigned long) 16);
+      lp = (unsigned long *) p;
+   }
+
+   return p;
+
+}
+
+unsigned char *dumpLinkedList(unsigned char *p, unsigned long count, unsigned long offset)
+{
+
+   register int i, r;
+   unsigned long *lp;
+   unsigned char ch;
+
+   lp = (unsigned long *) p;
+
+   DBGPrint("           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n");
+   DBGPrint("Linked List -> [%08X + %X] = %08X\n", (unsigned)lp,
+            (unsigned)offset,
+            (unsigned)mdb_getword((unsigned long)((unsigned long)lp + (unsigned long)offset), 4));
+
+   for (r = 0; r < count; r++)
+   {
+      DBGPrint("%08X ", (unsigned) p);
+      for (i = 0; i < 16; i++)
+      {
+	 DBGPrint(" %02X", (unsigned) mdb_getword((unsigned long)&p[i], 1));
+      }
+      DBGPrint("  ");
+      for (i = 0; i < 16; i++)
+      {
+         ch = mdb_getword((unsigned long)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((unsigned long) p + (unsigned long) 16);
+   }
+
+   return (unsigned char *)(mdb_getword((unsigned long)((unsigned long)lp + (unsigned long)offset), 4));
+
+}
+
+unsigned char *dumpDoubleStack(StackFrame *stackFrame, unsigned char *p, unsigned long count)
+{
+
+   register int i, r;
+   unsigned long *lp;
+   unsigned char ch;
+
+   lp = (unsigned long *) p;
+
+   DBGPrint("Stack = %04lX:%08X\n",
+            (unsigned long)GetStackSegment(stackFrame),
+            (unsigned)p);
+
+   for (r = 0; r < count; r++)
+   {
+      DBGPrint("%04X:", (unsigned) GetStackSegment(stackFrame));
+      DBGPrint("%08X ", (unsigned) p);
+      for (i = 0; i < (16 / 4); i++)
+      {
+	 DBGPrint(" %08X", (unsigned) mdb_getword((unsigned long)&lp[i], 4));
+      }
+      DBGPrint("  ");
+      for (i = 0; i < 16; i++)
+      {
+         ch = mdb_getword((unsigned long)&p[i], 1);
+
+	 if (ch < 32 || ch > 126) DBGPrint(".");
+	 else DBGPrint("%c", ch);
+      }
+      DBGPrint("\n");
+
+      p = (void *)((unsigned long) p + (unsigned long) 16);
+      lp = (unsigned long *) p;
+   }
+
+   return p;
+
+}
+
+unsigned char *dumpStack(StackFrame *stackFrame, unsigned char *p, unsigned long count)
+{
+
+   register int r;
+   unsigned long *lp;
+
+   lp = (unsigned long *) p;
+
+   DBGPrint("Stack = %04X:%08X\n", (unsigned)GetStackSegment(stackFrame),
+            (unsigned)p);
+
+   for (r = 0; r < count; r++)
+   {
+      DBGPrint("%08X ", (unsigned) p);
+      DBGPrint("%08X ", (unsigned) mdb_getword((unsigned long)lp, 4));
+      if (DisplayClosestSymbol(mdb_getword((unsigned long)lp, 4)))
+         DBGPrint("\n");
+
+      p = (void *)((unsigned long) p + (unsigned long) 4);
+      lp = (unsigned long *) p;
+   }
+
+   return p;
+
+}
+
+unsigned long displayToggleHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint(".tc                      - toggles control registers (ON | OFF)\n");
+    DBGPrint(".tn                      - toggles coprocessor registers (ON | OFF)\n");
+    DBGPrint(".ts                      - toggles segment registers (ON | OFF)\n");
+    DBGPrint(".tg                      - toggles general registers (ON | OFF)\n");
+    DBGPrint(".tr                      - toggles display of break reason (ON | OFF)\n");
+    DBGPrint(".td                      - toggles full dereference display (ON | OFF)\n");
+    DBGPrint(".tl                      - toggles source line display (ON | OFF)\n");
+    DBGPrint(".tu                      - toggles unasm debug display (ON | OFF)\n");
+    DBGPrint(".t or .t <address>       - display task state segment (tss)\n");
+    return 1;
+}
+
+/* .TU */
+
+unsigned long ProcessTUToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     (debug_deref)
+     ? (debug_deref = 0)
+     : (debug_deref = 1);
+     DBGPrint("toggle unasm debug display (%s)\n",
+				  debug_deref ? "ON" : "OFF");
+     return 1;
+}
+
+/* .TD */
+
+unsigned long ProcessTDToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     (full_deref_toggle)
+     ? (full_deref_toggle = 0)
+     : (full_deref_toggle = 1);
+     DBGPrint("toggle full dereferencing info (%s) \n",
+					    full_deref_toggle ? "ON" : "OFF");
+     return 1;
+}
+
+
+/* .TL */
+
+unsigned long ProcessTLToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     (line_info_toggle)
+     ? (line_info_toggle = 0)
+     : (line_info_toggle = 1);
+     DBGPrint("toggle source line info (%s) \n",
+					    line_info_toggle ? "ON" : "OFF");
+     return 1;
+
+}
+
+/* .TG */
+
+unsigned long ProcessTGToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     (general_toggle)
+     ? (general_toggle = 0)
+     : (general_toggle = 1);
+     DBGPrint("toggle general registers (%s) \n",
+					    general_toggle ? "ON" : "OFF");
+     return 1;
+
+}
+
+/* .TC */
+
+unsigned long ProcessTCToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     (control_toggle)
+     ? (control_toggle = 0)
+     : (control_toggle = 1);
+     DBGPrint("toggle control registers (%s) \n",
+					    control_toggle ? "ON" : "OFF");
+     return 1;
+
+}
+
+/* .TN */
+
+unsigned long ProcessTNToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     (numeric_toggle)
+     ? (numeric_toggle = 0)
+     : (numeric_toggle = 1);
+     DBGPrint("toggle coprocessor registers (%s) \n",
+					    numeric_toggle ? "ON" : "OFF");
+     return 1;
+
+}
+
+/* .TR */
+
+unsigned long ProcessTRToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     (reason_toggle)
+     ? (reason_toggle = 0)
+     : (reason_toggle = 1);
+     DBGPrint("toggle display break reason (%s) \n",
+					    reason_toggle ? "ON" : "OFF");
+     return 1;
+
+}
+
+/* .TS */
+
+unsigned long ProcessTSToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     (segment_toggle)
+     ? (segment_toggle = 0)
+     : (segment_toggle = 1);
+     DBGPrint("toggle segment registers (%s) \n",
+					    segment_toggle ? "ON" : "OFF");
+     return 1;
+
+}
+
+unsigned long displayDebuggerVersionHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint(".v                       - display version info\n");
+    return 1;
+}
+
+/* .V */
+
+unsigned long DisplayDebuggerVersion(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     extern unsigned long MajorVersion;
+     extern unsigned long MinorVersion;
+     extern unsigned long BuildVersion;
+
+     DBGPrint("Merkey's Kernel Debugger\n");
+     DBGPrint("v%02d.%02d.%02d\n",
+              (int)MajorVersion, (int)MinorVersion, (int)BuildVersion);
+     DBGPrint("Copyright (C) 2008 Jeffrey Vernon Merkey.  "
+              "All Rights Reserved.\n");
+
+     return 1;
+}
+
+/* .Z */
+
+unsigned long displaySymbolsHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint(".z <name>                  - display symbol info\n");
+    return 1;
+}
+
+unsigned long displaySymbols(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     extern void DumpOSSymbolTableMatch(unsigned char *);
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (*cmd)
+	DumpOSSymbolTableMatch(cmd);
+     else
+	DumpOSSymbolTableMatch(NULL);
+
+     return 1;
+}
+
+/* LCPU */
+
+unsigned long listProcessors(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register int i;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     DBGPrint("Current Processor: %d\n", get_processor_id());
+     DBGPrint("Active Processors: \n");
+     for (i = 0; i < MAX_PROCESSORS; i++)
+     {
+        if (cpu_online(i))
+	   DBGPrint("   Processor %d\n", i);
+     }
+     return 1;
+
+}
+
+unsigned long clearScreenHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("cls                      - clear the screen\n");
+    return 1;
+}
+
+/* CLS */
+
+unsigned long clearDebuggerScreen(unsigned char *cmd,
+			 StackFrame *stackFrame, unsigned long Exception,
+			 DEBUGGER_PARSER *parser)
+{
+     extern void ClearScreen(void);
+
+     ClearScreen();
+     return 1;
+
+}
+
+unsigned long SearchMemoryHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("sb                       - search for bytes at address\n");
+    DBGPrint("sw                       - search for words at address\n");
+    DBGPrint("sd                       - search for dwords at address\n");
+    return 1;
+}
+
+/* S */
+
+/* use local storage and reduce stack space use.  these functions are always
+  called single threaded from the console */
+
+unsigned char s_changeBuffer[16];
+unsigned char b_searchBuffer[16];
+unsigned char b_copyBuffer[16];
+unsigned short w_searchBuffer[16];
+unsigned short w_copyBuffer[16];
+unsigned long d_searchBuffer[16];
+unsigned long d_copyBuffer[16];
+
+unsigned long SearchMemory(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     unsigned char *changeBuffer = s_changeBuffer;
+     unsigned char *searchBuffer = b_searchBuffer;
+     unsigned char *copyBuffer = b_copyBuffer;
+     unsigned long maxlen = sizeof(searchBuffer);
+     register unsigned char *changeB;
+     unsigned char *pB;
+     register unsigned long address, r, value, count, len, i;
+     unsigned long valid, EndingAddress = (unsigned long)high_memory;
+     register int key;
+     extern int mdb_getkey(void);
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     memset((unsigned long *)searchBuffer, 0, sizeof(searchBuffer));
+     count = 0;
+     changeB = (unsigned char *) searchBuffer;
+     changeBuffer[0] = '\0';
+     DBGPrint("enter bytes to search for, '.' to end input\n");
+     while ((changeBuffer[0] != '.') && (count < maxlen))
+     {
+	for (r = 0; r < 8; r++)
+	{
+	   DBGPrint("0x");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 4);
+
+	   if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.'))
+	      break;
+
+	   pB = (unsigned char *) &changeBuffer[0];
+	   len = strlen(pB);
+
+	   for (i = 0; i < len; i++)
+	      DBGPrint("\b");
+
+	   value = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      *changeB = (unsigned char) value;
+	   DBGPrint("%02X ", (unsigned char) *changeB);
+
+	   changeB++;
+	   if (count++ > maxlen)
+	      break;
+	}
+	if (DBGPrint("\n")) return 1;
+     }
+
+     if (count)
+     {
+	DBGPrint("enter start address for search:  ");
+	ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	pB = (unsigned char *) &changeBuffer[0];
+	address = EvaluateExpression(0, &pB, &valid);
+	if (valid)
+	{
+	   register unsigned long temp;
+
+	   DBGPrint("start address = [%08X]\n", (unsigned)address);
+	   DBGPrint("enter ending address for search:  ");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	   pB = (unsigned char *) &changeBuffer[0];
+	   temp = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      EndingAddress = temp;
+
+	   DBGPrint("\nsearching memory from 0x%08X to 0x%08X\n",
+                    (unsigned)address, (unsigned)EndingAddress);
+	   while (address < EndingAddress)
+	   {
+              read_memory((void *)address, copyBuffer, count);
+	      if (!memcmp(searchBuffer, copyBuffer, count))
+	      {
+		 if (DBGPrint("match at address [%08X]\n",
+                     (unsigned)address)) return 1;
+		 if (dumpSearchResults((unsigned char *)address, 4)) return 1;
+		 if (DBGPrint("searching\n")) return 1;
+	      }
+	      address++;
+	      if (!(address % 0x100000))
+	      {
+		  if (DBGPrint("searching memory at address 0x%08X ..."
+                        " Q or q to abort - any key to proceed\n",
+                                (unsigned)address)) return 1;
+                  key = mdb_getkey();
+                  if (((char)key == 'Q') || ((char)key == 'q'))
+                     break;
+	      }
+	   }
+	   if (DBGPrint("search completed.\n")) return 1;
+	   return 1;
+	}
+	if (DBGPrint("invalid start address\n")) return 1;
+	return 1;
+     }
+     if (DBGPrint("no search pattern\n")) return 1;
+     return 1;
+
+}
+
+/* SB */
+
+unsigned long SearchMemoryB(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     unsigned char *changeBuffer = s_changeBuffer;
+     unsigned char *searchBuffer = b_searchBuffer;
+     unsigned char *copyBuffer = b_copyBuffer;
+     unsigned long maxlen = sizeof(searchBuffer);
+     register unsigned char *changeB;
+     unsigned char *pB;
+     register unsigned long address, r, value, count, len, i;
+     unsigned long valid, EndingAddress = (unsigned long)high_memory;
+     register int key;
+     extern int mdb_getkey(void);
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     memset((unsigned long *)searchBuffer, 0, sizeof(searchBuffer));
+     count = 0;
+     changeB = (unsigned char *) searchBuffer;
+     changeBuffer[0] = '\0';
+     DBGPrint("enter bytes to search for, '.' to end input\n");
+     while (changeBuffer[0] != '.' && count < maxlen)
+     {
+	for (r = 0; r < 8; r++)
+	{
+	   DBGPrint("0x");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 4);
+
+	   if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.'))
+	      break;
+
+	   pB = (unsigned char *) &changeBuffer[0];
+	   len = strlen(pB);
+	   for (i = 0; i < len; i++)
+	      DBGPrint("\b");
+
+	   value = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      *changeB = (unsigned char) value;
+	   DBGPrint("%02X ", (unsigned char) *changeB);
+
+	   changeB++;
+	   if (count++ > maxlen)
+	      break;
+	}
+	if (DBGPrint("\n")) return 1;
+     }
+
+     if (count)
+     {
+	DBGPrint("enter start address for search:  ");
+	ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	pB = (unsigned char *) &changeBuffer[0];
+	address = EvaluateExpression(0, &pB, &valid);
+	if (valid)
+	{
+	   register unsigned long temp;
+
+	   DBGPrint("start address = [%08X]\n", (unsigned)address);
+
+	   DBGPrint("enter ending address for search:  ");
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	   pB = (unsigned char *) &changeBuffer[0];
+	   temp = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      EndingAddress = temp;
+
+	   DBGPrint("\nsearching memory from 0x%08X to 0x%08X\n",
+                    (unsigned)address, (unsigned)EndingAddress);
+	   while (address < EndingAddress)
+	   {
+              read_memory((void *)address, copyBuffer, count);
+	      if (!memcmp(searchBuffer, copyBuffer, count))
+	      {
+		 if (DBGPrint("match at address [%08X]\n",
+                     (unsigned)address)) return 1;
+		 if (dumpSearchResults((unsigned char *)address, 4)) return 1;
+		 if (DBGPrint("searching\n")) return 1;
+	      }
+	      address++;
+	      if (!(address % 0x100000))
+	      {
+		 if (DBGPrint("searching memory at address 0x%08X ..."
+                        " Q or q to abort - any key to proceed\n",
+                              (unsigned)address)) return 1;
+                 key = mdb_getkey();
+                 if (((char)key == 'Q') || ((char)key == 'q'))
+                    break;
+	      }
+	   }
+	   if (DBGPrint("search completed.\n")) return 1;
+	   return 1;
+	}
+	if (DBGPrint("invalid start address\n")) return 1;
+	return 1;
+     }
+     if (DBGPrint("no search pattern\n")) return 1;
+     return 1;
+}
+
+/* SW */
+
+unsigned long SearchMemoryW(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     unsigned char *changeBuffer = s_changeBuffer;
+     unsigned short *searchBuffer = w_searchBuffer;
+     unsigned short *copyBuffer = w_copyBuffer;
+     unsigned long maxlen = sizeof(searchBuffer) / sizeof(unsigned short);
+     register unsigned short *changeW;
+     unsigned char *pB;
+     register unsigned long address, r, value, count, len, i;
+     unsigned long valid, EndingAddress = (unsigned long)high_memory;
+     register int key;
+     extern int mdb_getkey(void);
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     memset((unsigned long *)searchBuffer, 0, sizeof(searchBuffer));
+     count = 0;
+     changeW = (unsigned short *) searchBuffer;
+     changeBuffer[0] = '\0';
+     DBGPrint("enter words to search for, '.' to end input\n");
+     while (changeBuffer[0] != '.' && count < maxlen)
+     {
+	for (r = 0; r < 4; r++)
+	{
+	   DBGPrint("0x");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 6);
+
+	   if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.') ||
+	       (changeBuffer[2] == '.') || (changeBuffer[3] == '.'))
+	      break;
+
+	   pB = (unsigned char *) &changeBuffer[0];
+	   len = strlen(pB);
+	   for (i = 0; i < len; i++)
+	      DBGPrint("\b");
+
+	   value = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      *changeW = value;
+	   DBGPrint("%04X ", *changeW);
+
+	   changeW++;
+	   if (count++ > maxlen)
+	      break;
+	}
+	if (DBGPrint("\n")) return 1;
+     }
+
+     if (count)
+     {
+	DBGPrint("enter start address for search:  ");
+	ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	pB = (unsigned char *) &changeBuffer[0];
+	address = EvaluateExpression(0, &pB, &valid);
+	if (valid)
+	{
+	   register unsigned long temp;
+
+	   DBGPrint("start address = [%08X]\n", (unsigned)address);
+
+	   DBGPrint("enter ending address for search:  ");
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	   pB = (unsigned char *) &changeBuffer[0];
+	   temp = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      EndingAddress = temp;
+
+	   DBGPrint("searching memory from 0x%08X to 0x%08X\n",
+                    (unsigned)address, (unsigned)EndingAddress);
+	   while (address < EndingAddress)
+	   {
+              read_memory((void *)address, copyBuffer, count * sizeof(unsigned short));
+	      if (!memcmp(searchBuffer, copyBuffer, count * sizeof(unsigned short)))
+	      {
+		 if (DBGPrint("match at address [%08X]\n",
+                     (unsigned)address)) return 1;
+		 if (dumpWordSearchResults((unsigned char *)address, 4))
+                     return 1;
+		 if (DBGPrint("searching\n")) return 1;;
+	      }
+	      address++;
+	      if (!(address % 0x100000))
+	      {
+		 if (DBGPrint("searching memory at address 0x%08X ..."
+                        " Q or q to abort - any key to proceed\n",
+                              (unsigned)address)) return 1;
+                  key = mdb_getkey();
+                  if (((char)key == 'Q') || ((char)key == 'q'))
+                     break;
+	      }
+	   }
+	   if (DBGPrint("search completed.\n")) return 1;
+	   return 1;
+	}
+	if (DBGPrint("invalid start address\n")) return 1;
+	return 1;
+     }
+     if (DBGPrint("no search pattern\n")) return 1;
+     return 1;
+}
+
+/* SD */
+
+unsigned long SearchMemoryD(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register unsigned char *changeBuffer = s_changeBuffer;
+     register unsigned long *searchBuffer = d_searchBuffer;
+     register unsigned long *copyBuffer = d_copyBuffer;
+     register unsigned long maxlen = sizeof(searchBuffer) / sizeof(unsigned long);
+     register unsigned long *changeD;
+     unsigned char *pB;
+     register unsigned long address, r, value, count, len, i;
+     unsigned long valid, EndingAddress = (unsigned long)high_memory;
+     register int key;
+     extern int mdb_getkey(void);
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     memset((unsigned long *)searchBuffer, 0, sizeof(searchBuffer));
+     count = 0;
+     changeD = (unsigned long *) searchBuffer;
+     changeBuffer[0] = '\0';
+     DBGPrint("enter dwords to search for, '.' to end input\n");
+     while (changeBuffer[0] != '.' && count < maxlen)
+     {
+	for (r = 0; r < 2; r++)
+	{
+	   DBGPrint("0x");
+
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 8);
+
+	   if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.') ||
+	       (changeBuffer[2] == '.') || (changeBuffer[3] == '.') ||
+	       (changeBuffer[4] == '.') || (changeBuffer[5] == '.') ||
+	       (changeBuffer[6] == '.') || (changeBuffer[7] == '.'))
+	      break;
+
+	   pB = (unsigned char *) &changeBuffer[0];
+	   len = strlen(pB);
+	   for (i = 0; i < len; i++)
+	      DBGPrint("\b");
+
+	   value = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      *changeD = value;
+	   DBGPrint("%08X ", (unsigned)*changeD);
+
+	   changeD++;
+	   if (count++ > maxlen)
+	      break;
+	}
+	if (DBGPrint("\n")) return 1;
+     }
+
+     if (count)
+     {
+	DBGPrint("enter start address for search:  ");
+	ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	pB = (unsigned char *) &changeBuffer[0];
+	address = EvaluateExpression(0, &pB, &valid);
+	if (valid)
+	{
+	   register unsigned long temp;
+
+	   DBGPrint("start address = [%08X]\n", (unsigned)address);
+
+	   DBGPrint("enter ending address for search:  ");
+	   ScreenInputFromKeyboard(&changeBuffer[0], 0, 16);
+	   pB = (unsigned char *) &changeBuffer[0];
+	   temp = EvaluateExpression(0, &pB, &valid);
+	   if (valid)
+	      EndingAddress = temp;
+
+	   DBGPrint("searching memory from 0x%08X to 0x%08X\n",
+                    (unsigned)address, (unsigned)EndingAddress);
+	   while (address < EndingAddress)
+	   {
+              read_memory((void *)address, copyBuffer, count * sizeof(unsigned long));
+	      if (!memcmp(searchBuffer, copyBuffer, count * sizeof(unsigned long)))
+	      {
+		 if (DBGPrint("match at address [%08X]\n",
+                     (unsigned)address)) return 1;
+		 if (dumpDoubleSearchResults((unsigned char *)address, 4))
+                     return 1;
+		 if (DBGPrint("searching\n")) return 1;
+	      }
+	      address++;
+	      if (!(address % 0x100000))
+	      {
+		 if (DBGPrint("searching memory at address 0x%08X ..."
+                        " Q or q to abort - any key to proceed\n",
+                              (unsigned)address)) return 1;
+                  key = mdb_getkey();
+                  if (((char)key == 'Q') || ((char)key == 'q'))
+                     break;
+	      }
+	   }
+	   if (DBGPrint("search completed.\n")) return 1;
+	   return 1;
+	}
+	if (DBGPrint("invalid start address\n")) return 1;
+	return 1;
+     }
+     if (DBGPrint("no search pattern\n")) return 1;
+     return 1;
+}
+
+
+unsigned long changeMemoryHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("c   <address>            - change bytes at address\n");
+    DBGPrint("cb  <address>            - change bytes at address\n");
+    DBGPrint("cw  <address>            - change words at address\n");
+    DBGPrint("cd  <address>            - change dwords at address\n");
+    return 1;
+}
+
+/* CW */
+
+unsigned long changeWordValue(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register unsigned char *changeBuffer = &workbuf[0][0];
+     register unsigned short *changeW, oldW;
+     unsigned char *pB;
+     register unsigned long address, r, value, len, i;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	changeW = (unsigned short *) address;
+	changeBuffer[0] = '\0';
+	DBGPrint("enter new value, <enter> to skip, or '.' to exit\n");
+	while (changeBuffer[0] != '.')
+	{
+	   DBGPrint("[%08X] ", (unsigned)changeW);
+	   for (r = 0; r < 4; r++)
+	   {
+	      oldW = (unsigned short) mdb_getword((unsigned long)changeW, 2);
+	      DBGPrint("(%04X)=", (unsigned) oldW);
+
+              ScreenInputFromKeyboard(&changeBuffer[0], 0, 6);
+
+	      if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.') ||
+		  (changeBuffer[2] == '.') || (changeBuffer[3] == '.'))
+		 break;
+	      pB = (unsigned char *) &changeBuffer[0];
+	      len = strlen(pB);
+
+	      for (i = 0; i < len; i++)
+		 DBGPrint("\b");
+
+	      value = EvaluateExpression(0, &pB, &valid);
+	      if (valid)
+		 mdb_putword((unsigned long)changeW, value, 2);
+	      DBGPrint("%04X ", (unsigned) mdb_getword((unsigned long)changeW, 2));
+	      changeW++;
+	   }
+	   if (DBGPrint("\n")) return 1;
+	}
+	return 1;
+     }
+     DBGPrint("invalid change (word) address\n");
+     return 1;
+}
+
+/* CD */
+
+unsigned long changeDoubleValue(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register unsigned char *changeBuffer = &workbuf[0][0];
+     register unsigned long *changeD, oldD;
+     register unsigned long address, r, value, len, i;
+     unsigned char *pB;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	changeD = (unsigned long *) address;
+	changeBuffer[0] = '\0';
+	DBGPrint("enter new value, <enter> to skip, or '.' to exit\n");
+	while (changeBuffer[0] != '.')
+	{
+	   DBGPrint("[%08X] ", (unsigned)changeD);
+	   for (r = 0; r < 2; r++)
+	   {
+	      oldD = (unsigned long) mdb_getword((unsigned long)changeD, 4);
+	      DBGPrint("(%08X)=", (unsigned) oldD);
+
+	      ScreenInputFromKeyboard(&changeBuffer[0], 0, 8);
+
+	      if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.') ||
+		  (changeBuffer[2] == '.') || (changeBuffer[3] == '.') ||
+		  (changeBuffer[4] == '.') || (changeBuffer[5] == '.') ||
+		  (changeBuffer[6] == '.') || (changeBuffer[7] == '.'))
+		 break;
+
+	      pB = (unsigned char *) &changeBuffer[0];
+	      len = strlen(pB);
+
+	      for (i = 0; i < len; i++)
+		 DBGPrint("\b");
+
+	      value = EvaluateExpression(0, &pB, &valid);
+	      if (valid)
+		 mdb_putword((unsigned long)changeD, value, 4);
+	      DBGPrint("%08X ", (unsigned)mdb_getword((unsigned long)changeD, 4));
+	      changeD++;
+	   }
+	   if (DBGPrint("\n")) return 1;
+	}
+	return 1;
+     }
+     DBGPrint("invalid change (dword) address\n");
+     return 1;
+}
+
+/* CB */
+
+unsigned long changeByteValue(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     unsigned char *changeBuffer = &workbuf[0][0];
+     register unsigned char *changeB, oldB;
+     unsigned char *pB;
+     register unsigned long address, r, value, len, i;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	changeB = (unsigned char *) address;
+	changeBuffer[0] = '\0';
+	DBGPrint("enter new value, <enter> to skip, or '.' to exit\n");
+	while (changeBuffer[0] != '.')
+	{
+	   DBGPrint("[%08X] ", (unsigned)changeB);
+	   for (r = 0; r < 8; r++)
+	   {
+	      oldB = (unsigned char) mdb_getword((unsigned long)changeB, 1);
+	      DBGPrint("(%02X)=", (unsigned) oldB);
+
+	      ScreenInputFromKeyboard(&changeBuffer[0], 0, 4);
+
+	      if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.'))
+		 break;
+
+	      pB = (unsigned char *) &changeBuffer[0];
+	      len = strlen(pB);
+	      for (i = 0; i < len; i++)
+		 DBGPrint("\b");
+
+	      value = EvaluateExpression(0, &pB, &valid);
+	      if (valid)
+		 mdb_putword((unsigned long)changeB, value, 1);
+	      DBGPrint("%02X ", (unsigned char) mdb_getword((unsigned long)changeB, 1));
+	      changeB++;
+	   }
+	   if (DBGPrint("\n")) return 1;
+	}
+	return 1;
+     }
+     DBGPrint("invalid change (byte) address\n");
+     return 1;
+}
+
+/* C */
+
+unsigned long changeDefaultValue(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser)
+{
+     unsigned char *changeBuffer = &workbuf[0][0];
+     register unsigned char *changeB, oldB;
+     unsigned char *pB;
+     register unsigned long address, r, value, len, i;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	changeB = (unsigned char *) address;
+	changeBuffer[0] = '\0';
+	DBGPrint("enter new value, <enter> to skip, or '.' to exit\n");
+	while (changeBuffer[0] != '.')
+	{
+	   DBGPrint("[%08X] ", (unsigned)changeB);
+	   for (r = 0; r < 8; r++)
+	   {
+	      oldB = (unsigned char) mdb_getword((unsigned long)changeB, 1);
+	      DBGPrint("(%02X)=", (unsigned char) oldB);
+
+	      ScreenInputFromKeyboard(&changeBuffer[0], 0, 4);
+
+	      if ((changeBuffer[0] == '.') || (changeBuffer[1] == '.'))
+		 break;
+
+	      pB = (unsigned char *) &changeBuffer[0];
+	      len = strlen(pB);
+
+	      for (i = 0; i < len; i++)
+		 DBGPrint("\b");
+
+	      value = EvaluateExpression(0, &pB, &valid);
+	      if (valid)
+		 mdb_putword((unsigned long)changeB, value, 1);
+	      DBGPrint("%02X ", (unsigned char) mdb_getword((unsigned long)changeB, 1));
+	      changeB++;
+	   }
+	   if (DBGPrint("\n")) return 1;
+	}
+	return 1;
+     }
+     DBGPrint("invalid change (byte) address\n");
+     return 1;
+
+}
+
+unsigned long displayCloseHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("?   <address>            - display closest symbols to <address>\n");
+    return 1;
+
+}
+
+/* ? */
+
+unsigned long displayCloseSymbols(unsigned char *cmd,
+			 StackFrame *stackFrame, unsigned long Exception,
+			 DEBUGGER_PARSER *parser)
+{
+     register unsigned long oldD;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     oldD = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	oldD = GetIP(stackFrame);
+     DisplayClosestSymbol(oldD);
+     return 1;
+
+}
+
+unsigned long debuggerWalkStack(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpStack(stackFrame,
+                          (unsigned char *)lastDumpAddress, lastDisplayLength);
+	return 1;
+     }
+     lastDumpAddress = (unsigned char *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (unsigned char *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpStack(stackFrame, (unsigned char *)lastDumpAddress, displayLength);
+     return 1;
+
+}
+
+unsigned long displayDumpHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("d   <address> <#lines>   - dump memory as bytes\n");
+    DBGPrint("dw  <address> <#lines>   - dump memory as words\n");
+    DBGPrint("dd  <address> <#lines>   - dump memory as double words\n");
+    DBGPrint("dl  <address> <#lines>   - dump linked list\n");
+    DBGPrint("ds  <address> <#lines>   - dump stack\n");
+    DBGPrint("dds <address> <#lines>   - dump stack double word\n");
+    DBGPrint("w   <address>            - display symbols on the stack\n");
+
+    return 1;
+}
+
+/* DL */
+
+unsigned long debuggerDumpLinkedList(unsigned char *cmd,
+			    StackFrame *stackFrame, unsigned long Exception,
+			    DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     extern unsigned char *lastLinkAddress;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastLinkAddress = dumpLinkedList((unsigned char *)lastLinkAddress, lastDisplayLength, 0);
+	return 1;
+     }
+
+     lastLinkAddress = (unsigned char *) EvaluateNumericExpression(stackFrame, &cmd,
+                                                          &valid);
+     if (!valid)
+	lastLinkAddress = (unsigned char *) GetStackAddress(stackFrame);
+
+     displayLength = EvaluateNumericExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+
+     lastLinkAddress = dumpLinkedList((unsigned char *)lastLinkAddress, displayLength, 0);
+
+     return 1;
+
+}
+
+/* DW */
+
+unsigned long debuggerDumpWord(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpWord((unsigned char *)lastDumpAddress, lastDisplayLength);
+	return 1;
+     }
+     lastDumpAddress = (unsigned char *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (unsigned char *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpWord((unsigned char *)lastDumpAddress, displayLength);
+     return 1;
+}
+
+/* DS */
+
+unsigned long debuggerDumpStack(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpStack(stackFrame, (unsigned char *)lastDumpAddress, lastDisplayLength);
+	return 1;
+     }
+     lastDumpAddress = (unsigned char *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (unsigned char *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpStack(stackFrame, (unsigned char *)lastDumpAddress, displayLength);
+     return 1;
+
+}
+
+/* DDS */
+
+unsigned long debuggerDumpDoubleStack(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpDoubleStack(stackFrame, (unsigned char *)lastDumpAddress,
+						    lastDisplayLength);
+	return 1;
+     }
+     lastDumpAddress = (unsigned char *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (unsigned char *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpDoubleStack(stackFrame, (unsigned char *)lastDumpAddress,
+						    displayLength);
+     return 1;
+
+}
+
+/* DD */
+
+unsigned long debuggerDumpDouble(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dumpDouble((unsigned char *)lastDumpAddress, lastDisplayLength);
+	return 1;
+     }
+     lastDumpAddress = (unsigned char *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (unsigned char *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dumpDouble((unsigned char *)lastDumpAddress, displayLength);
+     return 1;
+
+}
+
+/* D */
+
+unsigned long debuggerDumpByte(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastDumpAddress = dump((unsigned char *)lastDumpAddress, lastDisplayLength);
+	return 1;
+     }
+     lastDumpAddress = (unsigned char *) EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	lastDumpAddress = (unsigned char *) GetStackAddress(stackFrame);
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastDumpAddress = dump((unsigned char *)lastDumpAddress, displayLength);
+     return 1;
+
+}
+
+unsigned long displayDisassembleHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("id  <address> <#lines>   - unassemble code (32-bit)\n");
+    DBGPrint("u   <address> <#lines>   - unassemble code (32-bit)\n");
+    DBGPrint("uu  <address> <#lines>   - unassemble code (16-bit)\n");
+    return 1;
+}
+
+/* UU */
+
+unsigned long processDisassemble16(unsigned char *cmd,
+			  StackFrame *stackFrame, unsigned long Exception,
+			  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastUnasmAddress = disassemble(stackFrame, (unsigned long)lastUnasmAddress,
+						    lastDisplayLength, 0);
+	return 1;
+     }
+     lastUnasmAddress = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+     {
+        if (!*cmd)
+	   lastUnasmAddress = GetIP(stackFrame);
+        else
+        {
+           DBGPrint("invalid address for unassemble\n");
+           return 1;
+        }
+     }
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+		     displayLength = 20;
+     lastUnasmAddress = disassemble(stackFrame, (unsigned long)lastUnasmAddress,
+						 displayLength, 0);
+     return 1;
+}
+
+/* U */
+
+unsigned long processDisassemble32(unsigned char *cmd,
+			  StackFrame *stackFrame, unsigned long Exception,
+			  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     if (repeatCommand)
+     {
+	lastUnasmAddress = disassemble(stackFrame, (unsigned long)lastUnasmAddress,
+				       lastDisplayLength, 1);
+	return 1;
+     }
+     lastUnasmAddress = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+     {
+        if (!*cmd)
+	   lastUnasmAddress = GetIP(stackFrame);
+        else
+        {
+           DBGPrint("invalid address for unassemble\n");
+           return 1;
+        }
+     }
+     displayLength = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!displayLength || displayLength > 20)
+	displayLength = 20;
+     lastUnasmAddress = disassemble(stackFrame, (unsigned long)lastUnasmAddress,
+						 displayLength, 1);
+     return 1;
+
+}
diff -Naur linux-2.6.27/debug/mdb/mdb-base.h linux-2.6.27-mdb/debug/mdb/mdb-base.h
--- linux-2.6.27/debug/mdb/mdb-base.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-base.h	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,296 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#ifndef _MDB_BASE_H
+#define _MDB_BASE_H
+
+extern unsigned long enterKeyACC(unsigned long key, void *stackFrame,
+		     ACCELERATOR *accel);
+extern unsigned long activateRegisterDisplayACC(unsigned long key, void *stackFrame,
+		     ACCELERATOR *accel);
+
+extern unsigned long displayDebuggerHelpHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayDebuggerHelp(unsigned char *commandLine,
+			 StackFrame *stackFrame, unsigned long Exception,
+			 DEBUGGER_PARSER *parser);
+
+extern unsigned long ascTableHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayASCTable(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+
+extern unsigned long displayToggleHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTUToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTDToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTLToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTGToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTCToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTNToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTRToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTSToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long ProcessTAToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern unsigned long displayDebuggerVersionHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long DisplayDebuggerVersion(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern unsigned long displayKernelProcessHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayKernelProcess(unsigned char *cmd,
+			  StackFrame *stackFrame, unsigned long Exception,
+			  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayKernelQueueHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayKernelQueue(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser);
+
+extern unsigned long displaySymbolsHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displaySymbols(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser);
+
+extern unsigned long displayLoaderMapHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayLoaderMap(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern unsigned long displayModuleHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayModuleInfo(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayProcessesHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayProcesses(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern unsigned long displayRegistersHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayControlRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser);
+extern unsigned long displayAllRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser);
+extern unsigned long displaySegmentRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser);
+extern unsigned long displayNumericRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser);
+extern unsigned long displayGeneralRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser);
+extern unsigned long displayDefaultRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser);
+
+extern unsigned long displayAPICHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayAPICInfo(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+
+extern unsigned long listProcessors(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser);
+extern unsigned long listProcessorFrame(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser);
+
+extern unsigned long ReasonHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ReasonDisplay(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayMPSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayMPS(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern unsigned long clearScreenHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long clearDebuggerScreen(unsigned char *cmd,
+			 StackFrame *stackFrame, unsigned long Exception,
+			 DEBUGGER_PARSER *parser);
+
+
+extern unsigned long SearchMemoryHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long SearchMemory(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+extern unsigned long SearchMemoryB(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+extern unsigned long SearchMemoryW(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+extern unsigned long SearchMemoryD(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern unsigned long changeMemoryHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long changeWordValue(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+extern unsigned long changeDoubleValue(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+extern unsigned long changeByteValue(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+extern unsigned long changeDefaultValue(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser);
+
+
+extern unsigned long displayCloseHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayCloseSymbols(unsigned char *cmd,
+			 StackFrame *stackFrame, unsigned long Exception,
+			 DEBUGGER_PARSER *parser);
+
+
+extern unsigned long displayINTRHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayInterruptTable(unsigned char *cmd,
+			   StackFrame *stackFrame, unsigned long Exception,
+			   DEBUGGER_PARSER *parser);
+
+
+extern unsigned long viewScreensHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayScreenList(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+
+extern unsigned long displayIOAPICHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayIOAPICInfo(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+
+
+extern unsigned long displayDumpHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long debuggerWalkStack(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+extern unsigned long debuggerDumpLinkedList(unsigned char *cmd,
+			    StackFrame *stackFrame, unsigned long Exception,
+			    DEBUGGER_PARSER *parser);
+extern unsigned long debuggerDumpWord(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+extern unsigned long debuggerDumpStack(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+extern unsigned long debuggerDumpDoubleStack(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser);
+extern unsigned long debuggerDumpDouble(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser);
+extern unsigned long debuggerDumpByte(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+
+extern unsigned long displayDisassembleHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long processDisassemble16(unsigned char *cmd,
+			  StackFrame *stackFrame, unsigned long Exception,
+			  DEBUGGER_PARSER *parser);
+extern unsigned long processDisassemble32(unsigned char *cmd,
+			  StackFrame *stackFrame, unsigned long Exception,
+			  DEBUGGER_PARSER *parser);
+
+extern unsigned long rebootSystemHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long rebootSystem(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	                  DEBUGGER_PARSER *parser);
+
+extern unsigned long displaySectionsHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displaySections(unsigned char *cmd,
+		             StackFrame *stackFrame, unsigned long Exception,
+		             DEBUGGER_PARSER *parser);
+extern unsigned long displayKernelProcessHelp(unsigned char *commandLine,
+                                      DEBUGGER_PARSER *parser);
+extern unsigned long displayKernelProcess(unsigned char *cmd,
+		                  StackFrame *stackFrame, unsigned long Exception,
+		                  DEBUGGER_PARSER *parser);
+extern unsigned long displayProcessorStatusHelp(unsigned char *commandLine,
+                                        DEBUGGER_PARSER *parser);
+extern unsigned long displayProcessorStatus(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long backTraceHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long backTraceAllPID(unsigned char *cmd, StackFrame *stackFrame,
+                             unsigned long Exception, DEBUGGER_PARSER *parser);
+extern unsigned long backTracePID(unsigned char *cmd, StackFrame *stackFrame,
+                             unsigned long Exception, DEBUGGER_PARSER *parser);
+extern unsigned long backTraceStack(unsigned char *cmd, StackFrame *stackFrame,
+                             unsigned long Exception, DEBUGGER_PARSER *parser);
+extern unsigned long timedBreakpointHelp(unsigned char *commandLine,
+                                  DEBUGGER_PARSER *parser);
+extern unsigned long timerBreakpoint(unsigned char *cmd,
+                                     StackFrame *stackFrame,
+                                     unsigned long Exception,
+                                     DEBUGGER_PARSER *parser);
+extern unsigned long timerBreakpointClear(unsigned char *cmd,
+                                          StackFrame *stackFrame,
+                                          unsigned long Exception,
+                                          DEBUGGER_PARSER *parser);
+
+#if defined(CONFIG_MODULES)
+extern unsigned long listModulesHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long listModules(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	                 DEBUGGER_PARSER *parser);
+extern unsigned long unloadModule(unsigned char *cmd, StackFrame *stackFrame, unsigned long Exception,
+	                 DEBUGGER_PARSER *parser);
+#endif
+
+#endif
diff -Naur linux-2.6.27/debug/mdb/mdb.h linux-2.6.27-mdb/debug/mdb/mdb.h
--- linux-2.6.27/debug/mdb/mdb.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb.h	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,54 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#ifndef _MDB_H
+#define _MDB_H
+
+/* screen output function */
+extern int mdb_printf(char *s, ...);
+#define DBGPrint   mdb_printf
+
+/* external entry points used by linux */
+#define DEBUGGER_EXCEPTION        1
+#define NMI_EXCEPTION             2
+#define BREAKPOINT_EXCEPTION      3
+#define GENERAL_PROTECTION       13
+#define PAGE_FAULT_EXCEPTION     14
+#define KEYBOARD_ENTRY           19
+#define SOFTWARE_EXCEPTION       22
+
+/* internal trace messages */
+#define MDB_DEBUG_DEBUGGER       0
+
+#endif
diff -Naur linux-2.6.27/debug/mdb/mdb-ia32-apic.c linux-2.6.27-mdb/debug/mdb/mdb-ia32-apic.c
--- linux-2.6.27/debug/mdb/mdb-ia32-apic.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-ia32-apic.c	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,280 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/uaccess.h>
+#include <linux/nmi.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <linux/io.h>
+#include <linux/clocksource.h>
+
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb.h"
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+
+extern unsigned int io_apic_read(unsigned int apic, unsigned int reg);
+extern int nr_ioapics;
+
+unsigned long apic_directed_nmi(unsigned long cpu)
+{
+    send_IPI_mask(cpumask_of_cpu(cpu), 
+                  APIC_DM_NMI | APIC_INT_LEVELTRIG | APIC_INT_ASSERT);
+    send_IPI_mask(cpumask_of_cpu(cpu), 
+                  APIC_DM_NMI | APIC_INT_LEVELTRIG);
+    return 0;
+}
+
+void dump_ioapic(unsigned long num)
+{
+     unsigned long i, val;
+
+     if (num < nr_ioapics)
+     {
+        DBGPrint("io_apic registers\n");
+        for (i = 0; i <= 0x2F; i++)
+        {
+	   if ((i & 3) == 0)
+	      DBGPrint("%08X: ", i);
+
+	   val = io_apic_read(num, i * 4);
+	   DBGPrint("%08X ", val);
+
+	   if ((i & 3) == 3)
+	      DBGPrint("\n");
+        }
+     }
+     return;
+}
+
+void dump_local_apic(void)
+{
+    unsigned long i, val;
+
+    DBGPrint("local apic registers\n");
+    for (i = 0; i <= 0x3F; i++)
+    {
+       if ((i & 3) == 0)
+	  DBGPrint("%08X: ", i);
+
+       val = apic_read(i * 4);
+       DBGPrint("%08X ", val);
+
+       if ((i & 3) == 3)
+	  DBGPrint("\n");
+    }
+
+}
+
+void dump_remote_apic(unsigned long cpu)
+{
+    register unsigned long i, timeout, apicid;
+    register unsigned long val;
+
+    DBGPrint("remote apic registers processor(%d)\n", cpu);
+    for (i = 0; i <= 0x3F; i++)
+    {
+       if ((i & 3) == 0)
+	  DBGPrint("%08X: ", i);
+
+       apicid = cpu_present_to_apicid(cpu);
+       if (apicid == BAD_APICID)
+       {
+          DBGPrint("BADAPICX ");
+          continue;
+       }
+
+       timeout = 0;
+       while (apic_read(APIC_ICR) & APIC_ICR_BUSY)
+       {
+          udelay(100);
+          if (timeout++ >= 1000)
+             break;
+          cpu_relax();
+          touch_nmi_watchdog();
+       }
+
+       if (timeout >= 1000)
+       {
+          DBGPrint("???????? ");
+          continue;
+       }
+
+       apic_write(APIC_ICR2, SET_APIC_DEST_FIELD(apicid));
+       apic_write(APIC_ICR, i | APIC_DEST_LOGICAL | APIC_DM_REMRD);
+
+       timeout = 0;
+       while ((apic_read(APIC_ICR) & APIC_ICR_RR_MASK) == APIC_ICR_RR_INPROG)
+       {
+          udelay(100);
+          if (timeout++ >= 1000)
+             break;
+
+          cpu_relax();
+          touch_nmi_watchdog();
+       }
+
+       if (timeout >= 1000)
+       {
+          DBGPrint("???????? ");
+          continue;
+       }
+
+       if ((apic_read(APIC_ICR) & APIC_ICR_RR_MASK) == APIC_ICR_RR_VALID)
+       {
+          val = apic_read(APIC_RRR);
+          DBGPrint("%08X ", val);
+       }
+       else
+       {
+          DBGPrint("???????? ");
+       }
+
+       if ((i & 3) == 3)
+	  DBGPrint("\n");
+    }
+
+}
+
+unsigned long displayAPICHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("apic                     - display local apic regs\n");
+    DBGPrint("apic [p#]                - display remote apic regs\n");
+    return 1;
+}
+
+/* APIC */
+
+unsigned long displayAPICInfo(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser)
+{
+     register unsigned long value;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid && ((value >= MAX_PROCESSORS) || !cpu_online(value)))
+     {
+        DBGPrint("processor not found\n");
+        return 1;
+     }
+     if (valid && (value != get_processor_id()))
+        dump_remote_apic(value);
+     else
+        dump_local_apic();
+     return 1;
+}
+
+unsigned long displayIOAPICHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("ioapic [#]               - display specified ioapic [#] regs\n");
+    return 1;
+}
+
+/* IOAPIC */
+
+unsigned long displayIOAPICInfo(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     register unsigned long value;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid && !(value < nr_ioapics))
+     {
+        DBGPrint("ioapic not found\n");
+        return 1;
+     }
+     if (valid)
+        dump_ioapic(value);
+     else
+        dump_ioapic(0);
+     return 1;
+
+}
+
+#endif /* CONFIG_SMP */
diff -Naur linux-2.6.27/debug/mdb/mdb-ia32.c linux-2.6.27-mdb/debug/mdb/mdb-ia32.c
--- linux-2.6.27/debug/mdb/mdb-ia32.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-ia32.c	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,5769 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/uaccess.h>
+#include <linux/nmi.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <linux/io.h>
+#include <linux/clocksource.h>
+
+#ifdef CONFIG_SMP
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb.h"
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+unsigned long MajorVersion = 2627;
+unsigned long MinorVersion = 9042008;
+unsigned long BuildVersion = 6;
+
+unsigned char *IA32Flags[]=
+{
+   "CF", 0, "PF", 0, "AF",    0, "ZF", "SF", "TF", "IF", "DF", "OF",
+   0,    0, "NT", 0, "RF", "VM", "AC", "VIF","VIP","ID",    0,    0,
+   0,
+};
+
+unsigned char *BreakDescription[]=
+{
+   "EXECUTE",  "WRITE",  "IOPORT",  "READ/WRITE",
+};
+
+unsigned char *BreakLengthDescription[]={
+   ": 1 BYTE",  ": 2 BYTE",  ": ??????",  ": 4 BYTE",
+};
+
+unsigned char *ExceptionDescription[]={
+   "Divide By Zero",                 /*  0 */
+   "Debugger Exception (INT1)",      /*  1 */
+   "Non-Maskable Interrupt",         /*  2 */
+   "Debugger Breakpoint (INT3)",     /*  3 */
+   "Overflow Exception",             /*  4 */
+   "Bounds Check",                   /*  5 */
+   "Invalid Opcode",                 /*  6 */
+   "No Coprocessor",                 /*  7 */
+   "Double Fault",                   /*  8 */
+   "Cops Error",                     /*  9 */
+   "Invalid Task State Segment",     /*  10 */
+   "Segment Not Present",            /*  11 */
+   "Stack Exception",                /*  12 */
+   "General Protection",             /*  13 */
+   "Page Fault",                     /*  14 */
+   "InvalidInterrupt",               /*  15 */
+   "Coprocessor Error",              /*  16 */
+   "AlignmentCheck",                 /*  17 */
+   "Machine Check",                  /*  18 */
+   "Enter Debugger Request",         /*  19 */
+   "Unvectored Exception",           /*  20 */
+   "Directed NMI Breakpoint",        /*  21 */
+   "Panic"                           /*  22 */
+};
+unsigned long exceptions = (sizeof(ExceptionDescription) / sizeof(unsigned char *));
+
+unsigned char char32spc[] = { "xxxxxxxxxxxxxxxxxxxxxxxx " };
+unsigned char flset[] = { "VMRF  NT    OFDNIETFMIZR  AC  PE  CY" };
+unsigned char floff[] = { "              UPID  PLNZ      PO  NC" };
+unsigned char fluse[] = { 1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,0,1 };
+
+unsigned long MTRR_BASE_REGS[] = {
+  MTRR_PHYS_BASE_0, MTRR_PHYS_BASE_1, MTRR_PHYS_BASE_2, MTRR_PHYS_BASE_3,
+  MTRR_PHYS_BASE_4, MTRR_PHYS_BASE_5, MTRR_PHYS_BASE_6, MTRR_PHYS_BASE_7
+};
+
+unsigned long MTRR_MASK_VALUES[] = {
+  MTRR_PHYS_MASK_0, MTRR_PHYS_MASK_1, MTRR_PHYS_MASK_2, MTRR_PHYS_MASK_3,
+  MTRR_PHYS_MASK_4, MTRR_PHYS_MASK_5, MTRR_PHYS_MASK_6, MTRR_PHYS_MASK_7
+};
+
+/* recursive spin lock used by the debugger to gate processors acquiring
+ * the debugger console.  if the lock is already held on the current
+ * processor when called, increment a use counter.  this allows us to
+ * handle nested exceptions on the same processor without deadlocking */
+typedef struct _RLOCK
+{
+#if defined(CONFIG_SMP)
+    spinlock_t lock;
+#endif
+    unsigned long processor;
+    unsigned long count;
+    unsigned long flags[MAX_PROCESSORS];
+} rlock_t;
+
+#define PROCESSOR_INACTIVE    0
+#define PROCESSOR_ACTIVE      1
+#define PROCESSOR_SUSPEND     2
+#define PROCESSOR_RESUME      3
+#define PROCESSOR_DEBUG       4
+#define PROCESSOR_SHUTDOWN    5
+#define PROCESSOR_IPI         6
+#define PROCESSOR_SWITCH      7
+#define PROCESSOR_HOLD        8
+
+#define PIC1_DEBUG_MASK    0xFC
+#define PIC2_DEBUG_MASK    0xFF
+
+#define  MAX_PICS             3
+#define  PIC_0             0x20
+#define  PIC_1             0xA0
+#define  PIC_2             0x30
+#define  MASK_0            0x21
+#define  MASK_1            0xA1
+#define  MASK_2            0x31
+
+unsigned char irq_control[MAX_PICS] = { PIC_0, PIC_1, PIC_2 };
+unsigned char irq_mask[MAX_PICS] = { MASK_0, MASK_1, MASK_2 };
+unsigned char mask_value[MAX_PICS] = { 0xF8, 0xFF, 0xFF };
+
+StackFrame ReferenceFrame[MAX_PROCESSORS];
+NUMERIC_FRAME npx[MAX_PROCESSORS];
+
+#if defined(CONFIG_SMP)
+rlock_t debug_mutex = { SPIN_LOCK_UNLOCKED, -1, 0 };
+#else
+rlock_t debug_mutex = { -1, 0 };
+#endif
+
+atomic_t focusActive;  /* cpus is focus */
+atomic_t debuggerActive;  /* cpus in the debugger */
+atomic_t debuggerProcessors[MAX_PROCESSORS]; /* cpus in handlers */
+atomic_t nmiProcessors[MAX_PROCESSORS]; /* cpus suspended */
+atomic_t traceProcessors[MAX_PROCESSORS]; /* focus processor mode */
+unsigned long ProcessorHold[MAX_PROCESSORS];
+unsigned long ProcessorState[MAX_PROCESSORS];
+
+unsigned char *procState[]={
+   "PROCESSOR_INACTIVE", "PROCESSOR_ACTIVE  ", "PROCESSOR_SUSPEND ",
+   "PROCESSOR_RESUME  ", "PROCESSOR_DEBUG   ", "PROCESSOR_SHUTDOWN",
+   "PROCESSOR_IPI     ", "PROCESSOR_SWITCH  ", "PROCESSOR_HOLD    ",
+   "?                 ", "?                 ", "?                 ",
+   "?                 ", "?                 ", "?                 ",
+   "?                 "
+};
+
+/* debugger commands */
+
+DEBUGGER_PARSER backTraceAllPidPE = {
+0, 0, backTraceAllPID, backTraceHelp, 0, "BTA", 0, 0,
+"display stack backtrace for all processes" , 0 };
+
+DEBUGGER_PARSER backTracePidPE = {
+0, 0, backTracePID, backTraceHelp, 0, "BTP", 0, 0,
+"display stack backtrace by pid" , 0 };
+
+DEBUGGER_PARSER backTraceStackPE = {
+0, 0, backTraceStack, backTraceHelp, 0, "BT", 0, 0,
+"display stack backtrace by address" , 0 };
+
+DEBUGGER_PARSER uFramePE = {
+0, 0, dump_uf, 0, 0, "UF", 0, 0,
+"display task eframe contents" , 0 };
+
+DEBUGGER_PARSER eFramePE = {
+0, 0, dump_ef, 0, 0, "EF", 0, 0,
+"display eframe contents" , 0 };
+
+DEBUGGER_PARSER cpuFramePE = {
+0, 0, listProcessorFrame, processorCommandHelp, 0, "LR", 0, 0,
+"display cpu registers" , 0 };
+
+DEBUGGER_PARSER ProcessorPE = {
+0, 0, displayProcessorStatus, displayProcessorStatusHelp, 0, "PROCESSORS", 0, 0,
+"display processor status" , 0 };
+
+DEBUGGER_PARSER HPE = {
+0, 0, displayDebuggerHelp, displayDebuggerHelpHelp, 0, "HELP", 0, 0,
+"this help screen (type HELP <command> for specific help)" , 0 };
+
+DEBUGGER_PARSER HelpPE = {
+0, 0, displayDebuggerHelp, displayDebuggerHelpHelp, 0, "H", 0, 0,
+"this help screen" , 0 };
+
+DEBUGGER_PARSER clearScreenPE = {
+0, 0, clearDebuggerScreen, clearScreenHelp, 0, "CLS", 0, 0,
+"clear the screen" , 0 };
+
+DEBUGGER_PARSER asciiTablePE = {
+0, 0, displayASCTable, ascTableHelp, 0, "A", 0, 0,
+"display ASCII Table" , 0 };
+
+DEBUGGER_PARSER TUTogglePE = {
+0, 0, ProcessTUToggle, displayToggleHelp, 0, ".TU", 0, 0,
+"toggles unasm debug display (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TDTogglePE = {
+0, 0, ProcessTDToggle, displayToggleHelp, 0, ".TD", 0, 0,
+"toggles full dereference display (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TLTogglePE = {
+0, 0, ProcessTLToggle, displayToggleHelp, 0, ".TL", 0, 0,
+"toggles source line display (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TGTogglePE = {
+0, 0, ProcessTGToggle, displayToggleHelp, 0, ".TG", 0, 0,
+"toggles general registers (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TCTogglePE = {
+0, 0, ProcessTCToggle, displayToggleHelp, 0, ".TC", 0, 0,
+"toggles control registers (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER TNTogglePE = {
+0, 0, ProcessTNToggle, displayToggleHelp, 0, ".TN", 0, 0,
+"toggles coprocessor registers (ON | OFF)"  , 0 };
+
+DEBUGGER_PARSER TRTogglePE = {
+0, 0, ProcessTRToggle, displayToggleHelp, 0, ".TR", 0, 0,
+"toggles display of break reason (ON | OFF)"  , 0 };
+
+DEBUGGER_PARSER TSTogglePE = {
+0, 0, ProcessTSToggle, displayToggleHelp, 0, ".TS", 0, 0,
+"toggles segment registers (ON | OFF)"  , 0 };
+
+DEBUGGER_PARSER TATogglePE = {
+0, 0, ProcessTAToggle, displayToggleHelp, 0, ".TA", 0, 0,
+"toggles all registers (ON | OFF)" , 0 };
+
+DEBUGGER_PARSER ReasonPE = {
+0, 0, ReasonDisplay, ReasonHelp, 0, ".A", 0, 0,
+"display break reason" , 0 };
+
+DEBUGGER_PARSER TTogglePE = {
+0, 0, TSSDisplay, TSSDisplayHelp, 0, ".T", 0, 0,
+"display task state segment (tss)" , 0 };
+
+DEBUGGER_PARSER versionPE = {
+0, 0, DisplayDebuggerVersion, displayDebuggerVersionHelp, 0, ".V", 0, 0,
+"display version info" , 0 };
+
+#if defined(CONFIG_MODULES)
+DEBUGGER_PARSER lsmodPE1 = {
+0, 0, listModules, listModulesHelp, 0, ".M", 0, 0,
+"list loaded modules" , 0 };
+
+DEBUGGER_PARSER lsmodPE2 = {
+0, 0, listModules, listModulesHelp, 0, "LSMOD", 0, 0,
+"list loaded modules" , 0 };
+
+DEBUGGER_PARSER rmmodPE = {
+0, 0, unloadModule, listModulesHelp, 0, "RMMOD", 0, 0,
+"unload module" , 0 };
+#endif
+
+DEBUGGER_PARSER rebootPE = {
+0, 0, rebootSystem, rebootSystemHelp, 0, "REBOOT", 0, 0,
+"reboot host system" , 0 };
+
+DEBUGGER_PARSER KernelProcessPE1 = {
+0, 0, displayKernelProcess, displayKernelProcessHelp, 0, ".P", 0, 0,
+"display kernel processes" , 0 };
+
+DEBUGGER_PARSER KernelProcessPE2 = {
+0, 0, displayKernelProcess, displayKernelProcessHelp, 0, "PS", 0, 0,
+"display kernel processes" , 0 };
+
+/*
+DEBUGGER_PARSER SectionPE1 = {
+0, 0, displaySections, displaySectionsHelp, 0, ".S", 0, 0,
+"display kernel/module sections" , 0 };
+
+DEBUGGER_PARSER SectionPE2 = {
+0, 0, displaySections, displaySectionsHelp, 0, "SECTIONS", 0, 0,
+"display kernel/module sections" , 0 };
+*/
+
+DEBUGGER_PARSER AllSymbolsPE = {
+0, 0, displaySymbols, displaySymbolsHelp, 0, "SYMBOL", 0, 0,
+"display symbol(s)" , 0 };
+
+DEBUGGER_PARSER SymbolsPE = {
+0, 0, displaySymbols, displaySymbolsHelp, 0, ".Z", 0, 0,
+"display symbol(s)" , 0 };
+
+DEBUGGER_PARSER ControlPE = {
+0, 0, displayControlRegisters, displayRegistersHelp, 0, "RC", 0, 0,
+"display control registers" , 0 };
+
+DEBUGGER_PARSER AllPE = {
+0, 0, displayAllRegisters, displayRegistersHelp, 0, "RA", 0, 0,
+"display all registers" , 0 };
+
+DEBUGGER_PARSER SegmentPE = {
+0, 0, displaySegmentRegisters, displayRegistersHelp, 0, "RS", 0, 0,
+"display segment registers" , 0 };
+
+DEBUGGER_PARSER NumericPE = {
+0, 0, displayNumericRegisters, displayRegistersHelp, 0, "RN", 0, 0,
+"display coprocessor/MMX registers" , 0 };
+
+DEBUGGER_PARSER GeneralPE = {
+0, 0, displayGeneralRegisters, displayRegistersHelp, 0, "RG", 0, 0,
+"display general registers" , 0 };
+
+DEBUGGER_PARSER DefaultPE = {
+0, 0, displayDefaultRegisters, displayRegistersHelp, 0, "R", 0, 0,
+"display registers for a processor" , 0 };
+
+DEBUGGER_PARSER SearchMemoryBPE = {
+0, 0, SearchMemoryB, SearchMemoryHelp, 0, "SB", 0, 0,
+"search memory for pattern (bytes)"  , 0 };
+
+DEBUGGER_PARSER SearchMemoryWPE = {
+0, 0, SearchMemoryW, SearchMemoryHelp, 0, "SW", 0, 0,
+"search memory for pattern (words)"  , 0 };
+
+DEBUGGER_PARSER SearchMemoryDPE = {
+0, 0, SearchMemoryD, SearchMemoryHelp, 0, "SD", 0, 0,
+"search memory for pattern (dwords)"  , 0 };
+
+DEBUGGER_PARSER ChangeWordPE = {
+0, 0, changeWordValue, changeMemoryHelp, 0, "CW", 0, 0,
+"change words at address"  , 0 };
+
+DEBUGGER_PARSER ChangeDoublePE = {
+0, 0, changeDoubleValue, changeMemoryHelp, 0, "CD", 0, 0,
+"change dwords at address"  , 0 };
+
+DEBUGGER_PARSER ChangeBytePE = {
+0, 0, changeByteValue, changeMemoryHelp, 0, "CB", 0, 0,
+"change bytes at address"  , 0 };
+
+DEBUGGER_PARSER ChangeDefaultPE = {
+0, 0, changeDefaultValue, changeMemoryHelp, 0, "C", 0, 0,
+"change bytes at address"  , 0 };
+
+DEBUGGER_PARSER CloseSymbolsPE = {
+0, 0, displayCloseSymbols, displayCloseHelp, 0, "?", 0, 0,
+"display closest symbols to <address>" , 0 };
+
+DEBUGGER_PARSER WalkPE = {
+0, 0, debuggerWalkStack, displayDumpHelp, 0, "W", 0, 0,
+"display symbols on the stack"  , 0 };
+
+DEBUGGER_PARSER DumpLinkedPE = {
+0, 0, debuggerDumpLinkedList, displayDumpHelp, 0, "DL", 0, 0,
+"dump linked list"  , 0 };
+
+DEBUGGER_PARSER DumpWordPE = {
+0, 0, debuggerDumpWord, displayDumpHelp, 0, "DW", 0, 0,
+"dump memory as words"  , 0 };
+
+DEBUGGER_PARSER DumpStackPE = {
+0, 0, debuggerDumpStack, displayDumpHelp, 0, "DS", 0, 0,
+"dump stack"  , 0 };
+
+DEBUGGER_PARSER DumpDoubleStackPE = {
+0, 0, debuggerDumpDoubleStack, displayDumpHelp, 0, "DDS", 0, 0,
+"dump stack double word"  , 0 };
+
+DEBUGGER_PARSER DumpDoublePE = {
+0, 0, debuggerDumpDouble, displayDumpHelp, 0, "DD", 0, 0,
+"dump memory as double words" , 0 };
+
+DEBUGGER_PARSER DumpBytePE = {
+0, 0, debuggerDumpByte, displayDumpHelp, 0, "DB", 0, 0,
+"dump memory as bytes"  , 0 };
+
+DEBUGGER_PARSER DumpDefaultPE = {
+0, 0, debuggerDumpByte, displayDumpHelp, 0, "D", 0, 0,
+"dump memory as bytes"  , 0 };
+
+DEBUGGER_PARSER Diss16PE = {
+0, 0, processDisassemble16, displayDisassembleHelp, 0, "UU", 0, 0,
+"unassemble code (16-bit)" , 0 };
+
+DEBUGGER_PARSER Diss32PE = {
+0, 0, processDisassemble32, displayDisassembleHelp, 0, "U", 0, 0,
+"unassemble code (32-bit)"  , 0 };
+
+DEBUGGER_PARSER Id32PE = {
+0, 0, processDisassemble32, displayDisassembleHelp, 0, "ID", 0, 0,
+"unassemble code (32-bit)"  , 0 };
+
+DEBUGGER_PARSER ProceedPE = {
+0, 0, processProceed, executeCommandHelp, 0, "P", 0, 0,
+"proceed"  , -1 };
+
+DEBUGGER_PARSER TracePE = {
+0, 0, processTrace, executeCommandHelp, 0, "T", 0, 0,
+"trace"  , -1 };
+
+DEBUGGER_PARSER SingleStepPE = {
+0, 0, processTrace, executeCommandHelp, 0, "S", 0, 0,
+"single step"  , -1 };
+
+DEBUGGER_PARSER TraceSSPE = {
+0, 0, processTrace, executeCommandHelp, 0, "SS", 0, 0,
+"single step"  , -1 };
+
+DEBUGGER_PARSER TraceSSBPE = {
+0, 0, processTraceSSB, executeCommandHelp, 0, "SSB", 0, 0,
+"single step til branch", -1 };
+
+DEBUGGER_PARSER GPE = {
+0, 0, processGo, executeCommandHelp, 0, "G", 0, 0,
+"g or g til <address> match"  , -1 };
+
+DEBUGGER_PARSER GoPE = {
+0, 0, processGo, executeCommandHelp, 0, "GO", 0, 0,
+"go or go til <address> match"  , -1 };
+
+DEBUGGER_PARSER QPE = {
+0, 0, processGo, executeCommandHelp, 0, "Q", 0, 0,
+"quit debugger until <address> match"  , -1 };
+
+DEBUGGER_PARSER XPE = {
+0, 0, processGo, executeCommandHelp, 0, "X", 0, 0,
+"exit debugger until <address> match"  , -1 };
+
+DEBUGGER_PARSER BreakProcessorPE = {
+0, 0, breakProcessor, processorCommandHelp, 0, "CPU", 0, 0,
+"switch processor"  , -1 };
+
+DEBUGGER_PARSER ListProcessorsPE = {
+0, 0, listProcessors, processorCommandHelp, 0, "LCPU", 0, 0,
+"list processors"  , 0 };
+
+DEBUGGER_PARSER EAXPE = {
+0, 0, ChangeEAXRegister, displayEAXHelp, 0, "EAX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ORIGEAXPE = {
+0, 0, ChangeORIGEAXRegister, displayEAXHelp, 0, "ORGEAX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EBXPE = {
+0, 0, ChangeEBXRegister, displayEBXHelp, 0, "EBX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ECXPE = {
+0, 0, ChangeECXRegister, displayECXHelp, 0, "ECX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EDXPE = {
+0, 0, ChangeEDXRegister, displayEDXHelp, 0, "EDX", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ESIPE = {
+0, 0, ChangeESIRegister, displayESIHelp, 0, "ESI", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EDIPE = {
+0, 0, ChangeEDIRegister, displayEDIHelp, 0, "EDI", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EBPPE = {
+0, 0, ChangeEBPRegister, displayEBPHelp, 0, "EBP", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ESPPE = {
+0, 0, ChangeESPRegister, displayESPHelp, 0, "ESP", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER EIPPE = {
+0, 0, ChangeEIPRegister, displayEIPHelp, 0, "EIP", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER CSPE = {
+0, 0, ChangeCSRegister, displayCSHelp, 0, "XCS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER DSPE = {
+0, 0, ChangeDSRegister, displayDSHelp, 0, "XDS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ESPE = {
+0, 0, ChangeESRegister, displayESHelp, 0, "XES", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER FSPE = {
+0, 0, ChangeFSRegister, displayFSHelp, 0, "XFS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER GSPE = {
+0, 0, ChangeGSRegister, displayGSHelp, 0, "XGS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER SSPE = {
+0, 0, ChangeSSRegister, displaySSHelp, 0, "XSS", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER RFPE = {
+0, 0, ChangeRFFlag, displayRFHelp, 0, "RF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER TFPE = {
+0, 0, ChangeTFFlag, displayTFHelp, 0, "TF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ZFPE = {
+0, 0, ChangeZFFlag, displayZFHelp, 0, "ZF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER SFPE = {
+0, 0, ChangeSFFlag, displaySFHelp, 0, "SF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER PFPE = {
+0, 0, ChangePFFlag, displayPFHelp, 0, "PF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER CFPE = {
+0, 0, ChangeCFFlag, displayCFHelp, 0, "CF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER OFPE = {
+0, 0, ChangeOFFlag, displayOFHelp, 0, "OF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER IFPE = {
+0, 0, ChangeIFFlag, displayIFHelp, 0, "IF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER IDPE = {
+0, 0, ChangeIDFlag, displayIDHelp, 0, "CPUID", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER DFPE = {
+0, 0, ChangeDFFlag, displayDFHelp, 0, "DF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER NTPE = {
+0, 0, ChangeNTFlag, displayNTHelp, 0, "NT", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER VMPE = {
+0, 0, ChangeVMFlag, displayVMHelp, 0, "VM", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER VIFPE = {
+0, 0, ChangeVIFFlag, displayVIFHelp, 0, "VIF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER VIPPE = {
+0, 0, ChangeVIPFlag, displayVIPHelp, 0, "VIP", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER AFPE = {
+0, 0, ChangeAFFlag, displayAFHelp, 0, "AF", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER ACPE = {
+0, 0, ChangeACFlag, displayACHelp, 0, "AC", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER MTRRPE = {
+0, 0, DisplayMTRRRegisters, displayMTRRHelp, 0, "MTRR", 0, 0,
+"display memory type range registers" , 0 };
+
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+DEBUGGER_PARSER APIC_PE = {
+0, 0, displayAPICInfo, displayAPICHelp, 0, "APIC", 0, 0,
+"display local apic registers", 0 };
+
+DEBUGGER_PARSER IOAPIC_PE = {
+0, 0, displayIOAPICInfo, displayIOAPICHelp, 0, "IOAPIC", 0, 0,
+"display io apic registers", 0 };
+
+DEBUGGER_PARSER NMIProcessorPE = {
+0, 0, nmiProcessor, processorCommandHelp, 0, "NMI", 0, 0,
+"nmi processor (WARNING: See 'help nmi' for instructions)", -1 };
+#endif
+
+DEBUGGER_PARSER GDTPE = {
+0, 0, displayGDT, displayGDTHelp, 0, ".G", 0, 0,
+"display global descriptor table" , 0 };
+
+DEBUGGER_PARSER IDTPE = {
+0, 0, displayIDT, displayIDTHelp, 0, ".I", 0, 0,
+"display interrupt descriptor table"  , 0 };
+
+DEBUGGER_PARSER EvaluatePE = {
+0, 0, evaluateExpression, evaluateExpressionHelp, 0, ".E", 0, 0,
+"evaluate expression (help .e)"  , 0 };
+
+DEBUGGER_PARSER InputWordPE = {
+0, 0, inputWordPort, portCommandHelp, 0, "IW", 0, 0,
+"input word from port" , 0 };
+
+DEBUGGER_PARSER InputDoublePE = {
+0, 0, inputDoublePort, portCommandHelp, 0, "IL", 0, 0,
+"input double word from port" , 0 };
+
+DEBUGGER_PARSER InputBytePE = {
+0, 0, inputBytePort, portCommandHelp, 0, "IB", 0, 0,
+"input byte from port" , 0 };
+
+DEBUGGER_PARSER InputPE = {
+0, 0, inputPort, portCommandHelp, 0, "I", 0, 0,
+"input byte from port" , 0 };
+
+DEBUGGER_PARSER OutputWordPE = {
+0, 0, outputWordPort, portCommandHelp, 0, "OW", 0, 0,
+"output word to port" , 0 };
+
+DEBUGGER_PARSER OutputDoublePE = {
+0, 0, outputDoublePort, portCommandHelp, 0, "OL", 0, 0,
+"output double word to port" , 0 };
+
+DEBUGGER_PARSER OutputBytePE = {
+0, 0, outputBytePort, portCommandHelp, 0, "OB", 0, 0,
+"output byte to port" , 0 };
+
+DEBUGGER_PARSER OutputPE = {
+0, 0, outputPort, portCommandHelp, 0, "O", 0, 0,
+"output byte to port" , 0 };
+
+DEBUGGER_PARSER BreakClearAllPE = {
+0, 0, breakpointClearAll, breakpointCommandHelp, 0, "BCA", 0, 0,
+"clear all breakpoints" , 0 };
+
+DEBUGGER_PARSER BreakClearPE = {
+0, 0, breakpointClear, breakpointCommandHelp, 0, "BC", 0, 0,
+"clear breakpoint" , 0 };
+
+DEBUGGER_PARSER BreakMaskPE = {
+0, 0, breakpointMask, breakpointCommandHelp, 0, "BM", 0, 0,
+"mask breaks for specific processor" , 0 };
+
+DEBUGGER_PARSER BW1PE = {
+0, 0, breakpointWord1, breakpointCommandHelp, 0, "BW1", 0, -1,
+"" , 0 };
+
+DEBUGGER_PARSER BW2PE = {
+0, 0, breakpointWord2, breakpointCommandHelp, 0, "BW2", 0, -1,
+"" , 0 };
+
+DEBUGGER_PARSER BW4PE = {
+0, 0, breakpointWord4, breakpointCommandHelp, 0, "BW4", 0, -1,
+"" , 0 };
+
+DEBUGGER_PARSER BWPE = {
+0, 0, breakpointWord, breakpointCommandHelp, 0, "BW", 0, 0,
+"set write only breakpoint #=1,2 or 4 byte len" , 0 };
+
+DEBUGGER_PARSER BR1PE = {
+0, 0, breakpointRead1, breakpointCommandHelp, 0, "BR1", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BR2PE = {
+0, 0, breakpointRead2, breakpointCommandHelp, 0, "BR2", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BR4PE = {
+0, 0, breakpointRead4, breakpointCommandHelp, 0, "BR4", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BRPE = {
+0, 0, breakpointRead, breakpointCommandHelp, 0, "BR", 0, 0,
+"set read/write breakpoint #=1,2 or 4 byte len" , 0 };
+
+DEBUGGER_PARSER BI1PE = {
+0, 0, breakpointIO1, breakpointCommandHelp, 0, "BI1", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BI2PE = {
+0, 0, breakpointIO2, breakpointCommandHelp, 0, "BI2", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BI4PE = {
+0, 0, breakpointIO4, breakpointCommandHelp, 0, "BI4", 0, -1,
+"", 0 };
+
+DEBUGGER_PARSER BIPE = {
+0, 0, breakpointIO, breakpointCommandHelp, 0, "BI", 0, 0,
+"set io address breakpoint #=1,2 or 4 byte len"  , 0 };
+
+DEBUGGER_PARSER breakpointExecutePE = {
+0, 0, breakpointExecute, breakpointCommandHelp, 0, "B", 0, 0,
+"display all/set execute breakpoint" , 0 };
+
+DEBUGGER_PARSER breakShowTemp = {
+0, 0, breakpointShowTemp, breakpointCommandHelp, 0, "BST", 0, 0,
+"displays temporary breakpoints (proceed/go)" , 0 };
+
+DEBUGGER_PARSER breakTimer = {
+0, 0, timerBreakpoint, timedBreakpointHelp, 0, "ADDTIMER", 0, 0,
+"add a debug timer event" , 0 };
+
+DEBUGGER_PARSER breakTimerClear = {
+0, 0, timerBreakpointClear, timedBreakpointHelp, 0, "DELTIMER", 0, 0,
+"delete a debug timer event" , 0 };
+
+/* interactive debugger accelerators */
+
+ACCELERATOR traceSSBACC = {
+0, 0, processTraceSSBACC, 0, 0, K_F6, 0,
+"F6 - Trace/Single Step til Branch" };
+
+ACCELERATOR traceACC = {
+0, 0, processTraceACC, 0, 0, K_F7, 0,
+"F7 - Trace/Single Step" };
+
+ACCELERATOR proceedACC = {
+0, 0, processProceedACC, 0, 0, K_F8, 0,
+"F8 - Proceed" };
+
+ACCELERATOR goACC = {
+0, 0, processGoACC, 0, 0, K_F9, 0,
+"F9 - Go" };
+
+ACCELERATOR enterACC = { /* this accelerator handles repeat command */
+0, 0, enterKeyACC, 0, 0, 13, 0,   /* processing */
+"Enter - Execute or Repeat a Command" };
+
+unsigned char *lastDumpAddress;
+unsigned char *lastLinkAddress;
+unsigned long lastUnasmAddress;
+unsigned long displayLength;
+unsigned long lastCommand;
+unsigned long lastCommandEntry;
+unsigned char lastDebugCommand[100] = {""};
+unsigned long lastDisplayLength;
+unsigned char debugCommand[100] = {""};
+unsigned long nextUnasmAddress;
+unsigned long pic1Value;
+unsigned long pic2Value;
+unsigned long BreakReserved[4];
+unsigned long BreakPoints[4];
+unsigned long BreakType[4];
+unsigned long BreakLength[4];
+unsigned long BreakTemp[4];
+unsigned long BreakGo[4];
+unsigned long BreakProceed[4];
+unsigned long BreakMask[MAX_PROCESSORS];
+StackFrame *CurrentFrame[MAX_PROCESSORS];
+unsigned long NestedInterrupts[MAX_PROCESSORS];
+unsigned long ConditionalBreakpoint[4];
+unsigned char BreakCondition[4][256];
+StackFrame lastStackFrame;
+unsigned long lastCR0;
+unsigned long lastCR2;
+unsigned long lastCR4;
+unsigned long CurrentDR7;
+unsigned long CurrentDR6[MAX_PROCESSORS];
+unsigned long repeatCommand;
+unsigned long totalLines;
+unsigned long debuggerInitialized;
+unsigned long ssbmode;
+
+void mdb_breakpoint(void) {__asm__ __volatile__ ("int $0x03");};
+
+void MDBInitializeDebugger(void)
+{
+   register unsigned long i;
+   extern void InitializeDebuggerRegisters(void);
+   extern unsigned long AddAccelRoutine(ACCELERATOR *);
+
+   lastCommand = 0;
+   lastCommandEntry = 0;
+   lastDisplayLength = 0;
+
+   for (i = 0; i < MAX_PROCESSORS; i++)
+   {
+      BreakMask[i] = 0;
+      ProcessorHold[i] = 0;
+      ProcessorState[i] = 0;
+   }
+
+   for (i = 0; i < 4; i++)
+   {
+      BreakReserved[i] = 0;
+      BreakPoints[i] = 0;
+      BreakType[i] = 0;
+      BreakLength[i] = 0;
+      BreakProceed[i] = 0;
+      BreakGo[i] = 0;
+      BreakTemp[i] = 0;
+      ConditionalBreakpoint[i] = 0;
+      BreakCondition[i][0] = '\0';
+   }
+
+   InitializeDebuggerRegisters();
+
+   AddDebuggerCommandParser(&ReasonPE);
+   AddDebuggerCommandParser(&backTraceAllPidPE);
+   AddDebuggerCommandParser(&backTracePidPE);
+   AddDebuggerCommandParser(&backTraceStackPE);
+   AddDebuggerCommandParser(&eFramePE);
+   AddDebuggerCommandParser(&cpuFramePE);
+   AddDebuggerCommandParser(&ProcessorPE);
+   AddDebuggerCommandParser(&HPE);
+   AddDebuggerCommandParser(&HelpPE);
+   AddDebuggerCommandParser(&clearScreenPE);
+   AddDebuggerCommandParser(&asciiTablePE);
+   AddDebuggerCommandParser(&TUTogglePE);
+   AddDebuggerCommandParser(&TDTogglePE);
+   AddDebuggerCommandParser(&TLTogglePE);
+   AddDebuggerCommandParser(&TGTogglePE);
+   AddDebuggerCommandParser(&TCTogglePE);
+   AddDebuggerCommandParser(&TNTogglePE);
+   AddDebuggerCommandParser(&TRTogglePE);
+   AddDebuggerCommandParser(&TSTogglePE);
+   AddDebuggerCommandParser(&TATogglePE);
+   AddDebuggerCommandParser(&TTogglePE);
+   AddDebuggerCommandParser(&versionPE);
+   AddDebuggerCommandParser(&rebootPE);
+   AddDebuggerCommandParser(&KernelProcessPE1);
+   AddDebuggerCommandParser(&KernelProcessPE2);
+/*
+   AddDebuggerCommandParser(&SectionPE1);
+   AddDebuggerCommandParser(&SectionPE2);
+*/
+   AddDebuggerCommandParser(&AllSymbolsPE);
+   AddDebuggerCommandParser(&SymbolsPE);
+
+#if defined(CONFIG_MODULES)
+   AddDebuggerCommandParser(&lsmodPE1);
+   AddDebuggerCommandParser(&lsmodPE2);
+   AddDebuggerCommandParser(&rmmodPE);
+#endif
+
+   AddDebuggerCommandParser(&ControlPE);
+   AddDebuggerCommandParser(&AllPE);
+   AddDebuggerCommandParser(&SegmentPE);
+   AddDebuggerCommandParser(&NumericPE);
+   AddDebuggerCommandParser(&GeneralPE);
+   AddDebuggerCommandParser(&DefaultPE);
+   AddDebuggerCommandParser(&SearchMemoryBPE);
+   AddDebuggerCommandParser(&SearchMemoryWPE);
+   AddDebuggerCommandParser(&SearchMemoryDPE);
+   AddDebuggerCommandParser(&ChangeWordPE);
+   AddDebuggerCommandParser(&ChangeDoublePE);
+   AddDebuggerCommandParser(&ChangeBytePE);
+   AddDebuggerCommandParser(&ChangeDefaultPE);
+   AddDebuggerCommandParser(&CloseSymbolsPE);
+   AddDebuggerCommandParser(&WalkPE);
+   AddDebuggerCommandParser(&DumpLinkedPE);
+   AddDebuggerCommandParser(&DumpWordPE);
+   AddDebuggerCommandParser(&DumpStackPE);
+   AddDebuggerCommandParser(&DumpDoubleStackPE);
+   AddDebuggerCommandParser(&DumpDoublePE);
+   AddDebuggerCommandParser(&DumpBytePE);
+   AddDebuggerCommandParser(&DumpDefaultPE);
+   AddDebuggerCommandParser(&Diss16PE);
+   AddDebuggerCommandParser(&Diss32PE);
+   AddDebuggerCommandParser(&Id32PE);
+   AddDebuggerCommandParser(&ProceedPE);
+   AddDebuggerCommandParser(&TracePE);
+   AddDebuggerCommandParser(&SingleStepPE);
+   AddDebuggerCommandParser(&TraceSSPE);
+   AddDebuggerCommandParser(&TraceSSBPE);
+   AddDebuggerCommandParser(&GPE);
+   AddDebuggerCommandParser(&GoPE);
+   AddDebuggerCommandParser(&QPE);
+   AddDebuggerCommandParser(&XPE);
+   AddDebuggerCommandParser(&BreakProcessorPE);
+   AddDebuggerCommandParser(&ListProcessorsPE);
+   AddDebuggerCommandParser(&EAXPE);
+   AddDebuggerCommandParser(&ORIGEAXPE);
+   AddDebuggerCommandParser(&EBXPE);
+   AddDebuggerCommandParser(&ECXPE);
+   AddDebuggerCommandParser(&EDXPE);
+   AddDebuggerCommandParser(&ESIPE);
+   AddDebuggerCommandParser(&EDIPE);
+   AddDebuggerCommandParser(&EBPPE);
+   AddDebuggerCommandParser(&ESPPE);
+   AddDebuggerCommandParser(&EIPPE);
+   AddDebuggerCommandParser(&CSPE);
+   AddDebuggerCommandParser(&DSPE);
+   AddDebuggerCommandParser(&ESPE);
+   AddDebuggerCommandParser(&FSPE);
+   AddDebuggerCommandParser(&GSPE);
+   AddDebuggerCommandParser(&SSPE);
+   AddDebuggerCommandParser(&RFPE);
+   AddDebuggerCommandParser(&TFPE);
+   AddDebuggerCommandParser(&ZFPE);
+   AddDebuggerCommandParser(&SFPE);
+   AddDebuggerCommandParser(&PFPE);
+   AddDebuggerCommandParser(&CFPE);
+   AddDebuggerCommandParser(&OFPE);
+   AddDebuggerCommandParser(&IFPE);
+   AddDebuggerCommandParser(&IDPE);
+   AddDebuggerCommandParser(&DFPE);
+   AddDebuggerCommandParser(&NTPE);
+   AddDebuggerCommandParser(&VMPE);
+   AddDebuggerCommandParser(&VIFPE);
+   AddDebuggerCommandParser(&VIPPE);
+   AddDebuggerCommandParser(&AFPE);
+   AddDebuggerCommandParser(&ACPE);
+   AddDebuggerCommandParser(&MTRRPE);
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+   AddDebuggerCommandParser(&APIC_PE);
+   AddDebuggerCommandParser(&IOAPIC_PE);
+   AddDebuggerCommandParser(&NMIProcessorPE);
+#endif
+   AddDebuggerCommandParser(&GDTPE);
+   AddDebuggerCommandParser(&IDTPE);
+   AddDebuggerCommandParser(&EvaluatePE);
+   AddDebuggerCommandParser(&InputWordPE);
+   AddDebuggerCommandParser(&InputDoublePE);
+   AddDebuggerCommandParser(&InputBytePE);
+   AddDebuggerCommandParser(&InputPE);
+   AddDebuggerCommandParser(&OutputWordPE);
+   AddDebuggerCommandParser(&OutputDoublePE);
+   AddDebuggerCommandParser(&OutputBytePE);
+   AddDebuggerCommandParser(&OutputPE);
+   AddDebuggerCommandParser(&BreakClearAllPE);
+   AddDebuggerCommandParser(&BreakClearPE);
+   AddDebuggerCommandParser(&BreakMaskPE);
+   AddDebuggerCommandParser(&BW1PE);
+   AddDebuggerCommandParser(&BW2PE);
+   AddDebuggerCommandParser(&BW4PE);
+   AddDebuggerCommandParser(&BWPE);
+   AddDebuggerCommandParser(&BR1PE);
+   AddDebuggerCommandParser(&BR2PE);
+   AddDebuggerCommandParser(&BR4PE);
+   AddDebuggerCommandParser(&BRPE);
+   AddDebuggerCommandParser(&BI1PE);
+   AddDebuggerCommandParser(&BI2PE);
+   AddDebuggerCommandParser(&BI4PE);
+   AddDebuggerCommandParser(&BIPE);
+   AddDebuggerCommandParser(&breakpointExecutePE);
+   AddDebuggerCommandParser(&breakShowTemp);
+   AddDebuggerCommandParser(&breakTimer);
+   AddDebuggerCommandParser(&breakTimerClear);
+
+   AddAccelRoutine(&traceSSBACC);
+   AddAccelRoutine(&traceACC);
+   AddAccelRoutine(&proceedACC);
+   AddAccelRoutine(&goACC);
+   AddAccelRoutine(&enterACC);
+
+   debuggerInitialized = 1;
+   return;
+}
+
+void MDBClearDebuggerState(void)
+{
+   extern void ClearDebuggerRegisters(void);
+
+   ClearDebuggerRegisters();
+   debuggerInitialized = 0;
+   return;
+}
+
+
+void ClearTempBreakpoints(void)
+{
+   register unsigned long i;
+
+   for (i = 0; i < 4; i++)
+   {
+      if (BreakTemp[i])
+      {
+	 BreakTemp[i] = 0;
+	 BreakReserved[i] = 0;
+	 BreakPoints[i] = 0;
+	 BreakType[i] = 0;
+	 BreakLength[i] = 0;
+	 BreakGo[i] = 0;
+	 BreakProceed[i] = 0;
+      }
+   }
+   SetDebugRegisters();
+   return;
+}
+
+unsigned long ValidBreakpoint(unsigned long address)
+{
+
+   register unsigned long i;
+
+   for (i = 0; i < 4; i++)
+   {
+      if (!BreakTemp[i])
+	 if (BreakPoints[i] == address)
+	    return 1;
+   }
+   return 0;
+
+}
+
+unsigned long GetIP(StackFrame *stackFrame)
+{
+    return (unsigned long)(stackFrame->tEIP);
+}
+
+unsigned long GetStackAddress(StackFrame *stackFrame)
+{
+    return (unsigned long)(stackFrame->tESP);
+}
+
+unsigned long GetStackSegment(StackFrame *stackFrame)
+{
+    return (unsigned long)(stackFrame->tSS);
+}
+
+unsigned long SSBUpdate(StackFrame *stackFrame, unsigned long processor)
+{
+    if (!ssbmode)
+       return 0;
+
+    if (jmp_active)
+    {
+       ssbmode = 0;
+       return 0;
+    }
+
+    lastCommand = 'T';
+    strcpy(debugCommand, "SSB");
+    lastCR0 = ReadCR0();
+    lastCR2 = ReadCR2();
+    lastCR4 = ReadCR4();
+    memmove((void *)&lastStackFrame, stackFrame,
+		     sizeof(StackFrame));
+
+    stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+    atomic_inc(&focusActive);
+    atomic_inc(&traceProcessors[get_processor_id()]);
+    return -1;
+}
+
+/* F6 */
+
+unsigned long processTraceSSBACC(unsigned long key, void *p, ACCELERATOR *accel)
+{
+     register StackFrame *stackFrame = p;
+
+     DBGPrint("\n");
+     ssbmode = 1;
+     lastCommand = 'T';
+     strcpy(debugCommand, "SSB");
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+
+     /* set as focus processor for trace, ssb, or proceed */
+     atomic_inc(&focusActive);
+     atomic_inc(&traceProcessors[get_processor_id()]);
+     return -1;
+}
+
+/* F8 */
+
+unsigned long processProceedACC(unsigned long key, void *p, ACCELERATOR *accel)
+{
+     register StackFrame *stackFrame = p;
+     register unsigned long i;
+
+     ssbmode = 0;
+     DBGPrint("\n");
+     if (needs_proceed)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = nextUnasmAddress;
+	      BreakType[i] = BREAK_EXECUTE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      BreakTemp[i] = 1;
+	      BreakProceed[i] = 1;
+	      SetDebugRegisters();
+	      lastCommand = 'P';
+              strcpy(debugCommand, "P");
+	      lastCR0 = ReadCR0();
+	      lastCR2 = ReadCR2();
+	      lastCR4 = ReadCR4();
+	      memmove((void *)&lastStackFrame, stackFrame,
+		      sizeof(StackFrame));
+
+	      stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	      stackFrame->tSystemFlags |= RESUME;
+
+              /* set as focus processor for trace, ssb, or proceed */
+              atomic_inc(&focusActive);
+              atomic_inc(&traceProcessors[get_processor_id()]);
+	      return -1;
+	   }
+	}
+	DBGPrint("\nNo breakpoint available for Proceed, (single step) instead");
+     }
+     lastCommand = 'P';
+     strcpy(debugCommand, "P");
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame,
+	       sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+
+     /* set as focus processor for trace, ssb, or proceed */
+     atomic_inc(&focusActive);
+     atomic_inc(&traceProcessors[get_processor_id()]);
+     return -1;
+}
+
+/* F7 */
+
+unsigned long processTraceACC(unsigned long key, void *p, ACCELERATOR *accel)
+{
+     register StackFrame *stackFrame = p;
+
+     ssbmode = 0;
+     DBGPrint("\n");
+     lastCommand = 'T';
+     strcpy(debugCommand, "T");
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame,
+		     sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+
+     /* set as focus processor for trace, ssb, or proceed */
+     atomic_inc(&focusActive);
+     atomic_inc(&traceProcessors[get_processor_id()]);
+     return -1;
+}
+
+/* F9 */
+
+unsigned long processGoACC(unsigned long key, void *p, ACCELERATOR *accel)
+{
+     register StackFrame *stackFrame = p;
+
+     ssbmode = 0;
+     DBGPrint("\n");
+     ClearTempBreakpoints();
+     lastCommand = 'G';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame, sizeof(StackFrame));
+
+     stackFrame->tSystemFlags &= ~SINGLE_STEP;
+     stackFrame->tSystemFlags |= RESUME;
+     return -1;
+
+}
+
+unsigned long executeCommandHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("t                        - trace\n");
+    DBGPrint("s                        - single step\n");
+    DBGPrint("ss                       - single step\n");
+    DBGPrint("ssb                      - single step til branch\n");
+    DBGPrint("p                        - proceed\n");
+    DBGPrint("g or g <address>         - go\n");
+    DBGPrint("go or go <address>       - go\n");
+    DBGPrint("q or q <address>         - quit\n");
+    DBGPrint("x or x <address>         - exit\n");
+    DBGPrint("F7                       - trace\n");
+    DBGPrint("F8                       - proceed\n");
+    DBGPrint("F9                       - go\n");
+    DBGPrint("\n");
+    return 1;
+}
+
+/* P */
+
+unsigned long processProceed(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register unsigned long i;
+
+     ssbmode = 0;
+     if (needs_proceed)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = nextUnasmAddress;
+	      BreakType[i] = BREAK_EXECUTE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      BreakTemp[i] = 1;
+	      BreakProceed[i] = 1;
+	      SetDebugRegisters();
+	      lastCommand = 'P';
+	      lastCR0 = ReadCR0();
+	      lastCR2 = ReadCR2();
+	      lastCR4 = ReadCR4();
+	      memmove((void *)&lastStackFrame, stackFrame,
+		      sizeof(StackFrame));
+
+	      stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	      stackFrame->tSystemFlags |= RESUME;
+
+              /* set as focus processor for trace, ssb, or proceed */
+              atomic_inc(&focusActive);
+              atomic_inc(&traceProcessors[get_processor_id()]);
+	      return -1;
+	   }
+	}
+	DBGPrint("\nNo breakpoint available for Proceed, (single step) instead");
+     }
+     lastCommand = 'P';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame,
+	       sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+
+     /* set as focus processor for trace, ssb, or proceed */
+     atomic_inc(&focusActive);
+     atomic_inc(&traceProcessors[get_processor_id()]);
+     return -1;
+
+}
+
+/* SSB */
+
+unsigned long processTraceSSB(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     DBGPrint("\n");
+     ssbmode = 1;
+     lastCommand = 'T';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame,
+		     sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+
+     /* set as focus processor for trace, ssb, or proceed */
+     atomic_inc(&focusActive);
+     atomic_inc(&traceProcessors[get_processor_id()]);
+     return -1;
+
+}
+
+
+/* T */
+
+unsigned long processTrace(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     ssbmode = 0;
+     lastCommand = 'T';
+     lastCR0 = ReadCR0();
+     lastCR2 = ReadCR2();
+     lastCR4 = ReadCR4();
+     memmove((void *)&lastStackFrame, stackFrame,
+		     sizeof(StackFrame));
+
+     stackFrame->tSystemFlags |= (SINGLE_STEP | RESUME);
+
+     /* set as focus processor for trace, ssb, or proceed */
+     atomic_inc(&focusActive);
+     atomic_inc(&traceProcessors[get_processor_id()]);
+     return -1;
+
+}
+
+/* G */
+
+unsigned long processGo(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register unsigned long address;
+     unsigned long valid;
+     register unsigned long i;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     ssbmode = 0;
+     ClearTempBreakpoints();
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_EXECUTE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      BreakTemp[i] = 1;
+	      BreakGo[i] = 1;
+	      SetDebugRegisters();
+	      DBGPrint("\n");
+	      lastCommand = 'G';
+	      lastCR0 = ReadCR0();
+	      lastCR2 = ReadCR2();
+	      lastCR4 = ReadCR4();
+	      memmove((void *)&lastStackFrame, stackFrame,
+			      sizeof(StackFrame));
+
+	      stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	      stackFrame->tSystemFlags |= RESUME;
+	      return -1;
+	   }
+	}
+     }
+     else
+     {
+	DBGPrint("\n");
+	lastCommand = 'G';
+	lastCR0 = ReadCR0();
+	lastCR2 = ReadCR2();
+	lastCR4 = ReadCR4();
+	memmove((void *)&lastStackFrame, stackFrame,
+			sizeof(StackFrame));
+
+	stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	stackFrame->tSystemFlags |= RESUME;
+	return -1;
+     }
+     DBGPrint("no breakpoint available for GO\n");
+     return 1;
+
+}
+
+unsigned long processorCommandHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("lcpu                     - list processors\n");
+    DBGPrint("cpu [p#]                 - switch processor\n");
+    DBGPrint("lr  [p#]                 - display processor registers\n");
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+    DBGPrint("nmi [p#]                 - deliver hard nmi exception\n\n");
+    DBGPrint("The 'nmi [p#]' command will deliver a level triggered\n");
+    DBGPrint("NMI hardware interrupt to a specified processor and system\n");
+    DBGPrint("recovery may not be possible in all cases after issuing this\n");
+    DBGPrint("command.  This command is used to trigger debugger\n");
+    DBGPrint("entry on a hard hung processor.\n\n");
+    DBGPrint("If you just want to switch processors with a soft NMI\n");
+    DBGPrint("exception (which is typically recoverable), then use the\n");
+    DBGPrint("'cpu [p#]' command instead.  Only use the 'nmi [p#]' command\n");
+    DBGPrint("for situations where you need to trigger a hardware NMI to\n");
+    DBGPrint("force a hung processor to enter the debugger.\n");
+#endif
+    return 1;
+}
+
+/* CPU */
+
+unsigned long breakProcessor(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser)
+{
+     register unsigned long cpunum, cpu = get_processor_id();
+     unsigned long valid, i;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     cpunum = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+        if (cpunum == cpu)
+        {
+           DBGPrint("debugger already running on processor %d\n", (int)cpunum);
+           return 1;
+        }
+
+	if ((cpunum > MAX_PROCESSORS) || !(cpu_online(cpunum)))
+        {
+	   DBGPrint("invalid processor specified\n");
+           return 1;
+        }
+
+        for (i = 0; i < MAX_PROCESSORS; i++)
+        {
+           if (cpu_online(i))
+           {
+	      if (i == cpunum)
+              {
+	         ProcessorState[i] = PROCESSOR_SWITCH;
+                 ProcessorHold[cpu] = 1;
+                 barrier();
+                 break;
+              }
+	   }
+        }
+	DBGPrint("\n");
+	lastCommand = 'G';
+	lastCR0 = ReadCR0();
+	lastCR2 = ReadCR2();
+	lastCR4 = ReadCR4();
+	memmove((void *)&lastStackFrame, stackFrame,
+			   sizeof(StackFrame));
+	return -1;
+     }
+     else
+     {
+	DBGPrint("no target processor specified\n");
+        DBGPrint("Current Processor: %d\n", get_processor_id());
+        DBGPrint("Active Processors: ");
+
+        for (i = 0; i < MAX_PROCESSORS; i++)
+        {
+           if (cpu_online(i))
+           {
+	      if (i)
+                 DBGPrint(", ");
+
+	      DBGPrint("%d", i);
+	   }
+        }
+        DBGPrint("\n");
+     }
+     return 1;
+
+}
+
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+/* NMI */
+
+unsigned long nmiProcessor(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser)
+{
+     register unsigned long cpunum, cpu = get_processor_id();
+     unsigned long valid, i;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     cpunum = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+        if (cpunum == cpu)
+        {
+           DBGPrint("debugger already running on processor %d\n", (int)cpunum);
+           return 1;
+        }
+
+	if ((cpunum > MAX_PROCESSORS) || !(cpu_online(cpunum)))
+        {
+	   DBGPrint("invalid processor specified\n");
+           return 1;
+        }
+
+        for (i = 0; i < MAX_PROCESSORS; i++)
+        {
+           if (cpu_online(i))
+           {
+	      if (i == cpunum)
+              {
+	         ProcessorState[i] = PROCESSOR_SWITCH;
+                 ProcessorHold[cpu] = 1;
+                 barrier();
+                 apic_directed_nmi(i);
+                 break;
+              }
+	   }
+        }
+	DBGPrint("\n");
+	lastCommand = 'G';
+	lastCR0 = ReadCR0();
+	lastCR2 = ReadCR2();
+	lastCR4 = ReadCR4();
+	memmove((void *)&lastStackFrame, stackFrame,
+			   sizeof(StackFrame));
+	return -1;
+     }
+     else
+     {
+	DBGPrint("no target processor specified\n");
+        DBGPrint("Current Processor: %d\n", get_processor_id());
+        DBGPrint("Active Processors: ");
+
+        for (i = 0; i < MAX_PROCESSORS; i++)
+        {
+           if (cpu_online(i))
+           {
+	      if (i)
+                 DBGPrint(", ");
+
+	      DBGPrint("%d", i);
+	   }
+        }
+        DBGPrint("\n");
+     }
+     return 1;
+
+}
+#endif
+
+/* LR */
+
+extern  StackFrame CurrentStackFrame[MAX_PROCESSORS];
+
+unsigned long listProcessorFrame(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser)
+{
+     unsigned long valid, pnum;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     pnum = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid && (pnum < MAX_PROCESSORS) && (cpu_online(pnum)))
+     {
+	DBGPrint("Processor Frame %d -> (%08X)\n", pnum,
+                 &CurrentStackFrame[pnum]);
+	DisplayTSS((StackFrame *)&CurrentStackFrame[pnum]);
+     }
+     else
+	DBGPrint("invalid processor frame\n");
+
+     return 1;
+
+}
+
+/* EF */
+
+unsigned long dump_ef(unsigned char *cmd,
+	      StackFrame *stackFrame, unsigned long Exception,
+	      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     unsigned char *addr;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     addr = (unsigned char *)EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+        DBGPrint("invalid frame address\n");
+     }
+     else
+     {
+        addr = (unsigned char *)stackFrame->tReserved[2];
+        DBGPrint("invalid frame pointer address\n");
+     }
+     return 1;
+
+}
+
+/* UF */
+
+unsigned long dump_uf(unsigned char *cmd,
+	      StackFrame *stackFrame, unsigned long Exception,
+	      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     unsigned char *addr;
+     extern int mdb_dumpregs(struct pt_regs *, const char *, const char *);
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     addr = (unsigned char *)EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+        DBGPrint("invalid frame address\n");
+     }
+     else
+     {
+        addr = (unsigned char *)stackFrame->tReserved[2];
+        DBGPrint("invalid frame pointer address\n");
+     }
+     return 1;
+
+}
+
+/* .TA */
+
+unsigned long ProcessTAToggle(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     if (general_toggle)
+     {
+        general_toggle = 0;
+        control_toggle = 0;
+        segment_toggle = 0;
+     }
+     else
+     {
+        general_toggle = 1;
+        control_toggle = 1;
+        segment_toggle = 1;
+     }
+
+     DBGPrint("toggle general registers (%s) \n",
+					    general_toggle ? "ON" : "OFF");
+     DBGPrint("toggle control registers (%s) \n",
+					    control_toggle ? "ON" : "OFF");
+     DBGPrint("toggle segment registers (%s) \n",
+					    segment_toggle ? "ON" : "OFF");
+     return 1;
+
+}
+
+unsigned long TSSDisplayHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint(".t <address>             - display task state regs\n");
+    return 1;
+}
+
+/* .T */
+
+unsigned long TSSDisplay(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+	DisplayTSS(stackFrame);
+     else
+	DisplayTSS((StackFrame *) address);
+
+     return 1;
+}
+
+unsigned long displayRegistersHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("r                        - display registers for a processor\n");
+    DBGPrint("rc                       - display control registers \n");
+    DBGPrint("rs                       - display segment registers \n");
+    DBGPrint("rg                       - display general registers \n");
+    DBGPrint("ra                       - display all registers\n");
+    DBGPrint("rn                       - display coprocessor/MMX registers\n");
+
+    return 1;
+}
+
+/* RC */
+
+unsigned long displayControlRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     DBGPrint("Control Registers\n");
+     DisplayControlRegisters(get_processor_id(), stackFrame);
+     return 1;
+
+}
+
+/* RA */
+
+unsigned long displayAllRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     register unsigned long processor = get_processor_id();
+
+     DBGPrint("General Registers\n");
+     DisplayGeneralRegisters(stackFrame);
+
+     DBGPrint("Segment Registers\n");
+     DisplaySegmentRegisters(stackFrame);
+
+     DBGPrint("Control Registers\n");
+     DisplayControlRegisters(processor, stackFrame);
+
+     if (fpu_present())
+     {
+	DBGPrint("Coprocessor Registers\n");
+	DisplayNPXRegisters(processor);
+     }
+     else
+     {
+	DBGPrint("Coprocessor Not Present\n");
+     }
+     return 1;
+
+}
+
+
+/* RS */
+
+unsigned long displaySegmentRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     DBGPrint("Segment Registers\n");
+     DisplaySegmentRegisters(stackFrame);
+     return 1;
+
+}
+
+/* RN */
+
+unsigned long displayNumericRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     if (fpu_present())
+     {
+	DBGPrint("Coprocessor Registers\n");
+	DisplayNPXRegisters(get_processor_id());
+     }
+     else
+     {
+	DBGPrint("Coprocessor Not Present\n");
+     }
+     return 1;
+
+}
+
+/* RG */
+
+unsigned long displayGeneralRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser)
+{
+     DBGPrint("General Registers\n");
+     DisplayGeneralRegisters(stackFrame);
+     return 1;
+}
+
+#ifdef RENDER_NPX_VALUES
+double ldexp(double v, int e)
+{
+   double two = 2.0;
+
+   if (e < 0)
+   {
+      e = -e; /* This just might overflow on two-complement machines. */
+      if (e < 0)
+         return 0.0;
+
+      while (e > 0)
+      {
+	 if (e & 1)
+         {
+            v = v / two;
+         }
+	 two = two * two;
+	 e >>= 1;
+      }
+   }
+   else
+   if (e > 0)
+   {
+      while (e > 0)
+      {
+	 if (e & 1)
+            v = v * two;
+	 two = two * two;
+	 e >>= 1;
+      }
+   }
+   return v;
+}
+#endif
+
+void DisplayNPXRegisters(unsigned long processor)
+{
+     register int i;
+     int tag;
+     int tos;
+#ifdef RENDER_NPX_VALUES
+     double d;
+#endif
+
+     tos = (npx[processor].status >> 11) & 7;
+     if (tos) {};
+
+     DBGPrint("Control: 0x%04X  Status: 0x%04X  Tag: 0x%04X  TOS: %i CPU: %i\n",
+	       (unsigned)npx[processor].control & 0xFFFF,
+               (unsigned)npx[processor].status & 0xFFFF,
+               (unsigned)npx[processor].tag & 0xFFFF,
+               (int)tos, (int)processor);
+
+     for (i = 0; i < 8; i++)
+     {
+	tos = (npx[processor].status >> 11) & 7;
+	DBGPrint("st(%d)/MMX%d  ", i, (int)((tos + i) % 8));
+
+	if (npx[processor].reg[i].sign)
+	    DBGPrint("-");
+	else
+	    DBGPrint("+");
+
+	DBGPrint(" %04X %04X %04X %04X e %04X    ",
+		 (unsigned)npx[processor].reg[i].sig3,
+		 (unsigned)npx[processor].reg[i].sig2,
+		 (unsigned)npx[processor].reg[i].sig1,
+		 (unsigned)npx[processor].reg[i].sig0,
+		 (unsigned)npx[processor].reg[i].exponent);
+
+	 if (tos) {};
+	 tag = (npx[processor].tag >> (((i + tos) % 8) * 2)) & 3;
+	 switch (tag)
+	 {
+
+	    case 0:
+	       DBGPrint("Valid");
+#ifdef RENDER_NPX_VALUES
+	       if (((int) npx[processor].reg[i].exponent - 16382 < 1000) &&
+		  ((int) npx[processor].reg[i].exponent - 16382 > -1000))
+	       {
+		  d =
+                  npx[processor].reg[i].sig3 / 65536.0 +
+                  npx[processor].reg[i].sig2 / 65536.0 / 65536.0 +
+                  npx[processor].reg[i].sig1 / 65536.0 / 65536.0 / 65536.0;
+
+		  d = ldexp(d, (int) npx[processor].reg[i].exponent - 16382);
+
+	          if (npx[processor].reg[i].sign)
+		     d = -d;
+
+		  DBGPrint("  %.16g", d);
+	       }
+	       else
+		  DBGPrint("  (too big to display)");
+#endif
+	       DBGPrint("\n");
+	       break;
+
+	    case 1:
+	       DBGPrint("Zero\n");
+	       break;
+
+	    case 2:
+	       DBGPrint("Special\n");
+	       break;
+
+	    case 3:
+	       DBGPrint("Empty\n");
+	       break;
+	}
+     }
+}
+
+/* R */
+
+unsigned long displayDefaultRegisters(unsigned char *cmd,
+			     StackFrame *stackFrame, unsigned long Exception,
+			     DEBUGGER_PARSER *parser)
+{
+    register unsigned long processor = get_processor_id();
+
+    DisplayGeneralRegisters(stackFrame);
+
+    if (control_toggle)
+       DisplayControlRegisters(processor, stackFrame);
+
+    if (numeric_toggle)
+       DisplayNPXRegisters(processor);
+
+     disassemble(stackFrame, stackFrame->tEIP, 1, 1);
+     return 1;
+
+}
+
+void displayRegisters(StackFrame *stackFrame, unsigned long processor)
+{
+    if (general_toggle)
+       DisplayGeneralRegisters(stackFrame);
+
+    if (control_toggle)
+       DisplayControlRegisters(processor, stackFrame);
+
+    if (numeric_toggle)
+       DisplayNPXRegisters(processor);
+
+}
+
+unsigned long displayEAXHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* EAX */
+
+unsigned long ChangeEAXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEAX = value;
+	DBGPrint("EAX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+
+/* ORIGEAX */
+
+unsigned long ChangeORIGEAXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tReserved[1] = value;
+	DBGPrint("ORIGEAX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+
+unsigned long displayEBXHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* EBX */
+
+unsigned long ChangeEBXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEBX = value;
+	DBGPrint("EBX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+unsigned long displayECXHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* ECX */
+
+unsigned long ChangeECXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tECX = value;
+	DBGPrint("ECX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+
+unsigned long displayEDXHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* EDX */
+
+unsigned long ChangeEDXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEDX = value;
+	DBGPrint("EDX changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+unsigned long displayESIHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* ESI */
+
+unsigned long ChangeESIRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tESI = value;
+	DBGPrint("ESI changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+
+unsigned long displayEDIHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* EDI */
+
+unsigned long ChangeEDIRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEDI = value;
+	DBGPrint("EDI changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+
+unsigned long displayEBPHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* EBP */
+
+unsigned long ChangeEBPRegister(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEBP = value;
+	DBGPrint("EBP changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+
+unsigned long displayESPHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* ESP */
+
+unsigned long ChangeESPRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tESP = value;
+	DBGPrint("ESP changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+
+unsigned long displayEIPHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* EIP */
+
+unsigned long ChangeEIPRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	stackFrame->tEIP = value;
+	DBGPrint("EIP changed to 0x%08X\n", (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change register command or address\n");
+     return 1;
+
+}
+
+unsigned long displayCSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* CS */
+
+unsigned long ChangeCSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+     register unsigned short oldW;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tCS;
+	stackFrame->tCS = (unsigned short) value;
+	DBGPrint("CS: = [%04X] changed to CS: = [%04X]\n",
+			(unsigned)oldW, (unsigned) value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return 1;
+
+}
+
+unsigned long displayDSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* DS */
+
+unsigned long ChangeDSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+     register unsigned short oldW;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tDS;
+	stackFrame->tDS = (unsigned short) value;
+	DBGPrint("DS: = [%04X] changed to DS: = [%04X]\n",
+			(unsigned)oldW, (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return 1;
+
+}
+
+unsigned long displayESHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* ES */
+
+unsigned long ChangeESRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+     register unsigned short oldW;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tES;
+	stackFrame->tES = (unsigned short) value;
+	DBGPrint("ES: = [%04X] changed to ES: = [%04X]\n",
+			(unsigned)oldW, (unsigned) value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return 1;
+
+}
+
+unsigned long displayFSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* FS */
+
+unsigned long ChangeFSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+     register unsigned short oldW;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tFS;
+	stackFrame->tFS = (unsigned short) value;
+	DBGPrint("FS: = [%04X] changed to FS: = [%04X]\n",
+			(unsigned)oldW, (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return 1;
+
+}
+
+unsigned long displayGSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* GS */
+
+unsigned long ChangeGSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+     register unsigned short oldW;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tGS;
+	stackFrame->tGS = (unsigned short) value;
+	DBGPrint("GS: = [%04X] changed to GS: = [%04X]\n",
+			(unsigned)oldW, (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+     return 1;
+
+}
+
+unsigned long displaySSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* SS */
+
+unsigned long ChangeSSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value;
+     register unsigned short oldW;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldW = stackFrame->tSS;
+	stackFrame->tSS = (unsigned short) value;
+	DBGPrint("SS: = [%04X] changed to SS: = [%04X]\n",
+			(unsigned)oldW, (unsigned)value);
+     }
+     else
+	DBGPrint("invalid change segment register command or address\n");
+
+     return 1;
+
+}
+
+unsigned long displayRFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* RF */
+
+unsigned long ChangeRFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & RF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= RF_FLAG) : (stackFrame->tSystemFlags &= ~RF_FLAG);
+	DBGPrint("EFlag RF[%08X] changed to (%d)\n",
+			(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayTFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* TF */
+
+unsigned long ChangeTFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & TF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= TF_FLAG) : (stackFrame->tSystemFlags &= ~TF_FLAG);
+	DBGPrint("EFlag TF[%08X] changed to (%d)\n",
+			(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayZFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* ZF */
+
+unsigned long ChangeZFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & ZF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= ZF_FLAG) : (stackFrame->tSystemFlags &= ~ZF_FLAG);
+	DBGPrint("EFlag ZF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displaySFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* SF */
+
+unsigned long ChangeSFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & SF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= SF_FLAG) : (stackFrame->tSystemFlags &= ~SF_FLAG);
+	DBGPrint("EFlag SF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayPFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* PF */
+
+unsigned long ChangePFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & PF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= PF_FLAG) : (stackFrame->tSystemFlags &= ~PF_FLAG);
+	DBGPrint("EFlag PF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayCFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* CF */
+
+unsigned long ChangeCFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & CF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= CF_FLAG) : (stackFrame->tSystemFlags &= ~CF_FLAG);
+	DBGPrint("EFlag CF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayOFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* OF */
+
+unsigned long ChangeOFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & OF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= OF_FLAG) : (stackFrame->tSystemFlags &= ~OF_FLAG);
+	DBGPrint("EFlag OF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+
+unsigned long displayIFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* IF */
+
+unsigned long ChangeIFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & IF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= IF_FLAG) : (stackFrame->tSystemFlags &= ~IF_FLAG);
+	DBGPrint("EFlag IF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayIDHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* ID */
+
+unsigned long ChangeIDFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & ID_FLAGS;
+	(value) ? (stackFrame->tSystemFlags |= ID_FLAGS) : (stackFrame->tSystemFlags &= ~ID_FLAGS);
+	DBGPrint("EFlag ID[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayDFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* DF */
+
+unsigned long ChangeDFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & DF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= DF_FLAG) : (stackFrame->tSystemFlags &= ~DF_FLAG);
+	DBGPrint("EFlag DF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayNTHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* NT */
+
+unsigned long ChangeNTFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & NT_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= NT_FLAG) : (stackFrame->tSystemFlags &= ~NT_FLAG);
+	DBGPrint("EFlag NT[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayVMHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* VM */
+
+unsigned long ChangeVMFlag(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & VM_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= VM_FLAG) : (stackFrame->tSystemFlags &= ~VM_FLAG);
+	DBGPrint("EFlag VM[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+
+unsigned long displayVIFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* VIF */
+
+unsigned long ChangeVIFFlag(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & VIF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= VIF_FLAG) : (stackFrame->tSystemFlags &= ~VIF_FLAG);
+	DBGPrint("EFlag VIF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayVIPHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* VIP */
+
+unsigned long ChangeVIPFlag(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & VIP_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= VIP_FLAG) : (stackFrame->tSystemFlags &= ~VIP_FLAG);
+	DBGPrint("EFlag VIP[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayAFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* AF */
+
+unsigned long ChangeAFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & AF_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= AF_FLAG) : (stackFrame->tSystemFlags &= ~AF_FLAG);
+	DBGPrint("EFlag AF[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+
+unsigned long displayACHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    return 1;
+}
+
+/* AC */
+
+unsigned long ChangeACFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long value, oldD;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     value = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	oldD = stackFrame->tSystemFlags & AC_FLAG;
+	(value) ? (stackFrame->tSystemFlags |= AC_FLAG) : (stackFrame->tSystemFlags &= ~AC_FLAG);
+	DBGPrint("EFlag AC[%08X] changed to (%d)\n",
+				(unsigned)oldD, (int)value);
+     }
+     else
+	DBGPrint("invalid change flags command\n");
+     return 1;
+
+}
+
+unsigned long displayMTRRHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("mtrr                     - display memory type range registers\n");
+    return 1;
+}
+
+/* MTRR */
+
+unsigned long DisplayMTRRRegisters(unsigned char *cmd,
+			  StackFrame *stackFrame, unsigned long Exception,
+			  DEBUGGER_PARSER *parser)
+{
+     displayMTRRRegisters();
+     return 1;
+
+}
+
+unsigned long displayGDTHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint(".g or .g <address>       - display global descriptor table\n");
+    return 1;
+}
+
+/* .G */
+
+unsigned long displayGDT(unsigned char *cmd,
+		StackFrame *stackFrame, unsigned long Exception,
+		DEBUGGER_PARSER *parser)
+{
+     register unsigned long address;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+	DisplayGDT((unsigned char *) address);
+     else
+	DisplayGDT((unsigned char *) 0);
+     return 1;
+}
+
+unsigned long displayIDTHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint(".i or .i <address>       - display interrupt descriptor table\n");
+    return 1;
+}
+
+/* .I */
+
+unsigned long displayIDT(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+	DisplayIDT((unsigned char *) address);
+     else
+	DisplayIDT((unsigned char *) 0);
+     return 1;
+}
+
+unsigned long evaluateExpressionHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    extern void displayExpressionHelp(void);
+
+    displayExpressionHelp();
+    return 1;
+}
+
+/* .E */
+
+unsigned long evaluateExpression(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     extern void EvaluateCommandExpression(StackFrame *stackFrame,
+                                           unsigned char *cmd);
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     EvaluateCommandExpression(stackFrame, cmd);
+     return 1;
+}
+
+unsigned long portCommandHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("i   <port>               - input byte from port\n");
+    DBGPrint("ib  <port>               - input byte from port\n");
+    DBGPrint("iw  <port>               - input word from port\n");
+    DBGPrint("il  <port>               - input double word from port\n");
+    DBGPrint("o   <port> <val>         - output byte to port\n");
+    DBGPrint("ob  <port> <val>         - output byte to port\n");
+    DBGPrint("ow  <port> <val>         - output word to port\n");
+    DBGPrint("ol  <port> <val>         - output double word to port\n");
+    return 1;
+}
+
+/* IW */
+
+unsigned long inputWordPort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	DBGPrint("inportw (%04X) = %04X\n",
+                     (unsigned)address, (unsigned)inw(address));
+     }
+     else
+     {
+	DBGPrint("bad port command\n");
+     }
+     return 1;
+
+}
+
+/* ID */
+
+unsigned long inputDoublePort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	DBGPrint("inportd (%04X) = %08X\n",
+			  (unsigned)address, (unsigned)inl(address));
+     }
+     else
+     {
+	DBGPrint("bad port command\n");
+     }
+     return 1;
+
+}
+
+/* IB */
+
+unsigned long inputBytePort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	DBGPrint("inportb (%04X) = %02X\n",
+			  (unsigned)address, (unsigned)inb(address));
+     }
+     else
+     {
+	DBGPrint("bad port command\n");
+     }
+     return 1;
+
+}
+
+/* I */
+
+unsigned long inputPort(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser)
+{
+     register unsigned long address;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	DBGPrint("inportb (%04X) = %02X\n",
+			  (unsigned)address, (unsigned)inb(address));
+     }
+     else
+     {
+	DBGPrint("bad port command\n");
+     }
+     return 1;
+
+}
+
+/* OW */
+
+unsigned long outputWordPort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long port, value;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     port = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	value = EvaluateExpression(stackFrame, &cmd, &valid);
+	if (valid)
+	{
+	   DBGPrint("outportw (%04X) = %04X\n",
+				    (unsigned)port, (unsigned)value);
+	   outw(port, value);
+	   return 1;
+	}
+     }
+     else
+	DBGPrint("bad port command\n");
+
+     return 1;
+
+}
+
+/* OD */
+
+unsigned long outputDoublePort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long port, value;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     port = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	value = EvaluateExpression(stackFrame, &cmd, &valid);
+	if (valid)
+	{
+	   DBGPrint("outportd (%04X) = %08X\n",
+			    (unsigned)port, (unsigned)value);
+	   outl(port, value);
+	   return 1;
+	}
+     }
+     else
+	DBGPrint("bad port command\n");
+
+     return 1;
+
+}
+
+/* OB */
+
+unsigned long outputBytePort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long port, value;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     port = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	value = EvaluateExpression(stackFrame, &cmd, &valid);
+	if (valid)
+	{
+	   DBGPrint("outportb (%04X) = %02X\n",
+			    (unsigned)port, (unsigned)value);
+	   outb(port, value);
+	   return 1;
+	}
+     }
+     else
+	DBGPrint("bad port command\n");
+
+     return 1;
+
+}
+
+/* O */
+
+unsigned long outputPort(unsigned char *cmd,
+		StackFrame *stackFrame, unsigned long Exception,
+		DEBUGGER_PARSER *parser)
+{
+     register unsigned long port, value;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     port = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	value = EvaluateExpression(stackFrame, &cmd, &valid);
+	if (valid)
+	{
+	   DBGPrint("outportb (%04X) = %02X\n",
+			    (unsigned)port, (unsigned)value);
+	   outb(port, value);
+	   return 1;
+	}
+     }
+     else
+	DBGPrint("bad port command\n");
+
+     return 1;
+
+}
+
+unsigned long breakpointCommandHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("b                        - display all breakpoints\n");
+    DBGPrint("b   <address>            - set execute breakpoint\n");
+    DBGPrint("bc  [#] (1-4)            - clear breakpoint\n");
+    DBGPrint("bca                      - clear all breakpoints\n");
+    DBGPrint("br[#] <address>          - set read/write breakpoint #=1,2 or 4 byte len\n");
+    DBGPrint("bw[#] <address>          - set write only breakpoint #=1,2 or 4 byte len\n");
+    DBGPrint("bi[#] <address>          - set io address breakpoint #=1,2 or 4 byte len\n");
+    DBGPrint("bm  [p#]                 - mask breaks for specific processor \n");
+    DBGPrint("bst                      - display temporary (go/proceed) breakpoints\n");
+    return 1;
+}
+
+/* BCA */
+
+unsigned long breakpointClearAll(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long i;
+
+     for (i = 0; i < 4; i++)
+     {
+	BreakReserved[i] = 0;
+	BreakPoints[i] = 0;
+	BreakType[i] = 0;
+	BreakLength[i] = 0;
+	ConditionalBreakpoint[i] = 0;
+     }
+     SetDebugRegisters();
+     DBGPrint("all breakpoints cleared\n");
+
+     return 1;
+
+}
+
+/* BC */
+
+unsigned long breakpointClear(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     unsigned long valid;
+     register unsigned long i, address;
+     register unsigned char *symbolName;
+     register unsigned char *moduleName;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	i = address;
+	if (i < 4)
+	{
+	   symbolName = GetSymbolFromValue(BreakPoints[i], &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	   moduleName = GetModuleInfoFromSymbolValue(BreakPoints[i],
+                                           &modbuf[c][0], MAX_SYMBOL_LEN);
+           if (moduleName)
+	      DBGPrint("breakpoint %i at 0x%08X (%s %s) %s|%s cleared\n",
+			     (int)i,
+			     (unsigned)BreakPoints[i],
+			     BreakDescription[(BreakType[i] & 3)],
+			     BreakLengthDescription[(BreakLength[i] & 3)],
+			     ((char *)(moduleName) ? (char *)(moduleName)
+                             : (char *)("")),
+			     ((char *)(symbolName) ? (char *)(symbolName)
+                             : (char *)("")));
+           else
+	      DBGPrint("breakpoint %i at 0x%08X (%s %s) %s cleared\n",
+			     (int)i,
+			     (unsigned)BreakPoints[i],
+			     BreakDescription[(BreakType[i] & 3)],
+			     BreakLengthDescription[(BreakLength[i] & 3)],
+			     ((char *)(symbolName) ? (char *)(symbolName)
+                             : (char *)("")));
+	   BreakReserved[i] = 0;
+	   BreakPoints[i] = 0;
+	   BreakType[i] = 0;
+	   BreakLength[i] = 0;
+	   ConditionalBreakpoint[i] = 0;
+	   SetDebugRegisters();
+	   return 1;
+	}
+	else
+	   DBGPrint("breakpoint out of range\n");
+	return 1;
+     }
+     DBGPrint("breakpoint not found\n");
+     return 1;
+}
+
+/* BM */
+
+unsigned long breakpointMask(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, pnum, i;
+     unsigned long valid;
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	pnum = address;
+	if (pnum < MAX_PROCESSORS)
+	{
+	   if (BreakMask[pnum])
+	      BreakMask[pnum] = 0;
+	   else
+	      BreakMask[pnum] = 1;
+	   DBGPrint("processor %i : %s\n", (int)pnum,
+		   BreakMask[pnum] ? "BREAKS_MASKED" : "BREAKS_UNMASKED");
+	}
+	else
+	   DBGPrint("processor (%i) invalid\n", (int)pnum);
+     }
+     else
+     {
+	for (i = 0; i < MAX_PROCESSORS; i++)
+	{
+	   DBGPrint("processor %i : %s\n", (int)i,
+		    BreakMask[i] ? "BREAKS_MASKED" : "BREAKS_UNMASKED");
+	}
+     }
+     return 1;
+
+}
+
+/* BW1 */
+
+unsigned long breakpointWord1(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_WRITE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+		               ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+/* BW2 */
+
+unsigned long breakpointWord2(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_WRITE;
+	      BreakLength[i] = TWO_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+/* BW4 */
+
+unsigned long breakpointWord4(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_WRITE;
+	      BreakLength[i] = FOUR_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+/* BW */
+
+unsigned long breakpointWord(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_WRITE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+
+/* BR1 */
+
+unsigned long breakpointRead1(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_READWRITE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+
+/* BR2 */
+
+unsigned long breakpointRead2(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_READWRITE;
+	      BreakLength[i] = TWO_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+
+/* BR4 */
+
+unsigned long breakpointRead4(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_READWRITE;
+	      BreakLength[i] = FOUR_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+
+/* BR */
+
+unsigned long breakpointRead(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_READWRITE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+/* BI1 */
+
+unsigned long breakpointIO1(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_IOPORT;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+/* BI2 */
+
+unsigned long breakpointIO2(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_IOPORT;
+	      BreakLength[i] = TWO_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+/* BI4 */
+
+unsigned long breakpointIO4(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_IOPORT;
+	      BreakLength[i] = FOUR_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+/* BI */
+
+unsigned long breakpointIO(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (valid)
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; (r < 255) && (*pB); r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_IOPORT;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     else
+	DBGPrint("breakpoint parameters invalid\n");
+     return 1;
+
+}
+
+/* B */
+
+unsigned long breakpointExecute(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser)
+{
+     register unsigned long address, i, r;
+     register unsigned char *pB, *symbolName;
+     register unsigned char *moduleName;
+     unsigned long valid;
+     register int c = get_processor_id();
+
+     cmd = &cmd[parser->debugCommandNameLength];
+     while (*cmd && *cmd == ' ')
+        cmd++;
+
+     address = EvaluateExpression(stackFrame, &cmd, &valid);
+     if (!valid)
+     {
+        register int found = 0;
+
+	for (i = 0; i < 4; i++)
+	{
+	   if (BreakReserved[i])
+	   {
+	      symbolName = GetSymbolFromValue(BreakPoints[i], &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(BreakPoints[i],
+                                           &modbuf[c][0], MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("Break %i is at 0x%08X (%s %s) %s|%s\n",
+				(int)i,
+				(unsigned)BreakPoints[i],
+				BreakDescription[(BreakType[i] & 3)],
+				BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                : (char *)("")),
+			        ((char *)(symbolName) ? (char *)(symbolName)
+                                : (char *)("")));
+              else
+	         DBGPrint("Break %i is at 0x%08X (%s %s) %s\n",
+				(int)i,
+				(unsigned)BreakPoints[i],
+				BreakDescription[(BreakType[i] & 3)],
+				BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(symbolName) ? (char *)(symbolName)
+                                : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+              found = 1;
+	   }
+	}
+        if (!found)
+           DBGPrint("no breakpoints currently defined\n");
+
+     }
+     else
+     {
+	for (i = 0; i < 4; i++)
+	{
+	   if (!BreakReserved[i])
+	   {
+	      pB = cmd;
+	      EvaluateExpression(stackFrame, &cmd, &valid);
+	      if (valid)
+	      {
+		 ConditionalBreakpoint[i] = 1;
+		 for (r = 0; r < 255 && *pB; r++)
+		    BreakCondition[i][r] = *pB++;
+		 BreakCondition[i][r] = '\0';
+	      }
+	      BreakReserved[i] = 1;
+	      BreakPoints[i] = address;
+	      BreakType[i] = BREAK_EXECUTE;
+	      BreakLength[i] = ONE_BYTE_FIELD;
+	      symbolName = GetSymbolFromValue(address, &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	      moduleName = GetModuleInfoFromSymbolValue(address, &modbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+              if (moduleName)
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s|%s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(moduleName) ? (char *)(moduleName)
+                                 : (char *)("")),
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+              else
+	         DBGPrint("breakpoint %i set to 0x%08X (%s %s) %s\n",
+				 (int)i,
+				 (unsigned)BreakPoints[i],
+				 BreakDescription[(BreakType[i] & 3)],
+				 BreakLengthDescription[(BreakLength[i] & 3)],
+			         ((char *)(symbolName) ? (char *)(symbolName)
+                                 : (char *)("")));
+
+	      if (ConditionalBreakpoint[i])
+		 DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+	      SetDebugRegisters();
+	      return 1;
+	   }
+	}
+	DBGPrint("no breakpoint available\n");
+     }
+     return 1;
+
+}
+
+/* BST */
+
+unsigned long breakpointShowTemp(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser)
+{
+     register unsigned long i;
+     register unsigned char *symbolName;
+     register unsigned char *moduleName;
+     register int found = 0;
+     register int c = get_processor_id();
+
+     for (i = 0; i < 4; i++)
+     {
+	if (BreakReserved[i] && BreakTemp[i])
+	{
+	   symbolName = GetSymbolFromValue(BreakPoints[i], &symbuf[c][0],
+                                           MAX_SYMBOL_LEN);
+	   moduleName = GetModuleInfoFromSymbolValue(BreakPoints[i],
+                                           &modbuf[c][0], MAX_SYMBOL_LEN);
+           if (moduleName)
+	      DBGPrint("Break %i is at 0x%08X (%s %s) %s|%s [%s]\n",
+				(int)i,
+				(unsigned)BreakPoints[i],
+				BreakDescription[(BreakType[i] & 3)],
+				BreakLengthDescription[(BreakLength[i] & 3)],
+			       ((char *)(moduleName) ? (char *)(moduleName)
+                                : (char *)("")),
+			        ((char *)(symbolName) ? (char *)(symbolName)
+                                : (char *)("")),
+				BreakGo[i] ? "GO" : BreakProceed[i]
+                                ? "PROCEED" : "");
+           else
+	      DBGPrint("Break %i is at 0x%08X (%s %s) %s [%s]\n",
+				(int)i,
+				(unsigned)BreakPoints[i],
+				BreakDescription[(BreakType[i] & 3)],
+				BreakLengthDescription[(BreakLength[i] & 3)],
+			        ((char *)(symbolName) ? (char *)(symbolName)
+                                : (char *)("")),
+				BreakGo[i] ? "GO" : BreakProceed[i]
+                                ? "PROCEED" : "");
+	   if (ConditionalBreakpoint[i])
+	      DBGPrint("if (%s) is TRUE\n", BreakCondition[i]);
+
+           found = 1;
+	}
+     }
+     if (!found)
+        DBGPrint("no temporary breakpoints defined\n");
+
+     return 1;
+
+}
+
+unsigned long displayProcessorStatusHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("displays active processors and their current state\n");
+    return 1;
+}
+
+unsigned long displayProcessorStatus(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser)
+{
+     register unsigned long i;
+
+     for (i = 0; i < MAX_PROCESSORS; i++)
+     {
+        if (cpu_online(i))
+        {
+	   DBGPrint("Processor: (%i)  State:  %s\n",
+	              i, procState[ProcessorState[i] & 0xF]);
+        }
+     }
+     return 1;
+}
+
+void displayMTRRRegisters(void)
+{
+    register int i;
+    unsigned long base1, base2;
+    unsigned long mask1, mask2;
+    extern unsigned long cpu_mttr_on(void);
+
+    if (cpu_mttr_on())
+    {
+       DBGPrint("memory type range registers\n");
+       for (i = 0; i < 8; i++)
+       {
+	  ReadMSR(MTRR_BASE_REGS[i], &base1, &base2);
+	  ReadMSR(MTRR_MASK_VALUES[i], &mask1, &mask2);
+	  DBGPrint("MTRR_BASE_%i  %08X:%08X   MTRR_MASK_%i  %08X:%08X\n",
+			   (int)i,
+                           (unsigned)base1, (unsigned)base2,
+                           (int)i,
+                           (unsigned)mask1, (unsigned)mask2);
+       }
+    }
+    else
+       DBGPrint("memory type range registers are Pentium Pro/II/Xeon and above\n");
+    return;
+}
+
+void DisplayGDT(unsigned char *GDT_ADDRESS)
+{
+
+    register int i, r;
+    unsigned long count;
+    unsigned long gdt_pointer;
+    unsigned short gdt_index;
+    unsigned char *p;
+    unsigned char GDTR[8];
+    GDT *gdt;
+    TSS *tss;
+    union
+    {
+       GDT lgdt;
+       unsigned char data[8];
+    } lg;
+
+    ReadGDTR((unsigned long *)&GDTR[0]);
+    gdt_index = mdb_getword((unsigned long)&GDTR[0], 2);
+    gdt_pointer = mdb_getword((unsigned long)&GDTR[2], 4);
+
+    DBGPrint("GDTR: %04X:%08X  Processor: %i\n",
+                  (unsigned)gdt_index, (unsigned)gdt_pointer,
+                  (int)get_processor_id());
+
+    count = 0;
+    gdt_index = (gdt_index + 7) / 8;
+    p = (unsigned char *) gdt_pointer;
+    for (i = 0; i < gdt_index; i++)
+    {
+       if (DBGPrint("%08X (%04i):", (unsigned) count, (int)i)) return;
+       for (r = 0; r < 8; r++)
+       {
+	  lg.data[r] = (unsigned char) mdb_getword((unsigned long)&p[r], 1);
+	  if (DBGPrint(" %02X", (unsigned char) lg.data[r])) return;
+       }
+
+       gdt = (GDT *) &lg.lgdt;
+       if ((gdt->GDTType & 0x92) == 0x92)
+       {
+	  if (DBGPrint("  b:%08X lim:%08X t:%02X ot:%02X",
+		   ((gdt->Base3 << 24) | (gdt->Base2 << 16) |
+                   (gdt->Base1)),
+		   (((gdt->OtherType & 0xF) << 16) | (gdt->Limit)),
+		   gdt->GDTType, gdt->OtherType)) return;
+       }
+       else if ((gdt->GDTType & 0x89) == 0x89)
+       {
+	  tss = (TSS *) gdt;
+	  if (DBGPrint("  tss:%08X lim:%04X t:%02X ot:%02X",
+		      ((tss->TSSBase3 << 24) | (tss->TSSBase2 << 16) |
+                      (tss->TSSBase1)),
+		      tss->TSSLimit, tss->TSSType,
+                      tss->TSSOtherType)) return;
+       }
+       if (DBGPrint("\n")) return;
+
+       p = (void *)((unsigned long) p + (unsigned long) 8);
+       count += 8;
+    }
+
+    return;
+
+}
+
+void DisplayIDT(unsigned char *IDT_ADDRESS)
+{
+
+    register int i, r;
+    unsigned long count;
+    unsigned long idt_pointer;
+    unsigned short idt_index;
+    unsigned char *p;
+    unsigned char IDTR[8];
+    IDT *idt;
+    TSS_GATE *tss_gate;
+    union
+    {
+       IDT lidt;
+       unsigned char data[8];
+    } id;
+
+    ReadIDTR((unsigned long *)&IDTR[0]);
+    idt_index = mdb_getword((unsigned long)&IDTR[0], 2);
+    idt_pointer = mdb_getword((unsigned long)&IDTR[2], 4);
+
+    DBGPrint("IDTR: %04X:%08X  Processor: %i\n",
+                    (unsigned)idt_index, (unsigned)idt_pointer,
+                    (int)get_processor_id());
+
+    count = 0;
+    idt_index = (idt_index + 7) / 8;
+    p = (unsigned char *) idt_pointer;
+    for (i = 0; i < idt_index; i++)
+    {
+       if (DBGPrint("%08X (%04i):", (unsigned)count, (int)i)) return;
+       for (r = 0; r < 8; r++)
+       {
+	   id.data[r] = mdb_getword((unsigned long)&p[r], 1);
+	   if (DBGPrint(" %02X", (unsigned char) id.data[r])) return;
+       }
+       idt = (IDT *) &id.lidt;
+       if ((idt->IDTFlags & 0x8E) == 0x8E)
+       {
+	  if (DBGPrint("  b:%08X s:%04X t:%02X ot:%02X",
+			     ((idt->IDTHigh << 16) | (idt->IDTLow)),
+			     idt->IDTSegment,
+			     idt->IDTFlags, idt->IDTSkip)) return;
+
+       }
+       else if ((idt->IDTFlags & 0x85) == 0x85)
+       {
+	  tss_gate = (TSS_GATE *) idt;
+	  if (DBGPrint("  task_gate: %04X t:%02X",
+		     tss_gate->TSSSelector, tss_gate->TSSFlags)) return;
+       }
+       if (DBGPrint("\n")) return;
+
+       p = (void *)((unsigned long) p + (unsigned long) 8);
+       count += 8;
+    }
+
+    return;
+
+}
+
+void DisplayTSS(StackFrame *stackFrame)
+{
+
+    unsigned long i, f = 0;
+
+    DBGPrint("Task State Segment at 0x%08X\n",
+        (unsigned)stackFrame);
+
+    DBGPrint("LDT: %08X  CR3: %08X  IOMAP: %08X  BLINK: %08X\n",
+	(unsigned)stackFrame->tLDT,
+        (unsigned)stackFrame->tCR3,
+        (unsigned)stackFrame->tIOMap,
+        (unsigned)stackFrame->tReserved[0]);
+
+    DBGPrint("CS: %04X  DS: %04X  ES: %04X  FS: %04X  GS: %04X  SS: %04X\n",
+       (unsigned)stackFrame->tCS,
+       (unsigned)stackFrame->tDS,
+       (unsigned)stackFrame->tES,
+       (unsigned)stackFrame->tFS,
+       (unsigned)stackFrame->tGS,
+       (unsigned)stackFrame->tSS);
+
+    DBGPrint("EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X\n",
+       (unsigned)stackFrame->tEAX,
+       (unsigned)stackFrame->tEBX,
+       (unsigned)stackFrame->tECX,
+       (unsigned)stackFrame->tEDX);
+
+    DBGPrint("ESI: %08X  EDI: %08X  ESP: %08X  EBP: %08X\n",
+       (unsigned)stackFrame->tESI,
+       (unsigned)stackFrame->tEDI,
+       (unsigned)stackFrame->tESP,
+       (unsigned)stackFrame->tEBP);
+
+    DBGPrint("EIP: %08X  FLAGS: %08X ",
+       (unsigned)stackFrame->tEIP,
+       (unsigned)stackFrame->tSystemFlags);
+
+    DBGPrint(" (");
+    for (i = 0; i < 22; i++)
+    {
+       if (IA32Flags[i])
+       {
+	  if ((stackFrame->tSystemFlags >> i) & 0x00000001)
+	  {
+	     if (f)
+		DBGPrint(" ");
+	     f = 1;
+	     DBGPrint("%s", IA32Flags[i]);
+	  }
+       }
+    }
+    DBGPrint(")\n");
+
+
+}
+
+void DisplayGeneralRegisters(StackFrame *stackFrame)
+{
+
+    unsigned long i, f = 0;
+
+    DBGPrint("EAX: %08X ", (unsigned)stackFrame->tEAX);
+    DBGPrint("EBX: %08X ", (unsigned)stackFrame->tEBX);
+    DBGPrint("ECX: %08X ", (unsigned)stackFrame->tECX);
+    DBGPrint("EDX: %08X\n", (unsigned)stackFrame->tEDX);
+    DBGPrint("ESI: %08X ", (unsigned)stackFrame->tESI);
+    DBGPrint("EDI: %08X ", (unsigned)stackFrame->tEDI);
+    DBGPrint("ESP: %08X ", (unsigned)stackFrame->tESP);
+    DBGPrint("EBP: %08X\n", (unsigned)stackFrame->tEBP);
+
+    if (segment_toggle)
+       DisplaySegmentRegisters(stackFrame);
+
+    DBGPrint("EIP: %08X ", (unsigned)stackFrame->tEIP);
+    DBGPrint("ORGEAX: %08X ", (unsigned)stackFrame->tReserved[1]);
+    DBGPrint("EFLAGS: %08X ", (unsigned)stackFrame->tSystemFlags);
+
+    DBGPrint(" (");
+    for (i = 0; i < 22; i++)
+    {
+       if (IA32Flags[i])
+       {
+	  if ((stackFrame->tSystemFlags >> i) & 0x00000001)
+	  {
+	     if (f)
+		DBGPrint(" ");
+	     f = 1;
+	     DBGPrint("%s", IA32Flags[i]);
+	  }
+       }
+    }
+    DBGPrint(")\n");
+
+}
+
+void DisplaySegmentRegisters(StackFrame *stackFrame)
+{
+
+    DBGPrint("CS: %04X ", (unsigned)stackFrame->tCS);
+    DBGPrint("DS: %04X ", (unsigned)stackFrame->tDS);
+    DBGPrint("ES: %04X ", (unsigned)stackFrame->tES);
+    DBGPrint("FS: %04X ", (unsigned)stackFrame->tFS);
+    DBGPrint("GS: %04X ", (unsigned)stackFrame->tGS);
+    DBGPrint("SS: %04X\n", (unsigned)stackFrame->tSS);
+
+}
+
+void DisplayControlRegisters(unsigned long processor, StackFrame *stackFrame)
+{
+
+    unsigned char GDTR[8], IDTR[8];
+
+    if (stackFrame) {};
+
+    DBGPrint("CR0: %08X ", (unsigned)ReadCR0());
+    DBGPrint("CR2: %08X ", (unsigned)ReadCR2());
+    DBGPrint("CR3: %08X ", (unsigned)ReadCR3());
+    DBGPrint("CR4: %08X\n", (unsigned)ReadCR4());
+    DBGPrint("DR0: %08X ", (unsigned)ReadDR0());
+    DBGPrint("DR1: %08X ", (unsigned)ReadDR1());
+    DBGPrint("DR2: %08X ", (unsigned)ReadDR2());
+    DBGPrint("DR3: %08X\n", (unsigned)ReadDR3());
+    DBGPrint("DR6: %08X ", (unsigned)ReadDR6());
+    DBGPrint("DR7: %08X ", (unsigned)ReadDR7());
+    DBGPrint("VR6: %08X ", (unsigned)CurrentDR6[processor]);
+    DBGPrint("VR7: %08X\n", (unsigned)CurrentDR7);
+
+    ReadGDTR((unsigned long *)&GDTR[0]);
+    ReadIDTR((unsigned long *)&IDTR[0]);
+    DBGPrint("GDTR: %04X:%08X IDTR: %04X:%08X  LDTR: %04X  TR: %04X\n",
+			(unsigned)*(unsigned short *)&GDTR[0],
+                        (unsigned)*(unsigned long *)&GDTR[2],
+			(unsigned)*(unsigned short *)&IDTR[0],
+                        (unsigned)*(unsigned long *)&IDTR[2],
+			(unsigned)ReadLDTR(),
+                        (unsigned)ReadTR());
+
+}
+
+unsigned long ConsoleDisplayBreakReason(StackFrame *stackFrame,
+                                        unsigned long Exception,
+                                        unsigned long processor,
+                                        unsigned long lastCommand)
+{
+       if (last_mdb_oops)
+          DBGPrint("\nKernel Oops reported (%s)\n", last_mdb_oops);
+
+       if ((CurrentDR6[processor] & B0_BIT) && (CurrentDR7 & G0_BIT) &&
+            Exception == 1)
+       {
+	  if (BreakGo[0])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - GO breakpoint (0)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (BreakProceed[0])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed breakpoint (0)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (BreakPoints[0] && ConditionalBreakpoint[0])
+	  {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 0 (%s)\n",
+				 (unsigned)stackFrame->tEIP,
+                                 BreakDescription[(BreakType[0] & 3)]);
+	     DBGPrint("expr: %s was TRUE\n", BreakCondition[0]);
+             return 1;
+	  }
+	  else
+          if (BreakPoints[0])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 0 (%s)\n",
+				 (unsigned)stackFrame->tEIP,
+                                 BreakDescription[(BreakType[0] & 3)]);
+             return 1;
+          }
+          else
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - INT1 breakpoint (B0)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;  /* not one of ours */
+          }
+       }
+       else
+       if ((CurrentDR6[processor] & B1_BIT) && (CurrentDR7 & G1_BIT) &&
+            Exception == 1)
+       {
+	  if (BreakGo[1])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - GO breakpoint (1)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (BreakProceed[1])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed breakpoint (1)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (BreakPoints[1] && ConditionalBreakpoint[1])
+	  {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 1 (%s)\n",
+				 (unsigned)stackFrame->tEIP,
+                                 BreakDescription[(BreakType[1] & 3)]);
+	     DBGPrint("expr: %s was TRUE\n", BreakCondition[1]);
+             return 1;
+	  }
+	  else
+          if (BreakPoints[1])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 1 (%s)\n",
+				 (unsigned)stackFrame->tEIP,
+                                 BreakDescription[(BreakType[1] & 3)]);
+             return 1;
+          }
+          else
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - INT1 breakpoint (B1)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;  /* not one of ours */
+          }
+       }
+       else
+       if ((CurrentDR6[processor] & B2_BIT) && (CurrentDR7 & G2_BIT) &&
+            Exception == 1)
+       {
+	  if (BreakGo[2])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - GO breakpoint (2)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (BreakProceed[2])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed breakpoint (2)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (BreakPoints[2] && ConditionalBreakpoint[2])
+	  {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 2 (%s)\n",
+				 (unsigned)stackFrame->tEIP,
+                                 BreakDescription[(BreakType[2] & 3)]);
+	     DBGPrint("expr: %s was TRUE\n", BreakCondition[2]);
+             return 1;
+	  }
+	  else
+          if (BreakPoints[2])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 2 (%s)\n",
+				 (unsigned)stackFrame->tEIP,
+                                 BreakDescription[(BreakType[2] & 3)]);
+             return 1;
+          }
+          else
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - INT1 breakpoint (B2)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;  /* not one of ours */
+          }
+       }
+       else
+       if ((CurrentDR6[processor] & B3_BIT) && (CurrentDR7 & G3_BIT) &&
+            Exception == 1)
+       {
+	  if (BreakGo[3])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - GO breakpoint (3)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (BreakProceed[3])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed breakpoint (3)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (BreakPoints[3] && ConditionalBreakpoint[3])
+	  {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 3 (%s)\n",
+				 (unsigned)stackFrame->tEIP,
+                                 BreakDescription[(BreakType[3] & 3)]);
+	     DBGPrint("expr: %s was TRUE\n", BreakCondition[3]);
+             return 1;
+	  }
+	  else
+          if (BreakPoints[3])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - breakpoint 3 (%s)\n",
+				 (unsigned)stackFrame->tEIP,
+                                 BreakDescription[(BreakType[3] & 3)]);
+             return 1;
+          }
+          else
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - INT1 breakpoint (B3)\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;  /* not one of ours */
+          }
+       }
+       else
+       {
+	  /* if the last command was a Proceed that was converted into a */
+	  /* single step command, report proceed single step */
+	  if (lastCommandEntry == 'P' && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed (single step)\n",
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (lastCommandEntry == 'T' && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Trace (single step)\n",
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+          else
+	  if (lastCommandEntry == K_F8 && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Proceed (single step)\n",
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (lastCommandEntry == K_F7 && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - Trace (single step)\n",
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if (lastCommandEntry == K_F6 && Exception == 1)
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - SSB (step til branch)\n",
+                      (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+          else
+          if (Exception == 3)  /* not our exception */
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - INT3 breakpoint\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+          else
+          if (Exception == 1)  /* not our exception, must be gdb */
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - INT1 breakpoint\n",
+				 (unsigned)stackFrame->tEIP);
+             return 1;
+          }
+	  else
+          if ((Exception < exceptions) &&
+              ExceptionDescription[Exception % exceptions])
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - %s\n",
+                    (unsigned)stackFrame->tEIP,
+                    ExceptionDescription[Exception % exceptions]);
+             return 1;
+          }
+          else
+          {
+	     DBGPrint("\nBreak at 0x%08X due to - %lu\n",
+                    (unsigned)stackFrame->tEIP, Exception);
+             return 1;
+          }
+       }
+       DBGPrint("\nBreak at 0x%08X due to - Unknown Reason\n",
+	        (unsigned)stackFrame->tEIP);
+       return 1;
+
+}
+
+unsigned long ReasonHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser)
+{
+    DBGPrint("display break reason\n");
+    return 1;
+}
+
+unsigned long ReasonDisplay(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser)
+{
+     ConsoleDisplayBreakReason(stackFrame, Exception, get_processor_id(), 0);
+     return 1;
+}
+
+void ReadStackFrame(void *frame, StackFrame *sf, unsigned long processor)
+{
+   struct pt_regs *regs = frame;
+
+   sf->tCR3 = (unsigned long *)ReadCR3();
+   sf->tEIP = regs->ip;
+   sf->tSystemFlags = regs->flags;
+   sf->tReserved[1] = regs->orig_ax;
+   sf->tReserved[2] = (unsigned long)regs;
+   sf->tEAX = regs->ax;
+   sf->tECX = regs->cx;
+   sf->tEDX = regs->dx;
+   sf->tEBX = regs->bx;
+   sf->tEBP = regs->bp;
+   sf->tESI = regs->si;
+   sf->tEDI = regs->di;
+   sf->tES = (unsigned short)regs->es;
+   sf->tCS = (unsigned short)regs->cs;
+   sf->tDS = (unsigned short)regs->ds;
+   sf->tFS = (ReadFS() & 0xFFFF);
+   sf->tGS = (ReadGS() & 0xFFFF);
+   sf->tLDT = (ReadLDTR() & 0xFFFF);
+   if ((regs->cs & 0xffff) == __KERNEL_CS)
+   {
+      sf->tESP = (unsigned long)((unsigned long)regs + sizeof(struct pt_regs) - 2*4);
+      asm ("pushl %%ss\n"
+		   "popl %0\n"
+                  :"=m" (sf->tSS));
+      sf->tSS &= 0xFFFF;
+   }
+   else
+   {
+      sf->tESP = regs->sp;
+      sf->tSS = (unsigned short)regs->ss;
+   }
+   /* save state. */
+   memmove((void *)&ReferenceFrame[processor], sf, sizeof(StackFrame));
+   return;
+}
+
+void WriteStackFrame(void *frame, StackFrame *sf, unsigned long processor)
+{
+   struct pt_regs *regs = frame;
+
+   if (ReferenceFrame[processor].tEIP != sf->tEIP)
+      regs->ip = sf->tEIP;
+   if (ReferenceFrame[processor].tSystemFlags != sf->tSystemFlags)
+      regs->flags = sf->tSystemFlags;
+   if (ReferenceFrame[processor].tReserved[1] != sf->tReserved[1])
+      regs->orig_ax = sf->tReserved[1];
+   if (ReferenceFrame[processor].tEAX != sf->tEAX)
+      regs->ax = sf->tEAX;
+   if (ReferenceFrame[processor].tECX != sf->tECX)
+      regs->cx = sf->tECX;
+   if (ReferenceFrame[processor].tEDX != sf->tEDX)
+      regs->dx = sf->tEDX;
+   if (ReferenceFrame[processor].tEBX != sf->tEBX)
+      regs->bx = sf->tEBX;
+   if (ReferenceFrame[processor].tESP != sf->tESP)
+      regs->sp = sf->tESP;
+   if (ReferenceFrame[processor].tEBP != sf->tEBP)
+      regs->bp = sf->tEBP;
+   if (ReferenceFrame[processor].tESI != sf->tESI)
+      regs->si = sf->tESI;
+   if (ReferenceFrame[processor].tEDI != sf->tEDI)
+      regs->di = sf->tEDI;
+   if (ReferenceFrame[processor].tES != sf->tES)
+      regs->es = sf->tES;
+   if (ReferenceFrame[processor].tCS != sf->tCS)
+      regs->cs = sf->tCS;
+   if (ReferenceFrame[processor].tSS != sf->tSS)
+      regs->ss = sf->tSS;
+   if (ReferenceFrame[processor].tDS != sf->tDS)
+      regs->ds = sf->tDS;
+   return;
+}
+
+void SetDebugRegisters(void)
+{
+   register int i;
+
+   for (i = 0; i < 4; i++)
+   {
+      switch (i)
+      {
+	 case 0:
+	    if (BreakReserved[i])
+	    {
+	       CurrentDR7 &= 0xFFF0FFFF;
+	       CurrentDR7 |= G0_BIT;
+	       CurrentDR7 |= ((BreakType[i] << ((i * 4) + 16)) |
+			      (BreakLength[i] << ((i * 4) + 18)));
+	    }
+	    else
+	    {
+	       CurrentDR7 &= 0xFFF0FFFF;
+	       CurrentDR7 &= ~G0_BIT;
+	       CurrentDR7 &= ~L0_BIT;
+	    }
+	    WriteDR0(BreakPoints[i]);
+	    break;
+
+	 case 1:
+	    if (BreakReserved[i])
+	    {
+	       CurrentDR7 &= 0xFF0FFFFF;
+	       CurrentDR7 |= G1_BIT;
+	       CurrentDR7 |= ((BreakType[i] << ((i * 4) + 16)) |
+			      (BreakLength[i] << ((i * 4) + 18)));
+	    }
+	    else
+	    {
+	       CurrentDR7 &= 0xFF0FFFFF;
+	       CurrentDR7 &= ~G1_BIT;
+	       CurrentDR7 &= ~L1_BIT;
+	    }
+	    WriteDR1(BreakPoints[i]);
+	    break;
+
+	 case 2:
+	    if (BreakReserved[i])
+	    {
+	       CurrentDR7 &= 0xF0FFFFFF;
+	       CurrentDR7 |= G2_BIT;
+	       CurrentDR7 |= ((BreakType[i] << ((i * 4) + 16)) |
+			      (BreakLength[i] << ((i * 4) + 18)));
+	    }
+	    else
+	    {
+	       CurrentDR7 &= 0xF0FFFFFF;
+	       CurrentDR7 &= ~G2_BIT;
+	       CurrentDR7 &= ~L2_BIT;
+	    }
+	    WriteDR2(BreakPoints[i]);
+	    break;
+
+	 case 3:
+	    if (BreakReserved[i])
+	    {
+	       CurrentDR7 &= 0x0FFFFFFF;
+	       CurrentDR7 |= G3_BIT;
+	       CurrentDR7 |= ((BreakType[i] << ((i * 4) + 16)) |
+			      (BreakLength[i] << ((i * 4) + 18)));
+	    }
+	    else
+	    {
+	       CurrentDR7 &= 0x0FFFFFFF;
+	       CurrentDR7 &= ~G3_BIT;
+	       CurrentDR7 &= ~L3_BIT;
+	    }
+	    WriteDR3(BreakPoints[i]);
+	    break;
+
+      }
+   }
+   return;
+
+}
+
+void LoadDebugRegisters(void)
+{
+
+   register int i;
+
+   WriteDR6(0);  /* clear last exception status */
+   for (i = 0; i < 4; i++)
+   {
+      switch (i)
+      {
+	 case 0:
+	    if (BreakReserved[i])
+	       WriteDR0(BreakPoints[i]);
+	    break;
+
+	 case 1:
+	    if (BreakReserved[i])
+	       WriteDR1(BreakPoints[i]);
+	    break;
+
+	 case 2:
+	    if (BreakReserved[i])
+	       WriteDR2(BreakPoints[i]);
+	    break;
+
+	 case 3:
+	    if (BreakReserved[i])
+	       WriteDR3(BreakPoints[i]);
+	    break;
+      }
+   }
+   WriteDR7(CurrentDR7);  /* set breakpoint enable/disable state */
+
+}
+
+/*
+ *   processor synchronization
+ *
+ *   We have to handle multiple cpus with active breakpoints
+ *   attempting to access the debugger.  We also have to handle
+ *   double faulted situations.
+ *
+ */
+
+unsigned long debug_lock(rlock_t *rlock, unsigned long p)
+{
+#if defined(CONFIG_SMP)
+    if (!spin_trylock_irqsave((spinlock_t *)&rlock->lock, rlock->flags[p]))
+    {
+       if (rlock->processor == p)
+       {
+          rlock->count++;
+#if MDB_DEBUG_DEBUGGER
+          DBGPrint("%i: debug lock(++) count (%lu) state:%s\n",
+                   rlock->count, (int)p, procState[ProcessorState[p] & 0xF]);
+#endif
+       }
+       else
+       {
+#if MDB_DEBUG_DEBUGGER
+          DBGPrint("%i: debug trylock FAILED state:%s\n",
+                   (int)p, procState[ProcessorState[p] & 0xF]);
+#endif
+          while (1)
+          {
+             mdelay(1);
+             ProcessorState[p] = PROCESSOR_HOLD;
+             while (atomic_read(&focusActive) &&
+                   !atomic_read(&traceProcessors[p]))
+             {
+                cpu_relax();
+             }
+
+             if (spin_trylock_irqsave((spinlock_t *)&rlock->lock,
+                                      rlock->flags[p]))
+                break;
+          }
+          ProcessorState[p] = PROCESSOR_DEBUG;
+          rlock->processor = p;
+
+#if MDB_DEBUG_DEBUGGER
+          DBGPrint("%i: debug spinlock SUCCESS state:%s\n",
+                   (int)p, procState[ProcessorState[p] & 0xF]);
+#endif
+       }
+    }
+    else
+       rlock->processor = p;
+
+#if MDB_DEBUG_DEBUGGER
+    DBGPrint("%i: debug lock SUCCESS state:%s\n",
+             (int)p, procState[ProcessorState[p] & 0xF]);
+#endif
+#endif /* CONFIG_SMP */
+    return 1;
+}
+
+void debug_unlock(rlock_t *rlock, unsigned long p)
+{
+#if defined(CONFIG_SMP)
+    if (rlock->processor != p)
+    {
+#if MDB_DEBUG_DEBUGGER
+       DBGPrint("%i: debug unlock FAILED state:%s (%lu/%lu)\n",
+                (int)p, procState[ProcessorState[p] & 0xF],
+                 rlock->processor, p);
+#endif
+    }
+
+    if (rlock->count)
+    {
+       rlock->count--;
+#if MDB_DEBUG_DEBUGGER
+       DBGPrint("%i: debug unlock(--) count (%lu) state:%s\n",
+                (int)p, rlock->count, procState[ProcessorState[p] & 0xF]);
+#endif
+    }
+    else
+    {
+       rlock->processor = -1;
+       spin_unlock_irqrestore((spinlock_t *)&rlock->lock, rlock->flags[p]);
+    }
+#if MDB_DEBUG_DEBUGGER
+    DBGPrint("%i: debug unlock count (%lu) state:%s\n",
+             (int)p, rlock->count, procState[ProcessorState[p] & 0xF]);
+#endif
+#endif /* CONFIG_SMP */
+    return;
+}
+
+unsigned long StopProcessorsExclSelf(unsigned long self)
+{
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+   register unsigned long failed;
+   register int i;
+
+#if MDB_DEBUG_DEBUGGER
+   if (atomic_read(&debuggerActive) > 1)
+   {
+      DBGPrint("%i: stop processors IPI waiters:%i state:%s\n",
+               (int)self, (int)atomic_read(&debuggerActive),
+               procState[ProcessorState[self] & 0xF]);
+   }
+   DBGPrint("%i: stop processors ENTER state:%s\n",
+             (int)self, procState[ProcessorState[self] & 0xF]);
+#endif
+
+   /*
+      You need to delay before issuing NMI and allow any previously
+      released processors to exit and issue their IRETD before
+      triggering another NMI event or exception.
+
+      This fix seems to avoid lockup during APIC ICR write on some SMT
+      capable and dual core laptop computers (Acer 9410). if an ICR xcall
+      is issued before a target processor has exited an active
+      exception or if a processor inside an active INT1 exception
+      receives a directed NMI from the local APIC, it can result in
+      a hard hang.   The reason for this behavior has not been fully
+      investigated.
+
+      This lockup occurs if more than one processor is currently handling
+      an INT1 debugger exception and one of the processors gets an NMI
+      while still inside the INT1 exception (nested exceptions).  It
+      does not happen all the time and appears timing dependent.
+
+      The symptom is a hard bus hang while attempting to write an ICR
+      command to the local APIC ICR register.  The check for a busy bit
+      in the ICR register succeeds and allows the ICR write to occur
+      prior to the lockup.
+   */
+   mdelay(1);
+
+   for (i = 0; i < MAX_PROCESSORS; i++)
+   {
+      if (cpu_online(i))
+      {
+         if (i != self)
+         {
+            /* do not NMI a procesor already spinning inside the
+               debugger.  It may result in a system lockup. */
+            if (!atomic_read(&debuggerProcessors[i]))
+            {
+	       ProcessorHold[i] = 1;
+               barrier();
+#if MDB_DEBUG_DEBUGGER
+               DBGPrint("%i:send_IPI_mask ENTER cpu:%lu state:%s\n",
+                        (int)self, i, procState[ProcessorState[i] & 0xF]);
+#endif
+               send_IPI_mask(cpumask_of_cpu(i), APIC_DM_NMI);
+#if MDB_DEBUG_DEBUGGER
+               DBGPrint("%i:send_IPI_mask EXIT cpu:%lu state:%s\n",
+                        (int)self, i, procState[ProcessorState[i] & 0xF]);
+#endif
+            }
+         }
+      }
+   }
+
+#if 0
+   /* This code can result in hard system lockup on certain laptop models
+    * during NMI of the other processors. The cause has not been
+    * determined. */
+   DBGPrint("%i: Send_IPI_allbutself ...", (int)self);
+   send_IPI_allbutself(APIC_DM_NMI);
+   DBGPrint(" completed\n");
+#endif
+
+   for (i = 0, failed=0; i < MAX_PROCESSORS; i++)
+   {
+      if (cpu_online(i))
+      {
+         if (i != self)
+         {
+	    register unsigned long msecs = 1000;
+
+	    while (!atomic_read(&debuggerProcessors[i]) && msecs)
+	    {
+	       mdelay(1);
+	       msecs--;
+	    }
+
+	    if (!msecs)
+	    {
+	       failed++;
+	       DBGPrint("Processor %i could not be halted state:%s\n",
+                        (int)i, procState[ProcessorState[i] & 0xF]);
+	    }
+         }
+      }
+   }
+#if MDB_DEBUG_DEBUGGER
+   DBGPrint("%i: stop processors EXITED state:%s\n",
+             (int)self, procState[ProcessorState[self] & 0xF]);
+#endif
+
+   return (unsigned long) failed;
+#else
+   return 0;
+#endif
+}
+
+unsigned long FreeProcessorsExclSelf(unsigned long self)
+{
+#if defined(CONFIG_SMP) && !defined(CONFIG_X86_ELAN)
+   register int i;
+
+#if MDB_DEBUG_DEBUGGER
+   DBGPrint("%i: release processors ENTER state:%s\n",
+             (int)self, procState[ProcessorState[self] & 0xF]);
+#endif
+
+   for (i = 0; i < MAX_PROCESSORS; i++)
+   {
+      if (ProcessorState[i] != PROCESSOR_HOLD)
+      {
+         ProcessorState[i] = PROCESSOR_RESUME;
+         barrier();
+      }
+   }
+
+#if MDB_DEBUG_DEBUGGER
+   DBGPrint("%i: release processors EXITED state:%s\n",
+             (int)self, procState[ProcessorState[self] & 0xF]);
+#endif
+
+   return i;
+#else
+   return MAX_PROCESSORS;
+#endif
+
+}
+
+unsigned long WaitRestartExclSelf(unsigned long self)
+{
+#if defined(CONFIG_SMP)
+   register unsigned long failed;
+   register int i;
+
+#if MDB_DEBUG_DEBUGGER
+   DBGPrint("%i: wait processors ENTERED state:%s\n",
+             (int)self, procState[ProcessorState[self] & 0xF]);
+#endif
+
+   for (i = 0, failed=0; i < MAX_PROCESSORS; i++)
+   {
+      if (cpu_online(i))
+      {
+         if (i != self)
+         {
+	    register unsigned long msecs = 1000;
+
+	    while (atomic_read(&nmiProcessors[i]) && msecs)
+	    {
+	       mdelay(1);
+	       msecs--;
+	    }
+
+	    if (!msecs)
+	    {
+	       failed++;
+	       DBGPrint("Processor %i did not restart state:%s\n",
+                        (int)i, procState[ProcessorState[i] & 0xF]);
+	    }
+         }
+      }
+   }
+
+#if MDB_DEBUG_DEBUGGER
+   DBGPrint("%i: wait processors EXITED state:%s\n",
+             (int)self, procState[ProcessorState[self] & 0xF]);
+#endif
+
+   return (unsigned long) failed;
+#else
+   return 0;
+#endif
+}
+
+unsigned long enter_debugger(unsigned long exception, StackFrame *stackFrame,
+                             unsigned long processor)
+{
+    register unsigned long retCode;
+
+    if (debug_lock(&debug_mutex, processor))
+    {
+       /*  if the processors were already held in the debugger due to a
+        *  trace, ssb, or proceed session on a focus processor, do not
+        *  nest an xcall NMI or signal (not if you can help it). */
+       if (!atomic_read(&traceProcessors[processor]))
+          StopProcessorsExclSelf(processor);
+
+       retCode = debugger_command_entry(processor, exception, stackFrame);
+
+       /*  do not release the processors for active trace, ssb, or proceed
+        *  sessions on a focus processor. */
+       if (!atomic_read(&traceProcessors[processor]))
+       {
+          FreeProcessorsExclSelf(processor);
+          WaitRestartExclSelf(processor);
+       }
+       debug_unlock(&debug_mutex, processor);
+       clocksource_touch_watchdog();
+       return retCode;
+    }
+    clocksource_touch_watchdog();
+    return 0;
+}
+
+
+unsigned long debugger_entry(unsigned long Exception, StackFrame *stackFrame,
+                     unsigned long processor)
+{
+    register unsigned long retCode = 1;
+    unsigned char *cmd;
+    unsigned long valid;
+
+    atomic_inc(&debuggerActive);
+    atomic_inc(&debuggerProcessors[processor]);
+
+    ProcessorState[processor] = PROCESSOR_DEBUG;
+    CurrentFrame[processor] = stackFrame;
+
+    WriteDR7(0);  /* disable breakpoints while debugger is running */
+    CurrentDR6[processor] = ReadDR6();
+
+    if (fpu_present())
+       save_npx(&npx[processor]);
+
+MDBLoop:;
+    switch (Exception)
+    {
+          case 1:/* int 1 debug exception */
+	    if (BreakMask[processor])
+	    {
+	       stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	       stackFrame->tSystemFlags |= RESUME;
+	       break;
+	    }
+	    else
+	    if ((CurrentDR6[processor] & B0_BIT) &&
+                (CurrentDR7 & G0_BIT) &&
+                (ConditionalBreakpoint[0]))
+	    {
+	       cmd = (unsigned char *)&BreakCondition[0][0];
+	       if (!EvaluateExpression(stackFrame, &cmd, &valid))
+	       {
+		  stackFrame->tSystemFlags &= ~SINGLE_STEP;
+		  stackFrame->tSystemFlags |= RESUME;
+		  break;
+	       }
+	    }
+	    else
+	    if ((CurrentDR6[processor] & B1_BIT) &&
+                (CurrentDR7 & G1_BIT) &&
+                (ConditionalBreakpoint[1]))
+	    {
+	       cmd = (unsigned char *)&BreakCondition[1][0];
+	       if (!EvaluateExpression(stackFrame, &cmd, &valid))
+	       {
+		  stackFrame->tSystemFlags &= ~SINGLE_STEP;
+		  stackFrame->tSystemFlags |= RESUME;
+		  break;
+	       }
+	    }
+	    else
+	    if ((CurrentDR6[processor] & B2_BIT) &&
+                (CurrentDR7 & G2_BIT) &&
+                (ConditionalBreakpoint[2]))
+	    {
+	       cmd = (unsigned char *)&BreakCondition[2][0];
+	       if (!EvaluateExpression(stackFrame, &cmd, &valid))
+	       {
+		  stackFrame->tSystemFlags &= ~SINGLE_STEP;
+		  stackFrame->tSystemFlags |= RESUME;
+		  break;
+	       }
+	    }
+	    else
+	    if ((CurrentDR6[processor] & B3_BIT) &&
+                (CurrentDR7 & G3_BIT) &&
+                (ConditionalBreakpoint[3]))
+	    {
+	       cmd = (unsigned char *)&BreakCondition[3][0];
+	       if (!EvaluateExpression(stackFrame, &cmd, &valid))
+	       {
+		  stackFrame->tSystemFlags &= ~SINGLE_STEP;
+		  stackFrame->tSystemFlags |= RESUME;
+		  break;
+	       }
+	    }
+	    enter_debugger(Exception, stackFrame, processor);
+	    break;
+
+
+	 case 3:/* int 3 breakpoint */
+	    if (BreakMask[processor])
+	    {
+	       stackFrame->tSystemFlags &= ~SINGLE_STEP;
+	       stackFrame->tSystemFlags |= RESUME;
+	       break;
+	    }
+	    enter_debugger(Exception, stackFrame, processor);
+	    break;
+
+         case 2: /* nmi */
+            barrier();
+            if (ProcessorHold[processor])  /* hold processor */
+            {
+               ProcessorHold[processor] = 0;
+	       ProcessorState[processor] = PROCESSOR_SUSPEND;
+
+               /* processor suspend loop */
+               atomic_inc(&nmiProcessors[processor]);
+	       while ((ProcessorState[processor] != PROCESSOR_RESUME) &&
+	              (ProcessorState[processor] != PROCESSOR_SWITCH))
+               {
+                  barrier();
+	          if ((ProcessorState[processor] == PROCESSOR_RESUME) ||
+	              (ProcessorState[processor] == PROCESSOR_SWITCH))
+                     break;
+
+                  touch_nmi_watchdog();
+                  cpu_relax();
+               }
+               atomic_dec(&nmiProcessors[processor]);
+
+               if (ProcessorState[processor] == PROCESSOR_SWITCH)
+	          enter_debugger(21, stackFrame, processor);
+               break;
+            }
+            else   /* all other nmi exceptions fall through to here */
+	       enter_debugger(Exception, stackFrame, processor);
+            break;
+
+	 default:
+	    enter_debugger(Exception, stackFrame, processor);
+	    break;
+    }
+
+    if (ProcessorHold[processor])
+    {
+       Exception = 2;
+       goto MDBLoop;
+    }
+
+    LoadDebugRegisters();
+
+    if (fpu_present())
+       load_npx(&npx[processor]);
+
+    CurrentFrame[processor] = 0;
+    ProcessorState[processor] = PROCESSOR_ACTIVE;
+
+    atomic_dec(&debuggerProcessors[processor]);
+    atomic_dec(&debuggerActive);
+    return retCode;
+
+}
+
+void InitializeDebuggerRegisters(void)
+{
+   CurrentDR7 = (DR7DEF | GEXACT | LEXACT); /* set mode to GLOBAL EXACT */
+   WriteDR0(0);                      /* clear out DR0-DR6 */
+   WriteDR1(0);
+   WriteDR2(0);
+   WriteDR3(0);
+   WriteDR6(0);
+   WriteDR7(CurrentDR7);            /* set DR7 register */
+}
+
+void ClearDebuggerRegisters(void)
+{
+   WriteDR0(0);   /* clear out all breakpoints and breakpoint */
+   WriteDR1(0);   /* registers DR0-DR7 */
+   WriteDR2(0);
+   WriteDR3(0);
+   WriteDR6(0);
+   WriteDR7(0);
+}
diff -Naur linux-2.6.27/debug/mdb/mdb-ia32.h linux-2.6.27-mdb/debug/mdb/mdb-ia32.h
--- linux-2.6.27/debug/mdb/mdb-ia32.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-ia32.h	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,172 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#ifndef _MDB_IA32_H
+#define _MDB_IA32_H
+
+typedef struct _StackFrame {
+   unsigned long tReserved[7];
+   unsigned long *tCR3;
+   unsigned long tEIP;
+   unsigned long tSystemFlags;
+   unsigned long tEAX;
+   unsigned long tECX;
+   unsigned long tEDX;
+   unsigned long tEBX;
+   unsigned long tESP;
+   unsigned long tEBP;
+   unsigned long tESI;
+   unsigned long tEDI;
+   unsigned short tES;
+   unsigned short Res1;
+   unsigned short tCS;
+   unsigned short Res2;
+   unsigned short tSS;
+   unsigned short Res3;
+   unsigned short tDS;
+   unsigned short Res4;
+   unsigned short tFS;
+   unsigned short Res5;
+   unsigned short tGS;
+   unsigned short Res6;
+   unsigned short tLDT;
+   unsigned short Res7;
+   unsigned long tIOMap;
+} StackFrame;
+
+/*  128 bytes total size numeric register context */
+
+typedef struct _NPXREG {
+  unsigned short sig0;        /*  10 bytes total size this structure */
+  unsigned short sig1;
+  unsigned short sig2;
+  unsigned short sig3;
+  unsigned short exponent:15;
+  unsigned short sign:1;
+} NUMERIC_REGISTER_CONTEXT;
+
+typedef struct _NPX {
+  unsigned long control;
+  unsigned long status;
+  unsigned long tag;
+  unsigned long eip;
+  unsigned long cs;
+  unsigned long dataptr;
+  unsigned long datasel;
+  NUMERIC_REGISTER_CONTEXT reg[8];    /* 80 bytes */
+  unsigned long pad[5];
+} NUMERIC_FRAME;
+
+/*  128 bytes total size register context */
+
+typedef struct _CONTEXT_FRAME {
+    unsigned short cBackLink;
+    unsigned short cTSSReserved;
+    unsigned long cESP0;
+    unsigned short cSS0;
+    unsigned short cSS0res;
+    unsigned long cESP1;
+    unsigned short cSS1;
+    unsigned short cSS1res;
+    unsigned long cESP2;
+    unsigned short cSS2;
+    unsigned short cSS2res;
+    unsigned long cCR3;
+    unsigned long cEIP;
+    unsigned long cSystemFlags;
+    unsigned long cEAX;
+    unsigned long cECX;
+    unsigned long cEDX;
+    unsigned long cEBX;
+    unsigned long cESP;
+    unsigned long cEBP;
+    unsigned long cESI;
+    unsigned long cEDI;
+    unsigned long cES;
+    unsigned long cCS;
+    unsigned long cSS;
+    unsigned long cDS;
+    unsigned long cFS;
+    unsigned long cGS;
+    unsigned long cLDT;
+    unsigned long cIOPermissMap;
+    unsigned long pad[6];
+} CONTEXT_FRAME;
+
+static inline void _cli(void)
+{
+	__asm__ __volatile__("cli" : : : "memory");
+}
+
+static inline void _sti(void)
+{
+	__asm__ __volatile__("sti" : : : "memory");
+}
+
+static inline unsigned long get_flags(void)
+{
+	unsigned long flags;
+
+	__asm__ __volatile__(
+		"pushfl ; popl %0"
+		: "=g" (flags)
+		: /* no input */
+	);
+	return flags;
+}
+
+static inline unsigned long save_flags(void)
+{
+	unsigned long flags;
+
+	__asm__ __volatile__(
+		"pushfl ; popl %0"
+		: "=g" (flags)
+		: /* no input */
+	);
+	__asm__ __volatile__("cli" : : : "memory");
+	return flags;
+}
+
+static inline void restore_flags(unsigned long flags)
+{
+	__asm__ __volatile__(
+		"pushl %0 ; popfl"
+		:
+		:"g" (flags)
+		:"memory", "cc"
+	);
+}
+
+#endif
diff -Naur linux-2.6.27/debug/mdb/mdb-ia32-proc.h linux-2.6.27-mdb/debug/mdb/mdb-ia32-proc.h
--- linux-2.6.27/debug/mdb/mdb-ia32-proc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-ia32-proc.h	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,530 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#ifndef _MDB_IA32_PROC_H
+#define _MDB_IA32_PROC_H
+
+#define EXT_NMI_PORT             0x0461
+#define NMI_IO_PORT              0x0462
+#define NMI_CONTROL_PORT         0x0C6E
+#define NMI_PORT                 0x61
+#define PIC1_DEBUG_MASK          0xFC
+#define PIC2_DEBUG_MASK          0xFF
+#define EXCEPTION_ENTRIES        19
+#define RESUME                   0x00010000
+#define NESTED_TASK              0x00004000
+#define SINGLE_STEP              0x00000100
+#define INVALID_EXPRESSION       0
+#define NUMERIC_EXPRESSION       1
+#define BOOLEAN_EXPRESSION       2
+
+/* DR7 Breakpoint Type and Length Fields */
+
+#define BREAK_EXECUTE    0
+#define BREAK_WRITE      1
+#define BREAK_IOPORT     2
+#define BREAK_READWRITE  3
+#define ONE_BYTE_FIELD   0
+#define TWO_BYTE_FIELD   1
+#define UNDEFINED_FIELD  2
+#define FOUR_BYTE_FIELD  3
+
+/* DR7 Register */
+
+#define L0_BIT   0x00000001
+#define G0_BIT   0x00000002
+#define L1_BIT   0x00000004
+#define G1_BIT   0x00000008
+#define L2_BIT   0x00000010
+#define G2_BIT   0x00000020
+#define L3_BIT   0x00000040
+#define G3_BIT   0x00000080
+#define LEXACT   0x00000100
+#define GEXACT   0x00000200
+#define GDETECT  0x00002000
+#define DR7DEF   0x00000400
+
+/* DR6 Register */
+
+#define B0_BIT   0x00000001
+#define B1_BIT   0x00000002
+#define B2_BIT   0x00000004
+#define B3_BIT   0x00000008
+
+#define BD_BIT   0x00002000
+#define BS_BIT   0x00004000
+#define BT_BIT   0x00008000
+
+/* Memory Type Range Registers (MTRR) */
+
+#define MTRR_PHYS_BASE_0    0x200
+#define MTRR_PHYS_MASK_0    0x201
+#define MTRR_PHYS_BASE_1    0x202
+#define MTRR_PHYS_MASK_1    0x203
+#define MTRR_PHYS_BASE_2    0x204
+#define MTRR_PHYS_MASK_2    0x205
+#define MTRR_PHYS_BASE_3    0x206
+#define MTRR_PHYS_MASK_3    0x207
+#define MTRR_PHYS_BASE_4    0x208
+#define MTRR_PHYS_MASK_4    0x209
+#define MTRR_PHYS_BASE_5    0x20A
+#define MTRR_PHYS_MASK_5    0x20B
+#define MTRR_PHYS_BASE_6    0x20C
+#define MTRR_PHYS_MASK_6    0x20D
+#define MTRR_PHYS_BASE_7    0x20E
+#define MTRR_PHYS_MASK_7    0x20F
+
+/* IA32 flags settings */
+
+#define   CF_FLAG      0x00000001
+#define   PF_FLAG      0x00000004
+#define   AF_FLAG      0x00000010
+#define   ZF_FLAG      0x00000040
+#define   SF_FLAG      0x00000080
+#define   TF_FLAG      0x00000100  /* ss flag */
+#define   IF_FLAG      0x00000200
+#define   DF_FLAG      0x00000400
+#define   OF_FLAG      0x00000800
+#define   NT_FLAG      0x00004000
+#define   RF_FLAG      0x00010000  /* resume flag */
+#define   VM_FLAG      0x00020000
+#define   AC_FLAG      0x00040000
+#define   VIF_FLAG     0x00080000
+#define   VIP_FLAG     0x00100000
+#define   ID_FLAGS     0x00200000
+
+typedef struct _GDT {
+    unsigned short Limit;    /*	0xFFFF */
+    unsigned short Base1;    /*  0 */
+    unsigned char Base2;     /*	0 */
+    unsigned char GDTType;   /*	10010010b */
+    unsigned char OtherType; /*	11001111b */
+    unsigned char Base3;     /*	0 */
+} GDT;
+
+typedef struct _IDT {
+    unsigned short IDTLow;     /*	0 */
+    unsigned short IDTSegment; /*	0x08 */
+    unsigned char IDTSkip;     /*	0 */
+    unsigned char IDTFlags;    /*	10001110b */
+    unsigned short IDTHigh;    /*	0 */
+} IDT;
+
+typedef struct _TSS {
+    unsigned short TSSLimit;	/* 0x0080 */
+    unsigned short TSSBase1;	/* 0 */
+    unsigned char TSSBase2;	/* 0 */
+    unsigned char TSSType;	/* 10001001b */
+    unsigned char TSSOtherType;	/* 00000000b */
+    unsigned char TSSBase3;	/* 0 */
+} TSS;
+
+typedef struct _TSS_GATE {
+    unsigned short TSSRes1;	/* 0 */
+    unsigned short TSSSelector;	/* 0 */
+    unsigned char TSSRes2;	/* 0 */
+    unsigned char TSSFlags;	/* 10000101b */
+    unsigned short TSSRes3;	/* 0 */
+} TSS_GATE;
+
+typedef struct _LDT {
+    unsigned short LDTLimit;	/* 0xFFFF */
+    unsigned short LDTBase1;	/* 0 */
+    unsigned char LDTBase2;	/* 0 */
+    unsigned char LDTGDTType;	/* 10000010b */
+    unsigned char LDTOtherType;	/* 10001111b */
+    unsigned char LDTBase3;	/* 0 */
+} LDT;
+
+extern unsigned long ReadDR0(void);
+extern unsigned long ReadDR1(void);
+extern unsigned long ReadDR2(void);
+extern unsigned long ReadDR3(void);
+extern unsigned long ReadDR6(void);
+extern unsigned long ReadDR7(void);
+extern void WriteDR0(unsigned long);
+extern void WriteDR1(unsigned long);
+extern void WriteDR2(unsigned long);
+extern void WriteDR3(unsigned long);
+extern void WriteDR6(unsigned long);
+extern void WriteDR7(unsigned long);
+extern unsigned long ReadCR0(void);
+extern unsigned long ReadCR2(void);
+extern unsigned long ReadCR3(void);
+extern unsigned long ReadCR4(void);
+extern void ReadGDTR(unsigned long *);
+extern void ReadIDTR(unsigned long *);
+extern unsigned long ReadLDTR(void);
+extern unsigned long ReadTR(void);
+
+extern void ReadMSR(unsigned long msr, unsigned long *val1, unsigned long *val2);
+extern void WriteMSR(unsigned long msr, unsigned long *val1, unsigned long *val2);
+extern void MTRROpen(void);
+extern void MTRRClose(void);
+extern void save_npx(NUMERIC_FRAME *npx);
+extern void load_npx(NUMERIC_FRAME *npx);
+
+extern unsigned long get_processor_id(void);
+extern unsigned long get_physical_processor(void);
+extern unsigned long fpu_present(void);
+
+extern void DisplayTSS(StackFrame *stackFrame);
+extern void DisplayGeneralRegisters(StackFrame *stackFrame);
+extern void DisplaySegmentRegisters(StackFrame *stackFrame);
+extern void DisplayControlRegisters(unsigned long processor, StackFrame *stackFrame);
+extern double ldexp(double v, int e);
+extern void DisplayNPXRegisters(unsigned long processor);
+
+extern unsigned long processProceedACC(unsigned long key, void *stackFrame,
+		  ACCELERATOR *accel);
+extern unsigned long processTraceACC(unsigned long key, void *stackFrame,
+		  ACCELERATOR *accel);
+extern unsigned long processTraceSSBACC(unsigned long key, void *stackFrame,
+		  ACCELERATOR *accel);
+extern unsigned long processGoACC(unsigned long key, void *stackFrame,
+		  ACCELERATOR *accel);
+
+extern unsigned long executeCommandHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long processProceed(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser);
+extern unsigned long processTrace(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+extern unsigned long processTraceSSB(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+extern unsigned long processGo(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+
+
+extern unsigned long processorCommandHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long breakProcessor(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser);
+extern unsigned long TSSDisplayHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long TSSDisplay(unsigned char *cmd,
+                    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser);
+
+extern unsigned long displayEAXHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeEAXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+extern unsigned long ChangeORIGEAXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayEBXHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeEBXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayECXHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeECXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayEDXHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeEDXRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayESIHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeESIRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayEDIHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeEDIRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayEBPHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeEBPRegister(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayESPHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeESPRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayEIPHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeEIPRegister(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayCSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeCSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern unsigned long displayDSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeDSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern unsigned long displayESHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeESRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern unsigned long displayFSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeFSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern unsigned long displayGSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeGSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern unsigned long displaySSHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeSSRegister(unsigned char *cmd,
+		      StackFrame *stackFrame, unsigned long Exception,
+		      DEBUGGER_PARSER *parser);
+
+extern unsigned long displayRFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeRFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayTFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeTFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayZFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeZFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displaySFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeSFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayPFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangePFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayCFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeCFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayOFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeOFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayIFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeIFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayIDHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeIDFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayDFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeDFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayNTHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeNTFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayVMHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeVMFlag(unsigned char *cmd,
+	       StackFrame *stackFrame, unsigned long Exception,
+	       DEBUGGER_PARSER *parser);
+
+extern unsigned long displayVIFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeVIFFlag(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern unsigned long displayVIPHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeVIPFlag(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern unsigned long displayAFHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeAFFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayACHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long ChangeACFlag(unsigned char *cmd,
+		  StackFrame *stackFrame, unsigned long Exception,
+		  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayMTRRHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long DisplayMTRRRegisters(unsigned char *cmd,
+			  StackFrame *stackFrame, unsigned long Exception,
+			  DEBUGGER_PARSER *parser);
+
+extern unsigned long displayGDTHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayGDT(unsigned char *cmd,
+		StackFrame *stackFrame, unsigned long Exception,
+		DEBUGGER_PARSER *parser);
+
+extern unsigned long displayIDTHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayIDT(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern unsigned long evaluateExpressionHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long evaluateExpression(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern unsigned long displayDOSTableHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long displayDOSTable(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+
+extern unsigned long portCommandHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long inputWordPort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long inputDoublePort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long inputBytePort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long inputPort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long outputWordPort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long outputDoublePort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long outputBytePort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long outputPort(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+
+
+extern unsigned long breakpointCommandHelp(unsigned char *commandLine, DEBUGGER_PARSER *parser);
+extern unsigned long breakpointClearAll(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser);
+extern unsigned long breakpointClear(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern unsigned long breakpointMask(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser);
+extern unsigned long breakpointWord1(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern unsigned long breakpointWord2(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern unsigned long breakpointWord4(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern unsigned long breakpointWord(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser);
+extern unsigned long breakpointRead1(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern unsigned long breakpointRead2(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern unsigned long breakpointRead4(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long breakpointRead(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long breakpointIO1(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long breakpointIO2(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long breakpointIO4(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long breakpointIO(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long breakpointExecute(unsigned char *cmd,
+		   StackFrame *stackFrame, unsigned long Exception,
+		   DEBUGGER_PARSER *parser);
+extern unsigned long breakpointShowTemp(unsigned char *cmd,
+			StackFrame *stackFrame, unsigned long Exception,
+			DEBUGGER_PARSER *parser);
+extern unsigned long dump_ef(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern unsigned long dump_uf(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern void mdb_breakpoint(void);
+
+#if defined(CONFIG_SMP)
+extern unsigned long displayAPICHelp(unsigned char *commandLine,
+                                     DEBUGGER_PARSER *parser);
+extern unsigned long displayAPICInfo(unsigned char *cmd,
+		     StackFrame *stackFrame, unsigned long Exception,
+		     DEBUGGER_PARSER *parser);
+extern unsigned long displayIOAPICHelp(unsigned char *commandLine,
+                     DEBUGGER_PARSER *parser);
+extern unsigned long displayIOAPICInfo(unsigned char *cmd,
+		       StackFrame *stackFrame, unsigned long Exception,
+		       DEBUGGER_PARSER *parser);
+extern unsigned long nmiProcessor(unsigned char *cmd,
+		    StackFrame *stackFrame, unsigned long Exception,
+		    DEBUGGER_PARSER *parser);
+extern unsigned long apic_directed_nmi(unsigned long cpu);
+extern unsigned long apic_xcall(unsigned long cpu, unsigned long command,
+                                unsigned long type);
+#endif
+#endif
diff -Naur linux-2.6.27/debug/mdb/mdb-ia32-support.c linux-2.6.27-mdb/debug/mdb/mdb-ia32-support.c
--- linux-2.6.27/debug/mdb/mdb-ia32-support.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-ia32-support.c	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,1935 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/uaccess.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <linux/io.h>
+
+#ifdef CONFIG_SMP
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb.h"
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+#define mod(a)  (((a) >> 6) & 7)
+#define reg(a)  (((a) >> 3) & 7)
+#define rm(a)   ((a) & 7)
+#define ss(a)   (((a) >> 6) & 7)
+#define indx(a) (((a) >> 3) & 7)
+#define base(a) ((a) & 7)
+
+#define   CF_FLAG   0x00000001
+#define   PF_FLAG   0x00000004
+#define   AF_FLAG   0x00000010
+#define   ZF_FLAG   0x00000040
+#define   SF_FLAG   0x00000080
+#define   TF_FLAG   0x00000100
+#define   IF_FLAG   0x00000200
+#define   DF_FLAG   0x00000400
+#define   OF_FLAG   0x00000800
+#define   NT_FLAG   0x00004000
+#define   RF_FLAG   0x00010000
+#define   VM_FLAG   0x00020000
+#define   AC_FLAG   0x00040000
+#define   VIF_FLAG  0x00080000
+#define   VIP_FLAG  0x00100000
+#define   ID_FLAG   0x00200000
+
+short SegmentSize = 32;
+unsigned char buf[20];
+unsigned char *VirtualAddress;
+short bufp, bufe;
+unsigned char ubuf[4000], *ubufp;
+short Columns;
+unsigned char NoNameBuffer[100];
+short DefaultPickSign;
+short Prefix;
+signed int modrmv;
+signed int sibv;
+short OperandSize;
+short AddressSize;
+unsigned long needs_proceed;
+unsigned long jmp_active;
+short MODRMExtend;
+long DeRefValue;
+long pSize;
+extern unsigned long full_deref_toggle;
+extern unsigned long debug_deref;
+
+void ProcessInstruction(StackFrame *stackFrame, unsigned char *s);
+
+/* Percent tokens in strings:
+   First char after '%':
+	A - direct address
+	C - reg of r/m picks control register
+	D - reg of r/m picks debug register
+        E - r/m picks operand
+        F - flags register
+	G - reg of r/m picks general register
+        I - immediate data (takes extended size, data size)
+        J - relative IP offset
+        M - r/m picks memory
+        O - no r/m, offset only
+	R - mod of r/m picks register only
+        S - reg of r/m picks segment register
+        T - reg of r/m picks test register
+        X - DS:ESI
+        Y - ES:EDI
+	2 - Prefix of two-byte opcode
+	e - put in 'e' if use32 (second char is part of reg name)
+	    put in 'w' for use16 or 'd' for use32 (second char is 'w')
+	f - floating point (second char is esc value)
+	g - do r/m group 'n'
+	p - Prefix
+	s - size override (second char is a,o)
+        + - make default signed
+   Second char after '%':
+        a - two words in memory (BOUND)
+	b - byte
+        c - byte or word
+        d - dword
+	p - 32 or 48 bit pointer
+        s - six byte pseudo-descriptor
+        v - word or dword
+	w - word
+        F - use floating regs in mod/rm
+        + - always sign
+        - - sign if negative
+	1-8 - group number, esc value, etc
+*/
+
+unsigned char *opmap1[] =
+{
+  /* 0 */
+  "ADD %Eb,%Gb",   "ADD %Ev,%Gv",    "ADD %Gb,%Eb",   "ADD %Gv,%Ev",
+  "ADD AL,%I-bb",  "ADD %eAX,%I-vv", "PUSH ES",       "POP ES",
+  "OR %Eb,%Gb",    "OR %Ev,%Gv",     "OR %Gb,%Eb",    "OR %Gv,%Ev",
+  "OR AL,%Ibb",    "OR %eAX,%Ivv",   "PUSH CS",       "%2 ",
+  /* 1 */
+  "ADC %Eb,%Gb",   "ADC %Ev,%Gv",    "ADC %Gb,%Eb",   "ADC %Gv,%Ev",
+  "ADC AL,%I-bb",  "ADC %eAX,%I-vv", "PUSH SS",       "POP SS",
+  "SBB %Eb,%Gb",   "SBB %Ev,%Gv",    "SBB %Gb,%Eb",   "SBB %Gv,%Ev",
+  "SBB AL,%I-bb",  "SBB %eAX,%I-vv", "PUSH DS",       "POP DS",
+  /* 2 */
+  "AND %Eb,%Gb",   "AND %Ev,%Gv",    "AND %Gb,%Eb",   "AND %Gv,%Ev",
+  "AND AL,%Ibb",   "AND %eAX,%Ivv",  "%pe",           "DAA",
+  "SUB %Eb,%Gb",   "SUB %Ev,%Gv",    "SUB %Gb,%Eb",   "SUB %Gv,%Ev",
+  "SUB AL,%I-bb",  "SUB %eAX,%I-vv", "%pc",           "DAS",
+  /* 3 */
+  "XOR %Eb,%Gb",   "XOR %Ev,%Gv",    "XOR %Gb,%Eb",   "XOR %Gv,%Ev",
+  "XOR AL,%Ibb",   "XOR %eAX,%Ivv",  "%ps",           "AAA",
+  "CMP %Eb,%Gb",   "CMP %Ev,%Gv",    "CMP %Gb,%Eb",   "CMP %Gv,%Ev",
+  "CMP AL,%I-bb",  "CMP %eAX,%I-vv", "%pd",           "AAS",
+  /* 4 */
+  "INC %eAX",      "INC %eCX",       "INC %eDX",      "INC %eBX",
+  "INC %eSP",      "INC %eBP",       "INC %eSI",      "INC %eDI",
+  "DEC %eAX",      "DEC %eCX",       "DEC %eDX",      "DEC %eBX",
+  "DEC %eSP",      "DEC %eBP",       "DEC %eSI",      "DEC %eDI",
+  /* 5 */
+  "PUSH %eAX",     "PUSH %eCX",      "PUSH %eDX",     "PUSH %eBX",
+  "PUSH %eSP",     "PUSH %eBP",      "PUSH %eSI",     "PUSH %eDI",
+  "POP %eAX",      "POP %eCX",       "POP %eDX",      "POP %eBX",
+  "POP %eSP",      "POP %eBP",       "POP %eSI",      "POP %eDI",
+  /* 6 */
+  "PUSHA",         "POPA",           "BOUND %Gv,%Ma", "ARPL %Ew,%Rw",
+  "%pf",           "%pg",            "%so",           "%sa",
+  "PUSH %I-vv",    "IMUL %Gv=%Ev*%I-vv", "PUSH %I-vb","IMUL %Gv=%Ev*%I-vb",
+  "INSB %Yb,DX",   "INS%ew %Yv,DX",  "OUTSB DX,%Xb",  "OUTS%ew DX,%Xv",
+  /* 7 */
+  "JO %Jb",        "JNO %Jb",        "JC %Jb",        "JNC %Jb",
+  "JZ %Jb",        "JNZ %Jb",        "JBE %Jb",       "JNBE %Jb",
+  "JS %Jb",        "JNS %Jb",        "JPE %Jb",       "JPO %Jb",
+  "JL %Jb",        "JGE %Jb",        "JLE %Jb",       "JG %Jb",
+  /* 8 */
+  "%g1 %Eb,%Ibb",  "%g1 %Ev,%Ivv",   0,               "%g1 %Ev,%Ivb",
+  "TEST %Eb,%Gb",  "TEST %Ev,%Gv",   "XCHG %Eb,%Gb",  "XCHG %Ev,%Gv",
+  "MOV %Eb,%Gb",   "MOV %Ev,%Gv",    "MOV %Gb,%Eb",   "MOV %Gv,%Ev",
+  "MOV %Ew,%Sw",   "LEA %Gv,%M ",    "MOV %Sw,%Ew",   "POP %Ev",
+  /* 9 */
+  "NOP",           "XCHG %eAX,%eCX", "XCHG %eAX,%eDX","XCHG %eAX,%eBX",
+  "XCHG %eAX,%eSP","XCHG %eAX,%eBP", "XCHG %eAX,%eSI","XCHG %eAX,%eDI",
+  "CBW",           "CWD",            "CALL %Ap",      "FWAIT",
+  "PUSH %eFLAGS",  "POP %eFLAGS",    "SAHF",          "LAHF",
+  /* a */
+  "MOV AL,%Ob",    "MOV %eAX,%Ov",   "MOV %Ob,AL",    "MOV %Ov,%eAX",
+  "MOVSB %Xb,%Yb", "MOVS%ew %Xv,%Yv","CMPSB %Xb,%Yb", "CMPS%ew %Xv,%Yv",
+  "TEST AL,%Ibb",  "TEST %eAX,%Ivv", "STOSB %Yb,AL",  "STOS%ew %Yv,%eAX",
+  "LODSB AL,%Xb",  "LODS%ew %eAX,%Xv","SCASB AL,%Xb", "SCAS%ew %eAX,%Xv",
+  /* b */
+  "MOV AL,%Ibb",   "MOV CL,%Ibb",    "MOV DL,%Ibb",   "MOV BL,%Ibb",
+  "MOV AH,%Ibb",   "MOV CH,%Ibb",    "MOV DH,%Ibb",   "MOV BH,%Ibb",
+  "MOV %eAX,%I-vv","MOV %eCX,%I-vv", "MOV %eDX,%I-vv","MOV %eBX,%I-vv",
+  "MOV %eSP,%Ivv", "MOV %eBP,%Ivv",  "MOV %eSI,%I-vv","MOV %eDI,%I-vv",
+  /* c */
+  "%g2 %Eb,%Ibb",  "%g2 %Ev,%Ibb",   "RET %Iw",       "RET",
+  "LES %Gv,%Mp",   "LDS %Gv,%Mp",    "MOV %Eb,%Ibb",  "MOV %Ev,%I-vv",
+  "ENTER %Iww,%Ibb","LEAVE",         "RETF %Iww",     "RETF",
+  "INT 3",         "INT %Ibb",       "INTO",          "IRET",
+  /* d */
+  "%g2 %Eb,1",     "%g2 %Ev,1",      "%g2 %Eb,CL",    "%g2 %Ev,CL",
+  "AAM %Ibb",      "AAD %Ibb",       0,               "XLAT",
+  "%f0",           "%f1",            "%f2",           "%f3",
+  "%f4",           "%f5",            "%f6",           "%f7",
+  /* e */
+  "LOOPNE %Jb",    "LOOPE %Jb",      "LOOP %Jb",      "JCXZ %Jb",
+  "IN AL,%Ibb",    "IN %eAX,%Ibb",   "OUT %Ibb,AL",   "OUT %Ibb,%eAX",
+  "CALL %Jv",      "JMP %Jv",        "JMP %Ap",       "JMP(S) %Jb",
+  "IN AL,DX",      "IN %eAX,DX",     "OUT DX,AL",     "OUT DX,%eAX",
+  /* f */
+  "LOCK %p ",      0,                "REPNE %p ",     "REP(E) %p ",
+  "HLT",           "CMC",            "%g3",           "%g0",
+  "CLC",           "STC",            "CLI",           "STI",
+  "CLD",           "STD",            "%g4",           "%g5"
+};
+
+unsigned char *second[] =
+{
+  /* 0 */
+  "%g6",           "%g7",            "LAR %Gv,%Ew",   "LSL %Gv,%Ew",
+  0,               0,                "CLTS",          0,
+  "INVD",          "WBINV",          0,               "UD2A",
+  0,               "%y0",            "FEMMS",         0,
+  /* 1 */
+  "%z8",	   "%z9",	     "MOVLPS",	      "MOVLPS",
+  "UNPCKLPS",	   "UNPCKHPS",	     "MOVHPS",	      "MOVHPS",
+  "%g14",	   0,		     0,		      0,
+  0,		   0,		     0,		      0,
+  /* 2 */
+  "MOV %Rd,%Cd",   "MOV %Rd,%Dd",    "MOV %Cd,%Rd",   "MOV %Dd,%Rd",
+  "MOV %Rd,%Td",   0,                "MOV %Td,%Rd",   0,
+  "MOVAPS",	   "MOVAPS",	     "%z2",	      "MOVNTPS",
+  "%z4",	   "%z3",	     "UCOMISS",       "COMISS",
+  /* 3 */
+  "WRMSR MSR[ECX],EDX:EAX", "RDTSC", "RDMSR EDX:EAX,MSR[ECX]",  "RDPMC",
+  "SYSENTER",      "SYSEXIT",	     0,		      0,
+  0,		   0,		     0,		      0,
+  0,               0,                0,               0,
+  /* 4 */
+  "CMOVO %Gv,%Ev", "CMOVNO %Gv,%Ev", "CMOVB %Gv,%Ev",  "CMOVAE %Gv,%Ev",
+  "CMOVE %Gv,%Ev", "CMOVNE %Gv,%Ev", "CMOVBE %Gv,%Ev", "CMOVA %Gv,%Ev",
+  "CMOVS %Gv,%Ev", "CMOVNS %Gv,%Ev", "CMOVP %Gv,%Ev",  "CMOVNP %Gv,%Ev",
+  "CMOVL %Gv,%Ev", "CMOVGE %Gv,%Ev", "CMOVLE %Gv,%Ev", "CMOVG %Gv,%Ev",
+  /* 5 */
+  "MOVMSKPS",	   "%z13",           "%z12",          "%z11",
+  "ANDPS",         "ANDNPS",         "ORPS",          "XORPS",
+  "%z0",	   "%z10",           0,               0,
+  "%z14",          "%z7",            "%z5",           "%z6",
+  /* 6 */
+  0,               0,                0,               0,
+  0,               0,                0,               0,
+  0,               0,                0,               0,
+  0,               0,               "MOVD %Pd,%Ed",  "MOVQ %Pq,%Qq",
+  /* 7 */
+  0,		   0,                0,               0,
+  0,               0,                0,               0,
+  0,		   0,                0,               0,
+  0,               0,               "MOVD %Ed,%Pd",  "MOVQ %Qq,%Pq",
+  /* 8 */
+  "JO %Jv",        "JNO %Jv",        "JC %Jv",        "JNC %Jv",
+  "JZ %Jv",        "JNZ %Jv",        "JBE %Jv",       "JNBE %Jv",
+  "JS %Jv",        "JNS %Jv",        "JPE %Jv",       "JPO %Jv",
+  "JL %Jv",        "JGE %Jv",        "JLE %Jv",       "JG %Jv",
+  /* 9 */
+  "SETO %Eb",      "SETNO %Eb",      "SETC %Eb",      "SETNC %Eb",
+  "SETZ %Eb",      "SETNZ %Eb",      "SETBE %Eb",     "SETNBE %Eb",
+  "SETS %Eb",      "SETNS %Eb",      "SETP %Eb",      "SETNP %Eb",
+  "SETL %Eb",      "SETGE %Eb",      "SETLE %Eb",     "SETG %Eb",
+  /* a */
+  "PUSH FS",       "POP FS",         "CPUID",         "BT %Ev,%Gv",
+  "SHLD %Ev,%Gv,%Ibb","SHLD %Ev,%Gv,CL", 0,           0,
+  "PUSH GS",       "POP GS",         "RSM",           "BTS %Ev,%Gv",
+  "SHRD %Ev,%Gv,%Ibb","SHRD %Ev,%Gv,CL", 0,           "IMUL %Gv,%Ev",
+
+  /* b */
+  "CMPXCHG %Eb,%Gb", "CMPXCHG %Ev,%Gv", "LSS %Mp",       "BTR %Ev,%Gv",
+  "LFS %Mp",         "LGS %Mp",         "MOVZX %Gv,%Eb", "MOVZX %Gv,%Ew",
+  0,                 "UD2B",            "%g8 %Ev,%Ibb",  "BTC %Ev,%Gv",
+  "BSF %Gv,%Ev",     "BSR %Gv,%Ev",     "MOVSX %Gv,%Eb", "MOVSX %Gv,%Ew",
+
+  /* c */
+  "XADD %Eb,%Gb",  "XADD %Ev,%Gv",   0,		      0,
+  0,		   0,                0,               "%g9",
+  "BSWAP %eAX",    "BSWAP %eCX",     "BSWAP %eDX",    "BSWAP %eBX",
+  "BSWAP %eSP",    "BSWAP %eBP",     "BSWAP %eSI",    "BSWAP %eDI",
+  /* d */
+  0,		   0,                0,               0,
+  0,		   0,		     0,		      0,
+  0,		   0,		     0,		      0,
+  0,		   0,		     0,		      0,
+  /* e */
+  0,		   0,		     0,		      0,
+  0,		   0,		     0,		      0,
+  0,		   0,		     0,		      0,
+  0,		   0,		     0,		      0,
+  /* f */
+  0,		   0,		     0,		      0,
+  0,		   0,		     0,		      0,
+  0,		   0,		     0,		      0,
+  0,		   0,		     0,		      0
+
+};
+
+unsigned char *groups[][10] = {     /* group 0 is group 3 for %Ev set */
+/* g0 */
+{ "TEST %Ev,%Ivv", "TEST %Ev,%Ivv,", "NOT %Ev",       "NEG %Ev",
+  "MUL %eAX,%Ev",  "IMUL %eAX,%Ev",  "DIV %eAX,%Ev",  "IDIV %eAX,%Ev" },
+
+/* g1 */
+{ "ADD%+-",        "OR",             "ADC%+-",        "SBB%+-",
+  "AND",           "SUB%+-",         "XOR",           "CMP%+-" },
+
+/* g2  */
+{ "ROL",           "ROR",            "RCL",           "RCR",
+  "SHL",           "SHR",            "SHL",           "SAR" },
+
+/* g3 */
+{ "TEST %Eb,%Ibb", "TEST %Eb,%Ibb,", "NOT %Eb",       "NEG %Eb",
+  "MUL AL,%Eb",    "IMUL AL,%Eb",    "DIV AL,%Eb",    "IDIV AL,%Eb" },
+
+/* g4 */
+{ "INC %Eb",       "DEC %Eb",        0,               0,
+  0,               0,                0,               0 },
+
+/* g5 */
+{ "INC %Ev",       "DEC %Ev",        "CALL %Ev",      "CALL %Ep",
+  "JMP %Ev",       "JMP %Ep",        "PUSH %Ev",      0 },
+
+/* g6 */
+{ "SLDT %Ew",      "STR %Ew",        "LLDT %Ew",      "LTR %Ew",
+  "VERR %Ew",      "VERW %Ew",       0, 0 },
+
+/* g7 */
+{ "SGDT %Ms",      "SIDT %Ms",       "LGDT %Ms",      "LIDT %Ms",
+  "SMSW %Ew",      0,                "LMSW %Ew",      "INVLPG" },
+
+/* g8 */
+{ 0,               0,                0, 0,
+  "BT",            "BTS",            "BTR",           "BTC" },
+
+/* g9 */
+{ 0,               "CMPXCH8B %Mq",   0,               0,
+  0,               0,                0,               0 },
+
+/* g10 */
+{ 0,               0,                0,               0,
+  0,               0,                0,               0 },
+
+};
+
+/* zero here means invalid.  If first entry starts with '*', use st(i) */
+/* no assumed %EFs here.  Indexed by rm(modrm()) */
+
+unsigned char *f0[] = {
+  0,               0,                0,               0,
+  0,		   0,		     0,	              0
+};
+
+unsigned char *fop_9[]  = {
+  "*FXCH ST,%GF" };
+
+unsigned char *fop_10[] = {
+  "FNOP",	   0,		      0,	      0,
+  0,		   0,		      0,	      0 };
+
+unsigned char *fop_12[] = {
+  "FCHS",          "FABS",            0,              0,
+  "FTST",          "FXAM",	      0,	      0 };
+
+unsigned char *fop_13[] = {
+  "FLD1",	   "FLDL2T",	      "FLDL2E",       "FLDPL",
+  "FLDLG2",	   "FLDLN2",	      "FLDZ",	      0 };
+
+unsigned char *fop_14[] = {
+  "F2XM1",	   "FYL2X",	      "FPTAN",	      "FPATAN",
+  "FXTRACT",	   "FPREM1",	      "FDECSTP",      "FINCSTP" };
+
+unsigned char *fop_15[] = {
+  "FPREM",	   "FYL2XP1",	      "FSQRT",	      "FSINCOS",
+  "FRNDINT",	   "FSCALE",	      "FSIN",	      "FCOS" };
+
+unsigned char *fop_21[] = {
+   0, "FUCOMPP", 0, 0,
+   0, 0, 0, 0 };
+
+unsigned char *fop_28[] = {
+   0, 0, "FCLEX", "FINIT",
+   0, 0, 0, 0 };
+
+unsigned char *fop_32[] = {
+   "*FADD %GF,ST" };
+
+unsigned char *fop_33[] = {
+   "*FMUL %GF,ST" };
+
+unsigned char *fop_36[] = {
+   "*FSUBR %GF,ST" };
+
+unsigned char *fop_37[] = {
+   "*FSUB %GF,ST" };
+
+unsigned char *fop_38[] = {
+   "*FDIVR %GF,ST" };
+
+unsigned char *fop_39[] = {
+   "*FDIV %GF,ST" };
+
+unsigned char *fop_40[] = {
+   "*FFREE %GF" };
+
+unsigned char *fop_42[] = { "*FST %GF" };
+
+unsigned char *fop_43[] = { "*FSTP %GF" };
+
+unsigned char *fop_44[] = { "*FUCOM %GF" };
+
+unsigned char *fop_45[] = { "*FUCOMP %GF" };
+
+unsigned char *fop_48[] = { "*FADDP %GF,ST" };
+
+unsigned char *fop_49[] = { "*FMULP %GF,ST" };
+
+unsigned char *fop_51[] = { 0, "FCOMPP", 0, 0, 0, 0, 0, 0 };
+
+unsigned char *fop_52[] = { "*FSUBRP %GF,ST" };
+
+unsigned char *fop_53[] = { "*FSUBP %GF,ST" };
+
+unsigned char *fop_54[] = { "*FDIVRP %GF,ST" };
+
+unsigned char *fop_55[] = { "*FDIVP %GF,ST" };
+
+unsigned char *fop_60[] = { "FSTSW AX", 0, 0, 0, 0, 0, 0, 0 };
+
+unsigned char **fspecial[] = { /* 0=use st(i), 1=undefined 0 in fop_* means undefined */
+  0, 0, 0, 0, 0, 0, 0, 0,
+  0, fop_9, fop_10, 0, fop_12, fop_13, fop_14, fop_15,
+  f0, f0, f0, f0, f0, fop_21, f0, f0,
+  f0, f0, f0, f0, fop_28, f0, f0, f0,
+  fop_32, fop_33, f0, f0, fop_36, fop_37, fop_38, fop_39,
+  fop_40, f0, fop_42, fop_43, fop_44, fop_45, f0, f0,
+  fop_48, fop_49, f0, fop_51, fop_52, fop_53, fop_54, fop_55,
+  f0, f0, f0, f0, fop_60, f0, f0, f0,
+  };
+
+unsigned char *floatops[] = { /* assumed " %EF" at end of each.  mod != 3 only */
+/*00*/ "FADD", "FMUL", "FCOM", "FCOMP",
+       "FSUB", "FSUBR", "FDIV", "FDIVR",
+/*08*/ "FLD", 0, "FST", "FSTP",
+       "FLDENV", "FLDCW", "FSTENV", "FSTCW",
+/*16*/ "FIADD", "FIMUL", "FICOMW", "FICOMPW",
+       "FISUB", "FISUBR", "FIDIV", "FIDIVR",
+/*24*/ "FILD", 0, "FIST", "FISTP",
+       "FRSTOR", "FLDT", 0, "FSTPT",
+/*32*/ "FADDQ", "FMULQ", "FCOMQ", "FCOMPQ",
+       "FSUBQ", "FSUBRQ", "FDIVQ", "FDIVRQ",
+/*40*/ "FLDQ", 0, "FSTQ", "FSTPQ",
+       "FRESTOR", 0, "FSAVE", "FSTSW",
+/*48*/ "FIADDW", "FIMULW", "FICOMW", "FICOMPW",
+       "FISUBW", "FISUBRW", "FIDIVW", "FIDIVR",
+/*56*/ "FILDW", 0, "FISTW", "FISTPW",
+       "FBLDT", "FILDQ", "FBSTPT", "FISTPQ"
+};
+
+
+unsigned char *reg_names[3][8]={
+  {"AL","CL","DL","BL","AH","CH","DH","BH"},
+  {"AX","CX","DX","BX","SP","BP","SI","DI"},
+  {"EAX", /* 0 */
+   "ECX", /* 1 */
+   "EDX", /* 2 */
+   "EBX", /* 3 */
+   "ESP", /* 4 */
+   "EBP", /* 5 */
+   "ESI", /* 6 */
+   "EDI"} /* 7 */
+   };
+
+unsigned char *r_str[] = {
+   "BX+SI",
+   "BX+DI",
+   "BP+SI",
+   "BP+DI",
+   "SI",
+   "DI",
+   "BP",
+   "BX"
+};
+
+unsigned char *formats[5][4] = {
+    {"%08X", "%08X", "%08z", "%08z" },
+    {"%02X", "%02X", "%02z", "%02z" },
+    {"%04X", "%04X", "%04z", "%04z" },
+    {"%08X", "%08X", "%08z", "%08z" },
+    {"%08X", "%08X", "%08z", "%08z" } };
+
+unsigned char *i_str[] = {
+   "+EAX", /* 0 */
+   "+ECX", /* 1 */
+   "+EDX", /* 2 */
+   "+EBX", /* 3 */
+   "",     /* 4 */
+   "+EBP", /* 5 */
+   "+ESI", /* 6 */
+   "+EDI"  /* 7 */
+};
+
+unsigned char *sib_str[] = {
+   "%p:[EAX", /* 0 */
+   "%p:[ECX", /* 1 */
+   "%p:[EDX", /* 2 */
+   "%p:[EBX", /* 3 */
+   "%p:[ESP", /* 4 */
+   0,         /* 5 */
+   "%p:[ESI", /* 6 */
+   "%p:[EDI"  /* 7 */
+};
+
+long reg_get_value(unsigned long index, StackFrame *stackFrame)
+{
+     if (!stackFrame)
+        return 0;
+
+     switch (index)
+     {
+	case 0:
+	   return stackFrame->tEAX;
+
+	case 1:
+	   return stackFrame->tECX;
+
+	case 2:
+	   return stackFrame->tEDX;
+
+	case 3:
+	   return stackFrame->tEBX;
+
+	case 4:
+	   return stackFrame->tESP;
+
+	case 5:
+	   return stackFrame->tEBP;
+
+	case 6:
+	   return stackFrame->tESI;
+
+	case 7:
+	   return stackFrame->tEDI;
+
+	default:
+	   return 0;
+     }
+}
+
+long sib_get_value(unsigned long index, StackFrame *stackFrame)
+{
+     if (!stackFrame)
+        return 0;
+
+     switch (index)
+     {
+	case 0:
+	   return stackFrame->tEAX;
+
+	case 1:
+	   return stackFrame->tECX;
+
+	case 2:
+	   return stackFrame->tEDX;
+
+	case 3:
+	   return stackFrame->tEBX;
+
+	case 4:
+	   return stackFrame->tESP;
+
+	case 6:
+	   return stackFrame->tESI;
+
+	case 7:
+	   return stackFrame->tEDI;
+
+	case 5:
+	default:
+	   return 0;
+     }
+}
+
+long istr_get_value(unsigned long index, StackFrame *stackFrame)
+{
+     if (!stackFrame)
+        return 0;
+
+     switch (index)
+     {
+	case 0:
+	   return stackFrame->tEAX;
+
+	case 1:
+	   return stackFrame->tECX;
+
+	case 2:
+	   return stackFrame->tEDX;
+
+	case 3:
+	   return stackFrame->tEBX;
+
+	case 5:
+	   return stackFrame->tEBP;
+
+	case 6:
+	   return stackFrame->tESI;
+
+	case 7:
+	   return stackFrame->tEDI;
+
+	case 4:
+	default:
+	   return 0;
+     }
+}
+
+
+unsigned char *output_address(void *val, unsigned long *delta)
+{
+    unsigned char *symbolName;
+    unsigned char *moduleName;
+    register int c = get_processor_id();
+
+    if (delta)
+      *delta = 0;
+
+    symbolName = GetSymbolFromValue((unsigned long) val, &symbuf[c][0],
+                                    MAX_SYMBOL_LEN);
+    if (symbolName)
+    {
+       moduleName = GetModuleInfoFromSymbolValue((unsigned long) val, &modbuf[c][0],
+                                                 MAX_SYMBOL_LEN);
+       if (moduleName)
+          sprintf(NoNameBuffer, "%s|%s=%08X", moduleName, symbolName,
+                 (unsigned)val);
+       else
+          sprintf(NoNameBuffer, "%s=%08X", symbolName, (unsigned)val);
+    }
+    else
+       sprintf(NoNameBuffer, "%08X", (unsigned)val);
+
+    return NoNameBuffer;
+
+}
+
+unsigned char *output_jmp_address(StackFrame *stackFrame, long val, long *delta)
+{
+
+    unsigned char *symbolName;
+    unsigned char *moduleName;
+    long va = (long) VirtualAddress;
+    long v;
+    long segment, offset, sym_offset = 0;
+    register int c = get_processor_id();
+
+    if (delta)
+      *delta = 0;
+
+    if (!stackFrame)
+       return NoNameBuffer;
+
+    if ((!strncmp(ubuf, "JBE", 3) &&
+           ((stackFrame->tSystemFlags & ZF_FLAG) ||
+            (stackFrame->tSystemFlags & CF_FLAG))) ||
+
+	(!strncmp(ubuf, "JCXZ", 4) &&
+           (!stackFrame->tECX)) ||
+
+	(!strncmp(ubuf, "JC", 2) &&
+           (stackFrame->tSystemFlags & CF_FLAG)) ||
+
+	(!strncmp(ubuf, "JLE", 3) &&
+           ((stackFrame->tSystemFlags & ZF_FLAG) ||
+           ((stackFrame->tSystemFlags & ~SF_FLAG) !=
+            (stackFrame->tSystemFlags & ~OF_FLAG)))) ||
+
+	(!strncmp(ubuf, "JL", 2) &&
+           ((stackFrame->tSystemFlags & ~SF_FLAG) !=
+            (stackFrame->tSystemFlags & ~OF_FLAG))) ||
+
+	(!strncmp(ubuf, "JMP", 3)) ||
+
+	(!strncmp(ubuf, "JGE", 3) &&
+           ((stackFrame->tSystemFlags & ~SF_FLAG) ==
+            (stackFrame->tSystemFlags & ~OF_FLAG))) ||
+
+	(!strncmp(ubuf, "JG", 2) &&
+           ((!(stackFrame->tSystemFlags & ZF_FLAG)) &&
+            ((stackFrame->tSystemFlags & ~SF_FLAG) ==
+            (stackFrame->tSystemFlags & ~OF_FLAG)))) ||
+
+	(!strncmp(ubuf, "JNBE", 4) &&
+            (!(stackFrame->tSystemFlags & CF_FLAG)) &&
+            (!(stackFrame->tSystemFlags & ZF_FLAG))) ||
+
+	(!strncmp(ubuf, "JNO", 3) &&
+           (!(stackFrame->tSystemFlags & OF_FLAG))) ||
+
+	(!strncmp(ubuf, "JNC", 3) &&
+           (!(stackFrame->tSystemFlags & CF_FLAG))) ||
+
+	(!strncmp(ubuf, "JNZ", 3) &&
+           (!(stackFrame->tSystemFlags & ZF_FLAG))) ||
+
+	(!strncmp(ubuf, "JNS", 3) &&
+           (!(stackFrame->tSystemFlags & SF_FLAG))) ||
+
+	(!strncmp(ubuf, "JO", 2) &&
+           (stackFrame->tSystemFlags & OF_FLAG)) ||
+
+	(!strncmp(ubuf, "JPE", 3) &&
+           (stackFrame->tSystemFlags & PF_FLAG)) ||
+
+	(!strncmp(ubuf, "JPO", 3) &&
+           (!(stackFrame->tSystemFlags & PF_FLAG))) ||
+
+	(!strncmp(ubuf, "JS", 2) &&
+           (stackFrame->tSystemFlags & SF_FLAG)) ||
+
+	(!strncmp(ubuf, "JZ", 2) &&
+           (stackFrame->tSystemFlags & ZF_FLAG)) ||
+
+	(!strncmp(ubuf, "LOOPNE", 6) &&
+           (stackFrame->tECX) &&
+           (!(stackFrame->tSystemFlags & ZF_FLAG))) ||
+
+	(!strncmp(ubuf, "LOOPE", 5) &&
+           (stackFrame->tECX) &&
+           (stackFrame->tSystemFlags & ZF_FLAG)) ||
+
+	(!strncmp(ubuf, "LOOP", 4)))
+    {
+       jmp_active = 1;
+       if (SegmentSize == 32)
+       {
+	  symbolName = GetSymbolFromValueWithOffset(val + va, &sym_offset,
+                                            &symbuf[c][0], MAX_SYMBOL_LEN);
+	  if (symbolName)
+          {
+	     moduleName = GetModuleInfoFromSymbolValue(val + va, &modbuf[c][0],
+                                                       MAX_SYMBOL_LEN);
+             if (moduleName)
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s|%s+0x%X=%08X %c",
+                     moduleName, symbolName,
+                     (unsigned)sym_offset, (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+                else
+	           sprintf(NoNameBuffer, "%s|%s=%08X %c",
+                     moduleName, symbolName,
+                     (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+             }
+             else
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s+0x%X=%08X %c", symbolName,
+                     (unsigned)sym_offset, (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+                else
+	           sprintf(NoNameBuffer, "%s=%08X %c", symbolName,
+                     (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+             }
+          }
+	  else
+	     sprintf(NoNameBuffer, "%08X %c",
+                    (unsigned)(val + va),
+		    ((val + va) < va) ? 0x18 : 0x19);
+       }
+       else
+       {
+	  symbolName = GetSymbolFromValueWithOffset(val + va, &sym_offset,
+                                           &symbuf[c][0], MAX_SYMBOL_LEN);
+	  if (symbolName)
+          {
+	     moduleName = GetModuleInfoFromSymbolValue(val + va, &modbuf[c][0],
+                                                       MAX_SYMBOL_LEN);
+             if (moduleName)
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s|%s+0x%X=%08X %c",
+                     moduleName, symbolName,
+                     (unsigned)sym_offset, (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+                else
+	           sprintf(NoNameBuffer, "%s|%s=%08X %c",
+                     moduleName, symbolName,
+                     (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+             }
+             else
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s+0x%X=%08X %c", symbolName,
+                     (unsigned)sym_offset, (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+                else
+	           sprintf(NoNameBuffer, "%s=%08X %c", symbolName,
+                     (unsigned)(val + va),
+		     ((val + va) < va) ? 0x18 : 0x19);
+             }
+          }
+	  else
+	  {
+	     v = val + va;
+	     segment = (((unsigned long)v >> 4) & 0x0000FFFF);
+	     offset = ((unsigned long)v & 0x0000000F);
+	     sprintf(NoNameBuffer, "%04X:%04X %c",
+                    (unsigned)segment, (unsigned)offset,
+		    ((val + va) < va) ? 0x18 : 0x19);
+	  }
+       }
+    }
+    else
+    {
+       if (SegmentSize == 32)
+       {
+	  symbolName = GetSymbolFromValueWithOffset(val + va, &sym_offset,
+                                           &symbuf[c][0], MAX_SYMBOL_LEN);
+	  if (symbolName)
+          {
+	     moduleName = GetModuleInfoFromSymbolValue(val + va, &modbuf[c][0],
+                                                       MAX_SYMBOL_LEN);
+             if (moduleName)
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s|%s+0x%X=%08X",
+                     moduleName, symbolName,
+                     (unsigned)sym_offset, (unsigned)(val + va));
+                else
+	           sprintf(NoNameBuffer, "%s|%s=%08X",
+                     moduleName, symbolName,
+                     (unsigned)(val + va));
+             }
+             else
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s+0x%X=%08X", symbolName,
+                     (unsigned)sym_offset, (unsigned)(val + va));
+                else
+	           sprintf(NoNameBuffer, "%s=%08X", symbolName,
+                      (unsigned)(val + va));
+             }
+          }
+	  else
+	     sprintf(NoNameBuffer, "%08X",
+                     (unsigned)(val + va));
+       }
+       else
+       {
+	  symbolName = GetSymbolFromValueWithOffset(val + va, &sym_offset,
+                                           &symbuf[c][0], MAX_SYMBOL_LEN);
+	  if (symbolName)
+          {
+	     moduleName = GetModuleInfoFromSymbolValue(val + va, &modbuf[c][0],
+                                                       MAX_SYMBOL_LEN);
+             if (moduleName)
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s|%s+0x%X=%08X",
+                     moduleName, symbolName,
+                     (unsigned)sym_offset, (unsigned)(val + va));
+                else
+	           sprintf(NoNameBuffer, "%s|%s=%08X",
+                     moduleName, symbolName,
+                     (unsigned)(val + va));
+             }
+             else
+             {
+                if (sym_offset)
+	           sprintf(NoNameBuffer, "%s+0x%X=%08X", symbolName,
+                     (unsigned)sym_offset, (unsigned)(val + va));
+                else
+	           sprintf(NoNameBuffer, "%s=%08X", symbolName,
+                     (unsigned)(val + va));
+             }
+          }
+	  else
+	  {
+	     v = val + va;
+	     segment = (((unsigned long)v >> 4) & 0x0000FFFF);
+	     offset = ((unsigned long)v & 0x0000000F);
+	     sprintf(NoNameBuffer, "%04X:%04X",
+                     (unsigned)segment, (unsigned)offset);
+	  }
+       }
+    }
+    return NoNameBuffer;
+
+}
+
+unsigned short read_memory(void *addr, void *buf, unsigned len)
+{
+    register unsigned long i;
+    register unsigned char *s = buf;
+
+    for (i = 0; i < len; i++)
+       if (s)
+          s[i] = (unsigned char)mdb_getword((unsigned long)((unsigned long)addr + i), 1);
+    return 0;
+}
+
+unsigned char getbyte(void)
+{
+    short s;
+
+    if (bufp >= bufe)
+    {
+       s = 4;  /* byte read window is 4 */
+       read_memory((void *)VirtualAddress, buf, s);
+       bufe = s;
+       bufp = 0;
+    }
+    VirtualAddress = (void *)((unsigned long) VirtualAddress + (unsigned long) 1);
+
+    DBGPrint("%02X", buf[bufp]);
+    Columns += 2;
+
+    return buf[bufp++];
+}
+
+unsigned short modrm(void)
+{
+    if (modrmv == -1)
+      modrmv = getbyte();
+
+    return modrmv;
+}
+
+unsigned short sib(void)
+{
+    if (sibv == -1)
+      sibv = getbyte();
+
+    return sibv;
+}
+
+void DebugPrint(char *s, ...)
+{
+    char **a = &s;
+
+    vsprintf(ubufp, s, (va_list)(a+1));
+
+    while (*ubufp) ubufp++;
+}
+
+void DebugPutChar(unsigned char c)
+{
+    if (c == '\t')
+    {
+      do {
+	*ubufp++ = ' ';
+      } while ((ubufp-ubuf) % 8);
+    }
+    else
+      *ubufp++ = c;
+    *ubufp = 0;
+}
+
+unsigned long dereference_address(unsigned long addr, unsigned long width)
+{
+    register unsigned long retCode;
+
+    retCode = mdb_verify_rw((void *)addr, width);
+    if (full_deref_toggle)
+    {
+       switch (retCode)
+       {
+	  case 0:
+	     if (width == 1)
+		DebugPrint("=(*%08X=%02X)", addr, (unsigned char)mdb_getword(addr, 1));
+	     else
+	     if (width == 2)
+		DebugPrint("=(*%08X=%04X)", addr, (unsigned short)mdb_getword(addr, 2));
+	     else
+	     if (width == 4)
+		DebugPrint("=(*%08X=%08X)", addr, (unsigned long)mdb_getword(addr, 4));
+	     else
+		DebugPrint("=(*%08X=?)", addr);
+	     return retCode;
+
+	  default:
+	     if (width == 1)
+		DebugPrint("=(*%08X=?)", addr);
+	     else
+	     if (width == 2)
+		DebugPrint("=(*%08X=?)", addr);
+	     else
+	     if (width == 4)
+		DebugPrint("=(*%08X=?)", addr);
+	     else
+		DebugPrint("=(*%08X=?)", addr);
+	     return retCode;
+       }
+    }
+    else
+    {
+       switch (retCode)
+       {
+	  case 0:
+	     if (width == 1)
+		DebugPrint("=%02X", (unsigned char)mdb_getword(addr, 1));
+	     else
+	     if (width == 2)
+		DebugPrint("=%04X", (unsigned short)mdb_getword(addr, 2));
+	     else
+	     if (width == 4)
+		DebugPrint("=%08X", (unsigned long)mdb_getword(addr, 4));
+	     else
+		DebugPrint("=?");
+	     return retCode;
+
+	  default:
+	     if (width == 1)
+		DebugPrint("=?");
+	     else
+	     if (width == 2)
+		DebugPrint("=?");
+	     else
+	     if (width == 4)
+		DebugPrint("=?");
+	     else
+		DebugPrint("=?");
+	     return retCode;
+       }
+    }
+
+}
+
+short bytes(char c)
+{
+    switch (c)
+    {
+      case 'b':
+	return 1;
+
+      case 'w':
+	return 2;
+
+      case 'd':
+	return 4;
+
+      case 'v':
+	if (OperandSize == 32)
+	  return 4;
+	else
+	  return 2;
+    }
+    return 0;
+
+}
+
+void OutputHex(char c, short extend, short optional, short defsize,
+	       short sign, long *deref)
+{
+
+    unsigned char *fmt, *p;
+    short n=0, s=0, i;
+    long delta;
+    unsigned char buf1[6];
+    unsigned char *name;
+    unsigned char fmt2[16];
+
+    fmt = formats[0][sign];
+
+    if (deref) {};
+
+    switch (c)
+    {
+      case 'a':
+	break;
+
+      case 'b':
+	n = 1;
+	break;
+
+      case 'w':
+	n = 2;
+	break;
+
+      case 'd':
+	n = 4;
+	break;
+
+      case 's':
+	n = 6;
+	break;
+
+      case 'c':
+      case 'v':
+	if (defsize == 32)
+	  n = 4;
+	else
+	  n = 2;
+	break;
+
+      case 'p':
+	if (defsize == 32)
+	  n = 6;
+	else
+	  n = 4;
+	s = 1;
+	break;
+
+      case 'x':
+	return;
+    }
+
+    for (i = 0; i < n; i++)
+       buf1[i] = getbyte();
+
+    for (; i < extend; i++)
+       buf1[i] = (buf[i-1] & 0x80) ? 0xff : 0;
+
+    if (s)
+    {
+       DebugPrint("%02X%02X:", buf1[n-1], buf1[n-2]);
+       n -= 2;
+    }
+    switch (n)
+    {
+       case 1:
+	  delta = *(char *)buf1;
+	  break;
+
+       case 2:
+	  delta = *(short *)buf1;
+	  break;
+
+       case 4:
+	  delta = *(long *)buf1;
+	  break;
+    }
+    if (extend > n)
+    {
+       if (delta || !optional)
+       {
+	  if (extend <= 4)
+	     fmt = formats[extend][sign];
+
+	  if (deref)
+	     *deref += delta;
+
+          p = strchr(fmt, 'z');
+          if (p)
+          {
+             strcpy(fmt2, fmt);
+             p = strchr(fmt2, 'z');
+             if (delta < 0)
+                DebugPrint("-", delta);
+             else
+                DebugPrint("+", delta);
+             *p = 'X';
+             DebugPrint(fmt2, delta);
+          }
+          else
+             DebugPrint(fmt, delta);
+       }
+       return;
+    }
+    if ((n == 4) && sign < 2)
+    {
+       if (deref)
+	  *deref += delta;
+
+       name = output_address((void  *)delta, (unsigned long *) &delta);
+       if (name)
+       {
+	  DebugPrint("%s", name);
+	  if (delta)
+	     DebugPrint("+%X", delta);
+	  return;
+       }
+    }
+    switch (n)
+    {
+
+       case 1:
+	  fmt = formats[n][sign];
+
+          p = strchr(fmt, 'z');
+          if (p)
+          {
+             strcpy(fmt2, fmt);
+             p = strchr(fmt2, 'z');
+             if (delta < 0)
+                DebugPrint("-", delta);
+             else
+                DebugPrint("+", delta);
+             *p = 'X';
+	     DebugPrint(fmt2, (char) delta);
+          }
+          else
+	     DebugPrint(fmt, (char) delta);
+
+	  if (deref)
+	     *deref += (delta & 0xFF);
+
+	  break;
+
+       case 2:
+	  fmt = formats[n][sign];
+
+          p = strchr(fmt, 'z');
+          if (p)
+          {
+             strcpy(fmt2, fmt);
+             p = strchr(fmt2, 'z');
+             if (delta < 0)
+                DebugPrint("-", delta);
+             else
+                DebugPrint("+", delta);
+             *p = 'X';
+	     DebugPrint(fmt2, (unsigned short) delta);
+          }
+          else
+	     DebugPrint(fmt, (unsigned short) delta);
+
+	  if (deref)
+	     *deref += (delta & 0xFFFF);
+
+	  break;
+
+       case 4:
+	  fmt = formats[n][sign];
+
+          p = strchr(fmt, 'z');
+          if (p)
+          {
+             strcpy(fmt2, fmt);
+             p = strchr(fmt2, 'z');
+             if (delta < 0)
+                DebugPrint("-");
+             else
+                DebugPrint("+");
+             *p = 'X';
+	     DebugPrint(fmt2, (unsigned long) delta);
+          }
+          else
+	     DebugPrint(fmt, (unsigned long) delta);
+
+	  if (deref)
+	     *deref += delta;
+
+	  break;
+    }
+
+}
+
+
+void reg_name(short which, char size)
+{
+
+    if (size == 'F')
+    {
+       DebugPrint("ST(%d)", which);
+       return;
+    }
+
+    if (((size == 'v') && (OperandSize == 32)) || (size == 'd'))
+    {
+       DebugPutChar('E');
+    }
+
+    if (size == 'b')
+    {
+       DebugPutChar("ACDBACDB"[which]);
+       DebugPutChar("LLLLHHHH"[which]);
+    }
+    else
+    {
+       DebugPutChar("ACDBSBSD"[which]);
+       DebugPutChar("XXXXPPII"[which]);
+    }
+
+}
+
+
+short do_sib(StackFrame *stackFrame, short m, long *deref)
+{
+
+    long sib_val, istr_val, factor, offset = 0;
+    short pick_signed = DefaultPickSign;
+    short s, i, b, extra=0;
+
+    s = ss(sib());
+    i = indx(sib());
+    b = base(sib());
+    if (b == 5)
+    {
+       if (m == 0)
+       {
+	  if (deref)
+	     *deref = 0;
+	  ProcessInstruction(stackFrame, "%p:[");
+	  OutputHex('d', pSize, 0, AddressSize, 1, deref);
+       }
+       else
+       {
+
+	  if (debug_deref && stackFrame)
+	     DebugPrint("<EBP=%08X>", stackFrame->tEBP);
+
+	  if (deref && stackFrame)
+	     *deref += stackFrame->tEBP;
+	  ProcessInstruction(stackFrame, "%p:[EBP");
+	  pick_signed |= 2;
+       }
+    }
+    else
+    {
+       pick_signed |= 2;
+       sib_val = sib_get_value(b, stackFrame);
+
+       if (debug_deref)
+	  DebugPrint("<sib=%08X>", sib_val);
+
+       if (deref)
+	  *deref += sib_val;
+
+       ProcessInstruction(stackFrame, sib_str[b]);
+       if ((b == i) && (b != 4) && (i != 5))
+	  extra = 1;
+    }
+    if (extra == 0)
+    {
+       pick_signed |= 2;
+       istr_val = istr_get_value(i, stackFrame);
+
+       if (debug_deref)
+	  DebugPrint("<istr=%08X>", istr_val);
+
+       offset += istr_val;
+
+       DebugPrint(i_str[i]);
+    }
+
+    if (i != 4 && s)
+    {
+       DebugPrint("*%X", (1 << s) + extra);
+       factor = (1 << s) + extra;
+
+       if (debug_deref)
+	  DebugPrint("<factor=%08X>", factor);
+
+       offset = (offset * factor);
+    }
+
+    if (deref)
+       *deref += offset;
+
+    return pick_signed;
+
+}
+
+
+void do_modrm(StackFrame *stackFrame, char t)
+{
+
+    long reg_val;
+    short m = mod(modrm());
+    short r = rm(modrm());
+    short extend = (AddressSize == 32) ? 4 : 2;
+    short pick_signed = DefaultPickSign;
+
+    if (t == 'b')
+       pSize = 1;
+    else
+    if (t == 'v' && OperandSize == 32)
+       pSize = 4;
+    else
+    if (t == 'v' && OperandSize == 16)
+       pSize = 2;
+
+    if (m == 3)
+    {
+       reg_name(r, t);
+       return;
+    }
+    if ((m == 0) && (r == 5) && (AddressSize == 32))
+    {
+       DeRefValue = 0;
+       ProcessInstruction(stackFrame, "%p:[");
+       OutputHex('d', extend, 0, AddressSize, 0, (long *) &DeRefValue);
+       DebugPutChar(']');
+       dereference_address(DeRefValue, pSize);
+       return;
+    }
+    if ((m == 0) && (r == 6) && (AddressSize == 16))
+    {
+       DeRefValue = 0;
+       ProcessInstruction(stackFrame, "%p:[");
+       OutputHex('w', extend, 0, AddressSize, 0, (long *) &DeRefValue);
+       DebugPutChar(']');
+       dereference_address(DeRefValue, pSize);
+       return;
+    }
+    if ((AddressSize != 32) || (r != 4))
+    {
+       DeRefValue = 0;
+       ProcessInstruction(stackFrame, "%p:[");
+    }
+
+    if (AddressSize == 16)
+    {
+       DebugPrint(r_str[r]);
+       pick_signed |= 2;
+    }
+    else
+    {
+       DeRefValue = 0;
+       if (r == 4)
+	  pick_signed |= do_sib(stackFrame, m, (long *)&DeRefValue);
+       else
+       {
+	  reg_val = reg_get_value(r, stackFrame);
+	  DeRefValue += reg_val;
+
+	  if (debug_deref)
+	     DebugPrint("<%s=%08X>", reg_names[2][r], reg_val);
+
+	  DebugPrint(reg_names[2][r]);
+	  pick_signed |= 2;
+       }
+    }
+    MODRMExtend = extend;
+    OutputHex("xbv"[m], extend, 1, AddressSize, pick_signed, (long *) &DeRefValue);
+    DebugPutChar(']');
+    dereference_address(DeRefValue, pSize);
+
+}
+
+
+void floating_point(StackFrame *stackFrame, short e1)
+{
+
+    short esc = e1 * 8 + reg(modrm());
+
+    if (mod(modrm()) == 3)
+    {
+       if (fspecial[esc])
+       {
+	  if (fspecial[esc][0] && (fspecial[esc][0][0] == '*'))
+	  {
+	     ProcessInstruction(stackFrame, fspecial[esc][0]+1);
+	  }
+	  else
+	  {
+	     ProcessInstruction(stackFrame, fspecial[esc][rm(modrm())]);
+	  }
+       }
+       else
+       {
+	  ProcessInstruction(stackFrame, floatops[esc]);
+	  ProcessInstruction(stackFrame, " %EF");
+       }
+    }
+    else
+    {
+       ProcessInstruction(stackFrame, floatops[esc]);
+       ProcessInstruction(stackFrame, " %EF");
+    }
+}
+
+
+void percent(StackFrame *stackFrame, char c, unsigned char **tptr)
+{
+
+     long vofs, delta;
+     unsigned char *name;
+     short default_signed = DefaultPickSign;
+     char t = *(*tptr)++, it;
+     short extend = (AddressSize == 32) ? 4 : 2;
+     short iextend;
+
+     if (c != '+')
+     {
+	if (t == '-')
+	{
+	   default_signed = 1;
+	   t = *(*tptr)++;
+	}
+	else if (t == '+')
+	{
+	   default_signed = 2;
+	   t = *(*tptr)++;
+	}
+     }
+     switch (c)
+     {
+
+	case 'A':
+	   OutputHex(t, extend, 0, AddressSize, 0, 0);
+	   break;
+
+	case 'C':
+	   DebugPrint("CR%d", reg(modrm()));
+	   break;
+
+	case 'D':
+	   DebugPrint("DR%d", reg(modrm()));
+	   break;
+
+	case 'E':
+	   do_modrm(stackFrame, t);
+	   break;
+
+	case 'G':
+	   if (t == 'F')
+	      reg_name(rm(modrm()), t);
+	   else
+	      reg_name(reg(modrm()), t);
+	   break;
+
+	case 'I':
+	   switch (t)
+	   {
+	      case 'b':
+		 iextend = 1;
+		 it = *(*tptr)++;
+		 OutputHex(it, iextend, 0, OperandSize, default_signed, 0);
+		 break;
+
+	      case 'v':
+		 iextend = extend;
+		 it = *(*tptr)++;
+		 OutputHex(it, iextend, 0, OperandSize, default_signed, 0);
+		 break;
+
+	      default:
+		 iextend = 0;
+		 OutputHex(t, iextend, 0, OperandSize, default_signed, 0);
+		 break;
+	   }
+	   break;
+
+	case 'J':
+	   switch (bytes(t))
+	   {
+
+	      case 1:
+		 vofs = (char) getbyte();
+		 break;
+
+	      case 2:
+		 vofs = getbyte();
+		 vofs += getbyte() << 8;
+		 vofs = (int) vofs;
+		 break;
+
+	      case 4:
+		 vofs = (long)getbyte();
+		 vofs |= (long)getbyte() << 8;
+		 vofs |= (long)getbyte() << 16;
+		 vofs |= (long)getbyte() << 24;
+		 break;
+
+	      default:
+		 vofs = 0;	/* To avoid uninit error */
+	   }
+
+	   name = output_jmp_address(stackFrame, vofs, (long *) &delta);
+	   DebugPrint("%s", name);
+
+	   if (delta)
+	      DebugPrint("+%X (%X %c)", delta, ((long)vofs +
+                        (long)VirtualAddress),
+		        (vofs & 0x80000000UL) ? 0x1e : 0x1f);
+	   break;
+
+	case 'M':
+	   do_modrm(stackFrame, t);
+	   break;
+
+	case 'O':
+	   if (t == 'b')
+	      pSize = 1;
+	   else
+	   if (t == 'v' && OperandSize == 32)
+	      pSize = 4;
+	   else
+	   if (t == 'v' && OperandSize == 16)
+	      pSize = 2;
+	   DeRefValue = 0;
+	   ProcessInstruction(stackFrame, "%p:[");
+	   OutputHex(t, extend, 0, AddressSize, 0, (long *) &DeRefValue);
+	   DebugPutChar(']');
+	   dereference_address(DeRefValue, pSize);
+	   break;
+
+	case 'R':
+	   do_modrm(stackFrame, t);
+	   break;
+
+	case 'S':
+	   DebugPutChar("ECSDFG"[reg(modrm())]);
+	   DebugPutChar('S');
+	   break;
+
+	case 'T':
+	   DebugPrint("TR%d", reg(modrm()));
+	   break;
+
+	case 'X':
+	   if (t == 'b')
+	      pSize = 1;
+	   else
+	   if (t == 'v' && OperandSize == 32)
+	      pSize = 4;
+	   else
+	   if (t == 'v' && OperandSize == 16)
+	      pSize = 2;
+	   DebugPrint("DS:[");
+	   if (AddressSize == 32)
+	      DebugPutChar('E');
+	   DebugPrint("SI");
+	   if (AddressSize==32 && stackFrame)
+	      DebugPrint("=%08X", stackFrame->tESI);
+	   DebugPutChar(']');
+
+	   if (debug_deref && stackFrame)
+	      DebugPrint("<ESI=%08X>", stackFrame->tESI);
+
+           if (stackFrame)
+	      dereference_address(stackFrame->tESI, pSize);
+	   break;
+
+	case 'Y':
+	   if (t == 'b')
+	      pSize = 1;
+	   else
+	   if (t == 'v' && OperandSize == 32)
+	      pSize = 4;
+	   else
+	   if (t == 'v' && OperandSize == 16)
+	      pSize = 2;
+	   DebugPrint("ES:[");
+	   if (AddressSize == 32)
+	      DebugPutChar('E');
+	   DebugPrint("DI");
+	   if (AddressSize==32 && stackFrame)
+	      DebugPrint("=%08X", stackFrame->tEDI);
+	   DebugPutChar(']');
+
+	   if (debug_deref && stackFrame)
+	      DebugPrint("<EDI=%08X>", stackFrame->tEDI);
+
+           if (stackFrame)
+	      dereference_address(stackFrame->tEDI, pSize);
+	   break;
+
+	case '2':
+	   ProcessInstruction(stackFrame, second[getbyte()]);
+	   break;
+
+	case 'e':
+	   if (OperandSize == 32)
+	   {
+	      if (t == 'w')
+		 DebugPutChar('D');
+	      else
+	      {
+		 DebugPutChar('E');
+		 DebugPutChar(toupper(t));
+	      }
+	   }
+	   else
+	      DebugPutChar(toupper(t));
+	   break;
+
+	case 'f':
+	   floating_point(stackFrame, t - '0');
+	   break;
+
+	case 'g':
+	   ProcessInstruction(stackFrame, groups[t - '0'][reg(modrm())]);
+	   break;
+
+	case 'p':
+	   switch (t)
+	   {
+	      case 'c':
+	      case 'd':
+	      case 'e':
+	      case 'f':
+	      case 'g':
+	      case 's':
+		 Prefix = t;
+		 ProcessInstruction(stackFrame, opmap1[getbyte()]);
+		 break;
+
+	      case ':':
+		 if (Prefix)
+		    DebugPrint("%cS:", toupper(Prefix));
+		 break;
+
+	      case ' ':
+		 ProcessInstruction(stackFrame, opmap1[getbyte()]);
+		 break;
+
+	   }
+	   break;
+
+	case 's':
+	   switch (t)
+	   {
+	      case 'a':
+		 AddressSize = 48 - AddressSize;
+		 ProcessInstruction(stackFrame, opmap1[getbyte()]);
+		 break;
+
+	      case 'o':
+		 OperandSize = 48 - OperandSize;
+		 ProcessInstruction(stackFrame, opmap1[getbyte()]);
+		 break;
+	   }
+	   break;
+
+	case '+':
+	   switch (t)
+	   {
+
+	      case '-':
+		 DefaultPickSign = 1;
+		 break;
+
+	      case '+':
+		 DefaultPickSign = 2;
+		 break;
+
+	      default:
+		 DefaultPickSign = 0;
+		 break;
+	   }
+     }
+}
+
+unsigned long nestLevel;
+
+void ProcessInstruction(StackFrame *stackFrame, unsigned char *s)
+{
+
+     short c;
+
+     nestLevel++;
+     if (nestLevel > 5)
+     {
+	DebugPrint("<INVALID OPCODE [NESTED]>");
+	if (nestLevel)
+	   nestLevel--;
+	return;
+     }
+
+     if (s == 0)
+     {
+	DebugPrint("<INVALID OPCODE>");
+	if (nestLevel)
+	   nestLevel--;
+	return;
+     }
+
+     while ((c = *s++) != 0)
+     {
+	if (c == '%')
+	{
+	   c = *s++;
+	   percent(stackFrame, c, &s);
+	}
+	else
+	if (c == ' ')
+	   DebugPutChar('\t');
+	else
+	   DebugPutChar(c);
+     }
+     if (nestLevel)
+	nestLevel--;
+
+}
+
+unsigned long unassemble(StackFrame *stackFrame, unsigned long ip,
+                         unsigned long use, unsigned long *ret)
+{
+
+    long delta;
+    long segment, offset;
+    unsigned char *v = (unsigned char *) ip;
+
+    if (use)
+       SegmentSize = 32;
+    else
+       SegmentSize = 16;
+
+    DefaultPickSign = 0;
+    needs_proceed = 0;
+    jmp_active = 0;
+    nestLevel = 0;
+    pSize = 4;
+
+    output_address((void *)v, (unsigned long *) &delta);
+
+    if (SegmentSize == 32)
+    {
+       DBGPrint("%08X ", (unsigned)v);
+    }
+    else
+    {
+       segment = (((unsigned long)v >> 4) & 0x0000FFFF);
+       offset = ((unsigned long)v & 0x0000000F);
+       DBGPrint("%04X:%04X ", (unsigned)segment, (unsigned)offset);
+    }
+
+    Prefix = 0;
+    modrmv = sibv = -1;
+    OperandSize = AddressSize = SegmentSize;
+    VirtualAddress = (void *)v;
+    bufp = bufe = 0;
+    Columns = 0;
+    ubufp = ubuf;
+    ProcessInstruction(stackFrame, opmap1[getbyte()]);
+
+    do
+    {
+       DBGPrint(" ");
+       Columns++;
+    } while (Columns < 15);
+
+    Columns += strlen(ubuf);
+
+    do
+    {
+       DebugPutChar(' ');
+       Columns++;
+    } while (Columns < 43);
+
+    if (ret)
+       *ret = (unsigned long)VirtualAddress;
+
+    if (DBGPrint("%s\n", ubuf)) return 1;
+
+    /*
+    *  check for CALL, REP, INT, and LOOP instructions for proceed
+    *  breakpoint
+    */
+
+    if ((strncmp(ubuf, "CALL", 4) == 0) || (strncmp(ubuf, "REP", 3) == 0) ||
+	(strncmp(ubuf, "INT", 3) == 0)  || (strncmp(ubuf, "LOOP", 4) == 0))
+    {
+       needs_proceed = 1;
+       jmp_active = 1;
+    }
+
+    if ((strncmp(ubuf, "IRET", 4) == 0) || (strncmp(ubuf, "RET", 3) == 0))
+       jmp_active = 1;
+
+    return (unsigned long) 0;
+
+}
+
+int mdb_unasm_length(void *ip, int use)
+{
+    unsigned char *oldVAddress;
+    unsigned char *v = (unsigned char *) ip;
+
+    if (use)
+       SegmentSize = 32;
+    else
+       SegmentSize = 16;
+
+    DefaultPickSign = 0;
+    needs_proceed = 0;
+    jmp_active = 0;
+    nestLevel = 0;
+    pSize = 4;
+
+    Prefix = 0;
+    modrmv = sibv = -1;
+    OperandSize = AddressSize = SegmentSize;
+    oldVAddress = VirtualAddress = (void *)v;
+    bufp = bufe = 0;
+    Columns = 0;
+    ubufp = ubuf;
+    ProcessInstruction(NULL, opmap1[getbyte()]);
+
+    return (int)((unsigned long)VirtualAddress - (unsigned long)oldVAddress);
+
+}
diff -Naur linux-2.6.27/debug/mdb/mdb-keyboard.h linux-2.6.27-mdb/debug/mdb/mdb-keyboard.h
--- linux-2.6.27/debug/mdb/mdb-keyboard.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-keyboard.h	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,137 @@
+
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#undef KBD_REPORT_ERR			/* Report keyboard errors */
+#define KBD_REPORT_UNKN			/* Report unknown scan codes */
+#define KBD_REPORT_TIMEOUTS		/* Report keyboard timeouts */
+#undef KBD_IS_FOCUS_9000		/* We have the brain-damaged FOCUS-9000 keyboard */
+#undef INITIALIZE_MOUSE			/* Define if your PS/2 mouse needs initialization. */
+
+
+#define KBD_INIT_TIMEOUT 1000		/* Timeout in ms for initializing the keyboard */
+#define KBC_TIMEOUT 250			/* Timeout in ms for sending to keyboard controller */
+#define KBD_TIMEOUT 1000		/* Timeout in ms for keyboard command acknowledge */
+
+/*
+ *	Keyboard Controller Registers on normal PCs.
+ */
+
+#define KBD_STATUS_REG		0x64	/* Status register (R) */
+#define KBD_CNTL_REG		0x64	/* Controller command register (W) */
+#define KBD_DATA_REG		0x60	/* Keyboard data register (R/W) */
+
+/*
+ *	Keyboard Controller Commands
+ */
+
+#define KBD_CCMD_READ_MODE	0x20	/* Read mode bits */
+#define KBD_CCMD_WRITE_MODE	0x60	/* Write mode bits */
+#define KBD_CCMD_GET_VERSION	0xA1	/* Get controller version */
+#define KBD_CCMD_MOUSE_DISABLE	0xA7	/* Disable mouse interface */
+#define KBD_CCMD_MOUSE_ENABLE	0xA8	/* Enable mouse interface */
+#define KBD_CCMD_TEST_MOUSE	0xA9	/* Mouse interface test */
+#define KBD_CCMD_SELF_TEST	0xAA	/* Controller self test */
+#define KBD_CCMD_KBD_TEST	0xAB	/* Keyboard interface test */
+#define KBD_CCMD_KBD_DISABLE	0xAD	/* Keyboard interface disable */
+#define KBD_CCMD_KBD_ENABLE	0xAE	/* Keyboard interface enable */
+#define KBD_CCMD_WRITE_AUX_OBUF	0xD3    /* Write to output buffer as if
+					   initiated by the auxiliary device */
+#define KBD_CCMD_WRITE_MOUSE	0xD4	/* Write the following byte to the mouse */
+
+/*
+ *	Keyboard Commands
+ */
+
+#define KBD_CMD_SET_LEDS	0xED	/* Set keyboard leds */
+#define KBD_CMD_SET_RATE	0xF3	/* Set typematic rate */
+#define KBD_CMD_ENABLE		0xF4	/* Enable scanning */
+#define KBD_CMD_DISABLE		0xF5	/* Disable scanning */
+#define KBD_CMD_RESET		0xFF	/* Reset */
+
+/*
+ *	Keyboard Replies
+ */
+
+#define KBD_REPLY_POR		0xAA	/* Power on reset */
+#define KBD_REPLY_ACK		0xFA	/* Command ACK */
+#define KBD_REPLY_RESEND	0xFE	/* Command NACK, send the cmd again */
+
+/*
+ *	Status Register Bits
+ */
+
+#define KBD_STAT_OBF		0x01	/* Keyboard output buffer full */
+#define KBD_STAT_IBF		0x02	/* Keyboard input buffer full */
+#define KBD_STAT_SELFTEST	0x04	/* Self test successful */
+#define KBD_STAT_CMD		0x08	/* Last write was a command write (0=data) */
+#define KBD_STAT_UNLOCKED	0x10	/* Zero if keyboard locked */
+#define KBD_STAT_MOUSE_OBF	0x20	/* Mouse output buffer full */
+#define KBD_STAT_GTO		0x40	/* General receive/xmit timeout */
+#define KBD_STAT_PERR		0x80	/* Parity error */
+
+#define AUX_STAT_OBF (KBD_STAT_OBF | KBD_STAT_MOUSE_OBF)
+
+/*
+ *	Controller Mode Register Bits
+ */
+
+#define KBD_MODE_KBD_INT	0x01	/* Keyboard data generate IRQ1 */
+#define KBD_MODE_MOUSE_INT	0x02	/* Mouse data generate IRQ12 */
+#define KBD_MODE_SYS		0x04	/* The system flag (?) */
+#define KBD_MODE_NO_KEYLOCK	0x08	/* The keylock doesn't affect the keyboard if set */
+#define KBD_MODE_DISABLE_KBD	0x10	/* Disable keyboard interface */
+#define KBD_MODE_DISABLE_MOUSE	0x20	/* Disable mouse interface */
+#define KBD_MODE_KCC		0x40	/* Scan code conversion to PC format */
+#define KBD_MODE_RFU		0x80
+
+/*
+ *	Mouse Commands
+ */
+
+#define AUX_SET_RES		0xE8	/* Set resolution */
+#define AUX_SET_SCALE11		0xE6	/* Set 1:1 scaling */
+#define AUX_SET_SCALE21		0xE7	/* Set 2:1 scaling */
+#define AUX_GET_SCALE		0xE9	/* Get scaling factor */
+#define AUX_SET_STREAM		0xEA	/* Set stream mode */
+#define AUX_SET_SAMPLE		0xF3	/* Set sample rate */
+#define AUX_ENABLE_DEV		0xF4	/* Enable aux device */
+#define AUX_DISABLE_DEV		0xF5	/* Disable aux device */
+#define AUX_RESET		0xFF	/* Reset aux device */
+#define AUX_ACK			0xFA	/* Command byte ACK. */
+
+#define AUX_BUF_SIZE		2048	/* This might be better divisible by
+					   three to make overruns stay in sync
+					   but then the read function would need
+					   a lock etc - ick */
diff -Naur linux-2.6.27/debug/mdb/mdb-list.c linux-2.6.27-mdb/debug/mdb/mdb-list.c
--- linux-2.6.27/debug/mdb/mdb-list.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-list.c	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,642 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/uaccess.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <linux/io.h>
+
+#ifdef CONFIG_SMP
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb.h"
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+#ifdef MDB_ATOMIC
+static spinlock_t accelLock = SPIN_LOCK_UNLOCKED;
+static long accelflags;
+#endif
+
+ACCELERATOR *accelHead;
+ACCELERATOR *accelTail;
+
+unsigned long AccelRoutine(unsigned long key, void *p)
+{
+    register ACCELERATOR *accel;
+    unsigned long retCode;
+
+    accel = accelHead;
+    while (accel)
+    {
+       if (accel->accelFlags && accel->accelRoutine && accel->key == key)
+       {
+	  retCode = (accel->accelRoutine)(key, p, accel);
+	  return retCode;
+       }
+       accel = accel->accelNext;
+    }
+    return 0;
+}
+
+void ShowDebuggerAccelerators(void)
+{
+   register ACCELERATOR *accel;
+
+   DBGPrint("\nDebugger Keystroke Accelerator(s)\n");
+
+   accel = accelHead;
+   while (accel)
+   {
+      if (accel->shortHelp)
+         if (DBGPrint("%s\n", accel->shortHelp)) return;
+      accel = accel->accelNext;
+   }
+   return;
+}
+
+unsigned long IsAccelerator(unsigned long key)
+{
+    register ACCELERATOR *accel;
+
+    accel = accelHead;
+    while (accel)
+    {
+       if (accel->accelFlags && accel->accelRoutine && accel->key == key)
+       {
+	  return 1;
+       }
+       accel = accel->accelNext;
+    }
+    return 0;
+}
+
+unsigned long AccelHelpRoutine(unsigned long key)
+{
+    register ACCELERATOR *accel;
+
+    accel = accelHead;
+    if (key)  /* if we were passed a command string */
+    {
+       while (accel)
+       {
+	  if (accel->accelFlags && accel->key == key)
+	  {
+	     if (accel->accelRoutineHelp)
+	     {
+		DBGPrint("Accelerator %08X\n", (unsigned)accel->key);
+		(accel->accelRoutineHelp)(key, accel);
+		return 1;
+	     }
+	     DBGPrint("Accelerator %08X\n", (unsigned)accel->key);
+	     return 1;
+	  }
+	  accel = accel->accelNext;
+       }
+       DBGPrint("Help for Accelerator [%08X] not found\n", (unsigned)key);
+       return 1;
+    }
+    else
+    {
+       DBGPrint("Accelerator(s)\n");
+       while (accel)
+       {
+	  if (accel->accelFlags && accel->key && !accel->supervisorCommand)
+	     DBGPrint("%08X         - %s\n",
+                      (unsigned)accel->key, accel->shortHelp);
+	  accel = accel->accelNext;
+       }
+    }
+    return 0;
+}
+
+ACCELERATOR *insertAccel(ACCELERATOR *i, ACCELERATOR *top)
+{
+    ACCELERATOR *old, *p;
+
+    if (!accelTail)
+    {
+       i->accelNext = i->accelPrior = NULL;
+       accelTail = i;
+       return i;
+    }
+    p = top;
+    old = NULL;
+    while (p)
+    {
+       if (p->key < i->key)
+       {
+	  old = p;
+	  p = p->accelNext;
+       }
+       else
+       {
+	  if (p->accelPrior)
+	  {
+	     p->accelPrior->accelNext = i;
+	     i->accelNext = p;
+	     i->accelPrior = p->accelPrior;
+	     p->accelPrior = i;
+	     return top;
+	  }
+	  i->accelNext = p;
+	  i->accelPrior = NULL;
+	  p->accelPrior = i;
+	  return i;
+       }
+    }
+    old->accelNext = i;
+    i->accelNext = NULL;
+    i->accelPrior = old;
+    accelTail = i;
+    return accelHead;
+
+}
+
+unsigned long AddAccelRoutine(ACCELERATOR *newAccel)
+{
+    register ACCELERATOR *accel;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&accelLock, accelflags);
+#endif
+    accel = accelHead;
+    while (accel)
+    {
+       if (accel == newAccel || accel->key == newAccel->key)
+       {
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&accelLock, accelflags);
+#endif
+	  return 1;
+       }
+       accel = accel->accelNext;
+    }
+    newAccel->accelFlags = -1;
+    accelHead = insertAccel(newAccel, accelHead);
+
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&accelLock, accelflags);
+#endif
+    return 0;
+}
+
+unsigned long RemoveAccelRoutine(ACCELERATOR *newAccel)
+{
+    register ACCELERATOR *accel;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&accelLock, accelflags);
+#endif
+    accel = accelHead;
+    while (accel)
+    {
+       if (accel == newAccel)   /* found, remove from list */
+       {
+	  if (accelHead == newAccel)
+	  {
+	     accelHead = (void *) newAccel->accelNext;
+	     if (accelHead)
+		accelHead->accelPrior = NULL;
+	     else
+		accelTail = NULL;
+	  }
+	  else
+	  {
+	     newAccel->accelPrior->accelNext = newAccel->accelNext;
+	     if (newAccel != accelTail)
+		newAccel->accelNext->accelPrior = newAccel->accelPrior;
+	     else
+		accelTail = newAccel->accelPrior;
+	  }
+	  newAccel->accelNext = newAccel->accelPrior = 0;
+	  newAccel->accelFlags = 0;
+
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&accelLock, accelflags);
+#endif
+	  return 0;
+       }
+       accel = accel->accelNext;
+    }
+
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&accelLock, accelflags);
+#endif
+    return -1;
+}
+
+#ifdef MDB_ATOMIC
+static spinlock_t altDebugLock = SPIN_LOCK_UNLOCKED;
+static long altflags;
+#endif
+
+ALT_DEBUGGER *altDebugHead;
+ALT_DEBUGGER *altDebugTail;
+
+int AlternateDebuggerRoutine(int reason, int error, void *frame)
+{
+    register ALT_DEBUGGER *altDebug;
+    register unsigned long retCode;
+    unsigned long state;
+
+    state = save_flags();
+    altDebug = altDebugHead;
+    while (altDebug)
+    {
+       if (altDebug->AlternateDebugger)
+       {
+	  retCode = (altDebug->AlternateDebugger)(reason, error, frame);
+	  if (retCode)
+          {
+             restore_flags(state);
+	     return retCode;
+          }
+       }
+       altDebug = altDebug->altDebugNext;
+    }
+    restore_flags(state);
+    return 0;
+}
+
+unsigned long AddAlternateDebugger(ALT_DEBUGGER *Debugger)
+{
+    register ALT_DEBUGGER *altDebug;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&altDebugLock, altflags);
+#endif
+    altDebug = altDebugHead;
+    while (altDebug)
+    {
+       if (altDebug == Debugger)
+       {
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&altDebugLock, altflags);
+#endif
+	  return 1;
+       }
+       altDebug = altDebug->altDebugNext;
+    }
+    if (!altDebugHead)
+    {
+       altDebugHead = Debugger;
+       altDebugTail = Debugger;
+       Debugger->altDebugNext = 0;
+       Debugger->altDebugPrior = 0;
+    }
+    else
+    {
+       altDebugTail->altDebugNext = Debugger;
+       Debugger->altDebugNext = 0;
+       Debugger->altDebugPrior = altDebugTail;
+       altDebugTail = Debugger;
+    }
+
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&altDebugLock, altflags);
+#endif
+    return 0;
+}
+
+unsigned long RemoveAlternateDebugger(ALT_DEBUGGER *Debugger)
+{
+    register ALT_DEBUGGER *altDebug;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&altDebugLock, altflags);
+#endif
+    altDebug = altDebugHead;
+    while (altDebug)
+    {
+       if (altDebug == Debugger)   /* found, remove from list */
+       {
+	  if (altDebugHead == Debugger)
+	  {
+	     altDebugHead = (void *) Debugger->altDebugNext;
+	     if (altDebugHead)
+		altDebugHead->altDebugPrior = NULL;
+	     else
+		altDebugTail = NULL;
+	  }
+	  else
+	  {
+	     Debugger->altDebugPrior->altDebugNext = Debugger->altDebugNext;
+	     if (Debugger != altDebugTail)
+		Debugger->altDebugNext->altDebugPrior = Debugger->altDebugPrior;
+	     else
+		altDebugTail = Debugger->altDebugPrior;
+	  }
+	  Debugger->altDebugNext = Debugger->altDebugPrior = 0;
+
+#ifdef MDB_ATOMIC
+          spin_unlock_irqrestore(&altDebugLock, altflags);
+#endif
+	  return 0;
+       }
+       altDebug = altDebug->altDebugNext;
+    }
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&altDebugLock, altflags);
+#endif
+    return -1;
+}
+
+#ifdef MDB_ATOMIC
+static spinlock_t debugParserLock = SPIN_LOCK_UNLOCKED;
+static long parserflags;
+#endif
+
+DEBUGGER_PARSER *debugParserHead;
+DEBUGGER_PARSER *debugParserTail;
+
+unsigned long DebuggerParserRoutine(unsigned char *command, unsigned char *commandLine,
+			    StackFrame *stackFrame, unsigned long Exception)
+{
+    register DEBUGGER_PARSER *debugParser;
+    register unsigned long retCode, valid = 0, length;
+    register unsigned char *p;
+
+    p = commandLine;
+    if (!p)
+       return 0;
+
+    /* if a passed string is just whitespace, return error */
+    while (*p)
+    {
+       if ((*p != ' ') && (*p != '\n') && (*p != '\r'))
+       {
+          valid = 1;
+          break;
+       }
+       p++;
+    }
+    if (!valid)
+       return 0;
+
+    UpcaseString(command);
+    length = strlen(command);
+
+    debugParser = debugParserHead;
+    while (debugParser)
+    {
+       if (debugParser->parserFlags && debugParser->DebugCommandParser &&
+	   (debugParser->debugCommandNameLength == length) &&
+	   (!strcmp(debugParser->debugCommandName, command)))
+       {
+	  retCode = (debugParser->DebugCommandParser)(commandLine, stackFrame,
+						      Exception, debugParser);
+	  if (retCode)
+	     return retCode;
+       }
+       debugParser = debugParser->debugNext;
+    }
+
+    DBGPrint("unknown mdb command -> %s\n", command);
+    return 0;
+}
+
+unsigned long DebuggerParserHelpRoutine(unsigned char *command, unsigned char *commandLine)
+{
+    extern void ShowDebuggerAccelerators(void);
+    register DEBUGGER_PARSER *debugParser;
+    register unsigned long length;
+
+    UpcaseString(command);
+    length = strlen(command);
+    if (*command)  /* if we were passed a command string */
+    {
+
+       debugParser = debugParserHead;
+       while (debugParser)
+       {
+	  if (debugParser->parserFlags &&
+             (debugParser->debugCommandNameLength == length) &&
+             !strcmp(debugParser->debugCommandName, command))
+	  {
+	     if (debugParser->DebugCommandParserHelp)
+	     {
+		DBGPrint("Help for Command %s\n",
+                         debugParser->debugCommandName);
+		(debugParser->DebugCommandParserHelp)(commandLine, debugParser);
+		return 1;
+	     }
+	     DBGPrint("Help for Command %s\n", debugParser->debugCommandName);
+	     return 1;
+	  }
+	  debugParser = debugParser->debugNext;
+       }
+
+       DBGPrint("Help for Command [%s] not found\n", command);
+       return 1;
+    }
+    else
+    {
+       DBGPrint("Debugger Command(s)\n");
+
+       debugParser = debugParserHead;
+       while (debugParser)
+       {
+	  if (debugParser->parserFlags && debugParser->debugCommandName &&
+	      !debugParser->supervisorCommand)
+	     if (DBGPrint("%15s    - %s\n", debugParser->debugCommandName,
+                      debugParser->shortHelp)) return 0;
+	  debugParser = debugParser->debugNext;
+       }
+       ShowDebuggerAccelerators();
+    }
+    return 0;
+}
+
+DEBUGGER_PARSER *insertDebuggerParser(DEBUGGER_PARSER *i, DEBUGGER_PARSER *top)
+{
+    DEBUGGER_PARSER *old, *p;
+
+    if (!debugParserTail)
+    {
+       i->debugNext = i->debugPrior = NULL;
+       debugParserTail = i;
+       return i;
+    }
+    p = top;
+    old = NULL;
+    while (p)
+    {
+       if (strcmp(p->debugCommandName, i->debugCommandName) < 0)
+       {
+	  old = p;
+	  p = p->debugNext;
+       }
+       else
+       {
+	  if (p->debugPrior)
+	  {
+	     p->debugPrior->debugNext = i;
+	     i->debugNext = p;
+	     i->debugPrior = p->debugPrior;
+	     p->debugPrior = i;
+	     return top;
+	  }
+	  i->debugNext = p;
+	  i->debugPrior = NULL;
+	  p->debugPrior = i;
+	  return i;
+       }
+    }
+    old->debugNext = i;
+    i->debugNext = NULL;
+    i->debugPrior = old;
+    debugParserTail = i;
+    return debugParserHead;
+
+}
+
+unsigned long AddDebuggerCommandParser(DEBUGGER_PARSER *parser)
+{
+    register DEBUGGER_PARSER *debugParser;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&debugParserLock, parserflags);
+#endif
+    parser->parserFlags = -1;
+    parser->debugCommandNameLength = strlen(parser->debugCommandName);
+
+    debugParser = debugParserHead;
+    while (debugParser)
+    {
+       if (debugParser == parser ||
+	  (parser->debugCommandNameLength == 
+           debugParser->debugCommandNameLength &&
+	  (!strcmp(parser->debugCommandName, debugParser->debugCommandName))))
+       {
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&debugParserLock, parserflags);
+#endif
+	  return 1;
+       }
+       debugParser = debugParser->debugNext;
+    }
+
+    debugParserHead = insertDebuggerParser(parser, debugParserHead);
+
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&debugParserLock, parserflags);
+#endif
+    return 0;
+}
+
+unsigned long RemoveDebuggerCommandParser(DEBUGGER_PARSER *parser)
+{
+    register DEBUGGER_PARSER *debugParser;
+
+#ifdef MDB_ATOMIC
+    spin_lock_irqsave(&debugParserLock, parserflags);
+#endif
+    debugParser = debugParserHead;
+    while (debugParser)
+    {
+       if (debugParser == parser)   /* found, remove from list */
+       {
+	  if (debugParserHead == parser)
+	  {
+	     debugParserHead = (void *) parser->debugNext;
+	     if (debugParserHead)
+		debugParserHead->debugPrior = NULL;
+	     else
+		debugParserTail = NULL;
+	  }
+	  else
+	  {
+	     parser->debugPrior->debugNext = parser->debugNext;
+	     if (parser != debugParserTail)
+		parser->debugNext->debugPrior = parser->debugPrior;
+	     else
+		debugParserTail = parser->debugPrior;
+	  }
+	  parser->debugNext = parser->debugPrior = 0;
+	  parser->parserFlags = 0;
+
+#ifdef MDB_ATOMIC
+	  spin_unlock_irqrestore(&debugParserLock, parserflags);
+#endif
+	  return 0;
+       }
+       debugParser = debugParser->debugNext;
+    }
+#ifdef MDB_ATOMIC
+    spin_unlock_irqrestore(&debugParserLock, parserflags);
+#endif
+    return -1;
+}
+
diff -Naur linux-2.6.27/debug/mdb/mdb-list.h linux-2.6.27-mdb/debug/mdb/mdb-list.h
--- linux-2.6.27/debug/mdb/mdb-list.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-list.h	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,102 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#ifndef _MDB_LIST
+#define _MDB_LIST
+
+typedef struct _ACCELERATOR
+{
+    struct _ACCELERATOR *accelNext;
+    struct _ACCELERATOR *accelPrior;
+    unsigned long (*accelRoutine)(unsigned long key, void *p, struct _ACCELERATOR *parser);
+    unsigned long (*accelRoutineHelp)(unsigned long key, struct _ACCELERATOR *parser);
+    unsigned long accelFlags;
+    unsigned long key;
+    unsigned long supervisorCommand;
+    unsigned char *shortHelp;
+} ACCELERATOR;
+
+typedef struct _ALT_DEBUGGER
+{
+    struct _ALT_DEBUGGER *altDebugNext;
+    struct _ALT_DEBUGGER *altDebugPrior;
+    int (*AlternateDebugger)(int reason, int error, void *frame);
+} ALT_DEBUGGER;
+
+extern int AlternateDebuggerRoutine(int reason, int error, void *frame);
+extern unsigned long AddAlternateDebugger(ALT_DEBUGGER *Debugger);
+extern unsigned long RemoveAlternateDebugger(ALT_DEBUGGER *Debugger);
+
+typedef struct _DEBUGGER_PARSER {
+    struct _DEBUGGER_PARSER *debugNext;
+    struct _DEBUGGER_PARSER *debugPrior;
+    unsigned long (*DebugCommandParser)(unsigned char *commandLine,
+			       StackFrame *stackFrame, unsigned long Exception,
+			       struct _DEBUGGER_PARSER *parser);
+    unsigned long (*DebugCommandParserHelp)(unsigned char *commandLine,
+				   struct _DEBUGGER_PARSER *parser);
+    unsigned long parserFlags;
+    unsigned char *debugCommandName;
+    unsigned long debugCommandNameLength;
+    unsigned long supervisorCommand;
+    unsigned char *shortHelp;
+    unsigned long controlTransfer;
+} DEBUGGER_PARSER;
+
+typedef struct _DEBUGGER_LIST
+{
+   DEBUGGER_PARSER *head;
+   DEBUGGER_PARSER *tail;
+} DEBUGGER_LIST;
+
+extern unsigned long DebuggerParserRoutine(unsigned char *command, unsigned char *commandLine,
+			   StackFrame *stackFrame, unsigned long Exception);
+extern unsigned long DebuggerParserHelpRoutine(unsigned char *command, unsigned char *commandLine);
+extern unsigned long AddDebuggerCommandParser(DEBUGGER_PARSER *parser);
+extern unsigned long RemoveDebuggerCommandParser(DEBUGGER_PARSER *parser);
+
+static inline unsigned long strhash(unsigned char *s, int len, int limit)
+{
+   register unsigned long h = 0, a = 127, i;
+
+   if (!limit)
+      return -1;
+
+   for (i = 0; i < len && *s; s++, i++)
+      h = ((a * h) + *s) % limit;
+
+   return h;
+}
+
+#endif
diff -Naur linux-2.6.27/debug/mdb/mdb-logic.c linux-2.6.27-mdb/debug/mdb/mdb-logic.c
--- linux-2.6.27/debug/mdb/mdb-logic.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-logic.c	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,2375 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/uaccess.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <linux/io.h>
+
+#ifdef CONFIG_SMP
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb.h"
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+#define PROCESSOR_32        32
+#define PROCESSOR_64        64
+
+#define DEBUG_EXPRESS        0
+#define DEBUG_BOOL           0
+#define DEBUG_LOGICAL        0
+#define DEBUG_LOGICAL_STACK  0
+#define DEBUG_BOOL_STACK     0
+
+#define INVALID_EXPRESSION  0
+#define NUMERIC_EXPRESSION  1
+#define BOOLEAN_EXPRESSION  2
+
+#define NUM_STACK_SIZE      256
+#define CONTEXT_STACK_SIZE  1024
+#define BOOL_STACK_SIZE     256
+#define LOGICAL_STACK_SIZE  256
+
+#define NULL_TOKEN            0
+#define NUMBER_TOKEN          1
+#define MINUS_TOKEN           2
+#define PLUS_TOKEN            3
+#define MULTIPLY_TOKEN        4
+#define DIVIDE_TOKEN          5
+#define GREATER_TOKEN         6
+#define LESS_TOKEN            7
+#define XOR_TOKEN             8
+#define AND_TOKEN             9
+#define OR_TOKEN             10
+#define NOT_TOKEN            11
+#define NEG_TOKEN            12
+#define EQUAL_TOKEN          13
+#define LEFT_SHIFT_TOKEN     14
+#define RIGHT_SHIFT_TOKEN    15
+#define SPACE_TOKEN          16
+#define FLAGS_TOKEN          17
+#define EAX_TOKEN            18
+#define EBX_TOKEN            19
+#define ECX_TOKEN            20
+#define EDX_TOKEN            21
+#define ESI_TOKEN            22
+#define EDI_TOKEN            23
+#define EBP_TOKEN            24
+#define ESP_TOKEN            25
+#define CS_TOKEN             26
+#define DS_TOKEN             27
+#define ES_TOKEN             28
+#define FS_TOKEN             29
+#define GS_TOKEN             30
+#define SS_TOKEN             31
+#define DREF_OPEN_TOKEN      32
+#define DREF_CLOSE_TOKEN     33
+#define MOD_TOKEN            34
+#define NUMBER_END           35
+#define GREATER_EQUAL_TOKEN  36
+#define LESS_EQUAL_TOKEN     37
+#define EIP_TOKEN            38
+#define ASSIGNMENT_TOKEN     39
+#define DWORD_TOKEN          40
+#define WORD_TOKEN           41
+#define BYTE_TOKEN           42
+#define LOGICAL_AND_TOKEN    43
+#define LOGICAL_OR_TOKEN     44
+#define CF_TOKEN             45
+#define PF_TOKEN             46
+#define AF_TOKEN             47
+#define ZF_TOKEN             48
+#define SF_TOKEN             49
+#define IF_TOKEN             50
+#define DF_TOKEN             51
+#define OF_TOKEN             52
+#define VM_TOKEN             53
+#define AC_TOKEN             54
+#define BB_TOKEN             55
+#define EB_TOKEN             56
+#define NOT_EQUAL_TOKEN      57
+#define INVALID_NUMBER_TOKEN 58
+
+#define CF_FLAG   0x00000001
+#define PF_FLAG   0x00000004
+#define AF_FLAG   0x00000010
+#define ZF_FLAG   0x00000040
+#define SF_FLAG   0x00000080
+#define TF_FLAG   0x00000100  /* ss flag */
+#define IF_FLAG   0x00000200
+#define DF_FLAG   0x00000400
+#define OF_FLAG   0x00000800
+#define NT_FLAG   0x00004000
+#define RF_FLAG   0x00010000  /* resume flag */
+#define VM_FLAG   0x00020000
+#define AC_FLAG   0x00040000
+#define VIF_FLAG  0x00080000
+#define VIP_FLAG  0x00100000
+#define ID_FLAG   0x00200000
+
+#define   ULONG_PTR         0
+#define   WORD_PTR          1
+#define   BYTE_PTR          2
+
+#define   CLASS_DATA        1
+#define   CLASS_ASSIGN      2
+#define   CLASS_PARTITION   3
+#define   CLASS_ARITHMETIC  4
+#define   CLASS_BOOLEAN     5
+
+unsigned char *exprDescription[]={
+     "INVALID",
+     "NUMERIC",
+     "BOOLEAN",
+     "???????",
+};
+
+unsigned char *parserDescription[]={
+     "NULL_TOKEN",
+     "NUMBER_TOKEN",
+     "MINUS_TOKEN",
+     "PLUS_TOKEN",
+     "MULTIPLY_TOKEN",
+     "DIVIDE_TOKEN",
+     "GREATER_TOKEN",
+     "LESS_TOKEN",
+     "XOR_TOKEN",
+     "AND_TOKEN",
+     "OR_TOKEN",
+     "NOT_TOKEN",
+     "NEG_TOKEN",
+     "EQUAL_TOKEN",
+     "LEFT_SHIFT_TOKEN",
+     "RIGHT_SHIFT_TOKEN",
+     "SPACE_TOKEN",
+     "FLAGS_TOKEN",
+     "EAX_TOKEN",
+     "EBX_TOKEN",
+     "ECX_TOKEN",
+     "EDX_TOKEN",
+     "ESI_TOKEN",
+     "EDI_TOKEN",
+     "EBP_TOKEN",
+     "ESP_TOKEN",
+     "CS_TOKEN",
+     "DS_TOKEN",
+     "ES_TOKEN",
+     "FS_TOKEN",
+     "GS_TOKEN",
+     "SS_TOKEN",
+     "DREF_OPEN_TOKEN",
+     "DREF_CLOSE_TOKEN",
+     "MOD_TOKEN",
+     "NUMBER_END",
+     "GREATER_EQUAL_TOKEN",
+     "LESS_EQUAL_TOKEN",
+     "EIP_TOKEN",
+     "ASSIGNMENT_TOKEN",
+     "DWORD_TOKEN",
+     "WORD_TOKEN",
+     "BYTE_TOKEN",
+     "LOGICAL_AND_TOKEN",
+     "LOGICAL_OR_TOKEN",
+     "CF_TOKEN",
+     "PF_TOKEN",
+     "AF_TOKEN",
+     "ZF_TOKEN",
+     "SF_TOKEN",
+     "IF_TOKEN",
+     "DF_TOKEN",
+     "OF_TOKEN",
+     "VM_TOKEN",
+     "AC_TOKEN",
+     "BEGIN_BRACKET",
+     "END_BRACKET",
+     "NOT_EQUAL_TOKEN"
+     "INVALID_NUMBER_TOKEN"
+};
+
+unsigned char TokenIndex[256];
+unsigned char TokenClass[256];
+unsigned char TokenType[256];
+unsigned long TokenValue[256];
+unsigned long TokenCount;
+
+unsigned long numStack[NUM_STACK_SIZE];
+unsigned long *sp;
+unsigned long *tos;
+unsigned long *bos;
+
+unsigned long contextStack[CONTEXT_STACK_SIZE];
+unsigned long *c_sp;
+unsigned long *c_tos;
+unsigned long *c_bos;
+
+unsigned long booleanStack[BOOL_STACK_SIZE];
+unsigned long *b_sp;
+unsigned long *b_tos;
+unsigned long *b_bos;
+
+unsigned long logicalStack[LOGICAL_STACK_SIZE];
+unsigned long *l_sp;
+unsigned long *l_tos;
+unsigned long *l_bos;
+
+extern unsigned long GetValueFromSymbol(unsigned char *symbolName);
+extern unsigned char delim_table[256];
+
+#ifdef LINUX_DRIVER
+spinlock_t expressLock = SPIN_LOCK_UNLOCKED;
+static long flags;
+#endif
+
+unsigned long GetNumber(unsigned char *p, unsigned char **rp, unsigned long *opl, unsigned long *retCode, unsigned long mode)
+{
+
+    unsigned char *op, *pp = NULL;
+    unsigned long c = 0, decimal = 0, hex_found = 0, invalid = 0, valid = 0;
+
+    pp = op = p;
+    while (*p)
+    {
+       if (*p == 'X' || *p == 'x')
+       {
+          hex_found = 1;
+          p++;
+          pp = p;
+       }
+
+       if (*p >= '0' && *p <= '9')
+       {
+          valid++;
+	  p++;
+       }
+       else
+       if (*p >= 'A' && *p <= 'F')
+       {
+	  hex_found = 1;
+          valid++;
+	  p++;
+       }
+       else
+       if (*p >= 'a' && *p <= 'f')
+       {
+	  hex_found = 1;
+          valid++;
+	  p++;
+       }
+       else
+       if ((*p == 'R') || (*p == 'r'))
+       {
+	  decimal = 1;
+	  p++;
+       }
+       else
+       if (delim_table[((*p) & 0xFF)])
+	  break;
+       else
+       {
+          invalid = 1;
+          break;
+       }
+    }
+
+    if (rp)
+       *rp = p;
+    if (opl)
+       *opl = (unsigned long)((unsigned long)p - (unsigned long) op);
+
+    if (invalid && !valid)
+    {
+       if (retCode)
+          *retCode = -1;   /* invalid string */
+       return 0;
+    }
+
+    p = pp;
+
+    if (mode)
+       decimal = 1;
+
+    if (decimal)
+    {
+       /* parse as decimal number */
+       while (*p)
+       {
+	     if (*p >= '0' && *p <= '9')
+		c = (c * 10) + (*p - '0');
+	     else
+		break;
+	  p++;
+       }
+    }
+    else
+    if (hex_found)
+    {
+       /* parse as hex number */
+       while (*p)
+       {
+	  if (*p >= '0' && *p <= '9')
+	     c = (c << 4) | (*p - '0');
+	  else if (*p >= 'A' && *p <= 'F')
+	     c = (c << 4) | (*p - 'A' + 10);
+	  else if (*p >= 'a' && *p <= 'f')
+	     c = (c << 4) | (*p - 'a' + 10);
+	  else
+	     break;
+	  p++;
+       }
+    }
+    else  /* default parses as hex */
+    {
+       /* parse as hex number */
+       while (*p)
+       {
+	  if (*p >= '0' && *p <= '9')
+	     c = (c << 4) | (*p - '0');
+	  else if (*p >= 'A' && *p <= 'F')
+	     c = (c << 4) | (*p - 'A' + 10);
+	  else if (*p >= 'a' && *p <= 'f')
+	     c = (c << 4) | (*p - 'a' + 10);
+	  else
+	     break;
+	  p++;
+       }
+    }
+
+    if (retCode)
+       *retCode = 0;
+
+    return (c);
+
+}
+
+
+unsigned char *parseTokens(StackFrame *stackFrame, unsigned char *p, unsigned long mode)
+{
+
+    register unsigned long i, value;
+    unsigned char symbol[256], *s;
+    unsigned char *tmp, *op;
+    unsigned long delta, retCode = 0;
+
+    op = p;
+    TokenCount = 0;
+    while (TokenCount < 200 && (unsigned long)p - (unsigned long)op < 200)
+    {
+       if (isalpha(*p) || *p == '_' ||  *p == '@' || *p == '$')
+       {
+	  s = p;
+	  for (i = 0; i < 255; i++)
+          {
+             if (delim_table[((s[i]) & 0xFF)])
+                break;
+
+             if (!isprint(s[i]))
+                break;
+
+	     symbol[i] = s[i];
+          }
+	  symbol[i] = '\0';
+
+	  value = GetValueFromSymbol(symbol);
+	  if (value)
+	  {
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = value;
+	     TokenType[TokenCount++] = NUMBER_TOKEN;
+	     p = &s[i];   /* bump the pointer past the symbol */
+	  }
+       }
+
+       if (stackFrame)
+       {
+	 switch (*p)
+	 {
+
+	  case '\0':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = NULL_TOKEN;
+	     return (p);
+
+	  case ']':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = DREF_CLOSE_TOKEN;
+	     p++;
+	     break;
+
+	  case '(':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = BB_TOKEN;
+	     p++;
+	     break;
+
+	  case ')':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = EB_TOKEN;
+	     p++;
+	     break;
+
+	  case '+':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = PLUS_TOKEN;
+	     p++;
+	     break;
+
+	  case '-':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = MINUS_TOKEN;
+	     p++;
+	     break;
+
+	  case '*':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = MULTIPLY_TOKEN;
+	     p++;
+	     break;
+
+	  case '/':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = DIVIDE_TOKEN;
+	     p++;
+	     break;
+
+	  case '%':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = MOD_TOKEN;
+	     p++;
+	     break;
+
+	  case '~':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = NEG_TOKEN;
+	     p++;
+	     break;
+
+	  case '^':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = XOR_TOKEN;
+	     p++;
+	     break;
+
+	  case '!':
+	     p++;
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = NOT_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = NOT_TOKEN;
+	     break;
+
+	  case ' ':   /* drop spaces on the floor */
+	     p++;
+	     break;
+
+	  /*
+	   *   These cases require special handling
+	   */
+
+	  case 'p':
+	  case 'P':
+	     p++;
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & PF_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = PF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'z':
+	  case 'Z':
+	     p++;
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & ZF_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = ZF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'i':
+	  case 'I':
+	     p++;
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & IF_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = IF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'o':
+	  case 'O':
+	     p++;
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & OF_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = OF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'v':
+	  case 'V':
+	     p++;
+	     if (*p == 'M' || *p == 'm')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & VM_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = VM_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 'x':
+	  case 'X':
+	  case '0':
+	  case '1':
+	  case '2':
+	  case '3':
+	  case '4':
+	  case '5':
+	  case '6':
+	  case '7':
+	  case '8':
+	  case '9':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'a':
+	  case 'A':
+	     tmp = p;
+	     tmp++;
+	     if ((*tmp == 'F' || *tmp == 'f') && (*(tmp + 1) == ' ' || *(tmp + 1) == '=' ))
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & AF_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = AF_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     if ((*tmp == 'C' || *tmp == 'c') && (*(tmp + 1) == ' ' || *(tmp + 1) == '=' ))
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & AC_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = AC_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+
+	  case 'b':
+	  case 'B':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'c':
+	  case 'C':
+	     tmp = p;
+	     tmp++;
+	     if (*tmp == 'S' || *tmp == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tCS;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = CS_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     if ((*tmp == 'F' || *tmp == 'f') && (*(tmp + 1) == ' ' || *(tmp + 1) == '=' ))
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & CF_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = CF_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'd':
+	  case 'D':
+	     tmp = p;
+	     tmp++;
+	     if (*tmp == 'S' || *tmp == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tDS;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = DS_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     if ((*tmp == 'F' || *tmp == 'f') && (*(tmp + 1) == ' ' || *(tmp + 1) == '=' ))
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & DF_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = DF_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'e':
+	  case 'E':
+	     tmp = p;
+	     tmp++;
+	     if (*tmp == 'A' || *tmp == 'a')
+	     {
+		tmp++;
+		if (*tmp == 'X' || *tmp == 'x')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEAX;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = EAX_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode,
+                                                   mode);
+	        ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                   : (TokenType[TokenCount++] = NUMBER_TOKEN));
+		break;
+	     }
+	     if (*tmp == 'B' || *tmp == 'b')
+	     {
+		tmp++;
+		if (*tmp == 'X' || *tmp == 'x')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEBX;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = EBX_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		if (*tmp == 'P' || *tmp == 'p')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEBP;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = EBP_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode,
+                                                   mode);
+	        ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                   : (TokenType[TokenCount++] = NUMBER_TOKEN));
+		break;
+	     }
+	     if (*tmp == 'C' || *tmp == 'c')
+	     {
+		tmp++;
+		if (*tmp == 'X' || *tmp == 'x')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tECX;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = ECX_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode,
+                                                   mode);
+	        ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                   : (TokenType[TokenCount++] = NUMBER_TOKEN));
+		break;
+	     }
+	     if (*tmp == 'D' || *tmp == 'd')
+	     {
+		tmp++;
+		if (*tmp == 'X' || *tmp == 'x')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEDX;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = EDX_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		if (*tmp == 'I' || *tmp == 'i')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEDI;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = EDI_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode,
+                                                   mode);
+	        ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                   : (TokenType[TokenCount++] = NUMBER_TOKEN));
+		break;
+	     }
+	     if (*tmp == 'S' || *tmp == 's')
+	     {
+		tmp++;
+		if (*tmp == 'P' || *tmp == 'p')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tESP;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = ESP_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		if (*tmp == 'I' || *tmp == 'i')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tESI;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = ESI_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tES;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = ES_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     if (*tmp == 'I' || *tmp == 'i')
+	     {
+		tmp++;
+		if (*tmp == 'P' || *tmp == 'p')
+		{
+		   if (stackFrame)
+		      TokenValue[TokenCount] = stackFrame->tEIP;
+		   TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		   TokenType[TokenCount++] = EIP_TOKEN;
+		   p++;
+		   p++;
+		   p++;
+		   break;
+		}
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'f':
+	  case 'F':
+	     tmp = p;
+	     tmp++;
+	     if (*tmp == 'S' || *tmp == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tFS;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = FS_TOKEN;
+		p++;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case 'g':
+	  case 'G':   /* GS */
+	     p++;
+	     if (*p == 'S' || *p == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tGS;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = GS_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case 's':
+	  case 'S':
+	     p++;
+	     if (*p == 'S' || *p == 's')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSS;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = SS_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'F' || *p == 'f')
+	     {
+		if (stackFrame)
+		   TokenValue[TokenCount] = stackFrame->tSystemFlags & SF_FLAG;
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = SF_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case '[':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = DREF_OPEN_TOKEN;
+	     p++;
+	     if (*p == 'D' || *p == 'd')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = DWORD_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'W' || *p == 'w')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = WORD_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'B' || *p == 'b')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = BYTE_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case '=':
+	     p++;
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = ASSIGNMENT_TOKEN;
+	     break;
+
+	  case '<':
+	     p++;
+	     if (*p == '<')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = LEFT_SHIFT_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = LESS_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = LESS_TOKEN;
+	     break;
+
+	  case '>':
+	     p++;
+	     if (*p == '>')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = RIGHT_SHIFT_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = GREATER_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = GREATER_TOKEN;
+	     break;
+
+	  case '|':
+	     p++;
+	     if (*p == '|')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = LOGICAL_OR_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = OR_TOKEN;
+	     break;
+
+	  case '&':
+	     p++;
+	     if (*p == '&')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = LOGICAL_AND_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = AND_TOKEN;
+	     break;
+
+	  default: /* if we get a default, drop the character on the floor */
+	     p++;
+	     break;
+
+	 }
+       }
+       else
+       {
+	 switch (*p)
+	 {
+	  case '\0':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = NULL_TOKEN;
+	     return (p);
+
+	  case ']':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = DREF_CLOSE_TOKEN;
+	     p++;
+	     break;
+
+	  case '(':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = BB_TOKEN;
+	     p++;
+	     break;
+
+	  case ')':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = EB_TOKEN;
+	     p++;
+	     break;
+
+	  case '+':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = PLUS_TOKEN;
+	     p++;
+	     break;
+
+	  case '-':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = MINUS_TOKEN;
+	     p++;
+	     break;
+
+	  case '*':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = MULTIPLY_TOKEN;
+	     p++;
+	     break;
+
+	  case '/':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = DIVIDE_TOKEN;
+	     p++;
+	     break;
+
+	  case '%':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = MOD_TOKEN;
+	     p++;
+	     break;
+
+	  case '~':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = NEG_TOKEN;
+	     p++;
+	     break;
+
+	  case '^':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = XOR_TOKEN;
+	     p++;
+	     break;
+
+	  case '!':
+	     p++;
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = NOT_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = NOT_TOKEN;
+	     break;
+
+	  case ' ':   /* drop spaces on the floor */
+	     p++;
+	     break;
+
+	  /*
+	   *  These cases require special handling
+	   */
+
+	  case 'x':
+	  case 'X':
+	  case '0':
+	  case '1':
+	  case '2':
+	  case '3':
+	  case '4':
+	  case '5':
+	  case '6':
+	  case '7':
+	  case '8':
+	  case '9':
+	  case 'a':
+	  case 'A':
+	  case 'b':
+	  case 'B':
+	  case 'c':
+	  case 'C':
+	  case 'd':
+	  case 'D':
+	  case 'e':
+	  case 'E':
+	  case 'f':
+	  case 'F':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenValue[TokenCount] = GetNumber(p, &p, &delta, &retCode, mode);
+	     ((retCode) ? (TokenType[TokenCount++] = INVALID_NUMBER_TOKEN)
+	                : (TokenType[TokenCount++] = NUMBER_TOKEN));
+	     break;
+
+	  case '[':
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = DREF_OPEN_TOKEN;
+	     p++;
+	     if (*p == 'D' || *p == 'd')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = DWORD_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'W' || *p == 'w')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = WORD_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == 'B' || *p == 'b')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = BYTE_TOKEN;
+		p++;
+		break;
+	     }
+	     break;
+
+	  case '=':
+	     p++;
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = ASSIGNMENT_TOKEN;
+	     break;
+
+	  case '<':
+	     p++;
+	     if (*p == '<')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = LEFT_SHIFT_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = LESS_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = LESS_TOKEN;
+	     break;
+
+	  case '>':
+	     p++;
+	     if (*p == '>')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = RIGHT_SHIFT_TOKEN;
+		p++;
+		break;
+	     }
+	     if (*p == '=')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = GREATER_EQUAL_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = GREATER_TOKEN;
+	     break;
+
+	  case '|':
+	     p++;
+	     if (*p == '|')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = LOGICAL_OR_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = OR_TOKEN;
+	     break;
+
+	  case '&':
+	     p++;
+	     if (*p == '&')
+	     {
+		TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+		TokenType[TokenCount++] = LOGICAL_AND_TOKEN;
+		p++;
+		break;
+	     }
+	     TokenIndex[TokenCount] = (unsigned long) ((unsigned long) p - (unsigned long) op);
+	     TokenType[TokenCount++] = AND_TOKEN;
+	     break;
+
+	  default: /* if we get a default, drop the character on the floor */
+	     p++;
+	     break;
+
+	 }
+       }
+    }
+    return p;
+
+}
+
+void displayExpressionHelp(void)
+{
+
+       if (DBGPrint("Arithmetic Operators\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("+   add\n")) return;
+       if (DBGPrint("-   subtract\n")) return;
+       if (DBGPrint("*   multiply\n")) return;
+       if (DBGPrint("/   divide\n")) return;
+       if (DBGPrint("<<  bit shift left\n")) return;
+       if (DBGPrint(">>  bit shift right\n")) return;
+       if (DBGPrint("|   OR operator\n")) return;
+       if (DBGPrint("&   AND operator\n")) return;
+       if (DBGPrint("^   XOR operator\n")) return;
+       if (DBGPrint("~   NEG operator\n")) return;
+       if (DBGPrint("%%   MODULO operator\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 1:\n")) return;
+       if (DBGPrint("(0)> .e (100 + 100)\n")) return;
+       if (DBGPrint("(0)> result = 0x200 (512)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 2:\n")) return;
+       if (DBGPrint("(0)> .e (1 << 20)\n")) return;
+       if (DBGPrint("(0)> result = 0x00100000 (1,024,000)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 3:\n")) return;
+       if (DBGPrint("(0)> .e (FEF023 & 100F)\n")) return;
+       if (DBGPrint("(0)> result = 0x1003 (4099)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Boolean Operators (Conditional Breakpoint)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("==      is equal to\n")) return;
+       if (DBGPrint("!=      is not equal to\n")) return;
+       if (DBGPrint("!<expr> is not\n")) return;
+       if (DBGPrint(">       is greater than\n")) return;
+       if (DBGPrint("<       is less than\n")) return;
+       if (DBGPrint(">=      is greater than or equal to\n")) return;
+       if (DBGPrint("<=      if less than or equal to\n")) return;
+       if (DBGPrint("||      logical OR operator\n")) return;
+       if (DBGPrint("&&      logical AND operator\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("all breakpoint conditions must be enclosed in brackets () to\n")) return;
+       if (DBGPrint("evaluate correctly\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 1 (Execute Breakpoint):\n")) return;
+       if (DBGPrint("(0)> b 37000 (EAX == 20 && EBX <= 4000)\n")) return;
+       if (DBGPrint("breakpoint will activate if condition is true (returns 1)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 2 (IO Breakpoint):\n")) return;
+       if (DBGPrint("(0)> bi 3D4 (!EBX && [d ESI+40] != 2000)\n")) return;
+       if (DBGPrint("breakpoint will activate if condition is true (returns 1)\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Register Operators\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("EAX, EBX, ECX, EDX        - general registers\n")) return;
+       if (DBGPrint("ESI, EDI, EBP, ESP        - pointer registers\n")) return;
+       if (DBGPrint("EIP, <symbol>             - instruction pointer or symbol\n")) return;
+       if (DBGPrint("CS, DS, ES, FS, GS, SS    - segment registers\n")) return;
+       if (DBGPrint("CF, PF, AF, ZF, SF, IF    - flags\n")) return;
+       if (DBGPrint("DF, OF, VM, AC\n")) return;
+       if (DBGPrint("=                         - set equal to\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 1:\n")) return;
+       if (DBGPrint("(0)> EAX = 0032700 \n")) return;
+       if (DBGPrint("EAX changed to 0x0032700\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 2:\n")) return;
+       if (DBGPrint("(0)> u thread_switch\n")) return;
+       if (DBGPrint("unassembles function thread_switch\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 3 (Dump):\n")) return;
+       if (DBGPrint("(0)> d EBP+ECX\n")) return;
+       if (DBGPrint("(dumps [d EBP + ECX])\n")) return;
+       if (DBGPrint("[addr] 00 00 00 01 02 04 07 ...\n")) return;
+       if (DBGPrint("[addr] 00 34 56 00 7A 01 00 ...\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Bracket Operators\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("(       begin expression bracket\n")) return;
+       if (DBGPrint(")       end expression bracket\n")) return;
+       if (DBGPrint("[       begin pointer\n")) return;
+       if (DBGPrint("]       end pointer\n")) return;
+       if (DBGPrint("d       DWORD reference\n")) return;
+       if (DBGPrint("w       WORD reference\n")) return;
+       if (DBGPrint("b       BYTE reference\n")) return;
+       if (DBGPrint("<num>r  parse number as decimal not hex flag"
+                    " (e.g. 512r == 200)\n")) return;
+       if (DBGPrint("Note - DWORD, WORD, and BYTE dereference operators must\n"))          return;
+       if (DBGPrint("immediately follow pointer brackets (no spaces)\n"))                 return;
+       if (DBGPrint("i.e.  [d <addr/symbol>] or [w <addr/symbol>] or\n"))
+           return;
+       if (DBGPrint("[b <addr/symbol>], etc.\n"))
+           return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 1 (dump):\n")) return;
+       if (DBGPrint("(0)> d [d EAX+100r] \n")) return;
+       if (DBGPrint("[eax + 100 (dec)] 00 00 00 01 02 04 07 00\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 2 (dump):\n")) return;
+       if (DBGPrint("(0)> d [w 003400] \n")) return;
+       if (DBGPrint("[addr (hex)] 00 22 00 01 02 04 07 ...\n")) return;
+       if (DBGPrint("[addr (hex)] 00 31 A1 00 6A 05 00 ...\n")) return;
+       if (DBGPrint("\n")) return;
+       if (DBGPrint("Example 3 (break):\n")) return;
+       if (DBGPrint("(0)> b = 7A000 (EAX + ECX == 30) && ([d B8000+50]  == 0x07)\n")) return;
+       if (DBGPrint("breakpoint will activate if condition is true (returns 1)\n")) return;
+       if (DBGPrint("\n")) return;
+
+       return;
+
+}
+
+unsigned long deref(unsigned long type, unsigned long value)
+{
+   unsigned long *pd;
+   unsigned short *pw;
+   unsigned char *pb;
+
+   switch (type)
+   {
+      case ULONG_PTR:
+	 pd = (unsigned long *) value;
+#if (DEBUG_EXPRESS)
+	 DBGPrint("dref (d): [%08X]-> %08X\n", pd,
+                  mdb_getword((unsigned long)pd, 4));
+#endif
+	 return (unsigned long) mdb_getword((unsigned long)pd, 4);
+
+      case WORD_PTR:
+	 pw = (unsigned short *) value;
+#if (DEBUG_EXPRESS)
+	 DBGPrint("dref (w): [%08X]-> %04X\n", pw,
+                  mdb_getword((unsigned long)pw, 2));
+#endif
+	 return (unsigned short) mdb_getword((unsigned long)pw, 2);
+
+      case BYTE_PTR:
+	 pb = (unsigned char *) value;
+#if (DEBUG_EXPRESS)
+	 DBGPrint("dref (b): [%08X]-> %02X\n", pb,
+                  mdb_getword((unsigned long)pb, 1));
+#endif
+	 return (unsigned char) mdb_getword((unsigned long)pb, 1);
+
+      default:
+#if (DEBUG_EXPRESS)
+	 DBGPrint("dref (?): [0]-> 0\n");
+#endif
+	 return 0;
+   }
+
+}
+
+unsigned long ExpressPush(unsigned long i)
+{
+     if (sp > bos)
+     {
+#if (DEBUG_EXPRESS)
+	DBGPrint("push : <err>\n");
+#endif
+	return 0;
+     }
+     *sp = i;
+#if (DEBUG_EXPRESS)
+     DBGPrint("push : %08X (%d)\n", *sp, *sp);
+#endif
+     sp++;
+     return 1;
+}
+
+unsigned long ExpressPop(void)
+{
+    sp--;
+    if (sp < tos)
+    {
+       sp++;
+#if (DEBUG_EXPRESS)
+       DBGPrint("pop  : <err>\n");
+#endif
+       return 0;
+    }
+#if (DEBUG_EXPRESS)
+    DBGPrint("pop  : %08X (%d)\n", *sp, *sp);
+#endif
+    return *sp;
+
+}
+
+unsigned long ContextPush(unsigned long i)
+{
+     if (c_sp > c_bos)
+     {
+#if (DEBUG_EXPRESS)
+	DBGPrint("cpush: <err>\n");
+#endif
+	return 0;
+     }
+     *c_sp = i;
+#if (DEBUG_EXPRESS)
+     DBGPrint("cpush: %08X (%d)\n", *c_sp, *c_sp);
+#endif
+     c_sp++;
+     return 1;
+}
+
+unsigned long ContextPop(void)
+{
+    c_sp--;
+    if (c_sp < c_tos)
+    {
+       c_sp++;
+#if (DEBUG_EXPRESS)
+       DBGPrint("cpop : <err>\n");
+#endif
+       return 0;
+    }
+#if (DEBUG_EXPRESS)
+    DBGPrint("cpop : %08X (%d)\n", *c_sp, *c_sp);
+#endif
+    return *c_sp;
+
+}
+
+unsigned long BooleanPush(unsigned long i)
+{
+     if (b_sp > b_bos)
+     {
+#if (DEBUG_BOOL_STACK)
+	DBGPrint("bpush: <err>\n");
+#endif
+	return 0;
+     }
+     *b_sp = i;
+#if (DEBUG_BOOL_STACK)
+     DBGPrint("bpush: %08X (%d)\n", *b_sp, *b_sp);
+#endif
+     b_sp++;
+     return 1;
+}
+
+unsigned long BooleanPop(void)
+{
+    b_sp--;
+    if (b_sp < b_tos)
+    {
+       b_sp++;
+#if (DEBUG_BOOL_STACK)
+       DBGPrint("bpop : <err>\n");
+#endif
+       return 0;
+    }
+#if (DEBUG_BOOL_STACK)
+    DBGPrint("bpop : %08X (%d)\n", *b_sp, *b_sp);
+#endif
+    return *b_sp;
+
+}
+
+unsigned long LogicalPush(unsigned long i)
+{
+     if (l_sp > l_bos)
+     {
+#if (DEBUG_LOGICAL_STACK)
+	DBGPrint("lpush: <err>\n");
+#endif
+	return 0;
+     }
+     *l_sp = i;
+#if (DEBUG_LOGICAL_STACK)
+     DBGPrint("lpush: %08X (%d)\n", *l_sp, *l_sp);
+#endif
+     l_sp++;
+     return 1;
+}
+
+unsigned long LogicalPop(void)
+{
+    l_sp--;
+    if (l_sp < l_tos)
+    {
+       l_sp++;
+#if (DEBUG_LOGICAL_STACK)
+       DBGPrint("lpop : <err>\n");
+#endif
+       return 0;
+    }
+#if (DEBUG_LOGICAL_STACK)
+    DBGPrint("lpop : %08X (%d)\n", *l_sp, *l_sp);
+#endif
+    return *l_sp;
+
+}
+
+void initNumericStacks(void)
+{
+
+    sp = numStack;
+    tos = sp;
+    bos = sp + NUM_STACK_SIZE - 1;
+
+    c_sp = contextStack;
+    c_tos = c_sp;
+    c_bos = c_sp + CONTEXT_STACK_SIZE - 1;
+
+    b_sp = booleanStack;
+    b_tos = b_sp;
+    b_bos = b_sp + BOOL_STACK_SIZE - 1;
+
+    l_sp = logicalStack;
+    l_tos = l_sp;
+    l_bos = l_sp + LOGICAL_STACK_SIZE - 1;
+
+}
+
+unsigned long ProcessOperator(unsigned long oper)
+{
+    unsigned long a, b;
+
+    b = ExpressPop();
+    a = ExpressPop();
+    switch(oper)
+    {
+       case NEG_TOKEN:
+	  break;
+
+       case LEFT_SHIFT_TOKEN:
+	  ExpressPush(a << (b % PROCESSOR_32));  /* mod (b) to base 32 */
+	  break;
+
+       case RIGHT_SHIFT_TOKEN:
+	  ExpressPush(a >> (b % PROCESSOR_32));  /* mob (b) to base 32 */
+	  break;
+
+       case PLUS_TOKEN:
+	  ExpressPush(a + b);
+	  break;
+
+       case XOR_TOKEN:
+	  ExpressPush(a ^ b);
+	  break;
+
+       case AND_TOKEN:
+	  ExpressPush(a & b);
+	  break;
+
+       case MOD_TOKEN:
+	  if (b) /* if modulo by zero, drop value on the floor */
+	     ExpressPush(a % b);
+	  else
+	     ExpressPush(0);
+	  break;
+
+       case OR_TOKEN:
+	  ExpressPush(a | b);
+	  break;
+
+       case MINUS_TOKEN:
+	  ExpressPush(a - b);
+	  break;
+
+       case MULTIPLY_TOKEN:
+	  ExpressPush(a * b);
+	  break;
+
+       case DIVIDE_TOKEN:
+	  if (b) /* if divide by zero, drop value on the floor */
+	     ExpressPush(a / b);
+	  else
+	     ExpressPush(0);
+	  break;
+
+    }
+    return 0;
+
+}
+
+unsigned long ProcessBoolean(unsigned long oper)
+{
+
+    unsigned long a, b;
+
+    b = ExpressPop();
+    a = ExpressPop();
+    switch(oper)
+    {
+       case NOT_TOKEN:
+	  ExpressPush(a == b); /* we pushed an imaginary zero on the stack */
+	  break;             /* this operation returns the boolean for (!x) */
+
+       case GREATER_TOKEN:
+	  ExpressPush(a > b);
+	  break;
+
+       case LESS_TOKEN:
+	  ExpressPush(a < b);
+	  break;
+
+       case GREATER_EQUAL_TOKEN:
+	  ExpressPush(a >= b);
+	  break;
+
+       case LESS_EQUAL_TOKEN:
+	  ExpressPush(a <= b);
+	  break;
+
+       case EQUAL_TOKEN:
+	  ExpressPush(a == b);
+	  break;
+
+       case NOT_EQUAL_TOKEN:
+	  ExpressPush(a != b);
+	  break;
+    }
+    return 0;
+
+}
+
+unsigned long ProcessLogical(unsigned long oper)
+{
+
+    unsigned long a, b;
+
+    b = ExpressPop();
+    a = ExpressPop();
+    switch(oper)
+    {
+       case LOGICAL_AND_TOKEN:
+	  ExpressPush(a && b);
+	  break;
+
+       case LOGICAL_OR_TOKEN:
+	  ExpressPush(a || b);
+	  break;
+    }
+    return 0;
+
+}
+
+unsigned long ParseLogical(unsigned long logicalCount)
+{
+
+    register int i, r;
+    unsigned long a;
+    unsigned long c = 0, lastClass = 0, oper = 0;
+
+    for (i = 0; i < logicalCount; i++)
+       ExpressPush(LogicalPop());
+
+    for (i = 0, r = 0; i < (logicalCount / 2); i++)
+    {
+       a = ExpressPop();
+       TokenType[r] = NUMBER_TOKEN;
+       TokenValue[r++] = a;
+       a = ExpressPop();
+       TokenType[r] = a;  /* get the operator type */
+       TokenValue[r++] = 0;
+    }
+
+    initNumericStacks();
+
+#if (DEBUG_LOGICAL)
+     DBGPrint("\n");
+#endif
+    for (i = 0; i < logicalCount; i++)
+    {
+#if DEBUG_LOGICAL
+       DBGPrint("token: %02X  value: %08X  type: %s\n", TokenType[i],
+	      TokenValue[i], parserDescription[TokenType[i]]);
+#endif
+       switch (TokenType[i])
+       {
+	  case LOGICAL_AND_TOKEN:
+	  case LOGICAL_OR_TOKEN:
+	     if (lastClass != CLASS_BOOLEAN)
+	     {
+		lastClass = CLASS_BOOLEAN;
+		oper = TokenType[i];
+	     }
+	     continue;
+
+	  case NUMBER_TOKEN:
+	     if (lastClass == CLASS_DATA)
+	     {
+		c = ExpressPop();
+		return c;
+	     }
+	     lastClass = CLASS_DATA;
+	     c = TokenValue[i];
+	     ExpressPush(c);
+	     if (oper)
+		oper = ProcessLogical(oper);
+	     continue;
+
+	  case NULL_TOKEN:
+	     c = ExpressPop();
+	     return c;
+
+	  default:
+	     continue;
+       }
+    }
+    return c;
+
+}
+
+unsigned long ParseBoolean(unsigned long booleanCount)
+{
+
+    register int i, r;
+    unsigned long a, oper = 0;
+    unsigned long c = 0, lastClass = 0, logicalCount = 0;
+
+    for (i = 0; i < booleanCount; i++)
+       ExpressPush(BooleanPop());
+
+    for (i = 0, r = 0; i < (booleanCount / 2); i++)
+    {
+       a = ExpressPop();
+       TokenType[r] = NUMBER_TOKEN;
+       TokenValue[r++] = a;
+       a = ExpressPop();
+       TokenType[r] = a;  /* get the operator type */
+       TokenValue[r++] = 0;
+    }
+
+    initNumericStacks();
+
+#if (DEBUG_BOOL)
+     DBGPrint("\n");
+#endif
+    for (i = 0; i < booleanCount; i++)
+    {
+#if DEBUG_BOOL
+       DBGPrint("token: %02X  value: %08X  type: %s\n", TokenType[i],
+	      TokenValue[i], parserDescription[TokenType[i]]);
+#endif
+       switch (TokenType[i])
+       {
+	  /* partition operators */
+	  case LOGICAL_AND_TOKEN:
+	  case LOGICAL_OR_TOKEN:
+	     c = ExpressPop();
+	     LogicalPush(c);
+	     logicalCount++;
+	     LogicalPush(TokenType[i]);
+	     logicalCount++;
+	     ExpressPush(c);
+	     oper = 0;
+	     lastClass = 0;
+	     continue;
+
+	  /* boolean operators */
+	  case NOT_TOKEN:
+	     if (lastClass != CLASS_BOOLEAN)
+	     {
+		ExpressPush(0);
+		lastClass = CLASS_BOOLEAN;
+		oper = TokenType[i];
+	     }
+	     continue;
+
+	  case GREATER_TOKEN:
+	  case LESS_TOKEN:
+	  case GREATER_EQUAL_TOKEN:
+	  case LESS_EQUAL_TOKEN:
+	  case EQUAL_TOKEN:
+	  case NOT_EQUAL_TOKEN:
+	     if (lastClass != CLASS_BOOLEAN)
+	     {
+		lastClass = CLASS_BOOLEAN;
+		oper = TokenType[i];
+	     }
+	     continue;
+
+	  case NUMBER_TOKEN:
+	     if (lastClass == CLASS_DATA)
+	     {
+		c = ExpressPop();
+		if (logicalCount)
+		{
+		   LogicalPush(c);
+		   logicalCount++;
+		   LogicalPush(0); /* push null token */
+		   logicalCount++;
+		   c = ParseLogical(logicalCount);
+		   return c;
+		}
+		return c;
+	     }
+	     lastClass = CLASS_DATA;
+	     c = TokenValue[i];
+	     ExpressPush(c);
+	     if (oper)
+		oper = ProcessBoolean(oper);
+	     continue;
+
+	  case NULL_TOKEN:
+	     c = ExpressPop();
+	     if (logicalCount)
+	     {
+		LogicalPush(c);
+		logicalCount++;
+		LogicalPush(0); /* push null token */
+		logicalCount++;
+		c = ParseLogical(logicalCount);
+		return c;
+	     }
+	     return c;
+
+	  default:
+	     continue;
+       }
+    }
+    return c;
+
+}
+
+unsigned long Evaluate(StackFrame *stackFrame, unsigned char **p, unsigned long *type, unsigned long mode)
+{
+
+     register int i;
+     unsigned long oper = 0, dref = 0, bracket = 0;
+     unsigned long dref_type = 0, lastClass = 0, lastToken = 0;
+     unsigned long neg_flag = 0, negative_flag = 0, c;
+     unsigned long booleanCount = 0;
+
+#ifdef MDB_ATOMIC
+     spin_lock_irqsave(&expressLock, flags);
+#endif
+
+     if (type)
+	*type = INVALID_EXPRESSION;
+#if (DEBUG_BOOL)
+     DBGPrint("\n");
+#endif
+#if (DEBUG_EXPRESS)
+     DBGPrint("\np: %08X  %s\n", *p, *p);
+#endif
+     parseTokens(stackFrame, *p, mode);
+     if (TokenCount)
+     {
+	initNumericStacks();
+	for (i = 0; i < TokenCount; i++)
+	{
+#if (DEBUG_EXPRESS)
+	   DBGPrint("token: %s  lastClass: %d\n", parserDescription[TokenType[i]], lastClass);
+#endif
+	   switch (TokenType[i])
+	   {
+	      case INVALID_NUMBER_TOKEN:
+                 goto evaluate_error_exit;
+
+	      case NOT_TOKEN:
+		 if (lastClass != CLASS_DATA)
+		 {
+		    if (oper)
+		       oper = ProcessOperator(oper);
+		    c = ExpressPop();
+		    BooleanPush(c);
+		    booleanCount++;
+		    BooleanPush(TokenType[i]);
+		    booleanCount++;
+		    dref_type = 0;
+		    lastClass = 0;
+		    neg_flag  = 0;
+		    negative_flag = 0;
+		 }
+		 lastToken = NOT_TOKEN;
+		 continue;
+
+	      /* boolean operators */
+	      case GREATER_TOKEN:
+	      case LESS_TOKEN:
+	      case GREATER_EQUAL_TOKEN:
+	      case LESS_EQUAL_TOKEN:
+	      case LOGICAL_AND_TOKEN:
+	      case LOGICAL_OR_TOKEN:
+	      case EQUAL_TOKEN:
+	      case NOT_EQUAL_TOKEN:
+		 if (oper)
+		    oper = ProcessOperator(oper);
+		 c = ExpressPop();
+		 BooleanPush(c);
+		 booleanCount++;
+		 BooleanPush(TokenType[i]);
+		 booleanCount++;
+		 dref_type = 0;
+		 lastClass = 0;
+		 neg_flag  = 0;
+		 negative_flag = 0;
+		 lastToken = 0;
+		 continue;
+
+	      /* partition operators */
+	      case DWORD_TOKEN:
+		 if (dref)
+		    dref_type = ULONG_PTR;
+		 lastToken = 0;
+		 continue;
+
+	      case WORD_TOKEN:
+		 if (dref)
+		    dref_type = WORD_PTR;
+		 lastToken = 0;
+		 continue;
+
+	      case BYTE_TOKEN:
+		 if (dref)
+		    dref_type = BYTE_PTR;
+		 lastToken = 0;
+		 continue;
+
+	      case DREF_OPEN_TOKEN:   /* push state and nest for de-reference */
+		 if (lastClass == CLASS_DATA)
+		 {
+		    *p = (unsigned char *)((unsigned long)*p + (unsigned long)TokenIndex[i]);
+		    if (type)
+		    {
+		       if (booleanCount)
+			  *type = BOOLEAN_EXPRESSION;
+		       else
+			  *type = NUMERIC_EXPRESSION;
+		    }
+		    c = ExpressPop();
+		    if (booleanCount)
+		    {
+		       BooleanPush(c);
+		       booleanCount++;
+		       BooleanPush(0); /* last operator is the null token */
+		       booleanCount++;
+		       c = ParseBoolean(booleanCount);
+#if (DEBUG_BOOL)
+		       DBGPrint("be_N : (%d) = (%s)\n", c, c ? "TRUE" : "FALSE");
+#endif
+#ifdef MDB_ATOMIC
+		       spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		       return c;
+		    }
+#if (DEBUG_EXPRESS)
+		    DBGPrint("ee_N : %08X (%d)\n", c, c);
+#endif
+#ifdef MDB_ATOMIC
+		    spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		    return c;
+		 }
+		 dref++;
+		 ContextPush(dref_type);
+		 ContextPush(oper);
+		 ContextPush(lastClass);
+		 ContextPush(neg_flag);
+		 ContextPush(negative_flag);
+		 dref_type = 0;
+		 oper      = 0;
+		 lastClass = 0;
+		 neg_flag  = 0;
+		 negative_flag = 0;
+		 lastToken = 0;
+		 continue;
+
+	      case DREF_CLOSE_TOKEN: /* pop state,restore,and complete oper */
+		 if (!dref)
+		    continue;
+		 c = deref(dref_type, ExpressPop());
+		 ExpressPush(c);
+		 negative_flag  = ContextPop();
+		 neg_flag  = ContextPop();
+		 ContextPop();
+		 oper      = ContextPop();
+		 dref_type = ContextPop();
+		 if (dref)
+		    dref--;
+		 lastClass = CLASS_DATA;
+
+		 c = ExpressPop();
+		 if (negative_flag)
+		    c = 0 - c;
+		 if (neg_flag)
+		    c = ~c;
+		 neg_flag = 0;
+		 negative_flag = 0;
+		 ExpressPush(c);
+
+		 if (oper)
+		    oper = ProcessOperator(oper);
+		 lastToken = 0;
+		 continue;
+
+	      case BB_TOKEN:
+		 if (lastClass == CLASS_DATA)
+		 {
+		    *p = (unsigned char *)((unsigned long)*p + (unsigned long)TokenIndex[i]);
+		    if (type)
+		    {
+		       if (booleanCount)
+			  *type = BOOLEAN_EXPRESSION;
+		       else
+			  *type = NUMERIC_EXPRESSION;
+		    }
+		    c = ExpressPop();
+		    if (booleanCount)
+		    {
+		       BooleanPush(c);
+		       booleanCount++;
+		       BooleanPush(0); /* last operator is the null token */
+		       booleanCount++;
+		       c = ParseBoolean(booleanCount);
+#if (DEBUG_BOOL)
+		       DBGPrint("be_N : (%d) = (%s)\n", c, c ? "TRUE" : "FALSE");
+#endif
+#ifdef MDB_ATOMIC
+		       spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		       return c;
+		    }
+#if (DEBUG_EXPRESS)
+		    DBGPrint("ee_N : %08X (%d)\n", c, c);
+#endif
+#ifdef MDB_ATOMIC
+		    spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		    return c;
+		 }
+		 bracket++;
+		 ContextPush(oper);
+		 ContextPush(lastClass);
+		 ContextPush(neg_flag);
+		 ContextPush(negative_flag);
+		 oper      = 0;
+		 lastClass = 0;
+		 neg_flag  = 0;
+		 negative_flag = 0;
+		 lastToken = 0;
+		 continue;
+
+	      case EB_TOKEN:
+		 if (!bracket)
+		    continue;
+		 negative_flag  = ContextPop();
+		 neg_flag  = ContextPop();
+		 ContextPop();
+		 oper      = ContextPop();
+		 if (bracket)
+		    bracket--;
+		 lastClass = CLASS_DATA;
+		 c = ExpressPop();
+		 if (negative_flag)
+		    c = 0 - c;
+		 if (neg_flag)
+		    c = ~c;
+		 neg_flag = 0;
+		 negative_flag = 0;
+		 ExpressPush(c);
+		 if (oper)
+		    oper = ProcessOperator(oper);
+		 lastToken = 0;
+		 continue;
+
+	      /* arithmetic operators */
+	      case NEG_TOKEN:
+		 neg_flag = 1;
+		 lastToken = 0;
+		 continue;
+
+	      case MINUS_TOKEN:
+		 if (lastClass == CLASS_ARITHMETIC)
+		 {
+		    lastToken = MINUS_TOKEN;
+		    negative_flag = 1;
+		    continue;
+		 }
+		 if (lastClass != CLASS_ARITHMETIC)
+		 {
+		    lastClass = CLASS_ARITHMETIC;
+		    oper = TokenType[i];
+		 }
+		 lastToken = 0;
+		 continue;
+
+	      case PLUS_TOKEN:
+	      case LEFT_SHIFT_TOKEN:
+	      case RIGHT_SHIFT_TOKEN:
+	      case XOR_TOKEN:
+	      case AND_TOKEN:
+	      case MOD_TOKEN:
+	      case OR_TOKEN:
+	      case MULTIPLY_TOKEN:
+	      case DIVIDE_TOKEN:
+		 if (lastClass != CLASS_ARITHMETIC)
+		 {
+		    lastClass = CLASS_ARITHMETIC;
+		    oper = TokenType[i];
+		 }
+		 lastToken = 0;
+		 continue;
+
+	      /* data operators */
+	      case CF_TOKEN:
+	      case PF_TOKEN:
+	      case AF_TOKEN:
+	      case ZF_TOKEN:
+	      case SF_TOKEN:
+	      case IF_TOKEN:
+	      case DF_TOKEN:
+	      case OF_TOKEN:
+	      case VM_TOKEN:
+	      case AC_TOKEN:
+	      case EIP_TOKEN:
+	      case FLAGS_TOKEN:
+	      case EAX_TOKEN:
+	      case EBX_TOKEN:
+	      case ECX_TOKEN:
+	      case EDX_TOKEN:
+	      case ESI_TOKEN:
+	      case EDI_TOKEN:
+	      case EBP_TOKEN:
+	      case ESP_TOKEN:
+	      case CS_TOKEN:
+	      case DS_TOKEN:
+	      case ES_TOKEN:
+	      case FS_TOKEN:
+	      case GS_TOKEN:
+	      case SS_TOKEN:
+	      case NUMBER_TOKEN:
+		 if (lastClass == CLASS_DATA)
+		 {
+		    *p = (unsigned char *)((unsigned long)*p + (unsigned long)TokenIndex[i]);
+		    if (type)
+		    {
+		       if (booleanCount)
+			  *type = BOOLEAN_EXPRESSION;
+		       else
+			  *type = NUMERIC_EXPRESSION;
+		    }
+		    c = ExpressPop();
+		    if (booleanCount)
+		    {
+		       BooleanPush(c);
+		       booleanCount++;
+		       BooleanPush(0); /* last operator is the null token */
+		       booleanCount++;
+		       c = ParseBoolean(booleanCount);
+#if (DEBUG_BOOL)
+		       DBGPrint("be_N : (%d) = (%s)\n", c, c ? "TRUE" : "FALSE");
+#endif
+#ifdef MDB_ATOMIC
+		       spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		       return c;
+		    }
+#if (DEBUG_EXPRESS)
+		    DBGPrint("ee_N : %08X (%d)\n", c, c);
+#endif
+#ifdef MDB_ATOMIC
+		    spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		    return c;
+		 }
+		 lastClass = CLASS_DATA;
+		 c = TokenValue[i];
+		 if (negative_flag)
+		    c = 0 - c;
+		 if (neg_flag)
+		    c = ~TokenValue[i];
+		 neg_flag = 0;
+		 negative_flag = 0;
+		 ExpressPush(c);
+		 if (oper)
+		    oper = ProcessOperator(oper);
+		 lastToken = 0;
+		 continue;
+
+	      case NULL_TOKEN:
+		 *p = (unsigned char *)((unsigned long)*p + (unsigned long)TokenIndex[i]);
+		 if (TokenCount > 1 && type)
+		 {
+		    if (booleanCount)
+		       *type = BOOLEAN_EXPRESSION;
+		    else
+		       *type = NUMERIC_EXPRESSION;
+		 }
+		 c = ExpressPop();
+		 if (booleanCount)
+		 {
+		    BooleanPush(c);
+		    booleanCount++;
+		    BooleanPush(0); /* last operator is the null token */
+		    booleanCount++;
+		    c = ParseBoolean(booleanCount);
+#if (DEBUG_BOOL)
+		    DBGPrint("be_N : (%d) = (%s)\n", c, c ? "TRUE" : "FALSE");
+#endif
+#ifdef MDB_ATOMIC
+		    spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		    return c;
+		 }
+#if (DEBUG_EXPRESS)
+		 DBGPrint("ee_N : %08X (%d)\n", c, c);
+#endif
+#ifdef MDB_ATOMIC
+		 spin_unlock_irqrestore(&expressLock, flags);
+#endif
+		 return c;
+
+	      /* assignment operators */
+	      case ASSIGNMENT_TOKEN:
+		 lastToken = 0;
+		 continue;
+
+	      default:
+		 lastToken = 0;
+		 continue;
+	   }
+	}
+     }
+
+evaluate_error_exit:
+     if (type)
+	*type = INVALID_EXPRESSION;
+
+     if (lastToken) {};
+
+#ifdef MDB_ATOMIC
+     spin_unlock_irqrestore(&expressLock, flags);
+#endif
+     return 0;
+
+}
+
+unsigned long EvaluateNumericExpression(StackFrame *stackFrame, unsigned char **p, unsigned long *type)
+{
+     register unsigned long c;
+     c = Evaluate(stackFrame, p, type, 1);
+     return c;
+}
+
+unsigned long EvaluateExpression(StackFrame *stackFrame, unsigned char **p, unsigned long *type)
+{
+     register unsigned long c;
+     c = Evaluate(stackFrame, p, type, 0);
+     return c;
+}
+
+void EvaluateCommandExpression(StackFrame *stackFrame, unsigned char *p)
+{
+     unsigned char *expr;
+     unsigned long type;
+     unsigned long c;
+
+#if DEBUG_EXPRESS
+     DBGPrint("expr: [%s]\n", p);
+#endif
+     expr = p;
+     c = EvaluateExpression(stackFrame, &p, &type);
+     if (type)
+     {
+	DBGPrint("expr: %s = 0x%08X (%dr) (%s) bool(%i) = %s\n",
+		    expr, (unsigned)c, (int)c, exprDescription[type & 3],
+		    (c) ? 1 : 0, (c) ? "TRUE" : "FALSE");
+     }
+     else
+     {
+        DBGPrint("expression parameters invalid\n");
+	DBGPrint("expr: %s = 0x%08X (%dr) (results invalid) (%s)"
+                 " bool(%i) = %s\n",
+		 expr, (unsigned)c, (int)c, exprDescription[type & 3],
+		 (c) ? 1 : 0, (c) ? "TRUE" : "FALSE");
+     }
+     return;
+
+}
diff -Naur linux-2.6.27/debug/mdb/mdb-main.c linux-2.6.27-mdb/debug/mdb/mdb-main.c
--- linux-2.6.27/debug/mdb/mdb-main.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-main.c	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,694 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/uaccess.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <linux/io.h>
+#include <linux/kdebug.h>
+#include <linux/notifier.h>
+#include <linux/sysrq.h>
+#include <linux/input.h>
+
+#ifdef CONFIG_SMP
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb.h"
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+extern void MDBInitializeDebugger(void);
+extern void MDBClearDebuggerState(void);
+
+unsigned long TotalSystemMemory;
+unsigned long HistoryPointer;
+unsigned char HistoryBuffer[16][256];
+                              /* remember non-repeating commands */
+unsigned char delim_table[256];
+unsigned char workBuffer[256];
+unsigned char verbBuffer[100];
+void set_delimiter(unsigned char c) {  delim_table[c & 0xFF] = 1;  }
+StackFrame CurrentStackFrame[MAX_PROCESSORS];
+atomic_t inmdb = { 0 };
+unsigned char *mdb_oops;
+unsigned char *last_mdb_oops;
+
+void SaveLastCommandInfo(unsigned long processor)
+{
+    register int i;
+
+    repeatCommand = 0;
+    lastCommand = toupper(debugCommand[0]);
+    lastDisplayLength = displayLength;
+    atomic_set(&focusActive, 0);
+    atomic_set(&traceProcessors[processor], 0);
+
+    for (i = 0; (i < 80) && (debugCommand[i]); i++)
+    {
+       if ((debugCommand[i] == '\n') || (debugCommand[i] == '\r'))
+          lastDebugCommand[i] = '\0';
+       else
+          lastDebugCommand[i] = debugCommand[i];
+    }
+    lastDebugCommand[i] = '\0';
+
+    return;
+}
+
+int mdb(int reason, int error, void *frame)
+{
+    register unsigned long retCode = 0, processor = get_processor_id();
+    extern void ReadStackFrame(void *, StackFrame *, unsigned long);
+    extern void WriteStackFrame(void *, StackFrame *, unsigned long);
+    unsigned long state;
+#ifdef CONFIG_MDB_CONSOLE_REDIRECTION
+    extern int kmsg_redirect;
+    int kmsg_redirect_save;
+#endif
+
+    retCode = AlternateDebuggerRoutine(reason, error, frame);
+    if (retCode)
+       return retCode;
+
+    preempt_disable();
+#ifdef CONFIG_MDB_CONSOLE_REDIRECTION
+    kmsg_redirect_save = kmsg_redirect;
+    kmsg_redirect = 0;
+#endif
+
+    last_mdb_oops = NULL;
+    if (mdb_oops)
+    {
+       last_mdb_oops = mdb_oops;
+       mdb_oops = NULL;
+    }
+    atomic_inc(&inmdb);
+    state = save_flags();
+    memset(&CurrentStackFrame[processor], 0, sizeof(StackFrame));
+    ReadStackFrame(frame, &CurrentStackFrame[processor], processor);
+    CurrentStackFrame[processor].tReserved[2] = (unsigned long)frame;
+    retCode = debugger_entry(reason, &CurrentStackFrame[processor],
+                             processor);
+    WriteStackFrame(frame, &CurrentStackFrame[processor], processor);
+
+    restore_flags(state);
+    atomic_dec(&inmdb);
+
+#ifdef CONFIG_MDB_CONSOLE_REDIRECTION
+    kmsg_redirect = kmsg_redirect_save;
+#endif
+    preempt_enable();
+
+    return retCode;
+}
+
+static inline void out_chars(int c, unsigned char ch)
+{
+    register int i;
+
+    for (i = 0; i < c; i++)
+       DBGPrint("%c", ch);
+    return;
+}
+
+static inline void out_copy_chars_limit(int c, unsigned char ch,
+                                        unsigned char *s, int limit)
+{
+    register int i;
+
+    for (i = 0; (i < c) && (i < limit); i++)
+       s[i] = ch;
+    s[i] = '\0';
+    DBGPrint("%s", s);
+    return;
+}
+
+static inline void out_buffer_chars_limit(unsigned char *s, int limit)
+{
+    register int i;
+
+    for (i = 0; (i < strlen(s)) && (i < limit); i++)
+       DBGPrint("%c", s[i]);
+    return;
+}
+
+static inline void out_buffer_chars_limit_index(unsigned char *s, int limit,
+                                                int index)
+{
+    register int i;
+
+    for (i = 0; (i < limit) && (s[i]); i++)
+       DBGPrint("%c", s[index + i]);
+    return;
+}
+
+static inline void out_string(unsigned char *s)
+{
+    DBGPrint("%s", s);
+    return;
+}
+
+static inline void out_char(unsigned char ch)
+{
+    DBGPrint("%c", ch);
+    return;
+}
+
+unsigned long ScreenInputFromKeyboard(unsigned char *buf,
+                                      unsigned long buf_index,
+                                      unsigned long max_index)
+{
+    register unsigned long key;
+    register unsigned char *p;
+    register int i, r, temp;
+    register unsigned long orig_index, HistoryIndex;
+    extern unsigned long IsAccelerator(unsigned long);
+
+    if (buf_index > max_index)
+       return 0;
+
+    if (!max_index)
+       return 0;
+
+    orig_index = buf_index;
+
+    p = (unsigned char *)((unsigned long)buf + (unsigned long)buf_index);
+    for (i = 0; i < (max_index - buf_index); i++)
+       *p++ = '\0';
+
+    HistoryIndex = HistoryPointer;
+    while (1)
+    {
+       key = mdb_getkey();
+
+       if ((IsAccelerator(key)) && (key != 13))
+	  return key;
+
+       switch (key)
+       {
+	  case 8: /* backspace */
+	     if (buf_index)
+	     {
+                register int delta;
+
+		buf_index--;
+		out_string("\b \b");
+
+                delta = strlen(buf) - buf_index;
+                out_chars(delta, ' ');
+                out_chars(delta, '\b');
+
+	        p = (unsigned char *) &buf[buf_index];
+	        temp = buf_index;
+	        p++;
+	        while ((*p) && (temp < max_index))
+		   buf[temp++] = *p++;
+	        buf[temp] = '\0';
+
+                delta = strlen(buf) - buf_index;
+                out_buffer_chars_limit_index(buf, delta, buf_index);
+                out_chars(delta, '\b');
+	     }
+	     break;
+
+	  case K_P7: /* home */
+             {
+                unsigned char *s = &workBuffer[0];
+
+                out_copy_chars_limit(buf_index, '\b', s, 255);
+	        buf_index = orig_index;
+             }
+	     break;
+
+	  case K_P1: /* end */
+             {
+                unsigned char *s = &workBuffer[0];
+
+                out_copy_chars_limit(buf_index, '\b', s, 255);
+                out_buffer_chars_limit(buf, 255);
+	        buf_index = strlen(buf);
+             }
+	     break;
+
+	  case K_P4: /* left arrow */
+	     if (buf_index)
+	     {
+		buf_index--;
+		out_string("\b");
+	     }
+	     break;
+
+	  case K_P6: /* right arrow */
+	     if (buf_index < strlen(buf))
+	     {
+                out_char(buf[buf_index]);
+		buf_index++;
+	     }
+	     break;
+
+	  case K_PDOT:
+             {
+                register int delta;
+
+                delta = strlen(buf) - buf_index;
+
+                out_chars(delta, ' ');
+                out_chars(delta, '\b');
+
+	        p = (unsigned char *) &buf[buf_index];
+	        temp = buf_index;
+	        p++;
+	        while ((*p) && (temp < max_index))
+		   buf[temp++] = *p++;
+	        buf[temp] = '\0';
+
+                delta = strlen(buf) - buf_index;
+                out_buffer_chars_limit_index(buf, delta, buf_index);
+                out_chars(delta, '\b');
+             }
+	     break;
+
+	  case 13:  /* enter */
+	     if (strncmp(HistoryBuffer[(HistoryPointer - 1) & 0xF], buf,
+                         strlen(buf)) || (strlen(buf) !=
+                         strlen(HistoryBuffer[(HistoryPointer - 1) & 0xF])))
+	     {
+		for (r = 0; r < max_index; r++)
+		{
+		   if (buf[0])
+		      HistoryBuffer[HistoryPointer & 0xF][r] = buf[r];
+		}
+		if (buf[0])
+		   HistoryPointer++;
+	     }
+	     return 13;
+
+	  case K_P8: /* up arrow */
+	     if (HistoryBuffer[(HistoryIndex - 1) & 0xF][0])
+	     {
+                unsigned char *s = &workBuffer[0];
+
+                out_copy_chars_limit(buf_index, '\b', s, 255);
+                out_copy_chars_limit(buf_index, ' ', s, 255);
+                out_copy_chars_limit(buf_index, '\b', s, 255);
+
+		HistoryIndex--;
+
+		for (r = 0; r < max_index; r++)
+		   buf[r] = HistoryBuffer[HistoryIndex & 0xF][r];
+		buf_index = strlen(buf);
+
+                out_string(buf);
+	     }
+	     break;
+
+	  case K_P2: /* down arrow */
+	     if (HistoryBuffer[HistoryIndex & 0xF][0])
+	     {
+                unsigned char *s = &workBuffer[0];
+
+                out_copy_chars_limit(buf_index, '\b', s, 255);
+                out_copy_chars_limit(buf_index, ' ', s, 255);
+                out_copy_chars_limit(buf_index, '\b', s, 255);
+
+		HistoryIndex++;
+
+		for (r = 0; r < max_index; r++)
+		   buf[r] = HistoryBuffer[HistoryIndex & 0xF][r];
+		buf_index = strlen(buf);
+
+                out_string(buf);
+	     }
+	     break;
+
+	  default:
+	     if ((key > 0x7E) || (key < ' '))  /* if above or below text */
+		break;
+	     else
+	     {
+	        if (strlen(buf) < max_index)
+		{
+                   register int delta;
+
+		   for (i=max_index; i > buf_index; i--)
+		      buf[i] = buf[i-1];
+		   buf[buf_index] = (unsigned char)key;
+		   if (buf_index < max_index)
+		      buf_index++;
+
+                   delta = strlen(buf) - buf_index;
+                   out_buffer_chars_limit_index(buf, delta, buf_index);
+                   out_chars(delta, '\b');
+		}
+             }
+	     break;
+       }
+    }
+}
+
+unsigned long debugger_command_entry(unsigned long processor,
+                                     unsigned long Exception,
+			             StackFrame *stackFrame)
+{
+    register unsigned char *verb, *pp, *vp;
+    register unsigned long count, retCode, key;
+    extern unsigned long reason_toggle;
+    extern void displayRegisters(StackFrame *, unsigned long);
+
+    if (Exception > 22)
+       Exception = 20;
+
+    lastUnasmAddress = (unsigned long) GetIP(stackFrame);
+    lastLinkAddress = lastDumpAddress =
+                      (unsigned char *) GetStackAddress(stackFrame);
+    lastDisplayLength = displayLength = 20;
+    lastCommandEntry = lastCommand;
+    nextline = 0;
+    pause_mode = 0;
+
+    if (!ssbmode)
+    {
+       if (reason_toggle && !ConsoleDisplayBreakReason(stackFrame,
+           Exception, processor, lastCommand))
+          return 0;
+       displayRegisters(stackFrame, processor);
+    }
+    nextUnasmAddress = disassemble(stackFrame, lastUnasmAddress, 1, 1);
+    ClearTempBreakpoints();
+    if (SSBUpdate(stackFrame, processor) == -1)
+       return 0;
+
+    while (1)
+    {
+       pause_mode = 1;
+       nextline = 0;
+       DBGPrint("(%i)> ", (int)processor);
+
+       SaveLastCommandInfo(processor);
+       key = ScreenInputFromKeyboard((unsigned char *)&debugCommand[0], 0, 80);
+       if (key)
+       {
+          extern unsigned long AccelRoutine(unsigned long key, void *p);
+
+          retCode = AccelRoutine(key, stackFrame);
+          switch (retCode)
+          {
+             case 0:
+                break;
+
+             case -1:
+	        return retCode;
+
+             default:
+                DBGPrint("\n");
+                continue;
+          }
+       }
+
+       if (*debugCommand)
+       {
+          count = 0;
+          pp = (unsigned char *)debugCommand;
+          vp = verb = &verbBuffer[0];
+          while (*pp && *pp == ' ' && count++ < 80)
+	     pp++;
+
+          while (*pp && *pp != ' ' && *pp != '=' && count++ < 80)
+	     *vp++ = *pp++;
+          *vp = '\0';
+
+          while (*pp && *pp == ' ' && count++ < 80)
+	     pp++;
+
+          retCode = DebuggerParserRoutine(verb, (unsigned char *)debugCommand,
+                                          stackFrame, Exception);
+          switch (retCode)
+          {
+             case -1:
+	       return retCode;
+          }
+       }
+    }
+}
+
+#if MDB_DEBUG_DEBUGGER
+unsigned char *kdebug_state[]=
+{
+    "",
+    "DIE_OOPS",
+    "DIE_INT3",
+    "DIE_DEBUG",
+    "DIE_PANIC",
+    "DIE_NMI",
+    "DIE_DIE",
+    "DIE_NMIWATCHDOG",
+    "DIE_KERNELDEBUG",
+    "DIE_TRAP",
+    "DIE_GPF",
+    "DIE_CALL",
+    "DIE_NMI_IPI",
+    "DIE_PAGE_FAULT",
+    "DIE_NMIUNKNOWN",
+};
+int kdebug_state_size = sizeof(kdebug_state) / sizeof(unsigned char *);
+#endif
+
+static int mdb_notify(struct notifier_block *nb, unsigned long reason,
+                      void *data)
+{
+    register struct die_args *args = (struct die_args *)data;
+    register int err = 0;
+#if MDB_DEBUG_DEBUGGER
+    register unsigned long p = get_processor_id();
+
+    oops_in_progress++;
+    DBGPrint("%i: notify reason:%lu %s\n",
+             (int)p, reason, kdebug_state[reason % kdebug_state_size]);
+#else
+    oops_in_progress++;
+#endif
+    if (args)
+    {
+       switch (reason)
+       {
+          case DIE_DIE:
+          case DIE_PANIC:
+          case DIE_OOPS:
+             mdb_oops = (unsigned char *)args->str;
+             if (args->regs)
+                err = mdb(SOFTWARE_EXCEPTION, args->err, args->regs);
+             else
+             {
+                struct pt_regs *regs = get_irq_regs();
+
+                if (regs)
+                {
+                   err = mdb(SOFTWARE_EXCEPTION, args->err, regs);
+                   break;
+                }
+
+                /* if there are no regs passed on DIE_PANIC, or we
+		 * cannot locate a local interrupt context, trigger an
+                 * int 3 breakpoint and get the register context since
+                 * we were apparently called from panic() outside of an
+                 * exception.
+                 */
+                oops_in_progress--;
+                mdb_breakpoint();
+                return NOTIFY_STOP;
+             }
+             break;
+
+	  case DIE_INT3:
+             err = mdb(BREAKPOINT_EXCEPTION, args->err, args->regs);
+             break;
+
+          case DIE_DEBUG:
+             err = mdb(DEBUGGER_EXCEPTION, args->err, args->regs);
+             break;
+
+          case DIE_NMI:
+          case DIE_NMIWATCHDOG:
+          case DIE_NMIUNKNOWN:
+          case DIE_NMI_IPI:
+             err = mdb(NMI_EXCEPTION, args->err, args->regs);
+             break;
+
+          case DIE_KERNELDEBUG:
+             err = mdb(KEYBOARD_ENTRY, args->err, args->regs);
+             break;
+
+          case DIE_GPF:
+             err = mdb(GENERAL_PROTECTION, args->err, args->regs);
+             break;
+
+          case DIE_PAGE_FAULT:
+             err = mdb(PAGE_FAULT_EXCEPTION, args->err, args->regs);
+             break;
+
+          default:
+             break;
+       }
+    }
+    oops_in_progress--;
+    return (err ? NOTIFY_STOP : 0);
+}
+
+static struct notifier_block mdb_notifier =
+{
+    .notifier_call = mdb_notify,
+    .priority = 0x7FFFFFFF,
+};
+
+#ifdef CONFIG_MAGIC_SYSRQ
+static void sysrq_mdb(int key, struct tty_struct *tty)
+{
+    mdb_breakpoint();
+    return;
+}
+
+static struct sysrq_key_op sysrq_op =
+{
+    .handler     = sysrq_mdb,
+    .help_msg    = "mdb(J)",
+    .action_msg  = "MDB",
+};
+#endif
+
+static int __init mdb_init_module(void)
+{
+    register int i;
+    register int ret = 0;
+
+    /* return if debugger already initialized */
+    if (debuggerInitialized)
+       return 0;
+
+    MDBInitializeDebugger();
+
+    ret = register_die_notifier(&mdb_notifier);
+    if (ret)
+    {
+       MDBClearDebuggerState();
+       return ret;
+    }
+
+#ifdef CONFIG_MAGIC_SYSRQ
+    register_sysrq_key('j', &sysrq_op);
+#endif
+
+    /* initialize delimiter lookup table */
+    for (i = 0; i < 256; i++)
+        delim_table[i] = '\0';
+
+    set_delimiter('\0');
+    set_delimiter('\n');
+    set_delimiter('\r');
+    set_delimiter('[');
+    set_delimiter(']');
+    set_delimiter('<');
+    set_delimiter('>');
+    set_delimiter('(');
+    set_delimiter(')');
+    set_delimiter('|');
+    set_delimiter('&');
+    set_delimiter('=');
+    set_delimiter('*');
+    set_delimiter('+');
+    set_delimiter('-');
+    set_delimiter('/');
+    set_delimiter('%');
+    set_delimiter('~');
+    set_delimiter('^');
+    set_delimiter('!');
+    set_delimiter(' ');
+
+    return 0;
+}
+
+static void __exit mdb_exit_module(void)
+{
+#ifdef CONFIG_MAGIC_SYSRQ
+    unregister_sysrq_key('j', &sysrq_op);
+#endif
+    unregister_die_notifier(&mdb_notifier);
+    MDBClearDebuggerState();
+    return;
+}
+
+module_init(mdb_init_module);
+module_exit(mdb_exit_module);
+
+MODULE_DESCRIPTION("Merkey's Kernel Debugger");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.27/debug/mdb/mdb-os.c linux-2.6.27-mdb/debug/mdb/mdb-os.c
--- linux-2.6.27/debug/mdb/mdb-os.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-os.c	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,1125 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/cdrom.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/uaccess.h>
+#include <linux/nmi.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/atomic.h>
+#include <asm/msr.h>
+#include <linux/io.h>
+
+#ifdef CONFIG_SMP
+#include <mach_apic.h>
+#include <mach_ipi.h>
+#endif
+
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/kallsyms.h>
+
+#include "mdb.h"
+#include "mdb-ia32.h"
+#include "mdb-list.h"
+#include "mdb-ia32-proc.h"
+#include "mdb-base.h"
+#include "mdb-proc.h"
+#include "mdb-os.h"
+#include "mdb-keyboard.h"
+
+/* module symbol workspace */
+unsigned char symbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+unsigned char modbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+unsigned char workbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+unsigned char traceBuf[MAX_SYMBOL_LEN];
+
+int valid_stack_ptr(struct thread_info *tinfo, void *p)
+{
+    return ((p > (void *)tinfo) && (p < (void *)(tinfo + THREAD_SIZE - 3)));
+}
+
+unsigned long print_context_stack(struct thread_info *tinfo,
+			  unsigned long *stack, unsigned long ebp,
+                          unsigned long *rebp)
+{
+    register unsigned char *symbol;
+    unsigned long addr, offset;
+    unsigned char *modname;
+
+#ifdef	CONFIG_FRAME_POINTER
+    while (valid_stack_ptr(tinfo, (void *)ebp))
+    {
+	addr = mdb_getword((ebp + 4), 4);
+
+        if (DBGPrint("[<%08lx>] ", addr))
+           return 1;
+
+        symbol = GetSymbolFromValueOffsetModule(addr, &offset, &modname,
+                                                traceBuf, MAX_SYMBOL_LEN);
+        if (symbol)
+        {
+           if (modname)
+           {
+              if (offset)
+              {
+                 if (DBGPrint("%s|%s+0x%X", modname, symbol, offset))
+                    return 1;
+              }
+              else
+              {
+                 if (DBGPrint("%s|%s", modname, symbol))
+                    return 1;
+              }
+           }
+           else
+           {
+              if (offset)
+              {
+                 if (DBGPrint("%s+0x%X", symbol, offset))
+                    return 1;
+              }
+              else
+              {
+                 if (DBGPrint("%s", symbol))
+                    return 1;
+              }
+           }
+        }
+        if (DBGPrint("\n"))
+           return 1;
+
+	if (ebp == mdb_getword(ebp, 4))
+	   break;
+
+	ebp = mdb_getword(ebp, 4);
+    }
+#else
+    while (valid_stack_ptr(tinfo, stack))
+    {
+       addr = mdb_getword((unsigned long)stack, 4);
+       stack++;
+
+       if (__kernel_text_address(addr))
+       {
+          if (DBGPrint("[<%08lx>] ", addr))
+             return 1;
+
+          symbol = GetSymbolFromValueOffsetModule(addr, &offset, &modname,
+                                                traceBuf, MAX_SYMBOL_LEN);
+          if (symbol)
+          {
+             if (modname)
+             {
+                if (offset)
+                {
+                   if (DBGPrint("%s|%s+0x%X", modname, symbol, offset))
+                      return 1;
+                }
+                else
+                {
+                   if (DBGPrint("%s|%s", modname, symbol))
+                      return 1;
+                }
+             }
+             else
+             {
+                if (offset)
+                {
+                   if (DBGPrint("%s+0x%X", symbol, offset))
+                      return 1;
+                }
+                else
+                {
+                   if (DBGPrint("%s", symbol))
+                      return 1;
+                }
+             }
+          }
+          if (DBGPrint("\n"))
+             return 1;
+       }
+    }
+#endif
+    if (rebp)
+       *rebp = ebp;
+
+    return 0;
+}
+
+int bt_stack(struct task_struct *task, struct pt_regs *regs,
+             unsigned long *stack)
+{
+    unsigned long ebp = 0;
+
+    if (!task)
+       task = current;
+
+    if (!stack)
+    {
+       unsigned long dummy;
+
+       stack = &dummy;
+       if (task && task != current)
+       {
+          if (mdb_verify_rw((void *)&task->thread.sp, 4))
+             return 0;
+
+          stack = (unsigned long *)
+                  mdb_getword((unsigned long)&task->thread.sp, 4);
+       }
+    }
+
+#ifdef CONFIG_FRAME_POINTER
+    if (!ebp)
+    {
+       if (task == current)
+          asm ("movl %%ebp, %0" : "=r" (ebp) : );
+       else
+       {
+          if (mdb_verify_rw((void *)task->thread.sp, 4))
+             return 0;
+
+          ebp = (unsigned long)mdb_getword(task->thread.sp, 4);
+       }
+    }
+#endif
+
+    while (1)
+    {
+       struct thread_info *context;
+
+       context = (struct thread_info *)
+                 ((unsigned long)stack & (~(THREAD_SIZE - 1)));
+
+       if (mdb_verify_rw(context, 4))
+          return 0;
+
+       if (print_context_stack(context, stack, ebp, &ebp))
+          return 1;
+
+       if (mdb_verify_rw(&context->previous_esp, 4))
+          return 0;
+
+       stack = (unsigned long *)
+               mdb_getword((unsigned long)&context->previous_esp, 4);
+       if (!stack)
+          break;
+
+       touch_nmi_watchdog();
+    }
+    return 0;
+}
+
+unsigned char *mdbprompt = "--- More (Q to Quit) ---";
+int nextline;
+int pause_mode = 1;
+spinlock_t mdb_lock = SPIN_LOCK_UNLOCKED;
+unsigned long mdb_flags;
+
+int mdb_printf(char *fmt, ...)
+{
+	char buffer[256];
+	char keystroke[16];
+	va_list	ap;
+	int linecount;
+	struct console *con;
+
+        linecount = 23;
+	va_start(ap, fmt);
+	vsprintf(buffer, fmt, ap);
+	va_end(ap);
+
+	for (con = console_drivers; con; con = con->next)
+        {
+	   if ((con->flags & CON_ENABLED) && con->write &&
+	        (cpu_online(get_processor_id()) ||
+		(con->flags & CON_ANYTIME)))
+	      con->write(con, buffer, strlen(buffer));
+	}
+
+	if (strchr(buffer, '\n') != NULL)
+	   nextline++;
+
+	if (pause_mode && (nextline == linecount))
+        {
+	   nextline = 0;
+
+	   for (con = console_drivers; con; con = con->next)
+           {
+	      if ((con->flags & CON_ENABLED) && con->write &&
+	           (cpu_online(get_processor_id()) ||
+	           (con->flags & CON_ANYTIME)))
+	         con->write(con, mdbprompt, strlen(mdbprompt));
+	   }
+
+	   keystroke[0] = (char)mdb_getkey();
+	   nextline = 1;
+	   if ((keystroke[0] == 'q') || (keystroke[0] == 'Q'))
+           {
+	      for (con = console_drivers; con; con = con->next)
+              {
+		 if ((con->flags & CON_ENABLED) && con->write &&
+		     (cpu_online(get_processor_id()) ||
+		     (con->flags & CON_ANYTIME)))
+		    con->write(con, "\n", 1);
+	      }
+              return 1;
+           }
+	}
+        return 0;
+}
+
+
+int mdb_serial_port;
+
+int get_modem_char(void)
+{
+    unsigned char ch;
+    int status;
+
+    if (mdb_serial_port == 0)
+       return -1;
+
+    if ((status = inb(mdb_serial_port + UART_LSR)) & UART_LSR_DR)
+    {
+       ch = inb(mdb_serial_port + UART_RX);
+       switch (ch)
+       {
+	   case 0x7f:
+	      ch = 8;
+              break;
+
+           case '\t':
+	      ch = ' ';
+              break;
+
+           case 8:  /* backspace */
+              break;
+
+	   case 13: /* enter */
+	      DBGPrint("\n");
+              break;
+
+           default:
+	      if (!isprint(ch))
+	         return(-1);
+	      DBGPrint("%c", ch);
+              break;
+	}
+	return ch;
+    }
+    return -1;
+}
+
+#if defined(CONFIG_MDB_MODULE)
+u_short plain_map[NR_KEYS] = {
+	0xf200,	0xf01b,	0xf031,	0xf032,	0xf033,	0xf034,	0xf035,	0xf036,
+	0xf037,	0xf038,	0xf039,	0xf030,	0xf02d,	0xf03d,	0xf07f,	0xf009,
+	0xfb71,	0xfb77,	0xfb65,	0xfb72,	0xfb74,	0xfb79,	0xfb75,	0xfb69,
+	0xfb6f,	0xfb70,	0xf05b,	0xf05d,	0xf201,	0xf702,	0xfb61,	0xfb73,
+	0xfb64,	0xfb66,	0xfb67,	0xfb68,	0xfb6a,	0xfb6b,	0xfb6c,	0xf03b,
+	0xf027,	0xf060,	0xf700,	0xf05c,	0xfb7a,	0xfb78,	0xfb63,	0xfb76,
+	0xfb62,	0xfb6e,	0xfb6d,	0xf02c,	0xf02e,	0xf02f,	0xf700,	0xf30c,
+	0xf703,	0xf020,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
+	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf209,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03c,	0xf10a,
+	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short shift_map[NR_KEYS] = {
+	0xf200,	0xf01b,	0xf021,	0xf040,	0xf023,	0xf024,	0xf025,	0xf05e,
+	0xf026,	0xf02a,	0xf028,	0xf029,	0xf05f,	0xf02b,	0xf07f,	0xf009,
+	0xfb51,	0xfb57,	0xfb45,	0xfb52,	0xfb54,	0xfb59,	0xfb55,	0xfb49,
+	0xfb4f,	0xfb50,	0xf07b,	0xf07d,	0xf201,	0xf702,	0xfb41,	0xfb53,
+	0xfb44,	0xfb46,	0xfb47,	0xfb48,	0xfb4a,	0xfb4b,	0xfb4c,	0xf03a,
+	0xf022,	0xf07e,	0xf700,	0xf07c,	0xfb5a,	0xfb58,	0xfb43,	0xfb56,
+	0xfb42,	0xfb4e,	0xfb4d,	0xf03c,	0xf03e,	0xf03f,	0xf700,	0xf30c,
+	0xf703,	0xf020,	0xf207,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf10e,
+	0xf10f,	0xf110,	0xf111,	0xf112,	0xf113,	0xf213,	0xf203,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03e,	0xf10a,
+	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+u_short ctrl_map[NR_KEYS] = {
+	0xf200,	0xf200,	0xf200,	0xf000,	0xf01b,	0xf01c,	0xf01d,	0xf01e,
+	0xf01f,	0xf07f,	0xf200,	0xf200,	0xf01f,	0xf200,	0xf008,	0xf200,
+	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,	0xf019,	0xf015,	0xf009,
+	0xf00f,	0xf010,	0xf01b,	0xf01d,	0xf201,	0xf702,	0xf001,	0xf013,
+	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
+	0xf007,	0xf000,	0xf700,	0xf01c,	0xf01a,	0xf018,	0xf003,	0xf016,
+	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf20e,	0xf07f,	0xf700,	0xf30c,
+	0xf703,	0xf000,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
+	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf204,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf10a,
+	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+#endif
+
+int mdb_suppress_crlf;
+static int get_kbd_char(void)
+{
+	int	scancode, scanstatus;
+	static int shift_lock;	/* CAPS LOCK state (0-off, 1-on) */
+	static int shift_key;	/* Shift next keypress */
+	static int ctrl_key;
+	u_short keychar;
+#if !defined(CONFIG_MDB_MODULE)
+        extern u_short plain_map[], shift_map[], ctrl_map[];
+#endif
+
+	if ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)
+		return -1;
+
+	/*
+	 * Fetch the scancode
+	 */
+	scancode = inb(KBD_DATA_REG);
+	scanstatus = inb(KBD_STATUS_REG);
+
+	/*
+	 * Ignore mouse events.
+	 */
+	if (scanstatus & KBD_STAT_MOUSE_OBF)
+		return -1;
+
+	/*
+	 * Ignore release, trigger on make
+	 * (except for shift keys, where we want to
+	 *  keep the shift state so long as the key is
+	 *  held down).
+	 */
+
+	if (((scancode & 0x7f) == 0x2a) ||
+            ((scancode & 0x7f) == 0x36))
+        {
+		/*
+		 * Next key may use shift table
+		 */
+		if ((scancode & 0x80) == 0) {
+			shift_key=1;
+		} else {
+			shift_key=0;
+		}
+		return -1;
+	}
+
+	if ((scancode & 0x7f) == 0x1d) {
+		/*
+		 * Left ctrl key
+		 */
+		if ((scancode & 0x80) == 0) {
+			ctrl_key = 1;
+		} else {
+			ctrl_key = 0;
+		}
+		return -1;
+	}
+
+	if ((scancode & 0x80) != 0)
+		return -1;
+
+	scancode &= 0x7f;
+
+	/*
+	 * Translate scancode
+	 */
+
+	if (scancode == 0x3a) {
+		/*
+		 * Toggle caps lock
+		 */
+		shift_lock ^= 1;
+		return -1;
+	}
+
+	if (scancode == 0x0e) {
+		/*
+		 * Backspace
+		 */
+		return 8;
+	}
+
+	if (scancode == 0xe0) {
+		return -1;
+	}
+
+	/*
+	 * For Japanese 86/106 keyboards
+	 *	See comment in drivers/char/pc_keyb.c.
+	 *	- Masahiro Adegawa
+	 */
+	if (scancode == 0x73) {
+		scancode = 0x59;
+	} else if (scancode == 0x7d) {
+		scancode = 0x7c;
+	}
+
+	if (!shift_lock && !shift_key && !ctrl_key) {
+		keychar = plain_map[scancode];
+	} else if (shift_lock || shift_key) {
+		keychar = shift_map[scancode];
+	} else if (ctrl_key) {
+		keychar = ctrl_map[scancode];
+	} else {
+		keychar = 0x0020;
+		DBGPrint("Unknown state/scancode (%d)\n", scancode);
+	}
+
+	keychar &= 0x0fff;
+	if (keychar == '\t')
+		keychar = ' ';
+
+        switch (keychar)
+        {
+           case K_F1:
+           case K_F2:
+           case K_F3:
+           case K_F4:
+           case K_F5:
+           case K_F6:
+           case K_F7:
+           case K_F8:
+           case K_F9:
+           case K_F10:
+           case K_F11:
+           case K_F12:
+	      return keychar;
+           default:
+              break;
+        }
+
+	switch (KTYP(keychar))
+        {
+	   case KT_LETTER:
+	   case KT_LATIN:
+		if (isprint(keychar))
+			break;		/* printable characters */
+		/* drop through */
+	   case KT_SPEC:
+		if (keychar == K_ENTER)
+			break;
+		/* drop through */
+           case KT_PAD:
+                switch (keychar)
+                {
+                   case K_P0:
+                   case K_P1:
+                   case K_P2:
+                   case K_P4:
+                   case K_P6:
+                   case K_P7:
+                   case K_P8:
+                   case K_PDOT:
+                      return keychar;
+                }
+                return -1;
+
+           case KT_CUR:
+                switch (keychar)
+                {
+                   case K_DOWN:
+                   case K_LEFT:
+                   case K_RIGHT:
+                   case K_UP:
+                      return keychar;
+                }
+                return -1;
+
+	   default:
+		return(-1);	/* ignore unprintables */
+	}
+
+	if ((scancode & 0x7f) == 0x1c) {
+		/*
+		 * enter key.  All done.  Absorb the release scancode.
+		 */
+		while ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)
+			;
+
+		/*
+		 * Fetch the scancode
+		 */
+		scancode = inb(KBD_DATA_REG);
+		scanstatus = inb(KBD_STATUS_REG);
+
+		while (scanstatus & KBD_STAT_MOUSE_OBF)
+                {
+		   scancode = inb(KBD_DATA_REG);
+		   scanstatus = inb(KBD_STATUS_REG);
+		}
+
+                /* enter-release error */
+		if (scancode != 0x9c) {} ;
+
+                if (!mdb_suppress_crlf)
+		   DBGPrint("\n");
+		return 13;
+	}
+
+	/*
+	 * echo the character.
+	 */
+	DBGPrint("%c", keychar & 0xff);
+	return keychar & 0xff;
+}
+
+int mdb_getkey(void)
+{
+   int key = -1;
+
+   for (;;)
+   {
+      key = get_kbd_char();
+      if (key != -1)
+	 break;
+
+      touch_nmi_watchdog();
+   }
+   return key;
+}
+
+int mdb_copy(void *to, void *from, size_t size)
+{
+    return __copy_to_user_inatomic(to, from, size);
+}
+
+int mdb_verify_rw(void *addr, size_t size)
+{
+    unsigned char data[size];
+    return (mdb_copy(data, addr, size));
+}
+
+int mdb_getlword(unsigned long *word, unsigned long addr, size_t size)
+{
+	int err;
+
+	__u8  w1;
+	__u16 w2;
+	__u32 w4;
+	__u64 w8;
+
+	*word = 0;	/* Default value if addr or size is invalid */
+	switch (size) {
+	case 1:
+		if (!(err = mdb_copy(&w1, (void *)addr, size)))
+			*word = w1;
+		break;
+	case 2:
+		if (!(err = mdb_copy(&w2, (void *)addr, size)))
+			*word = w2;
+		break;
+	case 4:
+		if (!(err = mdb_copy(&w4, (void *)addr, size)))
+			*word = w4;
+		break;
+	case 8:
+		if (size <= sizeof(*word))
+                {
+			if (!(err = mdb_copy(&w8, (void *)addr, size)))
+				*word = w8;
+			break;
+		}
+	default:
+		err = -EFAULT;
+	}
+	return (err);
+}
+
+int mdb_putword(unsigned long addr, unsigned long word, size_t size)
+{
+	int err;
+	__u8  w1;
+	__u16 w2;
+	__u32 w4;
+	__u64 w8;
+
+	switch (size) {
+	case 1:
+		w1 = word;
+		err = mdb_copy((void *)addr, &w1, size);
+		break;
+	case 2:
+		w2 = word;
+		err = mdb_copy((void *)addr, &w2, size);
+		break;
+	case 4:
+		w4 = word;
+		err = mdb_copy((void *)addr, &w4, size);
+		break;
+	case 8:
+		if (size <= sizeof(word))
+                {
+		   w8 = word;
+		   err = mdb_copy((void *)addr, &w8, size);
+		   break;
+		}
+	default:
+		err = -EFAULT;
+	}
+	return (err);
+}
+
+unsigned long mdb_getword(unsigned long addr, size_t size)
+{
+   unsigned long data = 0;
+   register int ret;
+
+   ret = mdb_getlword(&data, addr, size);
+   if (ret)
+      return 0;
+
+   return data;
+}
+
+int DisplayClosestSymbol(unsigned long address)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset = 0, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(address, &size, &offset, &modname, namebuf);
+    if (!name)
+       return -1;
+
+    if (modname)
+    {
+       if (offset)
+          DBGPrint("%s|%s+0x%X\n", modname, name, offset);
+       else
+          DBGPrint("%s|%s\n", modname, name);
+    }
+    else
+    {
+       if (offset)
+          DBGPrint("%s+0x%X\n", name, offset);
+       else
+          DBGPrint("%s\n", name);
+    }
+    return 0;
+}
+
+void DumpOSSymbolTableMatch(unsigned char *symbol)
+{
+    mdb_kallsyms(symbol, DBGPrint);
+    return;
+}
+
+unsigned long GetValueFromSymbol(unsigned char *symbol)
+{
+   return ((unsigned long)kallsyms_lookup_name(symbol));
+}
+
+
+unsigned char *GetModuleInfoFromSymbolValue(unsigned long value, unsigned char *buf, unsigned long len)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(value, &size, &offset, &modname, namebuf);
+    if (modname && buf)
+    {
+       strncpy(buf, modname, len);
+       return (unsigned char *)buf;
+    }
+    return NULL;
+}
+
+unsigned char *GetSymbolFromValue(unsigned long value, unsigned char *buf, unsigned long len)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(value, &size, &offset, &modname, namebuf);
+    if (!name)
+       return NULL;
+
+    if (!offset && buf)
+    {
+       strncpy(buf, namebuf, len);
+       return (unsigned char *)buf;
+    }
+
+    return NULL;
+}
+
+unsigned char *GetSymbolFromValueWithOffset(unsigned long value, unsigned long *sym_offset,
+                                   unsigned char *buf, unsigned long len)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(value, &size, &offset, &modname, namebuf);
+    if (!name || !buf)
+       return NULL;
+
+    if (sym_offset)
+      *sym_offset = offset;
+
+    strncpy(buf, namebuf, len);
+    return (unsigned char *)buf;
+}
+
+unsigned char *GetSymbolFromValueOffsetModule(unsigned long value, unsigned long *sym_offset,
+                                     unsigned char **module, unsigned char *buf, unsigned long len)
+{
+    char *modname;
+    const char *name;
+    unsigned long offset, size;
+    char namebuf[KSYM_NAME_LEN+1];
+
+    name = kallsyms_lookup(value, &size, &offset, &modname, namebuf);
+    if (!name || !buf)
+       return NULL;
+
+    if (sym_offset)
+      *sym_offset = offset;
+
+    if (module)
+       *module = modname;
+
+    strncpy(buf, namebuf, len);
+    return (unsigned char *)buf;
+}
+
+
+unsigned long get_processor_id(void)
+{
+#if defined(CONFIG_SMP)
+   return raw_smp_processor_id();
+#else
+   return 0;
+#endif
+}
+
+unsigned long get_physical_processor(void)
+{
+#if defined(CONFIG_SMP)
+   return raw_smp_processor_id();
+#else
+   return 0;
+#endif
+}
+
+unsigned long fpu_present(void)
+{
+   if (boot_cpu_has(X86_FEATURE_FPU))
+       return 1;
+    return 0;
+}
+
+extern unsigned long cpu_mttr_on(void)
+{
+   if (boot_cpu_has(X86_FEATURE_MTRR))
+       return 1;
+    return 0;
+}
+
+unsigned char *UpcaseString(unsigned char *s)
+{
+   register int i;
+
+   for (i = 0; i < strlen(s); i++)
+      s[i] = toupper(s[i]);
+   return s;
+
+}
+void ClearScreen(void)
+{
+    return;
+}
+
+unsigned short ReadFS(void)
+{
+    unsigned short contents = 0;
+
+    __asm__ ("mov %%fs,%0\n\t":"=r"(contents));
+    return contents;
+}
+
+unsigned short ReadGS(void)
+{
+    unsigned short contents = 0;
+
+    __asm__ ("mov %%gs,%0\n\t":"=r"(contents));
+    return contents;
+}
+
+unsigned long ReadDR(unsigned long regnum)
+{
+	unsigned long contents = 0;
+
+	switch(regnum)
+        {
+	   case 0:
+		__asm__ ("movl %%db0,%0\n\t":"=r"(contents));
+		break;
+	   case 1:
+		__asm__ ("movl %%db1,%0\n\t":"=r"(contents));
+		break;
+	   case 2:
+		__asm__ ("movl %%db2,%0\n\t":"=r"(contents));
+		break;
+	   case 3:
+		__asm__ ("movl %%db3,%0\n\t":"=r"(contents));
+		break;
+	   case 4:
+	   case 5:
+		break;
+	   case 6:
+		__asm__ ("movl %%db6,%0\n\t":"=r"(contents));
+		break;
+	   case 7:
+		__asm__ ("movl %%db7,%0\n\t":"=r"(contents));
+		break;
+	   default:
+		break;
+	}
+
+	return contents;
+}
+
+void WriteDR(int regnum, unsigned long contents)
+{
+	switch(regnum)
+        {
+	   case 0:
+		__asm__ ("movl %0,%%db0\n\t"::"r"(contents));
+		break;
+	   case 1:
+		__asm__ ("movl %0,%%db1\n\t"::"r"(contents));
+		break;
+	   case 2:
+		__asm__ ("movl %0,%%db2\n\t"::"r"(contents));
+		break;
+	   case 3:
+		__asm__ ("movl %0,%%db3\n\t"::"r"(contents));
+		break;
+	   case 4:
+	   case 5:
+		break;
+	   case 6:
+		__asm__ ("movl %0,%%db6\n\t"::"r"(contents));
+		break;
+	   case 7:
+		__asm__ ("movl %0,%%db7\n\t"::"r"(contents));
+		break;
+	   default:
+		break;
+	}
+}
+
+unsigned long ReadCR(int regnum)
+{
+	unsigned long contents = 0;
+
+	switch(regnum)
+        {
+	   case 0:
+		__asm__ ("movl %%cr0,%0\n\t":"=r"(contents));
+		break;
+	   case 1:
+		break;
+	   case 2:
+		__asm__ ("movl %%cr2,%0\n\t":"=r"(contents));
+		break;
+	   case 3:
+		__asm__ ("movl %%cr3,%0\n\t":"=r"(contents));
+		break;
+	   case 4:
+		__asm__ ("movl %%cr4,%0\n\t":"=r"(contents));
+		break;
+	   default:
+		break;
+	}
+	return contents;
+}
+
+void WriteCR(int regnum, unsigned long contents)
+{
+	switch(regnum)
+        {
+	   case 0:
+		__asm__ ("movl %0,%%cr0\n\t"::"r"(contents));
+		break;
+	   case 1:
+		break;
+	   case 2:
+		__asm__ ("movl %0,%%cr2\n\t"::"r"(contents));
+		break;
+	   case 3:
+		__asm__ ("movl %0,%%cr3\n\t"::"r"(contents));
+		break;
+	   case 4:
+		__asm__ ("movl %0,%%cr4\n\t"::"r"(contents));
+		break;
+	   default:
+		break;
+	}
+	return;
+}
+
+unsigned long ReadTR(void)
+{
+   unsigned short tr;
+
+   __asm__ __volatile__("str %0":"=a"(tr));
+
+   return (unsigned long) tr;
+}
+
+unsigned long ReadLDTR(void)
+{
+   unsigned short ldt;
+
+   __asm__ __volatile__("sldt %0":"=a"(ldt));
+
+   return (unsigned long) ldt;
+}
+
+void ReadGDTR(unsigned long *v)
+{
+   __asm__ __volatile__("sgdt %0":"=m"(*v));
+}
+
+void ReadIDTR(unsigned long *v)
+{
+    __asm__ __volatile__("sidt %0":"=m"(*v));
+}
+
+void save_npx(NUMERIC_FRAME *v)
+{
+    __asm__ __volatile__("fsave %0":"=m"(*v));
+}
+
+void load_npx(NUMERIC_FRAME *v)
+{
+    __asm__ __volatile__("frstor %0":"=m"(*v));
+}
+
+unsigned long ReadDR0(void)  {  return (ReadDR(0)); }
+unsigned long ReadDR1(void)  {  return (ReadDR(1)); }
+unsigned long ReadDR2(void)  {  return (ReadDR(2)); }
+unsigned long ReadDR3(void)  {  return (ReadDR(3)); }
+unsigned long ReadDR6(void)  {  return (ReadDR(6)); }
+unsigned long ReadDR7(void)  {  return (ReadDR(7)); }
+
+void WriteDR0(unsigned long v) { WriteDR(0, v); }
+void WriteDR1(unsigned long v) { WriteDR(1, v); }
+void WriteDR2(unsigned long v) { WriteDR(2, v); }
+void WriteDR3(unsigned long v) { WriteDR(3, v); }
+void WriteDR6(unsigned long v) { WriteDR(6, v); }
+void WriteDR7(unsigned long v) { WriteDR(7, v); }
+
+unsigned long ReadCR0(void) {  return (ReadCR(0)); }
+unsigned long ReadCR2(void) {  return (ReadCR(2)); }
+unsigned long ReadCR3(void) {  return (ReadCR(3)); }
+unsigned long ReadCR4(void) {  return (ReadCR(4)); }
+
+void WriteCR0(unsigned long v) { WriteCR(0, v); }
+void WriteCR2(unsigned long v) { WriteCR(2, v); }
+void WriteCR3(unsigned long v) { WriteCR(3, v); }
+void WriteCR4(unsigned long v) { WriteCR(4, v); }
+
+void ReadMSR(unsigned long r, unsigned long *v1, unsigned long *v2)
+{
+    unsigned long vv1, vv2;
+
+    rdmsr(r, vv1, vv2);
+
+    if (v1)
+       *v1 = vv1;
+    if (v2)
+       *v2 = vv2;
+}
+
+void WriteMSR(unsigned long r, unsigned long *v1, unsigned long *v2)
+{
+    unsigned long vv1 = 0, vv2 = 0;
+
+    if (v1)
+       vv1 = *v1;
+    if (v2)
+       vv2 = *v2;
+
+    wrmsr(r, vv1, vv2);
+}
diff -Naur linux-2.6.27/debug/mdb/mdb-os.h linux-2.6.27-mdb/debug/mdb/mdb-os.h
--- linux-2.6.27/debug/mdb/mdb-os.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-os.h	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,106 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#ifndef _MDB_OS_H
+#define _MDB_OS_H
+
+#define MAX_SYMBOL_LEN  KSYM_NAME_LEN+1
+
+extern atomic_t inmdb;
+extern int pause_mode;
+extern unsigned char *mdb_oops;
+extern unsigned char *last_mdb_oops;
+extern unsigned char symbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+extern unsigned char modbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+extern unsigned char workbuf[MAX_PROCESSORS][MAX_SYMBOL_LEN];
+
+extern int mdb_kallsyms(char *str, int (*print)(char *s, ...));
+extern int mdb_modules(char *str, int (*print)(char *s, ...));
+extern int mdb_getkey(void);
+extern int mdb_getlword(unsigned long *word, unsigned long addr, size_t size);
+extern int mdb_putword(unsigned long addr, unsigned long word, size_t size);
+extern unsigned long mdb_getword(unsigned long addr, size_t size);
+extern int mdb_verify_rw(void *addr, size_t size);
+extern unsigned long ValidateAddress(unsigned long addr, unsigned long length);
+extern int DisplayClosestSymbol(unsigned long address);
+extern void DumpOSSymbolTableMatch(unsigned char *symbol);
+extern void DumpOSSymbolTable(void);
+extern unsigned long GetValueFromSymbol(unsigned char *symbol);
+extern unsigned char *GetModuleInfoFromSymbolValue(unsigned long value, unsigned char *buf, unsigned long len);
+extern unsigned char *GetSymbolFromValue(unsigned long value, unsigned char *buf, unsigned long len);
+extern unsigned char *GetSymbolFromValueWithOffset(unsigned long value, unsigned long *sym_offset,
+                                          unsigned char *buf, unsigned long len);
+extern unsigned char *GetSymbolFromValueOffsetModule(unsigned long value, unsigned long *sym_offset,
+                                     unsigned char **module, unsigned char *buf, unsigned long len);
+extern unsigned long get_processor_id(void);
+extern unsigned long get_physical_processor(void);
+extern unsigned long fpu_present(void);
+extern unsigned long cpu_mttr_on(void);
+extern unsigned char *UpcaseString(unsigned char *s);
+extern void ClearScreen(void);
+extern unsigned short ReadFS(void);
+extern unsigned short ReadGS(void);
+extern unsigned long ReadDR(unsigned long regnum);
+extern void WriteDR(int regnum, unsigned long contents);
+extern unsigned long ReadCR(int regnum);
+extern void WriteCR(int regnum, unsigned long contents);
+extern unsigned long ReadTR(void);
+extern unsigned long ReadLDTR(void);
+extern void ReadGDTR(unsigned long *v);
+extern void ReadIDTR(unsigned long *v);
+extern void save_npx(NUMERIC_FRAME *v);
+extern void load_npx(NUMERIC_FRAME *v);
+extern unsigned long ReadDR0(void);
+extern unsigned long ReadDR1(void);
+extern unsigned long ReadDR2(void);
+extern unsigned long ReadDR3(void);
+extern unsigned long ReadDR6(void);
+extern unsigned long ReadDR7(void);
+extern void WriteDR0(unsigned long v);
+extern void WriteDR1(unsigned long v);
+extern void WriteDR2(unsigned long v);
+extern void WriteDR3(unsigned long v);
+extern void WriteDR6(unsigned long v);
+extern void WriteDR7(unsigned long v);
+extern unsigned long ReadCR0(void);
+extern unsigned long ReadCR2(void);
+extern unsigned long ReadCR3(void);
+extern unsigned long ReadCR4(void);
+extern void WriteCR0(unsigned long v);
+extern void WriteCR2(unsigned long v);
+extern void WriteCR3(unsigned long v);
+extern void WriteCR4(unsigned long v);
+extern void ReadMSR(unsigned long r, unsigned long *v1, unsigned long *v2);
+extern void WriteMSR(unsigned long r, unsigned long *v1, unsigned long *v2);
+#endif
diff -Naur linux-2.6.27/debug/mdb/mdb-proc.h linux-2.6.27-mdb/debug/mdb/mdb-proc.h
--- linux-2.6.27/debug/mdb/mdb-proc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.27-mdb/debug/mdb/mdb-proc.h	2008-10-06 23:55:42.000000000 -0600
@@ -0,0 +1,146 @@
+
+/***************************************************************************
+*
+*   Copyright (c) 2008 Jeff V. Merkey  All Rights Reserved.
+*   1058 East 50 South
+*   Lindon, Utah 84042
+*   jmerkey@wolfmountaingroup.com
+*
+*   This program is free software; you can redistribute it and/or modify it
+*   under the terms of the GNU General Public License as published by the
+*   Free Software Foundation, version 2.
+*
+*   This program is distributed in the hope that it will be useful, but
+*   WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*   General Public License for more details.
+*
+*   You are free to modify and re-distribute this program in accordance
+*   with the terms specified in the GNU Public License.  The copyright
+*   contained in this code is required to be present in any derivative
+*   works and you are required to provide the source code for this
+*   program as part of any commercial or non-commercial distribution.
+*   You are required to respect the rights of the Copyright holders
+*   named within this code.
+*
+*   jmerkey@wolfmountaingroup.com is the official maintainer of
+*   this code.  You are encouraged to report any bugs, problems, fixes,
+*   suggestions, and comments about this software.
+*
+*   AUTHOR   :  Jeff V. Merkey
+*   DESCRIP  :  Merkey's Linux Debugger
+*
+***************************************************************************/
+
+#ifndef _MDB_PROC_H
+#define _MDB_PROC_H
+
+#define MAX_PROCESSORS           NR_CPUS
+#define SYMBOL_DEBUG             0
+
+/* mdb-base.c */
+extern unsigned long needs_proceed;
+extern unsigned long jmp_active;
+extern unsigned long general_toggle;
+extern unsigned long line_info_toggle;
+extern unsigned long control_toggle;
+extern unsigned long segment_toggle;
+extern unsigned long numeric_toggle;
+extern unsigned long reason_toggle;
+
+extern unsigned long MajorVersion;
+extern unsigned long MinorVersion;
+extern unsigned long BuildVersion;
+extern unsigned char *IA32Flags[];
+extern unsigned char *BreakDescription[];
+extern unsigned char *BreakLengthDescription[];
+extern unsigned char *ExceptionDescription[];
+extern NUMERIC_FRAME npx[MAX_PROCESSORS];
+extern StackFrame ReferenceFrame[MAX_PROCESSORS];
+
+extern atomic_t focusActive;
+extern atomic_t debuggerActive;
+extern atomic_t debuggerProcessors[MAX_PROCESSORS];
+extern atomic_t nmiProcessors[MAX_PROCESSORS];
+extern atomic_t traceProcessors[MAX_PROCESSORS];
+extern unsigned long ProcessorHold[MAX_PROCESSORS];
+extern unsigned long ProcessorState[MAX_PROCESSORS];
+extern unsigned char *procState[];
+
+// mdb-ia32.c
+extern unsigned char *lastDumpAddress;
+extern unsigned char *lastLinkAddress;
+extern unsigned long lastUnasmAddress;
+extern unsigned long displayLength;
+extern unsigned long lastCommand;
+extern unsigned long lastCommandEntry;
+extern unsigned char lastDebugCommand[100];
+extern unsigned long lastDisplayLength;
+extern unsigned char debugCommand[100];
+extern unsigned long nextUnasmAddress;
+extern unsigned long pic1Value;
+extern unsigned long pic2Value;
+extern unsigned long BreakReserved[4];
+extern unsigned long BreakPoints[4];
+extern unsigned long BreakType[4];
+extern unsigned long BreakLength[4];
+extern unsigned long BreakTemp[4];
+extern unsigned long BreakGo[4];
+extern unsigned long BreakProceed[4];
+extern unsigned long BreakMask[MAX_PROCESSORS];
+extern StackFrame *CurrentFrame[MAX_PROCESSORS];
+extern unsigned long NestedInterrupts[MAX_PROCESSORS];
+extern unsigned long ConditionalBreakpoint[4];
+extern unsigned char BreakCondition[4][256];
+extern StackFrame lastStackFrame;
+extern unsigned long lastCR0;
+extern unsigned long lastCR2;
+extern unsigned long lastCR4;
+extern unsigned long CurrentDR7;
+extern unsigned long CurrentDR6[MAX_PROCESSORS];
+extern unsigned long repeatCommand;
+extern unsigned long totalLines;
+extern unsigned long debuggerInitialized;
+extern unsigned long ssbmode;
+extern int nextline;
+
+extern unsigned long disassemble(StackFrame *stackFrame, unsigned long p, unsigned long count,
+                         unsigned long use);
+extern void ClearDebuggerState(void);
+extern void displayMTRRRegisters(void);
+extern void DisplayGDT(unsigned char *GDT_ADDRESS);
+extern void DisplayIDT(unsigned char *IDT_ADDRESS);
+extern void SetDebugRegisters(void);
+extern void LoadDebugRegisters(void);
+extern void ClearTempBreakpoints(void);
+extern unsigned long ValidBreakpoint(unsigned long address);
+extern unsigned char *dump(unsigned char *p, unsigned long count);
+extern unsigned char *dumpWord(unsigned char *p, unsigned long count);
+extern unsigned char *dumpDouble(unsigned char *p, unsigned long count);
+extern unsigned char *dumpLinkedList(unsigned char *p, unsigned long count, unsigned long offset);
+extern unsigned char *dumpDoubleStack(StackFrame *stackFrame, unsigned char *p, unsigned long count);
+extern unsigned char *dumpStack(StackFrame *stackFrame, unsigned char *p, unsigned long count);
+extern unsigned long debugger_setup(unsigned long processor, unsigned long Exception, StackFrame *stackFrame, unsigned char *panicMsg);
+extern unsigned long debugger_entry(unsigned long Exception, StackFrame *stackFrame, unsigned long processor);
+extern unsigned long debugger_command_entry(unsigned long processor, unsigned long Exception, StackFrame *stackFrame);
+extern unsigned long ConsoleDisplayBreakReason(StackFrame *stackFrame,
+			       unsigned long reason, unsigned long processor,
+			       unsigned long lastCommand);
+extern unsigned long EvaluateExpression(StackFrame *stackFrame, unsigned char **p, unsigned long *type);
+extern unsigned long EvaluateNumericExpression(StackFrame *stackFrame, unsigned char **p,
+                                       unsigned long *type);
+extern unsigned long unassemble(StackFrame *stackFrame, unsigned long ip, unsigned long use,
+                        unsigned long *ret);
+extern void DisplayASCIITable(void);
+extern unsigned char *UpcaseString(unsigned char *);
+extern unsigned long validate_address(unsigned long addr);
+extern unsigned long ScreenInputFromKeyboard(unsigned char *buffer, unsigned long Start, unsigned long Length);
+
+extern unsigned long GetIP(StackFrame *);
+extern unsigned long GetStackAddress(StackFrame *);
+extern unsigned long GetStackSegment(StackFrame *);
+extern unsigned short read_memory(void *, void *, unsigned);
+extern unsigned long SSBUpdate(StackFrame *stackFrame, unsigned long processor);
+extern void mdb_breakpoint(void);
+
+#endif
diff -Naur linux-2.6.27/Documentation/sysrq.txt linux-2.6.27-mdb/Documentation/sysrq.txt
--- linux-2.6.27/Documentation/sysrq.txt	2008-07-13 15:51:29.000000000 -0600
+++ linux-2.6.27-mdb/Documentation/sysrq.txt	2008-10-06 23:55:42.000000000 -0600
@@ -82,6 +82,8 @@
 
 'i'     - Send a SIGKILL to all processes, except for init.
 
+'j'	- Used by Jeff Merkey's Kernel Debugger (mdb).
+
 'k'     - Secure Access Key (SAK) Kills all programs on the current virtual
           console. NOTE: See important comments below in SAK section.
 
diff -Naur linux-2.6.27/drivers/char/vt.c linux-2.6.27-mdb/drivers/char/vt.c
--- linux-2.6.27/drivers/char/vt.c	2008-10-06 23:53:48.000000000 -0600
+++ linux-2.6.27-mdb/drivers/char/vt.c	2008-10-06 23:55:42.000000000 -0600
@@ -187,6 +187,7 @@
 int last_console;
 int want_console = -1;
 int kmsg_redirect;
+EXPORT_SYMBOL_GPL(kmsg_redirect);
 
 /*
  * For each existing display, we have a pointer to console currently visible
diff -Naur linux-2.6.27/kernel/extable.c linux-2.6.27-mdb/kernel/extable.c
--- linux-2.6.27/kernel/extable.c	2008-07-13 15:51:29.000000000 -0600
+++ linux-2.6.27-mdb/kernel/extable.c	2008-10-06 23:55:42.000000000 -0600
@@ -59,6 +59,7 @@
 		return 1;
 	return __module_text_address(addr) != NULL;
 }
+EXPORT_SYMBOL_GPL(__kernel_text_address);
 
 int kernel_text_address(unsigned long addr)
 {
diff -Naur linux-2.6.27/kernel/kallsyms.c linux-2.6.27-mdb/kernel/kallsyms.c
--- linux-2.6.27/kernel/kallsyms.c	2008-10-06 23:53:53.000000000 -0600
+++ linux-2.6.27-mdb/kernel/kallsyms.c	2008-10-06 23:55:42.000000000 -0600
@@ -160,6 +160,7 @@
 	}
 	return module_kallsyms_lookup_name(name);
 }
+EXPORT_SYMBOL_GPL(kallsyms_lookup_name);
 
 static unsigned long get_symbol_pos(unsigned long addr,
 				    unsigned long *symbolsize,
@@ -262,6 +263,7 @@
 				     namebuf);
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(kallsyms_lookup);
 
 int lookup_symbol_name(unsigned long addr, char *symname)
 {
@@ -477,5 +479,49 @@
 }
 __initcall(kallsyms_init);
 
+#if defined(CONFIG_MDB) || defined(CONFIG_MDB_MODULE)
+struct kallsym_iter mdb_iter;
+int mdb_kallsyms(char *str, int (*print)(char *s, ...))
+{
+    register loff_t pos = 0;
+    register struct kallsym_iter *iter = &mdb_iter;
+
+    if (!print)
+       return 0;
+
+    // set to beginning of the kallsyms list
+    reset_iter(iter, 0);
+    while (1)
+    {
+       // search the kallsyms list
+       if (!update_iter(iter, pos++))
+          break;
+
+       if (!iter->name[0])
+	  continue;
+
+       // if an exclusion search was specified, skip non-matching entries
+       if (str && *str && !strstr(iter->name, str))
+          continue;
+
+       if (iter->module_name[0])
+       {
+          if (print("%0*lx %c %s [%s]\n", (int)(2*sizeof(void*)),
+	      iter->value, iter->type, iter->name,
+	      iter->module_name))
+             return 1;
+       }
+       else
+       {
+          if (print("%0*lx %c %s\n", (int)(2*sizeof(void*)),
+	      iter->value, iter->type, iter->name))
+             return 1;
+       }
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(mdb_kallsyms);
+#endif
+
 EXPORT_SYMBOL(__print_symbol);
 EXPORT_SYMBOL_GPL(sprint_symbol);
diff -Naur linux-2.6.27/kernel/module.c linux-2.6.27-mdb/kernel/module.c
--- linux-2.6.27/kernel/module.c	2008-10-06 23:53:53.000000000 -0600
+++ linux-2.6.27-mdb/kernel/module.c	2008-10-06 23:55:42.000000000 -0600
@@ -2503,6 +2503,39 @@
 	return 0;
 }
 
+#if defined(CONFIG_MDB) || defined(CONFIG_MDB_MODULE)
+int mdb_modules(char *str, int (*print)(char *s, ...))
+{
+	struct module *mod;
+	struct module_use *use;
+
+        if (!print)
+           return 0;
+
+	list_for_each_entry(mod, &modules, list)
+        {
+           if (str && *str && !strstr(mod->name, str))
+              continue;
+
+	   print(" 0x%08p ", mod->module_core);
+	   print("%s", mod->name);
+	   print(" %lu %02u ", mod->init_size + mod->core_size,
+                 module_refcount(mod));
+	   list_for_each_entry(use, &mod->modules_which_use_me, list)
+		print("%s,", use->module_which_uses->name);
+	   if (mod->init != NULL && mod->exit == NULL)
+	      print("[permanent],");
+	   print(" %s ", mod->state == MODULE_STATE_GOING ? "Unloading":
+	                mod->state == MODULE_STATE_COMING ? "Loading":
+		        "Live");
+	   if (print("\n"))
+              return 1;
+	}
+        return 0;
+}
+EXPORT_SYMBOL_GPL(mdb_modules);
+#endif
+
 /* Look for this name: can be of form module:name. */
 unsigned long module_kallsyms_lookup_name(const char *name)
 {
diff -Naur linux-2.6.27/kernel/panic.c linux-2.6.27-mdb/kernel/panic.c
--- linux-2.6.27/kernel/panic.c	2008-10-06 23:53:53.000000000 -0600
+++ linux-2.6.27-mdb/kernel/panic.c	2008-10-06 23:55:42.000000000 -0600
@@ -21,6 +21,8 @@
 #include <linux/debug_locks.h>
 #include <linux/random.h>
 #include <linux/kallsyms.h>
+#include <linux/kdebug.h>
+
 
 int panic_on_oops;
 int tainted;
@@ -75,6 +77,13 @@
 	 */
 	preempt_disable();
 
+        /* call the notify_die handler for any resident debuggers which
+        * may be active and pass the message string.   On a software
+        * fault return at least some sort of regs for a remote debugger
+        * to look at.
+        */
+	notify_die(DIE_PANIC, buf, get_irq_regs(), 0, -1, SIGTERM);
+
 	bust_spinlocks(1);
 	va_start(args, fmt);
 	vsnprintf(buf, sizeof(buf), fmt, args);
diff -Naur linux-2.6.27/kernel/time/clocksource.c linux-2.6.27-mdb/kernel/time/clocksource.c
--- linux-2.6.27/kernel/time/clocksource.c	2008-10-06 23:53:53.000000000 -0600
+++ linux-2.6.27-mdb/kernel/time/clocksource.c	2008-10-06 23:55:42.000000000 -0600
@@ -242,6 +242,7 @@
 {
 	clocksource_resume_watchdog();
 }
+EXPORT_SYMBOL_GPL(clocksource_touch_watchdog);
 
 /**
  * clocksource_get_next - Returns the selected clocksource
diff -Naur linux-2.6.27/lib/Kconfig.debug linux-2.6.27-mdb/lib/Kconfig.debug
--- linux-2.6.27/lib/Kconfig.debug	2008-10-06 23:53:53.000000000 -0600
+++ linux-2.6.27-mdb/lib/Kconfig.debug	2008-10-06 23:55:42.000000000 -0600
@@ -134,6 +134,43 @@
 	  Say Y here if you are developing drivers or trying to debug and
 	  identify kernel problems.
 
+config MDB
+	tristate "Merkey's Kernel Debugger"
+	depends on DEBUG_KERNEL && X86
+	select MAGIC_SYSRQ
+	select KALLSYMS
+	select KALLSYMS_ALL
+	default m
+	help
+           Kernel Debugger for Linux written by Jeffrey Vernon
+           Merkey.  'echo j > /proc/sysrq-trigger' will activate the
+           debugger from the text based Linux Console, and the 'j'
+           character (alt-printscreen/sysrq + 'j') with MAGIC_SYSRQ
+           enabled to enter the debugger.  X Windows is not supported.
+           This debugger is minimal and text based.  Excellent help can
+           be obtained from the debugger by typing "Help Help" or
+           "help" from the debugger command console.  If you compiled
+           MDB as a module you may need to load the debugger with
+           the 'modprobe mdb' before you can access the debugger
+           from the Linux Console.  To enable the MAGIC-SYSRQ key
+           type 'echo 1 > /proc/sys/kernel/sysrq'.
+
+config MDB_CONSOLE_REDIRECTION
+	bool "MDB Console Redirection Support"
+	depends on MDB
+	default y
+	help
+           Reset any Console Redirection to default system settings (0)
+           when the MDB debugger is active.  The Debugger will restore
+           the redirection to the custom settings when the debugger
+           is exited.  This feature is useful on systems which by default
+           redirect printk output and the screen debugger output to a log
+           file or system device, which can prevent the debugger screen from
+           being visible.  Enabling this feature does not affect or disable
+           remote operations via serial port.  It is recommended to enable
+           this feature by default if intensive debugging is intended for
+           the target system.
+
 config DEBUG_SHIRQ
 	bool "Debug shared IRQ handlers"
 	depends on DEBUG_KERNEL && GENERIC_HARDIRQS
diff -Naur linux-2.6.27/Makefile linux-2.6.27-mdb/Makefile
--- linux-2.6.27/Makefile	2008-10-06 23:53:45.000000000 -0600
+++ linux-2.6.27-mdb/Makefile	2008-10-06 23:55:42.000000000 -0600
@@ -620,6 +620,7 @@
 
 ifeq ($(KBUILD_EXTMOD),)
 core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+core-$(CONFIG_MDB) += debug/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
