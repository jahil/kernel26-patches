diff -Nupr a/arch/i386/defconfig b/arch/i386/defconfig
--- a/arch/i386/defconfig	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/i386/defconfig	2007-05-11 11:44:45.000000000 +0200
@@ -102,7 +102,7 @@ CONFIG_DEFAULT_IOSCHED="anticipatory"
 #
 # Processor type and features
 #
-CONFIG_SMP=y
+# CONFIG_SMP is not set
 # CONFIG_X86_PC is not set
 # CONFIG_X86_ELAN is not set
 # CONFIG_X86_VOYAGER is not set
@@ -160,9 +160,9 @@ CONFIG_NR_CPUS=32
 CONFIG_SCHED_SMT=y
 CONFIG_SCHED_MC=y
 # CONFIG_PREEMPT_NONE is not set
-CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
-CONFIG_PREEMPT_BKL=y
+# CONFIG_PREEMPT_BKL is not set
 CONFIG_X86_LOCAL_APIC=y
 CONFIG_X86_IO_APIC=y
 CONFIG_X86_MCE=y
@@ -1469,6 +1469,33 @@ CONFIG_OPROFILE=y
 CONFIG_KPROBES=y
 
 #
+# Kerrighed support
+#
+CONFIG_KERRIGHED=y
+# CONFIG_KERRIGHED_DEVEL is not set
+CONFIG_KRG_TOOLS=y
+CONFIG_KRG_COMMUNICATION_FRAMEWORK=y
+CONFIG_KRG_HOTPLUG=y
+CONFIG_KRG_DISABLE_HEARTBEAT=y
+# CONFIG_KRG_SYNC is not set
+CONFIG_KRG_PROCFS=y
+# CONFIG_KRG_STREAM is not set
+CONFIG_KRG_CTNR=y
+CONFIG_KRG_MM=y
+CONFIG_KRG_DVFS=y
+CONFIG_KRG_FAF=y
+CONFIG_KRG_IPC=y
+CONFIG_KRG_PROC=y
+CONFIG_KRG_EPM=y
+# CONFIG_KRG_FD is not set
+CONFIG_KRG_SCHED=y
+CONFIG_KRG_PROC_MOSIX_PROBE=y
+CONFIG_KRG_MONOLITHIC=y
+CONFIG_AUTOLOAD_PLUGINS=y
+CONFIG_CLUSTER_WIDE_PROC=y
+# CONFIG_DEBUG_SEG_FAULT is not set
+
+#
 # Kernel hacking
 #
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
diff -Nupr a/arch/i386/Kconfig b/arch/i386/Kconfig
--- a/arch/i386/Kconfig	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/i386/Kconfig	2007-02-26 15:35:07.000000000 +0100
@@ -1192,6 +1192,8 @@ endmenu
 
 source "net/Kconfig"
 
+source "kerrighed/Kconfig.Kerrighed"
+
 source "drivers/Kconfig"
 
 source "fs/Kconfig"
diff -Nupr a/arch/i386/kdb/ChangeLog b/arch/i386/kdb/ChangeLog
--- a/arch/i386/kdb/ChangeLog	2007-06-05 17:06:30.000000000 +0200
+++ b/arch/i386/kdb/ChangeLog	2007-05-10 12:33:18.000000000 +0200
@@ -1,3 +1,13 @@
+2007-03-01 Keith Owens  <kaos@sgi.com>
+
+	* Remove sparse warnings.
+	* kdb v4.4-2.6.20-i386-3.
+
+2007-02-16 Keith Owens  <kaos@sgi.com>
+
+	* Initialise variable bits of struct disassemble_info each time.
+	* kdb v4.4-2.6.20-i386-2.
+
 2007-02-06 Keith Owens  <kaos@sgi.com>
 
 	* kdb v4.4-2.6.20-i386-1.
diff -Nupr a/arch/i386/kdb/kdba_id.c b/arch/i386/kdb/kdba_id.c
--- a/arch/i386/kdb/kdba_id.c	2007-06-05 17:06:30.000000000 +0200
+++ b/arch/i386/kdb/kdba_id.c	2007-05-10 12:33:18.000000000 +0200
@@ -239,7 +239,7 @@ kdba_id_printinsn(kdb_machreg_t pc, disa
  * Remarks:
  */
 
-void __init
+void
 kdba_id_init(disassemble_info *dip)
 {
 	dip->read_memory_func       = kdba_dis_getmem;
diff -Nupr a/arch/i386/kdb/kdbasupport.c b/arch/i386/kdb/kdbasupport.c
--- a/arch/i386/kdb/kdbasupport.c	2007-06-05 17:06:30.000000000 +0200
+++ b/arch/i386/kdb/kdbasupport.c	2007-05-10 12:33:18.000000000 +0200
@@ -816,7 +816,7 @@ static int
 kdba_stackdepth(int argc, const char **argv)
 {
 	int diag, cpu, threshold, used, over;
-	long percentage;
+	unsigned long percentage;
 	unsigned long esp;
 	long offset = 0;
 	int nextarg;
diff -Nupr a/arch/i386/kernel/cpu/proc.c b/arch/i386/kernel/cpu/proc.c
--- a/arch/i386/kernel/cpu/proc.c	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/i386/kernel/cpu/proc.c	2007-05-30 20:10:23.000000000 +0200
@@ -8,7 +8,10 @@
 /*
  *	Get CPU information for use by the procfs.
  */
-static int show_cpuinfo(struct seq_file *m, void *v)
+#ifndef CONFIG_KRG_PROCFS
+static
+#endif
+int show_cpuinfo(struct seq_file *m, void *v)
 {
 	/* 
 	 * These flag bits must match the definitions in <asm/cpufeature.h>.
@@ -73,13 +76,23 @@ static int show_cpuinfo(struct seq_file 
 		/* nothing */	/* constant_tsc - moved to flags */
 	};
 	struct cpuinfo_x86 *c = v;
+#ifdef CONFIG_KRG_PROCFS
+	int i, n = c->krg_cpu_id;
+	unsigned long cpu_khz = c->cpu_khz;
+#else // CONFIG_KRG_PROCFS
 	int i, n = c - cpu_data;
+#endif // CONFIG_KRG_PROCFS
 	int fpu_exception;
 
 #ifdef CONFIG_SMP
+#ifndef CONFIG_KERRIGHED
+	// since there are more processors than those physically available
+	// we must not do this test
+#else
 	if (!cpu_online(n))
 		return 0;
 #endif
+#endif
 	seq_printf(m, "processor\t: %d\n"
 		"vendor_id\t: %s\n"
 		"cpu family\t: %d\n"
diff -Nupr a/arch/i386/kernel/ldt.c b/arch/i386/kernel/ldt.c
--- a/arch/i386/kernel/ldt.c	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/i386/kernel/ldt.c	2007-03-02 18:26:40.000000000 +0100
@@ -28,7 +28,10 @@ static void flush_ldt(void *null)
 }
 #endif
 
-static int alloc_ldt(mm_context_t *pc, int mincount, int reload)
+#ifndef CONFIG_KRG_MM
+static
+#endif
+int alloc_ldt(mm_context_t *pc, int mincount, int reload)
 {
 	void *oldldt;
 	void *newldt;
diff -Nupr a/arch/i386/kernel/process.c b/arch/i386/kernel/process.c
--- a/arch/i386/kernel/process.c	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/i386/kernel/process.c	2007-03-28 12:21:08.000000000 +0200
@@ -417,6 +417,9 @@ int copy_thread(int nr, unsigned long cl
 
 	childregs = task_pt_regs(p);
 	*childregs = *regs;
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current)
+#endif
 	childregs->eax = 0;
 	childregs->esp = esp;
 
@@ -425,6 +428,9 @@ int copy_thread(int nr, unsigned long cl
 
 	p->thread.eip = (unsigned long) ret_from_fork;
 
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current)
+#endif
 	savesegment(fs,p->thread.fs);
 
 	tsk = current;
diff -Nupr a/arch/x86_64/defconfig b/arch/x86_64/defconfig
--- a/arch/x86_64/defconfig	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/x86_64/defconfig	2007-02-26 18:51:03.000000000 +0100
@@ -127,13 +127,13 @@ CONFIG_X86_HT=y
 CONFIG_X86_IO_APIC=y
 CONFIG_X86_LOCAL_APIC=y
 CONFIG_MTRR=y
-CONFIG_SMP=y
+# CONFIG_SMP is not set
 CONFIG_SCHED_SMT=y
 CONFIG_SCHED_MC=y
 # CONFIG_PREEMPT_NONE is not set
-CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
-CONFIG_PREEMPT_BKL=y
+# CONFIG_PREEMPT_BKL is not set
 CONFIG_NUMA=y
 CONFIG_K8_NUMA=y
 CONFIG_NODES_SHIFT=6
diff -Nupr a/arch/x86_64/Kconfig b/arch/x86_64/Kconfig
--- a/arch/x86_64/Kconfig	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/x86_64/Kconfig	2007-04-27 23:18:30.000000000 +0200
@@ -711,6 +711,8 @@ endmenu
 
 source "net/Kconfig"
 
+source "kerrighed/Kconfig.Kerrighed"
+
 source drivers/Kconfig
 
 source "drivers/firmware/Kconfig"
diff -Nupr a/arch/x86_64/kdb/ChangeLog b/arch/x86_64/kdb/ChangeLog
--- a/arch/x86_64/kdb/ChangeLog	2007-06-05 17:06:30.000000000 +0200
+++ b/arch/x86_64/kdb/ChangeLog	2007-05-10 13:50:58.000000000 +0200
@@ -1,3 +1,13 @@
+2007-03-01 Keith Owens  <kaos@sgi.com>
+
+	* Remove sparse warnings.
+	* kdb v4.4-2.6.20-x86_64-3.
+
+2007-02-16 Keith Owens  <kaos@sgi.com>
+
+	* Initialise variable bits of struct disassemble_info each time.
+	* kdb v4.4-2.6.20-x86_64-2.
+
 2007-02-06 Keith Owens  <kaos@sgi.com>
 
 	* kdb v4.4-2.6.20-x86_64-1.
diff -Nupr a/arch/x86_64/kdb/kdba_bp.c b/arch/x86_64/kdb/kdba_bp.c
--- a/arch/x86_64/kdb/kdba_bp.c	2007-06-05 17:06:30.000000000 +0200
+++ b/arch/x86_64/kdb/kdba_bp.c	2007-05-10 13:50:58.000000000 +0200
@@ -412,7 +412,7 @@ kdba_bptype(kdbhard_bp_t *bph)
  * Remarks:
  */
 
-void
+static void
 kdba_printbpreg(kdbhard_bp_t *bph)
 {
 	kdb_printf(" in dr%ld", bph->bph_reg);
diff -Nupr a/arch/x86_64/kdb/kdba_id.c b/arch/x86_64/kdb/kdba_id.c
--- a/arch/x86_64/kdb/kdba_id.c	2007-06-05 17:06:30.000000000 +0200
+++ b/arch/x86_64/kdb/kdba_id.c	2007-05-10 13:50:58.000000000 +0200
@@ -56,7 +56,7 @@ kdba_dis_getsym(bfd_vma addr, disassembl
  */
 
 /* ARGSUSED */
-void
+static void
 kdba_printaddress(kdb_machreg_t addr, disassemble_info *dip, int flag)
 {
 	kdb_symtab_t symtab;
@@ -240,7 +240,7 @@ kdba_id_printinsn(kdb_machreg_t pc, disa
  * Remarks:
  */
 
-void __init
+void
 kdba_id_init(disassemble_info *dip)
 {
 	dip->read_memory_func       = kdba_dis_getmem;
diff -Nupr a/arch/x86_64/kdb/kdbasupport.c b/arch/x86_64/kdb/kdbasupport.c
--- a/arch/x86_64/kdb/kdbasupport.c	2007-06-05 17:06:30.000000000 +0200
+++ b/arch/x86_64/kdb/kdbasupport.c	2007-05-10 13:50:58.000000000 +0200
@@ -793,7 +793,8 @@ static int
 kdba_cpu_pda(int argc, const char **argv)
 {
 	int diag, nextarg, all_cpus = 0;
-	long cpu, offset = 0;
+	long offset = 0;
+	unsigned long cpu;
 	struct x8664_pda *c;
 	static const char *fmtl = "  %-17.17s 0x%lx\n";
 	static const char *fmtd = "  %-17.17s %d\n";
@@ -980,6 +981,7 @@ smp_kdb_stop(void)
 }
 
 /* The normal KDB IPI handler */
+extern asmlinkage void smp_kdb_interrupt(struct pt_regs *regs);	/* for sparse */
 asmlinkage void
 smp_kdb_interrupt(struct pt_regs *regs)
 {
diff -Nupr a/arch/x86_64/kernel/ldt.c b/arch/x86_64/kernel/ldt.c
--- a/arch/x86_64/kernel/ldt.c	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/x86_64/kernel/ldt.c	2007-04-28 14:34:52.000000000 +0200
@@ -31,7 +31,10 @@ static void flush_ldt(void *null)
 }
 #endif
 
-static int alloc_ldt(mm_context_t *pc, unsigned mincount, int reload)
+#ifndef CONFIG_KRG_MM
+static
+#endif
+int alloc_ldt(mm_context_t *pc, int mincount, int reload)
 {
 	void *oldldt;
 	void *newldt;
diff -Nupr a/arch/x86_64/kernel/process.c b/arch/x86_64/kernel/process.c
--- a/arch/x86_64/kernel/process.c	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/x86_64/kernel/process.c	2007-03-28 12:21:08.000000000 +0200
@@ -463,6 +463,9 @@ int copy_thread(int nr, unsigned long cl
 			(THREAD_SIZE + task_stack_page(p))) - 1;
 	*childregs = *regs;
 
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current)
+#endif
 	childregs->rax = 0;
 	childregs->rsp = rsp;
 	if (rsp == ~0UL)
@@ -477,10 +480,16 @@ int copy_thread(int nr, unsigned long cl
 	p->thread.fs = me->thread.fs;
 	p->thread.gs = me->thread.gs;
 
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current) {
+#endif
 	asm("mov %%gs,%0" : "=m" (p->thread.gsindex));
 	asm("mov %%fs,%0" : "=m" (p->thread.fsindex));
 	asm("mov %%es,%0" : "=m" (p->thread.es));
 	asm("mov %%ds,%0" : "=m" (p->thread.ds));
+#ifdef CONFIG_KRG_EPM
+	}
+#endif
 
 	if (unlikely(test_tsk_thread_flag(me, TIF_IO_BITMAP))) {
 		p->thread.io_bitmap_ptr = kmalloc(IO_BITMAP_BYTES, GFP_KERNEL);
diff -Nupr a/arch/x86_64/kernel/setup.c b/arch/x86_64/kernel/setup.c
--- a/arch/x86_64/kernel/setup.c	2007-02-04 19:44:54.000000000 +0100
+++ b/arch/x86_64/kernel/setup.c	2007-02-28 15:51:33.000000000 +0100
@@ -1039,8 +1039,10 @@ void __cpuinit print_cpu_info(struct cpu
 /*
  *	Get CPU information for use by the procfs.
  */
-
-static int show_cpuinfo(struct seq_file *m, void *v)
+#ifndef CONFIG_KRG_PROCFS
+static
+#endif
+int show_cpuinfo(struct seq_file *m, void *v)
 {
 	struct cpuinfo_x86 *c = v;
 
@@ -1118,7 +1120,11 @@ static int show_cpuinfo(struct seq_file 
 		     "cpu family\t: %d\n"
 		     "model\t\t: %d\n"
 		     "model name\t: %s\n",
+#ifdef CONFIG_KRG_PROCFS
+		     (unsigned)(c->krg_cpu_id),
+#else
 		     (unsigned)(c-cpu_data),
+#endif
 		     c->x86_vendor_id[0] ? c->x86_vendor_id : "unknown",
 		     c->x86,
 		     (int)c->x86_model,
@@ -1130,9 +1136,13 @@ static int show_cpuinfo(struct seq_file 
 		seq_printf(m, "stepping\t: unknown\n");
 	
 	if (cpu_has(c,X86_FEATURE_TSC)) {
+#ifdef CONFIG_KRG_PROCFS
+		unsigned int freq = c->cpu_khz;
+#else
 		unsigned int freq = cpufreq_quick_get((unsigned)(c-cpu_data));
 		if (!freq)
 			freq = cpu_khz;
+#endif
 		seq_printf(m, "cpu MHz\t\t: %u.%03u\n",
 			     freq / 1000, (freq % 1000));
 	}
diff -Nupr a/drivers/char/tty_io.c b/drivers/char/tty_io.c
--- a/drivers/char/tty_io.c	2007-02-04 19:44:54.000000000 +0100
+++ b/drivers/char/tty_io.c	2007-03-07 17:29:15.000000000 +0100
@@ -1149,7 +1149,11 @@ static int hung_up_tty_ioctl(struct inod
 	return cmd == TIOCSPGRP ? -ENOTTY : -EIO;
 }
 
+#ifdef CONFIG_KRG_DVFS
+const struct file_operations tty_fops = {
+#else // CONFIG_KRG_DVFS
 static const struct file_operations tty_fops = {
+#endif // CONFIG_KRG_DVFS
 	.llseek		= no_llseek,
 	.read		= tty_read,
 	.write		= tty_write,
diff -Nupr a/fs/binfmt_aout.c b/fs/binfmt_aout.c
--- a/fs/binfmt_aout.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/binfmt_aout.c	2007-03-28 12:21:08.000000000 +0200
@@ -24,6 +24,9 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 #include <linux/init.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -549,11 +552,24 @@ out:
 
 static int __init init_aout_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	int retval;
+
+	krgsyms_register(KRGSYMS_BINFMTS_AOUT, &aout_format);
+	retval = register_binfmt(&aout_format);
+	if (retval)
+		krgsyms_unregister(KRGSYMS_BINFMTS_AOUT);
+	return retval;
+#else
 	return register_binfmt(&aout_format);
+#endif
 }
 
 static void __exit exit_aout_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_BINFMTS_AOUT);
+#endif
 	unregister_binfmt(&aout_format);
 }
 
diff -Nupr a/fs/binfmt_elf.c b/fs/binfmt_elf.c
--- a/fs/binfmt_elf.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/binfmt_elf.c	2007-03-28 12:21:08.000000000 +0200
@@ -39,6 +39,9 @@
 #include <linux/syscalls.h>
 #include <linux/random.h>
 #include <linux/elf.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
@@ -1753,12 +1756,25 @@ cleanup:
 
 static int __init init_elf_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	int retval;
+
+	krgsyms_register(KRGSYMS_BINFMTS_ELF, &elf_format);
+	retval = register_binfmt(&elf_format);
+	if (retval)
+		krgsyms_unregister(KRGSYMS_BINFMTS_ELF);
+	return retval;
+#else
 	return register_binfmt(&elf_format);
+#endif
 }
 
 static void __exit exit_elf_binfmt(void)
 {
 	/* Remove the COFF and ELF loaders. */
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_BINFMTS_ELF);
+#endif
 	unregister_binfmt(&elf_format);
 }
 
diff -Nupr a/fs/binfmt_elf_fdpic.c b/fs/binfmt_elf_fdpic.c
--- a/fs/binfmt_elf_fdpic.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/binfmt_elf_fdpic.c	2007-03-28 12:21:08.000000000 +0200
@@ -34,6 +34,9 @@
 #include <linux/elf.h>
 #include <linux/elf-fdpic.h>
 #include <linux/elfcore.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
@@ -90,11 +93,24 @@ static struct linux_binfmt elf_fdpic_for
 
 static int __init init_elf_fdpic_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	int retval;
+
+	krgsyms_register(KRGSYMS_BINFMTS_ELF_FDPIC, &elf_fdpic_format);
+	retval = register_binfmt(&elf_fdpic_format);
+	if (retval)
+		krgsyms_unregister(KRGSYMS_BINFMTS_ELF_FDPIC);
+	return retval;
+#else
 	return register_binfmt(&elf_fdpic_format);
+#endif
 }
 
 static void __exit exit_elf_fdpic_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_BINFMTS_ELF_FDPIC);
+#endif
 	unregister_binfmt(&elf_fdpic_format);
 }
 
diff -Nupr a/fs/binfmt_em86.c b/fs/binfmt_em86.c
--- a/fs/binfmt_em86.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/binfmt_em86.c	2007-03-28 12:21:08.000000000 +0200
@@ -19,6 +19,9 @@
 #include <linux/fs.h>
 #include <linux/file.h>
 #include <linux/errno.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 
 #define EM86_INTERP	"/usr/bin/em86"
@@ -102,11 +105,24 @@ static struct linux_binfmt em86_format =
 
 static int __init init_em86_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	int retval;
+
+	krgsyms_register(KRGSYMS_BINFMTS_EM86, &em86_format);
+	retval = register_binfmt(&em86_format);
+	if (retval)
+		krgsyms_unregister(KRGSYMS_BINFMTS_EM86);
+	return retval;
+#else
 	return register_binfmt(&em86_format);
+#endif
 }
 
 static void __exit exit_em86_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_BINFMTS_EM86);
+#endif
 	unregister_binfmt(&em86_format);
 }
 
diff -Nupr a/fs/binfmt_flat.c b/fs/binfmt_flat.c
--- a/fs/binfmt_flat.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/binfmt_flat.c	2007-03-28 12:21:08.000000000 +0200
@@ -36,6 +36,9 @@
 #include <linux/init.h>
 #include <linux/flat.h>
 #include <linux/syscalls.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/byteorder.h>
 #include <asm/system.h>
@@ -907,11 +910,24 @@ static int load_flat_binary(struct linux
 
 static int __init init_flat_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	int retval;
+
+	krgsyms_register(KRGSYMS_BINFMTS_FLAT, &flat_format);
+	retval = register_binfmt(&flat_format);
+	if (retval)
+		krgsyms_unregister(KRGSYMS_BINFMTS_FLAT);
+	return retval;
+#else
 	return register_binfmt(&flat_format);
+#endif
 }
 
 static void __exit exit_flat_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_BINFMTS_FLAT);
+#endif
 	unregister_binfmt(&flat_format);
 }
 
diff -Nupr a/fs/binfmt_misc.c b/fs/binfmt_misc.c
--- a/fs/binfmt_misc.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/binfmt_misc.c	2007-03-28 12:21:08.000000000 +0200
@@ -27,6 +27,9 @@
 #include <linux/namei.h>
 #include <linux/mount.h>
 #include <linux/syscalls.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/uaccess.h>
 
@@ -759,15 +762,25 @@ static int __init init_misc_binfmt(void)
 {
 	int err = register_filesystem(&bm_fs_type);
 	if (!err) {
+#ifdef CONFIG_KRG_EPM
+		krgsyms_register(KRGSYMS_BINFMTS_MISC, &misc_format);
+#endif
 		err = register_binfmt(&misc_format);
 		if (err)
 			unregister_filesystem(&bm_fs_type);
+#ifdef CONFIG_KRG_EPM
+		if (err)
+			krgsyms_unregister(KRGSYMS_BINFMTS_MISC);
+#endif
 	}
 	return err;
 }
 
 static void __exit exit_misc_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_BINFMTS_MISC);
+#endif
 	unregister_binfmt(&misc_format);
 	unregister_filesystem(&bm_fs_type);
 }
diff -Nupr a/fs/binfmt_script.c b/fs/binfmt_script.c
--- a/fs/binfmt_script.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/binfmt_script.c	2007-03-28 12:21:08.000000000 +0200
@@ -15,6 +15,9 @@
 #include <linux/smp_lock.h>
 #include <linux/err.h>
 #include <linux/fs.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 static int load_script(struct linux_binprm *bprm,struct pt_regs *regs)
 {
@@ -103,11 +106,24 @@ static struct linux_binfmt script_format
 
 static int __init init_script_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	int retval;
+
+	krgsyms_register(KRGSYMS_BINFMTS_SCRIPT, &script_format);
+	retval = register_binfmt(&script_format);
+	if (retval)
+		krgsyms_unregister(KRGSYMS_BINFMTS_SCRIPT);
+	return retval;
+#else
 	return register_binfmt(&script_format);
+#endif
 }
 
 static void __exit exit_script_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_BINFMTS_SCRIPT);
+#endif
 	unregister_binfmt(&script_format);
 }
 
diff -Nupr a/fs/binfmt_som.c b/fs/binfmt_som.c
--- a/fs/binfmt_som.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/binfmt_som.c	2007-03-28 12:21:08.000000000 +0200
@@ -28,6 +28,9 @@
 #include <linux/shm.h>
 #include <linux/personality.h>
 #include <linux/init.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/a.out.h>
 #include <asm/uaccess.h>
@@ -308,12 +311,25 @@ static int load_som_library(struct file 
 
 static int __init init_som_binfmt(void)
 {
+#ifdef CONFIG_KRG_EPM
+	int retval;
+
+	krgsyms_register(KRGSYMS_BINFMTS_SOM, &som_format);
+	retval = register_binfmt(&som_format);
+	if (retval)
+		krgsyms_unregister(KRGSYMS_BINFMTS_SOM);
+	return retval;
+#else
 	return register_binfmt(&som_format);
+#endif
 }
 
 static void __exit exit_som_binfmt(void)
 {
 	/* Remove the SOM loader. */
+#ifdef CONFIG_KRG_EPM
+	krgsyms_unregister(KRGSYMS_BINFMTS_SOM);
+#endif
 	unregister_binfmt(&som_format);
 }
 
diff -Nupr a/fs/dcache.c b/fs/dcache.c
--- a/fs/dcache.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/dcache.c	2007-03-07 17:29:15.000000000 +0100
@@ -1747,7 +1747,11 @@ shouldnt_be_hashed:
  *
  * "buflen" should be positive. Caller holds the dcache_lock.
  */
+#ifdef CONFIG_KRG_DVFS
+char * __d_path( struct dentry *dentry, struct vfsmount *vfsmnt,
+#else
 static char * __d_path( struct dentry *dentry, struct vfsmount *vfsmnt,
+#endif // CONFIG_KRG_DVFS
 			struct dentry *root, struct vfsmount *rootmnt,
 			char *buffer, int buflen)
 {
diff -Nupr a/fs/exec.c b/fs/exec.c
--- a/fs/exec.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/exec.c	2007-03-28 12:21:08.000000000 +0200
@@ -50,6 +50,14 @@
 #include <linux/tsacct_kern.h>
 #include <linux/cn_proc.h>
 #include <linux/audit.h>
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/task.h>
+#include <kerrighed/krginit.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/children.h>
+#include <kerrighed/signal.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -664,6 +672,13 @@ static int de_thread(struct task_struct 
 	 * and to assume its PID:
 	 */
 	if (!thread_group_leader(tsk)) {
+#ifdef CONFIG_KRG_PROC
+		struct task_ctnr_object *obj = NULL;
+#ifdef CONFIG_KRG_EPM
+		struct children_ctnr_object *parent_children_obj = NULL;
+		pid_t real_parent_tgid;
+#endif
+#endif
 		/*
 		 * Wait for the thread group leader to be a zombie.
 		 * It should already be zombie at this point, most
@@ -672,6 +687,23 @@ static int de_thread(struct task_struct 
 		leader = tsk->group_leader;
 		while (leader->exit_state != EXIT_ZOMBIE)
 			yield();
+#ifdef CONFIG_KRG_PROC
+		down_read(&kerrighed_init_sem);
+
+		/* tsk->pid will disappear just below. */
+#ifdef CONFIG_KRG_EPM
+		if (kh_parent_children_writelock) {
+			parent_children_obj =
+				kh_parent_children_writelock(tsk,
+							     &real_parent_tgid);
+			kh_remove_child(parent_children_obj, tsk->pid);
+		}
+#endif
+		KRGFCT(kh_free_task_struct)(tsk);
+
+		if (kh_task_writelock)
+			obj = kh_task_writelock(leader->pid);
+#endif
 
 		/*
 		 * The only record we have of the real-time age of a
@@ -707,6 +739,11 @@ static int de_thread(struct task_struct 
 		transfer_pid(leader, tsk, PIDTYPE_PGID);
 		transfer_pid(leader, tsk, PIDTYPE_SID);
 		list_replace_rcu(&leader->tasks, &tsk->tasks);
+#ifdef CONFIG_KRG_PROC
+		if (likely(obj))
+			obj->task = tsk;
+		tsk->task_ctnr = obj;
+#endif
 
 		tsk->group_leader = tsk;
 		leader->group_leader = tsk;
@@ -717,6 +754,20 @@ static int de_thread(struct task_struct 
 		leader->exit_state = EXIT_DEAD;
 
 		write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+		/* tsk has taken leader's pid. */
+		kh_task_unlock(tsk->pid);
+#ifdef CONFIG_KRG_EPM
+		if (parent_children_obj) {
+			kh_set_child_exit_signal(parent_children_obj,
+						 tsk->pid,
+						 tsk->exit_signal);
+			kh_children_unlock(real_parent_tgid);
+		}
+#endif
+
+		up_read(&kerrighed_init_sem);
+#endif
         }
 
 	/*
@@ -746,6 +797,11 @@ no_thread_group:
 		atomic_set(&newsighand->count, 1);
 		memcpy(newsighand->action, oldsighand->action,
 		       sizeof(newsighand->action));
+#ifdef CONFIG_KRG_EPM
+		newsighand->krg_objid = 0;
+
+		down_read(&kerrighed_init_sem);
+#endif
 
 		write_lock_irq(&tasklist_lock);
 		spin_lock(&oldsighand->siglock);
@@ -757,9 +813,25 @@ no_thread_group:
 		spin_unlock(&newsighand->siglock);
 		spin_unlock(&oldsighand->siglock);
 		write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+		KRGFCT(kh_malloc_sighand_struct)(tsk, 1);
+		{
+			unsigned long sighand_id = 0;
+
+			if (kh_exit_sighand)
+				sighand_id =
+					kh_exit_sighand(oldsighand->krg_objid);
+#endif
 
 		if (atomic_dec_and_test(&oldsighand->count))
 			kmem_cache_free(sighand_cachep, oldsighand);
+#ifdef CONFIG_KRG_EPM
+			if (sighand_id)
+				kh_sighand_struct_unlock(sighand_id);
+		}
+
+		up_read(&kerrighed_init_sem);
+#endif
 	}
 
 	BUG_ON(!thread_group_leader(tsk));
diff -Nupr a/fs/fcntl.c b/fs/fcntl.c
--- a/fs/fcntl.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/fcntl.c	2007-05-24 10:01:16.000000000 +0200
@@ -22,6 +22,9 @@
 #include <asm/poll.h>
 #include <asm/siginfo.h>
 #include <asm/uaccess.h>
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
 
 void fastcall set_close_on_exec(unsigned int fd, int flag)
 {
@@ -391,6 +394,16 @@ asmlinkage long sys_fcntl(unsigned int f
 	if (!filp)
 		goto out;
 
+#ifdef CONFIG_KRG_FAF
+	if ((filp->f_flags & O_FAF_CLT) && (cmd != F_DUPFD)) {
+	    if (kh_faf_fcntl)
+		err = kh_faf_fcntl(filp, cmd, arg);
+	    else
+		BUG();
+	    fput(filp);
+	    goto out;
+	}
+#endif
 	err = security_file_fcntl(filp, cmd, arg);
 	if (err) {
 		fput(filp);
@@ -415,6 +428,17 @@ asmlinkage long sys_fcntl64(unsigned int
 	if (!filp)
 		goto out;
 
+#ifdef CONFIG_KRG_FAF
+	if ((filp->f_flags & O_FAF_CLT) && (cmd != F_DUPFD)) {
+		if (kh_faf_fcntl64)
+			err = kh_faf_fcntl64(filp, cmd, arg);
+		else
+			BUG();
+		fput(filp);
+		goto out;
+	}
+#endif // CONFIG_KRG_FAF
+
 	err = security_file_fcntl(filp, cmd, arg);
 	if (err) {
 		fput(filp);
diff -Nupr a/fs/file.c b/fs/file.c
--- a/fs/file.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/file.c	2007-03-07 17:29:15.000000000 +0100
@@ -132,7 +132,10 @@ static void copy_fdtable(struct fdtable 
 	memset((char *)(nfdt->close_on_exec) + cpy, 0, set);
 }
 
-static struct fdtable * alloc_fdtable(unsigned int nr)
+#ifndef CONFIG_KRG_DVFS
+static
+#endif
+struct fdtable * alloc_fdtable(unsigned int nr)
 {
 	struct fdtable *fdt;
 	char *data;
diff -Nupr a/fs/file_table.c b/fs/file_table.c
--- a/fs/file_table.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/file_table.c	2007-05-16 13:12:13.000000000 +0200
@@ -24,6 +24,13 @@
 
 #include <asm/atomic.h>
 
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
+#ifdef CONFIG_KRG_DVFS
+#include <kerrighed/dvfs.h>
+#endif
+
 /* sysctl tunables... */
 struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
@@ -42,6 +49,10 @@ static inline void file_free_rcu(struct 
 
 static inline void file_free(struct file *f)
 {
+#ifdef CONFIG_KRG_DVFS
+	if (f->f_objid && kh_put_file)
+		kh_put_file(f);
+#endif
 	percpu_counter_dec(&nr_files);
 	call_rcu(&f->f_u.fu_rcuhead, file_free_rcu);
 }
@@ -154,10 +165,23 @@ void fastcall __fput(struct file *file)
 {
 	struct dentry *dentry = file->f_path.dentry;
 	struct vfsmount *mnt = file->f_path.mnt;
+#ifdef CONFIG_KRG_FAF
+	struct inode *inode;
+#else
 	struct inode *inode = dentry->d_inode;
+#endif
 
 	might_sleep();
 
+#ifdef CONFIG_KRG_FAF
+	if (file->f_flags & O_FAF_CLT) {
+		security_file_free(file);
+		file_kill(file);
+		file_free(file);
+		return;
+	}
+	inode = dentry->d_inode;
+#endif
 	fsnotify_close(file);
 	/*
 	 * The function eventpoll_release() should be the first called
diff -Nupr a/fs/inode.c b/fs/inode.c
--- a/fs/inode.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/inode.c	2007-03-29 18:42:55.000000000 +0200
@@ -134,6 +134,9 @@ static struct inode *alloc_inode(struct 
 		inode->i_cdev = NULL;
 		inode->i_rdev = 0;
 		inode->dirtied_when = 0;
+#ifdef CONFIG_KRG_DVFS
+		inode->i_objid = 0 ;
+#endif // CONFIG_KRG_DVFS
 		if (security_inode_alloc(inode)) {
 			if (inode->i_sb->s_op->destroy_inode)
 				inode->i_sb->s_op->destroy_inode(inode);
@@ -142,6 +145,9 @@ static struct inode *alloc_inode(struct 
 			return NULL;
 		}
 
+#ifdef CONFIG_KRG_DVFS
+		mapping->kddm_set = NULL;
+#endif // CONFIG_KRG_DVFS
 		mapping->a_ops = &empty_aops;
  		mapping->host = inode;
 		mapping->flags = 0;
diff -Nupr a/fs/ioctl.c b/fs/ioctl.c
--- a/fs/ioctl.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/ioctl.c	2007-03-07 17:29:15.000000000 +0100
@@ -16,6 +16,10 @@
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
+
 static long do_ioctl(struct file *filp, unsigned int cmd,
 		unsigned long arg)
 {
@@ -165,7 +169,15 @@ asmlinkage long sys_ioctl(unsigned int f
 	filp = fget_light(fd, &fput_needed);
 	if (!filp)
 		goto out;
-
+#ifdef CONFIG_KRG_FAF
+	if (filp->f_flags & O_FAF_CLT) {
+		if (kh_faf_ioctl)
+			error = kh_faf_ioctl(filp, cmd, arg);
+		else
+			BUG();
+		goto out_fput;
+	}
+#endif // CONFIG_KRG_FAF
 	error = security_file_ioctl(filp, cmd, arg);
 	if (error)
 		goto out_fput;
diff -Nupr a/fs/locks.c b/fs/locks.c
--- a/fs/locks.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/locks.c	2007-05-29 14:47:54.000000000 +0200
@@ -1578,6 +1578,16 @@ asmlinkage long sys_flock(unsigned int f
 	if (!filp)
 		goto out;
 
+#ifdef CONFIG_KRG_FAF
+	if (filp->f_flags & O_FAF_CLT) {
+		if (kh_faf_flock)
+			error = kh_faf_flock(filp, cmd);
+		else
+			BUG();
+		goto out_putf;
+	}
+#endif
+
 	can_sleep = !(cmd & LOCK_NB);
 	cmd &= ~LOCK_NB;
 	unlock = (cmd == LOCK_UN);
diff -Nupr a/fs/open.c b/fs/open.c
--- a/fs/open.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/open.c	2007-04-18 17:08:10.000000000 +0200
@@ -27,6 +27,9 @@
 #include <linux/syscalls.h>
 #include <linux/rcupdate.h>
 #include <linux/audit.h>
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
 
 int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
@@ -853,9 +856,15 @@ EXPORT_SYMBOL(dentry_open);
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
+#ifdef CONFIG_KRG_FAF
+int __get_unused_fd(struct task_struct *tsk)
+{
+        struct files_struct * files = tsk->files;
+#else // CONFIG_KRG_FAF
 int get_unused_fd(void)
 {
 	struct files_struct * files = current->files;
+#endif
 	int fd, error;
 	struct fdtable *fdt;
 
@@ -871,7 +880,11 @@ repeat:
 	 * N.B. For clone tasks sharing a files structure, this test
 	 * will limit the total number of files that can be opened.
 	 */
+#ifdef CONFIG_KRG_FAF
+	if (fd >= tsk->signal->rlim[RLIMIT_NOFILE].rlim_cur)
+#else
 	if (fd >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
+#endif
 		goto out;
 
 	/* Do we need to expand the fd array or fd set?  */
@@ -907,7 +920,10 @@ out:
 
 EXPORT_SYMBOL(get_unused_fd);
 
-static void __put_unused_fd(struct files_struct *files, unsigned int fd)
+#ifndef CONFIG_KRG_FAF
+static
+#endif
+void __put_unused_fd(struct files_struct *files, unsigned int fd)
 {
 	struct fdtable *fdt = files_fdtable(files);
 	__FD_CLR(fd, fdt->open_fds);
@@ -938,9 +954,15 @@ EXPORT_SYMBOL(put_unused_fd);
  * will follow.
  */
 
+#ifdef CONFIG_KRG_FAF
+void fastcall __fd_install(struct task_struct *tsk, unsigned int fd, struct file * file)
+{
+	struct files_struct *files = tsk->files;
+#else
 void fastcall fd_install(unsigned int fd, struct file * file)
 {
 	struct files_struct *files = current->files;
+#endif
 	struct fdtable *fdt;
 	spin_lock(&files->file_lock);
 	fdt = files_fdtable(files);
@@ -1018,7 +1040,11 @@ asmlinkage long sys_creat(const char __u
  * "id" is the POSIX thread ID. We use the
  * files pointer for this..
  */
+#ifdef CONFIG_KRG_FAF
+int __filp_close(struct file *filp, fl_owner_t id)
+#else
 int filp_close(struct file *filp, fl_owner_t id)
+#endif
 {
 	int retval = 0;
 
@@ -1030,6 +1056,12 @@ int filp_close(struct file *filp, fl_own
 	if (filp->f_op && filp->f_op->flush)
 		retval = filp->f_op->flush(filp, id);
 
+#ifdef CONFIG_KRG_FAF
+	if (filp->f_flags & O_FAF_CLT) {
+		fput(filp);
+		return retval;
+	}
+#endif // CONFIG_KRG_FAF
 	dnotify_flush(filp, id);
 	locks_remove_posix(filp, id);
 	fput(filp);
diff -Nupr a/fs/proc/array.c b/fs/proc/array.c
--- a/fs/proc/array.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/proc/array.c	2007-04-23 18:42:25.000000000 +0200
@@ -75,6 +75,12 @@
 #include <linux/cpuset.h>
 #include <linux/rcupdate.h>
 #include <linux/delayacct.h>
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+#include <kerrighed/procfs.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/children.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -161,8 +167,17 @@ static inline char * task_state(struct t
 	struct group_info *group_info;
 	int g;
 	struct fdtable *fdt = NULL;
+#ifdef CONFIG_KRG_EPM
+	pid_t real_parent_tgid = 0;
+#endif
 
 	rcu_read_lock();
+#ifdef CONFIG_KRG_EPM
+	if (kh_get_real_parent_tgid)
+		real_parent_tgid = kh_get_real_parent_tgid(p);
+	else if (pid_alive(p))
+		real_parent_tgid = rcu_dereference(p->real_parent)->tgid;
+#endif
 	buffer += sprintf(buffer,
 		"State:\t%s\n"
 		"SleepAVG:\t%lu%%\n"
@@ -175,7 +190,11 @@ static inline char * task_state(struct t
 		get_task_state(p),
 		(p->sleep_avg/1024)*100/(1020000000/1024),
 	       	p->tgid, p->pid,
+#ifdef CONFIG_KRG_EPM
+	       	pid_alive(p) ? real_parent_tgid : 0,
+#else
 	       	pid_alive(p) ? rcu_dereference(p->real_parent)->tgid : 0,
+#endif
 		pid_alive(p) && p->ptrace ? rcu_dereference(p->parent)->pid : 0,
 		p->uid, p->euid, p->suid, p->fsuid,
 		p->gid, p->egid, p->sgid, p->fsgid);
@@ -330,6 +349,14 @@ static int do_task_stat(struct task_stru
 	unsigned long rsslim = 0;
 	char tcomm[sizeof(task->comm)];
 	unsigned long flags;
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+	int krg_task_cpu;
+
+	if (kh_task_cpu)
+		krg_task_cpu = kh_task_cpu(task);
+	else
+		krg_task_cpu = task_cpu(task);
+#endif /* CONFIG_KRG_PROCFS && CONFIG_KRG_PROC */
 
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
@@ -383,6 +410,11 @@ static int do_task_stat(struct task_stru
 
 		sid = signal_session(sig);
 		pgid = process_group(task);
+#ifdef CONFIG_KRG_EPM
+		if (kh_get_real_parent_tgid)
+			ppid = kh_get_real_parent_tgid(task);
+		else
+#endif /* CONFIG_KRG_EPM */
 		ppid = rcu_dereference(task->real_parent)->tgid;
 
 		unlock_task_sighand(task, &flags);
@@ -454,7 +486,11 @@ static int do_task_stat(struct task_stru
 		0UL,
 		0UL,
 		task->exit_signal,
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+		krg_task_cpu,
+#else /* CONFIG_KRG_PROCFS && CONFIG_KRG_PROC */
 		task_cpu(task),
+#endif
 		task->rt_priority,
 		task->policy,
 		(unsigned long long)delayacct_blkio_ticks(task));
diff -Nupr a/fs/proc/base.c b/fs/proc/base.c
--- a/fs/proc/base.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/proc/base.c	2007-03-30 18:55:42.000000000 +0200
@@ -67,6 +67,14 @@
 #include <linux/mount.h>
 #include <linux/security.h>
 #include <linux/ptrace.h>
+#ifdef CONFIG_KRG_PROCFS
+#include <kerrighed/procfs.h>
+#include <kerrighed/kernel_headers.h>
+#endif
+#ifdef CONFIG_KRG_PROC
+#include <linux/pid_namespace.h>
+#include <kerrighed/pid.h>
+#endif
 #include <linux/seccomp.h>
 #include <linux/cpuset.h>
 #include <linux/audit.h>
@@ -196,7 +204,10 @@ static int proc_root_link(struct inode *
 	 (task->state == TASK_STOPPED || task->state == TASK_TRACED) && \
 	 security_ptrace(current,task) == 0))
 
-static int proc_pid_environ(struct task_struct *task, char * buffer)
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+int proc_pid_environ(struct task_struct *task, char * buffer)
 {
 	int res = 0;
 	struct mm_struct *mm = get_task_mm(task);
@@ -212,7 +223,10 @@ static int proc_pid_environ(struct task_
 	return res;
 }
 
-static int proc_pid_cmdline(struct task_struct *task, char * buffer)
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+int proc_pid_cmdline(struct task_struct *task, char * buffer)
 {
 	int res = 0;
 	unsigned int len;
@@ -335,7 +349,10 @@ static int proc_fd_access_allowed(struct
 	return allowed;
 }
 
-static int proc_setattr(struct dentry *dentry, struct iattr *attr)
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+int proc_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int error;
 	struct inode *inode = dentry->d_inode;
@@ -352,7 +369,10 @@ static int proc_setattr(struct dentry *d
 	return error;
 }
 
-static struct inode_operations proc_def_inode_operations = {
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+struct inode_operations proc_def_inode_operations = {
 	.setattr	= proc_setattr,
 };
 
@@ -932,8 +952,11 @@ out:
 	return ERR_PTR(error);
 }
 
-static int do_proc_readlink(struct dentry *dentry, struct vfsmount *mnt,
-			    char __user *buffer, int buflen)
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+int do_proc_readlink(struct dentry *dentry, struct vfsmount *mnt,
+		     char __user *buffer, int buflen)
 {
 	struct inode * inode;
 	char *tmp = (char*)__get_free_page(GFP_KERNEL), *path;
@@ -2023,7 +2046,18 @@ struct dentry *proc_pid_lookup(struct in
 		get_task_struct(task);
 	rcu_read_unlock();
 	if (!task)
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+	{
+#ifdef CONFIG_KRG_CAP
+		if (!can_use_krg_cap(current, CAP_SEE_LOCAL_PROC_STAT))
+#endif
+			if (kh_proc_pid_lookup && (tgid & GLOBAL_PID_MASK))
+				result = kh_proc_pid_lookup(dir, dentry, tgid);
+#endif
 		goto out;
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+	}
+#endif
 
 	result = proc_pid_instantiate(dir, dentry, task, NULL);
 	put_task_struct(task);
@@ -2069,7 +2103,10 @@ retry:
 
 #define TGID_OFFSET (FIRST_PROCESS_ENTRY + ARRAY_SIZE(proc_base_stuff))
 
-static int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
+#if !defined(CONFIG_KRG_PROCFS) || !defined(CONFIG_KRG_PROC)
+static
+#endif
+int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
 	struct task_struct *task, int tgid)
 {
 	char name[PROC_NUMBUF];
@@ -2096,6 +2133,14 @@ int proc_pid_readdir(struct file * filp,
 	}
 
 	tgid = filp->f_pos - TGID_OFFSET;
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+	if (kh_proc_pid_readdir
+	    && current->nsproxy->pid_ns == &init_pid_ns) {
+		/* All filling is done by kh_proc_pid_readdir */
+		if (kh_proc_pid_readdir(filp, dirent, filldir, TGID_OFFSET))
+			goto out;
+	} else
+#endif
 	for (task = next_tgid(tgid);
 	     task;
 	     put_task_struct(task), task = next_tgid(tgid + 1)) {
@@ -2106,7 +2151,11 @@ int proc_pid_readdir(struct file * filp,
 			goto out;
 		}
 	}
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+	filp->f_pos = KERRIGHED_PID_MAX_LIMIT + TGID_OFFSET;
+#else
 	filp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;
+#endif
 out:
 	put_task_struct(reaper);
 out_no_task:
diff -Nupr a/fs/proc/inode.c b/fs/proc/inode.c
--- a/fs/proc/inode.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/proc/inode.c	2007-05-02 17:07:43.000000000 +0200
@@ -15,6 +15,9 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/smp_lock.h>
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+#include <kerrighed/task.h>
+#endif
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -63,6 +66,10 @@ static void proc_delete_inode(struct ino
 
 	/* Stop tracking associated processes */
 	put_pid(PROC_I(inode)->pid);
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+	KRGFCT(kh_task_put)(PROC_I(inode)->distant_proc.task_obj);
+	PROC_I(inode)->distant_proc.task_obj = NULL;
+#endif
 
 	/* Let go of any associated proc directory entry */
 	de = PROC_I(inode)->pde;
@@ -95,6 +102,9 @@ static struct inode *proc_alloc_inode(st
 	ei->fd = 0;
 	ei->op.proc_get_link = NULL;
 	ei->pde = NULL;
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+	ei->distant_proc.task_obj = NULL;
+#endif
 	inode = &ei->vfs_inode;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	return inode;
@@ -168,6 +178,9 @@ struct inode *proc_get_inode(struct supe
 			inode->i_uid = de->uid;
 			inode->i_gid = de->gid;
 		}
+#ifdef CONFIG_KRG_PROCFS
+		PROC_I(inode)->krg_procfs_private = de->data;
+#endif /* CONFIG_KRG_PROCFS */
 		if (de->size)
 			inode->i_size = de->size;
 		if (de->nlink)
diff -Nupr a/fs/read_write.c b/fs/read_write.c
--- a/fs/read_write.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/read_write.c	2007-05-16 13:12:13.000000000 +0200
@@ -20,6 +20,13 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
+#ifdef CONFIG_KRG_DVFS
+#include <kerrighed/dvfs.h>
+#endif
+
 const struct file_operations generic_ro_fops = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
@@ -117,13 +124,25 @@ loff_t vfs_llseek(struct file *file, lof
 {
 	loff_t (*fn)(struct file *, loff_t, int);
 
+#ifdef CONFIG_KRG_DVFS
+	loff_t pos;
+	if (file->f_flags & O_KRG_SHARED)
+		kh_file_pos_read(file);
+#endif
 	fn = no_llseek;
 	if (file->f_mode & FMODE_LSEEK) {
 		fn = default_llseek;
 		if (file->f_op && file->f_op->llseek)
 			fn = file->f_op->llseek;
 	}
+#ifdef CONFIG_KRG_DVFS
+	pos = fn(file, offset, origin);
+	if (file->f_flags & O_KRG_SHARED)
+		kh_file_pos_write(file, file->f_pos);
+	return pos;
+#else
 	return fn(file, offset, origin);
+#endif
 }
 EXPORT_SYMBOL(vfs_llseek);
 
@@ -138,6 +157,16 @@ asmlinkage off_t sys_lseek(unsigned int 
 	if (!file)
 		goto bad;
 
+#ifdef CONFIG_KRG_FAF
+	if (file->f_flags & O_FAF_CLT) {
+		if (kh_faf_lseek)
+			retval = kh_faf_lseek(file, offset, origin);
+		else
+			BUG();
+		fput_light(file, fput_needed);
+		return retval;
+	}
+#endif
 	retval = -EINVAL;
 	if (origin <= 2) {
 		loff_t res = vfs_llseek(file, offset, origin);
@@ -169,10 +198,22 @@ asmlinkage long sys_llseek(unsigned int 
 	if (origin > 2)
 		goto out_putf;
 
+#ifdef CONFIG_KRG_FAF
+	if (file->f_flags & O_FAF_CLT) {
+		if (kh_faf_llseek)
+			retval = kh_faf_llseek(file, offset_high, offset_low,
+					       &offset, origin);
+		else
+			BUG();
+	} else {
+#endif //CONFIG_KRG_FAF
 	offset = vfs_llseek(file, ((loff_t) offset_high << 32) | offset_low,
 			origin);
 
 	retval = (int)offset;
+#ifdef CONFIG_KRG_FAF
+	}
+#endif //CONFIG_KRG_FAF
 	if (offset >= 0) {
 		retval = -EFAULT;
 		if (!copy_to_user(result, &offset, sizeof(offset)))
@@ -345,11 +386,19 @@ EXPORT_SYMBOL(vfs_write);
 
 static inline loff_t file_pos_read(struct file *file)
 {
+#ifdef CONFIG_KRG_DVFS
+	if (file->f_flags & O_KRG_SHARED)
+		return kh_file_pos_read(file);
+#endif // CONFIG_KRG_DVFS
 	return file->f_pos;
 }
 
 static inline void file_pos_write(struct file *file, loff_t pos)
 {
+#ifdef CONFIG_KRG_DVFS
+	if (file->f_flags & O_KRG_SHARED)
+		kh_file_pos_write(file, pos);
+#endif // CONFIG_KRG_DVFS
 	file->f_pos = pos;
 }
 
@@ -361,7 +410,22 @@ asmlinkage ssize_t sys_read(unsigned int
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
+#ifdef CONFIG_KRG_FAF
+		loff_t pos;
+
+		if (file->f_flags & O_FAF_CLT) {
+			if (kh_faf_read)
+				ret = kh_faf_read(file, buf, count);
+			else
+				BUG();
+			fput_light(file, fput_needed);
+			return ret;
+		}
+
+		pos = file_pos_read(file);
+#else // CONFIG_KRG_FAF
 		loff_t pos = file_pos_read(file);
+#endif // CONFIG_KRG_FAF
 		ret = vfs_read(file, buf, count, &pos);
 		file_pos_write(file, pos);
 		fput_light(file, fput_needed);
@@ -379,7 +443,22 @@ asmlinkage ssize_t sys_write(unsigned in
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
+#ifdef CONFIG_KRG_FAF
+		loff_t pos;
+
+		if (file->f_flags & O_FAF_CLT) {
+			if (kh_faf_write)
+				ret = kh_faf_write(file, buf, count);
+			else
+				BUG();
+			fput_light(file, fput_needed);
+			return ret;
+		}
+
+		pos = file_pos_read(file);
+#else // CONFIG_KRG_FAF
 		loff_t pos = file_pos_read(file);
+#endif // CONFIG_KRG_FAF
 		ret = vfs_write(file, buf, count, &pos);
 		file_pos_write(file, pos);
 		fput_light(file, fput_needed);
diff -Nupr a/fs/stat.c b/fs/stat.c
--- a/fs/stat.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/stat.c	2007-03-07 17:29:15.000000000 +0100
@@ -19,6 +19,10 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
+
 void generic_fillattr(struct inode *inode, struct kstat *stat)
 {
 	stat->dev = inode->i_sb->s_dev;
@@ -102,6 +106,16 @@ int vfs_fstat(unsigned int fd, struct ks
 	int error = -EBADF;
 
 	if (f) {
+#ifdef CONFIG_KRG_FAF
+		if (f->f_flags & O_FAF_CLT) {
+			if (kh_faf_fstat)
+				error = kh_faf_fstat(f, stat);
+			else
+				BUG();
+			fput(f);
+			return error;
+		}
+#endif
 		error = vfs_getattr(f->f_path.mnt, f->f_path.dentry, stat);
 		fput(f);
 	}
diff -Nupr a/fs/sync.c b/fs/sync.c
--- a/fs/sync.c	2007-02-04 19:44:54.000000000 +0100
+++ b/fs/sync.c	2007-03-07 17:29:15.000000000 +0100
@@ -13,6 +13,9 @@
 #include <linux/pagemap.h>
 #include <linux/quotaops.h>
 #include <linux/buffer_head.h>
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
 
 #define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \
 			SYNC_FILE_RANGE_WAIT_AFTER)
@@ -81,6 +84,15 @@ long do_fsync(struct file *file, int dat
 	int err;
 	struct address_space *mapping = file->f_mapping;
 
+#ifdef CONFIG_KRG_FAF
+	if (file->f_flags & O_FAF_CLT) {
+		if (kh_faf_fsync)
+			ret = kh_faf_fsync(file);
+		else
+			BUG();
+		goto out;
+	}
+#endif // CONFIG_KRG_FAF
 	if (!file->f_op || !file->f_op->fsync) {
 		/* Why?  We can still call filemap_fdatawrite */
 		ret = -EINVAL;
diff -Nupr a/include/acpi/platform/aclinux.h b/include/acpi/platform/aclinux.h
--- a/include/acpi/platform/aclinux.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/acpi/platform/aclinux.h	2007-04-28 15:07:15.000000000 +0200
@@ -59,6 +59,7 @@
 #include <asm/acpi.h>
 #include <linux/slab.h>
 #include <linux/spinlock_types.h>
+#include <linux/sched.h>
 #include <asm/current.h>
 
 /* Host-dependent types and defines */
diff -Nupr a/include/asm-generic/siginfo.h b/include/asm-generic/siginfo.h
--- a/include/asm-generic/siginfo.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/asm-generic/siginfo.h	2007-03-28 12:21:08.000000000 +0200
@@ -142,6 +142,9 @@ typedef struct siginfo {
  */
 #define SI_USER		0		/* sent by kill, sigsend, raise */
 #define SI_KERNEL	0x80		/* sent by the kernel from somewhere */
+#ifdef CONFIG_KRG_EPM
+#define SI_KERRIGHED	0x90		/* sent by Kerrighed for an EPM action */
+#endif
 #define SI_QUEUE	-1		/* sent by sigqueue */
 #define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
 #define SI_MESGQ __SI_CODE(__SI_MESGQ,-3) /* sent by real time mesq state change */
diff -Nupr a/include/asm-i386/current.h b/include/asm-i386/current.h
--- a/include/asm-i386/current.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/asm-i386/current.h	2007-03-28 12:21:08.000000000 +0200
@@ -11,6 +11,16 @@ static __always_inline struct task_struc
 	return read_pda(pcurrent);
 }
  
+#ifdef CONFIG_KRG_EPM
+#define krg_current (get_current()->effective_current)
+#define current ({							\
+	struct task_struct *__cur = get_current();			\
+	__cur->effective_current ? __cur->effective_current : __cur;	\
+})
+
+#else
+
 #define current get_current()
+#endif /* CONFIG_KRG_EPM */
 
 #endif /* !(_I386_CURRENT_H) */
diff -Nupr a/include/asm-i386/processor.h b/include/asm-i386/processor.h
--- a/include/asm-i386/processor.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/asm-i386/processor.h	2007-02-28 15:51:33.000000000 +0100
@@ -56,6 +56,10 @@ struct cpuinfo_x86 {
 	char	hard_math;
 	char	rfu;
        	int	cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
+#ifdef CONFIG_KRG_PROCFS
+	int	krg_cpu_id;
+	unsigned long	cpu_khz;
+#endif // CONFIG_KRG_PROCFS
 	unsigned long	x86_capability[NCAPINTS];
 	char	x86_vendor_id[16];
 	char	x86_model_id[64];
diff -Nupr a/include/asm-um/current.h b/include/asm-um/current.h
--- a/include/asm-um/current.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/asm-um/current.h	2007-03-28 12:21:08.000000000 +0200
@@ -11,7 +11,17 @@
 #include "asm/page.h"
 #include "linux/thread_info.h"
 
+#ifdef CONFIG_KRG_EPM
+#define krg_current (current_thread_info()->task->effective_current)
+#define current ({							\
+	struct task_struct *__cur = current_thread_info()->task;	\
+	__cur->effective_current ? __cur->effective_current : __cur;	\
+})
+
+#else
+
 #define current (current_thread_info()->task)
+#endif
 
 /*Backward compatibility - it's used inside arch/um.*/
 #define current_thread current_thread_info()
diff -Nupr a/include/asm-x86_64/current.h b/include/asm-x86_64/current.h
--- a/include/asm-x86_64/current.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/asm-x86_64/current.h	2007-03-28 12:21:08.000000000 +0200
@@ -12,7 +12,17 @@ static inline struct task_struct *get_cu
 	return t;
 } 
 
+#ifdef CONFIG_KRG_EPM
+#define krg_current (get_current()->effective_current)
+#define current ({							\
+	struct task_struct *__cur = get_current();			\
+	__cur->effective_current ? __cur->effective_current : __cur;	\
+})
+
+#else
+
 #define current get_current()
+#endif /* CONFIG_KRG_EPM */
 
 #else
 
diff -Nupr a/include/asm-x86_64/processor.h b/include/asm-x86_64/processor.h
--- a/include/asm-x86_64/processor.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/asm-x86_64/processor.h	2007-03-01 14:48:09.000000000 +0100
@@ -53,6 +53,10 @@ struct cpuinfo_x86 {
 	__u8	x86_model;
 	__u8	x86_mask;
 	int	cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
+#ifdef CONFIG_KRG_PROCFS
+	int	krg_cpu_id;
+	unsigned long cpu_khz;
+#endif // CONFIG_KRG_PROCFS
 	__u32	x86_capability[NCAPINTS];
 	char	x86_vendor_id[16];
 	char	x86_model_id[64];
diff -Nupr a/include/kerrighed/capabilities.h b/include/kerrighed/capabilities.h
--- a/include/kerrighed/capabilities.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/capabilities.h	2007-03-01 12:37:47.000000000 +0100
@@ -0,0 +1,55 @@
+/** Define Kerrighed Capabilities (not exported outside kernel)
+ * @author Jean Parpaillon (c) Inria 2006
+ */
+
+#ifndef _KERRIGHED_CAPABILITIES_H_INTERNAL
+#define _KERRIGHED_CAPABILITIES_H_INTERNAL
+
+#include <linux/capability.h>
+#include "sys/capabilities.h"
+
+/*
+ * MACROS
+ */
+#define KRG_CAP_INIT_PERM_SET CAP_FULL_SET
+#define KRG_CAP_INIT_EFF_SET CAP_TO_MASK (CAP_CHANGE_KERRIGHED_CAP)
+#define KRG_CAP_INIT_INH_PER_SET KRG_CAP_INIT_PERM_SET
+#define KRG_CAP_INIT_INH_EFF_SET KRG_CAP_INIT_EFF_SET
+
+#define KRG_CAP_INIT_ATOMIC_COUNTERS \
+	{{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0}}
+
+#define can_use_krg_cap(task,cap) \
+	(cap_raised(task->krg_cap_effective,cap) \
+	 && !atomic_read(&task->krg_cap_unavailable[cap]) \
+	 && !atomic_read(&task->krg_cap_unavailable_private[cap]))
+
+#define DEFAULT_KRG_DAEMON_CAP_EFF 0
+#define DEFAULT_KRG_DAEMON_CAP_PERM 0
+
+/*
+ * TYPES
+ */
+#ifdef __KERNEL__
+
+struct krg_cap_struct
+{
+	kernel_cap_t krg_cap_effective;
+	kernel_cap_t krg_cap_permitted;
+	kernel_cap_t krg_cap_inheritable_permitted;
+	kernel_cap_t krg_cap_inheritable_effective;
+};
+
+#else
+
+#include <sys/types.h>
+
+#endif /* __KERNEL__ */
+
+struct krg_cap_pid_desc
+{
+	pid_t pid;
+	krg_cap_t *caps;
+};
+
+#endif /* _KERRIGHED_CAPABILITIES_H_INTERNAL */
diff -Nupr a/include/kerrighed/children.h b/include/kerrighed/children.h
--- a/include/kerrighed/children.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/children.h	2007-05-23 21:04:56.000000000 +0200
@@ -0,0 +1,57 @@
+#ifndef __KKRG_CHILDREN_H__
+#define __KKRG_CHILDREN_H__
+
+#ifdef CONFIG_KRG_EPM
+
+#include <linux/types.h>
+
+struct children_ctnr_object;
+struct task_struct;
+
+extern
+struct children_ctnr_object * (*kh_alloc_children)(struct task_struct *task);
+extern void (*kh_share_children)(struct task_struct *task);
+extern void (*kh_exit_children)(struct task_struct *task);
+extern void (*kh_children_get)(struct children_ctnr_object *obj);
+extern void (*kh_children_put)(struct children_ctnr_object *obj);
+extern int (*kh_children_alive)(struct children_ctnr_object *obj);
+extern int (*kh_new_child)(struct children_ctnr_object *obj,
+			   pid_t parent_pid,
+			   pid_t child_pid, pid_t pgid, pid_t sid,
+			   int exit_signal);
+extern void (*kh_set_child_pgid)(struct children_ctnr_object *obj,
+				 pid_t pid, pid_t pgid);
+extern void (*kh_set_child_exit_signal)(struct children_ctnr_object *obj,
+					pid_t pid, int exit_signal);
+extern void (*kh_remove_child)(struct children_ctnr_object *obj,
+			       pid_t child_pid);
+extern void (*kh_reparent_child)(struct children_ctnr_object *obj,
+				 pid_t child_pid,
+				 pid_t reaper_pid, int same_group);
+extern void (*kh_forget_original_remote_parent)(struct task_struct *parent,
+						struct task_struct *reaper);
+extern void (*kh_reparent_to_local_child_reaper)(struct task_struct *task);
+extern int (*kh_may_be_eligible_child)(struct children_ctnr_object *obj,
+				       pid_t pid,
+				       int options);
+extern pid_t (*kh_get_real_parent_tgid)(struct task_struct *task);
+extern int (*kh_get_parent)(struct children_ctnr_object *obj, pid_t pid,
+			    pid_t *parent_pid, pid_t *real_parent_pid);
+extern struct children_ctnr_object * (*kh_children_writelock)(pid_t tgid);
+extern
+struct children_ctnr_object * (*kh_children_writelock_nested)(pid_t tgid);
+extern struct children_ctnr_object * (*kh_children_readlock)(pid_t tgid);
+extern struct children_ctnr_object * (*kh_parent_children_writelock)(
+	struct task_struct *task,
+	pid_t *parent_tgid);
+extern struct children_ctnr_object * (*kh_parent_children_readlock)(
+	struct task_struct *task,
+	pid_t *parent_tgid);
+extern void (*kh_children_unlock)(pid_t tgid);
+extern void (*kh_add_parent)(struct task_struct *task,
+			     struct task_struct *parent);
+extern void (*kh_remove_parent)(struct task_struct *task);
+
+#endif /* CONFIG_KRG_EPM */
+
+#endif /* __KKRG_CHILDREN_H__ */
diff -Nupr a/include/kerrighed/ctnr_headers.h b/include/kerrighed/ctnr_headers.h
--- a/include/kerrighed/ctnr_headers.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/ctnr_headers.h	2007-04-11 17:15:28.000000000 +0200
@@ -0,0 +1,4 @@
+/** Kerrighed Kernel Hooks **/
+
+extern int (*kh_copy_kddm_info)(unsigned long clone_flags,
+				struct task_struct * tsk);
diff -Nupr a/include/kerrighed/dvfs.h b/include/kerrighed/dvfs.h
--- a/include/kerrighed/dvfs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/dvfs.h	2007-03-07 17:29:15.000000000 +0100
@@ -0,0 +1,5 @@
+/** Kerrighed Kernel Hooks **/
+
+extern loff_t (*kh_file_pos_read)(struct file *file);
+extern void (*kh_file_pos_write)(struct file *file, loff_t pos);
+extern void (*kh_put_file)(struct file *file);
diff -Nupr a/include/kerrighed/faf.h b/include/kerrighed/faf.h
--- a/include/kerrighed/faf.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/faf.h	2007-05-29 14:47:54.000000000 +0200
@@ -0,0 +1,79 @@
+/** Kerrighed Kernel Hooks **/
+
+#ifndef __FAF_H__
+#define __FAF_H__
+
+extern off_t (*kh_faf_lseek)(struct file *file, off_t offset,
+			     unsigned int origin) ;
+extern long (*kh_faf_llseek)(struct file *file, unsigned long offset_high,
+			     unsigned long offset_low, loff_t * result,
+			     unsigned int origin) ;
+extern ssize_t (*kh_faf_read)(struct file *file, char * buf, size_t count) ;
+extern ssize_t (*kh_faf_write)(struct file *file, const char * buf,
+			       size_t count) ;
+extern long (*kh_faf_fcntl)(struct file *file, unsigned int cmd,
+			    unsigned long arg) ;
+extern long (*kh_faf_fcntl64)(struct file *file, unsigned int cmd,
+			      unsigned long arg) ;
+extern long (*kh_faf_ioctl)(struct file *file, unsigned int cmd,
+			    unsigned long arg) ;
+extern long (*kh_faf_fstat)(struct file *file, struct kstat *stat) ;
+extern long (*kh_faf_fsync)(struct file *file) ;
+extern long (*kh_faf_flock)(struct file *file, unsigned int cmd) ;
+extern void (*kh_faf_get_file)(struct file *file);
+extern int (*kh_faf_close_srv_file)(struct file *file);
+
+
+struct sockaddr;
+struct msghdr;
+
+extern long (*kh_faf_bind)(struct file * file, struct sockaddr __user *umyaddr,
+			   int addrlen);
+extern long (*kh_faf_connect)(struct file * file,
+			      struct sockaddr __user *uservaddr, int addrlen);
+extern long (*kh_faf_listen)(struct file * file, int backlog);
+extern long (*kh_faf_accept)(struct file * file,
+			     struct sockaddr __user *upeer_sockaddr,
+			     int __user *upeer_addrlen);
+extern long (*kh_faf_getsockname)(struct file * file,
+				  struct sockaddr __user *usockaddr,
+				  int __user *usockaddr_len);
+extern long (*kh_faf_getpeername)(struct file * file,
+				  struct sockaddr __user *usockaddr,
+				  int __user *usockaddr_len);
+extern long (*kh_faf_send)(struct file * file, void __user * buff, size_t len,
+			   unsigned flags);
+extern long (*kh_faf_sendto)(struct file * file, void __user * buff,
+			     size_t len, unsigned flags,
+			     struct sockaddr __user *addr, int addr_len);
+extern long (*kh_faf_recv)(struct file * file, void __user * ubuf, size_t size,
+			   unsigned flags);
+extern long (*kh_faf_recvfrom)(struct file * file, void __user * ubuf,
+			       size_t size, unsigned flags,
+			       struct sockaddr __user *addr,
+			       int __user *addr_len);
+extern long (*kh_faf_shutdown)(struct file * file, int how);
+extern long (*kh_faf_setsockopt)(struct file * file, int level, int optname,
+				 char __user *optval, int optlen);
+extern long (*kh_faf_getsockopt)(struct file * file, int level, int optname,
+				 char __user *optval, int __user *optlen);
+extern long (*kh_faf_sendmsg)(struct file * file, struct msghdr __user *msg,
+			      unsigned flags);
+extern long (*kh_faf_recvmsg)(struct file * file, struct msghdr __user *msg,
+			      unsigned int flags);
+
+static inline int filp_close(struct file *filp, fl_owner_t id)
+{
+	/* Check if we are closing the last usefull instance of a FAF
+	 * server file entry. If so, close the file within the FAF server.
+	 */
+	
+	if ((filp->f_flags & O_FAF_SRV) && (file_count(filp) == 2) &&
+	    kh_faf_close_srv_file)
+		kh_faf_close_srv_file(filp);
+	
+	return __filp_close(filp, id);
+}
+
+
+#endif // __FAF_H__
diff -Nupr a/include/kerrighed/fcntl.h b/include/kerrighed/fcntl.h
--- a/include/kerrighed/fcntl.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/fcntl.h	2007-05-16 13:12:13.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __KKRG_FCNTL__
+#define __KKRG_FCNTL__
+
+#define O_FAF_CLT        02000000 /* Client File Access Forwarding flag */
+#define O_FAF_SRV        04000000 /* Server File Access Forwarding flag */
+#define O_KRG_SHARED    010000000 /* Cluster wide shared file pointer */
+
+#endif // __KKRG_FCNTL__
diff -Nupr a/include/kerrighed/file.h b/include/kerrighed/file.h
--- a/include/kerrighed/file.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/file.h	2007-04-18 17:02:56.000000000 +0200
@@ -0,0 +1,37 @@
+#ifndef __KKRG_FILE__
+#define __KKRG_FILE__
+
+#include <asm/stat.h>
+#include <asm/current.h>
+#include <linux/mount.h>
+#include <linux/sched.h>
+
+int count_open_files(struct fdtable *fdt);
+struct fdtable * alloc_fdtable(unsigned int nr);
+
+char * __d_path( struct dentry *dentry, struct vfsmount *vfsmnt,
+		 struct dentry *root, struct vfsmount *rootmnt,
+		 char *buffer, int buflen);
+
+#ifdef CONFIG_KRG_FAF
+int __get_unused_fd(struct task_struct *tsk);
+
+static inline int get_unused_fd(void)
+{
+	return __get_unused_fd (current);
+}
+
+void fastcall __fd_install(struct task_struct *tsk, unsigned int fd,
+			   struct file * file);
+
+static inline void fastcall fd_install(unsigned int fd, struct file * file)
+{
+	__fd_install (current, fd, file);
+}
+
+void __put_unused_fd(struct files_struct *files, unsigned int fd);
+
+#endif
+
+
+#endif // __KKRG_FILE__
diff -Nupr a/include/kerrighed/fs.h b/include/kerrighed/fs.h
--- a/include/kerrighed/fs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/fs.h	2007-03-07 17:29:15.000000000 +0100
@@ -0,0 +1,8 @@
+#ifndef __KKRG_FS__
+#define __KKRG_FS__
+
+#define S_IFAF 0160000
+
+extern const struct file_operations tty_fops;
+
+#endif
diff -Nupr a/include/kerrighed/ghost.h b/include/kerrighed/ghost.h
--- a/include/kerrighed/ghost.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/ghost.h	2007-03-28 12:21:08.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef __KKRG_GHOST_H__
+#define __KKRG_GHOST_H__
+
+#ifdef CONFIG_KRG_EPM
+
+struct pt_regs;
+struct pid;
+
+/* ghost process */
+long __do_fork(unsigned long clone_flags,
+	       unsigned long stack_start,
+	       struct pt_regs *regs,
+	       unsigned long stack_size,
+	       int __user *parent_tidptr,
+	       int __user *child_tidptr,
+	       struct pid *__pid);
+
+int restart_block_krgsyms_register(void);
+int restart_block_krgsyms_unregister(void);
+
+#endif /* CONFIG_KRG_EPM */
+
+#endif /* __KKRG_GHOST_H__ */
diff -Nupr a/include/kerrighed/hashtable.h b/include/kerrighed/hashtable.h
--- a/include/kerrighed/hashtable.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/hashtable.h	2007-03-23 17:10:29.000000000 +0100
@@ -0,0 +1,204 @@
+/** Hashtable management interface
+ *  @file hashtable.h
+ *
+ *  Definition of hashtable management functions.
+ *  @author Viet Hoa Dinh, Renaud Lottiaux
+ */
+
+#ifndef __HASHTABLE_H__
+#define __HASHTABLE_H__
+
+#include <linux/stddef.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <asm/system.h>
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                                 MACROS                                   *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+
+#define HASHTABLE_SIZE 1024
+
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                                  TYPES                                   *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+
+/** Hashtable linked list element */
+struct hash_list {
+  unsigned long hash;        /* Key of stored data */
+  void * data;               /* Data stored in the table */
+  struct hash_list * next;   /* Next stored data */
+};
+
+/** Hashtable Structure */
+typedef struct hashtable_t {
+  spinlock_t lock ;                /** Structure lock */
+  struct hash_list * table ;       /** Hash table */
+  unsigned long hashtable_size ;   /** Size of the hash table */
+  unsigned long flags[NR_CPUS];
+} hashtable_t;
+
+#define hashtable_lock(table) spin_lock (&table->lock)
+#define hashtable_unlock(table) spin_unlock (&table->lock)
+
+#define hashtable_lock_bh(table) spin_lock_bh (&table->lock)
+#define hashtable_unlock_bh(table) spin_unlock_bh (&table->lock)
+
+#define hashtable_lock_irq(table) spin_lock_irq (&table->lock)
+#define hashtable_unlock_irq(table) spin_unlock_irq (&table->lock)
+
+#define hashtable_lock_irqsave(table) spin_lock_irqsave (&table->lock, table->flags[smp_processor_id()])
+#define hashtable_unlock_irqrestore(table) spin_unlock_irqrestore (&table->lock, table->flags[smp_processor_id()])
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                              EXTERN FUNCTIONS                            *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+
+
+/** Create a new hash table
+ *  @author Viet Hoa Dinh
+ * 
+ *  @param hashtable_size  Size of the hashtable to create.
+ *
+ *  @return  A pointer to the newly created hash table.
+ */
+hashtable_t * hashtable_new(unsigned long hashtable_size);
+
+
+
+/** Free a hash table
+ *  @author Viet Hoa Dinh
+ * 
+ *  @param table  The table to free
+ */
+void hashtable_free(hashtable_t * table);
+
+
+
+/** Add an element to a hash table
+ *  @author Viet Hoa Dinh
+ * 
+ *  @param table  The table to add the element in.
+ *  @param hash   The element key.
+ *  @param data   The element to add in the table
+ *
+ *  @return  0 if everything ok.
+ *           Negative value otherwise.
+ */
+int __hashtable_add(hashtable_t * table, unsigned long hash, void * data);
+
+static inline int hashtable_add(hashtable_t * table, unsigned long hash,
+			       void * data)
+{
+  int r ;
+
+  hashtable_lock_irqsave (table);
+
+  r = __hashtable_add (table, hash, data);
+
+  hashtable_unlock_irqrestore (table);
+
+  return r ;
+}
+
+
+
+/** Remove an element from a hash table
+ *  @author Viet Hoa Dinh
+ * 
+ *  @param table  The table to remove the element from.
+ *  @param hash   The element key.
+ *
+ *  @return  The data removed.
+ *           NULL value otherwise.
+ */
+void *__hashtable_remove(hashtable_t * table, unsigned long hash);
+
+static inline void * hashtable_remove(hashtable_t * table, unsigned long hash)
+{
+	void *data;
+	
+	hashtable_lock_irqsave (table);
+	
+	data = __hashtable_remove (table, hash);
+	
+	hashtable_unlock_irqrestore (table);
+	
+	return data ;
+}
+
+
+
+/** Find an element in a hash table
+ *  @author Viet Hoa Dinh
+ * 
+ *  @param table  The table to search the element in.
+ *  @param hash   The element key.
+ *
+ *  @return  A pointer to the data, if in the table.
+ *           NULL if data not found.
+ */
+void * __hashtable_find(hashtable_t * table, unsigned long hash);
+
+static inline void * hashtable_find(hashtable_t * table, unsigned long hash)
+{
+  void * r ;
+
+  hashtable_lock_irqsave (table);
+
+  r = __hashtable_find (table, hash);
+
+  hashtable_unlock_irqrestore (table);
+
+  return r ;
+}
+
+
+
+/** Apply a function on each hash table key.
+ *  @author Viet Hoa Dinh, Pascal Gallard
+ * 
+ *  @param table  The table to work with.
+ *  @param func   The function to apply.
+ *  @param data   Data to send to the given function.
+ */
+void __hashtable_foreach_key(hashtable_t * table,
+			     void (* func)(int, void *),
+			     void * data);
+
+
+
+/** Apply a function on each hash table element.
+ *  @author Viet Hoa Dinh, Pascal Gallard
+ * 
+ *  @param table  The table to work with.
+ *  @param func   The function to apply.
+ *  @param data   Data to send to the given function.
+ */
+void __hashtable_foreach_data(hashtable_t * table,
+			      void (* fun)(void *, void *),
+			      void * data);
+
+/** Find an element of the hashtable that staifies a criteria
+ *  @author David Margery
+ * 
+ *  @param table  The table to work with.
+ *  @param func   The function to apply.
+ *  @param data   Data to send to the given function.
+ */
+void * hashtable_find_data(hashtable_t * table,
+			   int (* fun)(void *, void *),
+			   void * data);
+
+
+#endif // __HASHTABLE_H__
diff -Nupr a/include/kerrighed/highmem.h b/include/kerrighed/highmem.h
--- a/include/kerrighed/highmem.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/highmem.h	2007-03-01 17:58:36.000000000 +0100
@@ -0,0 +1,21 @@
+#ifndef __KKRG_HIGHMEM__
+#define __KKRG_HIGHMEM__
+
+static inline void copy_buff_to_highpage(struct page * page, char *buffer)
+{
+  char *to;
+  to = (char *)kmap_atomic(page, KM_USER0);
+  copy_page(to, buffer);
+  kunmap_atomic(to, KM_USER0);
+}
+
+static inline void copy_highpage_to_buff(char *buffer, struct page * page)
+{
+  char *from;
+
+  from = (char *)kmap_atomic(page, KM_USER0);
+  copy_page(buffer, from);
+  kunmap_atomic(from, KM_USER0);
+}
+
+#endif // __KKRG_HIGHMEM__
diff -Nupr a/include/kerrighed/hotplug.h b/include/kerrighed/hotplug.h
--- a/include/kerrighed/hotplug.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/hotplug.h	2007-05-04 13:56:13.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef __KRG_HOTPLUG__
+#define __KRG_HOTPLUG__
+
+struct universe_elem {
+	int state;
+	int subid;
+};
+extern struct universe_elem universe[KERRIGHED_MAX_NODES];
+
+void krg_node_arrival(kerrighed_node_t nodeid);
+void krg_node_departure(kerrighed_node_t nodeid);
+
+#endif
diff -Nupr a/include/kerrighed/ipc.h b/include/kerrighed/ipc.h
--- a/include/kerrighed/ipc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/ipc.h	2007-05-29 16:03:20.000000000 +0200
@@ -0,0 +1,17 @@
+#ifndef __KKRG_IPC__
+#define __KKRG_IPC__
+
+#include <linux/lockdep.h>
+#include <asm/semaphore.h>
+
+struct ipc_id {
+       struct kern_ipc_perm* p;
+};
+
+int grow_ary(struct ipc_ids* ids, int newsize);
+
+extern struct ipc_namespace init_ipc_ns;
+
+extern struct lock_class_key ipcid_lock_key;
+
+#endif // __KKRG_IPC__
diff -Nupr a/include/kerrighed/kernel_headers.h b/include/kerrighed/kernel_headers.h
--- a/include/kerrighed/kernel_headers.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/kernel_headers.h	2007-03-28 16:25:38.000000000 +0200
@@ -0,0 +1,87 @@
+#ifndef __KKRG_KERNEL_HEADERS__
+#define __KKRG_KERNEL_HEADERS__
+
+#include <linux/autoconf.h>
+#include <asm/atomic.h>
+#include <linux/futex.h>
+#include <linux/rwsem.h>
+#include <kerrighed/types.h>
+#include <kerrighed/krginit.h>
+
+struct inode;
+struct vfsmount;
+struct sockaddr_un;
+
+/* Used in arch/<*>/mm/fault.c and epm/ghost_process_api.c */
+void show_registers(struct pt_regs *regs);
+
+/* kernel/kerrighed.c */
+
+#ifdef CONFIG_FD_V1
+/* FORK_DELAY */
+extern int jeton;
+extern int var_chan_admin;
+extern void msleep (unsigned int msecs);
+#endif //CONFIG_FD_V1
+#ifdef CONFIG_KRG_FD
+extern int vload;
+extern int nb_process_delayed;
+extern int threshold;
+extern int threshold_scheduler;
+extern int wait_time;
+//see fd_status
+typedef enum{
+  PFD_OK,
+    PFD_BLOCKED
+    } pfd_status;
+struct l_p_delay{
+  struct task_struct *p;
+  unsigned long clone_flags;
+  pfd_status fd_status; //process in the pfd_list but authorized (or NOT) to be woke up
+  struct list_head lh;
+};
+extern struct l_p_delay head_list_fd;
+extern int init_fd;
+extern int (*kh_fd_send_msg)(int code, int type);
+#endif //CONFIG_KRG_FD
+
+
+/* Stream */
+ssize_t bad_pipe_r(struct file *filp, char *buf,
+		size_t count, loff_t *ppos);
+ssize_t bad_pipe_w(struct file *filp, const char *buf,
+		size_t count, loff_t *ppos);
+int pipe_ioctl(struct inode *pino, struct file *filp,
+		unsigned int cmd, unsigned long arg);
+int unix_mkname(struct sockaddr_un * sunaddr, int len, unsigned *hashp);
+
+int local_stream_flush(struct file * filp);
+
+extern void (*setup_krg_read_pipe)(struct file *);
+extern void (*setup_krg_write_pipe)(struct file *);
+extern struct inode * (*get_krg_pipe_inode)(struct vfsmount *);
+
+extern struct vfsmount *pipe_mnt;
+
+
+#ifdef CONFIG_KRG_SYNC
+extern int (*kh_futex_queue_me)(struct futex_q *q);
+extern int (*kh_futex_wake)(union futex_key *key, int nr_wake, int nr_woken);
+#endif // CONFIG_KRG_SYNC
+
+#ifdef CONFIG_KRG_STREAM
+extern struct proto_ops unix_stream_ops;
+extern struct proto_ops unix_dgram_ops;
+extern struct proto_ops unix_seqpacket_ops;
+
+extern struct proto_ops *kernet_socket_ops;
+extern struct proto *kernet_socket_proto;
+
+extern struct proto_ops *kernet_unix_stream_ops;
+extern struct proto_ops *kernet_unix_datagram_ops;
+
+extern struct proto_ops *kernet_inet_stream_ops;
+extern struct proto_ops *kernet_inet_datagram_ops;
+#endif
+
+#endif /* __KKRG_KERNEL_HEADERS__ */
diff -Nupr a/include/kerrighed/kerrighed_signal.h b/include/kerrighed/kerrighed_signal.h
--- a/include/kerrighed/kerrighed_signal.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/kerrighed_signal.h	2007-03-28 12:21:08.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef __KKRG_KERRIGHED_SIGNAL_H__
+#define __KKRG_KERRIGHED_SIGNAL_H__
+
+/* Kerrighed signal */
+
+#ifdef CONFIG_KRG_EPM
+
+#include <asm/signal.h>
+
+struct siginfo;
+struct pt_regs;
+struct task_struct;
+
+typedef void kerrighed_handler_t(int sig, struct siginfo *info,
+				 struct pt_regs *regs);
+
+extern kerrighed_handler_t *kh_krg_handler[_NSIG];
+
+int send_kerrighed_signal(int sig, struct siginfo *info, struct task_struct *t);
+
+#endif /* CONFIG_KRG_EPM */
+
+#endif /* __KKRG_KERRIGHED_SIGNAL_H__ */
diff -Nupr a/include/kerrighed/krginit.h b/include/kerrighed/krginit.h
--- a/include/kerrighed/krginit.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/krginit.h	2007-03-12 17:56:41.000000000 +0100
@@ -0,0 +1,26 @@
+#ifndef __KRGINIT_H__
+#define __KRGINIT_H__
+
+#include <kerrighed/types.h>
+#include <linux/rwsem.h>
+
+enum kerrighed_init_flags_t {
+	KRG_INITFLAGS_NODEID,
+	KRG_INITFLAGS_SESSIONID,
+	KRG_INITFLAGS_NBNODES,
+};
+
+/* Tools */
+extern kerrighed_node_t kerrighed_node_id;
+extern kerrighed_node_t kerrighed_nb_nodes;
+extern kerrighed_node_t kerrighed_nb_nodes_min;
+extern kerrighed_session_t kerrighed_session_id;
+extern kerrighed_subsession_t kerrighed_subsession_id;
+extern int kerrighed_init_flags;
+extern struct rw_semaphore kerrighed_init_sem;
+
+#define SET_KRG_INIT_FLAGS(p) kerrighed_init_flags |= (1<<p)
+#define CLR_KRG_INIT_FLAGS(p) kerrighed_init_flags &= ~(1<<p)
+#define ISSET_KRG_INIT_FLAGS(p) (kerrighed_init_flags & (1<<p))
+
+#endif
diff -Nupr a/include/kerrighed/krgsyms.h b/include/kerrighed/krgsyms.h
--- a/include/kerrighed/krgsyms.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/krgsyms.h	2007-05-25 16:00:53.000000000 +0200
@@ -0,0 +1,51 @@
+#ifndef __KRGSYMS__
+#define __KRGSYMS__
+
+#ifndef __ASSEMBLY__
+
+typedef enum krgsyms_val {
+	KRGSYMS_UNDEF, // Must be the first one
+	KRGSYMS_VM_OPS_SHMEM,
+	KRGSYMS_VM_OPS_FILE_GENERIC,
+	KRGSYMS_VM_OPS_MEMORY_KDDM_VMOPS,
+	KRGSYMS_VM_OPS_SHM_KDDM_VMOPS,
+	KRGSYMS_ARCH_UNMAP_AREA,
+	KRGSYMS_ARCH_UNMAP_AREA_TOPDOWN,
+	KRGSYMS_ARCH_GET_UNMAP_AREA,
+	KRGSYMS_ARCH_GET_UNMAP_AREA_TOPDOWN,
+
+	/* Bin format structures */
+	KRGSYMS_BINFMTS_AOUT,
+	KRGSYMS_BINFMTS_ELF,
+	KRGSYMS_BINFMTS_ELF_FDPIC,
+	KRGSYMS_BINFMTS_EM86,
+	KRGSYMS_BINFMTS_FLAT,
+	KRGSYMS_BINFMTS_MISC,
+	KRGSYMS_BINFMTS_SCRIPT,
+	KRGSYMS_BINFMTS_SOM,
+
+	/* Restart block functions */
+	KRGSYMS_DO_NO_RESTART_SYSCALL,
+	KRGSYMS_COMPAT_NANOSLEEP_RESTART,
+	KRGSYMS_COMPAT_CLOCK_NANOSLEEP_RESTART,
+	KRGSYMS_CLOCK_NANOSLEEP_RESTART,
+	KRGSYMS_HRTIMER_NANOSLEEP_RESTART,
+	KRGSYMS_POSIX_CPU_NSLEEP_RESTART,
+	KRGSYMS_PROCESS_CPU_NSLEEP_RESTART,
+	KRGSYMS_THREAD_CPU_NSLEEP_RESTART,
+
+	KRGSYMS_TABLE_SIZE // Must be the last one
+} krgsyms_val_t;
+
+int krgsyms_register(enum krgsyms_val v, void* p);
+int krgsyms_unregister(enum krgsyms_val v);
+
+enum krgsyms_val krgsyms_export(void* p);
+void* krgsyms_import(enum krgsyms_val v);
+
+int init_krgsyms(void);
+void cleanup_krgsyms(void);
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KRGSYMS__ */
diff -Nupr a/include/kerrighed/mm.h b/include/kerrighed/mm.h
--- a/include/kerrighed/mm.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/mm.h	2007-03-01 17:58:36.000000000 +0100
@@ -0,0 +1,67 @@
+#ifndef __KKRG_MM__
+#define __KKRG_MM__
+
+#include <linux/err.h>
+#include <linux/fs.h>
+
+#ifdef CONFIG_USERMODE
+#ifdef PTE_MASK
+// At this time (2.6.11) PTE_MASK is not defined in UM, so as soon as this
+// will be defined, we will remove this part
+#warning PTE_MASK already defined
+#else
+#define PTE_MASK PAGE_MASK
+#endif
+#endif
+
+
+
+/** Kerrighed Extra vm_flags **/
+
+#define VM_CONTAINER  0x08000000
+
+
+
+/** Exported Functions **/
+
+int alloc_ldt(mm_context_t *pc, int mincount, int reload) ;
+void exit_mm(struct task_struct * tsk);
+
+
+
+/** Exported Variables **/
+
+extern struct kmem_cache *mm_cachep;
+extern struct vm_operations_struct shmem_vm_ops;
+extern struct vm_operations_struct generic_file_vm_ops ;
+extern struct vm_operations_struct shmem_vm_ops  ;
+
+static inline void dump_vma(struct task_struct *tsk)
+{
+  struct vm_area_struct *vma;
+
+  vma = tsk->mm->mmap;
+
+  while(vma)
+    {
+      printk ("[0x%08lx:0x%08lx] - flags 0x%08lx - offset 0x%08lx - "
+              "file %p\n", vma->vm_start, vma->vm_end, vma->vm_flags,
+              vma->vm_pgoff, vma->vm_file);
+
+      vma = vma->vm_next;
+    }
+}
+
+
+
+/** Kerrighed Kernel Hooks **/
+
+extern int (*kh_copy_mm)(unsigned long clone_flags, struct mm_struct *mm,
+                        struct mm_struct *oldmm);
+
+extern void (*kh_mmdrop) (struct mm_struct *mm);
+
+
+#define TestClearPageLRU(page)  test_and_clear_bit(PG_lru, &(page)->flags)
+
+#endif // __KKRG_MM__
diff -Nupr a/include/kerrighed/msg.h b/include/kerrighed/msg.h
--- a/include/kerrighed/msg.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/msg.h	2007-05-23 19:14:40.000000000 +0200
@@ -0,0 +1,6 @@
+#ifndef __KKRG_MSG__
+#define __KKRG_MSG__
+
+#define msg_ids(ns)	(*((ns)->ids[IPC_MSG_IDS]))
+
+#endif // __KKRG_MSG__
diff -Nupr a/include/kerrighed/pid.h b/include/kerrighed/pid.h
--- a/include/kerrighed/pid.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/pid.h	2007-05-28 17:05:31.000000000 +0200
@@ -0,0 +1,78 @@
+#ifndef __KKRG_PID__
+#define __KKRG_PID__
+
+#ifdef CONFIG_KRG_PROC
+
+#include <asm/page.h> /* Needed by linux/threads.h */
+#include <linux/threads.h>
+#include <linux/types.h>
+#include <kerrighed/sys/types.h>
+
+/* WARNING: procfs and futex need at least the 2 MSbits free (in procfs: 1 for
+ * sign, 1 for upper pid limit; in futex: see linux/futex.h) */
+
+#define GLOBAL_PID_MASK PID_MAX_LIMIT
+#define PID_NODE_SHIFT (NR_BITS_PID_MAX_LIMIT + 1)
+#define INTERNAL_PID_MASK (PID_MAX_LIMIT - 1)
+
+extern pid_t current_pid_mask;
+
+/* No type checking, no current_pid_mask checking */
+#define __MAKE_KERRIGHED_PID_FOR_NODE(pid, node) \
+	(((node) << PID_NODE_SHIFT)|GLOBAL_PID_MASK|((pid) & INTERNAL_PID_MASK))
+
+/* Same with checking */
+static inline pid_t make_kerrighed_pid_for_node(pid_t pid,
+						kerrighed_node_t node)
+{
+	pid_t ret;
+
+	if (likely(current_pid_mask))
+		ret = __MAKE_KERRIGHED_PID_FOR_NODE(pid, node);
+	else
+		ret = pid;
+
+	return ret;
+
+}
+
+#define MAKE_KERRIGHED_PID_FOR_NODE(pid,node) \
+	make_kerrighed_pid_for_node(pid, node)
+#define MAKE_KERRIGHED_PID(pid) \
+	MAKE_KERRIGHED_PID_FOR_NODE(pid,kerrighed_node_id)
+
+/** extract the original linux kernel pid of a Kerrighed PID */
+#define SHORT_PID(pid) ((pid) & INTERNAL_PID_MASK)
+/** extract the original node id of a Kerrighed PID */
+#define ORIG_NODE(pid) ((pid) >> PID_NODE_SHIFT)
+
+#define KERRIGHED_PID_MAX_LIMIT \
+	__MAKE_KERRIGHED_PID_FOR_NODE(0, KERRIGHED_MAX_NODES)
+
+/* PID location */
+extern int (*kh_set_pid_location)(pid_t pid, kerrighed_node_t node);
+#ifdef CONFIG_KRG_EPM
+extern int (*kh_unset_pid_location)(pid_t pid);
+#endif
+extern kerrighed_node_t (*kh_lock_pid_location)(pid_t pid);
+extern void (*kh_unlock_pid_location)(pid_t pid);
+
+#endif /* CONFIG_KRG_PROC */
+
+#ifdef CONFIG_KRG_EPM
+
+/* pid reference tracking */
+struct pid;
+
+extern struct pid * (*kh_get_pid)(int nr);
+extern void (*kh_end_get_pid)(struct pid *pid);
+extern void (*kh_put_pid)(struct pid *pid);
+
+struct pid * __alloc_pid(int nr);
+
+/* Checkpoint/restart */
+int reserve_pidmap(pid_t pid);
+
+#endif /* CONFIG_KRG_EPM */
+
+#endif /* __KKRG_PID__ */
diff -Nupr a/include/kerrighed/procfs.h b/include/kerrighed/procfs.h
--- a/include/kerrighed/procfs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/procfs.h	2007-03-30 18:55:42.000000000 +0200
@@ -0,0 +1,50 @@
+#ifndef __KKRG_PROCFS__
+#define __KKRG_PROCFS__
+
+#ifdef CONFIG_KRG_PROCFS
+
+#ifdef CONFIG_KRG_PROC
+
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+
+#define get_krg_proc_task(inode) (&PROC_I(inode)->distant_proc)
+
+#endif /* CONFIG_KRG_PROC */
+
+struct seq_file;
+
+int show_cpuinfo(struct seq_file *m, void *v);
+
+#ifdef CONFIG_KRG_PROC
+
+extern struct inode_operations proc_def_inode_operations;
+
+struct task_struct;
+
+int proc_setattr(struct dentry *dentry, struct iattr *attr);
+int do_proc_readlink(struct dentry *dentry, struct vfsmount *mnt,
+		     char __user *buffer, int buflen);
+
+int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
+			struct task_struct *task, int tgid);
+
+int proc_tgid_stat(struct task_struct *, char *);
+int proc_pid_status(struct task_struct *, char *);
+int proc_pid_statm(struct task_struct *, char *);
+int proc_pid_environ(struct task_struct *task, char *buffer);
+int proc_pid_cmdline(struct task_struct *task, char *buffer);
+
+extern int (*kh_task_cpu)(struct task_struct *task);
+extern struct dentry * (*kh_proc_pid_lookup)(struct inode *dir,
+					     struct dentry *dentry, pid_t pid);
+extern int (*kh_proc_pid_readdir)(struct file *filp,
+				  void *dirent, filldir_t filldir,
+				  loff_t offset);
+
+#endif /* CONFIG_KRG_PROC */
+
+#endif /* CONFIG_KRG_PROCFS */
+
+#endif
diff -Nupr a/include/kerrighed/ptrace.h b/include/kerrighed/ptrace.h
--- a/include/kerrighed/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/ptrace.h	2007-03-28 12:21:08.000000000 +0200
@@ -0,0 +1,29 @@
+#ifndef __KKRG_PTRACE_H__
+#define __KKRG_PTRACE_H__
+
+#ifdef CONFIG_KRG_EPM
+
+#include <linux/types.h>
+
+struct children_ctnr_object;
+struct task_struct;
+
+extern void (*kh_ptrace_link)(struct children_ctnr_object *obj,
+			      pid_t ptracer_pid,
+			      pid_t child_pid);
+extern void (*kh_ptrace_unlink)(struct children_ctnr_object *obj,
+				pid_t child_pid);
+
+extern int (*kh_ptrace_traceme)(void);
+extern int (*kh_ptrace_attach)(struct task_struct *task);
+extern void (*kh_ptrace_detach)(struct task_struct *task);
+extern void (*kh_ptrace_ptracer_exit)(struct task_struct *task);
+extern void (*kh_ptrace_reparent_ptraced)(struct task_struct *real_parent,
+					  struct task_struct *task);
+extern void (*kh_ptrace_release_ptraced)(struct task_struct *task);
+extern void (*kh_ptrace_copy_ptrace)(struct task_struct *task);
+
+
+#endif /* CONFIG_KRG_EPM */
+
+#endif /* __KKRG_PTRACE_H__ */
diff -Nupr a/include/kerrighed/sched.h b/include/kerrighed/sched.h
--- a/include/kerrighed/sched.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/sched.h	2007-03-28 16:25:38.000000000 +0200
@@ -0,0 +1,58 @@
+#ifndef __KKRG_SCHED_H__
+#define __KKRG_SCHED_H__
+
+#ifdef CONFIG_KRG_EPM
+
+#include <linux/types.h>
+#include <kerrighed/sys/types.h>
+
+/* WARNING: these flags must not overwrite the flags defined in linux/sched.h
+ * The place is becoming sparse ... */
+
+#define PF_EXIT_NOTIFYING  0x00000008  /* I am exiting and notifying my remote
+					* parent */
+#define PF_DISTANT_FORKING 0x04000000  /* I am doing a distant fork */
+#define PF_MIGRATING       0x08000000  /* I am migrating */
+#define PF_CHECKPOINTING   0x40000000  /* I am doing a checkpoint */
+#define PF_AWAY		   0x80000000  /* I don't want to be considered as local
+					* by my relatives */
+
+#define PF_KERRIGHED_ACTION (PF_DISTANT_FORKING | PF_MIGRATING	\
+			     | PF_CHECKPOINTING)
+
+struct task_struct;
+struct pt_regs;
+
+extern struct task_struct *baby_sitter;
+
+/* remote clone */
+extern int (*kh_do_fork)(unsigned long clone_flags,
+			 unsigned long stack_start,
+			 struct pt_regs *regs,
+			 unsigned long stack_size,
+			 int *parent_tidptr,
+			 int *child_tidptr);
+
+/* pgrp */
+extern int (*kh_will_become_orphaned_pgrp)(pid_t pgrp, pid_t ignored_kid);
+
+/* exit */
+extern int (*kh_exit_notify)(struct task_struct *task,
+			     kerrighed_node_t parent_node,
+			     int sig_num,
+			     pid_t groupid, pid_t sessionid);
+extern void (*kh_delay_release_task)(struct task_struct *task);
+
+/* migration */
+fastcall NORET_TYPE void do_exit_wo_notify(long error_code)
+	ATTRIB_NORET;
+
+#endif /* CONFIG_KRG_EPM */
+
+#ifdef CONFIG_KRG_SCHED
+extern void (*kh_calc_load)(unsigned long ticks);
+extern void (*kh_process_on)(struct task_struct *tsk);
+extern void (*kh_process_off)(struct task_struct *tsk);
+#endif /* CONFIG_KRG_SCHED */
+
+#endif /* __KKRG_SCHED_H__ */
diff -Nupr a/include/kerrighed/sem.h b/include/kerrighed/sem.h
--- a/include/kerrighed/sem.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/sem.h	2007-05-23 19:14:40.000000000 +0200
@@ -0,0 +1,6 @@
+#ifndef __KKRG_SEM__
+#define __KKRG_SEM__
+
+#define sem_ids(ns)	(*((ns)->ids[IPC_SEM_IDS]))
+
+#endif // __KKRG_SEM__
diff -Nupr a/include/kerrighed/shm.h b/include/kerrighed/shm.h
--- a/include/kerrighed/shm.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/shm.h	2007-06-01 11:32:51.000000000 +0200
@@ -0,0 +1,85 @@
+#ifndef __KKRG_SHM__
+#define __KKRG_SHM__
+
+#include <linux/msg.h>
+#include <../ipc/util.h>
+
+struct vm_area_struct;
+
+
+/** Kerrighed Hooks **/
+
+extern struct shmid_kernel * (*kh_shm_lock)(struct ipc_namespace *ns, int id);
+extern void (*kh_shm_unlock)(struct shmid_kernel *shp);
+
+extern int (*kh_shm_newseg) (struct ipc_namespace *ns, 
+			     struct shmid_kernel * shp);
+extern void (*kh_shm_destroy)(struct ipc_namespace *ns,
+			      struct shmid_kernel *shp) ;
+extern void (*kh_shm_rmid)(struct ipc_namespace *ns,
+			   struct shmid_kernel *shp) ;
+extern int (*kh_shm_get_max_id)(struct ipc_namespace *ns, struct ipc_ids* ids);
+extern int (*kh_get_ipc_id)(struct ipc_ids* ids, int size);
+extern int (*kh_ipc_findkey)(struct ipc_ids* ids, key_t key);
+
+
+/** Exported variables  **/
+
+extern struct vm_operations_struct krg_shmem_vmops;
+extern struct file_operations shm_file_operations ;
+
+
+
+/** Exported functions  **/
+
+#define shm_ids(ns)	(*((ns)->ids[IPC_SHM_IDS]))
+#define shm_file_ns(file) (*((struct ipc_namespace **)&(file)->private_data))
+
+int shm_addid(struct ipc_namespace *ns, struct shmid_kernel *shp);
+void shm_inc(struct ipc_namespace *ns, int id);
+void shm_close (struct vm_area_struct *shmd);
+
+static inline struct shmid_kernel* local_shm_lock (struct ipc_namespace *ns,
+						   int id)
+{
+       return (struct shmid_kernel*)ipc_lock(&shm_ids(ns),id);
+}
+
+static inline struct shmid_kernel* shm_lock (struct ipc_namespace *ns, int id)
+{
+       if (kh_shm_lock)
+               return kh_shm_lock(ns, id);
+       else
+               return local_shm_lock(ns, id);
+}
+
+static inline void local_shm_unlock(struct shmid_kernel *shp)
+{
+       ipc_unlock(&(shp)->shm_perm);
+}
+static inline void shm_unlock(struct shmid_kernel *shp)
+{
+       if (kh_shm_unlock)
+               kh_shm_unlock(shp);
+       local_shm_unlock(shp);
+}
+
+void _shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp);
+
+static inline void shm_destroy(struct ipc_namespace *ns,
+			       struct shmid_kernel *shp)
+{
+	if (kh_shm_destroy) {
+		shp->locked_for_del = 1;
+		kh_shm_destroy(ns, shp);
+	}
+	else
+		_shm_destroy(ns, shp);
+}
+
+#define shm_get(ns, id)			\
+	((struct shmid_kernel*)ipc_get(&shm_ids(ns),id))
+#define shm_buildid(ns, id, seq)	\
+	ipc_buildid(&shm_ids(ns), id, seq)
+
+#endif // __KKRG_SHM__
diff -Nupr a/include/kerrighed/signal.h b/include/kerrighed/signal.h
--- a/include/kerrighed/signal.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/signal.h	2007-05-30 02:12:44.000000000 +0200
@@ -0,0 +1,48 @@
+#ifndef __KKRG_SIGNAL_H__
+#define __KKRG_SIGNAL_H__
+
+#ifdef CONFIG_KRG_PROC
+
+#include <linux/types.h>
+
+/* signal_struct sharing */
+
+struct kmem_cache;
+
+/* exported from kernel/fork.c */
+extern struct kmem_cache *signal_cachep;
+
+struct signal_struct;
+struct task_struct;
+
+extern
+struct signal_struct * (*kh_malloc_signal_struct)(struct task_struct *task,
+						  int need_update);
+extern void (*kh_share_signal)(struct task_struct *task);
+extern pid_t (*kh_exit_signal)(struct task_struct *task);
+extern struct signal_struct * (*kh_signal_struct_readlock)(pid_t tgid);
+extern struct signal_struct * (*kh_signal_struct_writelock)(pid_t tgid);
+extern void (*kh_signal_struct_unlock)(pid_t tgid);
+
+#endif /* CONFIG_KRG_PROC */
+
+#ifdef CONFIG_KRG_EPM
+
+/* sighand_struct sharing */
+
+struct sighand_struct;
+
+extern
+struct sighand_struct * (*kh_malloc_sighand_struct)(struct task_struct *task,
+						    int need_update);
+extern void (*kh_share_sighand)(struct task_struct *task);
+extern unsigned long (*kh_exit_sighand)(unsigned long id);
+extern struct sighand_struct * (*kh_sighand_struct_readlock)(unsigned long id);
+extern struct sighand_struct * (*kh_sighand_struct_writelock)(unsigned long id);
+extern void (*kh_sighand_struct_unlock)(unsigned long id);
+
+extern int next_signal(struct sigpending *pending, sigset_t *mask);
+
+#endif /* CONFIG_KRG_EPM */
+
+#endif /* __KKRG_SIGNAL_H__ */
diff -Nupr a/include/kerrighed/sys/capabilities.h b/include/kerrighed/sys/capabilities.h
--- a/include/kerrighed/sys/capabilities.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/sys/capabilities.h	2007-02-28 15:47:16.000000000 +0100
@@ -0,0 +1,37 @@
+/** Define Kerrighed Capabilities
+ * @author David Margery (c) Inria 2004
+ */
+
+#ifndef _KERRIGHED_CAPABILITIES_H
+#define _KERRIGHED_CAPABILITIES_H
+
+enum {
+       CAP_CHANGE_KERRIGHED_CAP = 0,
+       CAP_CAN_MIGRATE,
+       CAP_DISTANT_FORK,
+       CAP_FORK_DELAY,
+       CAP_CHECKPOINTABLE,
+       CAP_USE_REMOTE_MEMORY,
+       CAP_USE_INTRA_CLUSTER_KERSTREAMS,
+       CAP_USE_INTER_CLUSTER_KERSTREAMS,
+       CAP_USE_WORLD_VISIBLE_KERSTREAMS, //10
+       CAP_SEE_LOCAL_PROC_STAT,
+       CAP_SIZE //keep as last capability
+};
+
+typedef struct krg_cap_struct krg_cap_t;
+typedef struct krg_cap_pid_desc krg_cap_pid_t;
+
+#ifndef __KERNEL__
+
+struct krg_cap_struct
+{
+  int  krg_cap_effective ;
+  int  krg_cap_permitted ;
+  int  krg_cap_inheritable_permitted ;
+  int  krg_cap_inheritable_effective ;
+} ;
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Nupr a/include/kerrighed/sys/checkpoint.h b/include/kerrighed/sys/checkpoint.h
--- a/include/kerrighed/sys/checkpoint.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/sys/checkpoint.h	2007-03-28 12:21:08.000000000 +0200
@@ -0,0 +1,36 @@
+#ifndef CHECKPOINT_TYPES_H
+#define CHECKPOINT_TYPES_H
+
+typedef enum {
+	FROM_APPID,
+	FROM_PID,
+	CALCUL_FRONTIER,
+	FROM_INSIDE
+} type_ckpt_t;
+
+typedef enum {
+	DISK,
+	MEMORY
+} media_t;
+
+typedef struct checkpoint_info
+{
+	long app_id;
+
+	type_ckpt_t type;
+	media_t media;
+
+	int gid;
+
+	int chkpt_sn;
+	int result;
+} checkpoint_infos_t ;
+
+typedef struct restart_request
+{
+	long app_id;
+	int chkpt_sn;
+	media_t media;
+} restart_request_t;
+
+#endif
diff -Nupr a/include/kerrighed/sys/types.h b/include/kerrighed/sys/types.h
--- a/include/kerrighed/sys/types.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/sys/types.h	2007-05-18 18:16:57.000000000 +0200
@@ -0,0 +1,68 @@
+/** Main kerrighed types.
+ *  @file gtypes.h
+ *
+ *  Definition of the main types and structures.
+ *  @author Renaud Lottiaux
+ */
+
+#ifndef __KERRIGHED_TYPES__
+#define __KERRIGHED_TYPES__
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                                 MACROS                                   *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_KRG_AUTONODEID
+#define NR_BITS_IN_MAX_NODE_ID     7
+#else
+#define NR_BITS_IN_MAX_NODE_ID     7
+#endif
+
+#define KERRIGHED_MAX_NODES      (1<<NR_BITS_IN_MAX_NODE_ID)        /* Real limit 32766 */
+
+#define KERRIGHED_MAX_CLUSTERS   256
+#define KERRIGHED_NODE_ID_NONE    -1        /* Invalid node id */
+#define KERRIGHED_MAX_CPU_PER_NODE 4
+
+#define KERRIGHED_MAX_CPU (KERRIGHED_MAX_NODES * KERRIGHED_MAX_CPU_PER_NODE)
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                                  TYPES                                   *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+/** Type for node id           */
+typedef short kerrighed_node_t;
+
+/** Boolean type */
+typedef unsigned int bool_t;
+
+/** Event counter type */
+typedef unsigned long event_counter_t;
+
+/** Physical address type */
+typedef unsigned long physaddr_t;
+
+/** Network id */
+typedef unsigned int kerrighed_network_t;
+
+enum kerrighed_status {
+	KRG_FIRST_START,
+	KRG_FINAL_STOP,
+	KRG_NODE_STARTING,
+	KRG_NODE_STOPING,
+	KRG_RUNNING_CLUSTER,
+};
+typedef enum kerrighed_status kerrighed_status_t;
+
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                             EXTERN VARIABLES                             *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+#endif // __KERRIGHED_TYPES__
diff -Nupr a/include/kerrighed/syscalls.h b/include/kerrighed/syscalls.h
--- a/include/kerrighed/syscalls.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/syscalls.h	2007-04-20 11:44:40.000000000 +0200
@@ -0,0 +1,42 @@
+/* Kerrighed hooks for remote syscalls */
+
+#ifndef __KKRG_SYSCALLS__
+#define __KKRG_SYSCALLS__
+
+#ifdef CONFIG_KRG_PROC
+
+#include <linux/types.h>
+
+/* not implemented yet */
+extern int (*kh_setpriority)(int which, int who, int niceval, int *error);
+/* not implemented yet */
+extern int (*kh_getpriority)(int which, int who, long *error);
+
+struct siginfo;
+extern int (*kh_kill_proc_info) (int sig, struct siginfo *info, pid_t pid);
+extern int (*kh_kill_pg_info) (int sig, struct siginfo *info, pid_t pgid);
+extern void (*kh_kill_all)(int sig, struct siginfo *info,
+			   int *count, int *retval,
+			   int tgid);
+
+extern int (*kh_getpgid)(pid_t pid);
+extern int (*kh_getsid)(pid_t pid);
+
+struct sched_param;
+extern int (*kh_sched_setscheduler)(pid_t pid,
+				    int policy, struct sched_param *param);
+extern long (*kh_sched_getscheduler) (pid_t pid);
+extern int (*kh_sched_getparam) (pid_t pid, struct sched_param *lp);
+
+#endif /* CONFIG_KRG_PROC */
+
+#ifdef CONFIG_KRG_EPM
+
+#if 0 /* Temporarily disabled */
+extern int (*kh_setpgid)(pid_t pgid, pid_t session);
+#endif /* 0 */
+extern int (*kh_forward_setpgid)(pid_t pid, pid_t pgid);
+
+#endif
+
+#endif /* __KKRG_SYSCALLS__ */
diff -Nupr a/include/kerrighed/task.h b/include/kerrighed/task.h
--- a/include/kerrighed/task.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/task.h	2007-05-09 16:13:10.000000000 +0200
@@ -0,0 +1,96 @@
+#ifndef __KKRG_TASK_H__
+#define __KKRG_TASK_H__
+
+#ifdef CONFIG_KRG_PROC
+
+#include <linux/types.h>
+#include <asm/cputime.h>
+#include <linux/rwsem.h>
+#include <linux/kref.h>
+#include <kerrighed/sys/types.h>
+
+/* task container */
+
+struct task_struct;
+struct thread_info;
+#ifdef CONFIG_KRG_EPM
+struct pid_ctnr_object;
+#endif
+
+struct task_ctnr_object {
+	volatile long state;
+	unsigned long flags;
+	unsigned long ptrace;
+	long exit_state;
+	int exit_code, exit_signal;
+
+#if 0
+	struct {
+		int state;
+		pid_t waited_by;
+		int exit_value;
+	} krg_thread;
+#endif
+
+	kerrighed_node_t node;
+	u32 self_exec_id;
+	int thread_group_empty;
+
+	unsigned long sighand_struct_id;
+
+	pid_t pid;
+	pid_t parent;
+	pid_t real_parent;
+	pid_t real_parent_tgid;
+	pid_t group_leader;
+
+	uid_t uid;
+	uid_t euid;
+	gid_t egid;
+
+	cputime_t utime, stime;
+
+	unsigned dumpable;
+
+	/* The remaining fields are not shared */
+#ifdef CONFIG_KRG_EPM
+	struct pid_ctnr_object *pid_obj;
+#endif
+	struct task_struct *task;
+
+	struct rw_semaphore sem;
+	int write_locked;
+
+	int alive;
+	struct kref kref;
+};
+
+/* task_struct allocation outside kernel/fork.c */
+/* Copy from: Linux kernel 2.6.20, kernel/fork.c, lines 90..94 */
+#include <asm/thread_info.h>
+#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
+#include <linux/slab.h>
+# define alloc_task_struct()    kmem_cache_alloc(task_struct_cachep, GFP_KERNEL)
+# define free_task_struct(tsk)  kmem_cache_free(task_struct_cachep, (tsk))
+extern struct kmem_cache *task_struct_cachep;
+#endif
+
+extern void (*kh_task_get)(struct task_ctnr_object *obj);
+extern void (*kh_task_put)(struct task_ctnr_object *obj);
+extern int (*kh_task_alive)(struct task_ctnr_object *obj);
+extern struct task_ctnr_object * (*kh_task_readlock)(pid_t pid);
+extern struct task_ctnr_object * (*kh_task_writelock)(pid_t pid);
+extern struct task_ctnr_object * (*kh_task_writelock_nested)(pid_t pid);
+extern void (*kh_task_unlock)(pid_t pid);
+extern struct task_struct * (*kh_malloc_task_struct)(pid_t pid);
+extern void (*kh_free_task_struct)(struct task_struct *task);
+
+/* exit */
+extern void (*kh_release_task)(struct task_struct *task);
+
+/* kerrighed_task (to be removed) */
+extern void (*kh_copy_process)(struct task_struct *tsk);
+
+#endif /* CONFIG_KRG_PROC */
+
+#endif /* __KKRG_TASK_H__ */
diff -Nupr a/include/kerrighed/types.h b/include/kerrighed/types.h
--- a/include/kerrighed/types.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/types.h	2007-03-28 12:21:08.000000000 +0200
@@ -0,0 +1,39 @@
+#ifndef __KRG_TYPES_INTERNAL__
+#define __KRG_TYPES_INTERNAL__
+
+#include <kerrighed/sys/types.h>
+
+#ifdef __KERNEL__
+#include <kerrighed/vector.h>
+#endif
+
+#define KRGFCT(p) if(p!=NULL) p
+
+#ifdef CONFIG_KERRIGHED
+#define krgstatic
+#else
+#define krgstatic static
+#endif
+
+#ifdef CONFIG_KERRIGHED
+
+typedef unsigned char kerrighed_session_t;
+typedef int kerrighed_subsession_t;
+typedef unsigned long unique_id_t;   /**< Unique id type */
+
+#endif // CONFIG_KERRIGHED
+
+#ifdef __KERNEL__
+
+#ifdef CONFIG_KRG_STREAM
+struct dstream_socket { // shared node-wide
+	unique_id_t id_socket;
+	unique_id_t id_container;
+	struct dstream_interface_ctnr *interface_ctnr;
+	struct stream_socket *krg_socket;
+};
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif // __KRG_TYPES_INTERNAL__
diff -Nupr a/include/kerrighed/unique_id.h b/include/kerrighed/unique_id.h
--- a/include/kerrighed/unique_id.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/unique_id.h	2007-03-27 16:24:19.000000000 +0200
@@ -0,0 +1,105 @@
+/** Unique id generator interface
+ *  @file unique_id.h
+ *
+ *  Definition of unique id generator interface. This mechanism generates
+ *  locally, an indentifier which is unique in the cluster.
+ *  @author Renaud Lottiaux
+ */
+
+#ifndef __UNIQUE_ID_H__
+#define __UNIQUE_ID_H__
+
+
+#include <linux/spinlock.h>
+#include <kerrighed/types.h>
+
+
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                                 MACROS                                   *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+
+
+#define UNIQUE_ID_NONE 0          /**< Invalid unique id */
+
+#define UNIQUE_ID_LOCAL_BITS 24   /**< Number of bits used for local part of
+				       the unique id. */
+#define UNIQUE_ID_NODE_BITS 8     /**< Number of bits used for nodeid part of
+				       the unique id. */
+#define UNIQUE_ID_NODE_SHIFT (UNIQUE_ID_LOCAL_BITS)
+
+
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                                  TYPES                                   *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+
+
+/** Unique id root type
+ */
+typedef struct unique_id_root {
+	atomic_t local_unique_id;   /**< Local unique id */
+} unique_id_root_t;
+
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                              EXTERN VARIABLES                            *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+
+
+extern unique_id_root_t mm_unique_id_root;
+
+
+
+/*--------------------------------------------------------------------------*
+ *                                                                          *
+ *                              EXTERN FUNCTIONS                            *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+
+
+/** Initialize a unique id root.
+ *  @author Renaud Lottiaux
+ *
+ *  @param root   The root to initialize
+ *  @return       0 if everything ok.
+ *                Negative value otherwise.
+ */
+int init_unique_id_root(unique_id_root_t *root);
+
+
+
+/** Initialize a unique id root with a given init value.
+ *  @author Renaud Lottiaux
+ *
+ *  @param root   The root to initialize
+ *  @param base   Base value for the key generator.
+ *  @return       0 if everything ok.
+ *                Negative value otherwise.
+ */
+int init_and_set_unique_id_root(unique_id_root_t *root, int base);
+
+
+
+/** Generate a unique id from a given root.
+ *  @author Renaud Lottiaux
+ *
+ *  @param root   The root of the unique id to generate.
+ *  @return       A unique id !
+ */
+unique_id_t get_unique_id(unique_id_root_t *unique_id_root);
+
+
+void init_unique_ids(void);
+
+#endif // __UNIQUE_ID_H__
diff -Nupr a/include/kerrighed/utils.h b/include/kerrighed/utils.h
--- a/include/kerrighed/utils.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/utils.h	2007-02-26 15:34:35.000000000 +0100
@@ -0,0 +1,20 @@
+/** Util functions
+ *  @file utils.h
+ *
+ *  @author Jean Parpaillon
+ */
+
+#include <linux/string.h>
+#include <linux/random.h>
+#include <kerrighed/sys/types.h>
+
+static inline kerrighed_node_t get_random_active_node(void)
+{
+  kerrighed_node_t node ;
+  unsigned int random ;
+
+  get_random_bytes(&random, sizeof(int));
+  node = nth_node(random % kerrighed_nb_nodes) ;
+
+  return node ;
+}
diff -Nupr a/include/kerrighed/vector.h b/include/kerrighed/vector.h
--- a/include/kerrighed/vector.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/kerrighed/vector.h	2007-05-02 14:51:20.000000000 +0200
@@ -0,0 +1,196 @@
+/** Definition of some bit vector management functions.
+ *  @file vector.h
+ *
+ *  @author Renaud Lottiaux
+ */
+
+#ifndef __KRG_VECTOR__
+#define __KRG_VECTOR__
+
+
+#ifdef __KERNEL__
+#include <linux/string.h>
+#include <asm/bitops.h>
+#else
+#include <string.h>
+
+/* Redefine the necessary bit functions since including the kernel header does
+ * not work anymore from userspace */
+/* All defs are taken from asm-i386/bitops.h and arch/i386/lib/bitops.c */
+
+/* Assume SMP by default */
+#define LOCK_PREFIX "\n\tlock; "
+
+#define ADDR (*(volatile long *) addr)
+
+static inline void set_bit(int nr, volatile unsigned long * addr)
+{
+	__asm__ __volatile__( LOCK_PREFIX
+		"btsl %1,%0"
+		:"+m" (ADDR)
+		:"Ir" (nr));
+}
+
+static inline void clear_bit(int nr, volatile unsigned long * addr)
+{
+	__asm__ __volatile__( LOCK_PREFIX
+		"btrl %1,%0"
+		:"+m" (ADDR)
+		:"Ir" (nr));
+}
+
+static inline int test_bit(int nr, const volatile unsigned long * addr)
+{
+	int oldbit;
+
+	__asm__ __volatile__(
+		"btl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit)
+		:"m" (ADDR),"Ir" (nr));
+	return oldbit;
+}
+
+#undef ADDR
+
+static inline unsigned long __ffs(unsigned long word)
+{
+	__asm__("bsfl %1,%0"
+		:"=r" (word)
+		:"rm" (word));
+	return word;
+}
+
+static inline unsigned find_first_bit(const unsigned long *addr, unsigned size)
+{
+	unsigned x = 0;
+
+	while (x < size) {
+		unsigned long val = *addr++;
+		if (val)
+			return __ffs(val) + x;
+		x += (sizeof(*addr)<<3);
+	}
+	return x;
+}
+
+/* Take from arch/i386/lib/bitops.c */
+static inline int find_next_bit(const unsigned long *addr, int size, int offset)
+{
+	const unsigned long *p = addr + (offset >> 5);
+	int set = 0, bit = offset & 31, res;
+
+	if (bit) {
+		/*
+		 * Look for nonzero in the first 32 bits:
+		 */
+		__asm__("bsfl %1,%0\n\t"
+			"jne 1f\n\t"
+			"movl $32, %0\n"
+			"1:"
+			: "=r" (set)
+			: "r" (*p >> bit));
+		if (set < (32 - bit))
+			return set + offset;
+		set = 32 - bit;
+		p++;
+	}
+	/*
+	 * No set bit yet, search remaining full words for a bit
+	 */
+	res = find_first_bit (p, size - 32 * (p - addr));
+	return (offset + set + res);
+}
+
+#endif /* __KERNEL__ */
+
+#define KERRIGHED_VECTOR_SIZE_BITS 256
+#define KERRIGHED_VECTOR_SIZE_BYTES (KERRIGHED_VECTOR_SIZE_BITS/8)
+
+typedef struct vector {
+  unsigned long vector[KERRIGHED_VECTOR_SIZE_BYTES/sizeof(unsigned long)];
+} vector_t;
+
+typedef vector_t kerrighed_nodes_t;
+
+/** Operations on vectors */
+
+/** Clear all bits in vector */
+static inline void clear_vector(vector_t *vector)
+{
+  memset(vector->vector, 0, KERRIGHED_VECTOR_SIZE_BYTES);
+}
+
+/** Set the bit index in vector */
+static inline void add_to_vector(vector_t *vector, int index)
+{
+  set_bit(index, vector->vector);
+}
+
+/** Reset the bit index in vector */
+static inline void remove_from_vector(vector_t *vector, int index)
+{
+  clear_bit(index, vector->vector);
+}
+
+/** Return a non null number if the index is set in the vector */
+static inline int is_in_vector(vector_t *vector, int index)
+{
+  return test_bit(index, vector->vector);
+}
+
+/** Return true if the index is the only one set in the vector */
+static inline int is_unique_in_vector(vector_t *vector, int index)
+{
+  int i;
+  
+  i = find_first_bit(vector->vector, KERRIGHED_VECTOR_SIZE_BITS);
+  if(i != index) return 0;
+  
+  i = find_next_bit(vector->vector, KERRIGHED_VECTOR_SIZE_BITS, index+1);
+  if(i != KERRIGHED_VECTOR_SIZE_BITS) return 0;
+  
+  return 1;
+}
+
+/** Return true if the vector is empty */
+static inline int vector_empty(vector_t *vector)
+{
+  return find_first_bit(vector->vector, KERRIGHED_VECTOR_SIZE_BITS) ==
+    KERRIGHED_VECTOR_SIZE_BITS;
+}
+
+/** Copy a vector */
+static inline void copy_vector(vector_t *vdest, vector_t *vsrc)
+{
+  memcpy(vdest->vector, vsrc->vector, KERRIGHED_VECTOR_SIZE_BYTES);
+}
+
+/** Find the first bit set in the vector */
+static inline int find_first_in_vector(vector_t *vector)
+{
+  return find_first_bit(vector->vector, KERRIGHED_VECTOR_SIZE_BITS) ;
+}
+
+/** Find the next bit set in the vector */
+static inline int find_next_in_vector(vector_t *vector, int index)
+{
+  return find_next_bit(vector->vector, KERRIGHED_VECTOR_SIZE_BITS, index) ;
+}
+
+static inline int is_equal_vector(vector_t *v1, vector_t *v2){
+  int i;
+
+  for(i=0;i<KERRIGHED_VECTOR_SIZE_BITS;i++)
+    if( (is_in_vector(v1, i) && !is_in_vector(v2, i))
+	|| (!is_in_vector(v1, i) && is_in_vector(v2, i))
+	)
+      return 0;
+
+  return 1;
+};
+
+#ifdef __KERNEL__
+#define print_vector(VEC) {int i; printk ("[ ");for(i=KERRIGHED_VECTOR_SIZE_BYTES/sizeof(unsigned long) - 1;i>=0;i--)printk("%08lx ", VEC.vector[i]); printk("]\n");}
+#endif /* __KERNEL__ */
+
+#endif // __KRG_VECTOR__
diff -Nupr a/include/linux/binfmts.h b/include/linux/binfmts.h
--- a/include/linux/binfmts.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/binfmts.h	2007-03-28 12:21:08.000000000 +0200
@@ -29,6 +29,12 @@ struct linux_binprm{
 	struct file * file;
 	int e_uid, e_gid;
 	kernel_cap_t cap_inheritable, cap_permitted, cap_effective;
+#ifdef CONFIG_KRG_CAP
+	/* The model need changes with filesystem support  ... */
+#if 0
+	kernel_cap_t krg_cap_permitted, krg_cap_forced, krg_cap_effective;
+#endif /* 0 */
+#endif
 	void *security;
 	int argc, envc;
 	char * filename;	/* Name of binary as seen by procps */
diff -Nupr a/include/linux/fcntl.h b/include/linux/fcntl.h
--- a/include/linux/fcntl.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/fcntl.h	2007-03-07 17:29:15.000000000 +0100
@@ -59,4 +59,8 @@
 
 #endif /* __KERNEL__ */
 
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/fcntl.h>
+#endif
+
 #endif
diff -Nupr a/include/linux/file.h b/include/linux/file.h
--- a/include/linux/file.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/file.h	2007-03-07 17:29:15.000000000 +0100
@@ -72,7 +72,9 @@ extern struct file * FASTCALL(fget(unsig
 extern struct file * FASTCALL(fget_light(unsigned int fd, int *fput_needed));
 extern void FASTCALL(set_close_on_exec(unsigned int fd, int flag));
 extern void put_filp(struct file *);
+#ifndef CONFIG_KRG_FAF
 extern int get_unused_fd(void);
+#endif
 extern void FASTCALL(put_unused_fd(unsigned int fd));
 struct kmem_cache;
 
@@ -100,8 +102,9 @@ static inline struct file * fcheck_files
  */
 #define fcheck(fd)	fcheck_files(current->files, fd)
 
+#ifndef CONFIG_KRG_FAF
 extern void FASTCALL(fd_install(unsigned int fd, struct file * file));
-
+#endif
 struct task_struct;
 
 struct files_struct *get_files_struct(struct task_struct *);
@@ -110,4 +113,8 @@ void reset_files_struct(struct task_stru
 
 extern struct kmem_cache *files_cachep;
 
+#ifdef CONFIG_KRG_DVFS
+#include <kerrighed/file.h>
+#endif
+
 #endif /* __LINUX_FILE_H */
diff -Nupr a/include/linux/fs.h b/include/linux/fs.h
--- a/include/linux/fs.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/fs.h	2007-05-16 13:12:13.000000000 +0200
@@ -447,6 +447,9 @@ struct address_space {
 	spinlock_t		private_lock;	/* for use by the address_space */
 	struct list_head	private_list;	/* ditto */
 	struct address_space	*assoc_mapping;	/* ditto */
+#ifdef CONFIG_KRG_DVFS
+	struct kddm_set         *kddm_set;
+#endif // CONFIG_KRG_DVFS
 } __attribute__((aligned(sizeof(long))));
 	/*
 	 * On most architectures that alignment is already the case; but
@@ -569,6 +572,10 @@ struct inode {
 
 	__u32			i_generation;
 
+#ifdef CONFIG_KRG_DVFS
+	unsigned long		i_objid;
+#endif
+
 #ifdef CONFIG_DNOTIFY
 	unsigned long		i_dnotify_mask; /* Directory notify events */
 	struct dnotify_struct	*i_dnotify; /* for directory notifications */
@@ -730,6 +737,12 @@ struct file {
 #ifdef CONFIG_SECURITY
 	void			*f_security;
 #endif
+#ifdef CONFIG_KRG_DVFS
+	unsigned long		f_objid;
+#endif
+#ifdef CONFIG_KRG_FAF
+	unsigned long		f_faf_srv_index;
+#endif
 	/* needed for tty driver, and maybe others */
 	void			*private_data;
 
@@ -745,6 +758,7 @@ extern spinlock_t files_lock;
 #define file_list_unlock() spin_unlock(&files_lock);
 
 #define get_file(x)	atomic_inc(&(x)->f_count)
+
 #define file_count(x)	atomic_read(&(x)->f_count)
 
 #define	MAX_NON_LFS	((1UL<<31) - 1)
@@ -1463,7 +1477,11 @@ extern long do_sys_open(int fdf, const c
 			int mode);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+#ifdef CONFIG_KRG_FAF
+extern int __filp_close(struct file *, fl_owner_t id);
+#else
 extern int filp_close(struct file *, fl_owner_t id);
+#endif
 extern char * getname(const char __user *);
 
 /* fs/dcache.c */
@@ -2000,5 +2018,9 @@ static inline void free_secdata(void *se
 { }
 #endif	/* CONFIG_SECURITY */
 
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */
diff -Nupr a/include/linux/highmem.h b/include/linux/highmem.h
--- a/include/linux/highmem.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/highmem.h	2007-03-01 17:58:36.000000000 +0100
@@ -125,4 +125,8 @@ static inline void copy_highpage(struct 
 	kunmap_atomic(vto, KM_USER1);
 }
 
+#ifdef CONFIG_KRG_MM
+#include <kerrighed/highmem.h>
+#endif
+
 #endif /* _LINUX_HIGHMEM_H */
diff -Nupr a/include/linux/init_task.h b/include/linux/init_task.h
--- a/include/linux/init_task.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/init_task.h	2007-05-28 17:09:42.000000000 +0200
@@ -56,6 +56,13 @@
 	.cpu_vm_mask	= CPU_MASK_ALL,				\
 }
 
+#ifdef CONFIG_KRG_PROC
+#define INIT_SIGNALS_PROC					\
+	.krg_objid	= 0,
+#else
+#define INIT_SIGNALS_PROC
+#endif
+
 #define INIT_SIGNALS(sig) {						\
 	.count		= ATOMIC_INIT(1), 				\
 	.wait_chldexit	= __WAIT_QUEUE_HEAD_INITIALIZER(sig.wait_chldexit),\
@@ -68,6 +75,7 @@
 	.pgrp		= 1,						\
 	.tty_old_pgrp   = 0,						\
 	{ .__session      = 1},						\
+	INIT_SIGNALS_PROC						\
 }
 
 extern struct nsproxy init_nsproxy;
@@ -80,14 +88,71 @@ extern struct nsproxy init_nsproxy;
 	INIT_IPC_NS(ipc_ns)						\
 }
 
+#ifdef CONFIG_KRG_HOTPLUG
+#define INIT_SIGHAND_HOTPLUG						\
+	.krg_action	= { { { .sa_handler = NULL, } }, },
+#else
+#define INIT_SIGHAND_HOTPLUG
+#endif
+
+#ifdef CONFIG_KRG_EPM
+#define INIT_SIGHAND_EPM						\
+	.krg_objid	= 0,
+#else
+#define INIT_SIGHAND_EPM
+#endif
+
 #define INIT_SIGHAND(sighand) {						\
 	.count		= ATOMIC_INIT(1), 				\
 	.action		= { { { .sa_handler = NULL, } }, },		\
+	INIT_SIGHAND_HOTPLUG						\
 	.siglock	= __SPIN_LOCK_UNLOCKED(sighand.siglock),	\
+	INIT_SIGHAND_EPM						\
 }
 
 extern struct group_info init_groups;
 
+#ifdef CONFIG_KRG_CTNR
+#define INIT_CTNR .kddm_info = NULL,
+#else
+#define INIT_CTNR
+#endif
+
+#ifdef CONFIG_KRG_CAP
+#define INIT_KRG_CAP							\
+	.krg_cap_effective	       = KRG_CAP_INIT_EFF_SET,		\
+	.krg_cap_permitted	       = KRG_CAP_INIT_PERM_SET,		\
+	.krg_cap_inheritable_effective = KRG_CAP_INIT_INH_EFF_SET,	\
+	.krg_cap_inheritable_permitted = KRG_CAP_INIT_INH_PER_SET,
+#else
+#define INIT_KRG_CAP
+#endif
+
+#ifdef CONFIG_KRG_HOTPLUG
+#define INIT_HOTPLUG 							\
+	.krg_blocked	= {{0}},
+#else
+#define INIT_HOTPLUG
+#endif
+
+#ifdef CONFIG_KRG_PROC
+#define INIT_PROC							\
+	.task_ctnr	= NULL,
+#else
+#define INIT_PROC
+#endif
+
+#ifdef CONFIG_KRG_EPM
+#define INIT_EPM(tsk)							\
+	.krg_task	= NULL,						\
+	.effective_current = NULL,					\
+	.parent_children_obj = NULL,					\
+	.children_obj	= NULL,						\
+	.distant_children = LIST_HEAD_INIT(tsk.distant_children),
+#else
+#define INIT_EPM
+#endif
+
 /*
  *  INIT_TASK is used to set up the first task table, touch at
  * your own risk!. Base=0, limit=0x1fffff (=2MB)
@@ -141,6 +206,11 @@ extern struct group_info init_groups;
 	.pi_lock	= SPIN_LOCK_UNLOCKED,				\
 	INIT_TRACE_IRQFLAGS						\
 	INIT_LOCKDEP							\
+	INIT_CTNR							\
+	INIT_KRG_CAP							\
+	INIT_HOTPLUG							\
+	INIT_PROC							\
+	INIT_EPM(tsk)							\
 }
 
 
diff -Nupr a/include/linux/ipc.h b/include/linux/ipc.h
--- a/include/linux/ipc.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/ipc.h	2007-03-02 18:26:40.000000000 +0100
@@ -123,6 +123,10 @@ static inline void put_ipc_ns(struct ipc
 #endif
 }
 
+#ifdef CONFIG_KRG_IPC
+#include <kerrighed/ipc.h>
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_IPC_H */
diff -Nupr a/include/linux/kdbprivate.h b/include/linux/kdbprivate.h
--- a/include/linux/kdbprivate.h	2007-06-05 17:06:30.000000000 +0200
+++ b/include/linux/kdbprivate.h	2007-05-10 12:33:18.000000000 +0200
@@ -121,6 +121,7 @@ extern int kdbgetaddrarg(int, const char
 			 long *, char **);
 extern int kdbgetsymval(const char *, kdb_symtab_t *);
 extern int kdbnearsym(unsigned long, kdb_symtab_t *);
+extern void kdbnearsym_cleanup(void);
 extern char *kdb_read(char *buffer, size_t bufsize);
 extern char *kdb_strdup(const char *str, gfp_t type);
 extern void kdb_symbol_print(kdb_machreg_t, const kdb_symtab_t *, unsigned int);
@@ -467,6 +468,7 @@ extern void kdb_runqueue(unsigned long c
 
 extern void *debug_kmalloc(size_t size, gfp_t flags);
 extern void debug_kfree(const void *);
+extern void debug_kusage(void);
 
 extern void kdba_set_current_task(const struct task_struct *);
 extern const struct task_struct *kdb_current_task;
@@ -489,5 +491,6 @@ extern int kdba_verify_rw(unsigned long 
 
 extern int kdb_wait_for_cpus_secs;
 extern void kdba_cpu_up(void);
+extern char kdb_prompt_str[];
 
 #endif	/* !_KDBPRIVATE_H */
diff -Nupr a/include/linux/mm.h b/include/linux/mm.h
--- a/include/linux/mm.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/mm.h	2007-03-01 17:58:36.000000000 +0100
@@ -68,6 +68,14 @@ struct vm_area_struct {
 
 	pgprot_t vm_page_prot;		/* Access permissions of this VMA. */
 	unsigned long vm_flags;		/* Flags, listed below. */
+#ifdef CONFIG_KRG_MM
+	struct vm_operations_struct * initial_vm_ops;
+	int last_fault;    /* Type of memory fault for the last page fault.
+			    * Cleaner solution is to add this value as an
+			    * argument to vm_ops nopage function. But all
+			    * nopage functions sould then be modified...
+			    */
+#endif // CONFIG_KRG_MM
 
 	struct rb_node vm_rb;
 
@@ -202,6 +210,10 @@ struct vm_operations_struct {
 	void (*open)(struct vm_area_struct * area);
 	void (*close)(struct vm_area_struct * area);
 	struct page * (*nopage)(struct vm_area_struct * area, unsigned long address, int *type);
+#ifdef CONFIG_KRG_MM
+	struct page * (*wppage)(struct vm_area_struct * area, unsigned long address);
+	void (*unlink) ( struct vm_area_struct *area );
+#endif // CONFIG_KRG_MM
 	unsigned long (*nopfn)(struct vm_area_struct * area, unsigned long address);
 	int (*populate)(struct vm_area_struct * area, unsigned long address, unsigned long len, pgprot_t prot, unsigned long pgoff, int nonblock);
 
@@ -1167,5 +1179,9 @@ extern int randomize_va_space;
 
 __attribute__((weak)) const char *arch_vma_name(struct vm_area_struct *vma);
 
+#ifdef CONFIG_KRG_MM
+#include <kerrighed/mm.h>
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_MM_H */
diff -Nupr a/include/linux/msg.h b/include/linux/msg.h
--- a/include/linux/msg.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/msg.h	2007-05-23 19:14:40.000000000 +0200
@@ -98,6 +98,10 @@ extern long do_msgsnd(int msqid, long mt
 extern long do_msgrcv(int msqid, long *pmtype, void __user *mtext,
 			size_t msgsz, long msgtyp, int msgflg);
 
+#ifdef CONFIG_KRG_IPC
+#include <kerrighed/msg.h>
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_MSG_H */
diff -Nupr a/include/linux/page-flags.h b/include/linux/page-flags.h
--- a/include/linux/page-flags.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/page-flags.h	2007-04-26 16:55:16.000000000 +0200
@@ -91,6 +91,25 @@
 #define PG_nosave_free		18	/* Used for system suspend/resume */
 #define PG_buddy		19	/* Page is free, on buddy lists */
 
+#ifdef CONFIG_KRG_MM
+#define PG_to_invalidate       20
+#define PG_to_set_read_only    21
+#ifdef CONFIG_DEBUG_PAGEALLOC
+#define PG_in_vec              22
+
+#define PageInVec(page)       test_bit(PG_in_vec, &(page)->flags)
+#define SetPageInVec(page)    set_bit(PG_in_vec, &(page)->flags)
+#define ClearPageInVec(page)  clear_bit(PG_in_vec, &(page)->flags)
+#endif
+
+#define PageToInvalidate(page)      test_bit(PG_to_invalidate, &(page)->flags)
+#define SetPageToInvalidate(page)   set_bit(PG_to_invalidate, &(page)->flags)
+#define ClearPageToInvalidate(page) clear_bit(PG_to_invalidate, &(page)->flags)
+
+#define PageToSetReadOnly(page)     test_bit(PG_to_set_read_only, &(page)->flags)
+#define SetPageToSetReadOnly(page)  set_bit(PG_to_set_read_only, &(page)->flags)
+#define ClearPageToSetReadOnly(page) clear_bit(PG_to_set_read_only, &(page)->flags)
+#endif // CONFIG_KRG_MM
 
 #if (BITS_PER_LONG > 32)
 /*
diff -Nupr a/include/linux/pagevec.h b/include/linux/pagevec.h
--- a/include/linux/pagevec.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/pagevec.h	2007-04-26 16:55:16.000000000 +0200
@@ -58,6 +58,9 @@ static inline unsigned pagevec_space(str
  */
 static inline unsigned pagevec_add(struct pagevec *pvec, struct page *page)
 {
+#ifdef CONFIG_DEBUG_PAGEALLOC
+	SetPageInVec(page);
+#endif
 	pvec->pages[pvec->nr++] = page;
 	return pagevec_space(pvec);
 }
diff -Nupr a/include/linux/pid.h b/include/linux/pid.h
--- a/include/linux/pid.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/pid.h	2007-03-28 12:21:08.000000000 +0200
@@ -40,6 +40,10 @@ enum pid_type
  * processes.
  */
 
+#ifdef CONFIG_KRG_EPM
+struct pid_ctnr_object;
+#endif
+
 struct pid
 {
 	atomic_t count;
@@ -49,6 +53,9 @@ struct pid
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
 	struct rcu_head rcu;
+#ifdef CONFIG_KRG_EPM
+	struct pid_ctnr_object *ctnr_obj;
+#endif
 };
 
 struct pid_link
diff -Nupr a/include/linux/proc_fs.h b/include/linux/proc_fs.h
--- a/include/linux/proc_fs.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/proc_fs.h	2007-05-02 17:07:43.000000000 +0200
@@ -249,11 +249,42 @@ union proc_op {
 	int (*proc_read)(struct task_struct *task, char *page);
 };
 
+#if defined(CONFIG_KRG_PROCFS) && defined(CONFIG_KRG_PROC)
+#include <linux/types.h>
+#include <kerrighed/sys/types.h>
+
+struct proc_distant_pid_info;
+
+union proc_distant_op {
+	int (*proc_get_link)(struct inode *,
+			     struct dentry **, struct vfsmount **);
+	int (*proc_read)(struct proc_distant_pid_info *task, char *page);
+};
+
+struct task_ctnr_object;
+
+struct proc_distant_pid_info {
+	struct task_ctnr_object *task_obj;
+	pid_t pid;
+	kerrighed_node_t prob_node;
+	int dumpable;
+	uid_t euid;
+	gid_t egid;
+	union proc_distant_op op;
+};
+#endif
+
 struct proc_inode {
 	struct pid *pid;
 	int fd;
 	union proc_op op;
 	struct proc_dir_entry *pde;
+#ifdef CONFIG_KRG_PROCFS
+	void *krg_procfs_private;
+#ifdef CONFIG_KRG_PROC
+	struct proc_distant_pid_info distant_proc;
+#endif
+#endif
 	struct inode vfs_inode;
 };
 
diff -Nupr a/include/linux/sched.h b/include/linux/sched.h
--- a/include/linux/sched.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/sched.h	2007-04-23 18:42:25.000000000 +0200
@@ -86,6 +86,15 @@ struct sched_param {
 
 #include <asm/processor.h>
 
+#ifdef CONFIG_KRG_CAP
+#include <kerrighed/capabilities.h>
+#endif
+
+#ifdef CONFIG_KRG_TOOLS
+#include <kerrighed/vector.h>
+#include <kerrighed/types.h>
+#endif
+
 struct exec_domain;
 struct futex_pi_state;
 
@@ -151,6 +160,10 @@ extern unsigned long weighted_cpuload(co
 /* in tsk->state again */
 #define TASK_NONINTERACTIVE	64
 #define TASK_DEAD		128
+#ifdef CONFIG_KRG_EPM
+/* in tsk->exit_state */
+#define EXIT_MIGRATION		256
+#endif
 
 #define __set_task_state(tsk, state_value)		\
 	do { (tsk)->state = (state_value); } while (0)
@@ -370,6 +383,11 @@ struct mm_struct {
 	int core_waiters;
 	struct completion *core_startup_done, core_done;
 
+#ifdef CONFIG_KRG_MM
+	struct kddm_set * anon_vma_kddm_set;
+	unique_id_t mm_id;
+#endif // CONFIG_KRG_MM
+
 	/* aio bits */
 	rwlock_t		ioctx_list_lock;
 	struct kioctx		*ioctx_list;
@@ -378,7 +396,13 @@ struct mm_struct {
 struct sighand_struct {
 	atomic_t		count;
 	struct k_sigaction	action[_NSIG];
+#ifdef CONFIG_KRG_HOTPLUG
+	struct k_sigaction	krg_action[_NSIG];
+#endif
 	spinlock_t		siglock;
+#ifdef CONFIG_KRG_EPM
+	unsigned long		krg_objid;
+#endif
 };
 
 struct pacct_struct {
@@ -491,6 +515,9 @@ struct signal_struct {
 #ifdef CONFIG_TASKSTATS
 	struct taskstats *stats;
 #endif
+#ifdef CONFIG_KRG_PROC
+	unsigned long krg_objid;
+#endif
 };
 
 /* Context switch must be unlocked if interrupts are to be enabled */
@@ -798,6 +825,16 @@ enum sleep_type {
 
 struct prio_array;
 
+#ifdef CONFIG_KRG_FD
+/* FORK_DELAY */
+//see fd_flag
+typedef enum {
+	NOT_A_PFD,
+	PFD_NOT_ALREADY_WU,
+	PFD_ALREADY_WU
+} pfd_state;
+#endif //CONFIG_KRG_FD
+
 struct task_struct {
 	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
 	struct thread_info *thread_info;
@@ -938,6 +975,9 @@ struct task_struct {
 	struct sighand_struct *sighand;
 
 	sigset_t blocked, real_blocked;
+#ifdef CONFIG_KRG_HOTPLUG
+	sigset_t krg_blocked;
+#endif
 	sigset_t saved_sigmask;		/* To be restored with TIF_RESTORE_SIGMASK */
 	struct sigpending pending;
 
@@ -1051,6 +1091,37 @@ struct task_struct {
 #ifdef CONFIG_FAULT_INJECTION
 	int make_it_fail;
 #endif
+
+#ifdef CONFIG_KRG_CAP
+        kernel_cap_t krg_cap_effective;
+	kernel_cap_t krg_cap_permitted;
+	kernel_cap_t krg_cap_inheritable_effective;
+	kernel_cap_t krg_cap_inheritable_permitted;
+        atomic_t krg_cap_used[CAP_SIZE];
+        atomic_t krg_cap_unavailable[CAP_SIZE];
+        atomic_t krg_cap_unavailable_private[CAP_SIZE];
+#endif
+#ifdef CONFIG_KRG_PROC
+	struct task_ctnr_object *task_ctnr;
+#endif
+#ifdef CONFIG_KRG_EPM
+	struct kerrighed_task *krg_task;
+	struct task_struct *effective_current;
+	struct children_ctnr_object *parent_children_obj;
+	struct children_ctnr_object *children_obj;
+	struct list_head distant_children;
+#endif
+#ifdef CONFIG_KRG_FD
+	/* FORK_DELAY */
+	pfd_state fd_flag; //not a pfd, already wake up, not already wake up...
+#endif
+#ifdef CONFIG_KRG_TOOLS
+        vector_t ack_vector;
+        long ack_result;
+#endif
+#ifdef CONFIG_KRG_CTNR
+	struct kddm_info_struct *kddm_info;
+#endif
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
diff -Nupr a/include/linux/sem.h b/include/linux/sem.h
--- a/include/linux/sem.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/sem.h	2007-05-23 19:14:40.000000000 +0200
@@ -155,6 +155,10 @@ static inline void exit_sem(struct task_
 }
 #endif
 
+#ifdef CONFIG_KRG_IPC
+#include <kerrighed/sem.h>
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SEM_H */
diff -Nupr a/include/linux/shm.h b/include/linux/shm.h
--- a/include/linux/shm.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/shm.h	2007-03-02 18:26:40.000000000 +0100
@@ -85,6 +85,11 @@ struct shmid_kernel /* private to the ke
 	time_t			shm_ctim;
 	pid_t			shm_cprid;
 	pid_t			shm_lprid;
+#ifdef CONFIG_KRG_IPC
+	short			shm_cnode;
+	short			shm_lnode;
+	short			locked_for_del;
+#endif // CONFIG_KRG_IPC
 	struct user_struct	*mlock_user;
 };
 
@@ -104,6 +109,10 @@ static inline long do_shmat(int shmid, c
 }
 #endif
 
+#ifdef CONFIG_KRG_IPC
+#include <kerrighed/shm.h>
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SHM_H_ */
diff -Nupr a/include/linux/sysctl.h b/include/linux/sysctl.h
--- a/include/linux/sysctl.h	2007-06-05 17:06:30.000000000 +0200
+++ b/include/linux/sysctl.h	2007-03-02 22:59:22.000000000 +0100
@@ -58,6 +58,21 @@ struct __sysctl_args {
 #define CTL_UNNUMBERED	CTL_NONE	/* sysctl without a binary number */
 #endif
 
+#ifdef CONFIG_KRG_FD
+enum {
+	CTL_FD_THRESHOLD = 1,
+	CTL_FD_VERSION = 2,
+	CTL_FD_FIFO = 3,
+	CTL_FD_VLOAD = 4,
+	CTL_FD_WAIT_TIME = 5,
+	CTL_FD_THRESHOLD_SCHED = 6,
+//#ifdef CONFIG_FD_V1
+	CTL_FD_JETON = 7,
+	CTL_FD_VAR_CHAN_ADMIN = 8,
+//#endif //V1
+};
+#endif //FD
+
 enum
 {
 	CTL_KERN=1,		/* General kernel info and control */
@@ -69,7 +84,12 @@ enum
 	CTL_DEV=7,		/* Devices */
 	CTL_BUS=8,		/* Busses */
 	CTL_ABI=9,		/* Binary emulation */
+#ifndef CONFIG_KRG_FD
 	CTL_CPU=10		/* CPU stuff (speed scaling, etc) */
+#else
+	CTL_CPU=10,		/* CPU stuff (speed scaling, etc) */
+	CTL_FD=11		/* Fork Delay */
+#endif //FD
 };
 
 /* CTL_BUS names: */
diff -Nupr a/include/linux/threads.h b/include/linux/threads.h
--- a/include/linux/threads.h	2007-02-04 19:44:54.000000000 +0100
+++ b/include/linux/threads.h	2007-03-16 16:18:27.000000000 +0100
@@ -21,6 +21,7 @@
 
 #define MIN_THREADS_LEFT_FOR_ROOT 4
 
+#ifndef CONFIG_KRG_PROC
 /*
  * This controls the default maximum pid allocated to a process
  */
@@ -33,4 +34,15 @@
 #define PID_MAX_LIMIT (CONFIG_BASE_SMALL ? PAGE_SIZE * 8 : \
 	(sizeof(long) > 4 ? 4 * 1024 * 1024 : PID_MAX_DEFAULT))
 
+#else /* CONFIG_KRG_PROC */
+
+/* We need the number of bits for Kerrighed PIDs definitions. */
+#define NR_BITS_PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 12 : 15)
+#define PID_MAX_DEFAULT (1 << NR_BITS_PID_MAX_DEFAULT)
+
+#define NR_BITS_PID_MAX_LIMIT (CONFIG_BASE_SMALL ? PAGE_SHIFT + 3 : \
+	(sizeof(long) > 4 ? 22 : NR_BITS_PID_MAX_DEFAULT))
+#define PID_MAX_LIMIT (1 << NR_BITS_PID_MAX_LIMIT)
+#endif /* CONFIG_KRG_PROC */
+
 #endif
diff -Nupr a/init/main.c b/init/main.c
--- a/init/main.c	2007-06-05 17:06:30.000000000 +0200
+++ b/init/main.c	2007-02-26 15:35:07.000000000 +0100
@@ -63,6 +63,11 @@
 #include <asm/smp.h>
 #endif
 
+#ifdef CONFIG_KRG_COMMUNICATION_FRAMEWORK
+#include <kerrighed/types.h>
+#include <kerrighed/krginit.h>
+#endif
+
 #ifdef	CONFIG_KDB
 #include <linux/kdb.h>
 #endif	/* CONFIG_KDB */
@@ -111,9 +116,19 @@ static inline void mark_rodata_ro(void) 
 extern void tc_init(void);
 #endif
 
+#ifdef CONFIG_KRG_COMMUNICATION_FRAMEWORK
+extern void kerrighed_init(void);
+extern void global_pid_init(int, int, int, int);
+#endif
+
 enum system_states system_state;
 EXPORT_SYMBOL(system_state);
 
+static int __initdata early_kerrighed_node_id=-1;
+static int __initdata early_kerrighed_session_id=-1;
+static int __initdata early_kerrighed_nb_nodes=-1;
+static int __initdata early_kerrighed_nb_nodes_min=-1;
+
 /*
  * Boot command-line arguments
  */
@@ -773,6 +788,10 @@ static int init(void * unused)
 
 	cpuset_init_smp();
 
+#ifdef CONFIG_KRG_COMMUNICATION_FRAMEWORK
+	kerrighed_init();
+#endif
+	
 	do_basic_setup();
 
 	/*
@@ -788,6 +807,12 @@ static int init(void * unused)
 		prepare_namespace();
 	}
 
+#ifdef CONFIG_KERRIGHED
+	global_pid_init(early_kerrighed_node_id, early_kerrighed_nb_nodes, 
+			early_kerrighed_session_id, early_kerrighed_nb_nodes_min);
+#endif
+
+	
 	/*
 	 * Ok, we have completed the initial bootup, and
 	 * we're essentially up and running. Get rid of the
@@ -829,3 +854,36 @@ static int init(void * unused)
 
 	panic("No init found.  Try passing init= option to kernel.");
 }
+
+static int __init  parse_node_id(char *str)
+{
+	get_option(&str, &early_kerrighed_node_id);
+
+	return 0;
+}
+
+static int __init  parse_nb_nodes(char *str)
+{
+	get_option(&str, &early_kerrighed_nb_nodes);
+
+	return 0;
+}
+
+static int __init  parse_session_id(char *str)
+{
+	get_option(&str, &early_kerrighed_session_id);
+
+	return 0;
+}
+
+static int __init  parse_nb_nodes_min(char *str)
+{
+	get_option(&str, &early_kerrighed_nb_nodes_min);
+
+	return 0;
+}
+
+__setup("node_id=",parse_node_id);
+__setup("session_id=",parse_session_id);
+__setup("nb_nodes=",parse_nb_nodes);
+__setup("nb_nodes_min=",parse_nb_nodes_min);
diff -Nupr a/ipc/msg.c b/ipc/msg.c
--- a/ipc/msg.c	2007-02-04 19:44:54.000000000 +0100
+++ b/ipc/msg.c	2007-05-23 19:14:40.000000000 +0200
@@ -71,7 +71,9 @@ static atomic_t msg_hdrs =	ATOMIC_INIT(0
 
 static struct ipc_ids init_msg_ids;
 
+#ifndef CONFIG_KRG_IPC
 #define msg_ids(ns)	(*((ns)->ids[IPC_MSG_IDS]))
+#endif
 
 #define msg_lock(ns, id)	((struct msg_queue*)ipc_lock(&msg_ids(ns), id))
 #define msg_unlock(msq)		ipc_unlock(&(msq)->q_perm)
diff -Nupr a/ipc/sem.c b/ipc/sem.c
--- a/ipc/sem.c	2007-02-04 19:44:54.000000000 +0100
+++ b/ipc/sem.c	2007-05-23 19:14:40.000000000 +0200
@@ -87,7 +87,9 @@
 #include <asm/uaccess.h>
 #include "util.h"
 
+#ifndef CONFIG_KRG_IPC
 #define sem_ids(ns)	(*((ns)->ids[IPC_SEM_IDS]))
+#endif
 
 #define sem_lock(ns, id)	((struct sem_array*)ipc_lock(&sem_ids(ns), id))
 #define sem_unlock(sma)		ipc_unlock(&(sma)->sem_perm)
diff -Nupr a/ipc/shm.c b/ipc/shm.c
--- a/ipc/shm.c	2007-02-04 19:44:54.000000000 +0100
+++ b/ipc/shm.c	2007-06-01 11:32:51.000000000 +0200
@@ -42,11 +42,15 @@
 
 #include "util.h"
 
-static struct file_operations shm_file_operations;
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+struct file_operations shm_file_operations;
 static struct vm_operations_struct shm_vm_ops;
 
 static struct ipc_ids init_shm_ids;
 
+#ifndef CONFIG_KRG_IPC
 #define shm_ids(ns)	(*((ns)->ids[IPC_SHM_IDS]))
 
 #define shm_lock(ns, id)		\
@@ -57,12 +61,19 @@ static struct ipc_ids init_shm_ids;
 	((struct shmid_kernel*)ipc_get(&shm_ids(ns),id))
 #define shm_buildid(ns, id, seq)	\
 	ipc_buildid(&shm_ids(ns), id, seq)
+#endif
 
 static int newseg (struct ipc_namespace *ns, key_t key,
 		int shmflg, size_t size);
 static void shm_open (struct vm_area_struct *shmd);
-static void shm_close (struct vm_area_struct *shmd);
-static void shm_destroy (struct ipc_namespace *ns, struct shmid_kernel *shp);
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+void shm_close (struct vm_area_struct *shmd);
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+void shm_destroy (struct ipc_namespace *ns, struct shmid_kernel *shp);
 #ifdef CONFIG_PROC_FS
 static int sysvipc_shm_proc_show(struct seq_file *s, void *it);
 #endif
@@ -80,12 +91,28 @@ static void __ipc_init __shm_init_ns(str
 static void do_shm_rmid(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
 	if (shp->shm_nattch){
+#ifdef CONFIG_KRG_IPC
+		if (kh_shm_rmid)
+			kh_shm_rmid(ns, shp);
+#endif
 		shp->shm_perm.mode |= SHM_DEST;
 		/* Do not find it any more */
 		shp->shm_perm.key = IPC_PRIVATE;
 		shm_unlock(shp);
 	} else
+#ifdef CONFIG_KRG_IPC
+	{
+		if (kh_shm_destroy) {
+			shp->locked_for_del = 1;
+			kh_shm_destroy(ns, shp);
+		}
+		else
+			shm_destroy(ns, shp);
+	}
+#else // CONFIG_KRG_IPC
 		shm_destroy(ns, shp);
+#endif
+
 }
 
 #ifdef CONFIG_IPC_NS
@@ -143,14 +170,20 @@ static inline struct shmid_kernel *shm_r
 	return (struct shmid_kernel *)ipc_rmid(&shm_ids(ns), id);
 }
 
-static inline int shm_addid(struct ipc_namespace *ns, struct shmid_kernel *shp)
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+inline int shm_addid(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
 	return ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);
 }
 
 
 
-static inline void shm_inc(struct ipc_namespace *ns, int id)
+#ifndef CONFIG_KRG_IPC
+static inline
+#endif
+void shm_inc(struct ipc_namespace *ns, int id)
 {
 	struct shmid_kernel *shp;
 
@@ -162,7 +195,9 @@ static inline void shm_inc(struct ipc_na
 	shm_unlock(shp);
 }
 
+#ifndef CONFIG_KRG_IPC // Definition moved in include/kerrighed/shm.h
 #define shm_file_ns(file) (*((struct ipc_namespace **)&(file)->private_data))
+#endif
 
 /* This is called by fork, once for every shm attach. */
 static void shm_open(struct vm_area_struct *shmd)
@@ -179,7 +214,11 @@ static void shm_open(struct vm_area_stru
  * It has to be called with shp and shm_ids.mutex locked,
  * but returns with shp unlocked and freed.
  */
+#ifdef CONFIG_KRG_IPC
+void _shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
+#else
 static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
+#endif
 {
 	ns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid(ns, shp->id);
@@ -200,7 +239,10 @@ static void shm_destroy(struct ipc_names
  * The descriptor has already been removed from the current->mm->mmap list
  * and will later be kfree()d.
  */
-static void shm_close (struct vm_area_struct *shmd)
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+void shm_close (struct vm_area_struct *shmd)
 {
 	struct file * file = shmd->vm_file;
 	int id = file->f_path.dentry->d_inode->i_ino;
@@ -249,7 +291,10 @@ static int shm_release(struct inode *ino
 	return 0;
 }
 
-static struct file_operations shm_file_operations = {
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+struct file_operations shm_file_operations = {
 	.mmap		= shm_mmap,
 	.release	= shm_release,
 #ifndef CONFIG_MMU
@@ -289,7 +334,9 @@ static int newseg (struct ipc_namespace 
 	shp->shm_perm.key = key;
 	shp->shm_perm.mode = (shmflg & S_IRWXUGO);
 	shp->mlock_user = NULL;
-
+#ifdef CONFIG_KRG_IPC
+        shp->locked_for_del = 0;
+#endif
 	shp->shm_perm.security = NULL;
 	error = security_shm_alloc(shp);
 	if (error) {
@@ -339,6 +386,13 @@ static int newseg (struct ipc_namespace 
 		file->f_op = &shm_file_operations;
 
 	ns->shm_tot += numpages;
+#ifdef CONFIG_KRG_IPC
+	if (kh_shm_newseg) {
+		error = kh_shm_newseg(ns, shp) ;
+		if (error)
+			goto no_id;
+	}
+#endif // CONFIG_KRG_IPC
 	shm_unlock(shp);
 	return shp->id;
 
@@ -542,6 +596,11 @@ asmlinkage long sys_shmctl (int shmid, i
 		shminfo.shmmin = SHMMIN;
 		if(copy_shminfo_to_user (buf, &shminfo, version))
 			return -EFAULT;
+#ifdef CONFIG_KRG_IPC
+		if (kh_shm_get_max_id)
+			err = kh_shm_get_max_id(ns, &shm_ids(ns));
+		else
+#endif
 		/* reading a integer is always atomic */
 		err= shm_ids(ns).max_id;
 		if(err<0)
@@ -563,6 +622,11 @@ asmlinkage long sys_shmctl (int shmid, i
 		shm_info.shm_tot = ns->shm_tot;
 		shm_info.swap_attempts = 0;
 		shm_info.swap_successes = 0;
+#ifdef CONFIG_KRG_IPC
+		if (kh_shm_get_max_id)
+			err = kh_shm_get_max_id(ns, &shm_ids(ns));
+		else
+#endif
 		err = shm_ids(ns).max_id;
 		mutex_unlock(&shm_ids(ns).mutex);
 		if(copy_to_user (buf, &shm_info, sizeof(shm_info))) {
@@ -611,6 +675,10 @@ asmlinkage long sys_shmctl (int shmid, i
 			tbuf.shm_nattch	= shp->shm_nattch;
 		else
 			tbuf.shm_nattch = file_count(shp->shm_file) - 1;
+#ifdef CONFIG_KRG_IPC
+		tbuf.__unused4 = shp->shm_cnode;
+		tbuf.__unused5 = shp->shm_lnode;
+#endif
 		shm_unlock(shp);
 		if(copy_shmid_to_user (buf, &tbuf, version))
 			err = -EFAULT;
@@ -700,7 +768,6 @@ asmlinkage long sys_shmctl (int shmid, i
 		err = security_shm_shmctl(shp, cmd);
 		if (err)
 			goto out_unlock_up;
-
 		do_shm_rmid(ns, shp);
 		mutex_unlock(&shm_ids(ns).mutex);
 		goto out;
@@ -944,7 +1011,12 @@ asmlinkage long sys_shmdt(char __user *s
 		 * a fragment created by mprotect() and/or munmap(), or it
 		 * otherwise it starts at this address with no hassles.
 		 */
+#ifdef CONFIG_KRG_IPC
+		if ((vma->vm_ops == &shm_vm_ops || is_vm_hugetlb_page(vma)
+		     || vma->vm_ops == &krg_shmem_vmops) &&
+#else
 		if ((vma->vm_ops == &shm_vm_ops || is_vm_hugetlb_page(vma)) &&
+#endif
 			(vma->vm_start - addr)/PAGE_SIZE == vma->vm_pgoff) {
 
 
diff -Nupr a/ipc/util.c b/ipc/util.c
--- a/ipc/util.c	2007-02-04 19:44:54.000000000 +0100
+++ b/ipc/util.c	2007-05-30 15:12:07.000000000 +0200
@@ -33,6 +33,10 @@
 #include <linux/proc_fs.h>
 #include <linux/audit.h>
 #include <linux/nsproxy.h>
+#ifdef CONFIG_KRG_IPC
+#include <linux/lockdep.h>
+#include <kerrighed/ipc.h>
+#endif
 
 #include <asm/unistd.h>
 
@@ -255,6 +259,14 @@ int ipc_findkey(struct ipc_ids* ids, key
 	struct kern_ipc_perm* p;
 	int max_id = ids->max_id;
 
+#ifdef CONFIG_KRG_IPC
+	if (kh_ipc_findkey) {
+		id = kh_ipc_findkey(ids, key);
+		if (id != -1)
+			return id;
+	}
+#endif
+
 	/*
 	 * rcu_dereference() is not needed here
 	 * since ipc_ids.mutex is held
@@ -272,7 +284,10 @@ int ipc_findkey(struct ipc_ids* ids, key
 /*
  * Requires ipc_ids.mutex locked
  */
-static int grow_ary(struct ipc_ids* ids, int newsize)
+#ifndef CONFIG_KRG_IPC
+static
+#endif
+int grow_ary(struct ipc_ids* ids, int newsize)
 {
 	struct ipc_id_ary* new;
 	struct ipc_id_ary* old;
@@ -329,6 +344,15 @@ int ipc_addid(struct ipc_ids* ids, struc
 	 * rcu_dereference()() is not needed here since
 	 * ipc_ids.mutex is held
 	 */
+#ifdef CONFIG_KRG_IPC
+	if (kh_get_ipc_id) {
+		id = kh_get_ipc_id(ids, size);
+		if (id >= 0)
+			goto found;
+		else
+			return -1;
+	}
+#endif
 	for (id = 0; id < size; id++) {
 		if(ids->entries->p[id] == NULL)
 			goto found;
@@ -347,6 +371,10 @@ found:
 		ids->seq = 0;
 
 	spin_lock_init(&new->lock);
+#ifdef CONFIG_KRG_IPC
+	/* Have to merge class with the one initialized through kddm */
+	lockdep_set_class(&new->lock, &ipcid_lock_key);
+#endif
 	new->deleted = 0;
 	rcu_read_lock();
 	spin_lock(&new->lock);
diff -Nupr a/ipc/util.h b/ipc/util.h
--- a/ipc/util.h	2007-02-04 19:44:54.000000000 +0100
+++ b/ipc/util.h	2007-05-30 15:12:07.000000000 +0200
@@ -10,6 +10,11 @@
 #ifndef _IPC_UTIL_H
 #define _IPC_UTIL_H
 
+#include <linux/autoconf.h>
+#ifdef CONFIG_KRG_IPC
+#include <kerrighed/types.h>
+#endif
+
 #define USHRT_MAX 0xffff
 #define SEQ_MULTIPLIER	(IPCMNI)
 
@@ -38,6 +43,11 @@ struct ipc_ids {
 	struct mutex mutex;
 	struct ipc_id_ary nullentry;
 	struct ipc_id_ary* entries;
+#ifdef CONFIG_KRG_IPC
+	unique_id_t id_ctnr;
+	unique_id_t key_ctnr;
+	unique_id_t map_ctnr;
+#endif
 };
 
 struct seq_file;
diff -Nupr a/kdb/ChangeLog b/kdb/ChangeLog
--- a/kdb/ChangeLog	2007-06-05 17:06:30.000000000 +0200
+++ b/kdb/ChangeLog	2007-05-10 12:33:18.000000000 +0200
@@ -1,3 +1,28 @@
+2007-03-01 Keith Owens  <kaos@sgi.com>
+
+	* Remove sparse warnings.
+	* kdb v4.4-2.6.20-common-6.
+
+2007-02-27 Keith Owens  <kaos@sgi.com>
+
+	* set_irq_regs() on entry to kdb() if they are not already set.
+	* kdb v4.4-2.6.20-common-5.
+
+2007-02-22 Keith Owens  <kaos@sgi.com>
+
+	* Initialise struct disassemble_info in kdb_id1().
+	* kdb v4.4-2.6.20-common-4.
+
+2007-02-16 Keith Owens  <kaos@sgi.com>
+
+	* Clean up debug_alloc_pool code.
+	* kdb v4.4-2.6.20-common-3.
+
+2007-02-16 Keith Owens  <kaos@sgi.com>
+
+	* Initialise variable bits of struct disassemble_info each time.
+	* kdb v4.4-2.6.20-common-2.
+
 2007-02-06 Keith Owens  <kaos@sgi.com>
 
 	* kdb v4.4-2.6.20-common-1.
diff -Nupr a/kdb/kdb_bt.c b/kdb/kdb_bt.c
--- a/kdb/kdb_bt.c	2007-06-05 17:06:30.000000000 +0200
+++ b/kdb/kdb_bt.c	2007-05-10 12:33:18.000000000 +0200
@@ -123,7 +123,6 @@ kdb_bt(int argc, const char **argv)
 		kdb_printf("No process with pid == %ld found\n", pid);
 		return 0;
 	} else if (strcmp(argv[0], "btt") == 0) {
-		unsigned long addr;
 		if (argc != 1)
 			return KDB_ARGCOUNT;
 		if ((diag = kdbgetularg((char *)argv[1], &addr)))
diff -Nupr a/kdb/kdb_id.c b/kdb/kdb_id.c
--- a/kdb/kdb_id.c	2007-06-05 17:06:30.000000000 +0200
+++ b/kdb/kdb_id.c	2007-05-10 12:33:18.000000000 +0200
@@ -52,6 +52,9 @@ kdb_id(int argc, const char **argv)
 	char lastbuf[50];
 	unsigned long word;
 
+	kdb_di.fprintf_func = kdb_dis_fprintf;
+	kdba_id_init(&kdb_di);
+
 	if (argc != 1)  {
 		if (lastpc == 0) {
 			return KDB_ARGCOUNT;
@@ -120,6 +123,9 @@ kdb_id1(unsigned long pc)
 	char *mode;
 	int diag;
 
+	kdb_di.fprintf_func = kdb_dis_fprintf;
+	kdba_id_init(&kdb_di);
+
 	/*
 	 * Allow the user to specify that this instruction
 	 * should be treated differently.
@@ -227,7 +233,4 @@ kdb_id_init(void)
 	kdb_di.insn_type	= 0;
 	kdb_di.target		= 0;
 	kdb_di.target2		= 0;
-	kdb_di.fprintf_func	= kdb_dis_fprintf;
-
-	kdba_id_init(&kdb_di);
 }
diff -Nupr a/kdb/kdb_io.c b/kdb/kdb_io.c
--- a/kdb/kdb_io.c	2007-06-05 17:06:30.000000000 +0200
+++ b/kdb/kdb_io.c	2007-05-10 12:33:18.000000000 +0200
@@ -484,6 +484,8 @@ kdb_printf(const char *fmt, ...)
 		spin_lock(&kdb_printf_lock);
 		got_printf_lock = 1;
 		atomic_inc(&kdb_event);
+	} else {
+		__acquire(kdb_printf_lock);
 	}
 
 	diag = kdbgetintenv("LINES", &linecount);
@@ -599,6 +601,8 @@ kdb_printf(const char *fmt, ...)
 		spin_unlock(&kdb_printf_lock);
 		KDB_STATE_CLEAR(PRINTF_LOCK);
 		atomic_dec(&kdb_event);
+	} else {
+		__release(kdb_printf_lock);
 	}
 	preempt_enable();
 	if (do_longjmp)
diff -Nupr a/kdb/kdbmain.c b/kdb/kdbmain.c
--- a/kdb/kdbmain.c	2007-06-05 17:06:30.000000000 +0200
+++ b/kdb/kdbmain.c	2007-05-10 12:33:18.000000000 +0200
@@ -542,7 +542,7 @@ kdbgetaddrarg(int argc, const char **arg
 	      char **name)
 {
 	kdb_machreg_t addr;
-	long off = 0;
+	unsigned long off = 0;
 	int positive;
 	int diag;
 	int found = 0;
@@ -1159,8 +1159,6 @@ kdb_quiet(int reason)
  *	none
  */
 
-extern char kdb_prompt_str[];
-
 static int
 kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs, kdb_dbtrap_t db_result)
 {
@@ -1735,7 +1733,8 @@ kdb(kdb_reason_t reason, int error, stru
 	kdb_intstate_t int_state;	/* Interrupt state */
 	kdb_reason_t reason2 = reason;
 	int result = 0;	/* Default is kdb did not handle it */
-	int ss_event;
+	int ss_event, old_regs_saved = 0;
+	struct pt_regs *old_regs = NULL;
 	kdb_dbtrap_t db_result=KDB_DB_NOBPT;
 	preempt_disable();
 	atomic_inc(&kdb_event);
@@ -1748,6 +1747,23 @@ kdb(kdb_reason_t reason, int error, stru
 	default:
 		break;
 	}
+	switch(reason) {
+	case KDB_REASON_ENTER:
+	case KDB_REASON_ENTER_SLAVE:
+	case KDB_REASON_BREAK:
+	case KDB_REASON_DEBUG:
+	case KDB_REASON_OOPS:
+	case KDB_REASON_SWITCH:
+	case KDB_REASON_KEYBOARD:
+	case KDB_REASON_NMI:
+		if (regs && regs != get_irq_regs()) {
+			old_regs = set_irq_regs(regs);
+			old_regs_saved = 1;
+		}
+		break;
+	default:
+		break;
+	}
 	if (kdb_continue_catastrophic > 2) {
 		kdb_printf("kdb_continue_catastrophic is out of range, setting to 2\n");
 		kdb_continue_catastrophic = 2;
@@ -2007,12 +2023,16 @@ kdb(kdb_reason_t reason, int error, stru
 	  !KDB_STATE(DOING_SS) &&
 	  !KDB_STATE(RECURSE)) {
 		/*
-		 * (Re)install the global breakpoints.  This is only done
-		 * once from the initial processor on go.
+		 * (Re)install the global breakpoints and cleanup the cached
+		 * symbol table.  This is only done once from the initial
+		 * processor on go.
 		 */
 		KDB_DEBUG_STATE("kdb 12", reason);
-		if (!kdb_quiet(reason) || smp_processor_id() == 0)
+		if (!kdb_quiet(reason) || smp_processor_id() == 0) {
 			kdb_bp_install_global(regs);
+			kdbnearsym_cleanup();
+			debug_kusage();
+		}
 		if (!KDB_STATE(GO1)) {
 			/*
 			 * Release all other cpus which will see KDB_STATE(LEAVING) is set.
@@ -2056,6 +2076,8 @@ kdb(kdb_reason_t reason, int error, stru
 	if (!(KDB_STATE(DOING_SS) || KDB_STATE(SSBPT) || KDB_STATE(RECURSE))) {
 		KDB_DEBUG_STATE("kdb 15", result);
 		kdb_bp_install_local(regs);
+		if (old_regs_saved)
+			set_irq_regs(old_regs);
 		KDB_STATE_CLEAR(KDB_CONTROL);
 	}
 
@@ -2901,7 +2923,8 @@ kdb_dmesg(int argc, const char **argv)
 	/* Do a line at a time (max 200 chars) to reduce protocol overhead */
 	c = '\n';
 	while (start != end) {
-		char buf[201], *p = buf;
+		char buf[201];
+	       	p = buf;
 		while (start < end && (c = *KDB_WRAP(start)) && (p - buf) < sizeof(buf)-1) {
 			++start;
 			*p++ = c;
diff -Nupr a/kdb/kdbsupport.c b/kdb/kdbsupport.c
--- a/kdb/kdbsupport.c	2007-06-05 17:06:30.000000000 +0200
+++ b/kdb/kdbsupport.c	2007-05-10 12:33:18.000000000 +0200
@@ -94,13 +94,14 @@ kdbgetsymval(const char *symname, kdb_sy
  *	more than ~20 later calls before using a saved value.
  */
 
+static char *kdb_name_table[100];	/* arbitrary size */
+
 int
 kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)
 {
 	int ret = 0;
 	unsigned long symbolsize;
 	unsigned long offset;
-	static char *knt[100];	/* kdb name table, arbitrary size */
 #define knt1_size 128		/* must be >= kallsyms table size */
 	char *knt1 = NULL;
 
@@ -137,21 +138,23 @@ kdbnearsym(unsigned long addr, kdb_symta
 			strncpy(knt1, symtab->sym_name, knt1_size);
 			knt1[knt1_size-1] = '\0';
 		}
-		for (i = 0; i < ARRAY_SIZE(knt); ++i) {
-			if (knt[i] && strcmp(knt[i], knt1) == 0)
+		for (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {
+			if (kdb_name_table[i] && strcmp(kdb_name_table[i], knt1) == 0)
 				break;
 		}
-		if (i >= ARRAY_SIZE(knt)) {
-			debug_kfree(knt[0]);
-			memcpy(knt, knt+1, sizeof(knt[0])*(ARRAY_SIZE(knt)-1));
+		if (i >= ARRAY_SIZE(kdb_name_table)) {
+			debug_kfree(kdb_name_table[0]);
+			memcpy(kdb_name_table, kdb_name_table+1,
+			       sizeof(kdb_name_table[0])*(ARRAY_SIZE(kdb_name_table)-1));
 		} else {
 			debug_kfree(knt1);
-			knt1 = knt[i];
-			memcpy(knt+i, knt+i+1, sizeof(knt[0])*(ARRAY_SIZE(knt)-i-1));
-		}
-		i = ARRAY_SIZE(knt) - 1;
-		knt[i] = knt1;
-		symtab->sym_name = knt[i];
+			knt1 = kdb_name_table[i];
+			memcpy(kdb_name_table+i, kdb_name_table+i+1,
+			       sizeof(kdb_name_table[0])*(ARRAY_SIZE(kdb_name_table)-i-1));
+		}
+		i = ARRAY_SIZE(kdb_name_table) - 1;
+		kdb_name_table[i] = knt1;
+		symtab->sym_name = kdb_name_table[i];
 		knt1 = NULL;
 	}
 
@@ -165,6 +168,18 @@ out:
 	return ret;
 }
 
+void
+kdbnearsym_cleanup(void)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {
+		if (kdb_name_table[i]) {
+			debug_kfree(kdb_name_table[i]);
+			kdb_name_table[i] = NULL;
+		}
+	}
+}
+
 /*
  * kallsyms_symbol_complete
  *
@@ -918,17 +933,21 @@ struct debug_alloc_header {
 
 static u64 debug_alloc_pool_aligned[64*1024/dah_align];	/* 64K pool */
 static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;
-static u32 dah_first;
+static u32 dah_first, dah_first_call = 1;
 
 /* Locking is awkward.  The debug code is called from all contexts, including
  * non maskable interrupts.  A normal spinlock is not safe in NMI context.  Try
  * to get the debug allocator lock, if it cannot be obtained after a second
  * then give up.  If the lock could not be previously obtained on this cpu then
  * only try once.
+ *
+ * sparse has no annotation for "this function _sometimes_ acquires a lock", so
+ * fudge the acquire/release notation.
  */
 static DEFINE_SPINLOCK(dap_lock);
-static
-int get_dap_lock(void)
+static int
+get_dap_lock(void)
+	__acquires(dap_lock)
 {
 	static int dap_locked = -1;
 	int count;
@@ -946,23 +965,24 @@ int get_dap_lock(void)
 		udelay(1000);
 	}
 	dap_locked = smp_processor_id();
+	__acquire(dap_lock);
 	return 0;
 }
 
-void *debug_kmalloc(size_t size, gfp_t flags)
+void
+*debug_kmalloc(size_t size, gfp_t flags)
 {
 	unsigned int rem, h_offset;
 	struct debug_alloc_header *best, *bestprev, *prev, *h;
-	static int first_call = 1;
 	void *p = NULL;
-	if ((p = kmalloc(size, flags)))
-		return p;
-	if (!get_dap_lock())
+	if (!get_dap_lock()) {
+		__release(dap_lock);	/* we never actually got it */
 		return NULL;
+	}
 	h = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);
-	if (first_call) {
+	if (dah_first_call) {
 		h->size = sizeof(debug_alloc_pool_aligned) - sizeof(*h);
-		first_call = 0;
+		dah_first_call = 0;
 	}
 	prev = best = bestprev = NULL;
 	while (1) {
@@ -999,7 +1019,8 @@ out:
 	return p;
 }
 
-void debug_kfree(const void *p)
+void
+debug_kfree(const void *p)
 {
 	struct debug_alloc_header *h;
 	unsigned int h_offset;
@@ -1010,8 +1031,10 @@ void debug_kfree(const void *p)
 		kfree(p);
 		return;
 	}
-	if (!get_dap_lock())
+	if (!get_dap_lock()) {
+		__release(dap_lock);	/* we never actually got it */
 		return;		/* memory leak, cannot be helped */
+	}
 	h = (struct debug_alloc_header *)p - 1;
 	h_offset = (char *)h - debug_alloc_pool;
 	if (h_offset < dah_first) {
@@ -1019,16 +1042,18 @@ void debug_kfree(const void *p)
 		dah_first = h_offset;
 	} else {
 		struct debug_alloc_header *prev;
+		unsigned int prev_offset;
 		prev = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);
 		while (1) {
 			if (!prev->next || prev->next > h_offset)
 				break;
 			prev = (struct debug_alloc_header *)(debug_alloc_pool + prev->next);
 		}
-		if (sizeof(*prev) + prev->size == h_offset) {
+		prev_offset = (char *)prev - debug_alloc_pool;
+		if (prev_offset + sizeof(*prev) + prev->size == h_offset) {
 			prev->size += sizeof(*h) + h->size;
 			h = prev;
-			h_offset = (char *)h - debug_alloc_pool;
+			h_offset = prev_offset;
 		} else {
 			h->next = prev->next;
 			prev->next = h_offset;
@@ -1043,6 +1068,33 @@ void debug_kfree(const void *p)
 	spin_unlock(&dap_lock);
 }
 
+void
+debug_kusage(void)
+{
+	struct debug_alloc_header *h;
+	static int debug_kusage_one_time = 1;
+	if (!get_dap_lock()) {
+		__release(dap_lock);	/* we never actually got it */
+		return;
+	}
+	h = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);
+	if (dah_first == 0 &&
+	    (h->size == sizeof(debug_alloc_pool_aligned) - sizeof(*h) ||
+	     dah_first_call))
+		goto out;
+	if (!debug_kusage_one_time)
+		goto out;
+	debug_kusage_one_time = 0;
+	kdb_printf("%s: debug_kmalloc memory leak dah_first %d\n",
+		   __FUNCTION__, dah_first);
+	do {
+		kdb_printf("%s: h %p size %d\n", __FUNCTION__, h, h->size);
+		h = (struct debug_alloc_header *)(debug_alloc_pool + h->next);
+	} while (h->next);
+out:
+	spin_unlock(&dap_lock);
+}
+
 /* Maintain a small stack of kdb_flags to allow recursion without disturbing
  * the global kdb state.
  */
diff -Nupr a/kdb/Makefile b/kdb/Makefile
--- a/kdb/Makefile	2007-06-05 17:06:30.000000000 +0200
+++ b/kdb/Makefile	2007-05-10 12:33:18.000000000 +0200
@@ -21,7 +21,7 @@ quiet_cmd_gen-kdb = GENKDB  $@
 		/^[ \t]*$$/{next} \
 		{gsub(/"/, "\\\"", $$0); \
 		  print "static __initdata char kdb_cmd" cmds++ "[] = \"" $$0 "\\n\";"} \
-		END {print "char __initdata *kdb_cmds[] = {"; for (i = 0; i < cmds; ++i) {print "  kdb_cmd" i ","}; print("  NULL\n};");}' \
+		END {print "extern char *kdb_cmds[]; char __initdata *kdb_cmds[] = {"; for (i = 0; i < cmds; ++i) {print "  kdb_cmd" i ","}; print("  NULL\n};");}' \
 		$(filter-out %/Makefile,$^) > $@
 
 $(obj)/gen-kdb_cmds.c:	$(src)/kdb_cmds $(wildcard $(TOPDIR)/arch/$(ARCH)/kdb/kdb_cmds) $(src)/Makefile
diff -Nupr a/kernel/compat.c b/kernel/compat.c
--- a/kernel/compat.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/compat.c	2007-03-28 12:21:08.000000000 +0200
@@ -23,6 +23,9 @@
 #include <linux/timex.h>
 #include <linux/migrate.h>
 #include <linux/posix-timers.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/uaccess.h>
 
@@ -657,6 +660,34 @@ long compat_sys_clock_nanosleep(clockid_
 	return err;	
 } 
 
+#ifdef CONFIG_KRG_EPM
+int compat_krgsyms_register(void)
+{
+	int err;
+
+	err = krgsyms_register(KRGSYMS_COMPAT_NANOSLEEP_RESTART,
+			       compat_nanosleep_restart);
+	if (err)
+		return err;
+	err = krgsyms_register(KRGSYMS_COMPAT_CLOCK_NANOSLEEP_RESTART,
+			       compat_clock_nanosleep_restart);
+	if (err)
+		krgsyms_unregister(KRGSYMS_COMPAT_NANOSLEEP_RESTART);
+
+	return err;
+}
+
+int compat_krgsyms_unregister(void)
+{
+	int err;
+
+	err = krgsyms_unregister(KRGSYMS_COMPAT_CLOCK_NANOSLEEP_RESTART);
+	err = err ? err : krgsyms_unregister(KRGSYMS_COMPAT_NANOSLEEP_RESTART);
+
+	return err;
+}
+#endif /* CONFIG_KRG_EPM */
+
 /*
  * We currently only need the following fields from the sigevent
  * structure: sigev_value, sigev_signo, sig_notify and (sometimes
diff -Nupr a/kernel/exit.c b/kernel/exit.c
--- a/kernel/exit.c	2007-06-05 17:06:30.000000000 +0200
+++ b/kernel/exit.c	2007-05-30 15:58:31.000000000 +0200
@@ -45,6 +45,18 @@
 #include <linux/audit.h> /* for audit_free() */
 #include <linux/resource.h>
 #include <linux/blkdev.h>
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/task.h>
+#include <kerrighed/signal.h>
+#include <kerrighed/krginit.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/sched.h>
+#include <kerrighed/children.h>
+#include <kerrighed/pid.h>
+#include <kerrighed/ptrace.h>
+#include <kerrighed/sys/types.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -53,7 +65,10 @@
 
 extern void sem_exit (void);
 
-static void exit_mm(struct task_struct * tsk);
+#ifndef CONFIG_KRG_MM
+static
+#endif
+void exit_mm(struct task_struct * tsk);
 
 static void __unhash_process(struct task_struct *p)
 {
@@ -86,6 +101,15 @@ static void __exit_signal(struct task_st
 	spin_lock(&sighand->siglock);
 
 	posix_cpu_timers_exit(tsk);
+#ifdef CONFIG_KRG_EPM
+	if (tsk->exit_state == EXIT_MIGRATION) {
+		if (tsk == sig->curr_target)
+			sig->curr_target = next_thread(tsk);
+		if (tsk == sig->curr_target)
+			sig->curr_target = NULL;
+		sig = NULL;
+	} else
+#endif
 	if (atomic_dec_and_test(&sig->count))
 		posix_cpu_timers_exit_group(tsk);
 	else {
@@ -126,6 +150,9 @@ static void __exit_signal(struct task_st
 	spin_unlock(&sighand->siglock);
 	rcu_read_unlock();
 
+#ifdef CONFIG_KRG_EPM
+	if (tsk->exit_state != EXIT_MIGRATION)
+#endif
 	__cleanup_sighand(sighand);
 	clear_tsk_thread_flag(tsk,TIF_SIGPENDING);
 	flush_sigqueue(&tsk->pending);
@@ -136,6 +163,71 @@ static void __exit_signal(struct task_st
 	}
 }
 
+#ifdef CONFIG_KRG_EPM
+/* If return value is not NULL, all variables are set, and the children kddm
+ * object will have to be unlocked with kh_children_unlock(*real_parent_tgid_p),
+ * and parent pid location will have to be unlocked with
+ * kh_unlock_pid_location(*parent_pid_p)
+ *
+ * If return value is NULL, parent has no children kddm object. It is up to the
+ * caller to know whether original parent died or is still alive and never had a
+ * children kddm object.
+ */
+static
+struct children_ctnr_object *parent_children_writelock_pid_location_lock(
+	struct task_struct *task,
+	pid_t *real_parent_tgid_p,
+	pid_t *real_parent_pid_p,
+	pid_t *parent_pid_p,
+	kerrighed_node_t *parent_node_p)
+{
+	struct children_ctnr_object *children_obj;
+	pid_t real_parent_tgid;
+	pid_t real_parent_pid;
+	pid_t parent_pid;
+	struct task_ctnr_object *obj;
+	kerrighed_node_t parent_node = KERRIGHED_NODE_ID_NONE;
+	struct timespec backoff_time = {
+		.tv_sec = 1,
+		.tv_nsec = 0
+	};	/* 1 second */
+
+	/* Similar to kh_lock_pid_location but we need to acquire
+	 * parent_children_writelock at the same time without deadlocking with
+	 * migration */
+	for (;;) {
+		children_obj = kh_parent_children_writelock(task,
+							    &real_parent_tgid);
+		if (!children_obj)
+			break;
+		kh_get_parent(children_obj, task->pid,
+			      &parent_pid, &real_parent_pid);
+		obj = kh_task_readlock(parent_pid);
+		BUG_ON(!obj);
+		parent_node = obj->node;
+		if (parent_node != KERRIGHED_NODE_ID_NONE)
+			break;
+		kh_task_unlock(parent_pid);
+		kh_children_unlock(real_parent_tgid);
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(timespec_to_jiffies(&backoff_time) + 1);
+	}
+	BUG_ON(children_obj && parent_node == KERRIGHED_NODE_ID_NONE);
+
+	/* If children_obj is not NULL, then children_obj is write-locked and
+	 * obj is read-locked,
+	 * otherwise none is locked. */
+	if (children_obj) {
+		*real_parent_tgid_p = real_parent_tgid;
+		*real_parent_pid_p = real_parent_pid;
+		*parent_pid_p = parent_pid;
+		*parent_node_p = parent_node;
+	}
+	return children_obj;
+}
+#endif
+
 static void delayed_put_task_struct(struct rcu_head *rhp)
 {
 	put_task_struct(container_of(rhp, struct task_struct, rcu));
@@ -145,9 +237,57 @@ void release_task(struct task_struct * p
 {
 	struct task_struct *leader;
 	int zap_leader;
+#ifdef CONFIG_KRG_PROC
+	pid_t signal_id;
+#endif
+#ifdef CONFIG_KRG_EPM
+	unsigned long sighand_id;
+	int delay_notify_parent = 0;
+#endif
+#ifdef CONFIG_KRG_EPM
+	if (!p->thread_info) {
+		/* p points to a fake task_struct allocated when notifying
+		 * the death of a remote child
+		 */
+		kh_release_task(p);
+		return;
+	}
+
+	/* Because we may have to release the group leader at the same time and
+	 * because with KRG_EPM this may need to do blocking operations in the
+	 * context of an unhashed task (current thread), we make sure that the
+	 * task that will do the job will remain a plain task during the whole
+	 * operation. */
+	read_lock(&tasklist_lock);
+	if (!thread_group_leader(p) && likely(p == current)
+	    && likely(kh_delay_release_task)) {
+		read_unlock(&tasklist_lock);
+		kh_delay_release_task(p);
+		return;
+	}
+	read_unlock(&tasklist_lock);
+#endif
 repeat:
+#ifdef CONFIG_KRG_PROC
+	KRGFCT(kh_release_task)(p);
+	signal_id = 0;
+#ifdef CONFIG_KRG_EPM
+	if (likely(p->exit_state != EXIT_MIGRATION))
+#endif
+	if (kh_exit_signal)
+		signal_id = kh_exit_signal(p);
+#endif
+#ifdef CONFIG_KRG_EPM
+	sighand_id = 0;
+	if (kh_exit_sighand && p->exit_state != EXIT_MIGRATION)
+		sighand_id = kh_exit_sighand(p->sighand->krg_objid);
+#endif
 	atomic_dec(&p->user->processes);
 	write_lock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (unlikely(p->ptrace))
+		KRGFCT(kh_ptrace_release_ptraced)(p);
+#endif
 	ptrace_unlink(p);
 	BUG_ON(!list_empty(&p->ptrace_list) || !list_empty(&p->ptrace_children));
 	__exit_signal(p);
@@ -161,6 +301,12 @@ repeat:
 	leader = p->group_leader;
 	if (leader != p && thread_group_empty(leader) && leader->exit_state == EXIT_ZOMBIE) {
 		BUG_ON(leader->exit_signal == -1);
+#ifdef CONFIG_KRG_EPM
+		if (leader->parent == baby_sitter
+		    || leader->parent->children_obj)
+			delay_notify_parent = 1;
+		else
+#endif
 		do_notify_parent(leader, leader->exit_signal);
 		/*
 		 * If we were the last child thread and the leader has
@@ -177,8 +323,90 @@ repeat:
 	write_unlock_irq(&tasklist_lock);
 	proc_flush_task(p);
 	release_thread(p);
+#ifdef CONFIG_KRG_EPM
+	if (p->parent_children_obj) {
+		struct children_ctnr_object *obj = p->parent_children_obj;
+
+		rcu_assign_pointer(p->parent_children_obj, NULL);
+		synchronize_rcu();
+		kh_children_put(obj);
+	}
+	if (sighand_id)
+		kh_sighand_struct_unlock(sighand_id);
+#endif
+#ifdef CONFIG_KRG_PROC
+	if (signal_id)
+		kh_signal_struct_unlock(signal_id);
+#endif
 	call_rcu(&p->rcu, delayed_put_task_struct);
+#ifdef CONFIG_KRG_PROC
+	up_read_non_owner(&kerrighed_init_sem);
+#endif
+
+#ifdef CONFIG_KRG_EPM
+	if (delay_notify_parent) {
+		struct children_ctnr_object *parent_children_obj;
+		pid_t real_parent_tgid;
+		pid_t parent_pid, real_parent_pid;
+		kerrighed_node_t parent_node;
+
+		BUG_ON(p == current);
+
+		parent_children_obj =
+			parent_children_writelock_pid_location_lock(
+				leader,
+				&real_parent_tgid,
+				&real_parent_pid,
+				&parent_pid,
+				&parent_node);
+		kh_task_writelock_nested(leader->pid);
+
+		write_lock_irq(&tasklist_lock);
+		BUG_ON(leader->exit_signal == -1);
+		/* Needed to check whether we were reparented to init, and to
+		 * know which task to notify in case parent is still remote */
+		if (!parent_children_obj) {
+			/* Real parent died and let us reparent leader to local
+			 * init. */
+			kh_reparent_to_local_child_reaper(leader);
+			do_notify_parent(leader, leader->exit_signal);
+		} else if (unlikely(leader->parent != baby_sitter))
+			/* Parent came back... */
+			do_notify_parent(leader, leader->exit_signal);
+		else if (!kh_get_parent(parent_children_obj, leader->pid,
+					&parent_pid, &real_parent_pid)) {
+			/* Make sure that task_ctnr is up to date */
+			leader->task_ctnr->parent = parent_pid;
+			leader->task_ctnr->real_parent = real_parent_pid;
+
+			kh_exit_notify(leader,
+				       parent_node,
+				       leader->exit_signal,
+				       process_group(leader),
+				       process_session(leader));
+		} else
+			BUG();
+
+		zap_leader = (leader->exit_signal == -1);
+		write_unlock_irq(&tasklist_lock);
+
+		kh_task_unlock(leader->pid);
+		if (parent_children_obj) {
+			kh_unlock_pid_location(parent_pid);
+			if (zap_leader)
+				/* Parent was not interested by notification,
+				 * but may have been woken up in do_wait and
+				 * should not see leader as a child
+				 * anymore. Remove leader from its children kddm
+				 * object before parent can access it again. */
+				kh_remove_child(parent_children_obj,
+						leader->pid);
+			kh_children_unlock(real_parent_tgid);
+		}
 
+		delay_notify_parent = 0;
+	}
+#endif
 	p = leader;
 	if (unlikely(zap_leader))
 		goto repeat;
@@ -223,6 +451,10 @@ static int will_become_orphaned_pgrp(int
 	do_each_task_pid(pgrp, PIDTYPE_PGID, p) {
 		if (p == ignored_task
 				|| p->exit_state
+#ifdef CONFIG_KRG_EPM
+				|| (p->flags & PF_EXIT_NOTIFYING)
+				|| (p->real_parent == baby_sitter)
+#endif
 				|| is_init(p->real_parent))
 			continue;
 		if (process_group(p->real_parent) != pgrp &&
@@ -274,10 +506,24 @@ static int has_stopped_jobs(int pgrp)
  */
 static void reparent_to_init(void)
 {
+#ifdef CONFIG_KRG_EPM
+	struct children_ctnr_object *parent_children_obj = NULL;
+	pid_t parent_tgid;
+
+	down_read(&kerrighed_init_sem);
+
+	if (kh_parent_children_writelock)
+		parent_children_obj = kh_parent_children_writelock(current,
+								   &parent_tgid);
+#endif
 	write_lock_irq(&tasklist_lock);
 
 	ptrace_unlink(current);
 	/* Reparent to init */
+#ifdef CONFIG_KRG_EPM
+	KRGFCT(kh_reparent_child)(parent_children_obj, current->pid,
+				  child_reaper(current)->pid, 0);
+#endif
 	remove_parent(current);
 	current->parent = child_reaper(current);
 	current->real_parent = child_reaper(current);
@@ -296,6 +542,12 @@ static void reparent_to_init(void)
 	       sizeof(current->signal->rlim));
 	atomic_inc(&(INIT_USER->__count));
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (parent_children_obj)
+		kh_children_unlock(parent_tgid);
+
+	up_read(&kerrighed_init_sem);
+#endif
 	switch_uid(INIT_USER);
 }
 
@@ -550,7 +802,10 @@ EXPORT_SYMBOL_GPL(exit_fs);
  * Turn us into a lazy TLB process if we
  * aren't already..
  */
-static void exit_mm(struct task_struct * tsk)
+#ifndef CONFIG_KRG_MM
+static
+#endif
+void exit_mm(struct task_struct * tsk)
 {
 	struct mm_struct *mm = tsk->mm;
 
@@ -683,7 +938,11 @@ forget_original_parent(struct task_struc
 			reaper = child_reaper(father);
 			break;
 		}
+#ifdef CONFIG_KRG_EPM
+	} while (reaper->exit_state || (reaper->flags & PF_EXIT_NOTIFYING));
+#else
 	} while (reaper->exit_state);
+#endif
 
 	/*
 	 * There are only two places where our children can be:
@@ -701,6 +960,10 @@ forget_original_parent(struct task_struc
 
 		/* if father isn't the real parent, then ptrace must be enabled */
 		BUG_ON(father != p->real_parent && !ptrace);
+#ifdef CONFIG_KRG_EPM
+		if (unlikely(ptrace))
+			KRGFCT(kh_ptrace_ptracer_exit)(p);
+#endif
 
 		if (father == p->real_parent) {
 			/* reparent with a reaper, real father it's us */
@@ -712,6 +975,11 @@ forget_original_parent(struct task_struc
 			if (p->exit_state == EXIT_ZOMBIE && p->exit_signal != -1 &&
 			    thread_group_empty(p))
 				do_notify_parent(p, p->exit_signal);
+#ifdef CONFIG_KRG_EPM
+			/* TODO: find a way to notify parent only once and
+			 * record exit_signal in parent's children kddm
+			 * object */
+#endif
 		}
 
 		/*
@@ -723,9 +991,16 @@ forget_original_parent(struct task_struc
 		if (unlikely(ptrace && p->exit_state == EXIT_ZOMBIE && p->exit_signal == -1))
 			list_add(&p->ptrace_list, to_release);
 	}
+#ifdef CONFIG_KRG_EPM
+	/* Reparent remote children */
+	KRGFCT(kh_forget_original_remote_parent)(father, reaper);
+#endif
 	list_for_each_safe(_p, _n, &father->ptrace_children) {
 		p = list_entry(_p, struct task_struct, ptrace_list);
 		choose_new_parent(p, reaper);
+#ifdef CONFIG_KRG_EPM
+		KRGFCT(kh_ptrace_reparent_ptraced)(father, p);
+#endif
 		reparent_thread(p, father, 1);
 	}
 }
@@ -734,12 +1009,31 @@ forget_original_parent(struct task_struc
  * Send signals to all our closest relatives so that they know
  * to properly mourn us..
  */
+#ifdef CONFIG_KRG_EPM
+static void exit_notify(struct task_struct *tsk, int notify)
+#else
 static void exit_notify(struct task_struct *tsk)
+#endif
 {
 	int state;
 	struct task_struct *t;
 	struct list_head ptrace_dead, *_p, *_n;
+#ifdef CONFIG_KRG_EPM
+	pid_t real_parent_tgid = 0;
+	struct children_ctnr_object *parent_children_obj = NULL;
+	pid_t real_parent_pid = 0;
+	struct task_ctnr_object *real_parent_obj = NULL;
+	pid_t parent_pid = 0;
+	kerrighed_node_t parent_node = KERRIGHED_NODE_ID_NONE;
+	int original_exit_signal;
+#endif
 
+#ifdef CONFIG_KRG_EPM
+	if (likely(notify)) {
+		/* We are doing the real exit of the process.
+		 * ie. we are not doing exit in a migration
+		 */
+#endif
 	if (signal_pending(tsk) && !(tsk->signal->flags & SIGNAL_GROUP_EXIT)
 	    && !thread_group_empty(tsk)) {
 		/*
@@ -763,6 +1057,35 @@ static void exit_notify(struct task_stru
 		read_unlock(&tasklist_lock);
 	}
 
+#ifdef CONFIG_KRG_PROC
+#ifdef CONFIG_KRG_EPM
+	if (kh_parent_children_writelock)
+		parent_children_obj =
+			parent_children_writelock_pid_location_lock(
+				tsk,
+				&real_parent_tgid,
+				&real_parent_pid,
+				&parent_pid,
+				&parent_node);
+	if (tsk->children_obj) {
+		if (parent_children_obj)
+			kh_children_writelock_nested(tsk->tgid);
+		else
+			kh_children_writelock(tsk->tgid);
+	}
+	if (parent_children_obj)
+		kh_task_writelock_nested(tsk->pid);
+	else
+#endif /* CONFIG_KRG_EPM */
+	KRGFCT(kh_task_writelock)(tsk->pid);
+#ifdef CONFIG_KRG_EPM
+	if (tsk->task_ctnr && parent_children_obj) {
+		/* Make sure that task_ctnr is up to date */
+		tsk->task_ctnr->parent = parent_pid;
+		tsk->task_ctnr->real_parent = real_parent_pid;
+	}
+#endif /* CONFIG_KRG_EPM */
+#endif /* CONFIG_KRG_PROC */
 	write_lock_irq(&tasklist_lock);
 
 	/*
@@ -778,6 +1101,9 @@ static void exit_notify(struct task_stru
 	forget_original_parent(tsk, &ptrace_dead);
 	BUG_ON(!list_empty(&tsk->children));
 	BUG_ON(!list_empty(&tsk->ptrace_children));
+#ifdef CONFIG_KRG_EPM
+	BUG_ON(!list_empty(&tsk->distant_children));
+#endif
 
 	/*
 	 * Check to see if any process groups have become orphaned
@@ -791,6 +1117,11 @@ static void exit_notify(struct task_stru
 	 
 	t = tsk->real_parent;
 	
+#ifdef CONFIG_KRG_EPM
+	if (t == baby_sitter) {
+		/* TODO: check for orphan pgrp with remote real_parent */
+	} else {
+#endif
 	if ((process_group(t) != process_group(tsk)) &&
 	    (process_session(t) == process_session(tsk)) &&
 	    will_become_orphaned_pgrp(process_group(tsk), tsk) &&
@@ -798,6 +1129,9 @@ static void exit_notify(struct task_stru
 		__kill_pg_info(SIGHUP, SEND_SIG_PRIV, process_group(tsk));
 		__kill_pg_info(SIGCONT, SEND_SIG_PRIV, process_group(tsk));
 	}
+#ifdef CONFIG_KRG_EPM
+	}
+#endif
 
 	/* Let father know we died 
 	 *
@@ -815,6 +1149,43 @@ static void exit_notify(struct task_stru
 	 *	
 	 */
 	
+#ifdef CONFIG_KRG_EPM
+	/* Prevent exiting processes from reparenting their children to us
+	 * while we release the tasklist_lock */
+	tsk->flags |= PF_EXIT_NOTIFYING;
+
+	if ((t == baby_sitter || tsk->parent == baby_sitter)
+	    && !parent_children_obj) {
+		/* Real parent died and let us reparent to local init. */
+		kh_reparent_to_local_child_reaper(tsk);
+		t = tsk->real_parent;
+	}
+
+	if (t == baby_sitter) {
+		write_unlock_irq(&tasklist_lock);
+
+		/* Temporarily deactivate lockdep validator until new
+		 * implementation */
+		lockdep_off();
+		real_parent_obj = kh_task_readlock(real_parent_pid);
+		BUG_ON(!real_parent_obj);
+		read_lock(&tasklist_lock);
+		/* task_ctnr version of vanilla linux check */
+		if (tsk->exit_signal != SIGCHLD && tsk->exit_signal != -1 &&
+		    ( tsk->parent_exec_id != real_parent_obj->self_exec_id  ||
+		      tsk->self_exec_id != tsk->parent_exec_id)
+		    && !capable(CAP_KILL))
+			tsk->exit_signal = SIGCHLD;
+		read_unlock(&tasklist_lock);
+		kh_task_unlock(real_parent_pid);
+		lockdep_on();
+
+		write_lock_irq(&tasklist_lock);
+
+		/* Real parent may have migrated while we released the lock. */
+		t = tsk->real_parent;
+	} else
+#endif
 	if (tsk->exit_signal != SIGCHLD && tsk->exit_signal != -1 &&
 	    ( tsk->parent_exec_id != t->self_exec_id  ||
 	      tsk->self_exec_id != tsk->parent_exec_id)
@@ -826,6 +1197,28 @@ static void exit_notify(struct task_stru
 	 * send it a SIGCHLD instead of honoring exit_signal.  exit_signal
 	 * only has special meaning to our real parent.
 	 */
+#ifdef CONFIG_KRG_EPM
+	original_exit_signal = tsk->exit_signal;
+	if (t == baby_sitter || tsk->parent == baby_sitter) {
+		int sig_num = -1;
+
+		BUG_ON(parent_pid != tsk->task_ctnr->parent);
+		/* children kddm version of vanilla linux ptrace check and
+		 * notify */
+		if (tsk->exit_signal != -1 && thread_group_empty(tsk))
+			sig_num = parent_pid == real_parent_pid ? tsk->exit_signal : SIGCHLD;
+		else if (tsk->ptrace)
+			sig_num = SIGCHLD;
+
+		state = kh_exit_notify(tsk,
+				       parent_node,
+				       sig_num,
+				       process_group(tsk),
+				       process_session(tsk));
+		/* tsk->exit_state was set in kh_exit_notify */
+		BUG_ON(!tsk->exit_state);
+	} else {
+#endif
 	if (tsk->exit_signal != -1 && thread_group_empty(tsk)) {
 		int signal = tsk->parent == tsk->real_parent ? tsk->exit_signal : SIGCHLD;
 		do_notify_parent(tsk, signal);
@@ -839,21 +1232,73 @@ static void exit_notify(struct task_stru
 	     unlikely(tsk->parent->signal->flags & SIGNAL_GROUP_EXIT)))
 		state = EXIT_DEAD;
 	tsk->exit_state = state;
+#ifdef CONFIG_KRG_EPM
+	}
+	/* once exit_state is set, PF_EXIT_NOTIFYING is useless */
+	tsk->flags &= ~PF_EXIT_NOTIFYING;
+#endif
 
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+#ifdef CONFIG_KRG_EPM
+	if (parent_children_obj) {
+		kh_unlock_pid_location(parent_pid);
+		if (tsk->exit_signal == -1 && original_exit_signal != -1)
+			/* Parent was not interested by notification, but may
+			 * have been woken up in do_wait and should not see tsk
+			 * as a child anymore. Remove tsk from its children kddm
+			 * object before parent can access it again. */
+			kh_remove_child(parent_children_obj, tsk->pid);
+		else
+			kh_set_child_exit_signal(parent_children_obj,
+						 tsk->pid, tsk->exit_signal);
+		kh_children_unlock(real_parent_tgid);
+	}
+#endif /* CONFIG_KRG_EPM */
+	KRGFCT(kh_task_unlock)(tsk->pid);
+#ifdef CONFIG_KRG_EPM
+	if (tsk->children_obj)
+		kh_exit_children(tsk);
+#endif /* CONFIG_KRG_EPM */
+	/* No kerrighed structure should be accessed after this point,
+	 * since the task may have already been released by its reaper.
+	 * The exception of course is the case in which the task self-reaps.
+	 */
+#endif /* CONFIG_KRG_PROC */
 
 	list_for_each_safe(_p, _n, &ptrace_dead) {
 		list_del_init(_p);
 		t = list_entry(_p, struct task_struct, ptrace_list);
 		release_task(t);
 	}
+#ifdef CONFIG_KRG_EPM
+	} else { /* (!notify) */
+		/* Not a real DEAD... just a migration. */
+		write_lock_irq(&tasklist_lock);
+		BUG_ON(!list_empty(&tsk->children));
+		BUG_ON(!list_empty(&tsk->ptrace_children));
+		BUG_ON(!list_empty(&tsk->distant_children));
+
+		BUG_ON(tsk->parent != baby_sitter);
+		BUG_ON(tsk->real_parent != baby_sitter);
+
+		tsk->exit_state = EXIT_MIGRATION;
+		write_unlock_irq(&tasklist_lock);
+
+		state = EXIT_DEAD;
+	}
+#endif
 
 	/* If the process is dead, release it - nobody will wait for it */
 	if (state == EXIT_DEAD)
 		release_task(tsk);
 }
 
+#ifdef CONFIG_KRG_EPM
+static inline void __do_exit(long code, int notify)
+#else
 fastcall NORET_TYPE void do_exit(long code)
+#endif
 {
 	struct task_struct *tsk = current;
 	int group_dead;
@@ -892,6 +1337,9 @@ fastcall NORET_TYPE void do_exit(long co
 		schedule();
 	}
 
+#ifdef CONFIG_KRG_PROC
+	down_read_non_owner(&kerrighed_init_sem);
+#endif
 	tsk->flags |= PF_EXITING;
 
 	if (unlikely(in_atomic()))
@@ -942,11 +1390,19 @@ fastcall NORET_TYPE void do_exit(long co
 	tsk->exit_code = code;
 	proc_exit_connector(tsk);
 	exit_task_namespaces(tsk);
+#ifdef CONFIG_KRG_EPM
+	exit_notify(tsk, notify);
+#else
 	exit_notify(tsk);
+#endif
 #ifdef CONFIG_NUMA
 	mpol_free(tsk->mempolicy);
 	tsk->mempolicy = NULL;
 #endif
+#ifdef CONFIG_KRG_CTNR
+	if (tsk->kddm_info)
+		kfree(tsk->kddm_info);
+#endif
 	/*
 	 * This must happen late, after the PID is not
 	 * hashed anymore:
@@ -977,6 +1433,24 @@ fastcall NORET_TYPE void do_exit(long co
 		cpu_relax();	/* For when BUG is null */
 }
 
+#ifdef CONFIG_KRG_EPM
+fastcall NORET_TYPE void do_exit(long code)
+{
+	__do_exit(code, 1);
+	/* Avoid "noreturn function does return".  */
+	for (;;);
+}
+
+fastcall NORET_TYPE void do_exit_wo_notify(long code)
+{
+	__do_exit(code, 0);
+	/* Avoid "noreturn function does return".  */
+	for (;;);
+}
+
+EXPORT_SYMBOL(do_exit_wo_notify);
+#endif /* CONFIG_KRG_EPM */
+
 EXPORT_SYMBOL_GPL(do_exit);
 
 NORET_TYPE void complete_and_exit(struct completion *comp, long code)
@@ -1125,6 +1599,10 @@ static int wait_task_zombie(struct task_
 			return 0;
 		get_task_struct(p);
 		read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+		if (likely(kh_may_be_eligible_child))
+			kh_children_unlock(current->tgid);
+#endif
 		if ((exit_code & 0x7f) == 0) {
 			why = CLD_EXITED;
 			status = exit_code >> 8;
@@ -1201,6 +1679,10 @@ static int wait_task_zombie(struct task_
 	 * thread can reap it because we set its state to EXIT_DEAD.
 	 */
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (likely(kh_may_be_eligible_child))
+		kh_children_unlock(current->tgid);
+#endif
 
 	retval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;
 	status = (p->signal->flags & SIGNAL_GROUP_EXIT)
@@ -1236,6 +1718,17 @@ static int wait_task_zombie(struct task_
 	}
 	retval = p->pid;
 	if (p->real_parent != p->parent) {
+#ifdef CONFIG_KRG_EPM
+		struct children_ctnr_object *parent_children_obj = NULL;
+		pid_t real_parent_tgid;
+		/* p may be set to NULL while we still need it */
+		struct task_struct *saved_p = p;
+
+		if (kh_parent_children_writelock)
+			parent_children_obj =
+				kh_parent_children_writelock(saved_p,
+							     &real_parent_tgid);
+#endif
 		write_lock_irq(&tasklist_lock);
 		/* Double-check with lock held.  */
 		if (p->real_parent != p->parent) {
@@ -1254,6 +1747,14 @@ static int wait_task_zombie(struct task_
 			}
 		}
 		write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+		if (parent_children_obj) {
+			kh_set_child_exit_signal(parent_children_obj,
+						 saved_p->pid,
+						 saved_p->exit_signal);
+			kh_children_unlock(real_parent_tgid);
+		}
+#endif
 	}
 	if (p != NULL)
 		release_task(p);
@@ -1292,6 +1793,10 @@ static int wait_task_stopped(struct task
 	 */
 	get_task_struct(p);
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (likely(kh_may_be_eligible_child))
+		kh_children_unlock(current->tgid);
+#endif
 
 	if (unlikely(noreap)) {
 		pid_t pid = p->pid;
@@ -1410,6 +1915,10 @@ static int wait_task_continued(struct ta
 	uid = p->uid;
 	get_task_struct(p);
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (likely(kh_may_be_eligible_child))
+		kh_children_unlock(current->tgid);
+#endif
 
 	if (!infop) {
 		retval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;
@@ -1451,15 +1960,30 @@ static long do_wait(pid_t pid, int optio
 	DECLARE_WAITQUEUE(wait, current);
 	struct task_struct *tsk;
 	int flag, retval;
+#ifdef CONFIG_KRG_EPM
+	struct list_head *children;
+	int distant_mode;
+#endif
 
+#ifdef CONFIG_KRG_EPM
+	down_read(&kerrighed_init_sem);
+#endif
 	add_wait_queue(&current->signal->wait_chldexit,&wait);
 repeat:
+#ifdef CONFIG_KRG_EPM
+	if (likely(kh_may_be_eligible_child))
+		kh_children_readlock(current->tgid);
+#endif
 	/*
 	 * We will set this flag if we see any child that might later
 	 * match our criteria, even if we are not able to reap it yet.
 	 */
 	flag = 0;
 	current->state = TASK_INTERRUPTIBLE;
+#ifdef CONFIG_KRG_EPM
+	distant_mode = 0;
+distant_mode:
+#endif
 	read_lock(&tasklist_lock);
 	tsk = current;
 	do {
@@ -1467,7 +1991,15 @@ repeat:
 		struct list_head *_p;
 		int ret;
 
+#ifdef CONFIG_KRG_EPM
+		if (distant_mode)
+			children = &tsk->distant_children;
+		else
+			children = &tsk->children;
+		list_for_each(_p,children) {
+#else
 		list_for_each(_p,&tsk->children) {
+#endif
 			p = list_entry(_p, struct task_struct, sibling);
 
 			ret = eligible_child(pid, options, p);
@@ -1561,20 +2093,51 @@ check_continued:
 	} while (tsk != current);
 
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (!distant_mode) {
+		distant_mode = 1;
+		goto distant_mode;
+	}
+#endif
 	if (flag) {
+#ifdef CONFIG_KRG_EPM
+wait_distant_child:
+		if (likely(kh_may_be_eligible_child))
+			kh_children_unlock(current->tgid);
+#endif
 		retval = 0;
 		if (options & WNOHANG)
 			goto end;
 		retval = -ERESTARTSYS;
 		if (signal_pending(current))
 			goto end;
+#ifdef CONFIG_KRG_EPM
+		up_read(&kerrighed_init_sem);
+#endif
 		schedule();
+#ifdef CONFIG_KRG_EPM
+		down_read(&kerrighed_init_sem);
+#endif
 		goto repeat;
 	}
+#ifdef CONFIG_KRG_EPM
+	else if (likely(kh_may_be_eligible_child)) {
+		/* Check global children list for children that are not linked
+		 * locally
+		 */
+		if (kh_may_be_eligible_child(current->children_obj,
+					     pid, options))
+			goto wait_distant_child;
+		kh_children_unlock(current->tgid);
+	}
+#endif
 	retval = -ECHILD;
 end:
 	current->state = TASK_RUNNING;
 	remove_wait_queue(&current->signal->wait_chldexit,&wait);
+#ifdef CONFIG_KRG_EPM
+	up_read(&kerrighed_init_sem);
+#endif
 	if (infop) {
 		if (retval > 0)
 		retval = 0;
diff -Nupr a/kernel/fork.c b/kernel/fork.c
--- a/kernel/fork.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/fork.c	2007-05-09 16:13:10.000000000 +0200
@@ -50,6 +50,28 @@
 #include <linux/taskstats_kern.h>
 #include <linux/random.h>
 
+#ifdef CONFIG_KRG_CTNR
+#include <kerrighed/ctnr_headers.h>
+#endif
+#ifdef CONFIG_KRG_TOOLS
+#include <kerrighed/unique_id.h>
+#endif
+#ifdef CONFIG_KRG_PROC
+#include <linux/lockdep.h>
+#include <kerrighed/task.h>
+#include <kerrighed/pid.h>
+#include <kerrighed/signal.h>
+#include <kerrighed/krginit.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/sched.h>
+#include <kerrighed/children.h>
+#include <kerrighed/ptrace.h>
+#endif
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/faf.h>
+#endif
+
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -81,13 +103,19 @@ int nr_processes(void)
 }
 
 #ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
+#ifndef CONFIG_KRG_PROC
 # define alloc_task_struct()	kmem_cache_alloc(task_struct_cachep, GFP_KERNEL)
 # define free_task_struct(tsk)	kmem_cache_free(task_struct_cachep, (tsk))
-static struct kmem_cache *task_struct_cachep;
+static
+#endif /* CONFIG_KRG_PROC */
+struct kmem_cache *task_struct_cachep;
 #endif
 
 /* SLAB cache for signal_struct structures (tsk->signal) */
-static struct kmem_cache *signal_cachep;
+#ifndef CONFIG_KRG_PROC
+static
+#endif
+struct kmem_cache *signal_cachep;
 
 /* SLAB cache for sighand_struct structures (tsk->sighand) */
 struct kmem_cache *sighand_cachep;
@@ -102,7 +130,10 @@ struct kmem_cache *fs_cachep;
 struct kmem_cache *vm_area_cachep;
 
 /* SLAB cache for mm_struct structures (tsk->mm) */
-static struct kmem_cache *mm_cachep;
+#ifndef CONFIG_KRG_MM
+static
+#endif
+struct kmem_cache *mm_cachep;
 
 void free_task(struct task_struct *tsk)
 {
@@ -114,7 +145,11 @@ EXPORT_SYMBOL(free_task);
 
 void __put_task_struct(struct task_struct *tsk)
 {
+#ifdef CONFIG_KRG_EPM
+	WARN_ON(!(tsk->exit_state & (EXIT_DEAD | EXIT_ZOMBIE | EXIT_MIGRATION)));
+#else
 	WARN_ON(!(tsk->exit_state & (EXIT_DEAD | EXIT_ZOMBIE)));
+#endif
 	WARN_ON(atomic_read(&tsk->usage));
 	WARN_ON(tsk == current);
 
@@ -158,24 +193,54 @@ void __init fork_init(unsigned long memp
 		init_task.signal->rlim[RLIMIT_NPROC];
 }
 
+#ifdef CONFIG_KRG_PROC
+static struct task_struct *dup_task_struct(struct task_struct *orig, pid_t pid)
+#else
 static struct task_struct *dup_task_struct(struct task_struct *orig)
+#endif
 {
 	struct task_struct *tsk;
 	struct thread_info *ti;
+#ifdef CONFIG_KRG_PROC
+	struct task_ctnr_object *task_ctnr = NULL;
+#endif
 
 	prepare_to_copy(orig);
 
+#ifdef CONFIG_KRG_PROC
+	if (kh_malloc_task_struct) {
+		tsk = kh_malloc_task_struct(pid);
+		if (tsk)
+			task_ctnr = tsk->task_ctnr;
+	} else
+#endif
 	tsk = alloc_task_struct();
 	if (!tsk)
 		return NULL;
 
 	ti = alloc_thread_info(tsk);
 	if (!ti) {
+#ifdef CONFIG_KRG_PROC
+#ifdef CONFIG_KRG_EPM
+		if (!krg_current)
+#endif
+		if (task_ctnr) {
+			kh_task_unlock(pid);
+			kh_free_task_struct(tsk);
+		}
+#endif
 		free_task_struct(tsk);
 		return NULL;
 	}
 
 	*tsk = *orig;
+#ifdef CONFIG_KRG_PROC
+	/* Those two fields were overwritten when copying the whole struct and
+	 * they are needed before copy_process assigns tsk->pid in case an error
+	 * leads to destroy the task container object. */
+	tsk->pid = pid;
+	tsk->task_ctnr = task_ctnr;
+#endif
 	tsk->thread_info = ti;
 	setup_thread_stack(tsk, orig);
 
@@ -333,6 +398,9 @@ static struct mm_struct * mm_init(struct
 	INIT_LIST_HEAD(&mm->mmlist);
 	mm->core_waiters = 0;
 	mm->nr_ptes = 0;
+#ifdef CONFIG_KRG_MM
+        mm->mm_id = get_unique_id(&mm_unique_id_root);
+#endif
 	set_mm_counter(mm, file_rss, 0);
 	set_mm_counter(mm, anon_rss, 0);
 	spin_lock_init(&mm->page_table_lock);
@@ -371,6 +439,10 @@ struct mm_struct * mm_alloc(void)
  */
 void fastcall __mmdrop(struct mm_struct *mm)
 {
+#ifdef CONFIG_KRG_MM
+	if (kh_mmdrop)
+		kh_mmdrop(mm);
+#endif
 	BUG_ON(mm == &init_mm);
 	mm_free_pgd(mm);
 	destroy_context(mm);
@@ -555,6 +627,16 @@ static int copy_mm(unsigned long clone_f
 	if (!mm)
 		goto fail_nomem;
 
+#ifdef CONFIG_KRG_MM
+        if(kh_copy_mm != NULL) {
+                retval = kh_copy_mm(clone_flags, mm, oldmm);
+                if (retval) {
+			mmput(mm);
+                        goto fail_nomem;
+		}
+        }
+#endif // CONFIG_KRG_MM
+
 good_mm:
 	/* Initializing for Swap token stuff */
 	mm->token_priority = 0;
@@ -612,7 +694,10 @@ static inline int copy_fs(unsigned long 
 	return 0;
 }
 
-static int count_open_files(struct fdtable *fdt)
+#ifndef CONFIG_KRG_DVFS
+static
+#endif
+int count_open_files(struct fdtable *fdt)
 {
 	int size = fdt->max_fds;
 	int i;
@@ -807,11 +892,43 @@ static inline int copy_sighand(unsigned 
 {
 	struct sighand_struct *sig;
 
+#ifdef CONFIG_KRG_EPM
+	if (unlikely(krg_current != NULL
+		     && tsk->tgid == krg_current->signal->krg_objid))
+		/* This is a process migration: sighand_struct is retreived
+		 * through its container. */
+		return 0;
+
+	if (!krg_current)
+#endif
 	if (clone_flags & (CLONE_SIGHAND | CLONE_THREAD)) {
+#ifdef CONFIG_KRG_EPM
+		sig = current->sighand;
+		KRGFCT(kh_sighand_struct_writelock)(sig->krg_objid);
+#endif
 		atomic_inc(&current->sighand->count);
+#ifdef CONFIG_KRG_EPM
+		KRGFCT(kh_share_sighand)(current);
+		KRGFCT(kh_sighand_struct_unlock)(sig->krg_objid);
+		if (likely(tsk->task_ctnr))
+			tsk->task_ctnr->sighand_struct_id = sig->krg_objid;
+#endif
 		return 0;
 	}
+#ifdef CONFIG_KRG_EPM
+	sig = NULL;
+	if (kh_malloc_sighand_struct)
+		sig = kh_malloc_sighand_struct(tsk, 0);
+	if (!sig) {
+#endif
 	sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);
+#ifdef CONFIG_KRG_EPM
+		if (sig) {
+			sig->krg_objid = 0;
+			atomic_inc(&tsk->krg_cap_unavailable_private[CAP_CAN_MIGRATE]);
+		}
+	}
+#endif
 	rcu_assign_pointer(tsk->sighand, sig);
 	if (!sig)
 		return -ENOMEM;
@@ -831,12 +948,43 @@ static inline int copy_signal(unsigned l
 	struct signal_struct *sig;
 	int ret;
 
+#ifdef CONFIG_KRG_EPM
+	if (unlikely(krg_current != NULL
+		     && tsk->tgid == krg_current->signal->krg_objid))
+		/* This is a process migration: signal_struct is retreived
+		 * through its container. */
+		return 0;
+
+	if (!krg_current)
+#endif
 	if (clone_flags & CLONE_THREAD) {
+#ifdef CONFIG_KRG_PROC
+		KRGFCT(kh_signal_struct_writelock)(current->tgid);
+#endif
 		atomic_inc(&current->signal->count);
 		atomic_inc(&current->signal->live);
+#ifdef CONFIG_KRG_PROC
+		KRGFCT(kh_share_signal)(current);
+		KRGFCT(kh_signal_struct_unlock)(current->tgid);
+#endif
 		return 0;
 	}
+#ifdef CONFIG_KRG_PROC
+	sig = NULL;
+	if (kh_malloc_signal_struct)
+		sig = kh_malloc_signal_struct(tsk, 0);
+	if (!sig) {
+#endif /* CONFIG_KRG_PROC */
 	sig = kmem_cache_alloc(signal_cachep, GFP_KERNEL);
+#ifdef CONFIG_KRG_PROC
+		if (sig) {
+			sig->krg_objid = 0;
+#ifdef CONFIG_KRG_EPM
+			atomic_inc(&tsk->krg_cap_unavailable_private[CAP_CAN_MIGRATE]);
+#endif
+		}
+	}
+#endif /* CONFIG_KRG_PROC */
 	tsk->signal = sig;
 	if (!sig)
 		return -ENOMEM;
@@ -880,8 +1028,14 @@ static inline int copy_signal(unsigned l
 	INIT_LIST_HEAD(&sig->cpu_timers[2]);
 	taskstats_tgid_init(sig);
 
+#ifdef CONFIG_KRG_EPM
+	if (likely(!krg_current))
+#endif
 	task_lock(current->group_leader);
 	memcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);
+#ifdef CONFIG_KRG_EPM
+	if (likely(!krg_current))
+#endif
 	task_unlock(current->group_leader);
 
 	if (sig->rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY) {
@@ -894,6 +1048,10 @@ static inline int copy_signal(unsigned l
 	}
 	acct_init_pacct(&sig->pacct);
 
+#ifdef CONFIG_KRG_PROC
+	if (sig->krg_objid)
+		kh_signal_struct_unlock(tsk->tgid);
+#endif
 	return 0;
 }
 
@@ -906,11 +1064,31 @@ void __cleanup_signal(struct signal_stru
 static inline void cleanup_signal(struct task_struct *tsk)
 {
 	struct signal_struct *sig = tsk->signal;
+#ifdef CONFIG_KRG_PROC
+	pid_t signal_id = 0;
+#ifdef CONFIG_KRG_EPM
+	struct task_struct *krg_current_saved;
+
+	krg_current_saved = krg_current;
+	krg_current = NULL;
+#endif
+
+	if (kh_exit_signal)
+		signal_id = kh_exit_signal(tsk);
+#endif
 
 	atomic_dec(&sig->live);
 
 	if (atomic_dec_and_test(&sig->count))
 		__cleanup_signal(sig);
+#ifdef CONFIG_KRG_PROC
+	if (signal_id)
+		kh_signal_struct_unlock(signal_id);
+
+#ifdef CONFIG_KRG_EPM
+	krg_current = krg_current_saved;
+#endif
+#endif
 }
 
 static inline void copy_flags(unsigned long clone_flags, struct task_struct *p)
@@ -958,6 +1136,9 @@ static struct task_struct *copy_process(
 {
 	int retval;
 	struct task_struct *p = NULL;
+#ifdef CONFIG_KRG_EPM
+	pid_t parent_tgid;
+#endif
 
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
 		return ERR_PTR(-EINVAL);
@@ -982,7 +1163,11 @@ static struct task_struct *copy_process(
 		goto fork_out;
 
 	retval = -ENOMEM;
+#ifdef CONFIG_KRG_PROC
+	p = dup_task_struct(current, pid);
+#else
 	p = dup_task_struct(current);
+#endif
 	if (!p)
 		goto fork_out;
 
@@ -1096,13 +1281,94 @@ static struct task_struct *copy_process(
 #ifdef CONFIG_DEBUG_MUTEXES
 	p->blocked_on = NULL; /* not blocked yet */
 #endif
+#ifdef CONFIG_KRG_TOOLS
+	clear_vector(&p->ack_vector);
+	p->ack_result = 0;
+#endif
+#ifdef CONFIG_KRG_EPM
+	if (kh_copy_process)
+		kh_copy_process(p);
+	else
+		p->krg_task = NULL;
+#endif
 
 	p->tgid = p->pid;
 	if (clone_flags & CLONE_THREAD)
 		p->tgid = current->tgid;
+#ifdef CONFIG_KRG_PROC
+	BUG_ON((p->tgid & GLOBAL_PID_MASK) != (p->pid & GLOBAL_PID_MASK));
+#endif
 
+#ifdef CONFIG_KRG_CAP
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current || p->tgid != krg_current->signal->krg_objid)
+#endif
+	{
+		/* This is not a migration, so we have to compute the new
+		 * capabilities and reset the private krg_cap_unavailable
+		 * array. */
+		kernel_cap_t new_krg_effective;
+		int i;
+
+		new_krg_effective =
+			cap_intersect(current->krg_cap_inheritable_effective,
+				      current->krg_cap_inheritable_permitted);
+
+		p->krg_cap_permitted = current->krg_cap_inheritable_permitted;
+		p->krg_cap_effective = new_krg_effective;
+
+		for (i = 0; i < CAP_SIZE; i++)
+			atomic_set(&p->krg_cap_unavailable_private[i], 0);
+		/* The other fields have been inherited by copy. */
+	}
+#endif /* CONFIG_KRG_CAP */
+#ifdef CONFIG_KRG_EPM
+	INIT_LIST_HEAD(&p->distant_children);
+	/* Exclude kernel threads and local pids from using children kddm
+	 * set. */
+	if (likely(kh_alloc_children)
+	    && likely(p->tgid & GLOBAL_PID_MASK) && likely(current->mm)) {
+		/* Attach p to the children kddm object of its thread
+		 * group */
+		if (!krg_current && !(clone_flags & CLONE_THREAD)) {
+			p->children_obj = kh_alloc_children(p);
+			if (unlikely(!p->children_obj)) {
+				retval = -ENOMEM;
+				goto bad_fork_cleanup_policy;
+			}
+		} else {
+			p->children_obj = current->children_obj;
+			if (!krg_current && p->children_obj)
+				kh_share_children(p);
+		}
+	} else
+		p->children_obj = NULL;
+	BUG_ON(krg_current && !p->children_obj);
+	if (!krg_current && !p->children_obj) {
+		atomic_inc(&p->krg_cap_unavailable_private[CAP_DISTANT_FORK]);
+		/* This could be refined in the future: allow migration until
+		 * there are children, and after there are no more children. */
+		atomic_inc(&p->krg_cap_unavailable_private[CAP_CAN_MIGRATE]);
+	}
+#endif /* CONFIG_KRG_EPM */
+#ifdef CONFIG_KRG_CTNR
+	if (kh_copy_kddm_info)
+		if ((retval = kh_copy_kddm_info(clone_flags, p)))
+#ifdef CONFIG_KRG_EPM
+			goto bad_fork_cleanup_children_obj;
+#else
+			goto bad_fork_cleanup_policy;
+#endif
+#endif
 	if ((retval = security_task_alloc(p)))
+#ifdef CONFIG_KRG_CTNR
+		goto bad_fork_cleanup_kddm_info;
+#else
+#ifdef CONFIG_KRG_EPM
+#error CONFIG_KRG_CTNR should be set!
+#endif
 		goto bad_fork_cleanup_policy;
+#endif
 	if ((retval = audit_alloc(p)))
 		goto bad_fork_cleanup_security;
 	/* copy all the process information */
@@ -1141,6 +1407,9 @@ static struct task_struct *copy_process(
 	/*
 	 * sigaltstack should be cleared when sharing the same VM
 	 */
+#ifdef CONFIG_KRG_EPM
+	if (likely(!krg_current))
+#endif
 	if ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)
 		p->sas_ss_sp = p->sas_ss_size = 0;
 
@@ -1158,8 +1427,19 @@ static struct task_struct *copy_process(
 	p->parent_exec_id = p->self_exec_id;
 
 	/* ok, now we should be set up.. */
+#ifdef CONFIG_KRG_EPM
+	if (likely(!krg_current)) {
+#endif
 	p->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);
 	p->pdeath_signal = 0;
+#ifdef CONFIG_KRG_EPM
+	} else {
+		p->exit_signal = clone_flags & CSIGNAL;
+		if (p->tgid != krg_current->signal->krg_objid)
+			/* Not a migration */
+			p->pdeath_signal = 0;
+	}
+#endif
 	p->exit_state = 0;
 
 	/*
@@ -1167,9 +1447,55 @@ static struct task_struct *copy_process(
 	 * We dont wake it up yet.
 	 */
 	p->group_leader = p;
+#ifdef CONFIG_KRG_PROC
+	BUG_ON(p->task_ctnr && p->task_ctnr->group_leader != p->pid);
+#endif
 	INIT_LIST_HEAD(&p->thread_group);
 	INIT_LIST_HEAD(&p->ptrace_children);
 	INIT_LIST_HEAD(&p->ptrace_list);
+#ifdef CONFIG_KRG_EPM
+	/* Prepare to put p in the children kddm object of its parent.
+	 * If p reuses the parent of current, this is a bit tricky since
+	 * current may have been reparented to init before we acquire it's
+	 * parent process' children lock. */
+	parent_tgid = 0; /* Prevent gcc from whining on a possible use without
+			  * initialization */
+	if (!krg_current) {
+		struct children_ctnr_object *parent_children_obj = NULL;
+
+		if ((clone_flags & (CLONE_PARENT | CLONE_THREAD))) {
+			if (kh_parent_children_writelock)
+				parent_children_obj =
+					kh_parent_children_writelock(current,
+								     &parent_tgid);
+			else {
+				BUG_ON(current->real_parent == baby_sitter);
+				parent_tgid = current->real_parent->tgid;
+			}
+		} else {
+			parent_tgid = current->tgid;
+			if (kh_parent_children_writelock) {
+				parent_children_obj =
+					kh_children_writelock(parent_tgid);
+				if (!parent_children_obj)
+					kh_children_unlock(parent_tgid);
+			}
+		}
+		KRGFCT(kh_children_get)(parent_children_obj);
+		p->parent_children_obj = parent_children_obj;
+
+		/* Only init may have parent_tgid == 0 (the swapper). */
+		BUG_ON(p->pid != 1 && !parent_tgid);
+		/* Children of a process having no children kddm object cannot
+		 * migrate but with init we can do an exception. Maybe we should
+		 * check a bit more in order to allow migration only if the
+		 * first parent was not init. This would require another flag to
+		 * tell that the calling process was reparented. */
+		if (!parent_children_obj
+		    && parent_tgid != child_reaper(p)->tgid)
+			atomic_inc(&p->krg_cap_unavailable_private[CAP_CAN_MIGRATE]);
+	}
+#endif /* CONFIG_KRG_EPM */
 
 	/* Perform scheduler related setup. Assign this task to a CPU. */
 	sched_fork(p, clone_flags);
@@ -1200,8 +1526,33 @@ static struct task_struct *copy_process(
 	else
 		p->real_parent = current;
 	p->parent = p->real_parent;
+#ifdef CONFIG_KRG_PROC
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current)
+#endif
+	if (p->task_ctnr) {
+		if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {
+			p->task_ctnr->real_parent = current->task_ctnr->real_parent;
+			p->task_ctnr->real_parent_tgid = current->task_ctnr->real_parent_tgid;
+		} else {
+			p->task_ctnr->real_parent = current->pid;
+			p->task_ctnr->real_parent_tgid = current->tgid;
+		}
+		p->task_ctnr->parent = p->task_ctnr->real_parent;
+	}
+#endif /* CONFIG_KRG_PROC */
 
 	spin_lock(&current->sighand->siglock);
+#ifdef CONFIG_KRG_EPM
+#define SIGHAND_LOCK_CLEANUP do {				\
+	spin_unlock(&current->sighand->siglock);		\
+	write_unlock_irq(&tasklist_lock);			\
+	if (likely(p->parent_children_obj)) {			\
+		kh_children_unlock(parent_tgid);		\
+		kh_children_put(p->parent_children_obj);	\
+	}							\
+} while (0)
+#endif
 
 	/*
 	 * Process group and session signals need to be delivered to just the
@@ -1213,14 +1564,31 @@ static struct task_struct *copy_process(
  	 */
  	recalc_sigpending();
 	if (signal_pending(current)) {
+#ifdef CONFIG_KRG_EPM
+		SIGHAND_LOCK_CLEANUP;
+#else
 		spin_unlock(&current->sighand->siglock);
 		write_unlock_irq(&tasklist_lock);
+#endif
 		retval = -ERESTARTNOINTR;
 		goto bad_fork_cleanup_namespaces;
 	}
 
+#ifdef CONFIG_KRG_EPM
+	if (likely(!krg_current))
+#endif
 	if (clone_flags & CLONE_THREAD) {
 		p->group_leader = current->group_leader;
+#ifdef CONFIG_KRG_PROC
+		if (p->task_ctnr) {
+			p->task_ctnr->group_leader =
+				current->task_ctnr->group_leader;
+#ifdef CONFIG_KRG_EPM
+			if (p->group_leader != baby_sitter)
+#endif
+			BUG_ON(p->task_ctnr->group_leader != p->group_leader->pid);
+		}
+#endif
 		list_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);
 
 		if (!cputime_eq(current->signal->it_virt_expires,
@@ -1239,10 +1607,34 @@ static struct task_struct *copy_process(
 		}
 	}
 
+#ifdef CONFIG_KRG_EPM
+	if (likely(!krg_current)) {
+		retval = 0;
+		if (likely(kh_new_child)) {
+			pid_t parent_pid = p->parent->pid;
+
+			if (p->parent == baby_sitter)
+				parent_pid = p->task_ctnr->parent;
+			retval = kh_new_child(p->parent_children_obj,
+					      parent_pid,
+					      p->pid,
+					      process_group(p),
+					      process_session(p),
+					      p->exit_signal);
+		}
+		if (unlikely(retval)) {
+			SIGHAND_LOCK_CLEANUP;
+			goto bad_fork_cleanup_namespaces;
+		}
+	}
+#endif
 	if (likely(p->pid)) {
 		add_parent(p);
 		if (unlikely(p->ptrace & PT_PTRACED))
 			__ptrace_link(p, current->parent);
+#ifdef CONFIG_KRG_EPM
+		KRGFCT(kh_ptrace_copy_ptrace)(p);
+#endif
 
 		if (thread_group_leader(p)) {
 			p->signal->tty = current->signal->tty;
@@ -1259,8 +1651,31 @@ static struct task_struct *copy_process(
 	}
 
 	total_forks++;
+#ifdef CONFIG_KRG_EPM
+#undef SIGHAND_LOCK_CLEANUP
+#endif
 	spin_unlock(&current->sighand->siglock);
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (likely(p->parent_children_obj))
+		kh_children_unlock(parent_tgid);
+#endif
+#ifdef CONFIG_KRG_PROC
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current) {
+#endif
+	if (p->task_ctnr) {
+			/* We had to deactivate lockdep while creating the
+			 * task kddm object. */
+			lockdep_off();
+			kh_task_unlock(pid);
+			lockdep_on();
+			kh_set_pid_location(pid, kerrighed_node_id);
+	}
+#ifdef CONFIG_KRG_EPM
+	}
+#endif
+#endif
 	proc_fork_connector(p);
 	return p;
 
@@ -1272,9 +1687,32 @@ bad_fork_cleanup_mm:
 	if (p->mm)
 		mmput(p->mm);
 bad_fork_cleanup_signal:
+#ifdef CONFIG_KRG_EPM
+	if (likely(!krg_current
+		   || p->tgid != krg_current->signal->krg_objid))
+#endif
 	cleanup_signal(p);
 bad_fork_cleanup_sighand:
+#ifdef CONFIG_KRG_EPM
+	if (likely(!krg_current
+		   || p->tgid != krg_current->signal->krg_objid)) {
+		unsigned long sighand_id = 0;
+		struct task_struct *krg_current_saved;
+
+		krg_current_saved = krg_current;
+		krg_current = NULL;
+
+		if (kh_exit_sighand)
+			sighand_id = kh_exit_sighand(p->sighand->krg_objid);
+#endif /* CONFIG_KRG_EPM */
 	__cleanup_sighand(p->sighand);
+#ifdef CONFIG_KRG_EPM
+		if (sighand_id)
+			kh_sighand_struct_unlock(sighand_id);
+
+		krg_current = krg_current_saved;
+	}
+#endif /* CONFIG_KRG_EPM */
 bad_fork_cleanup_fs:
 	exit_fs(p); /* blocking */
 bad_fork_cleanup_files:
@@ -1285,6 +1723,17 @@ bad_fork_cleanup_audit:
 	audit_free(p);
 bad_fork_cleanup_security:
 	security_task_free(p);
+#ifdef CONFIG_KRG_CTNR
+bad_fork_cleanup_kddm_info:
+	kfree(p->kddm_info);
+#endif
+#ifdef CONFIG_KRG_EPM
+bad_fork_cleanup_children_obj:
+	if (!krg_current && p->children_obj) {
+		kh_children_writelock(p->tgid);
+		kh_exit_children(p);
+	}
+#endif
 bad_fork_cleanup_policy:
 #ifdef CONFIG_NUMA
 	mpol_free(p->mempolicy);
@@ -1302,6 +1751,15 @@ bad_fork_cleanup_count:
 	atomic_dec(&p->user->processes);
 	free_uid(p->user);
 bad_fork_free:
+#ifdef CONFIG_KRG_PROC
+#ifdef CONFIG_KRG_EPM
+	if (!krg_current)
+#endif
+	if (p->task_ctnr) {
+		kh_task_unlock(pid);
+		kh_free_task_struct(p);
+	}
+#endif /* CONFIG_KRG_PROC */
 	free_task(p);
 fork_out:
 	return ERR_PTR(retval);
@@ -1347,20 +1805,64 @@ static inline int fork_traceflag (unsign
  * It copies the process, and if successful kick-starts
  * it and waits for it to finish using the VM if required.
  */
+#ifdef CONFIG_KRG_EPM
+long __do_fork(unsigned long clone_flags,
+	       unsigned long stack_start,
+	       struct pt_regs *regs,
+	       unsigned long stack_size,
+	       int __user *parent_tidptr,
+	       int __user *child_tidptr,
+	       struct pid *__pid)
+#else
 long do_fork(unsigned long clone_flags,
 	      unsigned long stack_start,
 	      struct pt_regs *regs,
 	      unsigned long stack_size,
 	      int __user *parent_tidptr,
 	      int __user *child_tidptr)
+#endif
 {
 	struct task_struct *p;
 	int trace = 0;
+#ifdef CONFIG_KRG_EPM
+	struct pid *pid = __pid;
+#else
 	struct pid *pid = alloc_pid();
+#endif
 	long nr;
 
+#ifdef CONFIG_KRG_EPM
+	if (!pid)
+		pid = alloc_pid();
+#endif
 	if (!pid)
 		return -EAGAIN;
+#ifdef CONFIG_KRG_PROC
+	down_read(&kerrighed_init_sem);
+#endif
+#ifdef CONFIG_KRG_EPM
+#ifdef CONFIG_KRG_CAP
+	if (can_use_krg_cap(current, CAP_DISTANT_FORK))
+#endif
+	if (!krg_current) {
+		int retval;
+
+		BUG_ON(__pid);
+		retval = 0;
+		if (kh_do_fork) {
+			up_read(&kerrighed_init_sem);
+			retval = kh_do_fork(clone_flags, stack_start, regs,
+					    stack_size, parent_tidptr,
+					    child_tidptr);
+			if (retval > 0) {
+				free_pid(pid);
+				return retval;
+			} else
+				/* let a chance to local fork */
+				down_read(&kerrighed_init_sem);
+		}
+	}
+#endif /* CONFIG_KRG_EPM */
 	nr = pid->nr;
 	if (unlikely(current->ptrace)) {
 		trace = fork_traceflag (clone_flags);
@@ -1389,6 +1891,11 @@ long do_fork(unsigned long clone_flags,
 			set_tsk_thread_flag(p, TIF_SIGPENDING);
 		}
 
+#ifdef CONFIG_KRG_EPM
+		if (krg_current)
+			; /* Noop */
+		else
+#endif
 		if (!(clone_flags & CLONE_STOPPED))
 			wake_up_new_task(p, clone_flags);
 		else
@@ -1407,12 +1914,36 @@ long do_fork(unsigned long clone_flags,
 			}
 		}
 	} else {
+#ifdef CONFIG_KRG_EPM
+		/* The pid must be freed by the one having allocated it */
+		if (!__pid)
+#endif
 		free_pid(pid);
 		nr = PTR_ERR(p);
 	}
+#ifdef CONFIG_KRG_PROC
+	up_read(&kerrighed_init_sem);
+#endif
 	return nr;
 }
 
+#ifdef CONFIG_KRG_EPM
+long do_fork(unsigned long clone_flags,
+	      unsigned long stack_start,
+	      struct pt_regs *regs,
+	      unsigned long stack_size,
+	      int __user *parent_tidptr,
+	      int __user *child_tidptr)
+{
+	return __do_fork(clone_flags,
+			 stack_start, regs, stack_size,
+			 parent_tidptr, child_tidptr,
+			 NULL);
+}
+
+EXPORT_SYMBOL(__do_fork);
+#endif
+
 #ifndef ARCH_MIN_MMSTRUCT_ALIGN
 #define ARCH_MIN_MMSTRUCT_ALIGN 0
 #endif
diff -Nupr a/kernel/hrtimer.c b/kernel/hrtimer.c
--- a/kernel/hrtimer.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/hrtimer.c	2007-03-28 12:21:08.000000000 +0200
@@ -37,6 +37,9 @@
 #include <linux/notifier.h>
 #include <linux/syscalls.h>
 #include <linux/interrupt.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 #include <asm/uaccess.h>
 
@@ -774,6 +777,20 @@ sys_nanosleep(struct timespec __user *rq
 	return hrtimer_nanosleep(&tu, rmtp, HRTIMER_REL, CLOCK_MONOTONIC);
 }
 
+#ifdef CONFIG_KRG_EPM
+int hrtimer_krgsyms_register(void)
+{
+	return krgsyms_register(KRGSYMS_HRTIMER_NANOSLEEP_RESTART,
+				hrtimer_nanosleep_restart);
+}
+
+int hrtimer_krgsyms_unregister(void)
+{
+	return krgsyms_unregister(KRGSYMS_HRTIMER_NANOSLEEP_RESTART);
+}
+#endif
+
+
 /*
  * Functions related to boot-time initialization:
  */
diff -Nupr a/kernel/pid.c b/kernel/pid.c
--- a/kernel/pid.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/pid.c	2007-05-28 17:05:31.000000000 +0200
@@ -27,6 +27,10 @@
 #include <linux/bootmem.h>
 #include <linux/hash.h>
 #include <linux/pid_namespace.h>
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/pid.h>
+#include <kerrighed/krginit.h>
+#endif
 
 #define pid_hashfn(nr) hash_long((unsigned long)nr, pidhash_shift)
 static struct hlist_head *pid_hash;
@@ -154,6 +158,67 @@ static int alloc_pidmap(struct pid_names
 	return -1;
 }
 
+#ifdef CONFIG_KRG_EPM
+int reserve_pidmap(pid_t pid)
+{
+	int i, offset, max_scan;
+	struct pidmap *map, *tmp_map;
+	struct pid_namespace *pid_ns = current->nsproxy->pid_ns;
+
+	BUG_ON(ORIG_NODE(pid) != kerrighed_node_id);
+	pid = SHORT_PID(pid);
+	if (pid >= pid_max) return -1;
+
+	offset = pid & BITS_PER_PAGE_MASK;
+	map = &pid_ns->pidmap[pid/BITS_PER_PAGE];
+	max_scan = (pid_max + BITS_PER_PAGE - 1)/BITS_PER_PAGE - !offset;
+
+	tmp_map = &pid_ns->pidmap[0/BITS_PER_PAGE];
+
+	i = 0;
+
+	/* create all the missing pages */
+	/* TODO: really needed? */
+	while (unlikely(!tmp_map->page)) {
+		void *page;
+
+		if (i > max_scan) return -2;
+
+		page = kzalloc(PAGE_SIZE, GFP_KERNEL);
+		/*
+		 * Free the page if someone raced with us
+		 * installing it:
+		 */
+		spin_lock_irq(&pidmap_lock);
+		if (tmp_map->page)
+			kfree(page);
+		else
+			tmp_map->page = page;
+		spin_unlock_irq(&pidmap_lock);
+		if (unlikely(!tmp_map->page))
+			return -3;
+
+		if (map == tmp_map) break;
+		++tmp_map;
+		++i;
+	}
+
+	/* Reserve pid in the page */
+	if (pid == mk_pid(pid_ns, map, offset)) {
+		if (!test_and_set_bit(offset, map->page)) {
+			atomic_dec(&map->nr_free);
+
+			return 0;
+		}
+		return -4;
+	}
+
+	return -5;
+}
+
+EXPORT_SYMBOL(reserve_pidmap);
+#endif
+
 static int next_pidmap(struct pid_namespace *pid_ns, int last)
 {
 	int offset;
@@ -197,23 +262,56 @@ fastcall void free_pid(struct pid *pid)
 	hlist_del_rcu(&pid->pid_chain);
 	spin_unlock_irqrestore(&pidmap_lock, flags);
 
+#ifndef CONFIG_KRG_EPM
+#ifdef CONFIG_KRG_PROC
+	BUG_ON((pid->nr & GLOBAL_PID_MASK)
+	       && ORIG_NODE(pid->nr) != kerrighed_node_id);
+#endif
 	free_pidmap(&init_pid_ns, pid->nr);
+#else /* CONFIG_KRG_EPM */
+	{
+		int nr = pid->nr;
+
+		if (!(nr & GLOBAL_PID_MASK)
+		    || ORIG_NODE(nr) == kerrighed_node_id)
+			free_pidmap(&init_pid_ns, SHORT_PID(nr));
+	}
+#endif /* CONFIG_KRG_EPM */
 	call_rcu(&pid->rcu, delayed_put_pid);
 }
 
+#ifdef CONFIG_KRG_EPM
+struct pid *__alloc_pid(int nr)
+#else
 struct pid *alloc_pid(void)
+#endif
 {
 	struct pid *pid;
 	enum pid_type type;
+#ifndef CONFIG_KRG_EPM
 	int nr = -1;
+#endif
 
 	pid = kmem_cache_alloc(pid_cachep, GFP_KERNEL);
 	if (!pid)
 		goto out;
 
+#ifdef CONFIG_KRG_EPM
+	pid->ctnr_obj = NULL;
+
+	BUG_ON(nr > 0 && !(nr & GLOBAL_PID_MASK));
+	if (nr < 0) {
+#endif
 	nr = alloc_pidmap(current->nsproxy->pid_ns);
 	if (nr < 0)
 		goto out_free;
+#ifdef CONFIG_KRG_PROC
+	if (likely(current->nsproxy->pid_ns == &init_pid_ns))
+		nr = MAKE_KERRIGHED_PID(nr);
+#endif
+#ifdef CONFIG_KRG_EPM
+	}
+#endif
 
 	atomic_set(&pid->count, 1);
 	pid->nr = nr;
@@ -233,6 +331,15 @@ out_free:
 	goto out;
 }
 
+#ifdef CONFIG_KRG_EPM
+struct pid * alloc_pid(void)
+{
+	return __alloc_pid(-1);
+}
+
+EXPORT_SYMBOL(__alloc_pid);
+#endif
+
 struct pid * fastcall find_pid(int nr)
 {
 	struct hlist_node *elem;
@@ -275,6 +382,11 @@ void fastcall detach_pid(struct task_str
 		if (!hlist_empty(&pid->tasks[tmp]))
 			return;
 
+#ifdef CONFIG_KRG_EPM
+	if (kh_put_pid)
+		kh_put_pid(pid);
+	else
+#endif
 	free_pid(pid);
 }
 
@@ -348,13 +460,34 @@ struct pid *find_get_pid(pid_t nr)
 struct pid *find_ge_pid(int nr)
 {
 	struct pid *pid;
+#ifdef CONFIG_KRG_PROC
+	int global = (nr & GLOBAL_PID_MASK);
+#endif
 
 	do {
+#ifdef CONFIG_KRG_PROC
+		if (global && current->nsproxy->pid_ns == &init_pid_ns
+		    && !(nr & GLOBAL_PID_MASK))
+			nr = MAKE_KERRIGHED_PID(nr);
+#endif
 		pid = find_pid(nr);
 		if (pid)
 			break;
+#ifdef CONFIG_KRG_PROC
+		if (global) {
+			if (ORIG_NODE(nr) != kerrighed_node_id)
+				break;
+			nr = SHORT_PID(nr);
+		}
+#endif
 		nr = next_pidmap(current->nsproxy->pid_ns, nr);
 	} while (nr > 0);
+#ifdef CONFIG_KRG_PROC
+	if (nr <= 0
+	    && ISSET_KRG_INIT_FLAGS(KRG_INITFLAGS_NODEID) && !global
+	    && current->nsproxy->pid_ns == &init_pid_ns)
+		return find_ge_pid(MAKE_KERRIGHED_PID(0));
+#endif
 
 	return pid;
 }
diff -Nupr a/kernel/posix-cpu-timers.c b/kernel/posix-cpu-timers.c
--- a/kernel/posix-cpu-timers.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/posix-cpu-timers.c	2007-03-28 12:21:08.000000000 +0200
@@ -6,6 +6,9 @@
 #include <linux/posix-timers.h>
 #include <asm/uaccess.h>
 #include <linux/errno.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 static int check_clock(const clockid_t which_clock)
 {
@@ -1597,6 +1600,45 @@ static long thread_cpu_nsleep_restart(st
 	return -EINVAL;
 }
 
+#ifdef CONFIG_KRG_EPM
+int posix_cpu_timers_krgsyms_register(void)
+{
+	int err;
+
+	err = krgsyms_register(KRGSYMS_POSIX_CPU_NSLEEP_RESTART,
+			       posix_cpu_nsleep_restart);
+	if (err)
+		goto out;
+	err = krgsyms_register(KRGSYMS_PROCESS_CPU_NSLEEP_RESTART,
+			       process_cpu_nsleep_restart);
+	if (err)
+		goto err_process_cpu_nsleep;
+	err = krgsyms_register(KRGSYMS_THREAD_CPU_NSLEEP_RESTART,
+			       thread_cpu_nsleep_restart);
+	if (err)
+		goto err_thread_cpu_nsleep;
+ out:
+	return err;
+
+err_thread_cpu_nsleep:
+	krgsyms_unregister(KRGSYMS_PROCESS_CPU_NSLEEP_RESTART);
+err_process_cpu_nsleep:
+	krgsyms_unregister(KRGSYMS_POSIX_CPU_NSLEEP_RESTART);
+	goto out;
+}
+
+int posix_cpu_timers_krgsyms_unregister(void)
+{
+	int err;
+
+	err = krgsyms_unregister(KRGSYMS_THREAD_CPU_NSLEEP_RESTART);
+	err = err ? err : krgsyms_unregister(KRGSYMS_PROCESS_CPU_NSLEEP_RESTART);
+	err = err ? err : krgsyms_unregister(KRGSYMS_POSIX_CPU_NSLEEP_RESTART);
+
+	return err;
+}
+#endif /* CONFIG_KRG_EPM */
+
 static __init int init_posix_cpu_timers(void)
 {
 	struct k_clock process = {
diff -Nupr a/kernel/posix-timers.c b/kernel/posix-timers.c
--- a/kernel/posix-timers.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/posix-timers.c	2007-03-28 12:21:08.000000000 +0200
@@ -48,6 +48,9 @@
 #include <linux/wait.h>
 #include <linux/workqueue.h>
 #include <linux/module.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/krgsyms.h>
+#endif
 
 /*
  * Management arrays for POSIX timers.	 Timers are kept in slab memory
@@ -994,3 +997,16 @@ clock_nanosleep_restart(struct restart_b
 	return CLOCK_DISPATCH(which_clock, nsleep_restart,
 			      (restart_block));
 }
+
+#ifdef CONFIG_KRG_EPM
+int posix_timers_krgsyms_register(void)
+{
+	return krgsyms_register(KRGSYMS_CLOCK_NANOSLEEP_RESTART,
+				clock_nanosleep_restart);
+}
+
+int posix_timers_krgsyms_unregister(void)
+{
+	return krgsyms_unregister(KRGSYMS_CLOCK_NANOSLEEP_RESTART);
+}
+#endif /* CONFIG_KRG_EPM */
diff -Nupr a/kernel/ptrace.c b/kernel/ptrace.c
--- a/kernel/ptrace.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/ptrace.c	2007-03-28 12:21:08.000000000 +0200
@@ -18,6 +18,9 @@
 #include <linux/ptrace.h>
 #include <linux/security.h>
 #include <linux/signal.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/ptrace.h>
+#endif
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -34,6 +37,11 @@ void __ptrace_link(struct task_struct *c
 	if (child->parent == new_parent)
 		return;
 	list_add(&child->ptrace_list, &child->parent->ptrace_children);
+#ifdef CONFIG_KRG_EPM
+	/* Does nothing yet */
+	KRGFCT(kh_ptrace_link)(NULL, new_parent->pid, child->pid);
+#endif /* CONFIG_KRG_EPM */
+
 	remove_parent(child);
 	child->parent = new_parent;
 	add_parent(child);
@@ -72,6 +80,10 @@ void __ptrace_unlink(struct task_struct 
 	child->ptrace = 0;
 	if (!list_empty(&child->ptrace_list)) {
 		list_del_init(&child->ptrace_list);
+#ifdef CONFIG_KRG_EPM
+		/* Does nothing yet */
+		KRGFCT(kh_ptrace_unlink)(NULL, child->pid);
+#endif /* CONFIG_KRG_EPM */
 		remove_parent(child);
 		child->parent = child->real_parent;
 		add_parent(child);
@@ -196,6 +208,13 @@ repeat:
 	retval = may_attach(task);
 	if (retval)
 		goto bad;
+#ifdef CONFIG_KRG_EPM
+	if (kh_ptrace_attach) {
+		retval = kh_ptrace_attach(task);
+		if (retval)
+			goto bad;
+	}
+#endif /* CONFIG_KRG_EPM */
 
 	/* Go */
 	task->ptrace |= PT_PTRACED | ((task->real_parent != current)
@@ -237,6 +256,9 @@ int ptrace_detach(struct task_struct *ch
 	if (child->ptrace)
 		__ptrace_detach(child, data);
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	KRGFCT(kh_ptrace_detach)(child);
+#endif /* CONFIG_KRG_EPM */
 
 	return 0;
 }
@@ -406,6 +428,10 @@ int ptrace_traceme(void)
 	task_lock(current);
 	if (!(current->ptrace & PT_PTRACED)) {
 		ret = security_ptrace(current->parent, current);
+#ifdef CONFIG_KRG_EPM
+		if (!ret && kh_ptrace_traceme)
+			ret = kh_ptrace_traceme();
+#endif
 		/*
 		 * Set the ptrace bit in the process ptrace flags.
 		 */
diff -Nupr a/kernel/sched.c b/kernel/sched.c
--- a/kernel/sched.c	2007-06-05 17:06:30.000000000 +0200
+++ b/kernel/sched.c	2007-03-28 16:25:38.000000000 +0200
@@ -53,6 +53,13 @@
 #include <linux/kprobes.h>
 #include <linux/delayacct.h>
 #include <asm/tlb.h>
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/syscalls.h>
+#include <kerrighed/pid.h>
+#endif
+#ifdef CONFIG_KRG_SCHED
+#include <kerrighed/sched.h>
+#endif
 
 #include <asm/unistd.h>
 
@@ -852,6 +859,9 @@ static void __activate_task(struct task_
 		target = rq->expired;
 	enqueue_task(p, target);
 	inc_nr_running(p, rq);
+#ifdef CONFIG_KRG_SCHED
+	KRGFCT(kh_process_on)(p);
+#endif
 }
 
 /*
@@ -1004,6 +1014,9 @@ static void deactivate_task(struct task_
 	dec_nr_running(p, rq);
 	dequeue_task(p, p->array);
 	p->array = NULL;
+#ifdef CONFIG_KRG_SCHED
+	KRGFCT(kh_process_off)(p);
+#endif
 }
 
 /*
@@ -4324,6 +4337,10 @@ do_sched_setscheduler(pid_t pid, int pol
 	if (p != NULL)
 		retval = sched_setscheduler(p, policy, &lparam);
 	rcu_read_unlock();
+#ifdef CONFIG_KRG_PROC
+	if (!p && kh_sched_setscheduler && (pid & GLOBAL_PID_MASK))
+		retval = kh_sched_setscheduler(pid, policy, &lparam);
+#endif
 
 	return retval;
 }
@@ -4375,6 +4392,10 @@ asmlinkage long sys_sched_getscheduler(p
 			retval = p->policy;
 	}
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+	if (!p && kh_sched_getscheduler && (pid & GLOBAL_PID_MASK))
+		retval = kh_sched_getscheduler(pid);
+#endif
 
 out_nounlock:
 	return retval;
@@ -4398,7 +4419,17 @@ asmlinkage long sys_sched_getparam(pid_t
 	p = find_process_by_pid(pid);
 	retval = -ESRCH;
 	if (!p)
+#ifdef CONFIG_KRG_PROC
+	{
+		read_unlock(&tasklist_lock);
+		if (kh_sched_getparam && (pid & GLOBAL_PID_MASK))
+			retval = kh_sched_getparam(pid, &lp);
+		if (retval)
+			goto out_nounlock;
+	} else {
+#else
 		goto out_unlock;
+#endif
 
 	retval = security_task_getscheduler(p);
 	if (retval)
@@ -4406,6 +4437,9 @@ asmlinkage long sys_sched_getparam(pid_t
 
 	lp.sched_priority = p->rt_priority;
 	read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+	}
+#endif
 
 	/*
 	 * This one might sleep, we cannot do it with a spinlock held ...
diff -Nupr a/kernel/signal.c b/kernel/signal.c
--- a/kernel/signal.c	2007-06-05 17:06:30.000000000 +0200
+++ b/kernel/signal.c	2007-05-30 02:12:44.000000000 +0200
@@ -26,6 +26,14 @@
 #include <linux/freezer.h>
 #include <linux/pid_namespace.h>
 #include <linux/nsproxy.h>
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/syscalls.h>
+#include <kerrighed/pid.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/sched.h>
+#include <kerrighed/kerrighed_signal.h>
+#endif
 
 #include <asm/param.h>
 #include <asm/uaccess.h>
@@ -233,7 +241,11 @@ void recalc_sigpending(void)
 
 /* Given the mask, find the first available signal that should be serviced. */
 
+#ifdef CONFIG_KERRIGHED
+int
+#else
 static int
+#endif
 next_signal(struct sigpending *pending, sigset_t *mask)
 {
 	unsigned long i, *s, *m, x;
@@ -266,6 +278,9 @@ next_signal(struct sigpending *pending, 
 	
 	return sig;
 }
+#ifdef CONFIG_KERRIGHED
+EXPORT_SYMBOL(next_signal);
+#endif
 
 static struct sigqueue *__sigqueue_alloc(struct task_struct *t, gfp_t flags,
 					 int override_rlimit)
@@ -1109,6 +1124,10 @@ kill_pg_info(int sig, struct siginfo *in
 {
 	int retval;
 
+#ifdef CONFIG_KRG_PROC
+	if (kh_kill_pg_info)
+		return kh_kill_pg_info(sig, info, pgrp);
+#endif /* CONFIG_KRG_PROC */
 	read_lock(&tasklist_lock);
 	retval = __kill_pg_info(sig, info, pgrp);
 	read_unlock(&tasklist_lock);
@@ -1143,6 +1162,10 @@ static int kill_proc_info(int sig, struc
 	rcu_read_lock();
 	error = kill_pid_info(sig, info, find_pid(pid));
 	rcu_read_unlock();
+#ifdef CONFIG_KRG_PROC
+	if (error == -ESRCH && kh_kill_proc_info && (pid & GLOBAL_PID_MASK))
+		error = kh_kill_proc_info(sig, info, pid);
+#endif /* CONFIG_KRG_PROC */
 	return error;
 }
 
@@ -1208,6 +1231,10 @@ static int kill_something_info(int sig, 
 			}
 		}
 		read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+		if (kh_kill_all)
+			kh_kill_all(sig, info, &count, &retval, current->tgid);
+#endif /* CONFIG_KRG_PROC */
 		return count ? retval : -ESRCH;
 	} else if (pid < 0) {
 		return kill_pg_info(sig, info, -pid);
@@ -1458,6 +1485,44 @@ out:
 	return ret;
 }
 
+#ifdef CONFIG_KRG_EPM
+int send_kerrighed_signal(int sig, struct siginfo *info, struct task_struct *t)
+{
+	int err;
+	unsigned long flags;
+
+	printk("send_kerrighed_signal: %d (%s) -> %d (%s)\n",
+	       current->pid, current->comm, t->pid, t->comm);
+	info->si_signo = sig;
+	info->si_code = SI_KERRIGHED;
+
+	spin_lock_irqsave(&t->sighand->siglock, flags);
+	err = send_signal(sig, info, t, &t->pending);
+	if (!err)
+		signal_wake_up(t, 0);
+	spin_unlock_irqrestore(&t->sighand->siglock, flags);
+
+	return err;
+}
+
+EXPORT_SYMBOL(send_kerrighed_signal);
+
+static int handle_kerrighed_signal(int sig, struct siginfo *info,
+				   struct pt_regs *regs)
+{
+	int released = 0;
+
+	if (kh_krg_handler[sig]) {
+		spin_unlock_irq(&current->sighand->siglock);
+		released = 1;
+
+		(*kh_krg_handler[sig])(sig, info, regs);
+	}
+
+	return released;
+}
+#endif /* CONFIG_KRG_EPM */
+
 /*
  * Wake up any threads in the parent blocked in wait* syscalls.
  */
@@ -1550,6 +1615,10 @@ static void do_notify_parent_cldstop(str
 		tsk = tsk->group_leader;
 		parent = tsk->real_parent;
 	}
+#ifdef CONFIG_KRG_EPM
+	if (parent == baby_sitter)
+		return;
+#endif
 
 	info.si_signo = SIGCHLD;
 	info.si_errno = 0;
@@ -1830,6 +1899,14 @@ relock:
 
 		if (!signr)
 			break; /* will return 0 */
+#ifdef CONFIG_KRG_EPM
+		if (unlikely(info->si_code == SI_KERRIGHED)) {
+			if (likely(handle_kerrighed_signal(signr, info, regs)))
+				/* It released the siglock.  */
+				goto relock;
+			continue;
+		}
+#endif
 
 		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
 			ptrace_signal_deliver(regs, cookie);
diff -Nupr a/kernel/sys.c b/kernel/sys.c
--- a/kernel/sys.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/sys.c	2007-05-30 15:40:34.000000000 +0200
@@ -33,6 +33,16 @@
 #include <linux/compat.h>
 #include <linux/syscalls.h>
 #include <linux/kprobes.h>
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/krginit.h>
+#include <kerrighed/syscalls.h>
+#include <kerrighed/signal.h>
+#include <kerrighed/pid.h>
+#endif
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/sys/types.h>
+#include <kerrighed/children.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -1363,6 +1373,18 @@ asmlinkage long sys_setpgid(pid_t pid, p
 {
 	struct task_struct *p;
 	struct task_struct *group_leader = current->group_leader;
+#ifdef CONFIG_KRG_EPM
+	kerrighed_node_t node = KERRIGHED_NODE_ID_NONE;
+	/* We assume that:
+	 * 1/ only kernel threads and init have session id 1,
+	 * 2/ init won't call sys_setpgid on other processes,
+	 * 3/ the only kernel thread that calls sys_setpgid is
+	 *    the rpc handler of a forwarded setpgid.
+	 *
+	 * Should these assumptions be false, we may use a process flag set by
+	 * the rpc handler instead. */
+	int forwarded_call = process_session(group_leader) == 1;
+#endif /* CONFIG_KRG_EPM */
 	int err = -EINVAL;
 
 	if (!pid)
@@ -1372,6 +1394,28 @@ asmlinkage long sys_setpgid(pid_t pid, p
 	if (pgid < 0)
 		return -EINVAL;
 
+#ifdef CONFIG_KRG_PROC
+	down_read(&kerrighed_init_sem);
+
+#ifdef CONFIG_KRG_EPM
+	if (pid != current->pid && !forwarded_call && kh_forward_setpgid) {
+		node = kh_lock_pid_location(pid);
+		if (node != kerrighed_node_id
+		    && node != KERRIGHED_NODE_ID_NONE) {
+			kh_unlock_pid_location(pid);
+			err = kh_forward_setpgid(pid, pgid);
+
+			up_read(&kerrighed_init_sem);
+
+			return err;
+		}
+	}
+	if (!forwarded_call)
+		/* Otherwise the struct is locked by the calling kernel
+		 * thread. */
+#endif /* CONFIG_KRG_EPM */
+	KRGFCT(kh_signal_struct_writelock)(pid);
+#endif /* CONFIG_KRG_PROC */
 	/* From this point forward we keep holding onto the tasklist lock
 	 * so that our parent does not change from under us. -DaveM
 	 */
@@ -1386,6 +1430,11 @@ asmlinkage long sys_setpgid(pid_t pid, p
 	if (!thread_group_leader(p))
 		goto out;
 
+#ifdef CONFIG_KRG_EPM
+	if (forwarded_call)
+		/* The rpc handler already did the following checks. */
+		goto session_leader_check;
+#endif /* CONFIG_KRG_EPM */
 	if (p->real_parent == group_leader) {
 		err = -EPERM;
 		if (process_session(p) != process_session(group_leader))
@@ -1399,6 +1448,9 @@ asmlinkage long sys_setpgid(pid_t pid, p
 			goto out;
 	}
 
+#ifdef CONFIG_KRG_EPM
+session_leader_check:
+#endif
 	err = -EPERM;
 	if (p->signal->leader)
 		goto out;
@@ -1407,7 +1459,11 @@ asmlinkage long sys_setpgid(pid_t pid, p
 		struct task_struct *g =
 			find_task_by_pid_type(PIDTYPE_PGID, pgid);
 
+#ifdef CONFIG_KRG_EPM
+		if (!g || process_session(g) != process_session(p))
+#else
 		if (!g || process_session(g) != process_session(group_leader))
+#endif
 			goto out;
 	}
 
@@ -1422,9 +1478,41 @@ asmlinkage long sys_setpgid(pid_t pid, p
 	}
 
 	err = 0;
+#ifdef CONFIG_KRG_EPM
+	if (!forwarded_call)
+		get_task_struct(p);
+#endif
 out:
 	/* All paths lead to here, thus we are safe. -DaveM */
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (forwarded_call)
+		goto out_nounlock;
+#endif
+#ifdef CONFIG_KRG_PROC
+	KRGFCT(kh_signal_struct_unlock)(pid);
+#ifdef CONFIG_KRG_EPM
+	if (node != KERRIGHED_NODE_ID_NONE)
+		KRGFCT(kh_unlock_pid_location)(pid);
+	if (err)
+		goto out_nounlock;
+	if (kh_parent_children_writelock) {
+		struct children_ctnr_object *parent_children_obj;
+		pid_t real_parent_tgid;
+
+		parent_children_obj =
+			kh_parent_children_writelock(p, &real_parent_tgid);
+		if (parent_children_obj) {
+			kh_set_child_pgid(parent_children_obj, pid, pgid);
+			kh_children_unlock(real_parent_tgid);
+		}
+	}
+	put_task_struct(p);
+ out_nounlock:
+#endif /* CONFIG_KRG_EPM */
+
+	up_read(&kerrighed_init_sem);
+#endif /* CONFIG_KRG_PROC */
 	return err;
 }
 
@@ -1446,6 +1534,10 @@ asmlinkage long sys_getpgid(pid_t pid)
 				retval = process_group(p);
 		}
 		read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+		if (!p && kh_getpgid && (pid & GLOBAL_PID_MASK))
+			retval = kh_getpgid(pid);
+#endif
 		return retval;
 	}
 }
@@ -1478,6 +1570,10 @@ asmlinkage long sys_getsid(pid_t pid)
 				retval = process_session(p);
 		}
 		read_unlock(&tasklist_lock);
+#ifdef CONFIG_KRG_PROC
+		if (!p && kh_getsid && (pid & GLOBAL_PID_MASK))
+			retval = kh_getsid(pid);
+#endif
 		return retval;
 	}
 }
@@ -1488,6 +1584,9 @@ asmlinkage long sys_setsid(void)
 	pid_t session;
 	int err = -EPERM;
 
+#ifdef CONFIG_KRG_EPM
+	down_read(&kerrighed_init_sem);
+#endif
 	write_lock_irq(&tasklist_lock);
 
 	/* Fail if I am already a session leader */
@@ -1516,6 +1615,22 @@ asmlinkage long sys_setsid(void)
 	err = process_group(group_leader);
 out:
 	write_unlock_irq(&tasklist_lock);
+#ifdef CONFIG_KRG_EPM
+	if (err >= 0 && kh_parent_children_writelock) {
+		struct children_ctnr_object *parent_children_obj;
+		pid_t real_parent_tgid;
+
+		parent_children_obj =
+			kh_parent_children_writelock(current,
+						     &real_parent_tgid);
+		if (parent_children_obj) {
+			kh_set_child_pgid(parent_children_obj,
+					  session, session);
+			kh_children_unlock(real_parent_tgid);
+		}
+	}
+	up_read(&kerrighed_init_sem);
+#endif
 	return err;
 }
 
diff -Nupr a/kernel/sysctl.c b/kernel/sysctl.c
--- a/kernel/sysctl.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/sysctl.c	2007-03-02 22:59:22.000000000 +0100
@@ -158,6 +158,9 @@ static struct ctl_table_header root_tabl
 	{ root_table, LIST_HEAD_INIT(root_table_header.ctl_entry) };
 
 static ctl_table kern_table[];
+#ifdef CONFIG_KRG_FD
+static ctl_table fd_table[];
+#endif //FD
 static ctl_table vm_table[];
 static ctl_table fs_table[];
 static ctl_table debug_table[];
@@ -230,6 +233,94 @@ static void unregister_proc_table(ctl_ta
 
 /* The default sysctl tables: */
 
+#ifdef CONFIG_KRG_FD
+extern int threshold;
+extern int threshold_scheduler;
+extern int nb_process_delayed;
+extern int wait_time;
+#ifdef CONFIG_FD_V1
+extern int jeton;
+extern int var_chan_admin;
+#endif //V1
+extern int vload;
+static ctl_table fd_table[] = {
+	{
+		.ctl_name	= CTL_FD_THRESHOLD,
+		.procname	= "threshold",
+		.mode		= 0644,
+		.data           = &threshold,
+		.maxlen         = sizeof(threshold),
+		.proc_handler   = &proc_dointvec,
+	},
+	{
+		.ctl_name	= CTL_FD_VERSION,
+		.procname	= "version",
+		.mode		= 0444,
+#ifdef CONFIG_FD_V1
+		.data           = "FD_VERSION 1 : token",
+		.maxlen         = sizeof("FD_VERSION 1 : token"),
+#endif
+#ifdef CONFIG_FD_V2
+		.data           = "FD_VERSION 2 : message passing",
+		.maxlen         = sizeof("FD_VERSION 2 : message passing"),
+#endif
+
+		.proc_handler   = &proc_dostring,
+	},
+	{
+		.ctl_name	= CTL_FD_FIFO,
+		.procname	= "fifo",
+		.mode		= 0444,
+		.data           = &nb_process_delayed,
+		.maxlen         = sizeof(nb_process_delayed),
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= CTL_FD_VLOAD,
+		.procname	= "vload",
+		.mode		= 0444,
+		.data           = &vload,
+		.maxlen         = sizeof(vload),
+		.proc_handler   = &proc_dointvec,
+	},
+	{
+		.ctl_name	= CTL_FD_WAIT_TIME,
+		.procname	= "wait_time",
+		.mode		= 0644,
+		.data           = &wait_time,
+		.maxlen         = sizeof(wait_time),
+		.proc_handler   = &proc_dointvec,
+	},
+	{
+		.ctl_name	= CTL_FD_THRESHOLD_SCHED,
+		.procname	= "threshold_scheduler",
+		.mode		= 0644,
+		.data           = &threshold_scheduler,
+		.maxlen         = sizeof(threshold_scheduler),
+		.proc_handler   = &proc_dointvec,
+	},
+#ifdef CONFIG_FD_V1
+	{
+		.ctl_name	= CTL_FD_JETON,
+		.procname	= "jeton",
+		.mode		= 0444,
+		.data           = &jeton,
+		.maxlen         = sizeof(jeton),
+		.proc_handler   = &proc_dointvec,
+	},
+	{
+		.ctl_name	= CTL_FD_VAR_CHAN_ADMIN,
+		.procname	= "var_chan_admin",
+		.mode		= 0444,
+		.data           = &var_chan_admin,
+		.maxlen         = sizeof(var_chan_admin),
+		.proc_handler   = &proc_dointvec,
+	},
+#endif //V1
+	{ .ctl_name = 0 }
+};
+#endif //FD
+
 static ctl_table root_table[] = {
 	{
 		.ctl_name	= CTL_KERN,
@@ -243,6 +334,14 @@ static ctl_table root_table[] = {
 		.mode		= 0555,
 		.child		= vm_table,
 	},
+#ifdef CONFIG_KRG_FD
+	{
+		.ctl_name	= CTL_FD,
+		.procname	= "fork_delay",
+		.mode		= 0555,
+		.child		= fd_table,
+	},
+#endif
 #ifdef CONFIG_NET
 	{
 		.ctl_name	= CTL_NET,
diff -Nupr a/kernel/timer.c b/kernel/timer.c
--- a/kernel/timer.c	2007-02-04 19:44:54.000000000 +0100
+++ b/kernel/timer.c	2007-05-23 21:01:06.000000000 +0200
@@ -34,6 +34,12 @@
 #include <linux/cpu.h>
 #include <linux/syscalls.h>
 #include <linux/delay.h>
+#ifdef CONFIG_KRG_EPM
+#include <kerrighed/children.h>
+#endif
+#ifdef CONFIG_KRG_SCHED
+#include <kerrighed/sched.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -1156,6 +1162,9 @@ static inline void calc_load(unsigned lo
 			count += LOAD_FREQ;
 		} while (count < 0);
 	}
+#ifdef CONFIG_KRG_SCHED
+	KRGFCT(kh_calc_load)(ticks);
+#endif
 }
 
 /*
@@ -1256,6 +1265,11 @@ asmlinkage long sys_getppid(void)
 	int pid;
 
 	rcu_read_lock();
+#ifdef CONFIG_KRG_EPM
+	if (kh_get_real_parent_tgid)
+		pid = kh_get_real_parent_tgid(current);
+	else
+#endif
 	pid = rcu_dereference(current->real_parent)->tgid;
 	rcu_read_unlock();
 
diff -Nupr a/kerrighed/dvfs.c b/kerrighed/dvfs.c
--- a/kerrighed/dvfs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/dvfs.c	2007-03-07 17:29:15.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ *  Copyright (C) 2006-2007, Renaud Lottiaux, Kerlabs.
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <kerrighed/dvfs.h>
+
+
+
+/** Kerrighed Kernel Hooks **/
+
+EXPORT_SYMBOL(kh_file_pos_read);
+EXPORT_SYMBOL(kh_file_pos_write);
+EXPORT_SYMBOL(kh_put_file);
+
+
+
+/** Kerrighed symbols needed for Kerrighed **/
+
+EXPORT_SYMBOL(count_open_files);
+EXPORT_SYMBOL(alloc_fdtable);
+EXPORT_SYMBOL(fs_cachep);
+EXPORT_SYMBOL(put_filp);
+EXPORT_SYMBOL(exit_files);
+EXPORT_SYMBOL(__d_path);
+EXPORT_SYMBOL(files_cachep);
+EXPORT_SYMBOL(open_namei);
diff -Nupr a/kerrighed/epm.c b/kerrighed/epm.c
--- a/kerrighed/epm.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/epm.c	2007-05-25 11:09:23.000000000 +0200
@@ -0,0 +1,280 @@
+/*
+ *  Kerrighed/kernel/kerrighed/epm.c
+ *
+ *  Copyright (C) 2007 Louis Rilling - Kerlabs
+ */
+
+#include <linux/module.h>
+
+/* Kerrighed hooks */
+
+#include <linux/types.h>
+#include <kerrighed/sys/types.h>
+#include <kerrighed/krgsyms.h>
+#include <kerrighed/kerrighed_signal.h>
+#include <asm/signal.h>
+
+/* remote clone */
+struct pt_regs;
+
+int (*kh_do_fork)(unsigned long clone_flags,
+		  unsigned long stack_start,
+		  struct pt_regs *regs,
+		  unsigned long stack_size,
+		  int *parent_tidptr,
+		  int *child_tidptr) = NULL;
+EXPORT_SYMBOL(kh_do_fork);
+
+/* remote syscalls */
+#if 0 /* Temporarily disabled */
+int (*kh_setpgid)(pid_t pgid, pid_t session);
+#endif /* 0 */
+int (*kh_forward_setpgid)(pid_t pid, pid_t pgid);
+#if 0 /* Temporarily disabled */
+EXPORT_SYMBOL(kh_setpgid);
+#endif /* 0 */
+EXPORT_SYMBOL(kh_forward_setpgid);
+
+/* parent for processes whose real parent is on a distant node */
+struct task_struct;
+
+struct task_struct *baby_sitter = NULL;
+EXPORT_SYMBOL(baby_sitter);
+
+/* Kerrighed signal */
+kerrighed_handler_t *kh_krg_handler[_NSIG];
+EXPORT_SYMBOL(kh_krg_handler);
+
+/* pid reference tracking */
+struct pid;
+struct pid * (*kh_get_pid)(int nr);
+void (*kh_end_get_pid)(struct pid *pid);
+void (*kh_put_pid)(struct pid *pid);
+/* EXPORT_SYMBOL(__free_pidmap); */
+EXPORT_SYMBOL(kh_get_pid);
+EXPORT_SYMBOL(kh_end_get_pid);
+EXPORT_SYMBOL(kh_put_pid);
+
+/* pgrp */
+int (*kh_will_become_orphaned_pgrp)(pid_t pgrp, pid_t ignored_kid) = NULL;
+EXPORT_SYMBOL(kh_will_become_orphaned_pgrp);
+
+/* children */
+struct children_ctnr_object;
+
+struct children_ctnr_object * (*kh_alloc_children)(struct task_struct *task);
+void (*kh_share_children)(struct task_struct *task);
+void (*kh_exit_children)(struct task_struct *task);
+void (*kh_children_get)(struct children_ctnr_object *obj);
+void (*kh_children_put)(struct children_ctnr_object *obj);
+int (*kh_children_alive)(struct children_ctnr_object *obj);
+int (*kh_new_child)(struct children_ctnr_object *obj, pid_t parent_pid,
+		    pid_t child_pid, pid_t pgid, pid_t sid,
+		    int exit_signal);
+void (*kh_set_child_pgid)(struct children_ctnr_object *obj,
+			  pid_t pid, pid_t pgid);
+void (*kh_set_child_exit_signal)(struct children_ctnr_object *obj,
+				 pid_t pid, int exit_signal);
+void (*kh_remove_child)(struct children_ctnr_object *obj, pid_t child_pid);
+void (*kh_reparent_child)(struct children_ctnr_object *obj, pid_t child_pid,
+			  pid_t reaper_pid, int same_group);
+void (*kh_forget_original_remote_parent)(struct task_struct *parent,
+					 struct task_struct *reaper);
+void (*kh_reparent_to_local_child_reaper)(struct task_struct *task);
+int (*kh_may_be_eligible_child)(struct children_ctnr_object *obj,
+				pid_t pid,
+				int options);
+pid_t (*kh_get_real_parent_tgid)(struct task_struct *task);
+int (*kh_get_parent)(struct children_ctnr_object *obj, pid_t pid,
+		     pid_t *parent_pid, pid_t *real_parent_pid);
+void (*kh_ptrace_link)(struct children_ctnr_object *obj,
+		       pid_t ptracer_pid,
+		       pid_t child_pid);
+void (*kh_ptrace_unlink)(struct children_ctnr_object *obj, pid_t child_pid);
+struct children_ctnr_object * (*kh_children_writelock)(pid_t tgid);
+struct children_ctnr_object * (*kh_children_writelock_nested)(pid_t tgid);
+struct children_ctnr_object * (*kh_children_readlock)(pid_t tgid);
+struct children_ctnr_object * (*kh_parent_children_writelock)(
+	struct task_struct *task,
+	pid_t *parent_tgid);
+struct children_ctnr_object * (*kh_parent_children_readlock)(
+	struct task_struct *task,
+	pid_t *parent_tgid);
+void (*kh_children_unlock)(pid_t tgid);
+void (*kh_add_parent)(struct task_struct *task, struct task_struct *parent);
+void (*kh_remove_parent)(struct task_struct *task);
+EXPORT_SYMBOL(kh_alloc_children);
+EXPORT_SYMBOL(kh_share_children);
+EXPORT_SYMBOL(kh_exit_children);
+EXPORT_SYMBOL(kh_children_get);
+EXPORT_SYMBOL(kh_children_put);
+EXPORT_SYMBOL(kh_children_alive);
+EXPORT_SYMBOL(kh_new_child);
+EXPORT_SYMBOL(kh_set_child_pgid);
+EXPORT_SYMBOL(kh_set_child_exit_signal);
+EXPORT_SYMBOL(kh_remove_child);
+EXPORT_SYMBOL(kh_reparent_child);
+EXPORT_SYMBOL(kh_forget_original_remote_parent);
+EXPORT_SYMBOL(kh_reparent_to_local_child_reaper);
+EXPORT_SYMBOL(kh_may_be_eligible_child);
+EXPORT_SYMBOL(kh_get_real_parent_tgid);
+EXPORT_SYMBOL(kh_get_parent);
+EXPORT_SYMBOL(kh_ptrace_link);
+EXPORT_SYMBOL(kh_ptrace_unlink);
+EXPORT_SYMBOL(kh_children_writelock);
+EXPORT_SYMBOL(kh_children_writelock_nested);
+EXPORT_SYMBOL(kh_children_readlock);
+EXPORT_SYMBOL(kh_parent_children_writelock);
+EXPORT_SYMBOL(kh_parent_children_readlock);
+EXPORT_SYMBOL(kh_children_unlock);
+EXPORT_SYMBOL(kh_add_parent);
+EXPORT_SYMBOL(kh_remove_parent);
+
+/* ptrace */
+int (*kh_ptrace_traceme)(void);
+int (*kh_ptrace_attach)(struct task_struct *task) = NULL;
+void (*kh_ptrace_detach)(struct task_struct *task) = NULL;
+void (*kh_ptrace_ptracer_exit)(struct task_struct *task);
+void (*kh_ptrace_reparent_ptraced)(struct task_struct *real_parent,
+				   struct task_struct *task);
+void (*kh_ptrace_release_ptraced)(struct task_struct *task);
+void (*kh_ptrace_copy_ptrace)(struct task_struct *task);
+EXPORT_SYMBOL(kh_ptrace_traceme);
+EXPORT_SYMBOL(kh_ptrace_attach);
+EXPORT_SYMBOL(kh_ptrace_detach);
+EXPORT_SYMBOL(kh_ptrace_ptracer_exit);
+EXPORT_SYMBOL(kh_ptrace_reparent_ptraced);
+EXPORT_SYMBOL(kh_ptrace_release_ptraced);
+EXPORT_SYMBOL(kh_ptrace_copy_ptrace);
+
+/* exit */
+int (*kh_exit_notify)(struct task_struct *task,
+		      kerrighed_node_t parent_node,
+		      int sig_num,
+		      pid_t groupid, pid_t sessionid) = NULL;
+void (*kh_delay_release_task)(struct task_struct *task);
+EXPORT_SYMBOL(kh_exit_notify);
+EXPORT_SYMBOL(kh_delay_release_task);
+
+/* signal handlers sharing */
+struct sighand_struct;
+
+struct sighand_struct* (*kh_malloc_sighand_struct)(struct task_struct *task,
+						   int need_update) = NULL;
+void (*kh_share_sighand)(struct task_struct *task);
+unsigned long (*kh_exit_sighand)(unsigned long id);
+struct sighand_struct * (*kh_sighand_struct_readlock)(unsigned long id) = NULL;
+struct sighand_struct * (*kh_sighand_struct_writelock)(unsigned long id) = NULL;
+void (*kh_sighand_struct_unlock)(unsigned long id) = NULL;
+EXPORT_SYMBOL(kh_malloc_sighand_struct);
+EXPORT_SYMBOL(kh_share_sighand);
+EXPORT_SYMBOL(kh_exit_sighand);
+EXPORT_SYMBOL(kh_sighand_struct_readlock);
+EXPORT_SYMBOL(kh_sighand_struct_writelock);
+EXPORT_SYMBOL(kh_sighand_struct_unlock);
+
+/* migration */
+int (*kh_unset_pid_location)(pid_t pid) = NULL;
+EXPORT_SYMBOL(kh_unset_pid_location);
+
+/* Krgsyms to register for restart_blocks in ghost processes */
+extern int compat_krgsyms_register(void);
+extern int posix_timers_krgsyms_register(void);
+extern int hrtimer_krgsyms_register(void);
+extern int posix_cpu_timers_krgsyms_register(void);
+extern int compat_krgsyms_unregister(void);
+extern int posix_timers_krgsyms_unregister(void);
+extern int hrtimer_krgsyms_unregister(void);
+extern int posix_cpu_timers_krgsyms_unregister(void);
+
+int restart_block_krgsyms_register(void)
+{
+	int retval;
+
+	retval = krgsyms_register(KRGSYMS_DO_NO_RESTART_SYSCALL,
+				  do_no_restart_syscall);
+#ifdef CONFIG_COMPAT
+	if (!retval)
+		retval = compat_krgsyms_register();
+#endif
+	if (!retval)
+		retval = posix_timers_krgsyms_register();
+	if (!retval)
+		retval = hrtimer_krgsyms_register();
+	if (!retval)
+		retval = posix_cpu_timers_krgsyms_register();
+
+	return retval;
+}
+
+int restart_block_krgsyms_unregister(void)
+{
+	int retval;
+
+	retval = krgsyms_unregister(KRGSYMS_DO_NO_RESTART_SYSCALL);
+#ifdef CONFIG_COMPAT
+	if (!retval)
+		retval = compat_krgsyms_unregister();
+#endif
+	if (!retval)
+		retval = posix_timers_krgsyms_unregister();
+	if (!retval)
+		retval = hrtimer_krgsyms_unregister();
+	if (!retval)
+		retval = posix_cpu_timers_krgsyms_unregister();
+
+	return retval;
+}
+
+EXPORT_SYMBOL(restart_block_krgsyms_register);
+EXPORT_SYMBOL(restart_block_krgsyms_unregister);
+
+/* vanilla Linux symbols */
+
+#include <linux/syscalls.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/thread_info.h>
+#include <linux/syscalls.h>
+#include <linux/nsproxy.h>
+#include <linux/mount.h>
+#include <linux/mnt_namespace.h>
+#include <linux/pid_namespace.h>
+#include <kerrighed/syscalls.h>
+#include <kerrighed/signal.h>
+
+extern void *_stext;
+extern void *_etext;
+
+/* remote syscalls */
+EXPORT_SYMBOL(sys_setpgid);
+
+/* ghost process */
+EXPORT_SYMBOL(wake_up_new_task);
+EXPORT_SYMBOL(alloc_uid);
+EXPORT_SYMBOL(free_uid);
+EXPORT_SYMBOL(default_exec_domain);
+EXPORT_SYMBOL(do_no_restart_syscall);
+EXPORT_SYMBOL(vfsmount_lock);
+EXPORT_SYMBOL(__put_mnt_ns);
+EXPORT_SYMBOL(init_pid_ns);
+EXPORT_SYMBOL(free_pid_ns);
+EXPORT_SYMBOL(free_nsproxy);
+
+/* PID allocation */
+EXPORT_SYMBOL(alloc_pid);
+EXPORT_SYMBOL(free_pid);
+
+/* exit */
+EXPORT_SYMBOL(do_notify_parent);
+EXPORT_SYMBOL(release_task);
+
+EXPORT_SYMBOL(sighand_cachep);
+
+/* used by checkpoint */
+EXPORT_SYMBOL(sys_unlink);
+EXPORT_SYMBOL(sys_mkdir);
+
+/* only used by DEBUGs */
+EXPORT_SYMBOL(_stext);
+EXPORT_SYMBOL(_etext);
diff -Nupr a/kerrighed/faf.c b/kerrighed/faf.c
--- a/kerrighed/faf.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/faf.c	2007-05-29 14:47:54.000000000 +0200
@@ -0,0 +1,133 @@
+/*
+ *  Copyright (C) 2006-2007, Renaud Lottiaux, Pascal Gallard, Kerlabs.
+ */
+
+#include <linux/module.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/syscalls.h>
+
+
+/** Pure file system Kerrighed Kernel Hooks **/
+
+off_t (*kh_faf_lseek)(struct file *file, off_t offset,
+			     unsigned int origin) ;
+long (*kh_faf_llseek)(struct file *file, unsigned long offset_high,
+			     unsigned long offset_low, loff_t * result,
+			     unsigned int origin) ;
+ssize_t (*kh_faf_read)(struct file *file, char * buf, size_t count) ;
+ssize_t (*kh_faf_write)(struct file *file, const char * buf,
+			size_t count) ;
+long (*kh_faf_fcntl)(struct file *file, unsigned int cmd,
+		     unsigned long arg) ;
+long (*kh_faf_fcntl64)(struct file *file, unsigned int cmd,
+		       unsigned long arg) ;
+long (*kh_faf_ioctl)(struct file *file, unsigned int cmd,
+		     unsigned long arg) ;
+long (*kh_faf_fstat)(struct file *file, struct kstat *stat) ;
+long (*kh_faf_fsync)(struct file *file) ;
+long (*kh_faf_flock)(struct file *file, unsigned int cmd);
+void (*kh_faf_get_file)(struct file *file);
+int (*kh_faf_close_srv_file)(struct file *file);
+
+
+
+/** Communication related Kerrighed Kernel Hooks **/
+
+long (*kh_faf_bind)(struct file * file, struct sockaddr __user *umyaddr,
+		    int addrlen);
+long (*kh_faf_connect)(struct file * file, struct sockaddr __user *uservaddr,
+		       int addrlen);
+long (*kh_faf_listen)(struct file * file, int backlog);
+long (*kh_faf_accept)(struct file * file,
+		      struct sockaddr __user *upeer_sockaddr,
+		      int __user *upeer_addrlen);
+long (*kh_faf_getsockname)(struct file * file,
+			   struct sockaddr __user *usockaddr,
+			   int __user *usockaddr_len);
+long (*kh_faf_getpeername)(struct file * file, 
+			   struct sockaddr __user *usockaddr,
+			   int __user *usockaddr_len);
+long (*kh_faf_send)(struct file * file, void __user * buff, size_t len,
+		    unsigned flags);
+long (*kh_faf_sendto)(struct file * file, void __user * buff, size_t len,
+		      unsigned flags, struct sockaddr __user *addr, 
+		      int addr_len);
+long (*kh_faf_recv)(struct file * file, void __user * ubuf, size_t size,
+		    unsigned flags);
+long (*kh_faf_recvfrom)(struct file * file, void __user * ubuf, size_t size,
+			unsigned flags, struct sockaddr __user *addr,
+			int __user *addr_len);
+long (*kh_faf_shutdown)(struct file * file, int how);
+long (*kh_faf_setsockopt)(struct file * file, int level, int optname,
+			  char __user *optval, int optlen);
+long (*kh_faf_getsockopt)(struct file * file, int level, int optname,
+			  char __user *optval, int __user *optlen);
+long (*kh_faf_sendmsg)(struct file * file, struct msghdr __user *msg,
+		       unsigned flags);
+long (*kh_faf_recvmsg)(struct file * file, struct msghdr __user *msg,
+		       unsigned int flags);
+
+
+
+/** Kerrighed Exported Symbols **/
+
+EXPORT_SYMBOL(kh_faf_lseek);
+EXPORT_SYMBOL(kh_faf_llseek);
+EXPORT_SYMBOL(kh_faf_read);
+EXPORT_SYMBOL(kh_faf_write);
+EXPORT_SYMBOL(kh_faf_fcntl);
+EXPORT_SYMBOL(kh_faf_fcntl64);
+EXPORT_SYMBOL(kh_faf_ioctl);
+EXPORT_SYMBOL(kh_faf_fstat);
+EXPORT_SYMBOL(kh_faf_fsync);
+EXPORT_SYMBOL(kh_faf_flock);
+EXPORT_SYMBOL(kh_faf_get_file);
+EXPORT_SYMBOL(kh_faf_bind);
+EXPORT_SYMBOL(kh_faf_connect);
+EXPORT_SYMBOL(kh_faf_listen);
+EXPORT_SYMBOL(kh_faf_accept);
+EXPORT_SYMBOL(kh_faf_getsockname);
+EXPORT_SYMBOL(kh_faf_getpeername);
+EXPORT_SYMBOL(kh_faf_send);
+EXPORT_SYMBOL(kh_faf_sendto);
+EXPORT_SYMBOL(kh_faf_recv);
+EXPORT_SYMBOL(kh_faf_recvfrom);
+EXPORT_SYMBOL(kh_faf_shutdown);
+EXPORT_SYMBOL(kh_faf_setsockopt);
+EXPORT_SYMBOL(kh_faf_getsockopt);
+EXPORT_SYMBOL(kh_faf_sendmsg);
+EXPORT_SYMBOL(kh_faf_recvmsg);
+
+
+EXPORT_SYMBOL(sys_getpeername);
+EXPORT_SYMBOL(sys_connect);
+EXPORT_SYMBOL(sys_fcntl);
+#if BITS_PER_LONG == 32
+EXPORT_SYMBOL(sys_fcntl64);
+#endif
+EXPORT_SYMBOL(sys_sendmsg);
+EXPORT_SYMBOL(sys_shutdown);
+EXPORT_SYMBOL(sys_llseek);
+EXPORT_SYMBOL(sys_ioctl);
+EXPORT_SYMBOL(sys_getsockopt);
+EXPORT_SYMBOL(sys_getsockname);
+EXPORT_SYMBOL(sys_sendto);
+EXPORT_SYMBOL(sys_write);
+EXPORT_SYMBOL(sys_accept);
+EXPORT_SYMBOL(__fd_install);
+EXPORT_SYMBOL(sys_send);
+EXPORT_SYMBOL(__put_unused_fd);
+EXPORT_SYMBOL(sys_fsync);
+EXPORT_SYMBOL(sys_flock);
+EXPORT_SYMBOL(sys_bind);
+EXPORT_SYMBOL(sys_recvmsg);
+EXPORT_SYMBOL(kh_faf_close_srv_file);
+EXPORT_SYMBOL(sys_listen);
+EXPORT_SYMBOL(sys_lseek);
+EXPORT_SYMBOL(__get_unused_fd);
+EXPORT_SYMBOL(sys_recvfrom);
+EXPORT_SYMBOL(sys_setsockopt);
+EXPORT_SYMBOL(sys_recv);
+EXPORT_SYMBOL(__filp_close);
diff -Nupr a/kerrighed/hashtable.c b/kerrighed/hashtable.c
--- a/kerrighed/hashtable.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/hashtable.c	2007-04-19 09:38:44.000000000 +0200
@@ -0,0 +1,355 @@
+/*
+ *  Copyright (C) 2006-2007, Pascal Gallard, Kerlabs.
+ */
+
+#include <kerrighed/hashtable.h>
+
+/*****************************************************************************/
+/*                                                                           */
+/*                           KERRIGHED HASH TABLES                           */
+/*                                                                           */
+/*****************************************************************************/
+
+
+static struct hash_list HASH_LISTHEAD_NEW = { 0, NULL, NULL };
+
+
+/** Add a new element in a hash table linked list.
+ *  @author Viet Hoa Dinh
+ * 
+ *  The function must be called with the lock taken.
+ *
+ *  @param table  The table to add the element in.
+ *  @param hash   The element key.
+ *  @param data   The element to add in the table
+ *
+ *  @return  0 if everything ok.
+ *           Negative value otherwise.
+ */
+static inline int hash_list_add(hashtable_t * table,
+                                unsigned long hash,
+				void * data)
+{
+  struct hash_list * ht;
+  int index;
+
+  index = hash % table->hashtable_size;
+
+  ht = kmalloc(sizeof(struct hash_list), GFP_ATOMIC);
+  if (ht == NULL)
+    return -ENOMEM;
+
+  ht->hash = hash;
+  ht->data = data;
+  ht->next = table->table[index].next;
+
+  table->table[index].next = ht;
+
+  return 0;
+}
+
+
+
+/** Remove an element from a hash table linked list.
+ *  @author Viet Hoa Dinh
+ *
+ *  The function must be called with the lock taken.
+ *
+ *  @param table  The table to remove the element from.
+ *  @param hash   The element key.
+ *
+ *  @return  0 if everything ok.
+ *           Negative value otherwise.
+ */
+static inline void *hash_list_remove(hashtable_t * table,
+				     unsigned long hash)
+{
+	struct hash_list * cur;
+	void *data;
+	int index;
+
+	index = hash % table->hashtable_size;
+
+	for(cur = &table->table[index] ; cur->next != NULL ; cur = cur->next) {
+		if (cur->next->hash == hash) {
+			struct hash_list * hash_data;
+
+			hash_data = cur->next;
+			data = hash_data->data;
+			cur->next = cur->next->next;
+
+			kfree(hash_data);
+			return data;
+		}
+	}
+	
+	return NULL;
+}
+
+
+
+/** Free a hash table linked list.
+ *  @author Viet Hoa Dinh
+ *
+ *  The function must be called with the lock taken.
+ *
+ *  @param list  List to free.
+ */
+static inline void hash_list_free(struct hash_list * list)
+{
+  struct hash_list * cur;
+  struct hash_list * next;
+
+  next = list;
+  while (next != NULL) {
+    cur = next;
+    next = cur->next;
+    kfree(cur);
+  }
+}
+
+
+
+/** Find an element in a hash table linked list.
+ *  @author Viet Hoa Dinh
+ *
+ *  The function must be called with the lock taken.
+ *
+ *  @param table  The table to find the element in.
+ *  @param hash   The element key.
+ *
+ *  @return  A pointer to the found data.
+ *           NULL if the data is not found.
+ */
+static inline void * hash_list_find(hashtable_t * table,
+				    unsigned long hash)
+{
+  struct hash_list * cur;
+  int index;
+
+  index = hash % table->hashtable_size;
+
+  for(cur = table->table[index].next ; cur != NULL ; cur = cur->next) {
+    if (cur->hash == hash)
+      return cur->data;
+  }
+
+  return NULL;
+}
+
+
+/** Create a new hash table */
+
+hashtable_t * hashtable_new(unsigned long hashtable_size)
+{
+  hashtable_t * ht;
+  int i;
+
+  ht = kmalloc(sizeof(hashtable_t), GFP_KERNEL);
+  if (ht == NULL)
+    return NULL;
+
+  ht->table = kmalloc(sizeof(struct hash_list) * hashtable_size, GFP_KERNEL);
+  if (ht->table == NULL)
+    return NULL;
+
+  ht->hashtable_size = hashtable_size;
+  spin_lock_init(&ht->lock);
+
+  for(i = 0 ; i < hashtable_size ; i++)
+    ht->table[i] = HASH_LISTHEAD_NEW;
+
+  return ht;
+}
+
+
+
+/** Free a hash table */
+
+void hashtable_free(hashtable_t * table)
+{
+  int i;
+  unsigned long flags ;
+
+  spin_lock_irqsave (&table->lock, flags);
+
+  for(i = 0 ; i < table->hashtable_size ; i++)
+    hash_list_free(table->table[i].next);
+
+  spin_unlock_irqrestore (&table->lock, flags);
+
+  kfree(table);
+}
+
+
+
+/** Add an element in a hash table */
+
+int __hashtable_add(hashtable_t * table,
+		    unsigned long hash,
+		    void * data)
+{
+  int index;
+  int r = 0 ;
+
+#if defined(CONFIG_SMP)
+  BUG_ON(!spin_is_locked(&table->lock));
+#endif
+
+  index = hash % table->hashtable_size;
+
+  if (table->table[index].data == NULL)
+    {
+      table->table[index].hash = hash;
+      table->table[index].data = data;
+      table->table[index].next = NULL;
+    }
+  else
+    r = hash_list_add(table, hash, data);
+
+  return r ;
+}
+
+
+/** Remove an element from a hash table */
+
+void *__hashtable_remove(hashtable_t * table,
+			 unsigned long hash)
+{
+	int index;
+	struct hash_list * next;
+	void *data = NULL;
+	
+#if defined(CONFIG_SMP)
+	BUG_ON(!spin_is_locked(&table->lock));
+#endif
+	
+	index = hash % table->hashtable_size;
+	
+	if (table->table[index].hash == hash) {
+		data = table->table[index].data;
+
+		if ((next = table->table[index].next) != NULL) {
+			table->table[index].hash = next->hash;
+			table->table[index].data = next->data;
+			table->table[index].next = next->next;
+			kfree(next);
+		}
+		else {
+			table->table[index].hash = 0;
+			table->table[index].data = NULL;
+		}
+	}
+	else
+		data = hash_list_remove(table, hash);
+	
+	return data ;
+}
+
+
+
+/** Find an element in a hash table */
+
+void * __hashtable_find(hashtable_t * table,
+			unsigned long hash)
+{
+  int index;
+  void * data ;
+
+
+#if defined(CONFIG_SMP)
+	BUG_ON(!spin_is_locked(&table->lock));
+#endif
+
+  index = hash % table->hashtable_size;
+
+  if (table->table[index].hash == hash)
+    data = table->table[index].data;
+  else
+    data = hash_list_find(table, hash);
+
+  return data ;
+}
+
+
+
+/** Apply a function of each hash table key */
+
+void __hashtable_foreach_key(hashtable_t * table,
+			     void (* func)(int, void *),
+			     void * data)
+{
+  unsigned long index;
+  struct hash_list * cur;
+  //unsigned long flags ;
+
+  //spin_lock_irqsave (&table->lock, flags);
+
+  for(index = 0 ; index < table->hashtable_size ; index ++) {
+    if (table->table[index].data != NULL) {
+      func(table->table[index].hash, data);
+      for(cur = table->table[index].next ; cur != NULL ; cur = cur->next)
+        func(cur->hash, data);
+    }
+  }
+
+  //spin_unlock_irqrestore (&table->lock, flags);
+}
+
+
+
+/** Apply a function of each hash table element */
+
+void __hashtable_foreach_data(hashtable_t * table,
+			      void (* func)(void *, void *),
+			      void * data)
+{
+  unsigned long index;
+  struct hash_list * cur;
+  //unsigned long flags ;
+
+	//spin_lock_irqsave (&table->lock, flags);
+
+  for(index = 0 ; index < table->hashtable_size ; index ++) {
+    if (table->table[index].data != NULL) {
+      func(table->table[index].data, data);
+      for(cur = table->table[index].next ; cur != NULL ; cur = cur->next)
+        func(cur->data, data);
+    }
+  }
+
+	//spin_unlock_irqrestore (&table->lock, flags);
+
+}
+
+void * hashtable_find_data(hashtable_t * table,
+			   int (* func)(void *, void *),
+			   void * data)
+{
+  unsigned long index;
+  struct hash_list * cur;
+  unsigned long flags ;
+  void * res = NULL ;
+
+  spin_lock_irqsave (&table->lock, flags);
+
+  for(index = 0 ; index < table->hashtable_size ; index ++) {
+    if (table->table[index].data != NULL) {
+      if (func(table->table[index].data, data))
+	{
+	  res = table->table[index].data ;
+	  goto found ;
+	}
+      for(cur = table->table[index].next ; cur != NULL ; cur = cur->next)
+        if (func(cur->data, data))
+	  {
+	    res = cur->data;
+	    goto found;
+	  }
+    }
+  }
+
+found:
+  spin_unlock_irqrestore (&table->lock, flags);
+  return res ;
+}
diff -Nupr a/kerrighed/ipc.c b/kerrighed/ipc.c
--- a/kerrighed/ipc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/ipc.c	2007-06-01 11:32:51.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+ *  Copyright (C) 2006-2007, Renaud Lottiaux, Kerlabs.
+ */
+
+#include <linux/module.h>
+#include <linux/msg.h>
+#include <../ipc/util.h>
+#include <linux/ipc.h>
+#include <linux/shm.h>
+#include <linux/mm.h>
+#include <linux/lockdep.h>
+
+
+
+/** Kerrighed Kernel Hooks **/
+
+/* Cluster wide SHM management */
+
+struct shmid_kernel * (*kh_shm_lock)(struct ipc_namespace *ns, int id) = NULL;
+void (*kh_shm_unlock)(struct shmid_kernel *shp) = NULL;
+
+int (*kh_shm_newseg) (struct ipc_namespace *ns, 
+		      struct shmid_kernel * shp) = NULL ;
+void (*kh_shm_destroy)(struct ipc_namespace *ns,
+		       struct shmid_kernel *shp) = NULL ;
+void (*kh_shm_rmid)(struct ipc_namespace *ns,
+		    struct shmid_kernel *shp) = NULL ;
+int (*kh_shm_get_max_id)(struct ipc_namespace *ns, struct ipc_ids* ids) = NULL;
+int (*kh_get_ipc_id)(struct ipc_ids *ids, int size) = NULL;
+int (*kh_ipc_findkey)(struct ipc_ids *ids, key_t key) = NULL;
+
+
+
+/** Kerrighed Definitions **/
+
+struct vm_operations_struct krg_shmem_vmops;
+
+struct lock_class_key ipcid_lock_key;
+
+
+/** Kerrighed Exported Symbols **/
+
+EXPORT_SYMBOL(ipc_rcu_alloc);
+EXPORT_SYMBOL(ipc_addid);
+EXPORT_SYMBOL(ipc_rcu_putref);
+EXPORT_SYMBOL(shm_inc);
+EXPORT_SYMBOL(shm_close);
+EXPORT_SYMBOL(krg_shmem_vmops);
+EXPORT_SYMBOL(ipcid_lock_key);
+
+EXPORT_SYMBOL(grow_ary);
+EXPORT_SYMBOL(_shm_destroy);
+EXPORT_SYMBOL(shmem_file_setup);
+EXPORT_SYMBOL(shm_file_operations);
+EXPORT_SYMBOL(kh_shm_lock);
+EXPORT_SYMBOL(kh_shm_unlock);
+EXPORT_SYMBOL(kh_shm_newseg);
+EXPORT_SYMBOL(kh_shm_get_max_id);
+EXPORT_SYMBOL(kh_shm_destroy);
+EXPORT_SYMBOL(kh_shm_rmid);
+EXPORT_SYMBOL(kh_get_ipc_id);
+EXPORT_SYMBOL(kh_ipc_findkey);
+EXPORT_SYMBOL(init_ipc_ns);
+EXPORT_SYMBOL(ipc_lock);
+EXPORT_SYMBOL(ipc_unlock);
diff -Nupr a/kerrighed/Kconfig.Kerrighed b/kerrighed/Kconfig.Kerrighed
--- a/kerrighed/Kconfig.Kerrighed	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/Kconfig.Kerrighed	2007-05-11 11:34:33.000000000 +0200
@@ -0,0 +1,277 @@
+menu "Cluster support"
+
+config KERRIGHED
+	bool "Add the Kerrighed support"
+	depends on PREEMPT_NONE && !KEYS
+	default y
+	select KRG_TOOLS if !KERRIGHED_DEVEL
+	select KRG_KNETDEV if !KERRIGHED_DEVEL
+	select KRG_COMM if !KERRIGHED_DEVEL
+	select KRG_HOTPLUG if !KERRIGHED_DEVEL
+	select KRG_RPC if !KERRIGHED_DEVEL
+	select KRG_CTNR if !KERRIGHED_DEVEL
+	select KRG_CAP if !KERRIGHED_DEVEL
+	select KRG_PROCFS if !KERRIGHED_DEVEL
+	select KRG_MM if !KERRIGHED_DEVEL
+	select KRG_DVFS if !KERRIGHED_DEVEL
+	select KRG_FAF if !KERRIGHED_DEVEL
+	select KRG_IPC if !KERRIGHED_DEVEL
+	select KRG_PROC if !KERRIGHED_DEVEL
+	select KRG_EPM if !KERRIGHED_DEVEL
+	select KRG_SCHED if !KERRIGHED_DEVEL
+	help
+	  Say Y if you want to use the Kerrighed features.	
+
+config KERRIGHED_DEVEL
+	bool "Allow to build a subset of Kerrighed (!! Kerrighed development only !!)"
+	depends on KERRIGHED
+	default n
+	help
+	  The only reason to enable this, is that you intend to port Kerrighed
+		on a new architecture.
+
+		Just say N, and forget about it.
+
+config KRG_TOOLS
+	bool "Tools"
+	depends on KERRIGHED
+	help
+	  Common library in Kerrighed (without communication)
+
+config KRG_COMMUNICATION_FRAMEWORK
+       bool "Communication layer"
+       depends on KERRIGHED
+       select KRG_KNETDEV
+       select KRG_KNETDEV_NETDEVICE
+       select KRG_COMM
+       select TIPC
+       select KRG_RPC
+       help
+         All-purpose communication layer
+
+config KRG_AUTONODEID
+       bool "Set nodeid automatically"
+       depends on KERRIGHED
+       help
+         During the boot, if the IP address is available
+	 (dhcp, command line, etc.), this nodeid is set to the less
+	 significant byte of the IP address.
+
+	 In order to avoid any headache, be sure that all your nodes are
+	 on the same /24 network.
+
+	 If unsure, say Y.
+
+config KRG_NETDEVICE_SESSION
+	bool "Session architecture"
+	depends on KRG_KNETDEV_NETDEVICE
+	help
+	  Say yes if you want to activate session numbering. This is usefull
+	  if you want to run different Kerrighed sub-clusters through the same
+	  Ethernet switch.
+
+	  If unsure, say Y.
+
+config KRG_NETDEVICE_BADNET
+	bool "Introduce network failure/drop/delay"
+	depends on KRG_KNETDEV_NETDEVICE && KERRIGHED_DEVEL
+	help
+	  Introduce network failure/drop/delay
+
+config KRG_NETDEVICE_FORCEHUB
+	bool "Only use broadcast mac address"
+	depends on KRG_KNETDEV_NETDEVICE && KERRIGHED_DEVEL
+	help
+	  in case you are using a switch and you want to monitor all the
+	  packets in the network
+
+config KRG_COMM_STAT_MSG_SIZE
+	bool "Gimli stat -- message size"
+	depends on GIMLI
+	help
+	  Enable more stats
+
+config KRG_HOTPLUG
+	bool "KerHotplug"
+	depends on KERRIGHED
+	help
+	  Support for nodes management
+
+config KRG_DISABLE_HEARTBEAT
+       bool "Disable failure detector"
+       depends on KRG_HOTPLUG
+       help
+         If you don't want automatic reconfiguration on a node failure
+         just select this option.
+
+config KRG_CTNR
+	bool "KerCtnr"
+	depends on KRG_COMMUNICATION_FRAMEWORK
+	help
+	  Cluster wide data management. This is the general purpose
+	  mechanism used in Kerrighed to implement distributed
+  	  services.
+
+	  If unsure, say Y.
+
+config KRG_CAP
+	bool "KerCapabilities"
+	depends on KERRIGHED
+	help
+	  Kerrighed capabilities mechanism.
+
+	  If unsure, say Y.
+
+config KRG_PROCFS
+	bool "ProcFS"
+	depends on KRG_CTNR && KERRIGHED
+	help
+	  Global /proc mechanism.
+
+	  If unsure, say Y.
+
+config KRG_SYNC
+	bool "KerSync"
+	depends on KERRIGHED && KRG_CTNR
+	help
+	  Synchronization library
+
+config KRG_STREAM
+	bool "KerStream"
+	depends on KERRIGHED && KRG_CTNR
+	help
+		Distributed stream architecture
+
+config KRG_STREAM_PIPE
+	bool "Pipe interface"
+	depends on KRG_STREAM
+	help
+		distributed pipe interface
+
+config KRG_STREAM_UNIX
+  bool "Unix socket interface"
+	depends on KRG_STREAM
+	help
+	  distributed Unix socket interface
+
+config KRG_STREAM_INET
+	bool "INET socket interface"
+	depends on KRG_STREAM
+	help
+	  distributed Inet socket interface
+
+config KRG_MM
+	bool "KerMM"
+	depends on KERRIGHED && KRG_CTNR
+	help
+	  Kerrighed's global memory management
+
+config KRG_DVFS
+	bool "Distributed VFS"
+	depends on KRG_MM && KERRIGHED
+	help
+	  Kerrighed's distributed VFS. This is the Kerrighed basic
+	  bloc for distributed file management.
+
+	  If unsure, say Y.
+
+config KRG_FAF
+	bool "File access forwarding"
+	depends on KERRIGHED && KRG_DVFS
+	help
+	  Enable migration of open files and streams for those which
+	  cannot be more efficiently managed by other Kerrighed mechanisms.
+
+	  If unsure, say Y.
+
+config KRG_IPC
+	bool "KerIPC"
+	depends on KERRIGHED && KRG_CTNR && KRG_MM
+	help
+	  Kerrighed's global IPC management
+
+config KRG_PROC
+	bool "KerProc"
+	depends on KERRIGHED && KRG_CTNR
+	help
+	  Low-level global process management: global PIDs, syscalls affecting
+	  remote tasks (including signals), global proc PID entries.
+
+	  If unsure, say Y.
+
+config KRG_EPM
+	bool "KerEPM"
+	depends on KERRIGHED && KRG_PROC && KRG_CAP && KRG_MM && (KRG_DVFS || KRG_FAF)
+	help
+	  Enhanced Process Management (process migration, checkpoint/restart...)
+
+	  If unsure, say Y.
+
+config KRG_FD
+	bool "Activate Fork Delay"
+	depends on KRG_EPM
+	default n
+	help
+	  Activate Fork Delay
+	  Even if you do not activate Fork_Delay, you will allow to set the FORK_DELAY capability with "krg_capset" but, it will not have effect.
+
+choice
+	prompt "Fork_Delay version :"
+	default FD_V1
+	depends on KRG_FD
+
+config FD_V1
+	bool "1 (token)"
+	help
+	  Version 1 of the Fork_Delay.
+	  It uses an implementation with a token.
+
+config FD_V2
+	bool "2 (message passing)"
+	help
+	  Not yet implemented !
+endchoice
+
+config KRG_SCHED
+	bool "KerSched"
+	depends on KERRIGHED && KRG_EPM
+	help
+	  Global scheduler framework
+
+	  If unsure, say Y.
+
+config KRG_SCHED_MOSIX_PROBE
+	bool "Mosix probe support"
+	depends on KRG_SCHED
+	default y
+	help
+	  MOSIX-like global scheduler doing processor load-balancing
+
+	  If unsure, say Y.
+
+config KRG_MONOLITHIC
+	bool "Build one module for Kerrighed core"
+	depends on KERRIGHED
+	default y
+
+config AUTOLOAD_PLUGINS
+	bool "Autoload default Kerrighed modules (mainly scheduler modules)"
+	depends on KRG_MONOLITHIC && KMOD 
+	default y
+	
+config CLUSTER_WIDE_PROC
+	bool "See Cluster wide stats in /proc"
+	depends on KERRIGHED
+	default y
+	help
+	  Say yes if you want to see your cluster as a big SMP through the
+	  /proc files (meminfo, cpuinfo, etc).
+	  
+	  If unsure, say Y.
+
+config DEBUG_SEG_FAULT
+	bool "Debug seg faults"
+	depends on KERRIGHED
+	default n
+
+endmenu
diff -Nupr a/kerrighed/kerrighed.c b/kerrighed/kerrighed.c
--- a/kerrighed/kerrighed.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/kerrighed.c	2007-04-11 17:15:28.000000000 +0200
@@ -0,0 +1,224 @@
+/*
+ *  Copyright (C) 2006-2007, Kerlabs.
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <linux/swap.h>
+#include <linux/proc_fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/syscalls.h>
+#include <linux/rmap.h>
+#include <linux/acct.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/rwsem.h>
+#include <asm/pgalloc.h>
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h> // Needed for UserMode
+#include <asm/unistd.h>
+#ifndef CONFIG_USERMODE
+#include <asm/sigcontext.h>
+#else
+#include <sigcontext.h>
+#endif
+
+#include <linux/msg.h>
+
+#include <kerrighed/kernel_headers.h>
+#include <kerrighed/unique_id.h>
+#ifdef CONFIG_KRG_STREAM
+#include <kerrighed/net.h>
+#endif
+#include <kerrighed/hashtable.h>
+#include <kerrighed/krgsyms.h>
+
+
+
+/*****************************************************************************/
+/*                                                                           */
+/*                          KERRIGHED KERNEL HOOKS                           */
+/*                                                                           */
+/*****************************************************************************/
+
+
+#ifdef CONFIG_KRG_CTNR
+int (*kh_copy_kddm_info)(unsigned long clone_flags, struct task_struct * tsk);
+EXPORT_SYMBOL(kh_copy_kddm_info);
+#endif
+
+
+#ifdef CONFIG_KRG_SYNC
+int (*kh_futex_queue_me)(struct futex_q *q) = NULL;
+int (*kh_futex_wake)(union futex_key *key, int nr_wake, int nr_woken) = NULL;
+#endif // CONFIG_KRG_SYNC
+
+#ifdef CONFIG_KRG_STREAM
+struct proto_ops *kernet_socket_ops;
+struct proto *kernet_socket_proto;
+struct proto_ops *kernet_unix_stream_ops;
+struct proto_ops *kernet_unix_datagram_ops;
+struct proto_ops *kernet_inet_stream_ops;
+struct proto_ops *kernet_inet_datagram_ops;
+#endif
+
+#ifdef CONFIG_KRG_STREAM
+#warning deprecated code
+#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)
+extern void net_family_write_lock(void);
+extern void net_family_write_unlock(void);
+#else
+extern struct net_proto_family *net_families[];
+#define net_family_write_lock() do { } while(0)
+#define net_family_write_unlock() do { } while(0)
+#endif
+#endif
+
+#ifdef CONFIG_KRG_STREAM_PIPE
+void (*setup_krg_read_pipe)(struct file *) = NULL ;
+void (*setup_krg_write_pipe)(struct file *) = NULL ;
+struct inode * (*get_krg_pipe_inode)(struct vfsmount *) = NULL ;
+#endif
+
+/* Kerrighed FS management */
+
+loff_t (*kh_file_pos_read)(struct file *file) = NULL;
+void (*kh_file_pos_write)(struct file *file, loff_t pos) = NULL;
+void (*kh_put_file)(struct file *file) = NULL;
+
+#ifdef CONFIG_KRG_STREAM_PIPE
+int local_stream_flush(struct file * filp)
+{
+	int i ;
+	int file_still_present = 0 ;
+	if (current->files && !(current->flags & PF_EXITING))
+	{
+		for (i = 0 ; i < current->files->max_fds ; i++)
+		{
+			if ( FD_ISSET(i, current->files->open_fds) )
+			{
+				if (current->files->fd[i] == filp)
+				{
+					file_still_present = 1 ;
+					break ;
+				}
+			}
+		}
+		if (!file_still_present)
+		{
+			atomic_dec(&current->krg_cap_unavailable[CAP_CAN_MIGRATE]) ;
+			if (atomic_read (&current->krg_cap_unavailable[CAP_CAN_MIGRATE]) < 0 )
+				BUG() ;
+			atomic_dec(&current->krg_cap_unavailable[CAP_DISTANT_FORK]) ;
+			if (atomic_read (&current->krg_cap_unavailable[CAP_DISTANT_FORK]) < 0 )
+				BUG() ;
+		}
+	}
+	else
+	{
+		//we are exiting and/or files is NULL : we can't keep count correctly
+		atomic_dec(&current->krg_cap_unavailable[CAP_CAN_MIGRATE]) ;
+		if (atomic_read (&current->krg_cap_unavailable[CAP_CAN_MIGRATE]) < 0 )
+			atomic_set(&current->krg_cap_unavailable[CAP_CAN_MIGRATE], 0) ;
+		atomic_dec(&current->krg_cap_unavailable[CAP_DISTANT_FORK]) ;
+		if (atomic_read (&current->krg_cap_unavailable[CAP_DISTANT_FORK]) < 0 )
+			atomic_set(&current->krg_cap_unavailable[CAP_DISTANT_FORK], 0) ;
+	}
+	return 0 ;
+}
+#endif
+#if defined(CONFIG_KRG_STREAM_INET) || defined(CONFIG_KRG_STREAM_UNIX)
+int sock_change(struct net_proto_family *newops,
+		struct net_proto_family **oldops){
+  if (newops->family >= NPROTO) {
+    printk(KERN_CRIT "protocol %d >= NPROTO(%d)\n", newops->family, NPROTO);
+    return -ENOBUFS;
+  }
+
+  net_family_write_lock();
+  if(oldops) *oldops = net_families[newops->family];
+  net_families[newops->family] = newops;
+  net_family_write_unlock();
+
+  return 0;
+};
+#endif
+
+
+#ifdef CONFIG_FD_V1
+/* FORK_DELAY */
+int jeton = -1;
+int var_chan_admin = -1;
+EXPORT_SYMBOL(var_chan_admin);
+EXPORT_SYMBOL(jeton);
+#endif //CONFIG_FD_V1
+
+#ifdef CONFIG_KRG_FD
+int wait_time = 3000;
+EXPORT_SYMBOL(wait_time);
+int vload = 0;
+EXPORT_SYMBOL(vload);
+int nb_process_delayed = 0;
+EXPORT_SYMBOL(nb_process_delayed);
+struct l_p_delay head_list_fd;
+EXPORT_SYMBOL(head_list_fd);
+int init_fd = 1; //initialization fd
+EXPORT_SYMBOL(init_fd);
+int (*kh_fd_send_msg)(int code, int type) = NULL;
+EXPORT_SYMBOL(kh_fd_send_msg);
+int threshold = 1990;
+EXPORT_SYMBOL(threshold);
+int threshold_scheduler = 2300; //krg_scheduler.c
+EXPORT_SYMBOL(threshold_scheduler);
+#endif //CONFIG_KRG_FD
+/*
+ * Kerrighed symbol
+ */
+
+#ifdef CONFIG_KRG_SYNC
+EXPORT_SYMBOL(kh_futex_queue_me);
+EXPORT_SYMBOL(kh_futex_wake);
+EXPORT_SYMBOL(__futex_wake);
+#endif // CONFIG_KRG_SYNC
+
+#ifdef CONFIG_KERRIGHED
+EXPORT_SYMBOL(hashtable_new);
+EXPORT_SYMBOL(hashtable_free);
+EXPORT_SYMBOL(hashtable_add);
+EXPORT_SYMBOL(__hashtable_add);
+EXPORT_SYMBOL(hashtable_remove);
+EXPORT_SYMBOL(__hashtable_remove);
+EXPORT_SYMBOL(hashtable_find);
+EXPORT_SYMBOL(__hashtable_find);
+EXPORT_SYMBOL(__hashtable_foreach_key);
+EXPORT_SYMBOL(__hashtable_foreach_data);
+EXPORT_SYMBOL(hashtable_find_data);
+EXPORT_SYMBOL(krgsyms_register);
+EXPORT_SYMBOL(krgsyms_unregister);
+EXPORT_SYMBOL(krgsyms_export);
+EXPORT_SYMBOL(krgsyms_import);
+#endif // CONFIG_KERRIGHED
+
+#ifdef CONFIG_KRG_STREAM
+EXPORT_SYMBOL(kernet_socket_ops);
+EXPORT_SYMBOL(kernet_socket_proto);
+#endif
+
+#ifdef CONFIG_KRG_STREAM_PIPE
+EXPORT_SYMBOL(setup_krg_read_pipe);
+EXPORT_SYMBOL(setup_krg_write_pipe);
+EXPORT_SYMBOL(get_krg_pipe_inode);
+#endif
+
+#ifdef CONFIG_KRG_STREAM_UNIX
+EXPORT_SYMBOL(unix_stream_ops);
+EXPORT_SYMBOL(kernet_unix_stream_ops);
+EXPORT_SYMBOL(kernet_unix_datagram_ops);
+#endif
+
+#ifdef CONFIG_KRG_STREAM_INET
+EXPORT_SYMBOL(kernet_inet_stream_ops);
+EXPORT_SYMBOL(kernet_inet_datagram_ops);
+#endif
diff -Nupr a/kerrighed/kersyms.c b/kerrighed/kersyms.c
--- a/kerrighed/kersyms.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/kersyms.c	2007-05-02 19:10:40.000000000 +0200
@@ -0,0 +1,76 @@
+/*
+ *  Copyright (C) 2006-2007, Pascal Gallard, Kerlabs.
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/syscalls.h>
+#include <linux/rmap.h>
+#include <linux/acct.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/rwsem.h>
+#include <asm/pgalloc.h>
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h> // Needed for UserMode
+#include <asm/unistd.h>
+#ifndef CONFIG_USERMODE
+#include <asm/sigcontext.h>
+#else
+#include <sigcontext.h>
+#endif
+
+#include <linux/msg.h>
+#include <linux/reboot.h>
+#include <../fs/proc/internal.h>
+
+#include <kerrighed/kernel_headers.h>
+
+/*
+ * Additionnal kernel symbol
+ */
+
+#ifdef CONFIG_USERMODE
+void show_registers(struct pt_regs *regs)
+{
+  printk("show_registers is not supported using UML\n");
+}
+#endif
+
+EXPORT_SYMBOL(show_registers);
+EXPORT_SYMBOL(machine_restart);
+
+#ifdef CONFIG_KRG_STREAM_PIPE
+EXPORT_SYMBOL(bad_pipe_r);
+EXPORT_SYMBOL(bad_pipe_w);
+EXPORT_SYMBOL(pipe_ioctl);
+EXPORT_SYMBOL(pipe_mnt);
+#endif /* CONFIG_KRG_STREAM_PIPE */
+#if defined(CONFIG_KRG_STREAM_INET) || defined(CONFIG_KRG_STREAM_UNIX)
+EXPORT_SYMBOL(sock_mnt);
+EXPORT_SYMBOL(sockfs_dentry_operations);
+EXPORT_SYMBOL(socket_file_ops);
+EXPORT_SYMBOL(sock_change);
+EXPORT_SYMBOL(sock_alloc);
+#endif
+
+#ifdef CONFIG_USERMODE
+EXPORT_SYMBOL(um_execve);
+EXPORT_SYMBOL(sc_to_sc);
+#endif // CONFIG_USERMODE
+
+#ifdef CONFIG_KRG_HOTPLUG
+EXPORT_SYMBOL(emergency_sync);
+EXPORT_SYMBOL(emergency_remount);
+#endif
+
+#ifdef CONFIG_KRG_CTNR
+EXPORT_SYMBOL(radix_tree_preload);
+#endif
+
+#ifdef CONFIG_KRG_COMMUNICATION_FRAMEWORK
+EXPORT_SYMBOL(tasklist_lock);
+#endif
diff -Nupr a/kerrighed/krginit.c b/kerrighed/krginit.c
--- a/kerrighed/krginit.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/krginit.c	2007-05-07 19:31:15.000000000 +0200
@@ -0,0 +1,253 @@
+/*
+ *  Copyright (C) 2006-2007, Pascal Gallard, Kerlabs.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+
+#include <kerrighed/types.h>
+#include <kerrighed/krginit.h>
+#include <kerrighed/krgsyms.h>
+#include <kerrighed/unique_id.h>
+#ifdef CONFIG_KRG_PROC
+#include <kerrighed/pid.h>
+#endif
+#ifdef CONFIG_KRG_HOTPLUG
+#include <kerrighed/hotplug.h>
+#endif
+
+/* Node id */
+kerrighed_node_t kerrighed_node_id = 0;
+EXPORT_SYMBOL(kerrighed_node_id);
+
+/* Number of active nodes in the cluster */
+kerrighed_node_t kerrighed_nb_nodes = 0;
+EXPORT_SYMBOL(kerrighed_nb_nodes);
+
+/* Min number of node before to start a cluster */
+kerrighed_node_t kerrighed_nb_nodes_min = -1;
+EXPORT_SYMBOL(kerrighed_nb_nodes_min);
+
+/* Session id in order to mix several krg in the same physical network */
+kerrighed_session_t kerrighed_session_id = 0;
+EXPORT_SYMBOL(kerrighed_session_id);
+
+/* ID of subcluster in the main one */
+kerrighed_subsession_t kerrighed_subsession_id = -1;
+EXPORT_SYMBOL(kerrighed_subsession_id);
+
+/* Initialisation flags */
+int kerrighed_init_flags = 0;
+EXPORT_SYMBOL(kerrighed_init_flags);
+
+/* lock around process transformation and hooks install */
+DECLARE_RWSEM(kerrighed_init_sem);
+EXPORT_SYMBOL(kerrighed_init_sem);
+
+#ifdef CONFIG_KRG_PROC
+/* Mask between local pid mode and global pid mode */
+pid_t current_pid_mask = 0;
+EXPORT_SYMBOL(current_pid_mask);
+#endif
+
+
+/*****************************************************************************/
+/*                                                                           */
+/*                          KERRIGHED INIT FUNCTION                          */
+/*                                                                           */
+/*****************************************************************************/
+
+static char *read_from_file(char *_filename, int size)
+{
+	int error;
+	struct file *f;
+	char *b, *filename;
+
+	b = kmalloc(size, GFP_ATOMIC);
+	BUG_ON(b==NULL);
+
+	filename = getname(_filename);
+	if (!IS_ERR(filename)) {
+		f = filp_open(filename, O_RDONLY, 0);
+		if (IS_ERR(f)) {
+			printk("error: %ld\n", PTR_ERR(f));
+			goto err_file;
+		}
+
+		error = kernel_read(f, 0, b, size);
+		//printk("read %d bytes\n", error);
+
+		b[error] = 0;
+		//printk(">>>%s<<<\n", b);
+
+		if (f->f_op && f->f_op->flush) {
+			error = f->f_op->flush(f, NULL);
+			if (error)
+				printk("global_pid_init: Error while closing file %d\n", error);
+		}
+	}
+	return b;
+
+ err_file:
+	kfree(b);
+	return NULL;
+}
+
+/* Remove then CR (if any) */
+static void strip_hostname(char *h)
+{
+	char *i;
+
+	for (i = h; *i; i++) {
+		if (*i == 10) {
+			*i=0;
+			break;
+		}
+	}
+}
+
+static char *get_next_line(char *k)
+{
+	char *i;
+
+	BUG_ON(*k==0);
+
+	for (i = k; *i; i++) {
+		if (*i == 10)
+			return i+1;
+	}
+
+	return NULL;
+}
+
+static void read_kerrighed_nodes(char *_h, char *k)
+{
+	char *ik, *h;
+	int lh;
+
+	if ((_h==NULL) || (k==NULL))
+		return;
+
+	lh = strlen(_h);
+	h = kmalloc(lh+1, GFP_ATOMIC);
+	strncpy(h, _h, lh);
+	h[lh] = ':';
+	h[lh+1] = 0;
+	lh = strlen(h);
+
+	kerrighed_nb_nodes = 0;
+	for (ik=k; *ik;) {
+		if (!ISSET_KRG_INIT_FLAGS(KRG_INITFLAGS_SESSIONID)) {
+			if (strncmp("session=", ik, 8) == 0){
+				ik += 8;
+				kerrighed_session_id = simple_strtoul(ik, NULL, 10);
+				SET_KRG_INIT_FLAGS(KRG_INITFLAGS_SESSIONID);
+
+				ik = get_next_line(ik);
+			}
+		}
+
+		if (strncmp("nbmin=", ik, 6) == 0) {
+			ik += 6;
+			kerrighed_nb_nodes_min = simple_strtoul(ik, NULL, 10);
+			ik = get_next_line(ik);
+		}
+
+		if (!ISSET_KRG_INIT_FLAGS(KRG_INITFLAGS_NODEID)) {
+			if (strncmp(h, ik, lh) == 0) {
+				char *end;
+				ik += lh;
+
+				kerrighed_node_id = simple_strtoul(ik, &end, 10);
+				SET_KRG_INIT_FLAGS(KRG_INITFLAGS_NODEID);
+			}
+		}
+
+		if (!ISSET_KRG_INIT_FLAGS(KRG_INITFLAGS_NBNODES))
+			kerrighed_nb_nodes++;
+
+		ik = get_next_line(ik);
+	}
+
+	if (!ISSET_KRG_INIT_FLAGS(KRG_INITFLAGS_NBNODES))
+		SET_KRG_INIT_FLAGS(KRG_INITFLAGS_NBNODES);
+}
+
+void global_pid_init(int nodeid, int nbnodes,int session_id, int nbmin)
+{
+	char *hostname, *kerrighed_nodes;
+	int need_read = 0;
+
+	if (!ISSET_KRG_INIT_FLAGS(KRG_INITFLAGS_NODEID)) {
+		if (nodeid >= 0) {
+			kerrighed_node_id = nodeid;
+			SET_KRG_INIT_FLAGS(KRG_INITFLAGS_NODEID);
+		} else
+			need_read = 1;
+	}
+
+	if (nbnodes >= 0) {
+		kerrighed_nb_nodes = nbnodes;
+		SET_KRG_INIT_FLAGS(KRG_INITFLAGS_NBNODES);
+	} else
+		need_read = 1;
+
+	if (session_id >= 0) {
+		kerrighed_session_id = session_id;
+		SET_KRG_INIT_FLAGS(KRG_INITFLAGS_SESSIONID);
+	} else
+		need_read = 1;
+
+	if (nbmin >= 0)
+		kerrighed_nb_nodes_min = nbmin;
+
+	if (need_read) {
+		/* first we read the name of the node */
+		hostname = read_from_file("/etc/hostname", 256);
+		if (!hostname) {
+			printk("Can't read /etc/hostname\n");
+			goto out;
+		}
+		strip_hostname(hostname);
+
+		kerrighed_nodes = read_from_file("/etc/kerrighed_nodes", 4096);
+		if (!kerrighed_nodes) {
+			kfree(hostname);
+			printk("Can't read /etc/kerrighed_nodes\n");
+			goto out;
+		}
+		read_kerrighed_nodes(hostname, kerrighed_nodes);
+
+		kfree(kerrighed_nodes);
+		kfree(hostname);
+	}
+
+ out:
+	if (ISSET_KRG_INIT_FLAGS(KRG_INITFLAGS_NODEID)) {
+#ifdef CONFIG_KRG_HOTPLUG
+		universe[kerrighed_node_id].state = 1;
+#endif
+#ifdef CONFIG_KRG_PROC
+		current_pid_mask = GLOBAL_PID_MASK;
+#endif
+	}
+
+	printk("Kerrighed session ID : %d\n", kerrighed_session_id);
+	printk("Kerrighed node ID    : %d\n", kerrighed_node_id);
+	printk("Kerrighed nb nodes   : %d\n", kerrighed_nb_nodes);
+	printk("Kerrighed min nodes  : %d\n", kerrighed_nb_nodes_min);
+
+	return;
+}
+
+EXPORT_SYMBOL(global_pid_init);
+
+void init_node_discovering(void);
+
+void kerrighed_init(void)
+{
+	init_krgsyms();
+	init_unique_ids();
+	init_node_discovering();
+}
diff -Nupr a/kerrighed/krgsyms.c b/kerrighed/krgsyms.c
--- a/kerrighed/krgsyms.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/krgsyms.c	2007-02-26 17:13:54.000000000 +0100
@@ -0,0 +1,109 @@
+/*
+ *  Copyright (C) 2006-2007, Pascal Gallard, Kerlabs.
+ */
+
+#include <kerrighed/krgsyms.h>
+#include <kerrighed/hashtable.h>
+
+/*****************************************************************************/
+/*                                                                           */
+/*                          KERRIGHED KSYM MANAGEMENT                        */
+/*                                                                           */
+/*****************************************************************************/
+
+
+#define KRGSYMS_HTABLE_SIZE 256
+
+static hashtable_t *krgsyms_htable = NULL;
+static void* krgsyms_table[KRGSYMS_TABLE_SIZE];
+
+int krgsyms_register(enum krgsyms_val v, void* p)
+{
+	if( (v < 0) || (v >= KRGSYMS_TABLE_SIZE) ){
+		printk("krgsyms_register: Incorrect krgsym value (%d)\n", v);
+		BUG();
+		return -1;
+	};
+
+	if(krgsyms_table[v])
+		printk("krgsyms_register_symbol(%d, %p): value already set in table\n",
+					 v, p);
+
+	if(hashtable_find(krgsyms_htable, (unsigned long)p) != NULL)
+	{
+		printk("krgsyms_register_symbol(%d, %p): value already set in htable\n",
+					 v, p);
+		BUG();
+	}
+
+	hashtable_add(krgsyms_htable, (unsigned long)p, (void*)v);
+	krgsyms_table[v] = p;
+
+	return 0;
+};
+
+int krgsyms_unregister(enum krgsyms_val v)
+{
+	void *p;
+
+	if( (v < 0) || (v >= KRGSYMS_TABLE_SIZE) ){
+		printk("krgsyms_unregister: Incorrect krgsym value (%d)\n", v);
+		BUG();
+		return -1;
+	};
+
+	p = krgsyms_table[v];
+	krgsyms_table[v] = NULL;
+	hashtable_remove(krgsyms_htable, (unsigned long)p);
+
+	return 0;
+};
+
+enum krgsyms_val krgsyms_export(void* p)
+{
+	enum krgsyms_val ret;
+
+	ret = (enum krgsyms_val)hashtable_find(krgsyms_htable, (unsigned long)p);
+
+	if ((p!=NULL) && (ret == KRGSYMS_UNDEF))
+	  {
+			printk ("undefined krgsymbol (0x%p)!", p);
+			BUG();
+		}
+
+	return ret;
+};
+
+void* krgsyms_import(enum krgsyms_val v)
+{
+	if( (v < 0) || (v >= KRGSYMS_TABLE_SIZE) ){
+		printk("krgsyms_import: Incorrect krgsym value (%d)\n", v);
+		BUG();
+		return NULL;
+	};
+
+	if ((v!=0) && (krgsyms_table[v] == NULL))
+	{
+		printk ("undefined krgsymbol (%d)\n", v);
+		BUG();
+	}
+
+	return krgsyms_table[v];
+};
+
+int init_krgsyms(void)
+{
+	int i;
+
+	krgsyms_htable = hashtable_new(KRGSYMS_HTABLE_SIZE);
+	if(krgsyms_table == NULL) return -ENOMEM;
+
+	for(i=0;i<KRGSYMS_TABLE_SIZE;i++){
+		krgsyms_table[i] = NULL;
+	};
+
+	return 0;
+};
+
+void cleanup_krgsyms(void){
+};
diff -Nupr a/kerrighed/Makefile b/kerrighed/Makefile
--- a/kerrighed/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/Makefile	2007-05-04 13:37:27.000000000 +0200
@@ -0,0 +1,15 @@
+#
+# Makefile for the Kerrighed kernel files.
+#
+
+obj-y = kerrighed.o unique_id.o kersyms.o krgsyms.o hashtable.o krginit.o
+
+obj-$(CONFIG_KRG_HOTPLUG) += node_discovering.o
+obj-$(CONFIG_KRG_PROCFS) += procfs.o
+obj-$(CONFIG_KRG_PROC) += proc.o
+obj-$(CONFIG_KRG_EPM) += epm.o
+obj-$(CONFIG_KRG_SCHED) += sched.o
+obj-$(CONFIG_KRG_MM) += mm.o
+obj-$(CONFIG_KRG_FAF) += faf.o
+obj-$(CONFIG_KRG_DVFS) += dvfs.o
+obj-$(CONFIG_KRG_IPC) += ipc.o
diff -Nupr a/kerrighed/mm.c b/kerrighed/mm.c
--- a/kerrighed/mm.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/mm.c	2007-05-30 17:22:46.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ *  Copyright (C) 2006-2007, Renaud Lottiaux, Kerlabs.
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/rmap.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <asm/pgalloc.h>
+
+
+
+/** Kerrighed Kernel Hooks **/
+
+int (*kh_copy_mm)(unsigned long clone_flags, struct mm_struct *mm,
+ 		  struct mm_struct *oldmm) = NULL;
+
+void (*kh_mmdrop) (struct mm_struct *mm) = NULL;
+
+
+
+/** Kerrighed Exported Symbols **/
+
+EXPORT_SYMBOL(kh_mmdrop);
+EXPORT_SYMBOL(kh_copy_mm);
+EXPORT_SYMBOL(try_to_unmap);
+EXPORT_SYMBOL(generic_file_vm_ops);
+EXPORT_SYMBOL(insert_vm_struct);
+EXPORT_SYMBOL(copy_page_range);
+EXPORT_SYMBOL(vm_area_cachep);
+EXPORT_SYMBOL(mm_cachep);
+EXPORT_SYMBOL(empty_zero_page);
+EXPORT_SYMBOL(exit_mm);
+EXPORT_SYMBOL(anon_vma_prepare);
+EXPORT_SYMBOL(page_add_anon_rmap);
+EXPORT_SYMBOL(lru_cache_add_active);
+EXPORT_SYMBOL(page_add_file_rmap);
+EXPORT_SYMBOL(mmlist_lock);
+#ifdef CONFIG_USERMODE
+EXPORT_SYMBOL(mk_pte);
+EXPORT_SYMBOL(flush_tlb_page);
+EXPORT_SYMBOL(flush_tlb_all);
+#else // CONFIG_USERMODE 
+EXPORT_SYMBOL(alloc_ldt);
+#ifdef CONFIG_SMP
+EXPORT_SYMBOL(flush_tlb_all);
+#endif
+#endif // CONFIG_USERMODE
+EXPORT_SYMBOL(pgd_alloc);
+EXPORT_SYMBOL(__pmd_alloc);
+EXPORT_SYMBOL(__pud_alloc);
+EXPORT_SYMBOL(pgd_free);
+EXPORT_SYMBOL(find_vma_prev);
+EXPORT_SYMBOL(page_remove_rmap);
+EXPORT_SYMBOL(add_to_page_cache_lru);
+EXPORT_SYMBOL(remove_from_page_cache);
+EXPORT_SYMBOL(arch_unmap_area);
+EXPORT_SYMBOL(arch_get_unmapped_area);
+EXPORT_SYMBOL(arch_unmap_area_topdown);
+EXPORT_SYMBOL(arch_get_unmapped_area_topdown);
+EXPORT_SYMBOL(shmem_vm_ops);
+EXPORT_SYMBOL(__pte_alloc);
+EXPORT_SYMBOL(__mmdrop);
diff -Nupr a/kerrighed/node_discovering.c b/kerrighed/node_discovering.c
--- a/kerrighed/node_discovering.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/node_discovering.c	2007-05-04 17:38:13.000000000 +0200
@@ -0,0 +1,30 @@
+#include <linux/module.h>
+
+#include <kerrighed/sys/types.h>
+#include <kerrighed/krginit.h>
+#include <kerrighed/hotplug.h>
+
+struct universe_elem universe[KERRIGHED_MAX_NODES];
+EXPORT_SYMBOL(universe);
+
+void krg_node_arrival(kerrighed_node_t nodeid){
+	printk("krg_node_arrival: %d\n", nodeid);
+	universe[nodeid].state = 1;
+};
+
+void krg_node_departure(kerrighed_node_t nodeid){
+	printk("krg_node_departure: %d\n", nodeid);
+	universe[nodeid].state = 0;
+};
+
+void init_node_discovering(void){
+	int i;
+
+	for(i=0;i<KERRIGHED_MAX_NODES;i++){
+		universe[i].state = 0;
+		universe[i].subid = -1;
+	};
+
+	if(ISSET_KRG_INIT_FLAGS(KRG_INITFLAGS_NODEID))
+		universe[kerrighed_node_id].state = 1;
+};
diff -Nupr a/kerrighed/proc.c b/kerrighed/proc.c
--- a/kerrighed/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/proc.c	2007-05-09 16:13:10.000000000 +0200
@@ -0,0 +1,122 @@
+/*
+ *  Kerrighed/kernel/kerrighed/proc.c
+ *
+ *  Copyright (C) 2007 Louis Rilling - Kerlabs
+ */
+
+#include <linux/module.h>
+
+/* Kerrighed hooks */
+
+#include <linux/types.h>
+#include <kerrighed/sys/types.h>
+
+/* remote syscalls */
+struct siginfo;
+struct sched_param;
+
+/* not implemented yet */
+int (*kh_setpriority)(int which, int who, int niceval, int *error) = NULL;
+/* not implemented yet */
+int (*kh_getpriority)(int which, int who, long *error) = NULL;
+/* not implemented yet */
+void (*kh_kill_all)(int sig, struct siginfo *info, int *count, int *retval,
+		    int tgid) = NULL;
+int (*kh_kill_proc_info)(int sig, struct siginfo *info, pid_t pid) = NULL;
+int (*kh_kill_pg_info)(int sig, struct siginfo *info, pid_t pgid) = NULL;
+int (*kh_getpgid)(pid_t pid);
+int (*kh_getsid)(pid_t pid);
+int (*kh_sched_setscheduler)(pid_t pid, int policy, struct sched_param *param);
+long (*kh_sched_getscheduler)(pid_t pid) = NULL;
+int (*kh_sched_getparam)(pid_t pid, struct sched_param *lp) = NULL;
+EXPORT_SYMBOL(kh_kill_all);
+EXPORT_SYMBOL(kh_kill_proc_info);
+EXPORT_SYMBOL(kh_kill_pg_info);
+EXPORT_SYMBOL(kh_getpgid);
+EXPORT_SYMBOL(kh_getsid);
+EXPORT_SYMBOL(kh_sched_setscheduler);
+EXPORT_SYMBOL(kh_sched_getscheduler);
+EXPORT_SYMBOL(kh_sched_getparam);
+
+/* kerrighed_task (to be removed) */
+struct task_struct;
+
+void (*kh_copy_process)(struct task_struct *tsk);
+EXPORT_SYMBOL(kh_copy_process);
+
+/* task container */
+struct task_ctnr_object;
+
+void (*kh_task_get)(struct task_ctnr_object *obj);
+void (*kh_task_put)(struct task_ctnr_object *obj);
+int (*kh_task_alive)(struct task_ctnr_object *obj);
+struct task_ctnr_object * (*kh_task_readlock)(pid_t pid);
+struct task_ctnr_object * (*kh_task_writelock)(pid_t pid);
+struct task_ctnr_object * (*kh_task_writelock_nested)(pid_t pid);
+void (*kh_task_unlock)(pid_t pid);
+struct task_struct* (*kh_malloc_task_struct)(pid_t pid);
+void (*kh_free_task_struct)(struct task_struct *task);
+EXPORT_SYMBOL(kh_task_get);
+EXPORT_SYMBOL(kh_task_put);
+EXPORT_SYMBOL(kh_task_alive);
+EXPORT_SYMBOL(kh_task_readlock);
+EXPORT_SYMBOL(kh_task_writelock);
+EXPORT_SYMBOL(kh_task_writelock_nested);
+EXPORT_SYMBOL(kh_task_unlock);
+EXPORT_SYMBOL(kh_malloc_task_struct);
+EXPORT_SYMBOL(kh_free_task_struct);
+
+/* pid location */
+int (*kh_set_pid_location)(pid_t pid, kerrighed_node_t node);
+kerrighed_node_t (*kh_lock_pid_location)(pid_t pid);
+void (*kh_unlock_pid_location)(pid_t pid);
+EXPORT_SYMBOL(kh_set_pid_location);
+EXPORT_SYMBOL(kh_lock_pid_location);
+EXPORT_SYMBOL(kh_unlock_pid_location);
+
+/* exit */
+void (*kh_release_task)(struct task_struct *p);
+EXPORT_SYMBOL(kh_release_task);
+
+/* signal struct sharing */
+struct signal_struct;
+
+struct signal_struct * (*kh_malloc_signal_struct)(struct task_struct *task,
+						  int need_update) = NULL;
+void (*kh_share_signal)(struct task_struct *task);
+pid_t (*kh_exit_signal)(struct task_struct *task);
+struct signal_struct * (*kh_signal_struct_readlock)(pid_t tgid) = NULL;
+struct signal_struct * (*kh_signal_struct_writelock)(pid_t tgid) = NULL;
+void (*kh_signal_struct_unlock)(pid_t tgid) = NULL;
+EXPORT_SYMBOL(kh_malloc_signal_struct);
+EXPORT_SYMBOL(kh_share_signal);
+EXPORT_SYMBOL(kh_exit_signal);
+EXPORT_SYMBOL(kh_signal_struct_readlock);
+EXPORT_SYMBOL(kh_signal_struct_writelock);
+EXPORT_SYMBOL(kh_signal_struct_unlock);
+
+
+/* vanilla Linux symbols */
+
+#include <linux/sched.h>
+#include <linux/syscalls.h>
+#include <linux/pid.h>
+#include <kerrighed/task.h>
+#include <kerrighed/signal.h>
+
+/* remote syscalls */
+EXPORT_SYMBOL(__kill_pg_info);
+EXPORT_SYMBOL(sys_getpgid);
+EXPORT_SYMBOL(sys_getsid);
+EXPORT_SYMBOL(sys_sched_getscheduler);
+EXPORT_SYMBOL(sys_sched_getparam);
+
+/* infrastructure */
+/* task_struct allocation outside kernel/fork.c */
+EXPORT_SYMBOL(__put_task_struct); /* Needed since put_task_struct is a macro */
+#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
+EXPORT_SYMBOL(task_struct_cachep);
+#endif
+EXPORT_SYMBOL(signal_cachep);
+
+EXPORT_SYMBOL(pid_task);
diff -Nupr a/kerrighed/procfs.c b/kerrighed/procfs.c
--- a/kerrighed/procfs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/procfs.c	2007-05-02 19:10:40.000000000 +0200
@@ -0,0 +1,91 @@
+/*
+ *  Kerrighed/kernel/kerrighed/procfs.c
+ *
+ *  Copyright (C) 1999-2006 INRIA, Universite de Rennes 1, EDF
+ *  Copyright (C) 2007 Louis Rilling - Kerlabs
+ */
+
+#include <linux/module.h>
+
+#ifdef CONFIG_KRG_PROC
+/* /proc/<pid>/ */
+
+/* Kerrighed hooks */
+#include <linux/fs.h>
+#include <linux/types.h>
+
+struct task_struct;
+struct inode;
+struct dentry;
+
+int (*kh_task_cpu)(struct task_struct *task);
+struct dentry * (*kh_proc_pid_lookup)(struct inode *dir,
+				      struct dentry *dentry, pid_t pid);
+int (*kh_proc_pid_readdir)(struct file *filp,
+			   void *dirent, filldir_t filldir,
+			   loff_t offset);
+EXPORT_SYMBOL(kh_task_cpu);
+EXPORT_SYMBOL(kh_proc_pid_lookup);
+EXPORT_SYMBOL(kh_proc_pid_readdir);
+#endif /* CONFIG_KRG_PROC */
+
+#ifdef CONFIG_KRG_PROC
+int proc_pid_environ(struct task_struct *task, char *buffer);
+int proc_pid_cmdline(struct task_struct *task, char *buffer);
+#endif
+
+struct seq_file;
+
+int show_cpuinfo(struct seq_file *m, void *v);
+
+#include <linux/pid.h>
+#include "../fs/proc/internal.h"
+#include <kerrighed/procfs.h>
+#include <linux/sched.h>
+#include <linux/highmem.h>
+#include <linux/swap.h>
+#include <linux/mmzone.h>
+#include <linux/kernel_stat.h>
+#include <linux/time.h>
+#include <linux/mman.h>
+#include <linux/hugetlb.h>
+
+/* vanilla Linux symbols */
+#ifdef CONFIG_KRG_PROC
+/* EXPORT_SYMBOL(last_pid); */
+/* EXPORT_SYMBOL(get_page_state); */
+/* EXPORT_SYMBOL(do_posix_clock_monotonic_gettime); */
+/* EXPORT_SYMBOL(boot_cpu_data); */
+EXPORT_SYMBOL(find_ge_pid);
+EXPORT_SYMBOL(is_subdir);
+EXPORT_SYMBOL(proc_def_inode_operations);
+EXPORT_SYMBOL(proc_setattr);
+EXPORT_SYMBOL(do_proc_readlink);
+EXPORT_SYMBOL(proc_pid_fill_cache);
+EXPORT_SYMBOL(proc_tgid_stat);
+EXPORT_SYMBOL(proc_pid_statm);
+EXPORT_SYMBOL(proc_pid_status);
+EXPORT_SYMBOL(proc_pid_environ);
+EXPORT_SYMBOL(proc_pid_cmdline);
+#endif
+
+EXPORT_SYMBOL(show_cpuinfo);
+EXPORT_SYMBOL(get_vmalloc_info);
+
+EXPORT_SYMBOL(total_forks);
+EXPORT_SYMBOL(nr_iowait);
+EXPORT_SYMBOL(nr_threads);
+#ifdef CONFIG_HIGHMEM
+EXPORT_SYMBOL(totalhigh_pages);
+#endif
+EXPORT_SYMBOL(si_swapinfo);
+EXPORT_SYMBOL(get_zone_counts);
+EXPORT_SYMBOL(nr_running);
+EXPORT_SYMBOL(nr_context_switches);
+EXPORT_SYMBOL(wall_to_monotonic);
+EXPORT_SYMBOL(vm_committed_space);
+EXPORT_SYMBOL(swapper_space);
+EXPORT_SYMBOL(total_swap_pages);
+EXPORT_SYMBOL(sysctl_overcommit_ratio);
+EXPORT_SYMBOL(hugetlb_total_pages);
+
diff -Nupr a/kerrighed/sched.c b/kerrighed/sched.c
--- a/kerrighed/sched.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/sched.c	2007-03-28 16:25:38.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ *  Kerrighed/kernel/kerrighed/sched.c
+ *
+ *  Copyright (C) 2007 Louis Rilling - Kerlabs
+ */
+
+#include <linux/module.h>
+
+/* Kerrighed hooks */
+
+struct task_struct;
+
+void (*kh_calc_load)(unsigned long ticks);
+/* Hook in the add_to_runqueue function of the kernel scheduler */
+void (*kh_process_on)(struct task_struct *tsk);
+/* Hook in the del_from_runqueue function of the kernel scheduler */
+void (*kh_process_off)(struct task_struct *tsk);
+
+EXPORT_SYMBOL(kh_calc_load);
+EXPORT_SYMBOL(kh_process_on);
+EXPORT_SYMBOL(kh_process_off);
diff -Nupr a/kerrighed/unique_id.c b/kerrighed/unique_id.c
--- a/kerrighed/unique_id.c	1970-01-01 01:00:00.000000000 +0100
+++ b/kerrighed/unique_id.c	2007-03-27 16:24:19.000000000 +0200
@@ -0,0 +1,91 @@
+/** Unique id generator
+ *  @file unique_id.c
+ *
+ *  Implementation of unique id generator. This mechanism generates
+ *  locally, an indentifier which is unique in the cluster.
+ *
+ *  Copyright (C) 2006-2007, Renaud Lottiaux, Kerlabs.
+ */
+
+#include <linux/hardirq.h>
+#include <linux/module.h>
+#include <kerrighed/unique_id.h>
+#include <kerrighed/krginit.h>
+#include <kerrighed/kernel_headers.h>
+
+unique_id_root_t mm_unique_id_root = {
+	.local_unique_id = ATOMIC_INIT(0),
+};
+
+/** Initialize a unique id root.
+ *  @author Renaud Lottiaux
+ *
+ *  @param root   The root to initialize
+ *  @return       0 if everything ok.
+ *                Negative value otherwise.
+ */
+int init_unique_id_root(unique_id_root_t *root)
+{
+	/* Value 0 is reserved for UNIQUE_ID_NONE */
+
+	atomic_set (&root->local_unique_id, 1);
+
+	return 0;
+}
+EXPORT_SYMBOL(init_unique_id_root);
+
+
+
+/** Initialize a unique id root with a given init value.
+ *  @author Renaud Lottiaux
+ *
+ *  @param root   The root to initialize
+ *  @param base   Init of value for the key generator.
+ *  @return       0 if everything ok.
+ *                Negative value otherwise.
+ */
+int init_and_set_unique_id_root(unique_id_root_t *root, int base)
+{
+	atomic_set (&root->local_unique_id, base + 1);
+
+	return 0;
+}
+EXPORT_SYMBOL(init_and_set_unique_id_root);
+
+
+
+/** Generate a unique id from a given root.
+ *  @author Renaud Lottiaux
+ *
+ *  @param root   The root of the unique id to generate.
+ *  @return       A unique id !
+ */
+unique_id_t get_unique_id(unique_id_root_t *root)
+{
+	unique_id_t unique_id ;
+
+	/* If the unique ID root has not been initialized... */
+	if (atomic_read(&root->local_unique_id) == 0)
+		return UNIQUE_ID_NONE;
+
+	unique_id = atomic_inc_return (&root->local_unique_id);
+
+	/* Check if there is a loop in the identitier generator */
+
+	if ((unique_id & 0xFFFFFF) == 0)
+		panic ("Unique id generator loop !\n");
+
+	/* Combine local unique id and local node id to generate a
+	   identifier which is unique cluster wide */
+
+	unique_id = unique_id | (kerrighed_node_id << UNIQUE_ID_NODE_SHIFT);
+
+	return unique_id;
+}
+EXPORT_SYMBOL(get_unique_id);
+
+
+void init_unique_ids(void)
+{
+	init_unique_id_root(&mm_unique_id_root);
+}
diff -Nupr a/Makefile b/Makefile
--- a/Makefile	2007-06-05 17:06:30.000000000 +0200
+++ b/Makefile	2007-05-02 15:30:54.000000000 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 20
-EXTRAVERSION =
+EXTRAVERSION = -krg
 NAME = Homicidal Dwarf Hamster
 
 # *DOCUMENTATION*
@@ -435,6 +435,7 @@ drivers-y	:= drivers/ sound/
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
+kerrighed-y	:= kerrighed/
 endif # KBUILD_EXTMOD
 
 ifeq ($(dot-config),1)
@@ -558,10 +559,10 @@ core-$(CONFIG_KDB) += kdb/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
-		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
+		     $(net-y) $(net-m) $(libs-y) $(libs-m) $(kerrighed-y)))
 
 vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
-		     $(init-n) $(init-) \
+		     $(init-n) $(init-) $(kerrighed-n) $(kerrighed-) \
 		     $(core-n) $(core-) $(drivers-n) $(drivers-) \
 		     $(net-n)  $(net-)  $(libs-n)    $(libs-))))
 
@@ -569,6 +570,7 @@ init-y		:= $(patsubst %/, %/built-in.o, 
 core-y		:= $(patsubst %/, %/built-in.o, $(core-y))
 drivers-y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
 net-y		:= $(patsubst %/, %/built-in.o, $(net-y))
+kerrighed-y	:= $(patsubst %/, %/built-in.o, $(kerrighed-y))
 libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
 libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
 libs-y		:= $(libs-y1) $(libs-y2)
@@ -601,7 +603,7 @@ libs-y		:= $(libs-y1) $(libs-y2)
 # System.map is generated to document addresses of all kernel symbols
 
 vmlinux-init := $(head-y) $(init-y)
-vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)
+vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y) $(kerrighed-y)
 vmlinux-all  := $(vmlinux-init) $(vmlinux-main)
 vmlinux-lds  := arch/$(ARCH)/kernel/vmlinux.lds
 
@@ -957,7 +959,6 @@ modules: $(vmlinux-dirs) $(if $(KBUILD_B
 	@echo '  Building modules, stage 2.';
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
 
-
 # Target to prepare building external modules
 PHONY += modules_prepare
 modules_prepare: prepare scripts
@@ -1202,6 +1203,12 @@ modules: $(module-dirs)
 	@echo '  Building modules, stage 2.';
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
 
+krgmodules1: $(module-dirs)
+
+krgmodules2:
+	@echo '  Building modules, stage 2.';
+	$(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modpost
+
 PHONY += modules_install
 modules_install: _emodinst_ _emodinst_post
 
diff -Nupr a/mm/memory.c b/mm/memory.c
--- a/mm/memory.c	2007-02-04 19:44:54.000000000 +0100
+++ b/mm/memory.c	2007-04-26 18:59:09.000000000 +0200
@@ -1505,6 +1505,9 @@ static int do_wp_page(struct mm_struct *
 	 * not dirty accountable.
 	 */
 	if (PageAnon(old_page)) {
+#ifdef CONFIG_KRG_MM
+		if (!(vma->vm_flags & VM_CONTAINER))
+#endif
 		if (!TestSetPageLocked(old_page)) {
 			reuse = can_share_swap_page(old_page);
 			unlock_page(old_page);
@@ -1569,6 +1572,24 @@ gotten:
 
 	if (unlikely(anon_vma_prepare(vma)))
 		goto oom;
+
+#ifdef CONFIG_KRG_MM
+        if (vma->vm_ops && vma->vm_ops->wppage) {
+		if (old_page)
+			page_cache_get(old_page);
+		
+		new_page = vma->vm_ops->wppage(vma, address & PAGE_MASK);
+		
+		if (!new_page) {
+			page_cache_release(old_page);
+			goto oom ;
+		}
+
+		page_cache_get(new_page);
+		goto install_page;
+        }
+#endif // CONFIG_KRG_MM
+
 	if (old_page == ZERO_PAGE(address)) {
 		new_page = alloc_zeroed_user_highpage(vma, address);
 		if (!new_page)
@@ -1583,6 +1604,9 @@ gotten:
 	/*
 	 * Re-check the pte - we dropped the lock
 	 */
+#ifdef CONFIG_KRG_MM
+install_page:
+#endif // CONFIG_KRG_MM
 	page_table = pte_offset_map_lock(mm, pmd, address, &ptl);
 	if (likely(pte_same(*page_table, orig_pte))) {
 		if (old_page) {
@@ -1606,6 +1630,11 @@ gotten:
 		ptep_clear_flush(vma, address, page_table);
 		set_pte_at(mm, address, page_table, entry);
 		update_mmu_cache(vma, address, entry);
+#ifdef CONFIG_KRG_MM
+		if (!PageLRU(new_page) &&
+		    ((old_page == NULL) ||
+		     (old_page && (new_page != old_page))))
+#endif
 		lru_cache_add_active(new_page);
 		page_add_new_anon_rmap(new_page, vma, address);
 
@@ -2171,6 +2200,9 @@ static int do_no_page(struct mm_struct *
 		smp_rmb(); /* serializes i_size against truncate_count */
 	}
 retry:
+#ifdef CONFIG_KRG_MM
+	vma->last_fault = write_access;
+#endif // CONFIG_KRG_MM
 	new_page = vma->vm_ops->nopage(vma, address & PAGE_MASK, &ret);
 	/*
 	 * No smp_rmb is needed here as long as there's a full
@@ -2191,7 +2223,16 @@ retry:
 	/*
 	 * Should we do an early C-O-W break?
 	 */
+#ifdef CONFIG_KRG_MM
+	if (new_page->mapping == NULL) {
+		if (unlikely(anon_vma_prepare(vma)))
+			goto oom;
+		anon = 1;
+	}
+	if (write_access && !(vma->vm_flags & VM_CONTAINER)) {
+#else
 	if (write_access) {
+#endif
 		if (!(vma->vm_flags & VM_SHARED)) {
 			struct page *page;
 
@@ -2247,11 +2288,22 @@ retry:
 	if (pte_none(*page_table)) {
 		flush_icache_page(vma, new_page);
 		entry = mk_pte(new_page, vma->vm_page_prot);
+#ifdef CONFIG_KRG_MM
 		if (write_access)
 			entry = maybe_mkwrite(pte_mkdirty(entry), vma);
+		else
+			if (vma->vm_flags & VM_CONTAINER)
+				entry = pte_wrprotect(entry);
+#else
+		if (write_access)
+			entry = maybe_mkwrite(pte_mkdirty(entry), vma);
+#endif
 		set_pte_at(mm, address, page_table, entry);
 		if (anon) {
 			inc_mm_counter(mm, anon_rss);
+#ifdef CONFIG_KRG_MM
+			if (!PageLRU(new_page))
+#endif
 			lru_cache_add_active(new_page);
 			page_add_new_anon_rmap(new_page, vma, address);
 		} else {
diff -Nupr a/mm/rmap.c b/mm/rmap.c
--- a/mm/rmap.c	2007-02-04 19:44:54.000000000 +0100
+++ b/mm/rmap.c	2007-03-01 17:58:36.000000000 +0100
@@ -626,6 +626,35 @@ static int try_to_unmap_one(struct page 
 	if (!pte)
 		goto out;
 
+#ifdef CONFIG_KRG_MM
+	if (PageToInvalidate(page)) {
+		if ((vma->vm_flags & (VM_LOCKED|VM_RESERVED))) {
+			ret = SWAP_FAIL;
+			goto out_unmap;
+		}
+		
+		/* Nuke the page table entry. */
+		flush_cache_page(vma, address, page_to_pfn(page));
+		pteval = ptep_clear_flush(vma, address, pte);
+		update_hiwater_rss(mm);
+		
+		if (PageAnon(page))
+			dec_mm_counter(mm, anon_rss);
+		else
+			dec_mm_counter(mm, file_rss);
+
+		page_remove_rmap(page, vma);
+		page_cache_release(page);
+	}
+	
+	if (PageToSetReadOnly(page)) {
+		ptep_set_wrprotect(mm, address, pte);
+		flush_tlb_page(vma, address);
+	}
+
+	goto out_unmap;
+#endif // CONFIG_KRG_MM
+
 	/*
 	 * If the page is mlock()d, we cannot swap it out.
 	 * If it's recently referenced (perhaps page_referenced
diff -Nupr a/mm/shmem.c b/mm/shmem.c
--- a/mm/shmem.c	2007-02-04 19:44:54.000000000 +0100
+++ b/mm/shmem.c	2007-03-01 17:58:36.000000000 +0100
@@ -181,7 +181,10 @@ static const struct file_operations shme
 static struct inode_operations shmem_inode_operations;
 static struct inode_operations shmem_dir_inode_operations;
 static struct inode_operations shmem_special_inode_operations;
-static struct vm_operations_struct shmem_vm_ops;
+#ifndef CONFIG_KRG_MM
+static
+#endif
+struct vm_operations_struct shmem_vm_ops;
 
 static struct backing_dev_info shmem_backing_dev_info  __read_mostly = {
 	.ra_pages	= 0,	/* No readahead */
@@ -2394,7 +2397,10 @@ static struct super_operations shmem_ops
 	.put_super	= shmem_put_super,
 };
 
-static struct vm_operations_struct shmem_vm_ops = {
+#ifndef CONFIG_KRG_MM
+static
+#endif
+struct vm_operations_struct shmem_vm_ops = {
 	.nopage		= shmem_nopage,
 	.populate	= shmem_populate,
 #ifdef CONFIG_NUMA
diff -Nupr a/mm/swap.c b/mm/swap.c
--- a/mm/swap.c	2007-02-04 19:44:54.000000000 +0100
+++ b/mm/swap.c	2007-04-26 16:55:16.000000000 +0200
@@ -272,6 +272,9 @@ void release_pages(struct page **pages, 
 			continue;
 		}
 
+#ifdef CONFIG_DEBUG_PAGEALLOC
+		ClearPageInVec(page);
+#endif
 		if (!put_page_testzero(page))
 			continue;
 
@@ -364,6 +367,9 @@ void __pagevec_lru_add(struct pagevec *p
 			spin_lock_irq(&zone->lru_lock);
 		}
 		VM_BUG_ON(PageLRU(page));
+#ifdef CONFIG_DEBUG_PAGEALLOC
+		ClearPageInVec(page);
+#endif
 		SetPageLRU(page);
 		add_page_to_inactive_list(zone, page);
 	}
@@ -391,6 +397,9 @@ void __pagevec_lru_add_active(struct pag
 			spin_lock_irq(&zone->lru_lock);
 		}
 		VM_BUG_ON(PageLRU(page));
+#ifdef CONFIG_DEBUG_PAGEALLOC
+		ClearPageInVec(page);
+#endif
 		SetPageLRU(page);
 		VM_BUG_ON(PageActive(page));
 		SetPageActive(page);
diff -Nupr a/net/ipv4/ipconfig.c b/net/ipv4/ipconfig.c
--- a/net/ipv4/ipconfig.c	2007-02-04 19:44:54.000000000 +0100
+++ b/net/ipv4/ipconfig.c	2007-05-04 17:38:13.000000000 +0200
@@ -60,6 +60,11 @@
 #include <net/ipconfig.h>
 #include <net/route.h>
 
+#ifdef CONFIG_KRG_AUTONODEID
+#include <kerrighed/krginit.h>
+#include <kerrighed/hotplug.h>
+#endif
+
 #include <asm/uaccess.h>
 #include <net/checksum.h>
 #include <asm/processor.h>
@@ -1359,6 +1364,14 @@ static int __init ip_auto_config(void)
 	ic_proto_used = ic_got_reply | (ic_proto_enabled & IC_USE_DHCP);
 #endif
 
+#ifdef CONFIG_KRG_AUTONODEID
+	kerrighed_node_id = ((unsigned char *)&ic_myaddr)[3];
+	universe[kerrighed_node_id].state = 1;
+	SET_KRG_INIT_FLAGS(KRG_INITFLAGS_NODEID);
+	printk("Automatic setting of kerrighed_node_id: %d\n",
+	       kerrighed_node_id);
+#endif
+	
 #ifndef IPCONFIG_SILENT
 	/*
 	 * Clue in the operator.
diff -Nupr a/net/socket.c b/net/socket.c
--- a/net/socket.c	2007-02-04 19:44:54.000000000 +0100
+++ b/net/socket.c	2007-05-23 12:42:37.000000000 +0200
@@ -93,6 +93,14 @@
 #include <net/sock.h>
 #include <linux/netfilter.h>
 
+#ifdef CONFIG_KRG_TOOLS
+#include <kerrighed/types.h>
+#endif
+
+#ifdef CONFIG_KRG_FAF
+#include <kerrighed/kernel_headers.h>
+#endif
+
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
 			 unsigned long nr_segs, loff_t pos);
@@ -1947,6 +1955,9 @@ asmlinkage long sys_socketcall(int call,
 	unsigned long a[6];
 	unsigned long a0, a1;
 	int err;
+#ifdef CONFIG_KRG_FAF
+	struct file * file = NULL;
+#endif
 
 	if (call < 1 || call > SYS_RECVMSG)
 		return -EINVAL;
@@ -1962,30 +1973,69 @@ asmlinkage long sys_socketcall(int call,
 	a0 = a[0];
 	a1 = a[1];
 
+#ifdef CONFIG_KRG_FAF
+	if( (call != SYS_SOCKET)
+	    && (call != SYS_SOCKETPAIR)){
+		file = fget(a0);
+		if(!file)
+			return -EBADF;
+	};
+#endif
+
 	switch (call) {
 	case SYS_SOCKET:
 		err = sys_socket(a0, a1, a[2]);
 		break;
 	case SYS_BIND:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_bind(file,(struct sockaddr __user *)a1, a[2]);
+		}else
+#endif
 		err = sys_bind(a0, (struct sockaddr __user *)a1, a[2]);
 		break;
 	case SYS_CONNECT:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_connect(file, (struct sockaddr __user *)a1, a[2]);
+		} else
+#endif
 		err = sys_connect(a0, (struct sockaddr __user *)a1, a[2]);
 		break;
 	case SYS_LISTEN:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_listen(file,a1);
+		} else
+#endif
 		err = sys_listen(a0, a1);
 		break;
 	case SYS_ACCEPT:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_accept(file,(struct sockaddr __user *)a1, (int __user *)a[2]);
+		} else
+#endif
 		err =
 		    sys_accept(a0, (struct sockaddr __user *)a1,
 			       (int __user *)a[2]);
 		break;
 	case SYS_GETSOCKNAME:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_getsockname(file,(struct sockaddr __user *)a1, (int __user *)a[2]);
+		} else
+#endif
 		err =
 		    sys_getsockname(a0, (struct sockaddr __user *)a1,
 				    (int __user *)a[2]);
 		break;
 	case SYS_GETPEERNAME:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_getpeername(file, (struct sockaddr __user *)a1, (int __user *)a[2]);
+		} else
+#endif
 		err =
 		    sys_getpeername(a0, (struct sockaddr __user *)a1,
 				    (int __user *)a[2]);
@@ -1994,41 +2044,94 @@ asmlinkage long sys_socketcall(int call,
 		err = sys_socketpair(a0, a1, a[2], (int __user *)a[3]);
 		break;
 	case SYS_SEND:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_send(file, (void __user *)a1, a[2], a[3]);
+		} else
+#endif
 		err = sys_send(a0, (void __user *)a1, a[2], a[3]);
 		break;
 	case SYS_SENDTO:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_sendto(file,(void __user *)a1, a[2], a[3],
+					    (struct sockaddr __user *)a[4], a[5]);
+		} else
+#endif
 		err = sys_sendto(a0, (void __user *)a1, a[2], a[3],
 				 (struct sockaddr __user *)a[4], a[5]);
 		break;
 	case SYS_RECV:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_recv(file, (void __user *)a1, a[2], a[3]);
+		} else
+#endif
 		err = sys_recv(a0, (void __user *)a1, a[2], a[3]);
 		break;
 	case SYS_RECVFROM:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_recvfrom(file, (void __user *)a1, a[2], a[3],
+					      (struct sockaddr __user *)a[4], (int __user *)a[5]);
+		} else
+#endif
 		err = sys_recvfrom(a0, (void __user *)a1, a[2], a[3],
 				   (struct sockaddr __user *)a[4],
 				   (int __user *)a[5]);
 		break;
 	case SYS_SHUTDOWN:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_shutdown(file,a1);
+		}else
+#endif
 		err = sys_shutdown(a0, a1);
 		break;
 	case SYS_SETSOCKOPT:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_setsockopt(file, a1, a[2], (char __user *)a[3], a[4]);
+		}else
+#endif
 		err = sys_setsockopt(a0, a1, a[2], (char __user *)a[3], a[4]);
 		break;
 	case SYS_GETSOCKOPT:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_getsockopt(file, a1, a[2], (char __user *)a[3], (int __user *)a[4]);
+		}else
+#endif
 		err =
 		    sys_getsockopt(a0, a1, a[2], (char __user *)a[3],
 				   (int __user *)a[4]);
 		break;
 	case SYS_SENDMSG:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_sendmsg(file, (struct msghdr __user *) a1, a[2]);
+		}else
+#endif
 		err = sys_sendmsg(a0, (struct msghdr __user *)a1, a[2]);
 		break;
 	case SYS_RECVMSG:
+#ifdef CONFIG_KRG_FAF
+		if (file->f_flags & O_FAF_CLT){
+			err = kh_faf_recvmsg(file, (struct msghdr __user *) a1, a[2]);
+		}else
+#endif
 		err = sys_recvmsg(a0, (struct msghdr __user *)a1, a[2]);
 		break;
 	default:
 		err = -EINVAL;
 		break;
 	}
+
+#ifdef CONFIG_KRG_FAF
+	if(file)
+		fput(file);
+#endif
+	
 	return err;
 }
 
diff -Nupr a/net/tipc/config.c b/net/tipc/config.c
--- a/net/tipc/config.c	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/config.c	2007-05-02 14:51:20.000000000 +0200
@@ -258,6 +258,7 @@ static struct sk_buff *cfg_enable_bearer
 		return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
 
 	args = (struct tipc_bearer_config *)TLV_DATA(req_tlv_area);
+	printk("%s %x %x\n", args->name, ntohl(args->detect_scope), ntohl(args->priority));
 	if (tipc_enable_bearer(args->name,
 			       ntohl(args->detect_scope),
 			       ntohl(args->priority)))
@@ -451,6 +452,7 @@ static struct sk_buff *cfg_set_netid(voi
 	if (tipc_mode == TIPC_NET_MODE)
 		return tipc_cfg_reply_error_string(TIPC_CFG_NOT_SUPPORTED
 			" (cannot change network id once TIPC has joined a network)");
+	printk("cfg_set_netid: %d\n", value);
 	tipc_net_id = value;
 	return tipc_cfg_reply_none();
 }
diff -Nupr a/net/tipc/core.c b/net/tipc/core.c
--- a/net/tipc/core.c	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/core.c	2007-05-02 14:51:20.000000000 +0200
@@ -105,6 +105,10 @@ int tipc_max_publications;
 int tipc_net_id;
 int tipc_remote_management;
 
+#ifdef CONFIG_KRG_COMMUNICATION_FRAMEWORK
+EXPORT_SYMBOL(tipc_own_addr);
+EXPORT_SYMBOL(tipc_net_id);
+#endif
 
 int tipc_get_mode(void)
 {
@@ -135,6 +139,9 @@ int tipc_core_start_net(void)
 	}
 	return res;
 }
+#ifdef CONFIG_KRG_COMMUNICATION_FRAMEWORK
+EXPORT_SYMBOL(tipc_core_start_net);
+#endif
 
 /**
  * tipc_core_stop - switch TIPC from SINGLE NODE to NOT RUNNING mode
diff -Nupr a/net/tipc/core.h b/net/tipc/core.h
--- a/net/tipc/core.h	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/core.h	2007-05-02 14:51:20.000000000 +0200
@@ -58,6 +58,8 @@
 #include <linux/list.h>
 #include <linux/vmalloc.h>
 
+#define HACK_PASCAL
+
 /*
  * TIPC debugging code
  */
diff -Nupr a/net/tipc/link.c b/net/tipc/link.c
--- a/net/tipc/link.c	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/link.c	2007-05-03 12:08:03.000000000 +0200
@@ -49,7 +49,6 @@
 #include "config.h"
 #include "bcast.h"
 
-
 /* 
  * Limit for deferred reception queue: 
  */
@@ -1254,14 +1253,22 @@ int tipc_link_send_sections_fast(struct 
 	int res;
 	u32 selector = msg_origport(hdr) & 1;
 
+	BUG_ON(sender->user_port);
+
 again:
 	/*
 	 * Try building message using port's max_pkt hint.
 	 * (Must not hold any locks while building message.)
 	 */
 
+#ifndef HACK_PASCAL
+	// original version
 	res = msg_build(hdr, msg_sect, num_sect, sender->max_pkt,
 			!sender->user_port, &buf);
+#else
+	res = msg_build(hdr, msg_sect, num_sect, sender->max_pkt,
+			(int)sender->user_port, &buf);
+#endif
 
 	read_lock_bh(&tipc_net_lock);
 	node = tipc_node_select(destaddr, selector);
@@ -1406,7 +1413,13 @@ again:
 		else
 			sz = fragm_rest;
 
+#ifndef HACK_PASCAL
+		// orginal version
 		if (likely(!sender->user_port)) {
+#else
+		if (unlikely(sender->user_port)) {	
+#endif
+			printk("link_send_sections_long: copy_from_user\n"); BUG();
 			if (copy_from_user(buf->data + fragm_crs, sect_crs, sz)) {
 error:
 				for (; buf_chain; buf_chain = buf) {
diff -Nupr a/net/tipc/msg.h b/net/tipc/msg.h
--- a/net/tipc/msg.h	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/msg.h	2007-05-02 14:51:20.000000000 +0200
@@ -788,11 +788,12 @@ static inline int msg_build(struct tipc_
 		return -ENOMEM;
 	memcpy((*buf)->data, (unchar *)hdr, hsz);
 	for (res = 1, cnt = 0; res && (cnt < num_sect); cnt++) {
-		if (likely(usrmem))
+		if (likely(usrmem)){
+			printk("%d msg_build: try to copy_from_user\n", current->pid); BUG();
 			res = !copy_from_user((*buf)->data + pos, 
 					      msg_sect[cnt].iov_base, 
 					      msg_sect[cnt].iov_len);
-		else
+		}else
 			memcpy((*buf)->data + pos, msg_sect[cnt].iov_base, 
 			       msg_sect[cnt].iov_len);
 		pos += msg_sect[cnt].iov_len;
diff -Nupr a/net/tipc/net.c b/net/tipc/net.c
--- a/net/tipc/net.c	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/net.c	2007-05-02 14:51:20.000000000 +0200
@@ -188,6 +188,8 @@ static void net_route_named_msg(struct s
 	u32 dnode;
 	u32 dport;
 
+	printk("net_route_named_msg\n");
+	
 	if (!msg_named(msg)) {
 		msg_dbg(msg, "tipc_net->drop_nam:");
 		buf_discard(buf);
diff -Nupr a/net/tipc/node.c b/net/tipc/node.c
--- a/net/tipc/node.c	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/node.c	2007-05-04 17:38:13.000000000 +0200
@@ -34,6 +34,9 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include <kerrighed/sys/types.h>
+#include <kerrighed/hotplug.h>
+
 #include "core.h"
 #include "config.h"
 #include "node.h"
@@ -133,21 +136,38 @@ void tipc_node_link_up(struct node *n_pt
 		dbg(" link %x into %x/%x\n", l_ptr, &active[0], &active[1]);
 		active[0] = active[1] = l_ptr;
 		node_established_contact(n_ptr);
+#ifdef CONFIG_KRG_HOTPLUG
+		goto exit;
+#endif
 		return;
 	}
 	if (l_ptr->priority < active[0]->priority) { 
 		info("New link <%s> becomes standby\n", l_ptr->name);
+#ifdef CONFIG_KRG_HOTPLUG
+		goto exit;
+#endif
 		return;
 	}
 	tipc_link_send_duplicate(active[0], l_ptr);
 	if (l_ptr->priority == active[0]->priority) { 
 		active[0] = l_ptr;
+#ifdef CONFIG_KRG_HOTPLUG
+		goto exit;
+#endif
 		return;
 	}
 	info("Old link <%s> becomes standby\n", active[0]->name);
 	if (active[1] != active[0])
 		info("Old link <%s> becomes standby\n", active[1]->name);
 	active[0] = active[1] = l_ptr;
+
+#ifdef CONFIG_KRG_HOTPLUG
+ exit:
+	if(n_ptr->working_links>1)
+		return;
+
+	krg_node_arrival(tipc_node(n_ptr->addr)-1);
+#endif
 }
 
 /**
diff -Nupr a/net/tipc/port.c b/net/tipc/port.c
--- a/net/tipc/port.c	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/port.c	2007-05-03 12:08:03.000000000 +0200
@@ -117,8 +117,13 @@ int tipc_multicast(u32 ref, struct tipc_
 	msg_set_namelower(hdr, seq->lower);
 	msg_set_nameupper(hdr, seq->upper);
 	msg_set_hdr_sz(hdr, MCAST_H_SIZE);
+#ifndef HACK_PASCAL
 	res = msg_build(hdr, msg_sect, num_sect, MAX_MSG_SIZE,
 			!oport->user_port, &buf);
+#else
+	res = msg_build(hdr, msg_sect, num_sect, MAX_MSG_SIZE,
+			(int)oport->user_port, &buf);
+#endif
 	if (unlikely(!buf))
 		return res;
 
@@ -492,8 +497,13 @@ int tipc_port_reject_sections(struct por
 	struct sk_buff *buf;
 	int res;
 
+#ifndef HACK_PASCAL
 	res = msg_build(hdr, msg_sect, num_sect, MAX_MSG_SIZE, 
 			!p_ptr->user_port, &buf);
+#else
+	res = msg_build(hdr, msg_sect, num_sect, MAX_MSG_SIZE,
+			(int)p_ptr->user_port, &buf);
+#endif
 	if (!buf)
 		return res;
 
@@ -1348,9 +1358,14 @@ int tipc_port_recv_sections(struct port 
 {
 	struct sk_buff *buf;
 	int res;
-	 
+
+#ifndef HACK_PASCAL
 	res = msg_build(&sender->publ.phdr, msg_sect, num_sect,
 			MAX_MSG_SIZE, !sender->user_port, &buf);
+#else
+	res = msg_build(&sender->publ.phdr, msg_sect, num_sect,
+			MAX_MSG_SIZE, (int)sender->user_port, &buf);
+#endif
 	if (likely(buf))
 		tipc_port_recv_msg(buf);
 	return res;
@@ -1462,6 +1477,7 @@ int tipc_forward2name(u32 ref, 
 	int res;
 
 	p_ptr = tipc_port_deref(ref);
+	BUG_ON(p_ptr->user_port);
 	if (!p_ptr || p_ptr->publ.connected)
 		return -EINVAL;
 
@@ -1479,10 +1495,12 @@ int tipc_forward2name(u32 ref, 
 	msg_set_destnode(msg, destnode);
 	msg_set_destport(msg, destport);
 
+	BUG_ON(p_ptr->user_port);
 	if (likely(destport || destnode)) {
 		p_ptr->sent++;
 		if (likely(destnode == tipc_own_addr))
 			return tipc_port_recv_sections(p_ptr, num_sect, msg_sect);
+		BUG_ON(p_ptr->user_port);
 		res = tipc_link_send_sections_fast(p_ptr, msg_sect, num_sect, 
 						   destnode);
 		if (likely(res != -ELINKCONG))
diff -Nupr a/net/tipc/port.h b/net/tipc/port.h
--- a/net/tipc/port.h	2007-02-04 19:44:54.000000000 +0100
+++ b/net/tipc/port.h	2007-05-02 14:51:20.000000000 +0200
@@ -175,7 +175,7 @@ static inline int tipc_port_recv_msg(str
 	u32 destport = msg_destport(msg);
 	u32 dsz = msg_data_sz(msg);
 	u32 err;
-	
+
 	/* forward unresolved named message */
 	if (unlikely(!destport)) {
 		tipc_net_route_msg(buf);
diff -Nupr a/scripts/package/builddeb b/scripts/package/builddeb
--- a/scripts/package/builddeb	2007-02-04 19:44:54.000000000 +0100
+++ b/scripts/package/builddeb	2007-02-26 18:51:03.000000000 +0100
@@ -62,10 +62,10 @@ EOF
 	chmod 755 "$tmpdir/DEBIAN/$script"
 done
 
-name="Kernel Compiler <$(id -nu)@$(hostname -f)>"
+name="$DEBFULLNAME <$DEBEMAIL>"
 # Generate a simple changelog template
 cat <<EOF > debian/changelog
-linux ($version) unstable; urgency=low
+kerrighed-kernel ($version) unstable; urgency=low
 
   * A standard release
 
@@ -97,16 +97,16 @@ EOF
 
 else
 cat <<EOF > debian/control
-Source: linux
+Source: kerrighed-kernel
 Section: base
 Priority: optional
 Maintainer: $name
 Standards-Version: 3.6.1
 
-Package: $packagename
+Package: kerrighed-kernel-$version
 Architecture: any
-Description: Linux kernel, version $version
- This package contains the Linux kernel, modules and corresponding other
+Description: Kerrighed kernel, version $version
+ This package contains the Kerrighed kernel, modules and corresponding other
  files version $version
 EOF
 fi
diff -Nupr a/scripts/package/Makefile b/scripts/package/Makefile
--- a/scripts/package/Makefile	2007-02-04 19:44:54.000000000 +0100
+++ b/scripts/package/Makefile	2007-02-26 18:51:03.000000000 +0100
@@ -8,8 +8,8 @@ TAR_IGNORE := --exclude SCCS --exclude B
 # RPM target
 # ---------------------------------------------------------------------------
 # The rpm target generates two rpm files:
-# /usr/src/packages/SRPMS/kernel-2.6.7rc2-1.src.rpm
-# /usr/src/packages/RPMS/i386/kernel-2.6.7rc2-1.<arch>.rpm
+# /usr/src/packages/SRPMS/kerrighed-kernel-2.6.7rc2-1.src.rpm
+# /usr/src/packages/RPMS/i386/kerrighed-kernel-2.6.7rc2-1.<arch>.rpm
 # The src.rpm files includes all source for the kernel being built
 # The <arch>.rpm includes kernel configuration, modules etc.
 #
@@ -27,7 +27,7 @@ RPM := $(shell if [ -x "/usr/bin/rpmbuil
 	           else echo rpm; fi)
 
 # Remove hyphens since they have special meaning in RPM filenames
-KERNELPATH := kernel-$(subst -,,$(KERNELRELEASE))
+KERNELPATH := kerrighed-kernel-$(subst -,,$(KERNELRELEASE))
 MKSPEC     := $(srctree)/scripts/package/mkspec
 PREV       := set -e; cd ..;
 
@@ -47,7 +47,7 @@ rpm-pkg rpm: $(objtree)/kernel.spec FORC
 	set -e; \
 	mv -f $(objtree)/.tmp_version $(objtree)/.version
 
-	$(RPM) --target $(UTS_MACHINE) -ta ../$(KERNELPATH).tar.gz
+	$(RPM) --target $(UTS_MACHINE) -ta ../$(KERNELPATH).tar.gz --buildroot $(objtree)/tmp
 	rm ../$(KERNELPATH).tar.gz
 
 clean-files := $(objtree)/kernel.spec
diff -Nupr a/scripts/package/mkspec b/scripts/package/mkspec
--- a/scripts/package/mkspec	2007-02-04 19:44:54.000000000 +0100
+++ b/scripts/package/mkspec	2007-02-26 18:51:03.000000000 +0100
@@ -21,22 +21,22 @@ if [ "`grep CONFIG_DRM=y .config | cut -
 	PROVIDES=kernel-drm
 fi
 
-PROVIDES="$PROVIDES kernel-$KERNELRELEASE"
+PROVIDES="$PROVIDES kerrighed-kernel-$KERNELRELEASE"
 __KERNELRELEASE=`echo $KERNELRELEASE | sed -e "s/-//g"`
 
-echo "Name: kernel"
-echo "Summary: The Linux Kernel"
+echo "Name: kerrighed-kernel"
+echo "Summary: The Kerrighed Kernel"
 echo "Version: $__KERNELRELEASE"
 # we need to determine the NEXT version number so that uname and
 # rpm -q will agree
 echo "Release: `. $srctree/scripts/mkversion`"
 echo "License: GPL"
 echo "Group: System Environment/Kernel"
-echo "Vendor: The Linux Community"
-echo "URL: http://www.kernel.org"
+echo "Vendor: The Kerrighed Project"
+echo "URL: http://kerrighed.org"
 
 if ! $PREBUILT; then
-echo "Source: kernel-$__KERNELRELEASE.tar.gz"
+echo "Source: kerrighed-kernel-$__KERNELRELEASE.tar.gz"
 fi
 
 echo "BuildRoot: /var/tmp/%{name}-%{PACKAGE_VERSION}-root"
@@ -45,7 +45,7 @@ echo "%define __spec_install_post /usr/l
 echo "%define debug_package %{nil}"
 echo ""
 echo "%description"
-echo "The Linux Kernel, the operating system core itself"
+echo "The Kerrighed Kernel, the operating system core itself"
 echo ""
 
 if ! $PREBUILT; then
diff -Nupr a/security/commoncap.c b/security/commoncap.c
--- a/security/commoncap.c	2007-02-04 19:44:54.000000000 +0100
+++ b/security/commoncap.c	2007-03-28 12:21:08.000000000 +0200
@@ -117,6 +117,14 @@ int cap_bprm_set_security (struct linux_
 	cap_clear (bprm->cap_inheritable);
 	cap_clear (bprm->cap_permitted);
 	cap_clear (bprm->cap_effective);
+#ifdef CONFIG_KRG_CAP
+	/* The model need changes with filesystem support ... */
+#if 0
+	cap_clear (bprm->krg_cap_forced);
+	cap_set_full (bprm->krg_cap_permitted);
+	cap_set_full (bprm-> krg_cap_effective);
+#endif /* 0 */
+#endif
 
 	/*  To support inheritance of root-permissions and suid-root
 	 *  executables under compatibility mode, we raise all three
@@ -178,6 +186,30 @@ void cap_bprm_apply_creds (struct linux_
 	/* AUD: Audit candidate if current->cap_effective is set */
 
 	current->keep_capabilities = 0;
+#ifdef CONFIG_KRG_CAP
+	/* The model need changes with filesystem support  ... */
+#if 0
+	{
+		//added by David Margery (c) Inria 2004
+		//Updated by Pascal Gallard (c) Inria 2005
+		kernel_cap_t new_krg_permitted, new_krg_effective;
+		new_krg_permitted =
+			cap_intersect (current->krg_cap_inheritable_permitted,
+				       bprm->krg_cap_permitted);
+		new_krg_permitted = cap_combine (new_krg_permitted,
+						 bprm->krg_cap_forced);
+
+		new_krg_effective = cap_intersect (bprm->krg_cap_effective,
+						   new_krg_permitted);
+		new_krg_effective =
+			cap_intersect (current->krg_cap_inheritable_effective,
+				       new_krg_effective);
+
+		current->krg_cap_permitted = new_krg_permitted;
+		current->krg_cap_effective = new_krg_effective;
+       }
+#endif /* 0 */
+#endif
 }
 
 int cap_bprm_secureexec (struct linux_binprm *bprm)
