diff -NurpP --minimal linux-2.6.20.15/Documentation/vserver/debug.txt linux-2.6.20.15-vs2.2.0.1/Documentation/vserver/debug.txt
--- linux-2.6.20.15/Documentation/vserver/debug.txt	1970-01-01 01:00:00 +0100
+++ linux-2.6.20.15-vs2.2.0.1/Documentation/vserver/debug.txt	2007-02-06 03:05:21 +0100
@@ -0,0 +1,154 @@
+
+debug_cvirt:
+
+ 2   4	"vx_map_tgid: %p/%llx: %d -> %d"
+	"vx_rmap_tgid: %p/%llx: %d -> %d"
+
+debug_dlim:
+
+ 0   1	"ALLOC (%p,#%d)%c inode (%d)"
+	"FREE  (%p,#%d)%c inode"
+ 1   2	"ALLOC (%p,#%d)%c %lld bytes (%d)"
+	"FREE  (%p,#%d)%c %lld bytes"
+ 2   4	"ADJUST: %lld,%lld on %ld,%ld [mult=%d]"
+ 3   8	"ext3_has_free_blocks(%p): %lu<%lu+1, %c, %u!=%u r=%d"
+	"ext3_has_free_blocks(%p): free=%lu, root=%lu"
+	"rcu_free_dl_info(%p)"
+ 4  10	"alloc_dl_info(%p,%d) = %p"
+	"dealloc_dl_info(%p)"
+	"get_dl_info(%p[#%d.%d])"
+	"put_dl_info(%p[#%d.%d])"
+ 5  20	"alloc_dl_info(%p,%d)*"
+ 6  40	"__hash_dl_info: %p[#%d]"
+	"__unhash_dl_info: %p[#%d]"
+ 7  80	"locate_dl_info(%p,#%d) = %p"
+
+debug_misc:
+
+ 0   1	"destroy_dqhash: %p [#0x%08x] c=%d"
+	"new_dqhash: %p [#0x%08x]"
+	"vroot[%d]_clr_dev: dev=%p[%lu,%d:%d]"
+	"vroot[%d]_get_real_bdev: dev=%p[%lu,%d:%d]"
+	"vroot[%d]_set_dev: dev=%p[%lu,%d:%d]"
+	"vroot_get_real_bdev not set"
+ 1   2	"cow_break_link(»%s«)"
+	"temp copy »%s«"
+ 2   4	"dentry_open(new): %p"
+	"dentry_open(old): %p"
+	"lookup_create(new): %p"
+	"old path »%s«"
+	"path_lookup(old): %d"
+	"vfs_create(new): %d"
+	"vfs_rename: %d"
+	"vfs_sendfile: %d"
+ 3   8	"fput(new_file=%p[#%d])"
+	"fput(old_file=%p[#%d])"
+ 4  10	"vx_info_kill(%p[#%d],%d,%d) = %d"
+	"vx_info_kill(%p[#%d],%d,%d)*"
+ 5  20	"vs_reboot(%p[#%d],%d)"
+ 6  40	"dropping task %p[#%u,%u] for %p[#%u,%u]"
+
+debug_net:
+
+ 2   4	"nx_addr_conflict(%p,%p) %d.%d,%d.%d"
+ 3   8	"inet_bind(%p) %d.%d.%d.%d, %d.%d.%d.%d, %d.%d.%d.%d"
+	"inet_bind(%p)* %p,%p;%lx %d.%d.%d.%d"
+ 4  10	"ip_route_connect(%p) %p,%p;%lx"
+ 5  20	"__addr_in_socket(%p,%d.%d.%d.%d) %p:%d.%d.%d.%d %p;%lx"
+ 6  40	"sk,egf: %p [#%d] (from %d)"
+	"sk,egn: %p [#%d] (from %d)"
+	"sk,req: %p [#%d] (from %d)"
+	"sk: %p [#%d] (from %d)"
+	"tw: %p [#%d] (from %d)"
+ 7  80	"__sock_recvmsg: %p[%p,%p,%p;%d]:%d/%d"
+	"__sock_sendmsg: %p[%p,%p,%p;%d]:%d/%d"
+
+debug_nid:
+
+ 0   1	"__lookup_nx_info(#%u): %p[#%u]"
+	"alloc_nx_info(%d) = %p"
+	"create_nx_info(%d) (dynamic rejected)"
+	"create_nx_info(%d) = %p (already there)"
+	"create_nx_info(%d) = %p (new)"
+	"dealloc_nx_info(%p)"
+ 1   2	"alloc_nx_info(%d)*"
+	"create_nx_info(%d)*"
+ 2   4	"get_nx_info(%p[#%d.%d])"
+	"put_nx_info(%p[#%d.%d])"
+ 3   8	"claim_nx_info(%p[#%d.%d.%d]) %p"
+	"clr_nx_info(%p[#%d.%d])"
+	"init_nx_info(%p[#%d.%d])"
+	"release_nx_info(%p[#%d.%d.%d]) %p"
+	"set_nx_info(%p[#%d.%d])"
+ 4  10	"__hash_nx_info: %p[#%d]"
+	"__nx_dynamic_id: [#%d]"
+	"__unhash_nx_info: %p[#%d.%d.%d]"
+ 5  20	"moved task %p into nxi:%p[#%d]"
+	"nx_migrate_task(%p,%p[#%d.%d.%d])"
+	"task_get_nx_info(%p)"
+ 6  40	"nx_clear_persistent(%p[#%d])"
+
+debug_quota:
+
+ 0   1	"quota_sync_dqh(%p,%d) discard inode %p"
+ 1   2	"quota_sync_dqh(%p,%d)"
+	"sync_dquots(%p,%d)"
+	"sync_dquots_dqh(%p,%d)"
+ 3   8	"do_quotactl(%p,%d,cmd=%d,id=%d,%p)"
+
+debug_switch:
+
+ 0   1	"vc: VCMD_%02d_%d[%d], %d,%p [%d,%d,%x,%x]"
+ 1   2	"vc: VCMD_%02d_%d[%d] = %08lx(%ld) [%d,%d]"
+ 4  10	"%s: (%s %s) returned %s with %d"
+
+debug_tag:
+
+ 7  80	"dx_parse_tag(»%s«): %d:#%d"
+	"dx_propagate_tag(%p[#%lu.%d]): %d,%d"
+
+debug_xid:
+
+ 0   1	"__lookup_vx_info(#%u): %p[#%u]"
+	"alloc_vx_info(%d) = %p"
+	"alloc_vx_info(%d)*"
+	"create_vx_info(%d) (dynamic rejected)"
+	"create_vx_info(%d) = %p (already there)"
+	"create_vx_info(%d) = %p (new)"
+	"dealloc_vx_info(%p)"
+	"loc_vx_info(%d) = %p (found)"
+	"loc_vx_info(%d) = %p (new)"
+	"loc_vx_info(%d) = %p (not available)"
+ 1   2	"create_vx_info(%d)*"
+	"loc_vx_info(%d)*"
+ 2   4	"get_vx_info(%p[#%d.%d])"
+	"put_vx_info(%p[#%d.%d])"
+ 3   8	"claim_vx_info(%p[#%d.%d.%d]) %p"
+	"clr_vx_info(%p[#%d.%d])"
+	"init_vx_info(%p[#%d.%d])"
+	"release_vx_info(%p[#%d.%d.%d]) %p"
+	"set_vx_info(%p[#%d.%d])"
+ 4  10	"__hash_vx_info: %p[#%d]"
+	"__unhash_vx_info: %p[#%d.%d.%d]"
+	"__vx_dynamic_id: [#%d]"
+ 5  20	"enter_vx_info(%p[#%d],%p) %p[#%d,%p]"
+	"leave_vx_info(%p[#%d,%p]) %p[#%d,%p]"
+	"moved task %p into vxi:%p[#%d]"
+	"task_get_vx_info(%p)"
+	"vx_migrate_task(%p,%p[#%d.%d])"
+ 6  40	"vx_clear_persistent(%p[#%d])"
+	"vx_exit_init(%p[#%d],%p[#%d,%d,%d])"
+	"vx_set_init(%p[#%d],%p[#%d,%d,%d])"
+	"vx_set_persistent(%p[#%d])"
+	"vx_set_reaper(%p[#%d],%p[#%d,%d])"
+ 7  80	"vx_child_reaper(%p[#%u,%u]) = %p[#%u,%u]"
+
+
+debug_limit:
+
+ n 2^n	"vx_acc_cres[%5d,%s,%2d]: %5d%s"
+	"vx_cres_avail[%5d,%s,%2d]: %5ld > %5d + %5d"
+
+ m 2^m	"vx_acc_page[%5d,%s,%2d]: %5d%s"
+	"vx_acc_pages[%5d,%s,%2d]: %5d += %5d"
+	"vx_pages_avail[%5d,%s,%2d]: %5ld > %5d + %5d"
diff -NurpP --minimal linux-2.6.20.15/Makefile linux-2.6.20.15-vs2.2.0.1/Makefile
--- linux-2.6.20.15/Makefile	2007-07-16 07:34:04 +0200
+++ linux-2.6.20.15-vs2.2.0.1/Makefile	2007-07-16 08:20:45 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 20
-EXTRAVERSION = .15
+EXTRAVERSION = .15-vs2.2.0.1
 NAME = Homicidal Dwarf Hamster
 
 # *DOCUMENTATION*
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/alpha/Kconfig
--- linux-2.6.20.15/arch/alpha/Kconfig	2007-02-06 02:59:58 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/Kconfig	2007-02-06 03:05:21 +0100
@@ -640,6 +640,8 @@ source "arch/alpha/oprofile/Kconfig"
 
 source "arch/alpha/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/kernel/asm-offsets.c linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/asm-offsets.c
--- linux-2.6.20.15/arch/alpha/kernel/asm-offsets.c	2006-02-15 13:54:10 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/asm-offsets.c	2007-02-06 03:05:21 +0100
@@ -36,6 +36,7 @@ void foo(void)
 	DEFINE(PT_PTRACED, PT_PTRACED);
 	DEFINE(CLONE_VM, CLONE_VM);
 	DEFINE(CLONE_UNTRACED, CLONE_UNTRACED);
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
 	DEFINE(SIGCHLD, SIGCHLD);
 	BLANK();
 
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/kernel/entry.S linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/entry.S
--- linux-2.6.20.15/arch/alpha/kernel/entry.S	2006-11-30 21:18:23 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/entry.S	2007-02-06 03:05:21 +0100
@@ -644,7 +644,7 @@ kernel_thread:
 	stq	$2, 152($sp)		/* HAE */
 
 	/* Shuffle FLAGS to the front; add CLONE_VM.  */
-	ldi	$1, CLONE_VM|CLONE_UNTRACED
+	ldi	$1, CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD;
 	or	$18, $1, $16
 	bsr	$26, sys_clone
 
@@ -873,24 +873,15 @@ sys_getxgid:
 	.globl	sys_getxpid
 	.ent	sys_getxpid
 sys_getxpid:
+	lda	$sp, -16($sp)
+	stq	$26, 0($sp)
 	.prologue 0
-	ldq	$2, TI_TASK($8)
 
-	/* See linux/kernel/timer.c sys_getppid for discussion
-	   about this loop.  */
-	ldq	$3, TASK_GROUP_LEADER($2)
-	ldq	$4, TASK_REAL_PARENT($3)
-	ldl	$0, TASK_TGID($2)
-1:	ldl	$1, TASK_TGID($4)
-#ifdef CONFIG_SMP
-	mov	$4, $5
-	mb
-	ldq	$3, TASK_GROUP_LEADER($2)
-	ldq	$4, TASK_REAL_PARENT($3)
-	cmpeq	$4, $5, $5
-	beq	$5, 1b
-#endif
-	stq	$1, 80($sp)
+	lda	$16, 96($sp)
+	jsr	$26, do_getxpid
+	ldq	$26, 0($sp)
+
+	lda	$sp, 16($sp)
 	ret
 .end sys_getxpid
 
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/kernel/osf_sys.c linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/osf_sys.c
--- linux-2.6.20.15/arch/alpha/kernel/osf_sys.c	2007-02-06 02:59:58 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/osf_sys.c	2007-02-06 03:05:21 +0100
@@ -885,7 +885,7 @@ osf_gettimeofday(struct timeval32 __user
 {
 	if (tv) {
 		struct timeval ktv;
-		do_gettimeofday(&ktv);
+		vx_gettimeofday(&ktv);
 		if (put_tv32(tv, &ktv))
 			return -EFAULT;
 	}
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/kernel/ptrace.c linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/ptrace.c
--- linux-2.6.20.15/arch/alpha/kernel/ptrace.c	2006-04-09 13:49:39 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/ptrace.c	2007-06-13 18:45:45 +0200
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/security.h>
 #include <linux/signal.h>
+#include <linux/vs_base.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -283,6 +284,11 @@ do_sys_ptrace(long request, long pid, lo
 		goto out_notsk;
 	}
 
+	if (!vx_check(vx_task_xid(child), VS_WATCH_P | VS_IDENT)) {
+		ret = -EPERM;
+		goto out;
+	}
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out;
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/kernel/semaphore.c linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/semaphore.c
--- linux-2.6.20.15/arch/alpha/kernel/semaphore.c	2004-08-14 12:55:32 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/semaphore.c	2007-02-06 03:05:21 +0100
@@ -68,8 +68,8 @@ __down_failed(struct semaphore *sem)
 	DECLARE_WAITQUEUE(wait, tsk);
 
 #ifdef CONFIG_DEBUG_SEMAPHORE
-	printk("%s(%d): down failed(%p)\n",
-	       tsk->comm, tsk->pid, sem);
+	printk("%s(%d:#%u): down failed(%p)\n",
+	       tsk->comm, tsk->pid, tsk->xid, sem);
 #endif
 
 	tsk->state = TASK_UNINTERRUPTIBLE;
@@ -97,8 +97,8 @@ __down_failed(struct semaphore *sem)
 	wake_up(&sem->wait);
 
 #ifdef CONFIG_DEBUG_SEMAPHORE
-	printk("%s(%d): down acquired(%p)\n",
-	       tsk->comm, tsk->pid, sem);
+	printk("%s(%d:#%u): down acquired(%p)\n",
+	       tsk->comm, tsk->pid, tsk->xid, sem);
 #endif
 }
 
@@ -110,8 +110,8 @@ __down_failed_interruptible(struct semap
 	long ret = 0;
 
 #ifdef CONFIG_DEBUG_SEMAPHORE
-	printk("%s(%d): down failed(%p)\n",
-	       tsk->comm, tsk->pid, sem);
+	printk("%s(%d:#%u): down failed(%p)\n",
+	       tsk->comm, tsk->pid, tsk->xid, sem);
 #endif
 
 	tsk->state = TASK_INTERRUPTIBLE;
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/kernel/systbls.S linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/systbls.S
--- linux-2.6.20.15/arch/alpha/kernel/systbls.S	2006-11-30 21:18:23 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/systbls.S	2007-02-06 03:05:21 +0100
@@ -446,7 +446,7 @@ sys_call_table:
 	.quad sys_stat64			/* 425 */
 	.quad sys_lstat64
 	.quad sys_fstat64
-	.quad sys_ni_syscall			/* sys_vserver */
+	.quad sys_vserver			/* sys_vserver */
 	.quad sys_ni_syscall			/* sys_mbind */
 	.quad sys_ni_syscall			/* sys_get_mempolicy */
 	.quad sys_ni_syscall			/* sys_set_mempolicy */
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/traps.c
--- linux-2.6.20.15/arch/alpha/kernel/traps.c	2006-09-20 16:57:57 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -182,7 +182,8 @@ die_if_kernel(char * str, struct pt_regs
 #ifdef CONFIG_SMP
 	printk("CPU %d ", hard_smp_processor_id());
 #endif
-	printk("%s(%d): %s %ld\n", current->comm, current->pid, str, err);
+	printk("%s(%d[#%u]): %s %ld\n", current->comm,
+		current->pid, current->xid, str, err);
 	dik_show_regs(regs, r9_15);
 	dik_show_trace((unsigned long *)(regs+1));
 	dik_show_code((unsigned int *)regs->pc);
diff -NurpP --minimal linux-2.6.20.15/arch/alpha/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/alpha/mm/fault.c
--- linux-2.6.20.15/arch/alpha/mm/fault.c	2007-02-06 02:59:58 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/alpha/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -198,8 +198,8 @@ do_page_fault(unsigned long address, uns
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
-	printk(KERN_ALERT "VM: killing process %s(%d)\n",
-	       current->comm, current->pid);
+	printk(KERN_ALERT "VM: killing process %s(%d:#%u)\n",
+	       current->comm, current->pid, current->xid);
 	if (!user_mode(regs))
 		goto no_context;
 	do_exit(SIGKILL);
diff -NurpP --minimal linux-2.6.20.15/arch/arm/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/arm/Kconfig
--- linux-2.6.20.15/arch/arm/Kconfig	2007-02-06 02:59:58 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm/Kconfig	2007-02-06 03:05:21 +0100
@@ -970,6 +970,8 @@ source "arch/arm/oprofile/Kconfig"
 
 source "arch/arm/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/arm/kernel/calls.S linux-2.6.20.15-vs2.2.0.1/arch/arm/kernel/calls.S
--- linux-2.6.20.15/arch/arm/kernel/calls.S	2007-02-06 02:59:59 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm/kernel/calls.S	2007-02-06 03:05:21 +0100
@@ -322,7 +322,7 @@
 /* 310 */	CALL(sys_request_key)
 		CALL(sys_keyctl)
 		CALL(ABI(sys_semtimedop, sys_oabi_semtimedop))
-/* vserver */	CALL(sys_ni_syscall)
+		CALL(sys_vserver)
 		CALL(sys_ioprio_set)
 /* 315 */	CALL(sys_ioprio_get)
 		CALL(sys_inotify_init)
diff -NurpP --minimal linux-2.6.20.15/arch/arm/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/arm/kernel/process.c
--- linux-2.6.20.15/arch/arm/kernel/process.c	2007-02-06 02:59:59 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -246,7 +246,8 @@ void __show_regs(struct pt_regs *regs)
 void show_regs(struct pt_regs * regs)
 {
 	printk("\n");
-	printk("Pid: %d, comm: %20s\n", current->pid, current->comm);
+	printk("Pid: %d[#%u], comm: %20s\n",
+		current->pid, current->xid, current->comm);
 	__show_regs(regs);
 	__backtrace();
 }
@@ -408,7 +409,8 @@ pid_t kernel_thread(int (*fn)(void *), v
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
 	regs.ARM_cpsr = SVC_MODE;
 
-	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -NurpP --minimal linux-2.6.20.15/arch/arm/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/arm/kernel/traps.c
--- linux-2.6.20.15/arch/arm/kernel/traps.c	2007-02-06 02:59:59 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -206,8 +206,8 @@ static void __die(const char *str, int e
 	printk("Internal error: %s: %x [#%d]\n", str, err, ++die_counter);
 	print_modules();
 	__show_regs(regs);
-	printk("Process %s (pid: %d, stack limit = 0x%p)\n",
-		tsk->comm, tsk->pid, thread + 1);
+	printk("Process %s (pid: %d:#%u, stack limit = 0x%p)\n",
+		tsk->comm, tsk->pid, tsk->xid, thread + 1);
 
 	if (!user_mode(regs) || in_interrupt()) {
 		dump_mem("Stack: ", regs->ARM_sp,
diff -NurpP --minimal linux-2.6.20.15/arch/arm/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/arm/mm/fault.c
--- linux-2.6.20.15/arch/arm/mm/fault.c	2007-02-06 03:00:01 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -267,7 +267,8 @@ do_page_fault(unsigned long addr, unsign
 		 * happened to us that made us unable to handle
 		 * the page fault gracefully.
 		 */
-		printk("VM: killing process %s\n", tsk->comm);
+		printk("VM: killing process %s(%d:#%u)\n",
+			tsk->comm, tsk->pid, tsk->xid);
 		do_exit(SIGKILL);
 		return 0;
 
diff -NurpP --minimal linux-2.6.20.15/arch/arm26/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/arm26/Kconfig
--- linux-2.6.20.15/arch/arm26/Kconfig	2007-02-06 03:00:02 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm26/Kconfig	2007-02-06 03:05:21 +0100
@@ -242,6 +242,8 @@ source "drivers/usb/Kconfig"
 
 source "arch/arm26/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/arm26/kernel/calls.S linux-2.6.20.15-vs2.2.0.1/arch/arm26/kernel/calls.S
--- linux-2.6.20.15/arch/arm26/kernel/calls.S	2005-03-02 12:38:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm26/kernel/calls.S	2007-02-06 03:05:21 +0100
@@ -257,6 +257,11 @@ __syscall_start:
 		.long	sys_lremovexattr
 		.long	sys_fremovexattr
 		.long	sys_tkill
+
+		.rept	313 - (. - __syscall_start) / 4
+			.long	sys_ni_syscall
+		.endr
+		.long	sys_vserver	/* 313 */
 __syscall_end:
 
 		.rept	NR_syscalls - (__syscall_end - __syscall_start) / 4
diff -NurpP --minimal linux-2.6.20.15/arch/arm26/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/arm26/kernel/process.c
--- linux-2.6.20.15/arch/arm26/kernel/process.c	2006-09-20 16:57:57 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm26/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -365,7 +365,8 @@ pid_t kernel_thread(int (*fn)(void *), v
         regs.ARM_r3 = (unsigned long)do_exit;
         regs.ARM_pc = (unsigned long)kernel_thread_helper | MODE_SVC26;
 
-        return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -NurpP --minimal linux-2.6.20.15/arch/arm26/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/arm26/kernel/traps.c
--- linux-2.6.20.15/arch/arm26/kernel/traps.c	2006-09-20 16:57:57 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/arm26/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -185,8 +185,9 @@ NORET_TYPE void die(const char *str, str
 	printk("Internal error: %s: %x\n", str, err);
 	printk("CPU: %d\n", smp_processor_id());
 	show_regs(regs);
-	printk("Process %s (pid: %d, stack limit = 0x%p)\n",
-		current->comm, current->pid, end_of_stack(tsk));
+	printk("Process %s (pid: %d[#%u], stack limit = 0x%p)\n",
+		current->comm, current->pid,
+		current->xid, end_of_stack(tsk));
 
 	if (!user_mode(regs) || in_interrupt()) {
 		__dump_stack(tsk, (unsigned long)(regs + 1));
diff -NurpP --minimal linux-2.6.20.15/arch/cris/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/cris/Kconfig
--- linux-2.6.20.15/arch/cris/Kconfig	2007-02-06 03:00:02 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/cris/Kconfig	2007-02-06 03:05:21 +0100
@@ -193,6 +193,8 @@ source "drivers/usb/Kconfig"
 
 source "arch/cris/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/cris/arch-v10/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/cris/arch-v10/kernel/process.c
--- linux-2.6.20.15/arch/cris/arch-v10/kernel/process.c	2006-09-20 16:57:57 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/cris/arch-v10/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -103,7 +103,8 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.dccr = 1 << I_DCCR_BITNR;
 
 	/* Ok, create the new process.. */
-        return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 
 /* setup the child's kernel stack with a pt_regs and switch_stack on it.
diff -NurpP --minimal linux-2.6.20.15/arch/cris/arch-v32/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/cris/arch-v32/kernel/process.c
--- linux-2.6.20.15/arch/cris/arch-v32/kernel/process.c	2006-09-20 16:57:57 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/cris/arch-v32/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -120,7 +120,8 @@ kernel_thread(int (*fn)(void *), void * 
 	regs.ccs = 1 << (I_CCS_BITNR + CCS_SHIFT);
 
 	/* Create the new process. */
-        return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 
 /*
diff -NurpP --minimal linux-2.6.20.15/arch/frv/kernel/kernel_thread.S linux-2.6.20.15-vs2.2.0.1/arch/frv/kernel/kernel_thread.S
--- linux-2.6.20.15/arch/frv/kernel/kernel_thread.S	2005-03-02 12:38:20 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/frv/kernel/kernel_thread.S	2007-02-06 03:05:21 +0100
@@ -13,6 +13,8 @@
 #include <asm/unistd.h>
 
 #define CLONE_VM	0x00000100	/* set if VM shared between processes */
+#define CLONE_KTHREAD	0x10000000	/* kernel thread */
+#define CLONE_KT	(CLONE_VM | CLONE_KTHREAD)	/* kernel thread flags */
 #define	KERN_ERR	"<3>"
 
 	.section .rodata
@@ -37,7 +39,7 @@ kernel_thread:
 
 	# start by forking the current process, but with shared VM
 	setlos.p	#__NR_clone,gr7		; syscall number
-	ori		gr10,#CLONE_VM,gr8	; first syscall arg	[clone_flags]
+	ori		gr10,#CLONE_KT,gr8	; first syscall arg	[clone_flags]
 	sethi.p		#0xe4e4,gr9		; second syscall arg	[newsp]
 	setlo		#0xe4e4,gr9
 	setlos.p	#0,gr10			; third syscall arg	[parent_tidptr]
diff -NurpP --minimal linux-2.6.20.15/arch/h8300/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/h8300/Kconfig
--- linux-2.6.20.15/arch/h8300/Kconfig	2007-02-06 03:00:03 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/h8300/Kconfig	2007-02-06 03:05:21 +0100
@@ -207,6 +207,8 @@ source "fs/Kconfig"
 
 source "arch/h8300/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/h8300/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/h8300/kernel/process.c
--- linux-2.6.20.15/arch/h8300/kernel/process.c	2006-09-20 16:57:58 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/h8300/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -134,7 +134,7 @@ int kernel_thread(int (*fn)(void *), voi
 
 	fs = get_fs();
 	set_fs (KERNEL_DS);
-	clone_arg = flags | CLONE_VM;
+	clone_arg = flags | CLONE_VM | CLONE_KTHREAD;
 	__asm__("mov.l sp,er3\n\t"
 		"sub.l er2,er2\n\t"
 		"mov.l %2,er1\n\t"
diff -NurpP --minimal linux-2.6.20.15/arch/i386/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/i386/Kconfig
--- linux-2.6.20.15/arch/i386/Kconfig	2007-02-06 03:00:03 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/i386/Kconfig	2007-02-06 03:05:21 +0100
@@ -1214,6 +1214,8 @@ endmenu
 
 source "arch/i386/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/i386/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/i386/kernel/process.c
--- linux-2.6.20.15/arch/i386/kernel/process.c	2007-02-06 03:00:06 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/i386/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -294,8 +294,10 @@ void show_regs(struct pt_regs * regs)
 	unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L;
 
 	printk("\n");
-	printk("Pid: %d, comm: %20s\n", current->pid, current->comm);
-	printk("EIP: %04x:[<%08lx>] CPU: %d\n",0xffff & regs->xcs,regs->eip, smp_processor_id());
+	printk("Pid: %d[#%u], comm: %20s\n",
+		current->pid, current->xid, current->comm);
+	printk("EIP: %04x:[<%08lx>] CPU: %d\n",
+		0xffff & regs->xcs,regs->eip, smp_processor_id());
 	print_symbol("EIP is at %s\n", regs->eip);
 
 	if (user_mode_vm(regs))
@@ -347,7 +349,8 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2;
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -NurpP --minimal linux-2.6.20.15/arch/i386/kernel/syscall_table.S linux-2.6.20.15-vs2.2.0.1/arch/i386/kernel/syscall_table.S
--- linux-2.6.20.15/arch/i386/kernel/syscall_table.S	2006-11-30 21:18:26 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/i386/kernel/syscall_table.S	2007-02-06 03:05:21 +0100
@@ -272,7 +272,7 @@ ENTRY(sys_call_table)
 	.long sys_tgkill	/* 270 */
 	.long sys_utimes
  	.long sys_fadvise64_64
-	.long sys_ni_syscall	/* sys_vserver */
+	.long sys_vserver
 	.long sys_mbind
 	.long sys_get_mempolicy
 	.long sys_set_mempolicy
diff -NurpP --minimal linux-2.6.20.15/arch/i386/kernel/sysenter.c linux-2.6.20.15-vs2.2.0.1/arch/i386/kernel/sysenter.c
--- linux-2.6.20.15/arch/i386/kernel/sysenter.c	2007-06-13 01:43:15 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/i386/kernel/sysenter.c	2007-03-10 18:57:29 +0100
@@ -17,6 +17,7 @@
 #include <linux/elf.h>
 #include <linux/mm.h>
 #include <linux/module.h>
+#include <linux/vs_memory.h>
 
 #include <asm/cpufeature.h>
 #include <asm/msr.h>
@@ -163,7 +164,7 @@ int arch_setup_additional_pages(struct l
 	current->mm->context.vdso = (void *)addr;
 	current_thread_info()->sysenter_return =
 				    (void *)VDSO_SYM(&SYSENTER_RETURN);
-	mm->total_vm++;
+	vx_vmpages_inc(mm);
 up_fail:
 	up_write(&mm->mmap_sem);
 	return ret;
diff -NurpP --minimal linux-2.6.20.15/arch/i386/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/i386/kernel/traps.c
--- linux-2.6.20.15/arch/i386/kernel/traps.c	2007-02-06 03:00:07 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/i386/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -56,6 +56,8 @@
 #include <asm/stacktrace.h>
 
 #include <linux/module.h>
+#include <linux/vs_context.h>
+#include <linux/vserver/history.h>
 
 #include "mach_traps.h"
 
@@ -315,8 +317,8 @@ void show_registers(struct pt_regs *regs
 		regs->esi, regs->edi, regs->ebp, esp);
 	printk(KERN_EMERG "ds: %04x   es: %04x   ss: %04x\n",
 		regs->xds & 0xffff, regs->xes & 0xffff, ss);
-	printk(KERN_EMERG "Process %.*s (pid: %d, ti=%p task=%p task.ti=%p)",
-		TASK_COMM_LEN, current->comm, current->pid,
+	printk(KERN_EMERG "Process %.*s (pid: %d[#%u], ti=%p task=%p task.ti=%p)",
+		TASK_COMM_LEN, current->comm, current->pid, current->xid,
 		current_thread_info(), current, current->thread_info);
 	/*
 	 * When in-kernel, we also print out the stack and code at the
@@ -386,6 +388,8 @@ void die(const char * str, struct pt_reg
 
 	oops_enter();
 
+	vxh_throw_oops();
+
 	if (die.lock_owner != raw_smp_processor_id()) {
 		console_verbose();
 		spin_lock_irqsave(&die.lock, flags);
@@ -423,9 +427,9 @@ void die(const char * str, struct pt_reg
 		if (nl)
 			printk("\n");
 		if (notify_die(DIE_OOPS, str, regs, err,
-					current->thread.trap_no, SIGSEGV) !=
-				NOTIFY_STOP) {
+			current->thread.trap_no, SIGSEGV) != NOTIFY_STOP) {
 			show_registers(regs);
+			vxh_dump_history();
 			/* Executive summary in case the oops scrolled away */
 			esp = (unsigned long) (&regs->esp);
 			savesegment(ss, ss);
diff -NurpP --minimal linux-2.6.20.15/arch/i386/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/i386/mm/fault.c
--- linux-2.6.20.15/arch/i386/mm/fault.c	2007-02-06 03:00:07 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/i386/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -594,7 +594,8 @@ out_of_memory:
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
-	printk("VM: killing process %s\n", tsk->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		tsk->comm, tsk->pid, tsk->xid);
 	if (error_code & 4)
 		do_exit(SIGKILL);
 	goto no_context;
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/ia64/Kconfig
--- linux-2.6.20.15/arch/ia64/Kconfig	2007-06-13 01:43:15 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/Kconfig	2007-03-10 18:57:29 +0100
@@ -569,6 +569,8 @@ endmenu
 
 source "arch/ia64/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/ia32/binfmt_elf32.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.6.20.15/arch/ia64/ia32/binfmt_elf32.c	2007-02-06 03:00:07 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/ia32/binfmt_elf32.c	2007-02-06 03:05:21 +0100
@@ -238,7 +238,8 @@ ia32_setup_arg_pages (struct linux_binpr
 			kmem_cache_free(vm_area_cachep, mpnt);
 			return ret;
 		}
-		current->mm->stack_vm = current->mm->total_vm = vma_pages(mpnt);
+		vx_vmpages_sub(current->mm, current->mm->total_vm - vma_pages(mpnt));
+		current->mm->stack_vm = current->mm->total_vm;
 	}
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/ia32/ia32_entry.S linux-2.6.20.15-vs2.2.0.1/arch/ia64/ia32/ia32_entry.S
--- linux-2.6.20.15/arch/ia64/ia32/ia32_entry.S	2006-06-18 04:51:55 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/ia32/ia32_entry.S	2007-02-06 03:05:21 +0100
@@ -483,7 +483,7 @@ ia32_syscall_table:
  	data8 sys_tgkill	/* 270 */
  	data8 compat_sys_utimes
  	data8 sys32_fadvise64_64
- 	data8 sys_ni_syscall
+	data8 sys32_vserver
   	data8 sys_ni_syscall
  	data8 sys_ni_syscall	/* 275 */
   	data8 sys_ni_syscall
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/ia32/sys_ia32.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/ia32/sys_ia32.c
--- linux-2.6.20.15/arch/ia64/ia32/sys_ia32.c	2007-02-06 03:00:07 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/ia32/sys_ia32.c	2007-02-06 03:05:21 +0100
@@ -1182,7 +1182,7 @@ sys32_gettimeofday (struct compat_timeva
 {
 	if (tv) {
 		struct timeval ktv;
-		do_gettimeofday(&ktv);
+		vx_gettimeofday(&ktv);
 		if (put_tv32(tv, &ktv))
 			return -EFAULT;
 	}
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/kernel/asm-offsets.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/asm-offsets.c
--- linux-2.6.20.15/arch/ia64/kernel/asm-offsets.c	2006-09-20 16:57:58 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/asm-offsets.c	2007-02-06 03:05:21 +0100
@@ -191,6 +191,7 @@ void foo(void)
     /* for assembly files which can't include sched.h: */
 	DEFINE(IA64_CLONE_VFORK, CLONE_VFORK);
 	DEFINE(IA64_CLONE_VM, CLONE_VM);
+	DEFINE(IA64_CLONE_KTHREAD, CLONE_KTHREAD);
 
 	BLANK();
 	DEFINE(IA64_CPUINFO_NSEC_PER_CYC_OFFSET,
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/kernel/entry.S linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/entry.S
--- linux-2.6.20.15/arch/ia64/kernel/entry.S	2007-02-06 03:00:07 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/entry.S	2007-02-06 03:07:01 +0100
@@ -1576,7 +1576,7 @@ sys_call_table:
 	data8 sys_mq_notify
 	data8 sys_mq_getsetattr
 	data8 sys_kexec_load
-	data8 sys_ni_syscall			// reserved for vserver
+	data8 sys_vserver
 	data8 sys_waitid			// 1270
 	data8 sys_add_key
 	data8 sys_request_key
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/kernel/perfmon.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/perfmon.c
--- linux-2.6.20.15/arch/ia64/kernel/perfmon.c	2007-02-06 03:00:07 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/perfmon.c	2007-02-06 03:05:21 +0100
@@ -41,6 +41,7 @@
 #include <linux/capability.h>
 #include <linux/rcupdate.h>
 #include <linux/completion.h>
+#include <linux/vs_memory.h>
 
 #include <asm/errno.h>
 #include <asm/intrinsics.h>
@@ -2356,7 +2357,7 @@ pfm_smpl_buffer_alloc(struct task_struct
 	 */
 	insert_vm_struct(mm, vma);
 
-	mm->total_vm  += size >> PAGE_SHIFT;
+	vx_vmpages_add(mm, size >> PAGE_SHIFT);
 	vm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file,
 							vma_pages(vma));
 	up_write(&task->mm->mmap_sem);
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/process.c
--- linux-2.6.20.15/arch/ia64/kernel/process.c	2007-02-06 03:00:07 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -105,7 +105,8 @@ show_regs (struct pt_regs *regs)
 	unsigned long ip = regs->cr_iip + ia64_psr(regs)->ri;
 
 	print_modules();
-	printk("\nPid: %d, CPU %d, comm: %20s\n", current->pid, smp_processor_id(), current->comm);
+	printk("\nPid: %d[#%u], CPU %d, comm: %20s\n",
+		current->pid, current->xid, smp_processor_id(), current->comm);
 	printk("psr : %016lx ifs : %016lx ip  : [<%016lx>]    %s\n",
 	       regs->cr_ipsr, regs->cr_ifs, ip, print_tainted());
 	print_symbol("ip is at %s\n", ip);
@@ -694,7 +695,8 @@ kernel_thread (int (*fn)(void *), void *
 	regs.sw.ar_fpsr = regs.pt.ar_fpsr = ia64_getreg(_IA64_REG_AR_FPSR);
 	regs.sw.ar_bspstore = (unsigned long) current + IA64_RBS_OFFSET;
 	regs.sw.pr = (1 << PRED_KERNEL_STACK);
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs.pt, 0, NULL, NULL);
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/kernel/ptrace.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/ptrace.c
--- linux-2.6.20.15/arch/ia64/kernel/ptrace.c	2006-09-20 16:57:58 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/ptrace.c	2007-06-13 18:45:53 +0200
@@ -17,6 +17,7 @@
 #include <linux/security.h>
 #include <linux/audit.h>
 #include <linux/signal.h>
+#include <linux/vs_base.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -1442,6 +1443,9 @@ sys_ptrace (long request, pid_t pid, uns
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VS_WATCH_P | VS_IDENT))
+		goto out_tsk;
+
 	ret = -EPERM;
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/traps.c
--- linux-2.6.20.15/arch/ia64/kernel/traps.c	2007-02-06 03:00:07 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/kernel/traps.c	2007-02-06 03:09:13 +0100
@@ -106,8 +106,9 @@ die (const char *str, struct pt_regs *re
 	put_cpu();
 
 	if (++die.lock_owner_depth < 3) {
-		printk("%s[%d]: %s %ld [%d]\n",
-			current->comm, current->pid, str, err, ++die_counter);
+		printk("%s[%d[#%u]]: %s %ld [%d]\n",
+			current->comm, current->pid, current->xid,
+			str, err, ++die_counter);
 		(void) notify_die(DIE_OOPS, (char *)str, regs, err, 255, SIGSEGV);
 		show_regs(regs);
   	} else
@@ -359,8 +360,9 @@ handle_fpu_swa (int fp_fault, struct pt_
 			if ((last.count & 15) < 5 && (ia64_fetchadd(1, &last.count, acq) & 15) < 5) {
 				last.time = current_jiffies + 5 * HZ;
 				printk(KERN_WARNING
-		       			"%s(%d): floating-point assist fault at ip %016lx, isr %016lx\n",
-		       			current->comm, current->pid, regs->cr_iip + ia64_psr(regs)->ri, isr);
+					"%s(%d[#%u]): floating-point assist fault at ip %016lx, isr %016lx\n",
+					current->comm, current->pid, current->xid,
+					regs->cr_iip + ia64_psr(regs)->ri, isr);
 			}
 		}
 	}
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/mm/fault.c
--- linux-2.6.20.15/arch/ia64/mm/fault.c	2006-11-30 21:18:27 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/mm/fault.c	2007-02-06 03:05:21 +0100
@@ -10,6 +10,7 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/kprobes.h>
+#include <linux/vs_memory.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
diff -NurpP --minimal linux-2.6.20.15/arch/ia64/sn/kernel/xpc_main.c linux-2.6.20.15-vs2.2.0.1/arch/ia64/sn/kernel/xpc_main.c
--- linux-2.6.20.15/arch/ia64/sn/kernel/xpc_main.c	2007-02-06 03:00:08 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ia64/sn/kernel/xpc_main.c	2007-02-06 03:05:21 +0100
@@ -108,6 +108,7 @@ static ctl_table xpc_sys_xpc_hb_dir[] = 
 		0644,
 		NULL,
 		&proc_dointvec_minmax,
+		NULL,
 		&sysctl_intvec,
 		NULL,
 		&xpc_hb_min_interval,
@@ -121,6 +122,7 @@ static ctl_table xpc_sys_xpc_hb_dir[] = 
 		0644,
 		NULL,
 		&proc_dointvec_minmax,
+		NULL,
 		&sysctl_intvec,
 		NULL,
 		&xpc_hb_check_min_interval,
@@ -145,6 +147,7 @@ static ctl_table xpc_sys_xpc_dir[] = {
 		0644,
 		NULL,
 		&proc_dointvec_minmax,
+		NULL,
 		&sysctl_intvec,
 		NULL,
 		&xpc_disengage_request_min_timelimit,
diff -NurpP --minimal linux-2.6.20.15/arch/m32r/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/m32r/kernel/process.c
--- linux-2.6.20.15/arch/m32r/kernel/process.c	2007-06-13 01:43:15 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/m32r/kernel/process.c	2007-03-10 18:57:29 +0100
@@ -211,8 +211,8 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.psw = M32R_PSW_BIE;
 
 	/* Ok, create the new process. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL,
-		NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 
 /*
diff -NurpP --minimal linux-2.6.20.15/arch/m32r/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/m32r/kernel/traps.c
--- linux-2.6.20.15/arch/m32r/kernel/traps.c	2006-11-30 21:18:28 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/m32r/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -195,8 +195,9 @@ static void show_registers(struct pt_reg
 	} else {
 		printk("SPI: %08lx\n", sp);
 	}
-	printk("Process %s (pid: %d, process nr: %d, stackpage=%08lx)",
-		current->comm, current->pid, 0xffff & i, 4096+(unsigned long)current);
+	printk("Process %s (pid: %d[#%u], process nr: %d, stackpage=%08lx)",
+		current->comm, current->pid, current->xid,
+		0xffff & i, 4096+(unsigned long)current);
 
 	/*
 	 * When in-kernel, we also print out the stack and code at the
diff -NurpP --minimal linux-2.6.20.15/arch/m68k/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/m68k/Kconfig
--- linux-2.6.20.15/arch/m68k/Kconfig	2007-02-06 03:00:08 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/m68k/Kconfig	2007-02-06 03:05:21 +0100
@@ -662,6 +662,8 @@ source "fs/Kconfig"
 
 source "arch/m68k/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/m68k/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/m68k/kernel/process.c
--- linux-2.6.20.15/arch/m68k/kernel/process.c	2006-11-30 21:18:28 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/m68k/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -159,7 +159,8 @@ int kernel_thread(int (*fn)(void *), voi
 
 	{
 	register long retval __asm__ ("d0");
-	register long clone_arg __asm__ ("d1") = flags | CLONE_VM | CLONE_UNTRACED;
+	register long clone_arg __asm__ ("d1") =
+		flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD;
 
 	retval = __NR_clone;
 	__asm__ __volatile__
diff -NurpP --minimal linux-2.6.20.15/arch/m68k/kernel/ptrace.c linux-2.6.20.15-vs2.2.0.1/arch/m68k/kernel/ptrace.c
--- linux-2.6.20.15/arch/m68k/kernel/ptrace.c	2006-09-20 16:57:58 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/m68k/kernel/ptrace.c	2007-06-13 18:46:00 +0200
@@ -19,6 +19,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/signal.h>
+#include <linux/vs_base.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -279,6 +280,8 @@ long arch_ptrace(struct task_struct *chi
 		ret = ptrace_request(child, request, addr, data);
 		break;
 	}
+	if (!vx_check(vx_task_xid(child), VS_WATCH_P | VS_IDENT))
+		goto out_tsk;
 
 	return ret;
 out_eio:
diff -NurpP --minimal linux-2.6.20.15/arch/m68k/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/m68k/kernel/traps.c
--- linux-2.6.20.15/arch/m68k/kernel/traps.c	2006-11-30 21:18:28 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/m68k/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -899,8 +899,8 @@ void show_registers(struct pt_regs *regs
 	printk("d4: %08lx    d5: %08lx    a0: %08lx    a1: %08lx\n",
 	       regs->d4, regs->d5, regs->a0, regs->a1);
 
-	printk("Process %s (pid: %d, task=%p)\n",
-		current->comm, current->pid, current);
+	printk("Process %s (pid: %d[#%u], task=%p)\n",
+		current->comm, current->pid, current->xid, current);
 	addr = (unsigned long)&fp->un;
 	printk("Frame format=%X ", regs->format);
 	switch (regs->format) {
diff -NurpP --minimal linux-2.6.20.15/arch/m68knommu/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/m68knommu/Kconfig
--- linux-2.6.20.15/arch/m68knommu/Kconfig	2007-02-06 03:00:08 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/m68knommu/Kconfig	2007-02-06 03:05:21 +0100
@@ -671,6 +671,8 @@ source "fs/Kconfig"
 
 source "arch/m68knommu/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/m68knommu/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/m68knommu/kernel/process.c
--- linux-2.6.20.15/arch/m68knommu/kernel/process.c	2007-02-06 03:00:08 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/m68knommu/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -122,7 +122,7 @@ void show_regs(struct pt_regs * regs)
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
 	int retval;
-	long clone_arg = flags | CLONE_VM;
+	long clone_arg = flags | CLONE_VM | CLONE_KTHREAD;
 	mm_segment_t fs;
 
 	fs = get_fs();
diff -NurpP --minimal linux-2.6.20.15/arch/m68knommu/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/m68knommu/kernel/traps.c
--- linux-2.6.20.15/arch/m68knommu/kernel/traps.c	2007-02-06 03:00:08 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/m68knommu/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -80,8 +80,9 @@ void die_if_kernel(char *str, struct pt_
 	printk(KERN_EMERG "d4: %08lx    d5: %08lx    a0: %08lx    a1: %08lx\n",
 	       fp->d4, fp->d5, fp->a0, fp->a1);
 
-	printk(KERN_EMERG "Process %s (pid: %d, stackpage=%08lx)\n",
-		current->comm, current->pid, PAGE_SIZE+(unsigned long)current);
+	printk(KERN_EMERG "Process %s (pid: %d[#%u], stackpage=%08lx)\n",
+		current->comm, current->pid, current->xid,
+		PAGE_SIZE+(unsigned long)current);
 	show_stack(NULL, (unsigned long *)fp);
 	do_exit(SIGSEGV);
 }
diff -NurpP --minimal linux-2.6.20.15/arch/mips/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/mips/Kconfig
--- linux-2.6.20.15/arch/mips/Kconfig	2007-02-06 03:00:08 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/Kconfig	2007-02-06 03:05:21 +0100
@@ -2084,6 +2084,8 @@ source "arch/mips/oprofile/Kconfig"
 
 source "arch/mips/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/mips/kernel/linux32.c linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/linux32.c
--- linux-2.6.20.15/arch/mips/kernel/linux32.c	2007-02-06 03:00:11 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/linux32.c	2007-02-06 03:05:21 +0100
@@ -300,7 +300,7 @@ sys32_gettimeofday(struct compat_timeval
 {
 	if (tv) {
 		struct timeval ktv;
-		do_gettimeofday(&ktv);
+		vx_gettimeofday(&ktv);
 		if (put_tv32(tv, &ktv))
 			return -EFAULT;
 	}
diff -NurpP --minimal linux-2.6.20.15/arch/mips/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/process.c
--- linux-2.6.20.15/arch/mips/kernel/process.c	2006-11-30 21:18:29 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -271,7 +271,8 @@ long kernel_thread(int (*fn)(void *), vo
 #endif
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 
 /*
diff -NurpP --minimal linux-2.6.20.15/arch/mips/kernel/ptrace.c linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/ptrace.c
--- linux-2.6.20.15/arch/mips/kernel/ptrace.c	2006-11-30 21:18:29 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/ptrace.c	2007-06-13 18:46:07 +0200
@@ -26,6 +26,7 @@
 #include <linux/user.h>
 #include <linux/security.h>
 #include <linux/signal.h>
+#include <linux/vs_base.h>
 
 #include <asm/byteorder.h>
 #include <asm/cpu.h>
@@ -172,6 +173,9 @@ long arch_ptrace(struct task_struct *chi
 {
 	int ret;
 
+	if (!vx_check(vx_task_xid(child), VS_WATCH_P | VS_IDENT))
+		goto out;
+
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
diff -NurpP --minimal linux-2.6.20.15/arch/mips/kernel/scall32-o32.S linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/scall32-o32.S
--- linux-2.6.20.15/arch/mips/kernel/scall32-o32.S	2007-02-06 03:00:11 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/scall32-o32.S	2007-02-06 03:05:21 +0100
@@ -619,7 +619,7 @@ einval:	li	v0, -EINVAL
 	sys	sys_mq_timedreceive	5
 	sys	sys_mq_notify		2	/* 4275 */
 	sys	sys_mq_getsetattr	3
-	sys	sys_ni_syscall		0	/* sys_vserver */
+	sys	sys_vserver		3
 	sys	sys_waitid		5
 	sys	sys_ni_syscall		0	/* available, was setaltroot */
 	sys	sys_add_key		5	/* 4280 */
diff -NurpP --minimal linux-2.6.20.15/arch/mips/kernel/scall64-64.S linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/scall64-64.S
--- linux-2.6.20.15/arch/mips/kernel/scall64-64.S	2007-02-06 03:00:11 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/scall64-64.S	2007-02-06 03:05:21 +0100
@@ -434,7 +434,7 @@ sys_call_table:
 	PTR	sys_mq_timedreceive
 	PTR	sys_mq_notify
 	PTR	sys_mq_getsetattr		/* 5235 */
-	PTR	sys_ni_syscall			/* sys_vserver */
+	PTR	sys_vserver
 	PTR	sys_waitid
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key
diff -NurpP --minimal linux-2.6.20.15/arch/mips/kernel/scall64-n32.S linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/scall64-n32.S
--- linux-2.6.20.15/arch/mips/kernel/scall64-n32.S	2007-02-06 03:00:11 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/scall64-n32.S	2007-02-06 03:05:21 +0100
@@ -360,7 +360,7 @@ EXPORT(sysn32_call_table)
 	PTR	compat_sys_mq_timedreceive
 	PTR	compat_sys_mq_notify
 	PTR	compat_sys_mq_getsetattr
-	PTR	sys_ni_syscall			/* 6240, sys_vserver */
+	PTR	sys32_vserver			/* 6240 */
 	PTR	sysn32_waitid
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key
diff -NurpP --minimal linux-2.6.20.15/arch/mips/kernel/scall64-o32.S linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/scall64-o32.S
--- linux-2.6.20.15/arch/mips/kernel/scall64-o32.S	2007-02-06 03:00:11 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/scall64-o32.S	2007-02-06 03:05:21 +0100
@@ -482,7 +482,7 @@ sys_call_table:
 	PTR	compat_sys_mq_timedreceive
 	PTR	compat_sys_mq_notify		/* 4275 */
 	PTR	compat_sys_mq_getsetattr
-	PTR	sys_ni_syscall			/* sys_vserver */
+	PTR	sys32_vserver
 	PTR	sys32_waitid
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key			/* 4280 */
diff -NurpP --minimal linux-2.6.20.15/arch/mips/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/traps.c
--- linux-2.6.20.15/arch/mips/kernel/traps.c	2007-02-06 03:00:11 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -299,8 +299,9 @@ void show_registers(struct pt_regs *regs
 {
 	show_regs(regs);
 	print_modules();
-	printk("Process %s (pid: %d, threadinfo=%p, task=%p)\n",
-	        current->comm, current->pid, current_thread_info(), current);
+	printk("Process %s (pid: %d:#%u, threadinfo=%p, task=%p)\n",
+		current->comm, current->pid, current->xid,
+		current_thread_info(), current);
 	show_stacktrace(current, regs);
 	show_code((unsigned int *) regs->cp0_epc);
 	printk("\n");
diff -NurpP --minimal linux-2.6.20.15/arch/mips/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/mips/mm/fault.c
--- linux-2.6.20.15/arch/mips/mm/fault.c	2007-02-06 03:00:11 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/mips/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -180,7 +180,8 @@ out_of_memory:
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
-	printk("VM: killing process %s\n", tsk->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		tsk->comm, tsk->pid, tsk->xid);
 	if (user_mode(regs))
 		do_exit(SIGKILL);
 	goto no_context;
diff -NurpP --minimal linux-2.6.20.15/arch/parisc/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/parisc/Kconfig
--- linux-2.6.20.15/arch/parisc/Kconfig	2007-02-06 03:00:12 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/parisc/Kconfig	2007-02-06 03:05:21 +0100
@@ -265,6 +265,8 @@ source "arch/parisc/oprofile/Kconfig"
 
 source "arch/parisc/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/parisc/kernel/entry.S linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/entry.S
--- linux-2.6.20.15/arch/parisc/kernel/entry.S	2006-11-30 21:18:30 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/entry.S	2007-02-06 03:05:21 +0100
@@ -761,6 +761,7 @@ fault_vector_11:
 
 #define CLONE_VM 0x100	/* Must agree with <linux/sched.h> */
 #define CLONE_UNTRACED 0x00800000
+#define CLONE_KTHREAD 0x10000000
 
 	.export __kernel_thread, code
 	.import do_fork
diff -NurpP --minimal linux-2.6.20.15/arch/parisc/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/process.c
--- linux-2.6.20.15/arch/parisc/kernel/process.c	2006-11-30 21:18:30 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -173,7 +173,7 @@ pid_t kernel_thread(int (*fn)(void *), v
 	 *	  kernel_thread can become a #define.
 	 */
 
-	return __kernel_thread(fn, arg, flags);
+	return __kernel_thread(fn, arg, flags | CLONE_KTHREAD);
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -NurpP --minimal linux-2.6.20.15/arch/parisc/kernel/sys_parisc32.c linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/sys_parisc32.c
--- linux-2.6.20.15/arch/parisc/kernel/sys_parisc32.c	2006-11-30 21:18:31 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/sys_parisc32.c	2007-02-15 00:05:56 +0100
@@ -204,11 +204,11 @@ static inline long get_ts32(struct times
 asmlinkage int
 sys32_gettimeofday(struct compat_timeval __user *tv, struct timezone __user *tz)
 {
-    extern void do_gettimeofday(struct timeval *tv);
+    extern void vx_gettimeofday(struct timeval *tv);
 
     if (tv) {
 	    struct timeval ktv;
-	    do_gettimeofday(&ktv);
+	    vx_gettimeofday(&ktv);
 	    if (put_compat_timeval(tv, &ktv))
 		    return -EFAULT;
     }
@@ -612,6 +612,7 @@ asmlinkage int sys32_sysinfo(struct sysi
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
+		/* TODO: requires vx virtualization */
 		val.uptime = jiffies / HZ;
 
 		val.loads[0] = avenrun[0] << (SI_LOAD_SHIFT - FSHIFT);
diff -NurpP --minimal linux-2.6.20.15/arch/parisc/kernel/syscall_table.S linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/syscall_table.S
--- linux-2.6.20.15/arch/parisc/kernel/syscall_table.S	2006-11-30 21:18:31 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/syscall_table.S	2007-02-06 03:05:21 +0100
@@ -368,7 +368,7 @@
 	ENTRY_COMP(mbind)		/* 260 */
 	ENTRY_COMP(get_mempolicy)
 	ENTRY_COMP(set_mempolicy)
-	ENTRY_SAME(ni_syscall)	/* 263: reserved for vserver */
+	ENTRY_DIFF(vserver)
 	ENTRY_SAME(add_key)
 	ENTRY_SAME(request_key)		/* 265 */
 	ENTRY_SAME(keyctl)
diff -NurpP --minimal linux-2.6.20.15/arch/parisc/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/traps.c
--- linux-2.6.20.15/arch/parisc/kernel/traps.c	2006-11-30 21:18:31 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/parisc/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -210,8 +210,9 @@ void die_if_kernel(char *str, struct pt_
 		if (err == 0)
 			return; /* STFU */
 
-		printk(KERN_CRIT "%s (pid %d): %s (code %ld) at " RFMT "\n",
-			current->comm, current->pid, str, err, regs->iaoq[0]);
+		printk(KERN_CRIT "%s (pid %d:#%u): %s (code %ld) at " RFMT "\n",
+			current->comm, current->pid, current->xid,
+			str, err, regs->iaoq[0]);
 #ifdef PRINT_USER_FAULTS
 		/* XXX for debugging only */
 		show_regs(regs);
@@ -242,8 +243,8 @@ void die_if_kernel(char *str, struct pt_
 	if (!console_drivers)
 		pdc_console_restart();
 	
-	printk(KERN_CRIT "%s (pid %d): %s (code %ld)\n",
-		current->comm, current->pid, str, err);
+	printk(KERN_CRIT "%s (pid %d:#%u): %s (code %ld)\n",
+		current->comm, current->pid, current->xid, str, err);
 	show_regs(regs);
 
 	if (in_interrupt())
diff -NurpP --minimal linux-2.6.20.15/arch/parisc/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/parisc/mm/fault.c
--- linux-2.6.20.15/arch/parisc/mm/fault.c	2007-02-06 03:00:12 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/parisc/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -213,8 +213,9 @@ bad_area:
 
 #ifdef PRINT_USER_FAULTS
 		printk(KERN_DEBUG "\n");
-		printk(KERN_DEBUG "do_page_fault() pid=%d command='%s' type=%lu address=0x%08lx\n",
-		    tsk->pid, tsk->comm, code, address);
+		printk(KERN_DEBUG "do_page_fault() pid=%d:#%u "
+		    "command='%s' type=%lu address=0x%08lx\n",
+		    tsk->pid, tsk->xid, tsk->comm, code, address);
 		if (vma) {
 			printk(KERN_DEBUG "vm_start = 0x%08lx, vm_end = 0x%08lx\n",
 					vma->vm_start, vma->vm_end);
@@ -264,7 +265,8 @@ no_context:
 
   out_of_memory:
 	up_read(&mm->mmap_sem);
-	printk(KERN_CRIT "VM: killing process %s\n", current->comm);
+	printk(KERN_CRIT "VM: killing process %s(%d:#%u)\n",
+		current->comm, current->pid, current->xid);
 	if (user_mode(regs))
 		do_exit(SIGKILL);
 	goto no_context;
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/powerpc/Kconfig
--- linux-2.6.20.15/arch/powerpc/Kconfig	2007-02-06 03:00:12 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/Kconfig	2007-02-06 03:05:21 +0100
@@ -1193,6 +1193,8 @@ endmenu
 
 source "arch/powerpc/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 config KEYS_COMPAT
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/kernel/asm-offsets.c linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/asm-offsets.c
--- linux-2.6.20.15/arch/powerpc/kernel/asm-offsets.c	2007-02-06 03:00:12 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/asm-offsets.c	2007-02-06 03:05:21 +0100
@@ -244,6 +244,7 @@ int main(void)
 
 	DEFINE(CLONE_VM, CLONE_VM);
 	DEFINE(CLONE_UNTRACED, CLONE_UNTRACED);
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
 
 #ifndef CONFIG_PPC64
 	DEFINE(MM_PGD, offsetof(struct mm_struct, pgd));
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/kernel/irq.c linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/irq.c
--- linux-2.6.20.15/arch/powerpc/kernel/irq.c	2007-02-06 03:00:12 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/irq.c	2007-02-06 03:05:21 +0100
@@ -53,6 +53,7 @@
 #include <linux/mutex.h>
 #include <linux/bootmem.h>
 #include <linux/pci.h>
+#include <linux/vs_context.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/kernel/misc_32.S linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/misc_32.S
--- linux-2.6.20.15/arch/powerpc/kernel/misc_32.S	2006-11-30 21:18:31 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/misc_32.S	2007-02-06 03:05:21 +0100
@@ -749,7 +749,7 @@ _GLOBAL(kernel_thread)
 	mr	r30,r3		/* function */
 	mr	r31,r4		/* argument */
 	ori	r3,r5,CLONE_VM	/* flags */
-	oris	r3,r3,CLONE_UNTRACED>>16
+	oris	r3,r3,(CLONE_UNTRACED|CLONE_KTHREAD)>>16
 	li	r4,0		/* new sp (unused) */
 	li	r0,__NR_clone
 	sc
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/kernel/misc_64.S linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/misc_64.S
--- linux-2.6.20.15/arch/powerpc/kernel/misc_64.S	2006-11-30 21:18:31 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/misc_64.S	2007-02-06 03:05:21 +0100
@@ -394,7 +394,7 @@ _GLOBAL(kernel_thread)
 	mr	r29,r3
 	mr	r30,r4
 	ori	r3,r5,CLONE_VM	/* flags */
-	oris	r3,r3,(CLONE_UNTRACED>>16)
+	oris	r3,r3,(CLONE_UNTRACED|CLONE_KTHREAD)>>16
 	li	r4,0		/* new sp (unused) */
 	li	r0,__NR_clone
 	sc
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/process.c
--- linux-2.6.20.15/arch/powerpc/kernel/process.c	2006-11-30 21:18:31 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -425,8 +425,9 @@ void show_regs(struct pt_regs * regs)
 	trap = TRAP(regs);
 	if (trap == 0x300 || trap == 0x600)
 		printk("DAR: "REG", DSISR: "REG"\n", regs->dar, regs->dsisr);
-	printk("TASK = %p[%d] '%s' THREAD: %p",
-	       current, current->pid, current->comm, task_thread_info(current));
+	printk("TASK = %p[%d,#%u] '%s' THREAD: %p",
+	       current, current->pid, current->xid,
+	       current->comm, task_thread_info(current));
 
 #ifdef CONFIG_SMP
 	printk(" CPU: %d", smp_processor_id());
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/kernel/sys_ppc32.c linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/sys_ppc32.c
--- linux-2.6.20.15/arch/powerpc/kernel/sys_ppc32.c	2007-02-06 03:00:13 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/sys_ppc32.c	2007-02-06 03:05:21 +0100
@@ -276,7 +276,7 @@ asmlinkage long compat_sys_gettimeofday(
 {
 	if (tv) {
 		struct timeval ktv;
-		do_gettimeofday(&ktv);
+		vx_gettimeofday(&ktv);
 		if (put_tv32(tv, &ktv))
 			return -EFAULT;
 	}
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/traps.c
--- linux-2.6.20.15/arch/powerpc/kernel/traps.c	2007-02-06 03:00:13 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -844,8 +844,9 @@ void nonrecoverable_exception(struct pt_
 
 void trace_syscall(struct pt_regs *regs)
 {
-	printk("Task: %p(%d), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\n",
-	       current, current->pid, regs->nip, regs->link, regs->gpr[0],
+	printk("Task: %p(%d[#%u]), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\n",
+	       current, current->pid, current->xid,
+	       regs->nip, regs->link, regs->gpr[0],
 	       regs->ccr&0x10000000?"Error=":"", regs->gpr[3], print_tainted());
 }
 
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/kernel/vdso.c linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/vdso.c
--- linux-2.6.20.15/arch/powerpc/kernel/vdso.c	2007-02-06 03:00:13 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/kernel/vdso.c	2007-02-06 03:05:21 +0100
@@ -22,6 +22,7 @@
 #include <linux/elf.h>
 #include <linux/security.h>
 #include <linux/bootmem.h>
+#include <linux/vs_memory.h>
 
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -302,7 +303,7 @@ int arch_setup_additional_pages(struct l
 
 	/* Put vDSO base into mm struct and account for memory usage */
 	current->mm->context.vdso_base = vdso_base;
-	mm->total_vm += (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+	vx_vmpages_add(mm, (vma->vm_end - vma->vm_start) >> PAGE_SHIFT);
 	up_write(&mm->mmap_sem);
 	return 0;
 
diff -NurpP --minimal linux-2.6.20.15/arch/powerpc/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/powerpc/mm/fault.c
--- linux-2.6.20.15/arch/powerpc/mm/fault.c	2007-02-06 03:00:13 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/powerpc/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -391,7 +391,8 @@ out_of_memory:
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
-	printk("VM: killing process %s\n", current->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		current->comm, current->pid, current->xid);
 	if (user_mode(regs))
 		do_exit(SIGKILL);
 	return SIGKILL;
diff -NurpP --minimal linux-2.6.20.15/arch/ppc/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/ppc/Kconfig
--- linux-2.6.20.15/arch/ppc/Kconfig	2007-02-06 03:00:16 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ppc/Kconfig	2007-02-06 03:05:21 +0100
@@ -1445,6 +1445,8 @@ source "arch/powerpc/oprofile/Kconfig"
 
 source "arch/ppc/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/ppc/kernel/asm-offsets.c linux-2.6.20.15-vs2.2.0.1/arch/ppc/kernel/asm-offsets.c
--- linux-2.6.20.15/arch/ppc/kernel/asm-offsets.c	2006-09-20 16:58:01 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/ppc/kernel/asm-offsets.c	2007-02-06 03:05:21 +0100
@@ -121,6 +121,7 @@ main(void)
 	DEFINE(TRAP, STACK_FRAME_OVERHEAD+offsetof(struct pt_regs, trap));
 	DEFINE(CLONE_VM, CLONE_VM);
 	DEFINE(CLONE_UNTRACED, CLONE_UNTRACED);
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
 	DEFINE(MM_PGD, offsetof(struct mm_struct, pgd));
 
 	/* About the CPU features table */
diff -NurpP --minimal linux-2.6.20.15/arch/ppc/kernel/misc.S linux-2.6.20.15-vs2.2.0.1/arch/ppc/kernel/misc.S
--- linux-2.6.20.15/arch/ppc/kernel/misc.S	2006-11-30 21:18:32 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ppc/kernel/misc.S	2007-02-06 03:05:21 +0100
@@ -848,7 +848,7 @@ _GLOBAL(kernel_thread)
 	mr	r30,r3		/* function */
 	mr	r31,r4		/* argument */
 	ori	r3,r5,CLONE_VM	/* flags */
-	oris	r3,r3,CLONE_UNTRACED>>16
+	oris	r3,r3,(CLONE_UNTRACED|CLONE_KTHREAD)>>16
 	li	r4,0		/* new sp (unused) */
 	li	r0,__NR_clone
 	sc
diff -NurpP --minimal linux-2.6.20.15/arch/ppc/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/ppc/kernel/traps.c
--- linux-2.6.20.15/arch/ppc/kernel/traps.c	2007-02-06 03:00:16 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ppc/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -696,8 +696,9 @@ void nonrecoverable_exception(struct pt_
 
 void trace_syscall(struct pt_regs *regs)
 {
-	printk("Task: %p(%d), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\n",
-	       current, current->pid, regs->nip, regs->link, regs->gpr[0],
+	printk("Task: %p(%d[#%u]), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\n",
+	       current, current->pid, current->xid,
+	       regs->nip, regs->link, regs->gpr[0],
 	       regs->ccr&0x10000000?"Error=":"", regs->gpr[3], print_tainted());
 }
 
diff -NurpP --minimal linux-2.6.20.15/arch/ppc/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/ppc/mm/fault.c
--- linux-2.6.20.15/arch/ppc/mm/fault.c	2006-11-30 21:18:32 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/ppc/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -296,7 +296,8 @@ out_of_memory:
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
-	printk("VM: killing process %s\n", current->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		current->comm, current->pid, current->xid);
 	if (user_mode(regs))
 		do_exit(SIGKILL);
 	return SIGKILL;
diff -NurpP --minimal linux-2.6.20.15/arch/s390/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/s390/Kconfig
--- linux-2.6.20.15/arch/s390/Kconfig	2007-02-06 03:00:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/s390/Kconfig	2007-02-06 03:05:21 +0100
@@ -522,6 +522,8 @@ endmenu
 
 source "arch/s390/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/s390/kernel/compat_linux.c linux-2.6.20.15-vs2.2.0.1/arch/s390/kernel/compat_linux.c
--- linux-2.6.20.15/arch/s390/kernel/compat_linux.c	2006-11-30 21:18:32 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/s390/kernel/compat_linux.c	2007-02-06 03:05:21 +0100
@@ -600,7 +600,7 @@ asmlinkage long sys32_gettimeofday(struc
 {
 	if (tv) {
 		struct timeval ktv;
-		do_gettimeofday(&ktv);
+		vx_gettimeofday(&ktv);
 		if (put_tv32(tv, &ktv))
 			return -EFAULT;
 	}
diff -NurpP --minimal linux-2.6.20.15/arch/s390/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/s390/kernel/process.c
--- linux-2.6.20.15/arch/s390/kernel/process.c	2006-11-30 21:18:32 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/s390/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -165,9 +165,9 @@ void show_regs(struct pt_regs *regs)
 	struct task_struct *tsk = current;
 
         printk("CPU:    %d    %s\n", task_thread_info(tsk)->cpu, print_tainted());
-        printk("Process %s (pid: %d, task: %p, ksp: %p)\n",
-	       current->comm, current->pid, (void *) tsk,
-	       (void *) tsk->thread.ksp);
+	printk("Process %s (pid: %d[#%u], task: %p, ksp: %p)\n",
+	       current->comm, current->pid, current->xid,
+	       (void *) tsk, (void *) tsk->thread.ksp);
 
 	show_registers(regs);
 	/* Show stack backtrace if pt_regs is from kernel mode */
@@ -198,7 +198,7 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.orig_gpr2 = -1;
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED,
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
 		       0, &regs, 0, NULL, NULL);
 }
 
diff -NurpP --minimal linux-2.6.20.15/arch/s390/kernel/ptrace.c linux-2.6.20.15-vs2.2.0.1/arch/s390/kernel/ptrace.c
--- linux-2.6.20.15/arch/s390/kernel/ptrace.c	2006-06-18 04:52:33 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/s390/kernel/ptrace.c	2007-06-13 18:46:13 +0200
@@ -33,6 +33,7 @@
 #include <linux/security.h>
 #include <linux/audit.h>
 #include <linux/signal.h>
+#include <linux/vs_base.h>
 
 #include <asm/segment.h>
 #include <asm/page.h>
@@ -723,7 +724,13 @@ sys_ptrace(long request, long pid, long 
 		goto out;
 	}
 
+	if (!vx_check(vx_task_xid(child), VS_WATCH_P | VS_IDENT)) {
+		ret = -EPERM;
+		goto out_tsk;
+	}
+
 	ret = do_ptrace(child, request, addr, data);
+out_tsk:
 	put_task_struct(child);
 out:
 	unlock_kernel();
diff -NurpP --minimal linux-2.6.20.15/arch/s390/kernel/syscalls.S linux-2.6.20.15-vs2.2.0.1/arch/s390/kernel/syscalls.S
--- linux-2.6.20.15/arch/s390/kernel/syscalls.S	2006-11-30 21:18:32 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/s390/kernel/syscalls.S	2007-02-06 03:05:21 +0100
@@ -271,7 +271,7 @@ SYSCALL(sys_clock_settime,sys_clock_sett
 SYSCALL(sys_clock_gettime,sys_clock_gettime,sys32_clock_gettime_wrapper)	/* 260 */
 SYSCALL(sys_clock_getres,sys_clock_getres,sys32_clock_getres_wrapper)
 SYSCALL(sys_clock_nanosleep,sys_clock_nanosleep,sys32_clock_nanosleep_wrapper)
-NI_SYSCALL							/* reserved for vserver */
+SYSCALL(sys_vserver,sys_vserver,sys32_vserver)
 SYSCALL(s390_fadvise64_64,sys_ni_syscall,sys32_fadvise64_64_wrapper)
 SYSCALL(sys_statfs64,sys_statfs64,compat_sys_statfs64_wrapper)
 SYSCALL(sys_fstatfs64,sys_fstatfs64,compat_sys_fstatfs64_wrapper)
diff -NurpP --minimal linux-2.6.20.15/arch/s390/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/s390/mm/fault.c
--- linux-2.6.20.15/arch/s390/mm/fault.c	2007-02-06 03:00:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/s390/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -359,7 +359,8 @@ out_of_memory:
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
-	printk("VM: killing process %s\n", tsk->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		tsk->comm, tsk->pid, tsk->xid);
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		do_exit(SIGKILL);
 	goto no_context;
diff -NurpP --minimal linux-2.6.20.15/arch/sh/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/sh/Kconfig
--- linux-2.6.20.15/arch/sh/Kconfig	2007-02-06 03:00:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sh/Kconfig	2007-02-06 03:05:21 +0100
@@ -709,6 +709,8 @@ source "arch/sh/oprofile/Kconfig"
 
 source "arch/sh/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/sh/kernel/irq.c linux-2.6.20.15-vs2.2.0.1/arch/sh/kernel/irq.c
--- linux-2.6.20.15/arch/sh/kernel/irq.c	2007-02-06 03:00:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sh/kernel/irq.c	2007-02-06 03:09:33 +0100
@@ -13,6 +13,7 @@
 #include <linux/seq_file.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/vs_context.h>
 #include <asm/processor.h>
 #include <asm/uaccess.h>
 #include <asm/thread_info.h>
diff -NurpP --minimal linux-2.6.20.15/arch/sh/kernel/kgdb_stub.c linux-2.6.20.15-vs2.2.0.1/arch/sh/kernel/kgdb_stub.c
--- linux-2.6.20.15/arch/sh/kernel/kgdb_stub.c	2006-11-30 21:18:34 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sh/kernel/kgdb_stub.c	2007-02-06 03:05:21 +0100
@@ -389,7 +389,7 @@ static struct task_struct *get_thread(in
 	if (pid == PID_MAX) pid = 0;
 
 	/* First check via PID */
-	thread = find_task_by_pid(pid);
+	thread = find_task_by_real_pid(pid);
 
 	if (thread)
 		return thread;
diff -NurpP --minimal linux-2.6.20.15/arch/sh/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/sh/kernel/process.c
--- linux-2.6.20.15/arch/sh/kernel/process.c	2007-02-06 03:00:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sh/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -104,7 +104,8 @@ void machine_power_off(void)
 void show_regs(struct pt_regs * regs)
 {
 	printk("\n");
-	printk("Pid : %d, Comm: %20s\n", current->pid, current->comm);
+	printk("Pid : %d:#%u, Comm: %20s\n",
+		current->pid, current->xid, current->comm);
 	print_symbol("PC is at %s\n", instruction_pointer(regs));
 	printk("PC  : %08lx SP  : %08lx SR  : %08lx ",
 	       regs->pc, regs->regs[15], regs->sr);
@@ -164,7 +165,8 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.sr = (1 << 30);
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 
 /*
diff -NurpP --minimal linux-2.6.20.15/arch/sh/kernel/vsyscall/vsyscall.c linux-2.6.20.15-vs2.2.0.1/arch/sh/kernel/vsyscall/vsyscall.c
--- linux-2.6.20.15/arch/sh/kernel/vsyscall/vsyscall.c	2007-02-06 03:00:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sh/kernel/vsyscall/vsyscall.c	2007-02-06 03:05:21 +0100
@@ -17,6 +17,7 @@
 #include <linux/gfp.h>
 #include <linux/module.h>
 #include <linux/elf.h>
+#include <linux/vs_memory.h>
 
 /*
  * Should the kernel map a VDSO page into processes and pass its
@@ -120,7 +121,7 @@ int arch_setup_additional_pages(struct l
 
 	current->mm->context.vdso = (void *)addr;
 
-	mm->total_vm++;
+	vx_vmpages_inc(mm);
 up_fail:
 	up_write(&mm->mmap_sem);
 	return ret;
diff -NurpP --minimal linux-2.6.20.15/arch/sh/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/sh/mm/fault.c
--- linux-2.6.20.15/arch/sh/mm/fault.c	2007-02-06 03:00:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sh/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -202,7 +202,8 @@ out_of_memory:
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
-	printk("VM: killing process %s\n", tsk->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		tsk->comm, tsk->pid, tsk->xid);
 	if (user_mode(regs))
 		do_exit(SIGKILL);
 	goto no_context;
diff -NurpP --minimal linux-2.6.20.15/arch/sh64/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/sh64/kernel/process.c
--- linux-2.6.20.15/arch/sh64/kernel/process.c	2006-11-30 21:18:35 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sh64/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -400,8 +400,8 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.pc = (unsigned long)kernel_thread_helper;
 	regs.sr = (1 << 30);
 
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0,
-		       &regs, 0, NULL, NULL);
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD,
+		0, &regs, 0, NULL, NULL);
 }
 
 /*
diff -NurpP --minimal linux-2.6.20.15/arch/sh64/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/sh64/mm/fault.c
--- linux-2.6.20.15/arch/sh64/mm/fault.c	2007-02-06 03:00:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sh64/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -82,7 +82,7 @@ static inline void print_vma(struct vm_a
 
 static inline void print_task(struct task_struct *tsk)
 {
-	printk("Task pid %d\n", tsk->pid);
+	printk("Task pid %d:#%u\n", tsk->pid, tsk->xid);
 }
 
 static pte_t *lookup_pte(struct mm_struct *mm, unsigned long address)
@@ -331,7 +331,8 @@ out_of_memory:
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
-	printk("VM: killing process %s\n", tsk->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		tsk->comm, tsk->pid, tsk->xid);
 	if (user_mode(regs))
 		do_exit(SIGKILL);
 	goto no_context;
diff -NurpP --minimal linux-2.6.20.15/arch/sparc/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/sparc/Kconfig
--- linux-2.6.20.15/arch/sparc/Kconfig	2007-02-06 03:00:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc/Kconfig	2007-02-06 03:05:21 +0100
@@ -306,6 +306,8 @@ endmenu
 
 source "arch/sparc/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/sparc/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/sparc/kernel/process.c
--- linux-2.6.20.15/arch/sparc/kernel/process.c	2007-02-06 03:00:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -706,7 +706,8 @@ pid_t kernel_thread(int (*fn)(void *), v
 			     /* Notreached by child. */
 			     "1: mov %%o0, %0\n\t" :
 			     "=r" (retval) :
-			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED),
+			     "i" (__NR_clone), "r" (flags |
+					CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD),
 			     "i" (__NR_exit),  "r" (fn), "r" (arg) :
 			     "g1", "g2", "g3", "o0", "o1", "memory", "cc");
 	return retval;
diff -NurpP --minimal linux-2.6.20.15/arch/sparc/kernel/ptrace.c linux-2.6.20.15-vs2.2.0.1/arch/sparc/kernel/ptrace.c
--- linux-2.6.20.15/arch/sparc/kernel/ptrace.c	2007-02-06 03:00:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc/kernel/ptrace.c	2007-06-13 18:46:20 +0200
@@ -19,6 +19,7 @@
 #include <linux/smp_lock.h>
 #include <linux/security.h>
 #include <linux/signal.h>
+#include <linux/vs_base.h>
 
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -302,6 +303,10 @@ asmlinkage void do_ptrace(struct pt_regs
 		pt_error_return(regs, -ret);
 		goto out;
 	}
+	if (!vx_check(vx_task_xid(child), VS_WATCH_P | VS_IDENT)) {
+		pt_error_return(regs, ESRCH);
+		goto out_tsk;
+	}
 
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
diff -NurpP --minimal linux-2.6.20.15/arch/sparc/kernel/systbls.S linux-2.6.20.15-vs2.2.0.1/arch/sparc/kernel/systbls.S
--- linux-2.6.20.15/arch/sparc/kernel/systbls.S	2006-11-30 21:18:35 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc/kernel/systbls.S	2007-02-06 03:05:21 +0100
@@ -71,7 +71,7 @@ sys_call_table:
 /*250*/	.long sparc_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
 /*255*/	.long sys_sync_file_range, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.long sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-/*265*/	.long sys_timer_delete, sys_timer_create, sys_nis_syscall, sys_io_setup, sys_io_destroy
+/*265*/	.long sys_timer_delete, sys_timer_create, sys_vserver, sys_io_setup, sys_io_destroy
 /*270*/	.long sys_io_submit, sys_io_cancel, sys_io_getevents, sys_mq_open, sys_mq_unlink
 /*275*/	.long sys_mq_timedsend, sys_mq_timedreceive, sys_mq_notify, sys_mq_getsetattr, sys_waitid
 /*280*/	.long sys_tee, sys_add_key, sys_request_key, sys_keyctl, sys_openat
diff -NurpP --minimal linux-2.6.20.15/arch/sparc/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/sparc/kernel/traps.c
--- linux-2.6.20.15/arch/sparc/kernel/traps.c	2006-09-20 16:58:06 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -99,7 +99,8 @@ void die_if_kernel(char *str, struct pt_
 "              /_| \\__/ |_\\\n"
 "                 \\__U_/\n");
 
-	printk("%s(%d): %s [#%d]\n", current->comm, current->pid, str, ++die_counter);
+	printk("%s(%d[#%u]): %s [#%d]\n", current->comm,
+		current->pid, current->xid, str, ++die_counter);
 	show_regs(regs);
 
 	__SAVE; __SAVE; __SAVE; __SAVE;
diff -NurpP --minimal linux-2.6.20.15/arch/sparc/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/sparc/mm/fault.c
--- linux-2.6.20.15/arch/sparc/mm/fault.c	2006-01-03 17:29:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -368,7 +368,8 @@ no_context:
  */
 out_of_memory:
 	up_read(&mm->mmap_sem);
-	printk("VM: killing process %s\n", tsk->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		tsk->comm, tsk->pid, tsk->xid);
 	if (from_user)
 		do_exit(SIGKILL);
 	goto no_context;
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/sparc64/Kconfig
--- linux-2.6.20.15/arch/sparc64/Kconfig	2007-02-06 03:00:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/Kconfig	2007-02-06 03:05:21 +0100
@@ -447,6 +447,8 @@ endmenu
 
 source "arch/sparc64/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/kernel/binfmt_aout32.c linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/binfmt_aout32.c
--- linux-2.6.20.15/arch/sparc64/kernel/binfmt_aout32.c	2007-02-06 03:00:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/binfmt_aout32.c	2007-02-06 03:05:21 +0100
@@ -27,6 +27,7 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 #include <linux/init.h>
+#include <linux/vs_memory.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/process.c
--- linux-2.6.20.15/arch/sparc64/kernel/process.c	2006-09-20 16:58:06 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -696,7 +696,8 @@ pid_t kernel_thread(int (*fn)(void *), v
 			     /* Notreached by child. */
 			     "1:" :
 			     "=r" (retval) :
-			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED),
+			     "i" (__NR_clone), "r" (flags |
+				CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD),
 			     "i" (__NR_exit),  "r" (fn), "r" (arg) :
 			     "g1", "g2", "g3", "o0", "o1", "memory", "cc");
 	return retval;
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/kernel/ptrace.c linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/ptrace.c
--- linux-2.6.20.15/arch/sparc64/kernel/ptrace.c	2007-02-06 03:00:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/ptrace.c	2007-06-13 18:46:26 +0200
@@ -22,6 +22,7 @@
 #include <linux/seccomp.h>
 #include <linux/audit.h>
 #include <linux/signal.h>
+#include <linux/vs_base.h>
 
 #include <asm/asi.h>
 #include <asm/pgtable.h>
@@ -215,6 +216,10 @@ asmlinkage void do_ptrace(struct pt_regs
 		pt_error_return(regs, -ret);
 		goto out;
 	}
+	if (!vx_check(vx_task_xid(child), VS_WATCH_P | VS_IDENT)) {
+		pt_error_return(regs, ESRCH);
+		goto out_tsk;
+	}
 
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/kernel/sys_sparc32.c linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/sys_sparc32.c
--- linux-2.6.20.15/arch/sparc64/kernel/sys_sparc32.c	2006-11-30 21:18:35 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/sys_sparc32.c	2007-02-06 03:05:21 +0100
@@ -793,7 +793,7 @@ asmlinkage long sys32_gettimeofday(struc
 {
 	if (tv) {
 		struct timeval ktv;
-		do_gettimeofday(&ktv);
+		vx_gettimeofday(&ktv);
 		if (put_tv32(tv, &ktv))
 			return -EFAULT;
 	}
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/kernel/systbls.S linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/systbls.S
--- linux-2.6.20.15/arch/sparc64/kernel/systbls.S	2007-06-13 01:43:15 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/systbls.S	2007-05-02 19:39:41 +0200
@@ -72,7 +72,7 @@ sys_call_table32:
 /*250*/	.word sys32_mremap, sys32_sysctl, sys32_getsid, sys_fdatasync, sys32_nfsservctl
 	.word sys32_sync_file_range, compat_sys_clock_settime, compat_sys_clock_gettime, compat_sys_clock_getres, sys32_clock_nanosleep
 /*260*/	.word compat_sys_sched_getaffinity, compat_sys_sched_setaffinity, sys32_timer_settime, compat_sys_timer_gettime, sys_timer_getoverrun
-	.word sys_timer_delete, compat_sys_timer_create, sys_ni_syscall, compat_sys_io_setup, sys_io_destroy
+	.word sys_timer_delete, compat_sys_timer_create, sys32_vserver, compat_sys_io_setup, sys_io_destroy
 /*270*/	.word sys32_io_submit, sys_io_cancel, compat_sys_io_getevents, sys32_mq_open, sys_mq_unlink
 	.word compat_sys_mq_timedsend, compat_sys_mq_timedreceive, compat_sys_mq_notify, compat_sys_mq_getsetattr, compat_sys_waitid
 /*280*/	.word sys32_tee, sys_add_key, sys_request_key, sys_keyctl, compat_sys_openat
@@ -142,7 +142,7 @@ sys_call_table:
 /*250*/	.word sys64_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
 	.word sys_sync_file_range, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.word sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-	.word sys_timer_delete, sys_timer_create, sys_ni_syscall, sys_io_setup, sys_io_destroy
+	.word sys_timer_delete, sys_timer_create, sys_vserver, sys_io_setup, sys_io_destroy
 /*270*/	.word sys_io_submit, sys_io_cancel, sys_io_getevents, sys_mq_open, sys_mq_unlink
 	.word sys_mq_timedsend, sys_mq_timedreceive, sys_mq_notify, sys_mq_getsetattr, sys_waitid
 /*280*/	.word sys_tee, sys_add_key, sys_request_key, sys_keyctl, sys_openat
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/traps.c
--- linux-2.6.20.15/arch/sparc64/kernel/traps.c	2007-02-06 03:00:20 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/kernel/traps.c	2007-02-06 03:05:21 +0100
@@ -2233,7 +2233,8 @@ void die_if_kernel(char *str, struct pt_
 "              /_| \\__/ |_\\\n"
 "                 \\__U_/\n");
 
-	printk("%s(%d): %s [#%d]\n", current->comm, current->pid, str, ++die_counter);
+	printk("%s(%d[#%u]): %s [#%d]\n", current->comm,
+		current->pid, current->xid, str, ++die_counter);
 	notify_die(DIE_OOPS, str, regs, 0, 255, SIGSEGV);
 	__asm__ __volatile__("flushw");
 	__show_regs(regs);
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/sparc64/mm/fault.c
--- linux-2.6.20.15/arch/sparc64/mm/fault.c	2006-09-20 16:58:06 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -484,7 +484,8 @@ handle_kernel_fault:
 out_of_memory:
 	insn = get_fault_insn(regs, insn);
 	up_read(&mm->mmap_sem);
-	printk("VM: killing process %s\n", current->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		current->comm, current->pid, current->xid);
 	if (!(regs->tstate & TSTATE_PRIV))
 		do_exit(SIGKILL);
 	goto handle_kernel_fault;
diff -NurpP --minimal linux-2.6.20.15/arch/sparc64/solaris/fs.c linux-2.6.20.15-vs2.2.0.1/arch/sparc64/solaris/fs.c
--- linux-2.6.20.15/arch/sparc64/solaris/fs.c	2007-02-06 03:00:21 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/sparc64/solaris/fs.c	2007-02-06 03:05:21 +0100
@@ -368,7 +368,7 @@ static int report_statvfs(struct vfsmoun
 		int j = strlen (p);
 		
 		if (j > 15) j = 15;
-		if (IS_RDONLY(inode)) i = 1;
+		if (IS_RDONLY(inode) || MNT_IS_RDONLY(mnt)) i = 1;
 		if (mnt->mnt_flags & MNT_NOSUID) i |= 2;
 		if (!sysv_valid_dev(inode->i_sb->s_dev))
 			return -EOVERFLOW;
@@ -404,7 +404,7 @@ static int report_statvfs64(struct vfsmo
 		int j = strlen (p);
 		
 		if (j > 15) j = 15;
-		if (IS_RDONLY(inode)) i = 1;
+		if (IS_RDONLY(inode) || MNT_IS_RDONLY(mnt)) i = 1;
 		if (mnt->mnt_flags & MNT_NOSUID) i |= 2;
 		if (!sysv_valid_dev(inode->i_sb->s_dev))
 			return -EOVERFLOW;
diff -NurpP --minimal linux-2.6.20.15/arch/um/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/um/Kconfig
--- linux-2.6.20.15/arch/um/Kconfig	2007-02-06 03:00:21 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/um/Kconfig	2007-02-06 03:05:21 +0100
@@ -311,6 +311,8 @@ source "drivers/connector/Kconfig"
 
 source "fs/Kconfig"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/um/kernel/trap.c linux-2.6.20.15-vs2.2.0.1/arch/um/kernel/trap.c
--- linux-2.6.20.15/arch/um/kernel/trap.c	2006-11-30 21:18:36 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/um/kernel/trap.c	2007-03-10 18:02:51 +0100
@@ -193,7 +193,8 @@ unsigned long segv(struct faultinfo fi, 
                 current->thread.arch.faultinfo = fi;
 		force_sig_info(SIGBUS, &si, current);
 	} else if (err == -ENOMEM) {
-		printk("VM: killing process %s\n", current->comm);
+		printk("VM: killing process %s(%d:#%u)\n",
+			current->comm, current->pid, current->xid);
 		do_exit(SIGKILL);
 	} else {
 		BUG_ON(err != -EFAULT);
diff -NurpP --minimal linux-2.6.20.15/arch/v850/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/v850/Kconfig
--- linux-2.6.20.15/arch/v850/Kconfig	2007-02-06 03:00:21 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/v850/Kconfig	2007-02-06 03:05:21 +0100
@@ -334,6 +334,8 @@ source "drivers/usb/Kconfig"
 
 source "arch/v850/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/v850/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/v850/kernel/process.c
--- linux-2.6.20.15/arch/v850/kernel/process.c	2006-09-20 16:58:06 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/v850/kernel/process.c	2007-02-06 03:05:21 +0100
@@ -83,7 +83,7 @@ int kernel_thread (int (*fn)(void *), vo
 	/* Clone this thread.  Note that we don't pass the clone syscall's
 	   second argument -- it's ignored for calls from kernel mode (the
 	   child's SP is always set to the top of the kernel stack).  */
-	arg0 = flags | CLONE_VM;
+	arg0 = flags | CLONE_VM | CLONE_KTHREAD;
 	syscall = __NR_clone;
 	asm volatile ("trap " SYSCALL_SHORT_TRAP
 		      : "=r" (ret), "=r" (syscall)
diff -NurpP --minimal linux-2.6.20.15/arch/v850/kernel/ptrace.c linux-2.6.20.15-vs2.2.0.1/arch/v850/kernel/ptrace.c
--- linux-2.6.20.15/arch/v850/kernel/ptrace.c	2006-04-09 13:49:44 +0200
+++ linux-2.6.20.15-vs2.2.0.1/arch/v850/kernel/ptrace.c	2007-06-13 18:46:34 +0200
@@ -24,6 +24,7 @@
 #include <linux/smp_lock.h>
 #include <linux/ptrace.h>
 #include <linux/signal.h>
+#include <linux/vs_base.h>
 
 #include <asm/errno.h>
 #include <asm/ptrace.h>
@@ -117,6 +118,9 @@ long arch_ptrace(struct task_struct *chi
 {
 	int rval;
 
+	if (!vx_check(vx_task_xid(child), VS_WATCH_P | VS_IDENT))
+		goto out;
+
 	switch (request) {
 		unsigned long val, copied;
 
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/Kconfig linux-2.6.20.15-vs2.2.0.1/arch/x86_64/Kconfig
--- linux-2.6.20.15/arch/x86_64/Kconfig	2007-02-06 03:00:21 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/Kconfig	2007-02-06 03:05:21 +0100
@@ -735,6 +735,8 @@ endmenu
 
 source "arch/x86_64/Kconfig.debug"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/ia32/ia32_aout.c linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/ia32_aout.c
--- linux-2.6.20.15/arch/x86_64/ia32/ia32_aout.c	2007-02-06 03:00:21 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/ia32_aout.c	2007-02-06 03:05:21 +0100
@@ -25,6 +25,7 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 #include <linux/init.h>
+#include <linux/vs_memory.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/ia32/ia32_binfmt.c linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.6.20.15/arch/x86_64/ia32/ia32_binfmt.c	2007-02-06 03:00:21 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/ia32_binfmt.c	2007-02-06 03:05:21 +0100
@@ -324,7 +324,8 @@ int ia32_setup_arg_pages(struct linux_bi
 			kmem_cache_free(vm_area_cachep, mpnt);
 			return ret;
 		}
-		mm->stack_vm = mm->total_vm = vma_pages(mpnt);
+		vx_vmpages_sub(mm, mm->total_vm - vma_pages(mpnt));
+		mm->stack_vm = mm->total_vm;
 	} 
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/ia32/ia32entry.S linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/ia32entry.S
--- linux-2.6.20.15/arch/x86_64/ia32/ia32entry.S	2006-11-30 21:18:37 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/ia32entry.S	2007-02-06 03:05:21 +0100
@@ -672,7 +672,7 @@ ia32_sys_call_table:
 	.quad sys_tgkill		/* 270 */
 	.quad compat_sys_utimes
 	.quad sys32_fadvise64_64
-	.quad quiet_ni_syscall	/* sys_vserver */
+	.quad sys32_vserver
 	.quad sys_mbind
 	.quad compat_sys_get_mempolicy	/* 275 */
 	.quad sys_set_mempolicy
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/ia32/sys_ia32.c linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/sys_ia32.c
--- linux-2.6.20.15/arch/x86_64/ia32/sys_ia32.c	2006-11-30 21:18:37 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/sys_ia32.c	2007-02-06 03:05:21 +0100
@@ -454,7 +454,7 @@ sys32_gettimeofday(struct compat_timeval
 {
 	if (tv) {
 		struct timeval ktv;
-		do_gettimeofday(&ktv);
+		vx_gettimeofday(&ktv);
 		if (put_tv32(tv, &ktv))
 			return -EFAULT;
 	}
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/ia32/syscall32.c linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/syscall32.c
--- linux-2.6.20.15/arch/x86_64/ia32/syscall32.c	2007-02-06 03:00:21 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/ia32/syscall32.c	2007-02-06 03:05:21 +0100
@@ -10,6 +10,7 @@
 #include <linux/init.h>
 #include <linux/stringify.h>
 #include <linux/security.h>
+#include <linux/vs_memory.h>
 #include <asm/proto.h>
 #include <asm/tlbflush.h>
 #include <asm/ia32_unistd.h>
@@ -77,7 +78,7 @@ int syscall32_setup_pages(struct linux_b
 		kmem_cache_free(vm_area_cachep, vma);
 		return ret;
 	}
-	mm->total_vm += npages;
+	vx_vmpages_add(mm, npages);
 	up_write(&mm->mmap_sem);
 	return 0;
 }
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/kernel/process.c linux-2.6.20.15-vs2.2.0.1/arch/x86_64/kernel/process.c
--- linux-2.6.20.15/arch/x86_64/kernel/process.c	2007-02-06 03:00:22 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/kernel/process.c	2007-02-06 03:05:22 +0100
@@ -54,7 +54,8 @@
 
 asmlinkage extern void ret_from_fork(void);
 
-unsigned long kernel_thread_flags = CLONE_VM | CLONE_UNTRACED;
+unsigned long kernel_thread_flags =
+	CLONE_VM | CLONE_UNTRACED | CLONE_KTHREAD;
 
 unsigned long boot_option_idle_override = 0;
 EXPORT_SYMBOL(boot_option_idle_override);
@@ -308,8 +309,8 @@ void __show_regs(struct pt_regs * regs)
 
 	printk("\n");
 	print_modules();
-	printk("Pid: %d, comm: %.20s %s %s %.*s\n",
-		current->pid, current->comm, print_tainted(),
+	printk("Pid: %d:#%u, comm: %.20s %s %s %.*s\n",
+		current->pid, current->xid, current->comm, print_tainted(),
 		init_utsname()->release,
 		(int)strcspn(init_utsname()->version, " "),
 		init_utsname()->version);
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/kernel/traps.c linux-2.6.20.15-vs2.2.0.1/arch/x86_64/kernel/traps.c
--- linux-2.6.20.15/arch/x86_64/kernel/traps.c	2007-02-06 03:00:22 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/kernel/traps.c	2007-02-06 03:05:22 +0100
@@ -430,8 +430,9 @@ void show_registers(struct pt_regs *regs
 
 	printk("CPU %d ", cpu);
 	__show_regs(regs);
-	printk("Process %s (pid: %d, threadinfo %p, task %p)\n",
-		cur->comm, cur->pid, task_thread_info(cur), cur);
+	printk("Process %s (pid: %d[#%u], threadinfo %p, task %p)\n",
+		cur->comm, cur->pid, cur->xid,
+		task_thread_info(cur), cur);
 
 	/*
 	 * When in-kernel, we also print out the stack and code at the
@@ -587,8 +588,8 @@ static void __kprobes do_trap(int trapnr
 	if (user_mode(regs)) {
 		if (exception_trace && unhandled_signal(tsk, signr))
 			printk(KERN_INFO
-			       "%s[%d] trap %s rip:%lx rsp:%lx error:%lx\n",
-			       tsk->comm, tsk->pid, str,
+			       "%s[%d:#%u] trap %s rip:%lx rsp:%lx error:%lx\n",
+			       tsk->comm, tsk->pid, tsk->xid, str,
 			       regs->rip, regs->rsp, error_code); 
 
 		if (info)
@@ -688,8 +689,8 @@ asmlinkage void __kprobes do_general_pro
 	if (user_mode(regs)) {
 		if (exception_trace && unhandled_signal(tsk, SIGSEGV))
 			printk(KERN_INFO
-		       "%s[%d] general protection rip:%lx rsp:%lx error:%lx\n",
-			       tsk->comm, tsk->pid,
+		       "%s[%d:#%u] general protection rip:%lx rsp:%lx error:%lx\n",
+			       tsk->comm, tsk->pid, tsk->xid,
 			       regs->rip, regs->rsp, error_code); 
 
 		force_sig(SIGSEGV, tsk);
diff -NurpP --minimal linux-2.6.20.15/arch/x86_64/mm/fault.c linux-2.6.20.15-vs2.2.0.1/arch/x86_64/mm/fault.c
--- linux-2.6.20.15/arch/x86_64/mm/fault.c	2007-02-06 03:00:22 +0100
+++ linux-2.6.20.15-vs2.2.0.1/arch/x86_64/mm/fault.c	2007-03-10 18:02:51 +0100
@@ -514,10 +514,10 @@ bad_area_nosemaphore:
 
 		if (exception_trace && unhandled_signal(tsk, SIGSEGV)) {
 			printk(
-		       "%s%s[%d]: segfault at %016lx rip %016lx rsp %016lx error %lx\n",
+		       "%s%s[%d:#%u]: segfault at %016lx rip %016lx rsp %016lx error %lx\n",
 					tsk->pid > 1 ? KERN_INFO : KERN_EMERG,
-					tsk->comm, tsk->pid, address, regs->rip,
-					regs->rsp, error_code);
+					tsk->comm, tsk->pid, tsk->xid, address,
+					regs->rip, regs->rsp, error_code);
 		}
        
 		tsk->thread.cr2 = address;
@@ -584,7 +584,8 @@ out_of_memory:
 		yield();
 		goto again;
 	}
-	printk("VM: killing process %s\n", tsk->comm);
+	printk("VM: killing process %s(%d:#%u)\n",
+		tsk->comm, tsk->pid, tsk->xid);
 	if (error_code & 4)
 		do_exit(SIGKILL);
 	goto no_context;
diff -NurpP --minimal linux-2.6.20.15/block/cfq-iosched.c linux-2.6.20.15-vs2.2.0.1/block/cfq-iosched.c
--- linux-2.6.20.15/block/cfq-iosched.c	2007-06-13 01:43:16 +0200
+++ linux-2.6.20.15-vs2.2.0.1/block/cfq-iosched.c	2007-05-02 19:39:41 +0200
@@ -221,6 +221,8 @@ static int cfq_queue_empty(request_queue
 
 static inline pid_t cfq_queue_pid(struct task_struct *task, int rw, int is_sync)
 {
+	if (task->xid)
+		return task->xid + (1 << 16);
 	/*
 	 * Use the per-process queue, for read requests and syncronous writes
 	 */
diff -NurpP --minimal linux-2.6.20.15/block/ll_rw_blk.c linux-2.6.20.15-vs2.2.0.1/block/ll_rw_blk.c
--- linux-2.6.20.15/block/ll_rw_blk.c	2007-06-13 01:43:16 +0200
+++ linux-2.6.20.15-vs2.2.0.1/block/ll_rw_blk.c	2007-06-24 18:53:40 +0200
@@ -30,6 +30,7 @@
 #include <linux/cpu.h>
 #include <linux/blktrace_api.h>
 #include <linux/fault-inject.h>
+#include <linux/vs_diskio.h>
 
 /*
  * for max sense size
@@ -2674,6 +2675,8 @@ static void drive_stat_acct(struct reque
 		disk_round_stats(rq->rq_disk);
 		rq->rq_disk->in_flight++;
 	}
+
+	vx_acc_diskio(current_vx_info(), rw, new_io, nr_sectors);
 }
 
 /*
diff -NurpP --minimal linux-2.6.20.15/drivers/block/Kconfig linux-2.6.20.15-vs2.2.0.1/drivers/block/Kconfig
--- linux-2.6.20.15/drivers/block/Kconfig	2007-02-06 03:00:26 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/block/Kconfig	2007-02-06 03:05:22 +0100
@@ -311,6 +311,13 @@ config BLK_DEV_CRYPTOLOOP
 	  instead, which can be configured to be on-disk compatible with the
 	  cryptoloop device.
 
+config BLK_DEV_VROOT
+	tristate "Virtual Root device support"
+	depends on QUOTACTL
+	---help---
+	  Saying Y here will allow you to use quota/fs ioctls on a shared
+	  partition within a virtual server without compromising security.
+
 config BLK_DEV_NBD
 	tristate "Network block device support"
 	depends on NET
diff -NurpP --minimal linux-2.6.20.15/drivers/block/Makefile linux-2.6.20.15-vs2.2.0.1/drivers/block/Makefile
--- linux-2.6.20.15/drivers/block/Makefile	2007-02-06 03:00:26 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/block/Makefile	2007-02-06 03:05:22 +0100
@@ -28,4 +28,5 @@ obj-$(CONFIG_BLK_DEV_CRYPTOLOOP) += cryp
 obj-$(CONFIG_VIODASD)		+= viodasd.o
 obj-$(CONFIG_BLK_DEV_SX8)	+= sx8.o
 obj-$(CONFIG_BLK_DEV_UB)	+= ub.o
+obj-$(CONFIG_BLK_DEV_VROOT)	+= vroot.o
 
diff -NurpP --minimal linux-2.6.20.15/drivers/block/loop.c linux-2.6.20.15-vs2.2.0.1/drivers/block/loop.c
--- linux-2.6.20.15/drivers/block/loop.c	2007-02-06 03:00:26 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/block/loop.c	2007-02-15 00:06:27 +0100
@@ -74,6 +74,7 @@
 #include <linux/highmem.h>
 #include <linux/gfp.h>
 #include <linux/kthread.h>
+#include <linux/vs_context.h>
 
 #include <asm/uaccess.h>
 
@@ -795,6 +796,7 @@ static int loop_set_fd(struct loop_devic
 	lo->lo_blocksize = lo_blocksize;
 	lo->lo_device = bdev;
 	lo->lo_flags = lo_flags;
+	lo->lo_xid = vx_current_xid();
 	lo->lo_backing_file = file;
 	lo->transfer = transfer_none;
 	lo->ioctl = NULL;
@@ -935,7 +937,7 @@ loop_set_status(struct loop_device *lo, 
 	struct loop_func_table *xfer;
 
 	if (lo->lo_encrypt_key_size && lo->lo_key_owner != current->uid &&
-	    !capable(CAP_SYS_ADMIN))
+	    !vx_capable(CAP_SYS_ADMIN, VXC_ADMIN_CLOOP))
 		return -EPERM;
 	if (lo->lo_state != Lo_bound)
 		return -ENXIO;
@@ -1015,7 +1017,8 @@ loop_get_status(struct loop_device *lo, 
 	memcpy(info->lo_crypt_name, lo->lo_crypt_name, LO_NAME_SIZE);
 	info->lo_encrypt_type =
 		lo->lo_encryption ? lo->lo_encryption->number : 0;
-	if (lo->lo_encrypt_key_size && capable(CAP_SYS_ADMIN)) {
+	if (lo->lo_encrypt_key_size &&
+		vx_capable(CAP_SYS_ADMIN, VXC_ADMIN_CLOOP)) {
 		info->lo_encrypt_key_size = lo->lo_encrypt_key_size;
 		memcpy(info->lo_encrypt_key, lo->lo_encrypt_key,
 		       lo->lo_encrypt_key_size);
@@ -1326,6 +1329,9 @@ static int lo_open(struct inode *inode, 
 {
 	struct loop_device *lo = inode->i_bdev->bd_disk->private_data;
 
+	if (!vx_check(lo->lo_xid, VS_IDENT|VS_HOSTID))
+		return -EACCES;
+
 	mutex_lock(&lo->lo_ctl_mutex);
 	lo->lo_refcnt++;
 	mutex_unlock(&lo->lo_ctl_mutex);
diff -NurpP --minimal linux-2.6.20.15/drivers/block/vroot.c linux-2.6.20.15-vs2.2.0.1/drivers/block/vroot.c
--- linux-2.6.20.15/drivers/block/vroot.c	1970-01-01 01:00:00 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/block/vroot.c	2007-06-13 19:18:14 +0200
@@ -0,0 +1,281 @@
+/*
+ *  linux/drivers/block/vroot.c
+ *
+ *  written by Herbert Pötzl, 9/11/2002
+ *  ported to 2.6.10 by Herbert Pötzl, 30/12/2004
+ *
+ *  based on the loop.c code by Theodore Ts'o.
+ *
+ * Copyright (C) 2002-2007 by Herbert Pötzl.
+ * Redistribution of this file is permitted under the
+ * GNU General Public License.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/file.h>
+#include <linux/major.h>
+#include <linux/blkdev.h>
+
+#include <linux/vroot.h>
+#include <linux/vs_context.h>
+
+
+static int max_vroot = 8;
+
+static struct vroot_device *vroot_dev;
+static struct gendisk **disks;
+
+
+static int vroot_set_dev(
+	struct vroot_device *vr,
+	struct file *vr_file,
+	struct block_device *bdev,
+	unsigned int arg)
+{
+	struct block_device *real_bdev;
+	struct file *file;
+	struct inode *inode;
+	int error;
+
+	error = -EBUSY;
+	if (vr->vr_state != Vr_unbound)
+		goto out;
+
+	error = -EBADF;
+	file = fget(arg);
+	if (!file)
+		goto out;
+
+	error = -EINVAL;
+	inode = file->f_dentry->d_inode;
+
+
+	if (S_ISBLK(inode->i_mode)) {
+		real_bdev = inode->i_bdev;
+		vr->vr_device = real_bdev;
+		__iget(real_bdev->bd_inode);
+	} else
+		goto out_fput;
+
+	vxdprintk(VXD_CBIT(misc, 0),
+		"vroot[%d]_set_dev: dev=" VXF_DEV,
+		vr->vr_number, VXD_DEV(real_bdev));
+
+	vr->vr_state = Vr_bound;
+	error = 0;
+
+ out_fput:
+	fput(file);
+ out:
+	return error;
+}
+
+static int vroot_clr_dev(
+	struct vroot_device *vr,
+	struct file *vr_file,
+	struct block_device *bdev)
+{
+	struct block_device *real_bdev;
+
+	if (vr->vr_state != Vr_bound)
+		return -ENXIO;
+	if (vr->vr_refcnt > 1)	/* we needed one fd for the ioctl */
+		return -EBUSY;
+
+	real_bdev = vr->vr_device;
+
+	vxdprintk(VXD_CBIT(misc, 0),
+		"vroot[%d]_clr_dev: dev=" VXF_DEV,
+		vr->vr_number, VXD_DEV(real_bdev));
+
+	bdput(real_bdev);
+	vr->vr_state = Vr_unbound;
+	vr->vr_device = NULL;
+	return 0;
+}
+
+
+static int vr_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	struct vroot_device *vr = inode->i_bdev->bd_disk->private_data;
+	int err;
+
+	down(&vr->vr_ctl_mutex);
+	switch (cmd) {
+	case VROOT_SET_DEV:
+		err = vroot_set_dev(vr, file, inode->i_bdev, arg);
+		break;
+	case VROOT_CLR_DEV:
+		err = vroot_clr_dev(vr, file, inode->i_bdev);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	up(&vr->vr_ctl_mutex);
+	return err;
+}
+
+static int vr_open(struct inode *inode, struct file *file)
+{
+	struct vroot_device *vr = inode->i_bdev->bd_disk->private_data;
+
+	down(&vr->vr_ctl_mutex);
+	vr->vr_refcnt++;
+	up(&vr->vr_ctl_mutex);
+	return 0;
+}
+
+static int vr_release(struct inode *inode, struct file *file)
+{
+	struct vroot_device *vr = inode->i_bdev->bd_disk->private_data;
+
+	down(&vr->vr_ctl_mutex);
+	--vr->vr_refcnt;
+	up(&vr->vr_ctl_mutex);
+	return 0;
+}
+
+static struct block_device_operations vr_fops = {
+	.owner =	THIS_MODULE,
+	.open =		vr_open,
+	.release =	vr_release,
+	.ioctl =	vr_ioctl,
+};
+
+struct block_device *__vroot_get_real_bdev(struct block_device *bdev)
+{
+	struct inode *inode = bdev->bd_inode;
+	struct vroot_device *vr;
+	struct block_device *real_bdev;
+	int minor = iminor(inode);
+
+	vr = &vroot_dev[minor];
+	real_bdev = vr->vr_device;
+
+	vxdprintk(VXD_CBIT(misc, 0),
+		"vroot[%d]_get_real_bdev: dev=" VXF_DEV,
+		vr->vr_number, VXD_DEV(real_bdev));
+
+	if (vr->vr_state != Vr_bound)
+		return ERR_PTR(-ENXIO);
+
+	__iget(real_bdev->bd_inode);
+	return real_bdev;
+}
+
+/*
+ * And now the modules code and kernel interface.
+ */
+
+module_param(max_vroot, int, 0);
+
+MODULE_PARM_DESC(max_vroot, "Maximum number of vroot devices (1-256)");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_BLOCKDEV_MAJOR(VROOT_MAJOR);
+
+MODULE_AUTHOR ("Herbert Pötzl");
+MODULE_DESCRIPTION ("Virtual Root Device Mapper");
+
+
+int __init vroot_init(void)
+{
+	int err, i;
+
+	if (max_vroot < 1 || max_vroot > 256) {
+		max_vroot = MAX_VROOT_DEFAULT;
+		printk(KERN_WARNING "vroot: invalid max_vroot "
+			"(must be between 1 and 256), "
+			"using default (%d)\n", max_vroot);
+	}
+
+	if (register_blkdev(VROOT_MAJOR, "vroot"))
+		return -EIO;
+
+	err = -ENOMEM;
+	vroot_dev = kmalloc(max_vroot * sizeof(struct vroot_device), GFP_KERNEL);
+	if (!vroot_dev)
+		goto out_mem1;
+	memset(vroot_dev, 0, max_vroot * sizeof(struct vroot_device));
+
+	disks = kmalloc(max_vroot * sizeof(struct gendisk *), GFP_KERNEL);
+	if (!disks)
+		goto out_mem2;
+
+	for (i = 0; i < max_vroot; i++) {
+		disks[i] = alloc_disk(1);
+		if (!disks[i])
+			goto out_mem3;
+	}
+
+	for (i = 0; i < max_vroot; i++) {
+		struct vroot_device *vr = &vroot_dev[i];
+		struct gendisk *disk = disks[i];
+
+		memset(vr, 0, sizeof(*vr));
+		init_MUTEX(&vr->vr_ctl_mutex);
+		vr->vr_number = i;
+		disk->major = VROOT_MAJOR;
+		disk->first_minor = i;
+		disk->fops = &vr_fops;
+		sprintf(disk->disk_name, "vroot%d", i);
+		disk->private_data = vr;
+	}
+
+	err = register_vroot_grb(&__vroot_get_real_bdev);
+	if (err)
+		goto out_mem3;
+
+	for (i = 0; i < max_vroot; i++)
+		add_disk(disks[i]);
+	printk(KERN_INFO "vroot: loaded (max %d devices)\n", max_vroot);
+	return 0;
+
+out_mem3:
+	while (i--)
+		put_disk(disks[i]);
+	kfree(disks);
+out_mem2:
+	kfree(vroot_dev);
+out_mem1:
+	unregister_blkdev(VROOT_MAJOR, "vroot");
+	printk(KERN_ERR "vroot: ran out of memory\n");
+	return err;
+}
+
+void vroot_exit(void)
+{
+	int i;
+
+	if (unregister_vroot_grb(&__vroot_get_real_bdev))
+		printk(KERN_WARNING "vroot: cannot unregister grb\n");
+
+	for (i = 0; i < max_vroot; i++) {
+		del_gendisk(disks[i]);
+		put_disk(disks[i]);
+	}
+	if (unregister_blkdev(VROOT_MAJOR, "vroot"))
+		printk(KERN_WARNING "vroot: cannot unregister blkdev\n");
+
+	kfree(disks);
+	kfree(vroot_dev);
+}
+
+module_init(vroot_init);
+module_exit(vroot_exit);
+
+#ifndef MODULE
+
+static int __init max_vroot_setup(char *str)
+{
+	max_vroot = simple_strtol(str, NULL, 0);
+	return 1;
+}
+
+__setup("max_vroot=", max_vroot_setup);
+
+#endif
+
diff -NurpP --minimal linux-2.6.20.15/drivers/char/sysrq.c linux-2.6.20.15-vs2.2.0.1/drivers/char/sysrq.c
--- linux-2.6.20.15/drivers/char/sysrq.c	2007-02-06 03:00:34 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/char/sysrq.c	2007-02-06 03:12:21 +0100
@@ -36,6 +36,7 @@
 #include <linux/workqueue.h>
 #include <linux/kexec.h>
 #include <linux/irq.h>
+#include <linux/vserver/debug.h>
 
 #include <asm/ptrace.h>
 #include <asm/irq_regs.h>
@@ -299,6 +300,21 @@ static struct sysrq_key_op sysrq_unrt_op
 	.enable_mask	= SYSRQ_ENABLE_RTNICE,
 };
 
+
+#ifdef CONFIG_VSERVER_DEBUG
+static void sysrq_handle_vxinfo(int key, struct tty_struct *tty)
+{
+	dump_vx_info_inactive((key == 'x')?0:1);
+}
+
+static struct sysrq_key_op sysrq_showvxinfo_op = {
+	.handler	= sysrq_handle_vxinfo,
+	.help_msg	= "conteXt",
+	.action_msg	= "Show Context Info",
+	.enable_mask	= SYSRQ_ENABLE_DUMP,
+};
+#endif
+
 /* Key Operations table and lock */
 static DEFINE_SPINLOCK(sysrq_key_table_lock);
 
@@ -347,7 +363,11 @@ static struct sysrq_key_op *sysrq_key_ta
 	/* x: May be registered on ppc/powerpc for xmon */
 	NULL,				/* x */
 	NULL,				/* y */
-	NULL				/* z */
+#ifdef CONFIG_VSERVER_DEBUG
+	&sysrq_showvxinfo_op,		/* z */
+#else
+	NULL,				/* z */
+#endif
 };
 
 /* key2index calculation, -1 on invalid index */
@@ -359,6 +379,8 @@ static int sysrq_key_table_key2index(int
 		retval = key - '0';
 	else if ((key >= 'a') && (key <= 'z'))
 		retval = key + 10 - 'a';
+	else if ((key >= 'A') && (key <= 'Z'))
+		retval = key + 10 - 'A';
 	else
 		retval = -1;
 	return retval;
diff -NurpP --minimal linux-2.6.20.15/drivers/char/tty_io.c linux-2.6.20.15-vs2.2.0.1/drivers/char/tty_io.c
--- linux-2.6.20.15/drivers/char/tty_io.c	2007-06-13 01:43:16 +0200
+++ linux-2.6.20.15-vs2.2.0.1/drivers/char/tty_io.c	2007-03-25 21:43:54 +0200
@@ -103,6 +103,7 @@
 #include <linux/selection.h>
 
 #include <linux/kmod.h>
+#include <linux/vs_pid.h>
 
 #undef TTY_DEBUG_HANGUP
 
@@ -185,6 +186,7 @@ static inline void free_tty_struct(struc
 {
 	kfree(tty->write_buf);
 	tty_buffer_free_all(tty);
+	memset(tty, 0xDEADDEAD, sizeof(struct tty_struct));
 	kfree(tty);
 }
 
@@ -2978,13 +2980,16 @@ unlock:
 
 static int tiocgpgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)
 {
+	pid_t pgrp;
 	/*
 	 * (tty == real_tty) is a cheap way of
 	 * testing if the tty is NOT a master pty.
 	 */
 	if (tty == real_tty && current->signal->tty != real_tty)
 		return -ENOTTY;
-	return put_user(real_tty->pgrp, p);
+
+	pgrp = vx_map_pid(real_tty->pgrp);
+	return put_user(pgrp, p);
 }
 
 /**
@@ -3014,6 +3019,8 @@ static int tiocspgrp(struct tty_struct *
 		return -ENOTTY;
 	if (get_user(pgrp, p))
 		return -EFAULT;
+
+	pgrp = vx_rmap_pid(pgrp);
 	if (pgrp < 0)
 		return -EINVAL;
 	if (session_of_pgrp(pgrp) != process_session(current))
@@ -3788,6 +3795,9 @@ EXPORT_SYMBOL(tty_unregister_driver);
 
 dev_t tty_devnum(struct tty_struct *tty)
 {
+	WARN_ON(!tty);
+	WARN_ON(!tty->magic);
+	WARN_ON(!tty->driver);
 	return MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;
 }
 EXPORT_SYMBOL(tty_devnum);
diff -NurpP --minimal linux-2.6.20.15/drivers/infiniband/core/uverbs_mem.c linux-2.6.20.15-vs2.2.0.1/drivers/infiniband/core/uverbs_mem.c
--- linux-2.6.20.15/drivers/infiniband/core/uverbs_mem.c	2007-02-06 03:00:37 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/infiniband/core/uverbs_mem.c	2007-02-06 03:05:22 +0100
@@ -36,6 +36,7 @@
 
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
+#include <linux/vs_memory.h>
 
 #include "uverbs.h"
 
@@ -161,7 +162,7 @@ out:
 	if (ret < 0)
 		__ib_umem_release(dev, mem, 0);
 	else
-		current->mm->locked_vm = locked;
+		vx_vmlocked_sub(current->mm, current->mm->locked_vm - locked);
 
 	up_write(&current->mm->mmap_sem);
 	free_page((unsigned long) page_list);
@@ -174,8 +175,8 @@ void ib_umem_release(struct ib_device *d
 	__ib_umem_release(dev, umem, 1);
 
 	down_write(&current->mm->mmap_sem);
-	current->mm->locked_vm -=
-		PAGE_ALIGN(umem->length + umem->offset) >> PAGE_SHIFT;
+	vx_vmlocked_sub(current->mm,
+		PAGE_ALIGN(umem->length + umem->offset) >> PAGE_SHIFT);
 	up_write(&current->mm->mmap_sem);
 }
 
@@ -185,7 +186,7 @@ static void ib_umem_account(struct work_
 		container_of(_work, struct ib_umem_account_work, work);
 
 	down_write(&work->mm->mmap_sem);
-	work->mm->locked_vm -= work->diff;
+	vx_vmlocked_sub(work->mm, work->diff);
 	up_write(&work->mm->mmap_sem);
 	mmput(work->mm);
 	kfree(work);
diff -NurpP --minimal linux-2.6.20.15/drivers/infiniband/hw/ipath/ipath_user_pages.c linux-2.6.20.15-vs2.2.0.1/drivers/infiniband/hw/ipath/ipath_user_pages.c
--- linux-2.6.20.15/drivers/infiniband/hw/ipath/ipath_user_pages.c	2007-02-06 03:00:37 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/infiniband/hw/ipath/ipath_user_pages.c	2007-02-06 03:05:22 +0100
@@ -33,6 +33,7 @@
 
 #include <linux/mm.h>
 #include <linux/device.h>
+#include <linux/vs_memory.h>
 
 #include "ipath_kernel.h"
 
@@ -61,7 +62,8 @@ static int __get_user_pages(unsigned lon
 	lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur >>
 		PAGE_SHIFT;
 
-	if (num_pages > lock_limit) {
+	if (num_pages > lock_limit ||
+		!vx_vmlocked_avail(current->mm, num_pages)) {
 		ret = -ENOMEM;
 		goto bail;
 	}
@@ -78,7 +80,7 @@ static int __get_user_pages(unsigned lon
 			goto bail_release;
 	}
 
-	current->mm->locked_vm += num_pages;
+	vx_vmlocked_add(current->mm, num_pages);
 
 	ret = 0;
 	goto bail;
@@ -203,7 +205,7 @@ void ipath_release_user_pages(struct pag
 
 	__ipath_release_user_pages(p, num_pages, 1);
 
-	current->mm->locked_vm -= num_pages;
+	vx_vmlocked_sub(current->mm, num_pages);
 
 	up_write(&current->mm->mmap_sem);
 }
@@ -220,7 +222,7 @@ static void user_pages_account(struct wo
 		container_of(_work, struct ipath_user_pages_work, work);
 
 	down_write(&work->mm->mmap_sem);
-	work->mm->locked_vm -= work->num_pages;
+	vx_vmlocked_sub(work->mm, work->num_pages);
 	up_write(&work->mm->mmap_sem);
 	mmput(work->mm);
 	kfree(work);
diff -NurpP --minimal linux-2.6.20.15/drivers/md/dm-ioctl.c linux-2.6.20.15-vs2.2.0.1/drivers/md/dm-ioctl.c
--- linux-2.6.20.15/drivers/md/dm-ioctl.c	2007-02-06 03:00:41 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/md/dm-ioctl.c	2007-06-13 18:47:12 +0200
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/dm-ioctl.h>
 #include <linux/hdreg.h>
+#include <linux/vs_context.h>
 
 #include <asm/uaccess.h>
 
@@ -100,7 +101,8 @@ static struct hash_cell *__get_name_cell
 	unsigned int h = hash_str(str);
 
 	list_for_each_entry (hc, _name_buckets + h, name_list)
-		if (!strcmp(hc->name, str)) {
+		if (vx_check(dm_get_xid(hc->md), VS_WATCH_P | VS_IDENT) &&
+			!strcmp(hc->name, str)) {
 			dm_get(hc->md);
 			return hc;
 		}
@@ -114,7 +116,8 @@ static struct hash_cell *__get_uuid_cell
 	unsigned int h = hash_str(str);
 
 	list_for_each_entry (hc, _uuid_buckets + h, uuid_list)
-		if (!strcmp(hc->uuid, str)) {
+		if (vx_check(dm_get_xid(hc->md), VS_WATCH_P | VS_IDENT) &&
+			!strcmp(hc->uuid, str)) {
 			dm_get(hc->md);
 			return hc;
 		}
@@ -349,6 +352,9 @@ typedef int (*ioctl_fn)(struct dm_ioctl 
 
 static int remove_all(struct dm_ioctl *param, size_t param_size)
 {
+	if (!vx_check(0, VS_ADMIN))
+		return -EPERM;
+
 	dm_hash_remove_all(1);
 	param->data_size = 0;
 	return 0;
@@ -396,6 +402,8 @@ static int list_devices(struct dm_ioctl 
 	 */
 	for (i = 0; i < NUM_BUCKETS; i++) {
 		list_for_each_entry (hc, _name_buckets + i, name_list) {
+			if (!vx_check(dm_get_xid(hc->md), VS_WATCH_P | VS_IDENT))
+				continue;
 			needed += sizeof(struct dm_name_list);
 			needed += strlen(hc->name) + 1;
 			needed += ALIGN_MASK;
@@ -419,6 +427,8 @@ static int list_devices(struct dm_ioctl 
 	 */
 	for (i = 0; i < NUM_BUCKETS; i++) {
 		list_for_each_entry (hc, _name_buckets + i, name_list) {
+			if (!vx_check(dm_get_xid(hc->md), VS_WATCH_P | VS_IDENT))
+				continue;
 			if (old_nl)
 				old_nl->next = (uint32_t) ((void *) nl -
 							   (void *) old_nl);
@@ -609,10 +619,11 @@ static struct hash_cell *__find_device_h
 	if (!md)
 		goto out;
 
-	mdptr = dm_get_mdptr(md);
+	if (vx_check(dm_get_xid(md), VS_WATCH_P | VS_IDENT))
+		mdptr = dm_get_mdptr(md);
+
 	if (!mdptr)
 		dm_put(md);
-
 out:
 	return mdptr;
 }
@@ -1409,8 +1420,8 @@ static int ctl_ioctl(struct inode *inode
 	ioctl_fn fn = NULL;
 	size_t param_size;
 
-	/* only root can play with this */
-	if (!capable(CAP_SYS_ADMIN))
+	/* only root and certain contexts can play with this */
+	if (!vx_capable(CAP_SYS_ADMIN, VXC_ADMIN_MAPPER))
 		return -EACCES;
 
 	if (_IOC_TYPE(command) != DM_IOCTL)
diff -NurpP --minimal linux-2.6.20.15/drivers/md/dm.c linux-2.6.20.15-vs2.2.0.1/drivers/md/dm.c
--- linux-2.6.20.15/drivers/md/dm.c	2007-02-06 03:00:41 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/md/dm.c	2007-02-15 00:06:27 +0100
@@ -21,6 +21,7 @@
 #include <linux/hdreg.h>
 #include <linux/blktrace_api.h>
 #include <linux/smp_lock.h>
+#include <linux/vs_base.h>
 
 #define DM_MSG_PREFIX "core"
 
@@ -77,6 +78,7 @@ struct mapped_device {
 	rwlock_t map_lock;
 	atomic_t holders;
 	atomic_t open_count;
+	xid_t xid;
 
 	unsigned long flags;
 
@@ -223,6 +225,7 @@ static void __exit dm_exit(void)
 static int dm_blk_open(struct inode *inode, struct file *file)
 {
 	struct mapped_device *md;
+	int ret = -ENXIO;
 
 	spin_lock(&_minor_lock);
 
@@ -231,18 +234,19 @@ static int dm_blk_open(struct inode *ino
 		goto out;
 
 	if (test_bit(DMF_FREEING, &md->flags) ||
-	    test_bit(DMF_DELETING, &md->flags)) {
-		md = NULL;
+	    test_bit(DMF_DELETING, &md->flags))
+		goto out;
+
+	ret = -EACCES;
+	if (!vx_check(md->xid, VS_IDENT|VS_HOSTID))
 		goto out;
-	}
 
 	dm_get(md);
 	atomic_inc(&md->open_count);
-
+	ret = 0;
 out:
 	spin_unlock(&_minor_lock);
-
-	return md ? 0 : -ENXIO;
+	return ret;
 }
 
 static int dm_blk_close(struct inode *inode, struct file *file)
@@ -438,6 +442,14 @@ int dm_set_geometry(struct mapped_device
 	return 0;
 }
 
+/*
+ * Get the xid associated with a dm device
+ */
+xid_t dm_get_xid(struct mapped_device *md)
+{
+	return md->xid;
+}
+
 /*-----------------------------------------------------------------
  * CRUD START:
  *   A more elegant soln is in the works that uses the queue
@@ -991,6 +1003,7 @@ static struct mapped_device *alloc_dev(i
 	atomic_set(&md->holders, 1);
 	atomic_set(&md->open_count, 0);
 	atomic_set(&md->event_nr, 0);
+	md->xid = vx_current_xid();
 
 	md->queue = blk_alloc_queue(GFP_KERNEL);
 	if (!md->queue)
diff -NurpP --minimal linux-2.6.20.15/drivers/md/dm.h linux-2.6.20.15-vs2.2.0.1/drivers/md/dm.h
--- linux-2.6.20.15/drivers/md/dm.h	2007-02-06 03:00:41 +0100
+++ linux-2.6.20.15-vs2.2.0.1/drivers/md/dm.h	2007-02-06 03:05:22 +0100
@@ -91,6 +91,8 @@ void dm_put_target_type(struct target_ty
 int dm_target_iterate(void (*iter_func)(struct target_type *tt,
 					void *param), void *param);
 
+xid_t dm_get_xid(struct mapped_device *md);
+
 /*-----------------------------------------------------------------
  * Useful inlines.
  *---------------------------------------------------------------*/
diff -NurpP --minimal linux-2.6.20.15/fs/attr.c linux-2.6.20.15-vs2.2.0.1/fs/attr.c
--- linux-2.6.20.15/fs/attr.c	2006-04-09 13:49:53 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/attr.c	2007-02-06 03:05:22 +0100
@@ -15,6 +15,9 @@
 #include <linux/fcntl.h>
 #include <linux/quotaops.h>
 #include <linux/security.h>
+#include <linux/proc_fs.h>
+#include <linux/devpts_fs.h>
+#include <linux/vs_base.h>
 
 /* Taken over from the old code... */
 
@@ -56,6 +59,30 @@ int inode_change_ok(struct inode *inode,
 		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
 			goto error;
 	}
+
+	/* Check for evil vserver activity */
+	if (vx_check(0, VS_ADMIN))
+		goto fine;
+
+	if (IS_BARRIER(inode)) {
+		vxwprintk(1, "xid=%d messing with the barrier.",
+			vx_current_xid());
+		goto error;
+	}
+	switch (inode->i_sb->s_magic) {
+		case PROC_SUPER_MAGIC:
+			/* maybe allow that in the future? */
+			vxwprintk(1, "xid=%d messing with the procfs.",
+				vx_current_xid());
+			goto error;
+		case DEVPTS_SUPER_MAGIC:
+			/* devpts is xid tagged */
+			if (vx_check((xid_t)inode->i_tag, VS_IDENT))
+				goto fine;
+			vxwprintk(1, "xid=%d messing with the devpts.",
+				vx_current_xid());
+			goto error;
+	}
 fine:
 	retval = 0;
 error:
@@ -79,6 +106,8 @@ int inode_setattr(struct inode * inode, 
 		inode->i_uid = attr->ia_uid;
 	if (ia_valid & ATTR_GID)
 		inode->i_gid = attr->ia_gid;
+	if ((ia_valid & ATTR_TAG) && IS_TAGGED(inode))
+		inode->i_tag = attr->ia_tag;
 	if (ia_valid & ATTR_ATIME)
 		inode->i_atime = timespec_trunc(attr->ia_atime,
 						inode->i_sb->s_time_gran);
@@ -153,7 +182,8 @@ int notify_change(struct dentry * dentry
 			error = security_inode_setattr(dentry, attr);
 		if (!error) {
 			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
-			    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid))
+			    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid) ||
+			    (ia_valid & ATTR_TAG && attr->ia_tag != inode->i_tag))
 				error = DQUOT_TRANSFER(inode, attr) ? -EDQUOT : 0;
 			if (!error)
 				error = inode_setattr(inode, attr);
diff -NurpP --minimal linux-2.6.20.15/fs/binfmt_aout.c linux-2.6.20.15-vs2.2.0.1/fs/binfmt_aout.c
--- linux-2.6.20.15/fs/binfmt_aout.c	2007-02-06 03:01:16 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/binfmt_aout.c	2007-02-06 03:05:22 +0100
@@ -24,6 +24,7 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 #include <linux/init.h>
+#include <linux/vs_memory.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
diff -NurpP --minimal linux-2.6.20.15/fs/binfmt_elf.c linux-2.6.20.15-vs2.2.0.1/fs/binfmt_elf.c
--- linux-2.6.20.15/fs/binfmt_elf.c	2007-06-13 01:43:19 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/binfmt_elf.c	2007-05-02 19:39:41 +0200
@@ -39,6 +39,7 @@
 #include <linux/syscalls.h>
 #include <linux/random.h>
 #include <linux/elf.h>
+#include <linux/vs_memory.h>
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
diff -NurpP --minimal linux-2.6.20.15/fs/binfmt_flat.c linux-2.6.20.15-vs2.2.0.1/fs/binfmt_flat.c
--- linux-2.6.20.15/fs/binfmt_flat.c	2007-02-06 03:01:16 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/binfmt_flat.c	2007-02-06 03:05:22 +0100
@@ -36,6 +36,7 @@
 #include <linux/init.h>
 #include <linux/flat.h>
 #include <linux/syscalls.h>
+#include <linux/vs_memory.h>
 
 #include <asm/byteorder.h>
 #include <asm/system.h>
diff -NurpP --minimal linux-2.6.20.15/fs/binfmt_som.c linux-2.6.20.15-vs2.2.0.1/fs/binfmt_som.c
--- linux-2.6.20.15/fs/binfmt_som.c	2006-11-30 21:19:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/binfmt_som.c	2007-02-06 03:05:22 +0100
@@ -28,6 +28,7 @@
 #include <linux/shm.h>
 #include <linux/personality.h>
 #include <linux/init.h>
+#include <linux/vs_memory.h>
 
 #include <asm/a.out.h>
 #include <asm/uaccess.h>
diff -NurpP --minimal linux-2.6.20.15/fs/dcache.c linux-2.6.20.15-vs2.2.0.1/fs/dcache.c
--- linux-2.6.20.15/fs/dcache.c	2007-02-06 03:01:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/dcache.c	2007-02-06 03:05:22 +0100
@@ -32,6 +32,7 @@
 #include <linux/seqlock.h>
 #include <linux/swap.h>
 #include <linux/bootmem.h>
+#include <linux/vs_limit.h>
 #include "internal.h"
 
 
@@ -155,6 +156,7 @@ void dput(struct dentry *dentry)
 	if (!dentry)
 		return;
 
+	vx_dentry_dec(dentry);
 repeat:
 	if (atomic_read(&dentry->d_count) == 1)
 		might_sleep();
@@ -168,6 +170,8 @@ repeat:
 		return;
 	}
 
+	vx_dentry_dec(dentry);
+
 	/*
 	 * AV: ->d_delete() is _NOT_ allowed to block now.
 	 */
@@ -278,6 +282,7 @@ static inline struct dentry * __dget_loc
 	if (!list_empty(&dentry->d_lru)) {
 		dentry_stat.nr_unused--;
 		list_del_init(&dentry->d_lru);
+		vx_dentry_inc(dentry);
 	}
 	return dentry;
 }
@@ -869,6 +874,9 @@ struct dentry *d_alloc(struct dentry * p
 	struct dentry *dentry;
 	char *dname;
 
+	if (!vx_dentry_avail(1))
+		return NULL;
+
 	dentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL); 
 	if (!dentry)
 		return NULL;
@@ -917,6 +925,7 @@ struct dentry *d_alloc(struct dentry * p
 	if (parent)
 		list_add(&dentry->d_u.d_child, &parent->d_subdirs);
 	dentry_stat.nr_dentry++;
+	vx_dentry_inc(dentry);
 	spin_unlock(&dcache_lock);
 
 	return dentry;
@@ -1266,6 +1275,7 @@ struct dentry * __d_lookup(struct dentry
 
 		if (!d_unhashed(dentry)) {
 			atomic_inc(&dentry->d_count);
+			vx_dentry_inc(dentry);
 			found = dentry;
 		}
 		spin_unlock(&dentry->d_lock);
diff -NurpP --minimal linux-2.6.20.15/fs/devpts/inode.c linux-2.6.20.15-vs2.2.0.1/fs/devpts/inode.c
--- linux-2.6.20.15/fs/devpts/inode.c	2006-11-30 21:19:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/devpts/inode.c	2007-06-13 18:47:27 +0200
@@ -19,8 +19,22 @@
 #include <linux/tty.h>
 #include <linux/devpts_fs.h>
 #include <linux/parser.h>
+#include <linux/vs_base.h>
 
-#define DEVPTS_SUPER_MAGIC 0x1cd1
+
+static int devpts_permission(struct inode *inode, int mask, struct nameidata *nd)
+{
+	int ret = -EACCES;
+
+	/* devpts is xid tagged */
+	if (vx_check((xid_t)inode->i_tag, VS_WATCH_P | VS_IDENT))
+		ret = generic_permission(inode, mask, NULL);
+	return ret;
+}
+
+static struct inode_operations devpts_file_inode_operations = {
+	.permission     = devpts_permission,
+};
 
 static struct vfsmount *devpts_mnt;
 static struct dentry *devpts_root;
@@ -91,6 +105,25 @@ static int devpts_remount(struct super_b
 	return 0;
 }
 
+static int devpts_filter(struct dentry *de)
+{
+	/* devpts is xid tagged */
+	return vx_check((xid_t)de->d_inode->i_tag, VS_WATCH_P | VS_IDENT);
+}
+
+static int devpts_readdir(struct file * filp, void * dirent, filldir_t filldir)
+{
+	return dcache_readdir_filter(filp, dirent, filldir, devpts_filter);
+}
+
+static struct file_operations devpts_dir_operations = {
+	.open		= dcache_dir_open,
+	.release	= dcache_dir_close,
+	.llseek		= dcache_dir_lseek,
+	.read		= generic_read_dir,
+	.readdir	= devpts_readdir,
+};
+
 static struct super_operations devpts_sops = {
 	.statfs		= simple_statfs,
 	.remount_fs	= devpts_remount,
@@ -116,8 +149,10 @@ devpts_fill_super(struct super_block *s,
 	inode->i_uid = inode->i_gid = 0;
 	inode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR;
 	inode->i_op = &simple_dir_inode_operations;
-	inode->i_fop = &simple_dir_operations;
+	inode->i_fop = &devpts_dir_operations;
 	inode->i_nlink = 2;
+	/* devpts is xid tagged */
+	inode->i_tag = (tag_t)vx_current_xid();
 
 	devpts_root = s->s_root = d_alloc_root(inode);
 	if (s->s_root)
@@ -175,6 +210,9 @@ int devpts_pty_new(struct tty_struct *tt
 	inode->i_gid = config.setgid ? config.gid : current->fsgid;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	init_special_inode(inode, S_IFCHR|config.mode, device);
+	/* devpts is xid tagged */
+	inode->i_tag = (tag_t)vx_current_xid();
+	inode->i_op = &devpts_file_inode_operations;
 	inode->i_private = tty;
 
 	dentry = get_node(number);
diff -NurpP --minimal linux-2.6.20.15/fs/ecryptfs/inode.c linux-2.6.20.15-vs2.2.0.1/fs/ecryptfs/inode.c
--- linux-2.6.20.15/fs/ecryptfs/inode.c	2007-02-06 03:01:17 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ecryptfs/inode.c	2007-02-06 03:05:22 +0100
@@ -415,7 +415,7 @@ static int ecryptfs_link(struct dentry *
 	dget(lower_new_dentry);
 	lower_dir_dentry = lock_parent(lower_new_dentry);
 	rc = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
-		      lower_new_dentry);
+		      lower_new_dentry, NULL);
 	if (rc || !lower_new_dentry->d_inode)
 		goto out_lock;
 	rc = ecryptfs_interpose(lower_new_dentry, new_dentry, dir->i_sb, 0);
@@ -443,7 +443,7 @@ static int ecryptfs_unlink(struct inode 
 	struct inode *lower_dir_inode = ecryptfs_inode_to_lower(dir);
 
 	lock_parent(lower_dentry);
-	rc = vfs_unlink(lower_dir_inode, lower_dentry);
+	rc = vfs_unlink(lower_dir_inode, lower_dentry, NULL);
 	if (rc) {
 		printk(KERN_ERR "Error in vfs_unlink; rc = [%d]\n", rc);
 		goto out_unlock;
@@ -480,7 +480,7 @@ static int ecryptfs_symlink(struct inode
 		goto out_lock;
 	}
 	rc = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry,
-			 encoded_symname, mode);
+			 encoded_symname, mode, NULL);
 	kfree(encoded_symname);
 	if (rc || !lower_dentry->d_inode)
 		goto out_lock;
@@ -505,7 +505,7 @@ static int ecryptfs_mkdir(struct inode *
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
 	lower_dir_dentry = lock_parent(lower_dentry);
-	rc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, mode);
+	rc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, mode, NULL);
 	if (rc || !lower_dentry->d_inode)
 		goto out;
 	rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
@@ -531,7 +531,7 @@ static int ecryptfs_rmdir(struct inode *
 	dget(dentry);
 	lower_dir_dentry = lock_parent(lower_dentry);
 	dget(lower_dentry);
-	rc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
+	rc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry, NULL);
 	dput(lower_dentry);
 	if (!rc)
 		d_delete(lower_dentry);
@@ -553,7 +553,7 @@ ecryptfs_mknod(struct inode *dir, struct
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
 	lower_dir_dentry = lock_parent(lower_dentry);
-	rc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, mode, dev);
+	rc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, mode, dev, NULL);
 	if (rc || !lower_dentry->d_inode)
 		goto out;
 	rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
diff -NurpP --minimal linux-2.6.20.15/fs/exec.c linux-2.6.20.15-vs2.2.0.1/fs/exec.c
--- linux-2.6.20.15/fs/exec.c	2007-06-13 01:43:19 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/exec.c	2007-05-02 19:39:41 +0200
@@ -50,6 +50,7 @@
 #include <linux/tsacct_kern.h>
 #include <linux/cn_proc.h>
 #include <linux/audit.h>
+#include <linux/vs_memory.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -437,7 +438,8 @@ int setup_arg_pages(struct linux_binprm 
 			kmem_cache_free(vm_area_cachep, mpnt);
 			return ret;
 		}
-		mm->stack_vm = mm->total_vm = vma_pages(mpnt);
+		vx_vmpages_sub(mm, mm->total_vm - vma_pages(mpnt));
+		mm->stack_vm = mm->total_vm;
 	}
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
@@ -1311,7 +1313,7 @@ static int format_corename(char *corenam
 			/* UNIX time of coredump */
 			case 't': {
 				struct timeval tv;
-				do_gettimeofday(&tv);
+				vx_gettimeofday(&tv);
 				rc = snprintf(out_ptr, out_end - out_ptr,
 					      "%lu", tv.tv_sec);
 				if (rc > out_end - out_ptr)
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/balloc.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/balloc.c
--- linux-2.6.20.15/fs/ext2/balloc.c	2006-09-20 16:58:34 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/balloc.c	2007-02-06 03:05:22 +0100
@@ -16,6 +16,8 @@
 #include <linux/sched.h>
 #include <linux/buffer_head.h>
 #include <linux/capability.h>
+#include <linux/vs_dlimit.h>
+#include <linux/vs_tag.h>
 
 /*
  * balloc.c contains the blocks allocation and deallocation routines
@@ -102,12 +104,13 @@ static int reserve_blocks(struct super_b
 {
 	struct ext2_sb_info *sbi = EXT2_SB(sb);
 	struct ext2_super_block *es = sbi->s_es;
-	unsigned free_blocks;
-	unsigned root_blocks;
+	unsigned long long free_blocks, root_blocks;
 
 	free_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);
 	root_blocks = le32_to_cpu(es->s_r_blocks_count);
 
+	DLIMIT_ADJUST_BLOCK(sb, dx_current_tag(), &free_blocks, &root_blocks);
+
 	if (free_blocks < count)
 		count = free_blocks;
 
@@ -258,6 +261,7 @@ do_more:
 	}
 error_return:
 	brelse(bitmap_bh);
+	DLIMIT_FREE_BLOCK(inode, freed);
 	release_blocks(sb, freed);
 	DQUOT_FREE_BLOCK(inode, freed);
 }
@@ -361,6 +365,10 @@ int ext2_new_block(struct inode *inode, 
 		*err = -ENOSPC;
 		goto out_dquot;
 	}
+	if (DLIMIT_ALLOC_BLOCK(inode, es_alloc)) {
+		*err = -ENOSPC;
+		goto out_dlimit;
+	}
 
 	ext2_debug ("goal=%lu.\n", goal);
 
@@ -508,6 +516,8 @@ got_block:
 	*err = 0;
 out_release:
 	group_release_blocks(sb, group_no, desc, gdp_bh, group_alloc);
+	DLIMIT_FREE_BLOCK(inode, es_alloc);
+out_dlimit:
 	release_blocks(sb, es_alloc);
 out_dquot:
 	DQUOT_FREE_BLOCK(inode, dq_alloc);
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/ext2.h linux-2.6.20.15-vs2.2.0.1/fs/ext2/ext2.h
--- linux-2.6.20.15/fs/ext2/ext2.h	2006-11-30 21:19:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/ext2.h	2007-02-06 03:05:22 +0100
@@ -166,6 +166,7 @@ extern const struct file_operations ext2
 extern const struct address_space_operations ext2_aops;
 extern const struct address_space_operations ext2_aops_xip;
 extern const struct address_space_operations ext2_nobh_aops;
+extern int ext2_sync_flags(struct inode *inode);
 
 /* namei.c */
 extern struct inode_operations ext2_dir_inode_operations;
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/file.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/file.c
--- linux-2.6.20.15/fs/ext2/file.c	2006-11-30 21:19:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/file.c	2007-02-06 03:05:22 +0100
@@ -54,6 +54,7 @@ const struct file_operations ext2_file_o
 	.release	= ext2_release_file,
 	.fsync		= ext2_sync_file,
 	.sendfile	= generic_file_sendfile,
+	.sendpage	= generic_file_sendpage,
 	.splice_read	= generic_file_splice_read,
 	.splice_write	= generic_file_splice_write,
 };
@@ -85,4 +86,5 @@ struct inode_operations ext2_file_inode_
 #endif
 	.setattr	= ext2_setattr,
 	.permission	= ext2_permission,
+	.sync_flags	= ext2_sync_flags,
 };
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/ialloc.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/ialloc.c
--- linux-2.6.20.15/fs/ext2/ialloc.c	2006-11-30 21:19:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/ialloc.c	2007-02-06 03:05:22 +0100
@@ -17,6 +17,8 @@
 #include <linux/backing-dev.h>
 #include <linux/buffer_head.h>
 #include <linux/random.h>
+#include <linux/vs_dlimit.h>
+#include <linux/vs_tag.h>
 #include "ext2.h"
 #include "xattr.h"
 #include "acl.h"
@@ -125,6 +127,7 @@ void ext2_free_inode (struct inode * ino
 		ext2_xattr_delete_inode(inode);
 	    	DQUOT_FREE_INODE(inode);
 		DQUOT_DROP(inode);
+		DLIMIT_FREE_INODE(inode);
 	}
 
 	es = EXT2_SB(sb)->s_es;
@@ -464,6 +467,11 @@ struct inode *ext2_new_inode(struct inod
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
 
+	inode->i_tag = dx_current_fstag(sb);
+	if (DLIMIT_ALLOC_INODE(inode)) {
+		err = -ENOSPC;
+		goto fail_dlim;
+	}
 	ei = EXT2_I(inode);
 	sbi = EXT2_SB(sb);
 	es = sbi->s_es;
@@ -577,7 +585,8 @@ got:
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
 	memset(ei->i_data, 0, sizeof(ei->i_data));
-	ei->i_flags = EXT2_I(dir)->i_flags & ~EXT2_BTREE_FL;
+	ei->i_flags = EXT2_I(dir)->i_flags &
+		~(EXT2_BTREE_FL|EXT2_IUNLINK_FL|EXT2_BARRIER_FL);
 	if (S_ISLNK(mode))
 		ei->i_flags &= ~(EXT2_IMMUTABLE_FL|EXT2_APPEND_FL);
 	/* dirsync is only applied to directories */
@@ -625,12 +634,15 @@ fail_free_drop:
 
 fail_drop:
 	DQUOT_DROP(inode);
+	DLIMIT_FREE_INODE(inode);
 	inode->i_flags |= S_NOQUOTA;
 	inode->i_nlink = 0;
 	iput(inode);
 	return ERR_PTR(err);
 
 fail:
+	DLIMIT_FREE_INODE(inode);
+fail_dlim:
 	make_bad_inode(inode);
 	iput(inode);
 	return ERR_PTR(err);
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/inode.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/inode.c
--- linux-2.6.20.15/fs/ext2/inode.c	2006-11-30 21:19:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/inode.c	2007-02-06 03:05:22 +0100
@@ -31,6 +31,7 @@
 #include <linux/writeback.h>
 #include <linux/buffer_head.h>
 #include <linux/mpage.h>
+#include <linux/vs_tag.h>
 #include "ext2.h"
 #include "acl.h"
 #include "xip.h"
@@ -913,7 +914,7 @@ void ext2_truncate (struct inode * inode
 		return;
 	if (ext2_inode_is_fast_symlink(inode))
 		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+	if (IS_APPEND(inode) || IS_IXORUNLINK(inode))
 		return;
 
 	ext2_discard_prealloc(inode);
@@ -1042,25 +1043,57 @@ void ext2_set_inode_flags(struct inode *
 {
 	unsigned int flags = EXT2_I(inode)->i_flags;
 
-	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
+	inode->i_flags &= ~(S_IMMUTABLE | S_IUNLINK | S_BARRIER |
+		S_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);
+
+	if (flags & EXT2_IMMUTABLE_FL)
+		inode->i_flags |= S_IMMUTABLE;
+	if (flags & EXT2_IUNLINK_FL)
+		inode->i_flags |= S_IUNLINK;
+	if (flags & EXT2_BARRIER_FL)
+		inode->i_flags |= S_BARRIER;
+
 	if (flags & EXT2_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (flags & EXT2_APPEND_FL)
 		inode->i_flags |= S_APPEND;
-	if (flags & EXT2_IMMUTABLE_FL)
-		inode->i_flags |= S_IMMUTABLE;
 	if (flags & EXT2_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
 	if (flags & EXT2_DIRSYNC_FL)
 		inode->i_flags |= S_DIRSYNC;
 }
 
+int ext2_sync_flags(struct inode *inode)
+{
+	unsigned int oldflags, newflags;
+
+	oldflags = EXT2_I(inode)->i_flags;
+	newflags = oldflags & ~(EXT2_IMMUTABLE_FL |
+		EXT2_IUNLINK_FL | EXT2_BARRIER_FL);
+
+	if (IS_IMMUTABLE(inode))
+		newflags |= EXT2_IMMUTABLE_FL;
+	if (IS_IUNLINK(inode))
+		newflags |= EXT2_IUNLINK_FL;
+	if (IS_BARRIER(inode))
+		newflags |= EXT2_BARRIER_FL;
+
+	if (oldflags ^ newflags) {
+		EXT2_I(inode)->i_flags = newflags;
+		inode->i_ctime = CURRENT_TIME;
+		mark_inode_dirty(inode);
+	}
+	return 0;
+}
+
 void ext2_read_inode (struct inode * inode)
 {
 	struct ext2_inode_info *ei = EXT2_I(inode);
 	ino_t ino = inode->i_ino;
 	struct buffer_head * bh;
 	struct ext2_inode * raw_inode = ext2_get_inode(inode->i_sb, ino, &bh);
+	uid_t uid;
+	gid_t gid;
 	int n;
 
 #ifdef CONFIG_EXT2_FS_POSIX_ACL
@@ -1071,12 +1104,17 @@ void ext2_read_inode (struct inode * ino
  		goto bad_inode;
 
 	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
-	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
-	inode->i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
+	uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
+	gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
 	if (!(test_opt (inode->i_sb, NO_UID32))) {
-		inode->i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
-		inode->i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
+		uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
+		gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
 	}
+	inode->i_uid = INOTAG_UID(DX_TAG(inode), uid, gid);
+	inode->i_gid = INOTAG_GID(DX_TAG(inode), uid, gid);
+	inode->i_tag = INOTAG_TAG(DX_TAG(inode), uid, gid,
+		le16_to_cpu(raw_inode->i_raw_tag));
+
 	inode->i_nlink = le16_to_cpu(raw_inode->i_links_count);
 	inode->i_size = le32_to_cpu(raw_inode->i_size);
 	inode->i_atime.tv_sec = le32_to_cpu(raw_inode->i_atime);
@@ -1173,8 +1211,8 @@ static int ext2_update_inode(struct inod
 	struct ext2_inode_info *ei = EXT2_I(inode);
 	struct super_block *sb = inode->i_sb;
 	ino_t ino = inode->i_ino;
-	uid_t uid = inode->i_uid;
-	gid_t gid = inode->i_gid;
+	uid_t uid = TAGINO_UID(DX_TAG(inode), inode->i_uid, inode->i_tag);
+	gid_t gid = TAGINO_GID(DX_TAG(inode), inode->i_gid, inode->i_tag);
 	struct buffer_head * bh;
 	struct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);
 	int n;
@@ -1209,6 +1247,9 @@ static int ext2_update_inode(struct inod
 		raw_inode->i_uid_high = 0;
 		raw_inode->i_gid_high = 0;
 	}
+#ifdef CONFIG_TAGGING_INTERN
+	raw_inode->i_raw_tag = cpu_to_le16(inode->i_tag);
+#endif
 	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
 	raw_inode->i_size = cpu_to_le32(inode->i_size);
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
@@ -1295,7 +1336,8 @@ int ext2_setattr(struct dentry *dentry, 
 	if (error)
 		return error;
 	if ((iattr->ia_valid & ATTR_UID && iattr->ia_uid != inode->i_uid) ||
-	    (iattr->ia_valid & ATTR_GID && iattr->ia_gid != inode->i_gid)) {
+	    (iattr->ia_valid & ATTR_GID && iattr->ia_gid != inode->i_gid) ||
+	    (iattr->ia_valid & ATTR_TAG && iattr->ia_tag != inode->i_tag)) {
 		error = DQUOT_TRANSFER(inode, iattr) ? -EDQUOT : 0;
 		if (error)
 			return error;
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/ioctl.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/ioctl.c
--- linux-2.6.20.15/fs/ext2/ioctl.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/ioctl.c	2007-02-06 03:13:14 +0100
@@ -13,6 +13,7 @@
 #include <linux/sched.h>
 #include <linux/compat.h>
 #include <linux/smp_lock.h>
+#include <linux/mount.h>
 #include <asm/current.h>
 #include <asm/uaccess.h>
 
@@ -32,7 +33,8 @@ int ext2_ioctl (struct inode * inode, st
 	case EXT2_IOC_SETFLAGS: {
 		unsigned int oldflags;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
@@ -53,7 +55,9 @@ int ext2_ioctl (struct inode * inode, st
 		 *
 		 * This test looks nicer. Thanks to Pauline Middelink
 		 */
-		if ((flags ^ oldflags) & (EXT2_APPEND_FL | EXT2_IMMUTABLE_FL)) {
+		if ((oldflags & EXT2_IMMUTABLE_FL) ||
+			((flags ^ oldflags) & (EXT2_APPEND_FL |
+			EXT2_IMMUTABLE_FL | EXT2_IUNLINK_FL))) {
 			if (!capable(CAP_LINUX_IMMUTABLE)) {
 				mutex_unlock(&inode->i_mutex);
 				return -EPERM;
@@ -75,7 +79,8 @@ int ext2_ioctl (struct inode * inode, st
 	case EXT2_IOC_SETVERSION:
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
 			return -EPERM;
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 		if (get_user(inode->i_generation, (int __user *) arg))
 			return -EFAULT;	
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/namei.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/namei.c
--- linux-2.6.20.15/fs/ext2/namei.c	2006-11-30 21:19:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/namei.c	2007-02-06 03:05:22 +0100
@@ -31,6 +31,7 @@
  */
 
 #include <linux/pagemap.h>
+#include <linux/vs_tag.h>
 #include "ext2.h"
 #include "xattr.h"
 #include "acl.h"
@@ -66,6 +67,7 @@ static struct dentry *ext2_lookup(struct
 		inode = iget(dir->i_sb, ino);
 		if (!inode)
 			return ERR_PTR(-EACCES);
+		dx_propagate_tag(nd, inode);
 	}
 	return d_splice_alias(inode, dentry);
 }
@@ -391,6 +393,7 @@ struct inode_operations ext2_dir_inode_o
 #endif
 	.setattr	= ext2_setattr,
 	.permission	= ext2_permission,
+	.sync_flags	= ext2_sync_flags,
 };
 
 struct inode_operations ext2_special_inode_operations = {
@@ -402,4 +405,5 @@ struct inode_operations ext2_special_ino
 #endif
 	.setattr	= ext2_setattr,
 	.permission	= ext2_permission,
+	.sync_flags	= ext2_sync_flags,
 };
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/super.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/super.c
--- linux-2.6.20.15/fs/ext2/super.c	2007-06-13 01:43:19 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/super.c	2007-03-10 18:57:30 +0100
@@ -324,7 +324,7 @@ enum {
 	Opt_err_ro, Opt_nouid32, Opt_nocheck, Opt_debug,
 	Opt_oldalloc, Opt_orlov, Opt_nobh, Opt_user_xattr, Opt_nouser_xattr,
 	Opt_acl, Opt_noacl, Opt_xip, Opt_ignore, Opt_err, Opt_quota,
-	Opt_usrquota, Opt_grpquota
+	Opt_usrquota, Opt_grpquota, Opt_tag, Opt_notag, Opt_tagid
 };
 
 static match_table_t tokens = {
@@ -352,6 +352,10 @@ static match_table_t tokens = {
 	{Opt_acl, "acl"},
 	{Opt_noacl, "noacl"},
 	{Opt_xip, "xip"},
+	{Opt_tag, "tag"},
+	{Opt_notag, "notag"},
+	{Opt_tagid, "tagid=%u"},
+	{Opt_tag, "tagxid"},
 	{Opt_grpquota, "grpquota"},
 	{Opt_ignore, "noquota"},
 	{Opt_quota, "quota"},
@@ -420,6 +424,20 @@ static int parse_options (char * options
 		case Opt_nouid32:
 			set_opt (sbi->s_mount_opt, NO_UID32);
 			break;
+#ifndef CONFIG_TAGGING_NONE
+		case Opt_tag:
+			set_opt (sbi->s_mount_opt, TAGGED);
+			break;
+		case Opt_notag:
+			clear_opt (sbi->s_mount_opt, TAGGED);
+			break;
+#endif
+#ifdef CONFIG_PROPAGATE
+		case Opt_tagid:
+			/* use args[0] */
+			set_opt (sbi->s_mount_opt, TAGGED);
+			break;
+#endif
 		case Opt_nocheck:
 			clear_opt (sbi->s_mount_opt, CHECK);
 			break;
@@ -730,6 +748,8 @@ static int ext2_fill_super(struct super_
 	if (!parse_options ((char *) data, sbi))
 		goto failed_mount;
 
+	if (EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_TAGGED)
+		sb->s_flags |= MS_TAGGED;
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?
 		 MS_POSIXACL : 0);
@@ -1038,6 +1058,13 @@ static int ext2_remount (struct super_bl
 		goto restore_opts;
 	}
 
+	if ((sbi->s_mount_opt & EXT2_MOUNT_TAGGED) &&
+		!(sb->s_flags & MS_TAGGED)) {
+		printk("EXT2-fs: %s: tagging not permitted on remount.\n",
+		       sb->s_id);
+		return -EINVAL;
+	}
+
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((sbi->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
 
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/symlink.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/symlink.c
--- linux-2.6.20.15/fs/ext2/symlink.c	2005-08-29 22:25:30 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/symlink.c	2007-02-06 03:05:22 +0100
@@ -38,6 +38,7 @@ struct inode_operations ext2_symlink_ino
 	.listxattr	= ext2_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+	.sync_flags	= ext2_sync_flags,
 };
  
 struct inode_operations ext2_fast_symlink_inode_operations = {
@@ -49,4 +50,5 @@ struct inode_operations ext2_fast_symlin
 	.listxattr	= ext2_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+	.sync_flags	= ext2_sync_flags,
 };
diff -NurpP --minimal linux-2.6.20.15/fs/ext2/xattr.c linux-2.6.20.15-vs2.2.0.1/fs/ext2/xattr.c
--- linux-2.6.20.15/fs/ext2/xattr.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext2/xattr.c	2007-02-06 03:05:22 +0100
@@ -60,6 +60,7 @@
 #include <linux/mbcache.h>
 #include <linux/quotaops.h>
 #include <linux/rwsem.h>
+#include <linux/vs_dlimit.h>
 #include "ext2.h"
 #include "xattr.h"
 #include "acl.h"
@@ -641,8 +642,12 @@ ext2_xattr_set2(struct inode *inode, str
 				   the inode.  */
 				ea_bdebug(new_bh, "reusing block");
 
+				error = -ENOSPC;
+				if (DLIMIT_ALLOC_BLOCK(inode, 1))
+					goto cleanup;
 				error = -EDQUOT;
 				if (DQUOT_ALLOC_BLOCK(inode, 1)) {
+					DLIMIT_FREE_BLOCK(inode, 1);
 					unlock_buffer(new_bh);
 					goto cleanup;
 				}
@@ -736,6 +741,7 @@ ext2_xattr_set2(struct inode *inode, str
 				le32_to_cpu(HDR(old_bh)->h_refcount) - 1);
 			if (ce)
 				mb_cache_entry_release(ce);
+			DLIMIT_FREE_BLOCK(inode, 1);
 			DQUOT_FREE_BLOCK(inode, 1);
 			mark_buffer_dirty(old_bh);
 			ea_bdebug(old_bh, "refcount now=%d",
@@ -800,6 +806,7 @@ ext2_xattr_delete_inode(struct inode *in
 		mark_buffer_dirty(bh);
 		if (IS_SYNC(inode))
 			sync_dirty_buffer(bh);
+		DLIMIT_FREE_BLOCK(inode, 1);
 		DQUOT_FREE_BLOCK(inode, 1);
 	}
 	EXT2_I(inode)->i_file_acl = 0;
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/balloc.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/balloc.c
--- linux-2.6.20.15/fs/ext3/balloc.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/balloc.c	2007-07-16 06:32:05 +0200
@@ -19,6 +19,8 @@
 #include <linux/ext3_jbd.h>
 #include <linux/quotaops.h>
 #include <linux/buffer_head.h>
+#include <linux/vs_dlimit.h>
+#include <linux/vs_tag.h>
 
 /*
  * balloc.c contains the blocks allocation and deallocation routines
@@ -613,8 +615,10 @@ void ext3_free_blocks(handle_t *handle, 
 		return;
 	}
 	ext3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);
-	if (dquot_freed_blocks)
+	if (dquot_freed_blocks) {
+		DLIMIT_FREE_BLOCK(inode, dquot_freed_blocks);
 		DQUOT_FREE_BLOCK(inode, dquot_freed_blocks);
+	}
 	return;
 }
 
@@ -1353,18 +1357,33 @@ out:
  *
  * Check if filesystem has at least 1 free block available for allocation.
  */
-static int ext3_has_free_blocks(struct ext3_sb_info *sbi)
+static int ext3_has_free_blocks(struct super_block *sb)
 {
-	ext3_fsblk_t free_blocks, root_blocks;
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
+	unsigned long long free_blocks, root_blocks;
+	int cond;
 
 	free_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);
 	root_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);
-	if (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&
+
+	vxdprintk(VXD_CBIT(dlim, 3),
+		"ext3_has_free_blocks(%p): free=%llu, root=%llu",
+		sb, free_blocks, root_blocks);
+
+	DLIMIT_ADJUST_BLOCK(sb, dx_current_tag(), &free_blocks, &root_blocks);
+
+	cond = (free_blocks < root_blocks + 1 &&
+		!capable(CAP_SYS_RESOURCE) &&
 		sbi->s_resuid != current->fsuid &&
-		(sbi->s_resgid == 0 || !in_group_p (sbi->s_resgid))) {
-		return 0;
-	}
-	return 1;
+		(sbi->s_resgid == 0 || !in_group_p (sbi->s_resgid)));
+
+	vxdprintk(VXD_CBIT(dlim, 3),
+		"ext3_has_free_blocks(%p): %llu<%llu+1, %c, %u!=%u r=%d",
+		sb, free_blocks, root_blocks,
+		!capable(CAP_SYS_RESOURCE)?'1':'0',
+		sbi->s_resuid, current->fsuid, cond?0:1);
+
+	return (cond ? 0 : 1);
 }
 
 /**
@@ -1381,7 +1400,7 @@ static int ext3_has_free_blocks(struct e
  */
 int ext3_should_retry_alloc(struct super_block *sb, int *retries)
 {
-	if (!ext3_has_free_blocks(EXT3_SB(sb)) || (*retries)++ > 3)
+	if (!ext3_has_free_blocks(sb) || (*retries)++ > 3)
 		return 0;
 
 	jbd_debug(1, "%s: retrying operation after ENOSPC\n", sb->s_id);
@@ -1444,6 +1463,8 @@ ext3_fsblk_t ext3_new_blocks(handle_t *h
 		*errp = -EDQUOT;
 		return 0;
 	}
+	if (DLIMIT_ALLOC_BLOCK(inode, num))
+	    goto out_dlimit;
 
 	sbi = EXT3_SB(sb);
 	es = EXT3_SB(sb)->s_es;
@@ -1460,7 +1481,7 @@ ext3_fsblk_t ext3_new_blocks(handle_t *h
 	if (block_i && ((windowsz = block_i->rsv_window_node.rsv_goal_size) > 0))
 		my_rsv = &block_i->rsv_window_node;
 
-	if (!ext3_has_free_blocks(sbi)) {
+	if (!ext3_has_free_blocks(sb)) {
 		*errp = -ENOSPC;
 		goto out;
 	}
@@ -1647,12 +1668,16 @@ allocated:
 	*errp = 0;
 	brelse(bitmap_bh);
 	DQUOT_FREE_BLOCK(inode, *count-num);
+	DLIMIT_FREE_BLOCK(inode, *count-num);
 	*count = num;
 	return ret_block;
 
 io_error:
 	*errp = -EIO;
 out:
+	if (!performed_allocation)
+		DLIMIT_FREE_BLOCK(inode, *count);
+out_dlimit:
 	if (fatal) {
 		*errp = fatal;
 		ext3_std_error(sb, fatal);
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/file.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/file.c
--- linux-2.6.20.15/fs/ext3/file.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/file.c	2007-02-06 03:05:22 +0100
@@ -121,6 +121,7 @@ const struct file_operations ext3_file_o
 	.release	= ext3_release_file,
 	.fsync		= ext3_sync_file,
 	.sendfile	= generic_file_sendfile,
+	.sendpage	= generic_file_sendpage,
 	.splice_read	= generic_file_splice_read,
 	.splice_write	= generic_file_splice_write,
 };
@@ -135,5 +136,6 @@ struct inode_operations ext3_file_inode_
 	.removexattr	= generic_removexattr,
 #endif
 	.permission	= ext3_permission,
+	.sync_flags	= ext3_sync_flags,
 };
 
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/ialloc.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/ialloc.c
--- linux-2.6.20.15/fs/ext3/ialloc.c	2006-11-30 21:19:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/ialloc.c	2007-02-06 03:05:22 +0100
@@ -23,6 +23,8 @@
 #include <linux/buffer_head.h>
 #include <linux/random.h>
 #include <linux/bitops.h>
+#include <linux/vs_dlimit.h>
+#include <linux/vs_tag.h>
 
 #include <asm/byteorder.h>
 
@@ -127,6 +129,7 @@ void ext3_free_inode (handle_t *handle, 
 	ext3_xattr_delete_inode(handle, inode);
 	DQUOT_FREE_INODE(inode);
 	DQUOT_DROP(inode);
+	DLIMIT_FREE_INODE(inode);
 
 	is_directory = S_ISDIR(inode->i_mode);
 
@@ -445,6 +448,12 @@ struct inode *ext3_new_inode(handle_t *h
 	inode = new_inode(sb);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
+
+	inode->i_tag = dx_current_fstag(sb);
+	if (DLIMIT_ALLOC_INODE(inode)) {
+		err = -ENOSPC;
+		goto out_dlimit;
+	}
 	ei = EXT3_I(inode);
 
 	sbi = EXT3_SB(sb);
@@ -566,7 +575,8 @@ got:
 	ei->i_dir_start_lookup = 0;
 	ei->i_disksize = 0;
 
-	ei->i_flags = EXT3_I(dir)->i_flags & ~EXT3_INDEX_FL;
+	ei->i_flags = EXT3_I(dir)->i_flags &
+		~(EXT3_INDEX_FL|EXT3_IUNLINK_FL|EXT3_BARRIER_FL);
 	if (S_ISLNK(mode))
 		ei->i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_APPEND_FL);
 	/* dirsync only applies to directories */
@@ -621,6 +631,8 @@ got:
 fail:
 	ext3_std_error(sb, err);
 out:
+	DLIMIT_FREE_INODE(inode);
+out_dlimit:
 	iput(inode);
 	ret = ERR_PTR(err);
 really_out:
@@ -632,6 +644,7 @@ fail_free_drop:
 
 fail_drop:
 	DQUOT_DROP(inode);
+	DLIMIT_FREE_INODE(inode);
 	inode->i_flags |= S_NOQUOTA;
 	inode->i_nlink = 0;
 	iput(inode);
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/inode.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/inode.c
--- linux-2.6.20.15/fs/ext3/inode.c	2007-06-13 01:43:20 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/inode.c	2007-05-02 19:39:41 +0200
@@ -37,6 +37,7 @@
 #include <linux/mpage.h>
 #include <linux/uio.h>
 #include <linux/bio.h>
+#include <linux/vs_tag.h>
 #include "xattr.h"
 #include "acl.h"
 
@@ -2246,7 +2247,7 @@ void ext3_truncate(struct inode *inode)
 		return;
 	if (ext3_inode_is_fast_symlink(inode))
 		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+	if (IS_APPEND(inode) || IS_IXORUNLINK(inode))
 		return;
 
 	/*
@@ -2568,19 +2569,65 @@ void ext3_set_inode_flags(struct inode *
 {
 	unsigned int flags = EXT3_I(inode)->i_flags;
 
-	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
+	inode->i_flags &= ~(S_IMMUTABLE | S_IUNLINK | S_BARRIER |
+		S_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);
+
+	if (flags & EXT3_IMMUTABLE_FL)
+		inode->i_flags |= S_IMMUTABLE;
+	if (flags & EXT3_IUNLINK_FL)
+		inode->i_flags |= S_IUNLINK;
+	if (flags & EXT3_BARRIER_FL)
+		inode->i_flags |= S_BARRIER;
+
 	if (flags & EXT3_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (flags & EXT3_APPEND_FL)
 		inode->i_flags |= S_APPEND;
-	if (flags & EXT3_IMMUTABLE_FL)
-		inode->i_flags |= S_IMMUTABLE;
 	if (flags & EXT3_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
 	if (flags & EXT3_DIRSYNC_FL)
 		inode->i_flags |= S_DIRSYNC;
 }
 
+int ext3_sync_flags(struct inode *inode)
+{
+	unsigned int oldflags, newflags;
+	int err = 0;
+
+	oldflags = EXT3_I(inode)->i_flags;
+	newflags = oldflags & ~(EXT3_IMMUTABLE_FL |
+		EXT3_IUNLINK_FL | EXT3_BARRIER_FL);
+
+	if (IS_IMMUTABLE(inode))
+		newflags |= EXT3_IMMUTABLE_FL;
+	if (IS_IUNLINK(inode))
+		newflags |= EXT3_IUNLINK_FL;
+	if (IS_BARRIER(inode))
+		newflags |= EXT3_BARRIER_FL;
+
+	if (oldflags ^ newflags) {
+		handle_t *handle;
+		struct ext3_iloc iloc;
+
+		handle = ext3_journal_start(inode, 1);
+		if (IS_ERR(handle))
+			return PTR_ERR(handle);
+		if (IS_SYNC(inode))
+			handle->h_sync = 1;
+		err = ext3_reserve_inode_write(handle, inode, &iloc);
+		if (err)
+			goto flags_err;
+
+		EXT3_I(inode)->i_flags = newflags;
+		inode->i_ctime = CURRENT_TIME;
+
+		err = ext3_mark_iloc_dirty(handle, inode, &iloc);
+	flags_err:
+		ext3_journal_stop(handle);
+	}
+	return err;
+}
+
 void ext3_read_inode(struct inode * inode)
 {
 	struct ext3_iloc iloc;
@@ -2588,6 +2635,8 @@ void ext3_read_inode(struct inode * inod
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct buffer_head *bh;
 	int block;
+	uid_t uid;
+	gid_t gid;
 
 #ifdef CONFIG_EXT3_FS_POSIX_ACL
 	ei->i_acl = EXT3_ACL_NOT_CACHED;
@@ -2600,12 +2649,17 @@ void ext3_read_inode(struct inode * inod
 	bh = iloc.bh;
 	raw_inode = ext3_raw_inode(&iloc);
 	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
-	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
-	inode->i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
+	uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
+	gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
 	if(!(test_opt (inode->i_sb, NO_UID32))) {
-		inode->i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
-		inode->i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
+		uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
+		gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
 	}
+	inode->i_uid = INOTAG_UID(DX_TAG(inode), uid, gid);
+	inode->i_gid = INOTAG_GID(DX_TAG(inode), uid, gid);
+	inode->i_tag = INOTAG_TAG(DX_TAG(inode), uid, gid,
+		le16_to_cpu(raw_inode->i_raw_tag));
+
 	inode->i_nlink = le16_to_cpu(raw_inode->i_links_count);
 	inode->i_size = le32_to_cpu(raw_inode->i_size);
 	inode->i_atime.tv_sec = le32_to_cpu(raw_inode->i_atime);
@@ -2729,6 +2783,8 @@ static int ext3_do_update_inode(handle_t
 	struct ext3_inode *raw_inode = ext3_raw_inode(iloc);
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct buffer_head *bh = iloc->bh;
+	uid_t uid = TAGINO_UID(DX_TAG(inode), inode->i_uid, inode->i_tag);
+	gid_t gid = TAGINO_GID(DX_TAG(inode), inode->i_gid, inode->i_tag);
 	int err = 0, rc, block;
 
 	/* For fields not not tracking in the in-memory inode,
@@ -2738,29 +2794,32 @@ static int ext3_do_update_inode(handle_t
 
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
 	if(!(test_opt(inode->i_sb, NO_UID32))) {
-		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(inode->i_uid));
-		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(inode->i_gid));
+		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));
+		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));
 /*
  * Fix up interoperability with old kernels. Otherwise, old inodes get
  * re-used with the upper 16 bits of the uid/gid intact
  */
 		if(!ei->i_dtime) {
 			raw_inode->i_uid_high =
-				cpu_to_le16(high_16_bits(inode->i_uid));
+				cpu_to_le16(high_16_bits(uid));
 			raw_inode->i_gid_high =
-				cpu_to_le16(high_16_bits(inode->i_gid));
+				cpu_to_le16(high_16_bits(gid));
 		} else {
 			raw_inode->i_uid_high = 0;
 			raw_inode->i_gid_high = 0;
 		}
 	} else {
 		raw_inode->i_uid_low =
-			cpu_to_le16(fs_high2lowuid(inode->i_uid));
+			cpu_to_le16(fs_high2lowuid(uid));
 		raw_inode->i_gid_low =
-			cpu_to_le16(fs_high2lowgid(inode->i_gid));
+			cpu_to_le16(fs_high2lowgid(gid));
 		raw_inode->i_uid_high = 0;
 		raw_inode->i_gid_high = 0;
 	}
+#ifdef CONFIG_TAGGING_INTERN
+	raw_inode->i_raw_tag = cpu_to_le16(inode->i_tag);
+#endif
 	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
 	raw_inode->i_size = cpu_to_le32(ei->i_disksize);
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
@@ -2913,7 +2972,8 @@ int ext3_setattr(struct dentry *dentry, 
 		return error;
 
 	if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
-		(ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid)) {
+		(ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid) ||
+		(ia_valid & ATTR_TAG && attr->ia_tag != inode->i_tag)) {
 		handle_t *handle;
 
 		/* (user+group)*(old+new) structure, inode write (sb,
@@ -2935,6 +2995,8 @@ int ext3_setattr(struct dentry *dentry, 
 			inode->i_uid = attr->ia_uid;
 		if (attr->ia_valid & ATTR_GID)
 			inode->i_gid = attr->ia_gid;
+		if ((attr->ia_valid & ATTR_TAG) && IS_TAGGED(inode))
+			inode->i_tag = attr->ia_tag;
 		error = ext3_mark_inode_dirty(handle, inode);
 		ext3_journal_stop(handle);
 	}
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/ioctl.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/ioctl.c
--- linux-2.6.20.15/fs/ext3/ioctl.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/ioctl.c	2007-02-06 03:05:22 +0100
@@ -8,6 +8,7 @@
  */
 
 #include <linux/fs.h>
+#include <linux/mount.h>
 #include <linux/jbd.h>
 #include <linux/capability.h>
 #include <linux/ext3_fs.h>
@@ -15,6 +16,7 @@
 #include <linux/time.h>
 #include <linux/compat.h>
 #include <linux/smp_lock.h>
+#include <linux/vs_tag.h>
 #include <asm/uaccess.h>
 
 int ext3_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
@@ -37,7 +39,8 @@ int ext3_ioctl (struct inode * inode, st
 		unsigned int oldflags;
 		unsigned int jflag;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
@@ -61,7 +64,9 @@ int ext3_ioctl (struct inode * inode, st
 		 *
 		 * This test looks nicer. Thanks to Pauline Middelink
 		 */
-		if ((flags ^ oldflags) & (EXT3_APPEND_FL | EXT3_IMMUTABLE_FL)) {
+		if ((oldflags & EXT3_IMMUTABLE_FL) ||
+			((flags ^ oldflags) & (EXT3_APPEND_FL |
+			EXT3_IMMUTABLE_FL | EXT3_IUNLINK_FL))) {
 			if (!capable(CAP_LINUX_IMMUTABLE)) {
 				mutex_unlock(&inode->i_mutex);
 				return -EPERM;
@@ -123,7 +128,8 @@ flags_err:
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
 			return -EPERM;
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 		if (get_user(generation, (int __user *) arg))
 			return -EFAULT;
@@ -177,7 +183,8 @@ flags_err:
 		if (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))
 			return -ENOTTY;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
@@ -212,7 +219,8 @@ flags_err:
 		if (!capable(CAP_SYS_RESOURCE))
 			return -EPERM;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if (get_user(n_blocks_count, (__u32 __user *)arg))
@@ -233,7 +241,8 @@ flags_err:
 		if (!capable(CAP_SYS_RESOURCE))
 			return -EPERM;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if (copy_from_user(&input, (struct ext3_new_group_input __user *)arg,
@@ -248,6 +257,38 @@ flags_err:
 		return err;
 	}
 
+#if defined(CONFIG_VSERVER_LEGACY) && !defined(CONFIG_TAGGING_NONE)
+	case EXT3_IOC_SETTAG: {
+		handle_t *handle;
+		struct ext3_iloc iloc;
+		int tag;
+		int err;
+
+		/* fixme: if stealth, return -ENOTTY */
+		if (!capable(CAP_CONTEXT))
+			return -EPERM;
+		if (IS_RDONLY(inode))
+			return -EROFS;
+		if (!(inode->i_sb->s_flags & MS_TAGGED))
+			return -ENOSYS;
+		if (get_user(tag, (int __user *) arg))
+			return -EFAULT;
+
+		handle = ext3_journal_start(inode, 1);
+		if (IS_ERR(handle))
+			return PTR_ERR(handle);
+		err = ext3_reserve_inode_write(handle, inode, &iloc);
+		if (err)
+			return err;
+
+		inode->i_tag = (tag & 0xFFFF);
+		inode->i_ctime = CURRENT_TIME;
+
+		err = ext3_mark_iloc_dirty(handle, inode, &iloc);
+		ext3_journal_stop(handle);
+		return err;
+	}
+#endif
 
 	default:
 		return -ENOTTY;
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/namei.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/namei.c
--- linux-2.6.20.15/fs/ext3/namei.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/namei.c	2007-02-06 03:05:22 +0100
@@ -37,6 +37,7 @@
 #include <linux/buffer_head.h>
 #include <linux/bio.h>
 #include <linux/smp_lock.h>
+#include <linux/vs_tag.h>
 
 #include "namei.h"
 #include "xattr.h"
@@ -1019,6 +1020,7 @@ static struct dentry *ext3_lookup(struct
 
 		if (!inode)
 			return ERR_PTR(-EACCES);
+		dx_propagate_tag(nd, inode);
 	}
 	return d_splice_alias(inode, dentry);
 }
@@ -2392,6 +2394,7 @@ struct inode_operations ext3_dir_inode_o
 	.removexattr	= generic_removexattr,
 #endif
 	.permission	= ext3_permission,
+	.sync_flags	= ext3_sync_flags,
 };
 
 struct inode_operations ext3_special_inode_operations = {
@@ -2403,4 +2406,5 @@ struct inode_operations ext3_special_ino
 	.removexattr	= generic_removexattr,
 #endif
 	.permission	= ext3_permission,
+	.sync_flags	= ext3_sync_flags,
 };
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/super.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/super.c
--- linux-2.6.20.15/fs/ext3/super.c	2007-06-13 01:43:20 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/super.c	2007-03-10 18:57:30 +0100
@@ -677,7 +677,7 @@ enum {
 	Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,
 	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_quota, Opt_noquota,
 	Opt_ignore, Opt_barrier, Opt_err, Opt_resize, Opt_usrquota,
-	Opt_grpquota
+	Opt_grpquota, Opt_tag, Opt_notag, Opt_tagid
 };
 
 static match_table_t tokens = {
@@ -727,6 +727,10 @@ static match_table_t tokens = {
 	{Opt_quota, "quota"},
 	{Opt_usrquota, "usrquota"},
 	{Opt_barrier, "barrier=%u"},
+	{Opt_tag, "tag"},
+	{Opt_notag, "notag"},
+	{Opt_tagid, "tagid=%u"},
+	{Opt_tag, "tagxid"},
 	{Opt_err, NULL},
 	{Opt_resize, "resize"},
 };
@@ -820,6 +824,20 @@ static int parse_options (char *options,
 		case Opt_nouid32:
 			set_opt (sbi->s_mount_opt, NO_UID32);
 			break;
+#ifndef CONFIG_TAGGING_NONE
+		case Opt_tag:
+			set_opt (sbi->s_mount_opt, TAGGED);
+			break;
+		case Opt_notag:
+			clear_opt (sbi->s_mount_opt, TAGGED);
+			break;
+#endif
+#ifdef CONFIG_PROPAGATE
+		case Opt_tagid:
+			/* use args[0] */
+			set_opt (sbi->s_mount_opt, TAGGED);
+			break;
+#endif
 		case Opt_nocheck:
 			clear_opt (sbi->s_mount_opt, CHECK);
 			break;
@@ -1490,6 +1508,9 @@ static int ext3_fill_super (struct super
 			    NULL, 0))
 		goto failed_mount;
 
+	if (EXT3_SB(sb)->s_mount_opt & EXT3_MOUNT_TAGGED)
+		sb->s_flags |= MS_TAGGED;
+
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((sbi->s_mount_opt & EXT3_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
 
@@ -2305,6 +2326,12 @@ static int ext3_remount (struct super_bl
 
 	if (sbi->s_mount_opt & EXT3_MOUNT_ABORT)
 		ext3_abort(sb, __FUNCTION__, "Abort forced by user");
+	if ((sbi->s_mount_opt & EXT3_MOUNT_TAGGED) &&
+		!(sb->s_flags & MS_TAGGED)) {
+		printk("EXT3-fs: %s: tagging not permitted on remount.\n",
+			sb->s_id);
+		return -EINVAL;
+	}
 
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((sbi->s_mount_opt & EXT3_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/symlink.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/symlink.c
--- linux-2.6.20.15/fs/ext3/symlink.c	2005-08-29 22:25:30 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/symlink.c	2007-02-06 03:05:22 +0100
@@ -40,6 +40,7 @@ struct inode_operations ext3_symlink_ino
 	.listxattr	= ext3_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+	.sync_flags	= ext3_sync_flags,
 };
 
 struct inode_operations ext3_fast_symlink_inode_operations = {
@@ -51,4 +52,5 @@ struct inode_operations ext3_fast_symlin
 	.listxattr	= ext3_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+	.sync_flags	= ext3_sync_flags,
 };
diff -NurpP --minimal linux-2.6.20.15/fs/ext3/xattr.c linux-2.6.20.15-vs2.2.0.1/fs/ext3/xattr.c
--- linux-2.6.20.15/fs/ext3/xattr.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext3/xattr.c	2007-02-06 03:05:22 +0100
@@ -58,6 +58,7 @@
 #include <linux/mbcache.h>
 #include <linux/quotaops.h>
 #include <linux/rwsem.h>
+#include <linux/vs_dlimit.h>
 #include "xattr.h"
 #include "acl.h"
 
@@ -492,6 +493,7 @@ ext3_xattr_release_block(handle_t *handl
 			ext3_journal_dirty_metadata(handle, bh);
 			if (IS_SYNC(inode))
 				handle->h_sync = 1;
+			DLIMIT_FREE_BLOCK(inode, 1);
 			DQUOT_FREE_BLOCK(inode, 1);
 			unlock_buffer(bh);
 			ea_bdebug(bh, "refcount now=%d; releasing",
@@ -760,11 +762,14 @@ inserted:
 			if (new_bh == bs->bh)
 				ea_bdebug(new_bh, "keeping");
 			else {
+				error = -ENOSPC;
+				if (DLIMIT_ALLOC_BLOCK(inode, 1))
+					goto cleanup;
 				/* The old block is released after updating
 				   the inode. */
 				error = -EDQUOT;
 				if (DQUOT_ALLOC_BLOCK(inode, 1))
-					goto cleanup;
+					goto cleanup_dlimit;
 				error = ext3_journal_get_write_access(handle,
 								      new_bh);
 				if (error)
@@ -841,6 +846,8 @@ cleanup:
 
 cleanup_dquot:
 	DQUOT_FREE_BLOCK(inode, 1);
+cleanup_dlimit:
+	DLIMIT_FREE_BLOCK(inode, 1);
 	goto cleanup;
 
 bad_block:
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/balloc.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/balloc.c
--- linux-2.6.20.15/fs/ext4/balloc.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/balloc.c	2007-07-16 06:32:05 +0200
@@ -19,6 +19,8 @@
 #include <linux/ext4_jbd2.h>
 #include <linux/quotaops.h>
 #include <linux/buffer_head.h>
+#include <linux/vs_dlimit.h>
+#include <linux/vs_tag.h>
 
 /*
  * balloc.c contains the blocks allocation and deallocation routines
@@ -630,8 +632,10 @@ void ext4_free_blocks(handle_t *handle, 
 		return;
 	}
 	ext4_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);
-	if (dquot_freed_blocks)
+	if (dquot_freed_blocks) {
+		DLIMIT_FREE_BLOCK(inode, dquot_freed_blocks);
 		DQUOT_FREE_BLOCK(inode, dquot_freed_blocks);
+	}
 	return;
 }
 
@@ -1370,18 +1374,33 @@ out:
  *
  * Check if filesystem has at least 1 free block available for allocation.
  */
-static int ext4_has_free_blocks(struct ext4_sb_info *sbi)
+static int ext4_has_free_blocks(struct super_block *sb)
 {
+	struct ext4_sb_info *sbi = EXT4_SB(sb);
 	ext4_fsblk_t free_blocks, root_blocks;
+	int cond;
 
 	free_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);
 	root_blocks = ext4_r_blocks_count(sbi->s_es);
-	if (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&
+
+	vxdprintk(VXD_CBIT(dlim, 3),
+		"ext4_has_free_blocks(%p): free=%llu, root=%llu",
+		sb, free_blocks, root_blocks);
+
+	DLIMIT_ADJUST_BLOCK(sb, dx_current_tag(), &free_blocks, &root_blocks);
+
+	cond = (free_blocks < root_blocks + 1 &&
+		!capable(CAP_SYS_RESOURCE) &&
 		sbi->s_resuid != current->fsuid &&
-		(sbi->s_resgid == 0 || !in_group_p (sbi->s_resgid))) {
-		return 0;
-	}
-	return 1;
+		(sbi->s_resgid == 0 || !in_group_p (sbi->s_resgid)));
+
+	vxdprintk(VXD_CBIT(dlim, 3),
+		"ext4_has_free_blocks(%p): %llu<%llu+1, %c, %u!=%u r=%d",
+		sb, free_blocks, root_blocks,
+		!capable(CAP_SYS_RESOURCE)?'1':'0',
+		sbi->s_resuid, current->fsuid, cond?0:1);
+
+	return (cond ? 0 : 1);
 }
 
 /**
@@ -1398,7 +1417,7 @@ static int ext4_has_free_blocks(struct e
  */
 int ext4_should_retry_alloc(struct super_block *sb, int *retries)
 {
-	if (!ext4_has_free_blocks(EXT4_SB(sb)) || (*retries)++ > 3)
+	if (!ext4_has_free_blocks(sb) || (*retries)++ > 3)
 		return 0;
 
 	jbd_debug(1, "%s: retrying operation after ENOSPC\n", sb->s_id);
@@ -1461,6 +1480,8 @@ ext4_fsblk_t ext4_new_blocks(handle_t *h
 		*errp = -EDQUOT;
 		return 0;
 	}
+	if (DLIMIT_ALLOC_BLOCK(inode, num))
+	    goto out_dlimit;
 
 	sbi = EXT4_SB(sb);
 	es = EXT4_SB(sb)->s_es;
@@ -1477,7 +1498,7 @@ ext4_fsblk_t ext4_new_blocks(handle_t *h
 	if (block_i && ((windowsz = block_i->rsv_window_node.rsv_goal_size) > 0))
 		my_rsv = &block_i->rsv_window_node;
 
-	if (!ext4_has_free_blocks(sbi)) {
+	if (!ext4_has_free_blocks(sb)) {
 		*errp = -ENOSPC;
 		goto out;
 	}
@@ -1661,12 +1682,16 @@ allocated:
 	*errp = 0;
 	brelse(bitmap_bh);
 	DQUOT_FREE_BLOCK(inode, *count-num);
+	DLIMIT_FREE_BLOCK(inode, *count-num);
 	*count = num;
 	return ret_block;
 
 io_error:
 	*errp = -EIO;
 out:
+	if (!performed_allocation)
+		DLIMIT_FREE_BLOCK(inode, *count);
+out_dlimit:
 	if (fatal) {
 		*errp = fatal;
 		ext4_std_error(sb, fatal);
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/file.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/file.c
--- linux-2.6.20.15/fs/ext4/file.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/file.c	2007-02-06 03:05:22 +0100
@@ -121,6 +121,7 @@ const struct file_operations ext4_file_o
 	.release	= ext4_release_file,
 	.fsync		= ext4_sync_file,
 	.sendfile	= generic_file_sendfile,
+	.sendpage	= generic_file_sendpage,
 	.splice_read	= generic_file_splice_read,
 	.splice_write	= generic_file_splice_write,
 };
@@ -135,5 +136,6 @@ struct inode_operations ext4_file_inode_
 	.removexattr	= generic_removexattr,
 #endif
 	.permission	= ext4_permission,
+	.sync_flags	= ext4_sync_flags,
 };
 
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/ialloc.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/ialloc.c
--- linux-2.6.20.15/fs/ext4/ialloc.c	2006-11-30 21:19:20 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/ialloc.c	2007-02-06 03:05:22 +0100
@@ -24,6 +24,8 @@
 #include <linux/random.h>
 #include <linux/bitops.h>
 #include <linux/blkdev.h>
+#include <linux/vs_dlimit.h>
+#include <linux/vs_tag.h>
 #include <asm/byteorder.h>
 
 #include "xattr.h"
@@ -127,6 +129,7 @@ void ext4_free_inode (handle_t *handle, 
 	ext4_xattr_delete_inode(handle, inode);
 	DQUOT_FREE_INODE(inode);
 	DQUOT_DROP(inode);
+	DLIMIT_FREE_INODE(inode);
 
 	is_directory = S_ISDIR(inode->i_mode);
 
@@ -448,6 +451,12 @@ struct inode *ext4_new_inode(handle_t *h
 	inode = new_inode(sb);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
+
+	inode->i_tag = dx_current_fstag(sb);
+	if (DLIMIT_ALLOC_INODE(inode)) {
+		err = -ENOSPC;
+		goto out_dlimit;
+	}
 	ei = EXT4_I(inode);
 
 	sbi = EXT4_SB(sb);
@@ -569,7 +578,8 @@ got:
 	ei->i_dir_start_lookup = 0;
 	ei->i_disksize = 0;
 
-	ei->i_flags = EXT4_I(dir)->i_flags & ~EXT4_INDEX_FL;
+	ei->i_flags = EXT4_I(dir)->i_flags &
+		~(EXT4_INDEX_FL|EXT4_IUNLINK_FL|EXT4_BARRIER_FL);
 	if (S_ISLNK(mode))
 		ei->i_flags &= ~(EXT4_IMMUTABLE_FL|EXT4_APPEND_FL);
 	/* dirsync only applies to directories */
@@ -635,6 +645,8 @@ got:
 fail:
 	ext4_std_error(sb, err);
 out:
+	DLIMIT_FREE_INODE(inode);
+out_dlimit:
 	iput(inode);
 	ret = ERR_PTR(err);
 really_out:
@@ -646,6 +658,7 @@ fail_free_drop:
 
 fail_drop:
 	DQUOT_DROP(inode);
+	DLIMIT_FREE_INODE(inode);
 	inode->i_flags |= S_NOQUOTA;
 	inode->i_nlink = 0;
 	iput(inode);
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/inode.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/inode.c
--- linux-2.6.20.15/fs/ext4/inode.c	2007-06-13 01:43:20 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/inode.c	2007-05-02 19:39:41 +0200
@@ -37,6 +37,7 @@
 #include <linux/mpage.h>
 #include <linux/uio.h>
 #include <linux/bio.h>
+#include <linux/vs_tag.h>
 #include "xattr.h"
 #include "acl.h"
 
@@ -2245,7 +2246,7 @@ void ext4_truncate(struct inode *inode)
 		return;
 	if (ext4_inode_is_fast_symlink(inode))
 		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+	if (IS_APPEND(inode) || IS_IXORUNLINK(inode))
 		return;
 
 	/*
@@ -2571,19 +2572,65 @@ void ext4_set_inode_flags(struct inode *
 {
 	unsigned int flags = EXT4_I(inode)->i_flags;
 
-	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
+	inode->i_flags &= ~(S_IMMUTABLE | S_IUNLINK | S_BARRIER |
+		S_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);
+
+	if (flags & EXT4_IMMUTABLE_FL)
+		inode->i_flags |= S_IMMUTABLE;
+	if (flags & EXT4_IUNLINK_FL)
+		inode->i_flags |= S_IUNLINK;
+	if (flags & EXT4_BARRIER_FL)
+		inode->i_flags |= S_BARRIER;
+
 	if (flags & EXT4_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (flags & EXT4_APPEND_FL)
 		inode->i_flags |= S_APPEND;
-	if (flags & EXT4_IMMUTABLE_FL)
-		inode->i_flags |= S_IMMUTABLE;
 	if (flags & EXT4_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
 	if (flags & EXT4_DIRSYNC_FL)
 		inode->i_flags |= S_DIRSYNC;
 }
 
+int ext4_sync_flags(struct inode *inode)
+{
+	unsigned int oldflags, newflags;
+	int err = 0;
+
+	oldflags = EXT4_I(inode)->i_flags;
+	newflags = oldflags & ~(EXT4_IMMUTABLE_FL |
+		EXT4_IUNLINK_FL | EXT4_BARRIER_FL);
+
+	if (IS_IMMUTABLE(inode))
+		newflags |= EXT4_IMMUTABLE_FL;
+	if (IS_IUNLINK(inode))
+		newflags |= EXT4_IUNLINK_FL;
+	if (IS_BARRIER(inode))
+		newflags |= EXT4_BARRIER_FL;
+
+	if (oldflags ^ newflags) {
+		handle_t *handle;
+		struct ext4_iloc iloc;
+
+		handle = ext4_journal_start(inode, 1);
+		if (IS_ERR(handle))
+			return PTR_ERR(handle);
+		if (IS_SYNC(inode))
+			handle->h_sync = 1;
+		err = ext4_reserve_inode_write(handle, inode, &iloc);
+		if (err)
+			goto flags_err;
+
+		EXT4_I(inode)->i_flags = newflags;
+		inode->i_ctime = CURRENT_TIME;
+
+		err = ext4_mark_iloc_dirty(handle, inode, &iloc);
+	flags_err:
+		ext4_journal_stop(handle);
+	}
+	return err;
+}
+
 void ext4_read_inode(struct inode * inode)
 {
 	struct ext4_iloc iloc;
@@ -2591,6 +2638,8 @@ void ext4_read_inode(struct inode * inod
 	struct ext4_inode_info *ei = EXT4_I(inode);
 	struct buffer_head *bh;
 	int block;
+	uid_t uid;
+	gid_t gid;
 
 #ifdef CONFIG_EXT4DEV_FS_POSIX_ACL
 	ei->i_acl = EXT4_ACL_NOT_CACHED;
@@ -2603,12 +2652,17 @@ void ext4_read_inode(struct inode * inod
 	bh = iloc.bh;
 	raw_inode = ext4_raw_inode(&iloc);
 	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
-	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
-	inode->i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
+	uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
+	gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
 	if(!(test_opt (inode->i_sb, NO_UID32))) {
-		inode->i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
-		inode->i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
+		uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
+		gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
 	}
+	inode->i_uid = INOTAG_UID(DX_TAG(inode), uid, gid);
+	inode->i_gid = INOTAG_GID(DX_TAG(inode), uid, gid);
+	inode->i_tag = INOTAG_TAG(DX_TAG(inode), uid, gid,
+		le16_to_cpu(raw_inode->i_raw_tag));
+
 	inode->i_nlink = le16_to_cpu(raw_inode->i_links_count);
 	inode->i_size = le32_to_cpu(raw_inode->i_size);
 	inode->i_atime.tv_sec = le32_to_cpu(raw_inode->i_atime);
@@ -2736,6 +2790,8 @@ static int ext4_do_update_inode(handle_t
 	struct ext4_inode *raw_inode = ext4_raw_inode(iloc);
 	struct ext4_inode_info *ei = EXT4_I(inode);
 	struct buffer_head *bh = iloc->bh;
+	uid_t uid = TAGINO_UID(DX_TAG(inode), inode->i_uid, inode->i_tag);
+	gid_t gid = TAGINO_GID(DX_TAG(inode), inode->i_gid, inode->i_tag);
 	int err = 0, rc, block;
 
 	/* For fields not not tracking in the in-memory inode,
@@ -2745,29 +2801,32 @@ static int ext4_do_update_inode(handle_t
 
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
 	if(!(test_opt(inode->i_sb, NO_UID32))) {
-		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(inode->i_uid));
-		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(inode->i_gid));
+		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));
+		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));
 /*
  * Fix up interoperability with old kernels. Otherwise, old inodes get
  * re-used with the upper 16 bits of the uid/gid intact
  */
 		if(!ei->i_dtime) {
 			raw_inode->i_uid_high =
-				cpu_to_le16(high_16_bits(inode->i_uid));
+				cpu_to_le16(high_16_bits(uid));
 			raw_inode->i_gid_high =
-				cpu_to_le16(high_16_bits(inode->i_gid));
+				cpu_to_le16(high_16_bits(gid));
 		} else {
 			raw_inode->i_uid_high = 0;
 			raw_inode->i_gid_high = 0;
 		}
 	} else {
 		raw_inode->i_uid_low =
-			cpu_to_le16(fs_high2lowuid(inode->i_uid));
+			cpu_to_le16(fs_high2lowuid(uid));
 		raw_inode->i_gid_low =
-			cpu_to_le16(fs_high2lowgid(inode->i_gid));
+			cpu_to_le16(fs_high2lowgid(gid));
 		raw_inode->i_uid_high = 0;
 		raw_inode->i_gid_high = 0;
 	}
+#ifdef CONFIG_TAGGING_INTERN
+	raw_inode->i_raw_tag = cpu_to_le16(inode->i_tag);
+#endif
 	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
 	raw_inode->i_size = cpu_to_le32(ei->i_disksize);
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
@@ -2924,7 +2983,8 @@ int ext4_setattr(struct dentry *dentry, 
 		return error;
 
 	if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
-		(ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid)) {
+		(ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid) ||
+		(ia_valid & ATTR_TAG && attr->ia_tag != inode->i_tag)) {
 		handle_t *handle;
 
 		/* (user+group)*(old+new) structure, inode write (sb,
@@ -2946,6 +3006,8 @@ int ext4_setattr(struct dentry *dentry, 
 			inode->i_uid = attr->ia_uid;
 		if (attr->ia_valid & ATTR_GID)
 			inode->i_gid = attr->ia_gid;
+		if ((attr->ia_valid & ATTR_TAG) && IS_TAGGED(inode))
+			inode->i_tag = attr->ia_tag;
 		error = ext4_mark_inode_dirty(handle, inode);
 		ext4_journal_stop(handle);
 	}
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/ioctl.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/ioctl.c
--- linux-2.6.20.15/fs/ext4/ioctl.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/ioctl.c	2007-02-06 03:05:22 +0100
@@ -8,6 +8,7 @@
  */
 
 #include <linux/fs.h>
+#include <linux/mount.h>
 #include <linux/jbd2.h>
 #include <linux/capability.h>
 #include <linux/ext4_fs.h>
@@ -15,6 +16,7 @@
 #include <linux/time.h>
 #include <linux/compat.h>
 #include <linux/smp_lock.h>
+#include <linux/vs_tag.h>
 #include <asm/uaccess.h>
 
 int ext4_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
@@ -37,7 +39,8 @@ int ext4_ioctl (struct inode * inode, st
 		unsigned int oldflags;
 		unsigned int jflag;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
@@ -61,7 +64,9 @@ int ext4_ioctl (struct inode * inode, st
 		 *
 		 * This test looks nicer. Thanks to Pauline Middelink
 		 */
-		if ((flags ^ oldflags) & (EXT4_APPEND_FL | EXT4_IMMUTABLE_FL)) {
+		if ((oldflags & EXT4_IMMUTABLE_FL) ||
+			((flags ^ oldflags) & (EXT4_APPEND_FL |
+			EXT4_IMMUTABLE_FL | EXT4_IUNLINK_FL))) {
 			if (!capable(CAP_LINUX_IMMUTABLE)) {
 				mutex_unlock(&inode->i_mutex);
 				return -EPERM;
@@ -123,7 +128,8 @@ flags_err:
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
 			return -EPERM;
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 		if (get_user(generation, (int __user *) arg))
 			return -EFAULT;
@@ -177,7 +183,8 @@ flags_err:
 		if (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))
 			return -ENOTTY;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
@@ -212,7 +219,8 @@ flags_err:
 		if (!capable(CAP_SYS_RESOURCE))
 			return -EPERM;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if (get_user(n_blocks_count, (__u32 __user *)arg))
@@ -233,7 +241,8 @@ flags_err:
 		if (!capable(CAP_SYS_RESOURCE))
 			return -EPERM;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if (copy_from_user(&input, (struct ext4_new_group_input __user *)arg,
@@ -248,6 +257,39 @@ flags_err:
 		return err;
 	}
 
+#if defined(CONFIG_VSERVER_LEGACY) && !defined(CONFIG_TAGGING_NONE)
+	case EXT4_IOC_SETTAG: {
+		handle_t *handle;
+		struct ext4_iloc iloc;
+		int tag;
+		int err;
+
+		/* fixme: if stealth, return -ENOTTY */
+		if (!capable(CAP_CONTEXT))
+			return -EPERM;
+		if (IS_RDONLY(inode))
+			return -EROFS;
+		if (!(inode->i_sb->s_flags & MS_TAGGED))
+			return -ENOSYS;
+		if (get_user(tag, (int __user *) arg))
+			return -EFAULT;
+
+		handle = ext4_journal_start(inode, 1);
+		if (IS_ERR(handle))
+			return PTR_ERR(handle);
+		err = ext4_reserve_inode_write(handle, inode, &iloc);
+		if (err)
+			return err;
+
+		inode->i_tag = (tag & 0xFFFF);
+		inode->i_ctime = CURRENT_TIME;
+
+		err = ext4_mark_iloc_dirty(handle, inode, &iloc);
+		ext4_journal_stop(handle);
+		return err;
+	}
+#endif
+
 	default:
 		return -ENOTTY;
 	}
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/namei.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/namei.c
--- linux-2.6.20.15/fs/ext4/namei.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/namei.c	2007-02-06 03:05:22 +0100
@@ -37,6 +37,7 @@
 #include <linux/buffer_head.h>
 #include <linux/bio.h>
 #include <linux/smp_lock.h>
+#include <linux/vs_tag.h>
 
 #include "namei.h"
 #include "xattr.h"
@@ -1017,6 +1018,7 @@ static struct dentry *ext4_lookup(struct
 
 		if (!inode)
 			return ERR_PTR(-EACCES);
+		dx_propagate_tag(nd, inode);
 	}
 	return d_splice_alias(inode, dentry);
 }
@@ -2390,6 +2392,7 @@ struct inode_operations ext4_dir_inode_o
 	.removexattr	= generic_removexattr,
 #endif
 	.permission	= ext4_permission,
+	.sync_flags	= ext4_sync_flags,
 };
 
 struct inode_operations ext4_special_inode_operations = {
@@ -2401,4 +2404,5 @@ struct inode_operations ext4_special_ino
 	.removexattr	= generic_removexattr,
 #endif
 	.permission	= ext4_permission,
+	.sync_flags	= ext4_sync_flags,
 };
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/super.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/super.c
--- linux-2.6.20.15/fs/ext4/super.c	2007-06-13 01:43:20 +0200
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/super.c	2007-03-10 18:57:30 +0100
@@ -728,7 +728,7 @@ enum {
 	Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,
 	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_quota, Opt_noquota,
 	Opt_ignore, Opt_barrier, Opt_err, Opt_resize, Opt_usrquota,
-	Opt_grpquota, Opt_extents,
+	Opt_grpquota, Opt_extents, Opt_tag, Opt_notag, Opt_tagid
 };
 
 static match_table_t tokens = {
@@ -779,6 +779,10 @@ static match_table_t tokens = {
 	{Opt_usrquota, "usrquota"},
 	{Opt_barrier, "barrier=%u"},
 	{Opt_extents, "extents"},
+	{Opt_tag, "tag"},
+	{Opt_notag, "notag"},
+	{Opt_tagid, "tagid=%u"},
+	{Opt_tag, "tagxid"},
 	{Opt_err, NULL},
 	{Opt_resize, "resize"},
 };
@@ -872,6 +876,20 @@ static int parse_options (char *options,
 		case Opt_nouid32:
 			set_opt (sbi->s_mount_opt, NO_UID32);
 			break;
+#ifndef CONFIG_TAGGING_NONE
+		case Opt_tag:
+			set_opt (sbi->s_mount_opt, TAGGED);
+			break;
+		case Opt_notag:
+			clear_opt (sbi->s_mount_opt, TAGGED);
+			break;
+#endif
+#ifdef CONFIG_PROPAGATE
+		case Opt_tagid:
+			/* use args[0] */
+			set_opt (sbi->s_mount_opt, TAGGED);
+			break;
+#endif
 		case Opt_nocheck:
 			clear_opt (sbi->s_mount_opt, CHECK);
 			break;
@@ -1549,6 +1567,9 @@ static int ext4_fill_super (struct super
 			    NULL, 0))
 		goto failed_mount;
 
+	if (EXT4_SB(sb)->s_mount_opt & EXT4_MOUNT_TAGGED)
+		sb->s_flags |= MS_TAGGED;
+
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((sbi->s_mount_opt & EXT4_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
 
@@ -2380,6 +2401,12 @@ static int ext4_remount (struct super_bl
 
 	if (sbi->s_mount_opt & EXT4_MOUNT_ABORT)
 		ext4_abort(sb, __FUNCTION__, "Abort forced by user");
+	if ((sbi->s_mount_opt & EXT4_MOUNT_TAGGED) &&
+		!(sb->s_flags & MS_TAGGED)) {
+		printk("EXT4-fs: %s: tagging not permitted on remount.\n",
+			sb->s_id);
+		return -EINVAL;
+	}
 
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((sbi->s_mount_opt & EXT4_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/symlink.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/symlink.c
--- linux-2.6.20.15/fs/ext4/symlink.c	2006-11-30 21:19:20 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/symlink.c	2007-02-06 03:05:22 +0100
@@ -40,6 +40,7 @@ struct inode_operations ext4_symlink_ino
 	.listxattr	= ext4_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+	.sync_flags	= ext4_sync_flags,
 };
 
 struct inode_operations ext4_fast_symlink_inode_operations = {
@@ -51,4 +52,5 @@ struct inode_operations ext4_fast_symlin
 	.listxattr	= ext4_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+	.sync_flags	= ext4_sync_flags,
 };
diff -NurpP --minimal linux-2.6.20.15/fs/ext4/xattr.c linux-2.6.20.15-vs2.2.0.1/fs/ext4/xattr.c
--- linux-2.6.20.15/fs/ext4/xattr.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ext4/xattr.c	2007-02-06 03:05:22 +0100
@@ -58,6 +58,7 @@
 #include <linux/mbcache.h>
 #include <linux/quotaops.h>
 #include <linux/rwsem.h>
+#include <linux/vs_dlimit.h>
 #include "xattr.h"
 #include "acl.h"
 
@@ -492,6 +493,7 @@ ext4_xattr_release_block(handle_t *handl
 			ext4_journal_dirty_metadata(handle, bh);
 			if (IS_SYNC(inode))
 				handle->h_sync = 1;
+			DLIMIT_FREE_BLOCK(inode, 1);
 			DQUOT_FREE_BLOCK(inode, 1);
 			unlock_buffer(bh);
 			ea_bdebug(bh, "refcount now=%d; releasing",
@@ -760,11 +762,14 @@ inserted:
 			if (new_bh == bs->bh)
 				ea_bdebug(new_bh, "keeping");
 			else {
+				error = -ENOSPC;
+				if (DLIMIT_ALLOC_BLOCK(inode, 1))
+					goto cleanup;
 				/* The old block is released after updating
 				   the inode. */
 				error = -EDQUOT;
 				if (DQUOT_ALLOC_BLOCK(inode, 1))
-					goto cleanup;
+					goto cleanup_dlimit;
 				error = ext4_journal_get_write_access(handle,
 								      new_bh);
 				if (error)
@@ -841,6 +846,8 @@ cleanup:
 
 cleanup_dquot:
 	DQUOT_FREE_BLOCK(inode, 1);
+cleanup_dlimit:
+	DLIMIT_FREE_BLOCK(inode, 1);
 	goto cleanup;
 
 bad_block:
diff -NurpP --minimal linux-2.6.20.15/fs/fcntl.c linux-2.6.20.15-vs2.2.0.1/fs/fcntl.c
--- linux-2.6.20.15/fs/fcntl.c	2007-02-06 03:01:18 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/fcntl.c	2007-02-06 03:05:22 +0100
@@ -18,6 +18,7 @@
 #include <linux/ptrace.h>
 #include <linux/signal.h>
 #include <linux/rcupdate.h>
+#include <linux/vs_limit.h>
 
 #include <asm/poll.h>
 #include <asm/siginfo.h>
@@ -84,6 +85,8 @@ repeat:
 	error = -EMFILE;
 	if (newfd >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
+	if (!vx_files_avail(1))
+		goto out;
 
 	error = expand_files(files, newfd);
 	if (error < 0)
@@ -124,6 +127,7 @@ static int dupfd(struct file *file, unsi
 		FD_SET(fd, fdt->open_fds);
 		FD_CLR(fd, fdt->close_on_exec);
 		spin_unlock(&files->file_lock);
+		vx_openfd_inc(fd);
 		fd_install(fd, file);
 	} else {
 		spin_unlock(&files->file_lock);
@@ -176,6 +180,9 @@ asmlinkage long sys_dup2(unsigned int ol
 
 	if (tofree)
 		filp_close(tofree, files);
+	else
+		vx_openfd_inc(newfd);	/* fd was unused */
+
 	err = newfd;
 out:
 	return err;
diff -NurpP --minimal linux-2.6.20.15/fs/file_table.c linux-2.6.20.15-vs2.2.0.1/fs/file_table.c
--- linux-2.6.20.15/fs/file_table.c	2007-02-06 03:01:19 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/file_table.c	2007-02-06 03:05:22 +0100
@@ -21,6 +21,8 @@
 #include <linux/fsnotify.h>
 #include <linux/sysctl.h>
 #include <linux/percpu_counter.h>
+#include <linux/vs_limit.h>
+#include <linux/vs_context.h>
 
 #include <asm/atomic.h>
 
@@ -120,6 +122,8 @@ struct file *get_empty_filp(void)
 	f->f_gid = tsk->fsgid;
 	eventpoll_init_file(f);
 	/* f->f_version: 0 */
+	f->f_xid = vx_current_xid();
+	vx_files_inc(f);
 	return f;
 
 over:
@@ -175,6 +179,8 @@ void fastcall __fput(struct file *file)
 	if (file->f_mode & FMODE_WRITE)
 		put_write_access(inode);
 	put_pid(file->f_owner.pid);
+	vx_files_dec(file);
+	file->f_xid = 0;
 	file_kill(file);
 	file->f_path.dentry = NULL;
 	file->f_path.mnt = NULL;
@@ -240,6 +246,8 @@ void put_filp(struct file *file)
 {
 	if (atomic_dec_and_test(&file->f_count)) {
 		security_file_free(file);
+		vx_files_dec(file);
+		file->f_xid = 0;
 		file_kill(file);
 		file_free(file);
 	}
diff -NurpP --minimal linux-2.6.20.15/fs/hfsplus/ioctl.c linux-2.6.20.15-vs2.2.0.1/fs/hfsplus/ioctl.c
--- linux-2.6.20.15/fs/hfsplus/ioctl.c	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/hfsplus/ioctl.c	2007-02-06 03:05:22 +0100
@@ -16,6 +16,7 @@
 #include <linux/fs.h>
 #include <linux/sched.h>
 #include <linux/xattr.h>
+#include <linux/mount.h>
 #include <asm/uaccess.h>
 #include "hfsplus_fs.h"
 
@@ -35,7 +36,8 @@ int hfsplus_ioctl(struct inode *inode, s
 			flags |= FS_NODUMP_FL; /* EXT2_NODUMP_FL */
 		return put_user(flags, (int __user *)arg);
 	case HFSPLUS_IOC_EXT2_SETFLAGS: {
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
diff -NurpP --minimal linux-2.6.20.15/fs/inode.c linux-2.6.20.15-vs2.2.0.1/fs/inode.c
--- linux-2.6.20.15/fs/inode.c	2007-02-06 03:01:22 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/inode.c	2007-02-06 03:05:22 +0100
@@ -115,6 +115,9 @@ static struct inode *alloc_inode(struct 
 		struct address_space * const mapping = &inode->i_data;
 
 		inode->i_sb = sb;
+
+		/* essential because of inode slab reuse */
+		inode->i_tag = 0;
 		inode->i_blkbits = sb->s_blocksize_bits;
 		inode->i_flags = 0;
 		atomic_set(&inode->i_count, 1);
@@ -233,6 +236,8 @@ void __iget(struct inode * inode)
 	inodes_stat.nr_unused--;
 }
 
+EXPORT_SYMBOL_GPL(__iget);
+
 /**
  * clear_inode - clear an inode
  * @inode: inode to clear
diff -NurpP --minimal linux-2.6.20.15/fs/ioctl.c linux-2.6.20.15-vs2.2.0.1/fs/ioctl.c
--- linux-2.6.20.15/fs/ioctl.c	2007-02-06 03:01:22 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ioctl.c	2007-02-06 03:05:22 +0100
@@ -12,10 +12,19 @@
 #include <linux/fs.h>
 #include <linux/security.h>
 #include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/vserver/inode.h>
+#include <linux/vs_tag.h>
 
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+
+#ifdef	CONFIG_VSERVER_LEGACY
+extern int vx_proc_ioctl(struct inode *, struct file *,
+	unsigned int, unsigned long);
+#endif
+
 static long do_ioctl(struct file *filp, unsigned int cmd,
 		unsigned long arg)
 {
@@ -146,6 +155,48 @@ int vfs_ioctl(struct file *filp, unsigne
 			else
 				error = -ENOTTY;
 			break;
+#ifdef	CONFIG_VSERVER_LEGACY
+#ifndef CONFIG_TAGGING_NONE
+		case FIOC_GETTAG: {
+			struct inode *inode = filp->f_dentry->d_inode;
+
+			/* fixme: if stealth, return -ENOTTY */
+			error = -EPERM;
+			if (capable(CAP_CONTEXT))
+				error = put_user(inode->i_tag, (int __user *) arg);
+			break;
+		}
+		case FIOC_SETTAG: {
+			struct inode *inode = filp->f_dentry->d_inode;
+			int tag;
+
+			/* fixme: if stealth, return -ENOTTY */
+			error = -EPERM;
+			if (!capable(CAP_CONTEXT))
+				break;
+			error = -EROFS;
+			if (IS_RDONLY(inode))
+				break;
+			error = -ENOSYS;
+			if (!(inode->i_sb->s_flags & MS_TAGGED))
+				break;
+			error = -EFAULT;
+			if (get_user(tag, (int __user *) arg))
+				break;
+			error = 0;
+			inode->i_tag = (tag & 0xFFFF);
+			inode->i_ctime = CURRENT_TIME;
+			mark_inode_dirty(inode);
+			break;
+		}
+#endif
+		case FIOC_GETXFLG:
+		case FIOC_SETXFLG:
+			error = -ENOTTY;
+			if (filp->f_dentry->d_inode->i_sb->s_magic == PROC_SUPER_MAGIC)
+				error = vx_proc_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+			break;
+#endif
 		default:
 			if (S_ISREG(filp->f_path.dentry->d_inode->i_mode))
 				error = file_ioctl(filp, cmd, arg);
diff -NurpP --minimal linux-2.6.20.15/fs/ioprio.c linux-2.6.20.15-vs2.2.0.1/fs/ioprio.c
--- linux-2.6.20.15/fs/ioprio.c	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/ioprio.c	2007-03-25 21:43:27 +0200
@@ -25,6 +25,7 @@
 #include <linux/capability.h>
 #include <linux/syscalls.h>
 #include <linux/security.h>
+#include <linux/vs_base.h>
 
 static int set_task_ioprio(struct task_struct *task, int ioprio)
 {
@@ -100,6 +101,8 @@ asmlinkage long sys_ioprio_set(int which
 			if (!who)
 				who = process_group(current);
 			do_each_task_pid(who, PIDTYPE_PGID, p) {
+				if (!vx_check(p->xid, VS_ADMIN_P | VS_IDENT))
+					continue;
 				ret = set_task_ioprio(p, ioprio);
 				if (ret)
 					break;
@@ -109,7 +112,7 @@ asmlinkage long sys_ioprio_set(int which
 			if (!who)
 				user = current->user;
 			else
-				user = find_user(who);
+				user = find_user(vx_current_xid(), who);
 
 			if (!user)
 				break;
@@ -184,6 +187,8 @@ asmlinkage long sys_ioprio_get(int which
 			if (!who)
 				who = process_group(current);
 			do_each_task_pid(who, PIDTYPE_PGID, p) {
+				if (!vx_check(p->xid, VS_ADMIN_P | VS_IDENT))
+					continue;
 				tmpio = get_task_ioprio(p);
 				if (tmpio < 0)
 					continue;
@@ -197,7 +202,7 @@ asmlinkage long sys_ioprio_get(int which
 			if (!who)
 				user = current->user;
 			else
-				user = find_user(who);
+				user = find_user(vx_current_xid(), who);
 
 			if (!user)
 				break;
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/acl.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/acl.c
--- linux-2.6.20.15/fs/jfs/acl.c	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/acl.c	2007-02-06 03:05:22 +0100
@@ -232,7 +232,8 @@ int jfs_setattr(struct dentry *dentry, s
 		return rc;
 
 	if ((iattr->ia_valid & ATTR_UID && iattr->ia_uid != inode->i_uid) ||
-	    (iattr->ia_valid & ATTR_GID && iattr->ia_gid != inode->i_gid)) {
+	    (iattr->ia_valid & ATTR_GID && iattr->ia_gid != inode->i_gid) ||
+	    (iattr->ia_valid & ATTR_TAG && iattr->ia_tag != inode->i_tag)) {
 		if (DQUOT_TRANSFER(inode, iattr))
 			return -EDQUOT;
 	}
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/file.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/file.c
--- linux-2.6.20.15/fs/jfs/file.c	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/file.c	2007-02-06 03:05:22 +0100
@@ -98,6 +98,7 @@ struct inode_operations jfs_file_inode_o
 	.setattr	= jfs_setattr,
 	.permission	= jfs_permission,
 #endif
+	.sync_flags	= jfs_sync_flags,
 };
 
 const struct file_operations jfs_file_operations = {
@@ -109,6 +110,7 @@ const struct file_operations jfs_file_op
 	.aio_write	= generic_file_aio_write,
 	.mmap		= generic_file_mmap,
 	.sendfile	= generic_file_sendfile,
+	.sendpage	= generic_file_sendpage,
 	.splice_read	= generic_file_splice_read,
 	.splice_write	= generic_file_splice_write,
 	.fsync		= jfs_fsync,
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/inode.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/inode.c
--- linux-2.6.20.15/fs/jfs/inode.c	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/inode.c	2007-02-06 03:05:22 +0100
@@ -22,6 +22,7 @@
 #include <linux/buffer_head.h>
 #include <linux/pagemap.h>
 #include <linux/quotaops.h>
+#include <linux/vs_dlimit.h>
 #include "jfs_incore.h"
 #include "jfs_inode.h"
 #include "jfs_filsys.h"
@@ -144,6 +145,7 @@ void jfs_delete_inode(struct inode *inod
 		DQUOT_INIT(inode);
 		DQUOT_FREE_INODE(inode);
 		DQUOT_DROP(inode);
+		DLIMIT_FREE_INODE(inode);
 	}
 
 	clear_inode(inode);
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/ioctl.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/ioctl.c
--- linux-2.6.20.15/fs/jfs/ioctl.c	2007-02-06 03:01:24 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/ioctl.c	2007-02-06 03:13:33 +0100
@@ -10,6 +10,7 @@
 #include <linux/capability.h>
 #include <linux/time.h>
 #include <linux/sched.h>
+#include <linux/mount.h>
 #include <asm/current.h>
 #include <asm/uaccess.h>
 
@@ -65,7 +66,8 @@ int jfs_ioctl(struct inode * inode, stru
 	case JFS_IOC_SETFLAGS: {
 		unsigned int oldflags;
 
-		if (IS_RDONLY(inode))
+		if (IS_RDONLY(inode) ||
+			(filp && MNT_IS_RDONLY(filp->f_vfsmnt)))
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
@@ -85,8 +87,8 @@ int jfs_ioctl(struct inode * inode, stru
 		 * the relevant capability.
 		 */
 		if ((oldflags & JFS_IMMUTABLE_FL) ||
-			((flags ^ oldflags) &
-			(JFS_APPEND_FL | JFS_IMMUTABLE_FL))) {
+			((flags ^ oldflags) & (JFS_APPEND_FL |
+			JFS_IMMUTABLE_FL | JFS_IUNLINK_FL))) {
 			if (!capable(CAP_LINUX_IMMUTABLE))
 				return -EPERM;
 		}
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/jfs_dinode.h linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_dinode.h
--- linux-2.6.20.15/fs/jfs/jfs_dinode.h	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_dinode.h	2007-02-06 03:05:22 +0100
@@ -162,9 +162,12 @@ struct dinode {
 #define JFS_APPEND_FL		0x01000000 /* writes to file may only append */
 #define JFS_IMMUTABLE_FL	0x02000000 /* Immutable file */
 
-#define JFS_FL_USER_VISIBLE	0x03F80000
+#define JFS_BARRIER_FL		0x04000000 /* Barrier for chroot() */
+#define JFS_IUNLINK_FL		0x08000000 /* Immutable unlink */
+
+#define JFS_FL_USER_VISIBLE	0x0FF80000
 #define JFS_FL_USER_MODIFIABLE	0x03F80000
-#define JFS_FL_INHERIT		0x03C80000
+#define JFS_FL_INHERIT		0x0BC80000
 
 /* These are identical to EXT[23]_IOC_GETFLAGS/SETFLAGS */
 #define JFS_IOC_GETFLAGS	_IOR('f', 1, long)
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/jfs_dtree.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_dtree.c
--- linux-2.6.20.15/fs/jfs/jfs_dtree.c	2007-02-06 03:01:24 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_dtree.c	2007-02-06 03:05:22 +0100
@@ -102,6 +102,7 @@
 
 #include <linux/fs.h>
 #include <linux/quotaops.h>
+#include <linux/vs_dlimit.h>
 #include "jfs_incore.h"
 #include "jfs_superblock.h"
 #include "jfs_filsys.h"
@@ -383,10 +384,10 @@ static u32 add_index(tid_t tid, struct i
 		 */
 		if (DQUOT_ALLOC_BLOCK(ip, sbi->nbperpage))
 			goto clean_up;
-		if (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {
-			DQUOT_FREE_BLOCK(ip, sbi->nbperpage);
-			goto clean_up;
-		}
+		if (DLIMIT_ALLOC_BLOCK(ip, sbi->nbperpage))
+			goto clean_up_dquot;
+		if (dbAlloc(ip, 0, sbi->nbperpage, &xaddr))
+			goto clean_up_dlimit;
 
 		/*
 		 * Save the table, we're going to overwrite it with the
@@ -479,6 +480,12 @@ static u32 add_index(tid_t tid, struct i
 
 	return index;
 
+      clean_up_dlimit:
+	DLIMIT_FREE_BLOCK(ip, sbi->nbperpage);
+
+      clean_up_dquot:
+	DQUOT_FREE_BLOCK(ip, sbi->nbperpage);
+
       clean_up:
 
 	jfs_ip->next_index--;
@@ -952,6 +959,7 @@ static int dtSplitUp(tid_t tid,
 	struct tlock *tlck;
 	struct lv *lv;
 	int quota_allocation = 0;
+	int dlimit_allocation = 0;
 
 	/* get split page */
 	smp = split->mp;
@@ -1036,6 +1044,12 @@ static int dtSplitUp(tid_t tid,
 		}
 		quota_allocation += n;
 
+		if (DLIMIT_ALLOC_BLOCK(ip, n)) {
+			rc = -ENOSPC;
+			goto extendOut;
+		}
+		dlimit_allocation += n;
+
 		if ((rc = dbReAlloc(sbi->ipbmap, xaddr, (s64) xlen,
 				    (s64) n, &nxaddr)))
 			goto extendOut;
@@ -1309,6 +1323,9 @@ static int dtSplitUp(tid_t tid,
       freeKeyName:
 	kfree(key.name);
 
+	/* Rollback dlimit allocation */
+	if (rc && dlimit_allocation)
+		DLIMIT_FREE_BLOCK(ip, dlimit_allocation);
 	/* Rollback quota allocation */
 	if (rc && quota_allocation)
 		DQUOT_FREE_BLOCK(ip, quota_allocation);
@@ -1376,6 +1393,12 @@ static int dtSplitPage(tid_t tid, struct
 		release_metapage(rmp);
 		return -EDQUOT;
 	}
+	/* Allocate blocks to dlimit. */
+	if (DLIMIT_ALLOC_BLOCK(ip, lengthPXD(pxd))) {
+		DQUOT_FREE_BLOCK(ip, lengthPXD(pxd));
+		release_metapage(rmp);
+		return -ENOSPC;
+	}
 
 	jfs_info("dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p", ip, smp, rmp);
 
@@ -1926,6 +1949,12 @@ static int dtSplitRoot(tid_t tid,
 		release_metapage(rmp);
 		return -EDQUOT;
 	}
+	/* Allocate blocks to dlimit. */
+	if (DLIMIT_ALLOC_BLOCK(ip, lengthPXD(pxd))) {
+		DQUOT_FREE_BLOCK(ip, lengthPXD(pxd));
+		release_metapage(rmp);
+		return -ENOSPC;
+	}
 
 	BT_MARK_DIRTY(rmp, ip);
 	/*
@@ -2292,6 +2321,8 @@ static int dtDeleteUp(tid_t tid, struct 
 
 	xlen = lengthPXD(&fp->header.self);
 
+	/* Free dlimit allocation. */
+	DLIMIT_FREE_BLOCK(ip, xlen);
 	/* Free quota allocation. */
 	DQUOT_FREE_BLOCK(ip, xlen);
 
@@ -2368,6 +2399,8 @@ static int dtDeleteUp(tid_t tid, struct 
 
 				xlen = lengthPXD(&p->header.self);
 
+				/* Free dlimit allocation */
+				DLIMIT_FREE_BLOCK(ip, xlen);
 				/* Free quota allocation */
 				DQUOT_FREE_BLOCK(ip, xlen);
 
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/jfs_extent.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_extent.c
--- linux-2.6.20.15/fs/jfs/jfs_extent.c	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_extent.c	2007-02-06 03:05:22 +0100
@@ -18,6 +18,7 @@
 
 #include <linux/fs.h>
 #include <linux/quotaops.h>
+#include <linux/vs_dlimit.h>
 #include "jfs_incore.h"
 #include "jfs_inode.h"
 #include "jfs_superblock.h"
@@ -147,6 +148,14 @@ extAlloc(struct inode *ip, s64 xlen, s64
 		return -EDQUOT;
 	}
 
+	/* Allocate blocks to dlimit. */
+	if (DLIMIT_ALLOC_BLOCK(ip, nxlen)) {
+		DQUOT_FREE_BLOCK(ip, nxlen);
+		dbFree(ip, nxaddr, (s64) nxlen);
+		mutex_unlock(&JFS_IP(ip)->commit_mutex);
+		return -ENOSPC;
+	}
+
 	/* determine the value of the extent flag */
 	xflag = abnr ? XAD_NOTRECORDED : 0;
 
@@ -164,6 +173,7 @@ extAlloc(struct inode *ip, s64 xlen, s64
 	 */
 	if (rc) {
 		dbFree(ip, nxaddr, nxlen);
+		DLIMIT_FREE_BLOCK(ip, nxlen);
 		DQUOT_FREE_BLOCK(ip, nxlen);
 		mutex_unlock(&JFS_IP(ip)->commit_mutex);
 		return (rc);
@@ -261,6 +271,13 @@ int extRealloc(struct inode *ip, s64 nxl
 		mutex_unlock(&JFS_IP(ip)->commit_mutex);
 		return -EDQUOT;
 	}
+	/* Allocate blocks to dlimit. */
+	if (DLIMIT_ALLOC_BLOCK(ip, nxlen)) {
+		DQUOT_FREE_BLOCK(ip, nxlen);
+		dbFree(ip, nxaddr, (s64) nxlen);
+		up(&JFS_IP(ip)->commit_sem);
+		return -ENOSPC;
+	}
 
 	delta = nxlen - xlen;
 
@@ -297,6 +314,7 @@ int extRealloc(struct inode *ip, s64 nxl
 		/* extend the extent */
 		if ((rc = xtExtend(0, ip, xoff + xlen, (int) nextend, 0))) {
 			dbFree(ip, xaddr + xlen, delta);
+			DLIMIT_FREE_BLOCK(ip, nxlen);
 			DQUOT_FREE_BLOCK(ip, nxlen);
 			goto exit;
 		}
@@ -308,6 +326,7 @@ int extRealloc(struct inode *ip, s64 nxl
 		 */
 		if ((rc = xtTailgate(0, ip, xoff, (int) ntail, nxaddr, 0))) {
 			dbFree(ip, nxaddr, nxlen);
+			DLIMIT_FREE_BLOCK(ip, nxlen);
 			DQUOT_FREE_BLOCK(ip, nxlen);
 			goto exit;
 		}
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/jfs_filsys.h linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_filsys.h
--- linux-2.6.20.15/fs/jfs/jfs_filsys.h	2007-02-06 03:01:24 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_filsys.h	2007-02-06 03:05:22 +0100
@@ -264,6 +264,7 @@
 #define JFS_NAME_MAX	255
 #define JFS_PATH_MAX	BPSIZE
 
+#define JFS_TAGGED		0x00800000	/* Context Tagging */
 
 /*
  *	file system state (superblock state)
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/jfs_imap.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_imap.c
--- linux-2.6.20.15/fs/jfs/jfs_imap.c	2007-02-06 03:01:24 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_imap.c	2007-02-06 03:05:22 +0100
@@ -45,6 +45,7 @@
 #include <linux/buffer_head.h>
 #include <linux/pagemap.h>
 #include <linux/quotaops.h>
+#include <linux/vs_tag.h>
 
 #include "jfs_incore.h"
 #include "jfs_inode.h"
@@ -3075,6 +3076,8 @@ static int copy_from_dinode(struct dinod
 {
 	struct jfs_inode_info *jfs_ip = JFS_IP(ip);
 	struct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);
+	uid_t uid;
+	gid_t gid;
 
 	jfs_ip->fileset = le32_to_cpu(dip->di_fileset);
 	jfs_ip->mode2 = le32_to_cpu(dip->di_mode);
@@ -3094,14 +3097,18 @@ static int copy_from_dinode(struct dinod
 	}
 	ip->i_nlink = le32_to_cpu(dip->di_nlink);
 
-	jfs_ip->saved_uid = le32_to_cpu(dip->di_uid);
+	uid = le32_to_cpu(dip->di_uid);
+	gid = le32_to_cpu(dip->di_gid);
+	ip->i_tag = INOTAG_TAG(DX_TAG(ip), uid, gid, 0);
+
+	jfs_ip->saved_uid = INOTAG_UID(DX_TAG(ip), uid, gid);
 	if (sbi->uid == -1)
 		ip->i_uid = jfs_ip->saved_uid;
 	else {
 		ip->i_uid = sbi->uid;
 	}
 
-	jfs_ip->saved_gid = le32_to_cpu(dip->di_gid);
+	jfs_ip->saved_gid = INOTAG_GID(DX_TAG(ip), uid, gid);
 	if (sbi->gid == -1)
 		ip->i_gid = jfs_ip->saved_gid;
 	else {
@@ -3166,14 +3173,12 @@ static void copy_to_dinode(struct dinode
 	dip->di_size = cpu_to_le64(ip->i_size);
 	dip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));
 	dip->di_nlink = cpu_to_le32(ip->i_nlink);
-	if (sbi->uid == -1)
-		dip->di_uid = cpu_to_le32(ip->i_uid);
-	else
-		dip->di_uid = cpu_to_le32(jfs_ip->saved_uid);
-	if (sbi->gid == -1)
-		dip->di_gid = cpu_to_le32(ip->i_gid);
-	else
-		dip->di_gid = cpu_to_le32(jfs_ip->saved_gid);
+
+	dip->di_uid = cpu_to_le32(TAGINO_UID(DX_TAG(ip),
+		(sbi->uid == -1) ? ip->i_uid : jfs_ip->saved_uid, ip->i_tag));
+	dip->di_gid = cpu_to_le32(TAGINO_GID(DX_TAG(ip),
+		(sbi->gid == -1) ? ip->i_gid : jfs_ip->saved_gid, ip->i_tag));
+
 	/*
 	 * mode2 is only needed for storing the higher order bits.
 	 * Trust i_mode for the lower order ones
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/jfs_inode.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_inode.c
--- linux-2.6.20.15/fs/jfs/jfs_inode.c	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_inode.c	2007-02-06 03:05:22 +0100
@@ -18,6 +18,8 @@
 
 #include <linux/fs.h>
 #include <linux/quotaops.h>
+#include <linux/vs_dlimit.h>
+#include <linux/vs_tag.h>
 #include "jfs_incore.h"
 #include "jfs_inode.h"
 #include "jfs_filsys.h"
@@ -30,19 +32,47 @@ void jfs_set_inode_flags(struct inode *i
 {
 	unsigned int flags = JFS_IP(inode)->mode2;
 
-	inode->i_flags &= ~(S_IMMUTABLE | S_APPEND |
-		S_NOATIME | S_DIRSYNC | S_SYNC);
+	inode->i_flags &= ~(S_IMMUTABLE | S_IUNLINK | S_BARRIER |
+		S_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);
 
 	if (flags & JFS_IMMUTABLE_FL)
 		inode->i_flags |= S_IMMUTABLE;
+	if (flags & JFS_IUNLINK_FL)
+		inode->i_flags |= S_IUNLINK;
+	if (flags & JFS_BARRIER_FL)
+		inode->i_flags |= S_BARRIER;
+
+	if (flags & JFS_SYNC_FL)
+		inode->i_flags |= S_SYNC;
 	if (flags & JFS_APPEND_FL)
 		inode->i_flags |= S_APPEND;
 	if (flags & JFS_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
 	if (flags & JFS_DIRSYNC_FL)
 		inode->i_flags |= S_DIRSYNC;
-	if (flags & JFS_SYNC_FL)
-		inode->i_flags |= S_SYNC;
+}
+
+int jfs_sync_flags(struct inode *inode)
+{
+	unsigned int oldflags, newflags;
+
+	oldflags = JFS_IP(inode)->mode2;
+	newflags = oldflags & ~(JFS_IMMUTABLE_FL |
+		JFS_IUNLINK_FL | JFS_BARRIER_FL);
+
+	if (IS_IMMUTABLE(inode))
+		newflags |= JFS_IMMUTABLE_FL;
+	if (IS_IUNLINK(inode))
+		newflags |= JFS_IUNLINK_FL;
+	if (IS_BARRIER(inode))
+		newflags |= JFS_BARRIER_FL;
+
+	if (oldflags ^ newflags) {
+		JFS_IP(inode)->mode2 = newflags;
+		inode->i_ctime = CURRENT_TIME;
+		mark_inode_dirty(inode);
+	}
+	return 0;
 }
 
 /*
@@ -90,10 +120,17 @@ struct inode *ialloc(struct inode *paren
 	jfs_inode->saved_uid = inode->i_uid;
 	jfs_inode->saved_gid = inode->i_gid;
 
+	inode->i_tag = dx_current_fstag(sb);
+	if (DLIMIT_ALLOC_INODE(inode)) {
+		iput(inode);
+		return NULL;
+	}
+
 	/*
 	 * Allocate inode to quota.
 	 */
 	if (DQUOT_ALLOC_INODE(inode)) {
+		DLIMIT_FREE_INODE(inode);
 		DQUOT_DROP(inode);
 		inode->i_flags |= S_NOQUOTA;
 		inode->i_nlink = 0;
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/jfs_inode.h linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_inode.h
--- linux-2.6.20.15/fs/jfs/jfs_inode.h	2006-11-30 21:19:25 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_inode.h	2007-02-06 03:05:22 +0100
@@ -31,6 +31,7 @@ extern void jfs_truncate(struct inode *)
 extern void jfs_truncate_nolock(struct inode *, loff_t);
 extern void jfs_free_zero_link(struct inode *);
 extern struct dentry *jfs_get_parent(struct dentry *dentry);
+extern int jfs_sync_flags(struct inode *);
 extern void jfs_set_inode_flags(struct inode *);
 extern int jfs_get_block(struct inode *, sector_t, struct buffer_head *, int);
 
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/jfs_xtree.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_xtree.c
--- linux-2.6.20.15/fs/jfs/jfs_xtree.c	2006-11-30 21:19:26 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/jfs_xtree.c	2007-02-06 03:05:22 +0100
@@ -21,6 +21,7 @@
 
 #include <linux/fs.h>
 #include <linux/quotaops.h>
+#include <linux/vs_dlimit.h>
 #include "jfs_incore.h"
 #include "jfs_filsys.h"
 #include "jfs_metapage.h"
@@ -841,7 +842,12 @@ int xtInsert(tid_t tid,		/* transaction 
 			hint = 0;
 		if ((rc = DQUOT_ALLOC_BLOCK(ip, xlen)))
 			goto out;
+		if ((rc = DLIMIT_ALLOC_BLOCK(ip, xlen))) {
+			DQUOT_FREE_BLOCK(ip, xlen);
+			goto out;
+		}
 		if ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {
+			DLIMIT_FREE_BLOCK(ip, xlen);
 			DQUOT_FREE_BLOCK(ip, xlen);
 			goto out;
 		}
@@ -871,6 +877,7 @@ int xtInsert(tid_t tid,		/* transaction 
 			/* undo data extent allocation */
 			if (*xaddrp == 0) {
 				dbFree(ip, xaddr, (s64) xlen);
+				DLIMIT_FREE_BLOCK(ip, xlen);
 				DQUOT_FREE_BLOCK(ip, xlen);
 			}
 			return rc;
@@ -1231,6 +1238,7 @@ xtSplitPage(tid_t tid, struct inode *ip,
 	struct tlock *tlck;
 	struct xtlock *sxtlck = NULL, *rxtlck = NULL;
 	int quota_allocation = 0;
+	int dlimit_allocation = 0;
 
 	smp = split->mp;
 	sp = XT_PAGE(ip, smp);
@@ -1250,6 +1258,13 @@ xtSplitPage(tid_t tid, struct inode *ip,
 
 	quota_allocation += lengthPXD(pxd);
 
+	/* Allocate blocks to dlimit. */
+	if (DLIMIT_ALLOC_BLOCK(ip, lengthPXD(pxd))) {
+	       rc = -ENOSPC;
+	       goto clean_up;
+	}
+	dlimit_allocation += lengthPXD(pxd);
+
 	/*
 	 * allocate the new right page for the split
 	 */
@@ -1451,6 +1466,9 @@ xtSplitPage(tid_t tid, struct inode *ip,
 
       clean_up:
 
+	/* Rollback dlimit allocation. */
+	if (dlimit_allocation)
+		DLIMIT_FREE_BLOCK(ip, dlimit_allocation);
 	/* Rollback quota allocation. */
 	if (quota_allocation)
 		DQUOT_FREE_BLOCK(ip, quota_allocation);
@@ -1515,6 +1533,12 @@ xtSplitRoot(tid_t tid,
 		release_metapage(rmp);
 		return -EDQUOT;
 	}
+	/* Allocate blocks to dlimit. */
+	if (DLIMIT_ALLOC_BLOCK(ip, lengthPXD(pxd))) {
+		DQUOT_FREE_BLOCK(ip, lengthPXD(pxd));
+		release_metapage(rmp);
+		return -ENOSPC;
+	}
 
 	jfs_info("xtSplitRoot: ip:0x%p rmp:0x%p", ip, rmp);
 
@@ -3941,6 +3965,8 @@ s64 xtTruncate(tid_t tid, struct inode *
 	else
 		ip->i_size = newsize;
 
+	/* update dlimit allocation to reflect freed blocks */
+	DLIMIT_FREE_BLOCK(ip, nfreed);
 	/* update quota allocation to reflect freed blocks */
 	DQUOT_FREE_BLOCK(ip, nfreed);
 
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/namei.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/namei.c
--- linux-2.6.20.15/fs/jfs/namei.c	2006-11-30 21:19:26 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/namei.c	2007-02-06 03:05:22 +0100
@@ -20,6 +20,7 @@
 #include <linux/fs.h>
 #include <linux/ctype.h>
 #include <linux/quotaops.h>
+#include <linux/vs_tag.h>
 #include "jfs_incore.h"
 #include "jfs_superblock.h"
 #include "jfs_inode.h"
@@ -1461,6 +1462,7 @@ static struct dentry *jfs_lookup(struct 
 		return ERR_PTR(-EACCES);
 	}
 
+	dx_propagate_tag(nd, ip);
 	dentry = d_splice_alias(ip, dentry);
 
 	if (dentry && (JFS_SBI(dip->i_sb)->mntflag & JFS_OS2))
@@ -1513,6 +1515,7 @@ struct inode_operations jfs_dir_inode_op
 	.setattr	= jfs_setattr,
 	.permission	= jfs_permission,
 #endif
+	.sync_flags	= jfs_sync_flags,
 };
 
 const struct file_operations jfs_dir_operations = {
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/super.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/super.c
--- linux-2.6.20.15/fs/jfs/super.c	2007-02-06 03:01:24 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/super.c	2007-02-06 03:05:22 +0100
@@ -194,7 +194,8 @@ static void jfs_put_super(struct super_b
 enum {
 	Opt_integrity, Opt_nointegrity, Opt_iocharset, Opt_resize,
 	Opt_resize_nosize, Opt_errors, Opt_ignore, Opt_err, Opt_quota,
-	Opt_usrquota, Opt_grpquota, Opt_uid, Opt_gid, Opt_umask
+	Opt_usrquota, Opt_grpquota, Opt_uid, Opt_gid, Opt_umask,
+	Opt_tag, Opt_notag, Opt_tagid
 };
 
 static match_table_t tokens = {
@@ -204,6 +205,10 @@ static match_table_t tokens = {
 	{Opt_resize, "resize=%u"},
 	{Opt_resize_nosize, "resize"},
 	{Opt_errors, "errors=%s"},
+	{Opt_tag, "tag"},
+	{Opt_notag, "notag"},
+	{Opt_tagid, "tagid=%u"},
+	{Opt_tag, "tagxid"},
 	{Opt_ignore, "noquota"},
 	{Opt_ignore, "quota"},
 	{Opt_usrquota, "usrquota"},
@@ -338,6 +343,20 @@ static int parse_options(char *options, 
 			}
 			break;
 		}
+#ifndef CONFIG_TAGGING_NONE
+		case Opt_tag:
+			*flag |= JFS_TAGGED;
+			break;
+		case Opt_notag:
+			*flag &= JFS_TAGGED;
+			break;
+#endif
+#ifdef CONFIG_PROPAGATE
+		case Opt_tagid:
+			/* use args[0] */
+			*flag |= JFS_TAGGED;
+			break;
+#endif
 		default:
 			printk("jfs: Unrecognized mount option \"%s\" "
 					" or missing value\n", p);
@@ -368,6 +387,13 @@ static int jfs_remount(struct super_bloc
 	if (!parse_options(data, sb, &newLVSize, &flag)) {
 		return -EINVAL;
 	}
+
+	if ((flag & JFS_TAGGED) && !(sb->s_flags & MS_TAGGED)) {
+		printk(KERN_ERR "JFS: %s: tagging not permitted on remount.\n",
+			sb->s_id);
+		return -EINVAL;
+	}
+
 	if (newLVSize) {
 		if (sb->s_flags & MS_RDONLY) {
 			printk(KERN_ERR
@@ -439,6 +465,9 @@ static int jfs_fill_super(struct super_b
 #ifdef CONFIG_JFS_POSIX_ACL
 	sb->s_flags |= MS_POSIXACL;
 #endif
+	/* map mount option tagxid */
+	if (sbi->flag & JFS_TAGGED)
+		sb->s_flags |= MS_TAGGED;
 
 	if (newLVSize) {
 		printk(KERN_ERR "resize option for remount only\n");
diff -NurpP --minimal linux-2.6.20.15/fs/jfs/xattr.c linux-2.6.20.15-vs2.2.0.1/fs/jfs/xattr.c
--- linux-2.6.20.15/fs/jfs/xattr.c	2006-11-30 21:19:26 +0100
+++ linux-2.6.20.15-vs2.2.0.1/fs/jfs/xattr.c	2007-02-06 03:05:22 +0100
@@ -23,6 +23,7 @@
 #include <linux/posix_acl_xattr.h>
 #include <linux/quotaops.h>
 #include <linux/security.h>
+#include <linux/vs_dlimit.h>
 #include "jfs_incore.h"
 #include "jfs_superblock.h"
 #include "jfs_dmap.h"
@@ -263,9 +264,16 @@ static int ea_write(struct inode *ip, st
 	if (DQUOT_ALLOC_BLOCK(ip, nblocks)) {
 		return -EDQUOT;
 	}
+	/* Allocate new blocks to dlimit. */
+	if (DLIMIT_ALLOC_BLOCK(ip, nblocks)) {
+		DQUOT_FREE_BLOCK(ip, nblocks);
+		return -ENOSPC;
+	}
 
 	rc = dbAlloc(ip, INOHINT(ip), nblocks, &blkno);
 	if (rc) {
+		/*Rollback dlimit allocation. */
+		DLIMIT_FREE_BLOCK(ip, nblocks);
 		/*Rollback quota allocation. */
 		DQUOT_FREE_BLOCK(ip, nblocks);
 		return rc;
@@ -332,6 +340,8 @@ static int ea_write(struct inode *ip, st
 
       failed:
 	/* Rollback quota allocation. */
+	DLIMIT_FREE_BLOCK(ip, nblocks);
+	/* Rollback quota allocation. */
 	DQUOT_FREE_BLOCK(ip, nblocks);
 
 	dbFree(ip, blkno, nblocks);
@@ -468,6 +478,7 @@ static int ea_get(struct inode *inode, s
 	s64 blkno;
 	int rc;
 	int quota_allocation = 0;
+	int dlimit_allocation = 0;
 
 	/* When fsck.jfs clears a bad ea, it doesn't clear the size */
 	if (ji->ea.flag == 0)
@@ -543,6 +554,12 @@ static int ea_get(struct inode *inode, s
 
 		quota_allocation = blocks_needed;
 
+		/* Allocate new blocks to dlimit. */
+		rc = -ENOSPC;
+		if (DLIMIT_ALLOC_BLOCK(inode, blocks_needed))
+			goto clean_up;
+		dlimit_allocation = blocks_needed;
+
 		rc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,
 			     &blkno);
 		if (rc)
@@ -599,6 +616,9 @@ static int ea_get(struct inode *inode, s
 	return ea_size;
 
       clean_up:
+	/* Rollback dlimit allocation */
+	if (dlimit_allocation)
+		DLIMIT_FREE_BLOCK(inode, dlimit_allocation);
 	/* Rollback quota allocation */
 	if (quota